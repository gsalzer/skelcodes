{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/*\r\n                              (           (        )      )          (          \r\n   (     (       *   )  *   ) )\\ )        )\\ )  ( /(   ( /(   (      )\\ )       \r\n ( )\\    )\\    ` )  /(` )  /((()/(  (    (()/(  )\\())  )\\())  )\\    (()/(  (    \r\n )((_)((((_)(   ( )(_))( )(_))/(_)) )\\    /(_))((_)\\  ((_)\\((((_)(   /(_)) )\\   \r\n((_)_  )\\ _ )\\ (_(_())(_(_())(_))  ((_)  (_))    ((_)__ ((_))\\ _ )\\ (_))  ((_)  \r\n | _ ) (_)_\\(_)|_   _||_   _|| |   | __| | _ \\  / _ \\\\ \\ / /(_)_\\(_)| |   | __| \r\n | _ \\  / _ \\    | |    | |  | |__ | _|  |   / | (_) |\\ V /  / _ \\  | |__ | _|  \r\n |___/ /_/ \\_\\   |_|    |_|  |____||___| |_|_\\  \\___/  |_|  /_/ \\_\\ |____||___| \r\n\r\n    Name Book implementation for ETH.TOWN Battle Royale\r\n    https://eth.town/battle\r\n\r\n    ETH.TOWN https://eth.town/\r\n    Â© 2018 ETH.TOWN All rights reserved\r\n*/\r\n\r\ncontract Owned {\r\n    address owner;\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Contract constructor\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n}\r\n\r\ncontract Managed is Owned {\r\n    mapping(address => bool) public isManager;\r\n\r\n    modifier onlyManagers {\r\n        require(msg.sender == owner || isManager[msg.sender], \"Not authorized\");\r\n        _;\r\n    }\r\n\r\n    function setIsManager(address _address, bool _value) external onlyOwner {\r\n        isManager[_address] = _value;\r\n    }\r\n}\r\n\r\ncontract BRNameBook is Managed {\r\n    using SafeMath for uint256;\r\n\r\n    address public feeRecipient = 0xFd6D4265443647C70f8D0D80356F3b22d596DA29; // Mainnet\r\n\r\n    uint256 public registrationFee = 0.1 ether;             // price to register a name\r\n    uint256 public numPlayers;                              // total number of players\r\n    mapping (address => uint256) public playerIdByAddr;     // (addr => pID) returns player id by address\r\n    mapping (bytes32 => uint256) public playerIdByName;     // (name => pID) returns player id by name\r\n    mapping (uint256 => Player) public playerData;          // (pID => data) player data\r\n    mapping (uint256 => mapping (bytes32 => bool)) public playerOwnsName; // (pID => name => bool) whether the player owns the name\r\n    mapping (uint256 => mapping (uint256 => bytes32)) public playerNamesList; // (pID => nameNum => name) list of names a player owns\r\n\r\n    struct Player {\r\n        address addr;\r\n        address loomAddr;\r\n        bytes32 name;\r\n        uint256 lastAffiliate;\r\n        uint256 nameCount;\r\n    }\r\n\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev prevents calls from contracts\r\n     */\r\n    modifier onlyHumans() {\r\n        require(msg.sender == tx.origin, \"Humans only\");\r\n        _;\r\n    }\r\n\r\n    event NameRegistered (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    function nameIsValid(string _nameStr) public view returns(bool) {\r\n        bytes32 _name = _processName(_nameStr);\r\n        return (playerIdByName[_name] == 0);\r\n    }\r\n\r\n    function setRegistrationFee(uint256 _newFee) onlyManagers() external {\r\n        registrationFee = _newFee;\r\n    }\r\n\r\n    function setFeeRecipient(address _feeRecipient) onlyManagers() external {\r\n        feeRecipient = _feeRecipient;\r\n    }\r\n\r\n    /**\r\n     * @dev registers a name.  UI will always display the last name you registered.\r\n     * but you will still own all previously registered names to use as affiliate\r\n     * links.\r\n     * - must pay a registration fee.\r\n     * - name must be unique\r\n     * - names will be converted to lowercase\r\n     * - name cannot start or end with a space\r\n     * - cannot have more than 1 space in a row\r\n     * - cannot be only numbers\r\n     * - cannot start with 0x\r\n     * - name must be at least 1 char\r\n     * - max length of 32 characters long\r\n     * - allowed characters: a-z, 0-9, and space\r\n     * -functionhash- 0x921dec21 (using ID for affiliate)\r\n     * -functionhash- 0x3ddd4698 (using address for affiliate)\r\n     * -functionhash- 0x685ffd83 (using name for affiliate)\r\n     * @param _nameString players desired name\r\n     * @param _affCode affiliate ID, address, or name of who refered you\r\n     * (this might cost a lot of gas)\r\n     */\r\n    function registerNameAffId(string _nameString, uint256 _affCode) onlyHumans() external payable {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee, \"Value below the fee\");\r\n\r\n        // filter name + condition checks\r\n        bytes32 name = _processName(_nameString);\r\n\r\n        // set up address\r\n        address addr = msg.sender;\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool isNewPlayer = _determinePlayerId(addr);\r\n\r\n        // fetch player id\r\n        uint256 playerId = playerIdByAddr[addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the\r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        uint256 affiliateId = _affCode;\r\n        if (affiliateId != 0 && affiliateId != playerData[playerId].lastAffiliate && affiliateId != playerId) {\r\n            // update last affiliate\r\n            playerData[playerId].lastAffiliate = affiliateId;\r\n        } else if (_affCode == playerId) {\r\n            affiliateId = 0;\r\n        }\r\n\r\n        // register name\r\n        _registerName(playerId, addr, affiliateId, name, isNewPlayer);\r\n    }\r\n\r\n    function registerNameAffAddress(string _nameString, address _affCode) onlyHumans() external payable {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee, \"Value below the fee\");\r\n\r\n        // filter name + condition checks\r\n        bytes32 name = _processName(_nameString);\r\n\r\n        // set up address\r\n        address addr = msg.sender;\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool isNewPlayer = _determinePlayerId(addr);\r\n\r\n        // fetch player id\r\n        uint256 playerId = playerIdByAddr[addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 affiliateId;\r\n        if (_affCode != address(0) && _affCode != addr) {\r\n            // get affiliate ID from aff Code\r\n            affiliateId = playerIdByAddr[_affCode];\r\n\r\n            // if affID is not the same as previously stored\r\n            if (affiliateId != playerData[playerId].lastAffiliate) {\r\n                // update last affiliate\r\n                playerData[playerId].lastAffiliate = affiliateId;\r\n            }\r\n        }\r\n\r\n        // register name\r\n        _registerName(playerId, addr, affiliateId, name, isNewPlayer);\r\n    }\r\n\r\n    function registerNameAffName(string _nameString, bytes32 _affCode) onlyHumans() public payable {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee, \"Value below the fee\");\r\n\r\n        // filter name + condition checks\r\n        bytes32 name = _processName(_nameString);\r\n\r\n        // set up address\r\n        address addr = msg.sender;\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool isNewPlayer = _determinePlayerId(addr);\r\n\r\n        // fetch player id\r\n        uint256 playerId = playerIdByAddr[addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 affiliateId;\r\n        if (_affCode != \"\" && _affCode != name) {\r\n            // get affiliate ID from aff Code\r\n            affiliateId = playerIdByName[_affCode];\r\n\r\n            // if affID is not the same as previously stored\r\n            if (affiliateId != playerData[playerId].lastAffiliate) {\r\n                // update last affiliate\r\n                playerData[playerId].lastAffiliate = affiliateId;\r\n            }\r\n        }\r\n\r\n        // register the name\r\n        _registerName(playerId, addr, affiliateId, name, isNewPlayer);\r\n    }\r\n\r\n    /**\r\n     * @dev players use this to change back to one of your old names.  tip, you'll\r\n     * still need to push that info to existing games.\r\n     * -functionhash- 0xb9291296\r\n     * @param _nameString the name you want to use\r\n     */\r\n    function useMyOldName(string _nameString) onlyHumans() public {\r\n        // filter name, and get pID\r\n        bytes32 name = _processName(_nameString);\r\n        uint256 playerId = playerIdByAddr[msg.sender];\r\n\r\n        // make sure they own the name\r\n        require(playerOwnsName[playerId][name] == true, \"Not your name\");\r\n\r\n        // update their current name\r\n        playerData[playerId].name = name;\r\n    }\r\n\r\n\r\n    function _registerName(uint256 _playerId, address _addr, uint256 _affID, bytes32 _name, bool _isNewPlayer) internal {\r\n        // if names already has been used, require that current msg sender owns the name\r\n        if (playerIdByName[_name] != 0) {\r\n            require(playerOwnsName[_playerId][_name] == true, \"Name already taken\");\r\n        }\r\n\r\n        // add name to player profile, registry, and name book\r\n        playerData[_playerId].name = _name;\r\n        playerIdByName[_name] = _playerId;\r\n        if (playerOwnsName[_playerId][_name] == false) {\r\n            playerOwnsName[_playerId][_name] = true;\r\n            playerData[_playerId].nameCount++;\r\n            playerNamesList[_playerId][playerData[_playerId].nameCount] = _name;\r\n        }\r\n\r\n        // process the registration fee\r\n        uint256 total = address(this).balance;\r\n        uint256 devDirect = total.mul(375).div(1000);\r\n        owner.call.value(devDirect)();\r\n        feeRecipient.call.value(total.sub(devDirect))();\r\n\r\n        // fire event\r\n        emit NameRegistered(_playerId, _addr, _name, _isNewPlayer, _affID, playerData[_affID].addr, playerData[_affID].name, msg.value, now);\r\n    }\r\n\r\n    function _determinePlayerId(address _addr) internal returns (bool) {\r\n        if (playerIdByAddr[_addr] == 0)\r\n        {\r\n            numPlayers++;\r\n            playerIdByAddr[_addr] = numPlayers;\r\n            playerData[numPlayers].addr = _addr;\r\n\r\n            // set the new player bool to true\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function _processName(string _input) internal pure returns (bytes32) {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n\r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n\r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n\r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n\r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                // require character is a space\r\n                    _temp[i] == 0x20 ||\r\n                // OR lowercase a-z\r\n                (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                // or 0-9\r\n                (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n\r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;\r\n            }\r\n        }\r\n\r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n\r\n    function registerNameAffIdExternal(address _addr, bytes32 _name, uint256 _affCode)\r\n    onlyManagers()\r\n    external\r\n    payable\r\n    returns (bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee, \"Value below the fee\");\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool isNewPlayer = _determinePlayerId(_addr);\r\n\r\n        // fetch player id\r\n        uint256 playerId = playerIdByAddr[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the\r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        uint256 affiliateId = _affCode;\r\n        if (affiliateId != 0 && affiliateId != playerData[playerId].lastAffiliate && affiliateId != playerId) {\r\n            // update last affiliate\r\n            playerData[playerId].lastAffiliate = affiliateId;\r\n        } else if (affiliateId == playerId) {\r\n            affiliateId = 0;\r\n        }\r\n\r\n        // register name\r\n        _registerName(playerId, _addr, affiliateId, _name, isNewPlayer);\r\n\r\n        return (isNewPlayer, affiliateId);\r\n    }\r\n\r\n    function registerNameAffAddressExternal(address _addr, bytes32 _name, address _affCode)\r\n    onlyManagers()\r\n    external\r\n    payable\r\n    returns (bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee, \"Value below the fee\");\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool isNewPlayer = _determinePlayerId(_addr);\r\n\r\n        // fetch player id\r\n        uint256 playerId = playerIdByAddr[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 affiliateId;\r\n        if (_affCode != address(0) && _affCode != _addr)\r\n        {\r\n            // get affiliate ID from aff Code\r\n            affiliateId = playerIdByAddr[_affCode];\r\n\r\n            // if affID is not the same as previously stored\r\n            if (affiliateId != playerData[playerId].lastAffiliate) {\r\n                // update last affiliate\r\n                playerData[playerId].lastAffiliate = affiliateId;\r\n            }\r\n        }\r\n\r\n        // register name\r\n        _registerName(playerId, _addr, affiliateId, _name, isNewPlayer);\r\n\r\n        return (isNewPlayer, affiliateId);\r\n    }\r\n\r\n    function registerNameAffNameExternal(address _addr, bytes32 _name, bytes32 _affCode)\r\n    onlyManagers()\r\n    external\r\n    payable\r\n    returns (bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require (msg.value >= registrationFee, \"Value below the fee\");\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool isNewPlayer = _determinePlayerId(_addr);\r\n\r\n        // fetch player id\r\n        uint256 playerId = playerIdByAddr[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 affiliateId;\r\n        if (_affCode != \"\" && _affCode != _name)\r\n        {\r\n            // get affiliate ID from aff Code\r\n            affiliateId = playerIdByName[_affCode];\r\n\r\n            // if affID is not the same as previously stored\r\n            if (affiliateId != playerData[playerId].lastAffiliate) {\r\n                // update last affiliate\r\n                playerData[playerId].lastAffiliate = affiliateId;\r\n            }\r\n        }\r\n\r\n        // register name\r\n        _registerName(playerId, _addr, affiliateId, _name, isNewPlayer);\r\n\r\n        return (isNewPlayer, affiliateId);\r\n    }\r\n\r\n    function assignPlayerID(address _addr) onlyManagers() external returns (uint256) {\r\n        _determinePlayerId(_addr);\r\n        return playerIdByAddr[_addr];\r\n    }\r\n\r\n    function getPlayerID(address _addr) public view returns (uint256) {\r\n        return playerIdByAddr[_addr];\r\n    }\r\n\r\n    function getPlayerName(uint256 _pID) public view returns (bytes32) {\r\n        return playerData[_pID].name;\r\n    }\r\n\r\n    function getPlayerNameCount(uint256 _pID) public view returns (uint256) {\r\n        return playerData[_pID].nameCount;\r\n    }\r\n\r\n    function getPlayerLastAffiliate(uint256 _pID) public view returns (uint256) {\r\n        return playerData[_pID].lastAffiliate;\r\n    }\r\n\r\n    function getPlayerAddr(uint256 _pID) public view returns (address) {\r\n        return playerData[_pID].addr;\r\n    }\r\n\r\n    function getPlayerLoomAddr(uint256 _pID) public view returns (address) {\r\n        return playerData[_pID].loomAddr;\r\n    }\r\n\r\n    function getPlayerLoomAddrByAddr(address _addr) public view returns (address) {\r\n        uint256 playerId = playerIdByAddr[_addr];\r\n        if (playerId == 0) {\r\n            return 0;\r\n        }\r\n\r\n        return playerData[playerId].loomAddr;\r\n    }\r\n\r\n    function getPlayerNames(uint256 _pID) public view returns (bytes32[]) {\r\n        uint256 nameCount = playerData[_pID].nameCount;\r\n\r\n        bytes32[] memory names = new bytes32[](nameCount);\r\n\r\n        uint256 i;\r\n        for (i = 1; i <= nameCount; i++) {\r\n            names[i - 1] = playerNamesList[_pID][i];\r\n        }\r\n\r\n        return names;\r\n    }\r\n\r\n    function setPlayerLoomAddr(uint256 _pID, address _addr, bool _allowOverwrite) onlyManagers() external {\r\n        require(_allowOverwrite || playerData[_pID].loomAddr == 0x0);\r\n\r\n        playerData[_pID].loomAddr = _addr;\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers, never throws.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x) internal pure returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x) internal pure returns (uint256)\r\n    {\r\n        return mul(x,x);\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y) internal pure returns (uint256)\r\n    {\r\n        if (x==0) {\r\n            return 0;\r\n        } else if (y==0) {\r\n            return 1;\r\n        } else {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return z;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerLastAffiliate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerData\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"loomAddr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"lastAffiliate\",\"type\":\"uint256\"},{\"name\":\"nameCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"}],\"name\":\"registerNameAffId\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerIdByAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"}],\"name\":\"registerNameAffAddress\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"}],\"name\":\"registerNameAffNameExternal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"setIsManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_allowOverwrite\",\"type\":\"bool\"}],\"name\":\"setPlayerLoomAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeRecipient\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nameStr\",\"type\":\"string\"}],\"name\":\"nameIsValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"address\"}],\"name\":\"registerNameAffAddressExternal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerLoomAddrByAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerLoomAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"}],\"name\":\"registerNameAffName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numPlayers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"useMyOldName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"uint256\"}],\"name\":\"registerNameAffIdExternal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newFee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"assignPlayerID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerNames\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerNameCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeRecipient\",\"type\":\"address\"}],\"name\":\"setFeeRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"playerIdByName\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerNamesList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"playerOwnsName\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"NameRegistered\",\"type\":\"event\"}]","ContractName":"BRNameBook","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4889eb06d16b00d7f8fa1fc214db3fe5b28b0c71c5368fd0ae2aa17510a283c8"}]}