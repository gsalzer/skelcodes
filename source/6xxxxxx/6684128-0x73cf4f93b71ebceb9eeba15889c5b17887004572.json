{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Labyrinth {\r\n    \r\n    uint entropy;\r\n    \r\n    function generateRandomNumber() external returns (uint) {\r\n        \r\n        bytes memory randomNumber = new bytes(32);\r\n        bytes memory treasureMapInBytes = toBytes(entropy);\r\n        uint8 nextByteInTreasureMap = uint8(treasureMapInBytes[31]);\r\n        uint8 pointerToNextPosition = nextByteInTreasureMap;\r\n        for(uint i = 31; i >0; i--) {\r\n            uint nextHashInLabyrinth = uint(blockhash(block.number - 1 - pointerToNextPosition));\r\n            bytes memory blockHashToBytes = toBytes(nextHashInLabyrinth);\r\n            uint8 byteFromBlockhash = uint8(blockHashToBytes[i]);\r\n            nextByteInTreasureMap = uint8(treasureMapInBytes[i]);\r\n            uint8 nextRandomNumber = nextByteInTreasureMap ^ byteFromBlockhash;\r\n            randomNumber[i] = bytes1(nextRandomNumber);\r\n            pointerToNextPosition = nextRandomNumber;\r\n        }\r\n        entropy = toUint(randomNumber);\r\n        return entropy;\r\n    }\r\n    function toBytes(uint256 x) pure internal returns (bytes b) {\r\n        b = new bytes(32);\r\n        assembly { mstore(add(b, 32), x) }\r\n    }\r\n    function toUint(bytes x) pure internal returns (uint b) {\r\n        assembly {\r\n            b := mload(add(x, 0x20))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"generateRandomNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Labyrinth","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://576721c26450fab260ccb3cca6cf684c5e08eb5709e8f23364eb7e5e54a2ba63"}]}