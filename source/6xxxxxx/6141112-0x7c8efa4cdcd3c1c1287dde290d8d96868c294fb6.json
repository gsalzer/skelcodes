{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\tfunction mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\t\tif (_a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tuint256 c = _a * _b;\r\n\t\tassert(c / _a == _b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\t\treturn _a / _b;\r\n\t}\r\n\r\n\tfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\t\tassert(_b <= _a);\r\n\t\treturn _a - _b;\r\n\t}\r\n\r\n\tfunction add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\t\tuint256 c = _a + _b;\r\n\t\tassert(c >= _a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract holds owner addresses, and provides basic authorization control\r\n * functions.\r\n */\r\ncontract Ownable {\r\n\t/**\r\n\t* @dev Allows to check if the given address has owner rights.\r\n\t* @param _owner The address to check for owner rights.\r\n\t* @return True if the address is owner, false if it is not.\r\n\t*/\r\n\tmapping(address => bool) public owners;\r\n\t\r\n\t/**\r\n\t* @dev The Ownable constructor adds the sender\r\n\t* account to the owners mapping.\r\n\t*/\r\n\tconstructor() public {\r\n\t\towners[msg.sender] = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if called by any account other than the owner.\r\n\t*/\r\n\tmodifier onlyOwners() {\r\n\t\trequire(owners[msg.sender], 'Owner message sender required.');\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Allows the current owners to grant or revoke \r\n\t* owner-level access rights to the contract.\r\n\t* @param _owner The address to grant or revoke owner rights.\r\n\t* @param _isAllowed Boolean granting or revoking owner rights.\r\n\t* @return True if the operation has passed or throws if failed.\r\n\t*/\r\n\tfunction setOwner(address _owner, bool _isAllowed) public onlyOwners {\r\n\t\trequire(_owner != address(0), 'Non-zero owner-address required.');\r\n\t\towners[_owner] = _isAllowed;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Destroyable\r\n * @dev Base contract that can be destroyed by the owners. All funds in contract will be sent back.\r\n */\r\ncontract Destroyable is Ownable {\r\n\r\n\tconstructor() public payable {}\r\n\r\n\t/**\r\n\t* @dev Transfers The current balance to the message sender and terminates the contract.\r\n\t*/\r\n\tfunction destroy() public onlyOwners {\r\n\t\tselfdestruct(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfers The current balance to the specified _recipient and terminates the contract.\r\n\t* @param _recipient The address to send the current balance to.\r\n\t*/\r\n\tfunction destroyAndSend(address _recipient) public onlyOwners {\r\n\t\trequire(_recipient != address(0), 'Non-zero recipient address required.');\r\n\t\tselfdestruct(_recipient);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title BotOperated\r\n * @dev The BotOperated contract holds bot addresses, and provides basic authorization control\r\n * functions.\r\n */\r\ncontract BotOperated is Ownable {\r\n\t/**\r\n\t* @dev Allows to check if the given address has bot rights.\r\n\t* @param _bot The address to check for bot rights.\r\n\t* @return True if the address is bot, false if it is not.\r\n\t*/\r\n\tmapping(address => bool) public bots;\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than bot or owner.\r\n\t */\r\n\tmodifier onlyBotsOrOwners() {\r\n\t\trequire(bots[msg.sender] || owners[msg.sender], 'Bot or owner message sender required.');\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Throws if called by any account other than the bot.\r\n\t*/\r\n\tmodifier onlyBots() {\r\n\t\trequire(bots[msg.sender], 'Bot message sender required.');\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev The BotOperated constructor adds the sender\r\n\t* account to the bots mapping.\r\n\t*/\r\n\tconstructor() public {\r\n\t\tbots[msg.sender] = true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Allows the current owners to grant or revoke \r\n\t* bot-level access rights to the contract.\r\n\t* @param _bot The address to grant or revoke bot rights.\r\n\t* @param _isAllowed Boolean granting or revoking bot rights.\r\n\t* @return True if the operation has passed or throws if failed.\r\n\t*/\r\n\tfunction setBot(address _bot, bool _isAllowed) public onlyOwners {\r\n\t\trequire(_bot != address(0), 'Non-zero bot-address required.');\r\n\t\tbots[_bot] = _isAllowed;\r\n\t}\r\n}\r\n\r\n/**\r\n* @title Pausable\r\n* @dev Base contract which allows children to implement an emergency stop mechanism.\r\n*/\r\ncontract Pausable is BotOperated {\r\n\tevent Pause();\r\n\tevent Unpause();\r\n\r\n\tbool public paused = true;\r\n\r\n\t/**\r\n\t* @dev Modifier to allow actions only when the contract IS NOT paused.\r\n\t*/\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!paused, 'Unpaused contract required.');\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Called by the owner to pause, triggers stopped state.\r\n\t* @return True if the operation has passed.\r\n\t*/\r\n\tfunction pause() public onlyBotsOrOwners {\r\n\t\tpaused = true;\r\n\t\temit Pause();\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Called by the owner to unpause, returns to normal state.\r\n\t* @return True if the operation has passed.\r\n\t*/\r\n\tfunction unpause() public onlyBotsOrOwners {\r\n\t\tpaused = false;\r\n\t\temit Unpause();\r\n\t}\r\n}\r\n\r\ninterface EternalDataStorage {\r\n\tfunction balances(address _owner) external view returns (uint256);\r\n\r\n\tfunction setBalance(address _owner, uint256 _value) external;\r\n\r\n\tfunction allowed(address _owner, address _spender) external view returns (uint256);\r\n\r\n\tfunction setAllowance(address _owner, address _spender, uint256 _amount) external;\r\n\r\n\tfunction totalSupply() external view returns (uint256);\r\n\r\n\tfunction setTotalSupply(uint256 _value) external;\r\n\r\n\tfunction frozenAccounts(address _target) external view returns (bool isFrozen);\r\n\r\n\tfunction setFrozenAccount(address _target, bool _isFrozen) external;\r\n\r\n\tfunction increaseAllowance(address _owner,  address _spender, uint256 _increase) external;\r\n\r\n\tfunction decreaseAllowance(address _owner,  address _spender, uint256 _decrease) external;\r\n}\r\n\r\ninterface Ledger {\r\n\tfunction addTransaction(address _from, address _to, uint _tokens) external;\r\n}\r\n\r\ninterface WhitelistData {\r\n\tfunction kycId(address _customer) external view returns (bytes32);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Standard token\r\n * @dev Implementation of the basic standard token.\r\n * @notice https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n */\r\ncontract ERC20Standard {\r\n\t\r\n\tusing SafeMath for uint256;\r\n\r\n\tEternalDataStorage internal dataStorage;\r\n\r\n\tLedger internal ledger;\r\n\r\n\tWhitelistData internal whitelist;\r\n\r\n\t/**\r\n\t * @dev Triggered when tokens are transferred.\r\n\t * @notice MUST trigger when tokens are transferred, including zero value transfers.\r\n\t */\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n\t/**\r\n\t * @dev Triggered whenever approve(address _spender, uint256 _value) is called.\r\n\t * @notice MUST trigger on any successful call to approve(address _spender, uint256 _value).\r\n\t */\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n\tmodifier isWhitelisted(address _customer) {\r\n\t\trequire(whitelist.kycId(_customer) != 0x0, 'Whitelisted customer required.');\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Constructor function that instantiates the EternalDataStorage, Ledger and Whitelist contracts.\r\n\t * @param _dataStorage Address of the Data Storage Contract.\r\n\t * @param _ledger Address of the Ledger Contract.\r\n\t * @param _whitelist Address of the Whitelist Data Contract.\r\n\t */\r\n\tconstructor(address _dataStorage, address _ledger, address _whitelist) public {\r\n\t\trequire(_dataStorage != address(0), 'Non-zero data storage address required.');\r\n\t\trequire(_ledger != address(0), 'Non-zero ledger address required.');\r\n\t\trequire(_whitelist != address(0), 'Non-zero whitelist address required.');\r\n\r\n\t\tdataStorage = EternalDataStorage(_dataStorage);\r\n\t\tledger = Ledger(_ledger);\r\n\t\twhitelist = WhitelistData(_whitelist);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Gets the total supply of tokens.\r\n\t * @return totalSupplyAmount The total amount of tokens.\r\n\t */\r\n\tfunction totalSupply() public view returns (uint256 totalSupplyAmount) {\r\n\t\treturn dataStorage.totalSupply();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Get the balance of the specified `_owner` address.\r\n\t * @return balance The token balance of the given address.\r\n\t */\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn dataStorage.balances(_owner);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer token to a specified address.\r\n\t * @param _to The address to transfer to.\r\n\t * @param _value The amount to be transferred.\r\n\t * @return success True if the transfer was successful, or throws.\r\n\t */\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success) {\r\n\t\treturn _transfer(msg.sender, _to, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Transfer `_value` tokens to `_to` in behalf of `_from`.\r\n\t * @param _from The address of the sender.\r\n\t * @param _to The address of the recipient.\r\n\t * @param _value The amount to send.\r\n\t * @return success True if the transfer was successful, or throws.\r\n\t */    \r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n\t\tuint256 allowed = dataStorage.allowed(_from, msg.sender);\r\n\t\trequire(allowed >= _value, 'From account has insufficient balance');\r\n\r\n\t\tallowed = allowed.sub(_value);\r\n\t\tdataStorage.setAllowance(_from, msg.sender, allowed);\r\n\r\n\t\treturn _transfer(_from, _to, _value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows `_spender` to withdraw from your account multiple times, up to the `_value` amount.\r\n\t * approve will revert if allowance of _spender is 0. increaseApproval and decreaseApproval should\r\n\t * be used instead to avoid exploit identified here: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\r\n\t * @notice If this function is called again it overwrites the current allowance with `_value`.\r\n\t * @param _spender The address authorized to spend.\r\n\t * @param _value The max amount they can spend.\r\n\t * @return success True if the operation was successful, or false.\r\n\t */\r\n\t \r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success) {\r\n\t\trequire\r\n\t\t(\r\n\t\t\t_value == 0 || dataStorage.allowed(msg.sender, _spender) == 0,\r\n\t\t\t'Approve value is required to be zero or account has already been approved.'\r\n\t\t);\r\n\t\t\r\n\t\tdataStorage.setAllowance(msg.sender, _spender, _value);\r\n\t\t\r\n\t\temit Approval(msg.sender, _spender, _value);\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n\t * This function must be called for increasing approval from a non-zero value\r\n\t * as using approve will revert. It has been added as a fix to the exploit mentioned\r\n\t * here: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _addedValue The amount of tokens to increase the allowance by.\r\n\t */\r\n\tfunction increaseApproval(address _spender, uint256 _addedValue) public {\r\n\t\tdataStorage.increaseAllowance(msg.sender, _spender, _addedValue);\r\n\t\t\r\n\t\temit Approval(msg.sender, _spender, dataStorage.allowed(msg.sender, _spender));\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n\t * This function must be called for decreasing approval from a non-zero value\r\n\t * as using approve will revert. It has been added as a fix to the exploit mentioned\r\n\t * here: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md#approve\r\n\t * allowed value is better to use this function to avoid 2 calls (and wait until\r\n\t * the first transaction is mined)\r\n\t * @param _spender The address which will spend the funds.\r\n\t * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n\t */\r\n\tfunction decreaseApproval(address _spender, uint256 _subtractedValue) public {\t\t\r\n\t\tdataStorage.decreaseAllowance(msg.sender, _spender, _subtractedValue);\r\n\t\t\r\n\t\temit Approval(msg.sender, _spender, dataStorage.allowed(msg.sender, _spender));\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n\t* @param _owner The address which owns the funds.\r\n\t* @param _spender The address which will spend the funds.\r\n\t* @return A uint256 specifying the amount of tokens still available for the spender.\r\n\t*/\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\r\n\t\treturn dataStorage.allowed(_owner, _spender);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Internal transfer, can only be called by this contract.\r\n\t * @param _from The address of the sender.\r\n\t * @param _to The address of the recipient.\r\n\t * @param _value The amount to send.\r\n\t * @return success True if the transfer was successful, or throws.\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n\t\trequire(_to != address(0), 'Non-zero to-address required.');\r\n\t\tuint256 fromBalance = dataStorage.balances(_from);\r\n\t\trequire(fromBalance >= _value, 'From-address has insufficient balance.');\r\n\r\n\t\tfromBalance = fromBalance.sub(_value);\r\n\r\n\t\tuint256 toBalance = dataStorage.balances(_to);\r\n\t\ttoBalance = toBalance.add(_value);\r\n\r\n\t\tdataStorage.setBalance(_from, fromBalance);\r\n\t\tdataStorage.setBalance(_to, toBalance);\r\n\r\n\t\tledger.addTransaction(_from, _to, _value);\r\n\r\n\t\temit Transfer(_from, _to, _value);\r\n\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title MintableToken\r\n * @dev ERC20Standard modified with mintable token creation.\r\n */\r\ncontract MintableToken is ERC20Standard, Ownable {\r\n\r\n\t/**\r\n\t * @dev Hardcap - maximum allowed amount of tokens to be minted\r\n\t */\r\n\tuint104 public constant MINTING_HARDCAP = 1e30;\r\n\r\n\t/**\r\n\t* @dev Auto-generated function to check whether the minting has finished.\r\n\t* @return True if the minting has finished, or false.\r\n\t*/\r\n\tbool public mintingFinished = false;\r\n\r\n\tevent Mint(address indexed _to, uint256 _amount);\r\n\t\r\n\tevent MintFinished();\r\n\r\n\tmodifier canMint() {\r\n\t\trequire(!mintingFinished, 'Uninished minting required.');\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function to mint tokens\r\n\t* @param _to The address that will receive the minted tokens.\r\n\t* @param _amount The amount of tokens to mint.\r\n\t*/\r\n\tfunction mint(address _to, uint256 _amount) public onlyOwners canMint() {\r\n\t\tuint256 totalSupply = dataStorage.totalSupply();\r\n\t\ttotalSupply = totalSupply.add(_amount);\r\n\t\t\r\n\t\trequire(totalSupply <= MINTING_HARDCAP, 'Total supply of token in circulation must be below hardcap.');\r\n\t\t\r\n\t\tdataStorage.setTotalSupply(totalSupply);\r\n\r\n\t\tuint256 toBalance = dataStorage.balances(_to);\r\n\t\ttoBalance = toBalance.add(_amount);\r\n\t\tdataStorage.setBalance(_to, toBalance);\r\n\r\n\t\tledger.addTransaction(address(0), _to, _amount);\r\n\r\n\t\temit Transfer(address(0), _to, _amount);\r\n\r\n\t\temit Mint(_to, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function to permanently stop minting new tokens.\r\n\t*/\r\n\tfunction finishMinting() public onlyOwners {\r\n\t\tmintingFinished = true;\r\n\t\temit MintFinished();\r\n\t}\r\n}\r\n\r\n/**\r\n * @title BurnableToken\r\n * @dev ERC20Standard token that can be irreversibly burned(destroyed).\r\n */\r\ncontract BurnableToken is ERC20Standard {\r\n\r\n\tevent Burn(address indexed _burner, uint256 _value);\r\n\t\r\n\t/**\r\n\t * @dev Remove tokens from the system irreversibly.\r\n\t * @notice Destroy tokens from your account.\r\n\t * @param _value The amount of tokens to burn.\r\n\t */\r\n\tfunction burn(uint256 _value) public {\r\n\t\tuint256 senderBalance = dataStorage.balances(msg.sender);\r\n\t\trequire(senderBalance >= _value, 'Burn value less than account balance required.');\r\n\t\tsenderBalance = senderBalance.sub(_value);\r\n\t\tdataStorage.setBalance(msg.sender, senderBalance);\r\n\r\n\t\tuint256 totalSupply = dataStorage.totalSupply();\r\n\t\ttotalSupply = totalSupply.sub(_value);\r\n\t\tdataStorage.setTotalSupply(totalSupply);\r\n\r\n\t\temit Burn(msg.sender, _value);\r\n\r\n\t\temit Transfer(msg.sender, address(0), _value);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Remove specified `_value` tokens from the system irreversibly on behalf of `_from`.\r\n\t * @param _from The address from which to burn tokens.\r\n\t * @param _value The amount of money to burn.\r\n\t */\r\n\tfunction burnFrom(address _from, uint256 _value) public {\r\n\t\tuint256 fromBalance = dataStorage.balances(_from);\r\n\t\trequire(fromBalance >= _value, 'Burn value less than from-account balance required.');\r\n\r\n\t\tuint256 allowed = dataStorage.allowed(_from, msg.sender);\r\n\t\trequire(allowed >= _value, 'Burn value less than account allowance required.');\r\n\r\n\t\tfromBalance = fromBalance.sub(_value);\r\n\t\tdataStorage.setBalance(_from, fromBalance);\r\n\r\n\t\tallowed = allowed.sub(_value);\r\n\t\tdataStorage.setAllowance(_from, msg.sender, allowed);\r\n\r\n\t\tuint256 totalSupply = dataStorage.totalSupply();\r\n\t\ttotalSupply = totalSupply.sub(_value);\r\n\t\tdataStorage.setTotalSupply(totalSupply);\r\n\r\n\t\temit Burn(_from, _value);\r\n\r\n\t\temit Transfer(_from, address(0), _value);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title PausableToken\r\n * @dev ERC20Standard modified with pausable transfers.\r\n **/\r\ncontract PausableToken is ERC20Standard, Pausable {\r\n\t\r\n\tfunction transfer(address _to, uint256 _value) public whenNotPaused returns (bool success) {\r\n\t\treturn super.transfer(_to, _value);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success) {\r\n\t\treturn super.transferFrom(_from, _to, _value);\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _value) public whenNotPaused returns (bool success) {\r\n\t\treturn super.approve(_spender, _value);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title FreezableToken\r\n * @dev ERC20Standard modified with freezing accounts ability.\r\n */\r\ncontract FreezableToken is ERC20Standard, Ownable {\r\n\r\n\tevent FrozenFunds(address indexed _target, bool _isFrozen);\r\n\r\n\t/**\r\n\t * @dev Allow or prevent target address from sending & receiving tokens.\r\n\t * @param _target Address to be frozen or unfrozen.\r\n\t * @param _isFrozen Boolean indicating freeze or unfreeze operation.\r\n\t */ \r\n\tfunction freezeAccount(address _target, bool _isFrozen) public onlyOwners {\r\n\t\trequire(_target != address(0), 'Non-zero to-be-frozen-account address required.');\r\n\t\tdataStorage.setFrozenAccount(_target, _isFrozen);\r\n\t\temit FrozenFunds(_target, _isFrozen);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks whether the target is frozen or not.\r\n\t * @param _target Address to check.\r\n\t * @return isFrozen A boolean that indicates whether the account is frozen or not. \r\n\t */\r\n\tfunction isAccountFrozen(address _target) public view returns (bool isFrozen) {\r\n\t\treturn dataStorage.frozenAccounts(_target);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Overrided _transfer function that uses freeze functionality\r\n\t */\r\n\tfunction _transfer(address _from, address _to, uint256 _value) internal returns (bool success) {\r\n\t\tassert(!dataStorage.frozenAccounts(_from));\r\n\r\n\t\tassert(!dataStorage.frozenAccounts(_to));\r\n\t\t\r\n\t\treturn super._transfer(_from, _to, _value);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title ERC20Extended\r\n * @dev Standard ERC20 token with extended functionalities.\r\n */\r\ncontract ERC20Extended is FreezableToken, PausableToken, BurnableToken, MintableToken, Destroyable {\r\n\t/**\r\n\t* @dev Auto-generated function that returns the name of the token.\r\n\t* @return The name of the token.\r\n\t*/\r\n\tstring public constant name = 'ORBISE10';\r\n\r\n\t/**\r\n\t* @dev Auto-generated function that returns the symbol of the token.\r\n\t* @return The symbol of the token.\r\n\t*/\r\n\tstring public constant symbol = 'ORBT';\r\n\r\n\t/**\r\n\t* @dev Auto-generated function that returns the number of decimals of the token.\r\n\t* @return The number of decimals of the token.\r\n\t*/\r\n\tuint8 public constant decimals = 18;\r\n\r\n\t/**\r\n\t* @dev Constant for the minimum allowed amount of tokens one can buy\r\n\t*/\r\n\tuint72 public constant MINIMUM_BUY_AMOUNT = 200e18;\r\n\r\n\t/**\r\n\t* @dev Auto-generated function that gets the price at which the token is sold.\r\n\t* @return The sell price of the token.\r\n\t*/\r\n\tuint256 public sellPrice;\r\n\r\n\t/**\r\n\t* @dev Auto-generated function that gets the price at which the token is bought.\r\n\t* @return The buy price of the token.\r\n\t*/\r\n\tuint256 public buyPrice;\r\n\r\n\t/**\r\n\t* @dev Auto-generated function that gets the address of the wallet of the contract.\r\n\t* @return The address of the wallet.\r\n\t*/\r\n\taddress public wallet;\r\n\r\n\t/**\r\n\t* @dev Constructor function that calculates the total supply of tokens, \r\n\t* sets the initial sell and buy prices and\r\n\t* passes arguments to base constructors.\r\n\t* @param _dataStorage Address of the Data Storage Contract.\r\n\t* @param _ledger Address of the Data Storage Contract.\r\n\t* @param _whitelist Address of the Whitelist Data Contract.\r\n\t*/\r\n\tconstructor\r\n\t(\r\n\t\taddress _dataStorage,\r\n\t\taddress _ledger,\r\n\t\taddress _whitelist\r\n\t)\r\n\t\tERC20Standard(_dataStorage, _ledger, _whitelist)\r\n\t\tpublic \r\n\t{\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Fallback function that allows the contract\r\n\t* to receive Ether directly.\r\n\t*/\r\n\tfunction() public payable { }\r\n\r\n\t/**\r\n\t* @dev Function that sets both the sell and the buy price of the token.\r\n\t* @param _sellPrice The price at which the token will be sold.\r\n\t* @param _buyPrice The price at which the token will be bought.\r\n\t*/\r\n\tfunction setPrices(uint256 _sellPrice, uint256 _buyPrice) public onlyBotsOrOwners {\r\n\t\tsellPrice = _sellPrice;\r\n\t\tbuyPrice = _buyPrice;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function that sets the current wallet address.\r\n\t* @param _walletAddress The address of wallet to be set.\r\n\t*/\r\n\tfunction setWallet(address _walletAddress) public onlyOwners {\r\n\t\trequire(_walletAddress != address(0), 'Non-zero wallet address required.');\r\n\t\twallet = _walletAddress;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Send Ether to buy tokens at the current token sell price.\r\n\t* @notice buy function has minimum allowed amount one can buy\r\n\t*/\r\n\tfunction buy() public payable whenNotPaused isWhitelisted(msg.sender) {\r\n\t\tuint256 amount = msg.value.mul(1e18);\r\n\t\t\r\n\t\tamount = amount.div(sellPrice);\r\n\r\n\t\trequire(amount >= MINIMUM_BUY_AMOUNT, \"Buy amount too small\");\r\n\t\t\r\n\t\t_transfer(this, msg.sender, amount);\r\n\t}\r\n\t\r\n\t/**\r\n\t* @dev Sell `_amount` tokens at the current buy price.\r\n\t* @param _amount The amount to sell.\r\n\t*/\r\n\tfunction sell(uint256 _amount) public whenNotPaused {\r\n\t\tuint256 toBeTransferred = _amount.mul(buyPrice);\r\n\r\n\t\trequire(toBeTransferred >= 1e18, \"Sell amount too small\");\r\n\r\n\t\ttoBeTransferred = toBeTransferred.div(1e18);\r\n\r\n\t\trequire(address(this).balance >= toBeTransferred, 'Contract has insufficient balance.');\r\n\t\t_transfer(msg.sender, this, _amount);\r\n\t\t\r\n\t\tmsg.sender.transfer(toBeTransferred);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Get the contract balance in WEI.\r\n\t*/\r\n\tfunction getContractBalance() public view returns (uint256) {\r\n\t\treturn address(this).balance;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Withdraw `_amount` ETH to the wallet address.\r\n\t* @param _amount The amount to withdraw.\r\n\t*/\r\n\tfunction withdraw(uint256 _amount) public onlyOwners {\r\n\t\trequire(address(this).balance >= _amount, 'Unable to withdraw specified amount.');\r\n\t\trequire(wallet != address(0), 'Non-zero wallet address required.');\r\n\t\twallet.transfer(_amount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Transfer, which is used when Orbise is bought with different currency than ETH.\r\n\t* @param _to The address of the recipient.\r\n\t* @param _value The amount of Orbise Tokens to transfer.\r\n\t* @return success True if operation is executed successfully.\r\n\t*/\r\n\tfunction nonEtherPurchaseTransfer(address _to, uint256 _value) public isWhitelisted(_to) onlyBots whenNotPaused returns (bool success) {\r\n\t\treturn _transfer(msg.sender, _to, _value);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"name\":\"_buyPrice\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalSupplyAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bot\",\"type\":\"address\"},{\"name\":\"_isAllowed\",\"type\":\"bool\"}],\"name\":\"setBot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_BUY_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint72\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_isAllowed\",\"type\":\"bool\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINTING_HARDCAP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint104\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"nonEtherPurchaseTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bots\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_walletAddress\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_isFrozen\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"isAccountFrozen\",\"outputs\":[{\"name\":\"isFrozen\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dataStorage\",\"type\":\"address\"},{\"name\":\"_ledger\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_isFrozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ERC20Extended","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e1430f91243b62d3207aeaca0c3138bd956720770000000000000000000000007917b0ce447c77c998109b4288f660532e70c9a30000000000000000000000001691c9f284a9d519dca1d9c0a4dadc992885432b","Library":"","SwarmSource":"bzzr://8506010efa2f4f411afcc6795803c1b22fab1ac5e6d445cdf7e074a6bc4a4c0f"}]}