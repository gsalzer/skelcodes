{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  int256 constant INT256_MIN = int256((uint256(1) << 255));\r\n\r\n  /**\r\n  * @dev Multiplies two unsigned integers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Multiplies two signed integers, throws on overflow.\r\n  */\r\n  function mul(int256 a, int256 b) internal pure returns (int256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert((a != -1 || b != INT256_MIN) && c / a == b);\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two unsigned integers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two signed integers, truncating the quotient.\r\n  */\r\n  function div(int256 a, int256 b) internal pure returns (int256) {\r\n    // assert(b != 0); // Solidity automatically throws when dividing by 0\r\n    // Overflow only happens when the smallest negative int is multiplied by -1.\r\n    assert(a != INT256_MIN || b != -1);\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two signed integers, throws on overflow.\r\n  */\r\n  function sub(int256 a, int256 b) internal pure returns (int256 c) {\r\n    c = a - b;\r\n    assert((b >= 0 && c <= a) || (b < 0 && c > a));\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two unsigned integers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two signed integers, throws on overflow.\r\n  */\r\n  function add(int256 a, int256 b) internal pure returns (int256 c) {\r\n    c = a + b;\r\n    assert((b >= 0 && c >= a) || (b < 0 && c < a));\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: @gnosis.pm/util-contracts/contracts/Proxy.sol\r\n\r\n/// @title Proxied - indicates that a contract will be proxied. Also defines storage requirements for Proxy.\r\n/// @author Alan Lu - <alan@gnosis.pm>\r\ncontract Proxied {\r\n    address public masterCopy;\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract Proxy is Proxied {\r\n    /// @dev Constructor function sets address of master copy contract.\r\n    /// @param _masterCopy Master copy address.\r\n    constructor(address _masterCopy)\r\n        public\r\n    {\r\n        require(_masterCopy != 0);\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        address _masterCopy = masterCopy;\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch success\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Tokens/OutcomeToken.sol\r\n\r\ncontract OutcomeTokenProxy is Proxy {\r\n    /*\r\n     *  Storage\r\n     */\r\n\r\n    // HACK: Lining up storage with StandardToken and OutcomeToken\r\n    mapping(address => uint256) balances;\r\n    uint256 totalSupply_;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    address internal eventContract;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Constructor sets events contract address\r\n    constructor(address proxied)\r\n        public\r\n        Proxy(proxied)\r\n    {\r\n        eventContract = msg.sender;\r\n    }\r\n}\r\n\r\n/// @title Outcome token contract - Issuing and revoking outcome tokens\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract OutcomeToken is Proxied, StandardToken {\r\n    using SafeMath for *;\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Issuance(address indexed owner, uint amount);\r\n    event Revocation(address indexed owner, uint amount);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public eventContract;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier isEventContract () {\r\n        // Only event contract is allowed to proceed\r\n        require(msg.sender == eventContract);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Events contract issues new tokens for address. Returns success\r\n    /// @param _for Address of receiver\r\n    /// @param outcomeTokenCount Number of tokens to issue\r\n    function issue(address _for, uint outcomeTokenCount)\r\n        public\r\n        isEventContract\r\n    {\r\n        balances[_for] = balances[_for].add(outcomeTokenCount);\r\n        totalSupply_ = totalSupply_.add(outcomeTokenCount);\r\n        emit Issuance(_for, outcomeTokenCount);\r\n    }\r\n\r\n    /// @dev Events contract revokes tokens for address. Returns success\r\n    /// @param _for Address of token holder\r\n    /// @param outcomeTokenCount Number of tokens to revoke\r\n    function revoke(address _for, uint outcomeTokenCount)\r\n        public\r\n        isEventContract\r\n    {\r\n        balances[_for] = balances[_for].sub(outcomeTokenCount);\r\n        totalSupply_ = totalSupply_.sub(outcomeTokenCount);\r\n        emit Revocation(_for, outcomeTokenCount);\r\n    }\r\n}\r\n\r\n// File: contracts/Oracles/Oracle.sol\r\n\r\n/// @title Abstract oracle contract - Functions to be implemented by oracles\r\ncontract Oracle {\r\n\r\n    function isOutcomeSet() public view returns (bool);\r\n    function getOutcome() public view returns (int);\r\n}\r\n\r\n// File: contracts/Events/Event.sol\r\n\r\ncontract EventData {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event OutcomeTokenCreation(OutcomeToken outcomeToken, uint8 index);\r\n    event OutcomeTokenSetIssuance(address indexed buyer, uint collateralTokenCount);\r\n    event OutcomeTokenSetRevocation(address indexed seller, uint outcomeTokenCount);\r\n    event OutcomeAssignment(int outcome);\r\n    event WinningsRedemption(address indexed receiver, uint winnings);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    ERC20 public collateralToken;\r\n    Oracle public oracle;\r\n    bool public isOutcomeSet;\r\n    int public outcome;\r\n    OutcomeToken[] public outcomeTokens;\r\n}\r\n\r\n/// @title Event contract - Provide basic functionality required by different event types\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract Event is EventData {\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Buys equal number of tokens of all outcomes, exchanging collateral tokens and sets of outcome tokens 1:1\r\n    /// @param collateralTokenCount Number of collateral tokens\r\n    function buyAllOutcomes(uint collateralTokenCount)\r\n        public\r\n    {\r\n        // Transfer collateral tokens to events contract\r\n        require(collateralToken.transferFrom(msg.sender, this, collateralTokenCount));\r\n        // Issue new outcome tokens to sender\r\n        for (uint8 i = 0; i < outcomeTokens.length; i++)\r\n            outcomeTokens[i].issue(msg.sender, collateralTokenCount);\r\n        emit OutcomeTokenSetIssuance(msg.sender, collateralTokenCount);\r\n    }\r\n\r\n    /// @dev Sells equal number of tokens of all outcomes, exchanging collateral tokens and sets of outcome tokens 1:1\r\n    /// @param outcomeTokenCount Number of outcome tokens\r\n    function sellAllOutcomes(uint outcomeTokenCount)\r\n        public\r\n    {\r\n        // Revoke sender's outcome tokens of all outcomes\r\n        for (uint8 i = 0; i < outcomeTokens.length; i++)\r\n            outcomeTokens[i].revoke(msg.sender, outcomeTokenCount);\r\n        // Transfer collateral tokens to sender\r\n        require(collateralToken.transfer(msg.sender, outcomeTokenCount));\r\n        emit OutcomeTokenSetRevocation(msg.sender, outcomeTokenCount);\r\n    }\r\n\r\n    /// @dev Sets winning event outcome\r\n    function setOutcome()\r\n        public\r\n    {\r\n        // Winning outcome is not set yet in event contract but in oracle contract\r\n        require(!isOutcomeSet && oracle.isOutcomeSet());\r\n        // Set winning outcome\r\n        outcome = oracle.getOutcome();\r\n        isOutcomeSet = true;\r\n        emit OutcomeAssignment(outcome);\r\n    }\r\n\r\n    /// @dev Returns outcome count\r\n    /// @return Outcome count\r\n    function getOutcomeCount()\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        return uint8(outcomeTokens.length);\r\n    }\r\n\r\n    /// @dev Returns outcome tokens array\r\n    /// @return Outcome tokens\r\n    function getOutcomeTokens()\r\n        public\r\n        view\r\n        returns (OutcomeToken[])\r\n    {\r\n        return outcomeTokens;\r\n    }\r\n\r\n    /// @dev Returns the amount of outcome tokens held by owner\r\n    /// @return Outcome token distribution\r\n    function getOutcomeTokenDistribution(address owner)\r\n        public\r\n        view\r\n        returns (uint[] outcomeTokenDistribution)\r\n    {\r\n        outcomeTokenDistribution = new uint[](outcomeTokens.length);\r\n        for (uint8 i = 0; i < outcomeTokenDistribution.length; i++)\r\n            outcomeTokenDistribution[i] = outcomeTokens[i].balanceOf(owner);\r\n    }\r\n\r\n    /// @dev Calculates and returns event hash\r\n    /// @return Event hash\r\n    function getEventHash() public view returns (bytes32);\r\n\r\n    /// @dev Exchanges sender's winning outcome tokens for collateral tokens\r\n    /// @return Sender's winnings\r\n    function redeemWinnings() public returns (uint);\r\n}\r\n\r\n// File: contracts/Events/ScalarEvent.sol\r\n\r\ncontract ScalarEventData {\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint8 public constant SHORT = 0;\r\n    uint8 public constant LONG = 1;\r\n    uint24 public constant OUTCOME_RANGE = 1000000;\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    int public lowerBound;\r\n    int public upperBound;\r\n}\r\n\r\ncontract ScalarEventProxy is Proxy, EventData, ScalarEventData {\r\n\r\n    /// @dev Contract constructor validates and sets basic event properties\r\n    /// @param _collateralToken Tokens used as collateral in exchange for outcome tokens\r\n    /// @param _oracle Oracle contract used to resolve the event\r\n    /// @param _lowerBound Lower bound for event outcome\r\n    /// @param _upperBound Lower bound for event outcome\r\n    constructor(\r\n        address proxied,\r\n        address outcomeTokenMasterCopy,\r\n        ERC20 _collateralToken,\r\n        Oracle _oracle,\r\n        int _lowerBound,\r\n        int _upperBound\r\n    )\r\n        Proxy(proxied)\r\n        public\r\n    {\r\n        // Validate input\r\n        require(address(_collateralToken) != 0 && address(_oracle) != 0);\r\n        collateralToken = _collateralToken;\r\n        oracle = _oracle;\r\n        // Create an outcome token for each outcome\r\n        for (uint8 i = 0; i < 2; i++) {\r\n            OutcomeToken outcomeToken = OutcomeToken(new OutcomeTokenProxy(outcomeTokenMasterCopy));\r\n            outcomeTokens.push(outcomeToken);\r\n            emit OutcomeTokenCreation(outcomeToken, i);\r\n        }\r\n\r\n        // Validate bounds\r\n        require(_upperBound > _lowerBound);\r\n        lowerBound = _lowerBound;\r\n        upperBound = _upperBound;\r\n    }\r\n}\r\n\r\n/// @title Scalar event contract - Scalar events resolve to a number within a range\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract ScalarEvent is Proxied, Event, ScalarEventData {\r\n    using SafeMath for *;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Exchanges sender's winning outcome tokens for collateral tokens\r\n    /// @return Sender's winnings\r\n    function redeemWinnings()\r\n        public\r\n        returns (uint winnings)\r\n    {\r\n        // Winning outcome has to be set\r\n        require(isOutcomeSet);\r\n        // Calculate winnings\r\n        uint24 convertedWinningOutcome;\r\n        // Outcome is lower than defined lower bound\r\n        if (outcome < lowerBound)\r\n            convertedWinningOutcome = 0;\r\n        // Outcome is higher than defined upper bound\r\n        else if (outcome > upperBound)\r\n            convertedWinningOutcome = OUTCOME_RANGE;\r\n        // Map outcome to outcome range\r\n        else\r\n            convertedWinningOutcome = uint24(OUTCOME_RANGE * (outcome - lowerBound) / (upperBound - lowerBound));\r\n        uint factorShort = OUTCOME_RANGE - convertedWinningOutcome;\r\n        uint factorLong = OUTCOME_RANGE - factorShort;\r\n        uint shortOutcomeTokenCount = outcomeTokens[SHORT].balanceOf(msg.sender);\r\n        uint longOutcomeTokenCount = outcomeTokens[LONG].balanceOf(msg.sender);\r\n        winnings = shortOutcomeTokenCount.mul(factorShort).add(longOutcomeTokenCount.mul(factorLong)) / OUTCOME_RANGE;\r\n        // Revoke all outcome tokens\r\n        outcomeTokens[SHORT].revoke(msg.sender, shortOutcomeTokenCount);\r\n        outcomeTokens[LONG].revoke(msg.sender, longOutcomeTokenCount);\r\n        // Payout winnings to sender\r\n        require(collateralToken.transfer(msg.sender, winnings));\r\n        emit WinningsRedemption(msg.sender, winnings);\r\n    }\r\n\r\n    /// @dev Calculates and returns event hash\r\n    /// @return Event hash\r\n    function getEventHash()\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(collateralToken, oracle, lowerBound, upperBound));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"setOutcome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"outcome\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"collateralTokenCount\",\"type\":\"uint256\"}],\"name\":\"buyAllOutcomes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LONG\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOutcomeTokenDistribution\",\"outputs\":[{\"name\":\"outcomeTokenDistribution\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OUTCOME_RANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint24\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"outcomeTokenCount\",\"type\":\"uint256\"}],\"name\":\"sellAllOutcomes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOutcomeCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"outcomeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lowerBound\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masterCopy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SHORT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"redeemWinnings\",\"outputs\":[{\"name\":\"winnings\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upperBound\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"collateralToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOutcomeSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOutcomeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"outcomeToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint8\"}],\"name\":\"OutcomeTokenCreation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"collateralTokenCount\",\"type\":\"uint256\"}],\"name\":\"OutcomeTokenSetIssuance\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"outcomeTokenCount\",\"type\":\"uint256\"}],\"name\":\"OutcomeTokenSetRevocation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"outcome\",\"type\":\"int256\"}],\"name\":\"OutcomeAssignment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnings\",\"type\":\"uint256\"}],\"name\":\"WinningsRedemption\",\"type\":\"event\"}]","ContractName":"ScalarEvent","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4215cf299e935dfebc0b92fe7f24d4b97957bc2c3c31d70059536873116a1fe0"}]}