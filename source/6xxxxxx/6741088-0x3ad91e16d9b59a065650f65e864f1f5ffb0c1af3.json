{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\npragma experimental ABIEncoderV2;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\n\r\nlibrary Math {\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute\r\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function decimals() public view returns (uint256);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/*\r\n    Modified Util contract as used by Kyber Network\r\n*/\r\n\r\nlibrary Utils {\r\n\r\n    uint256 constant internal PRECISION = (10**18);\r\n    uint256 constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint256 constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint256 constant internal MAX_DECIMALS = 18;\r\n    uint256 constant internal ETH_DECIMALS = 18;\r\n    uint256 constant internal MAX_UINT = 2**256-1;\r\n\r\n    // Currently constants can't be accessed from other contracts, so providing functions to do that here\r\n    function precision() internal pure returns (uint256) { return PRECISION; }\r\n    function max_qty() internal pure returns (uint256) { return MAX_QTY; }\r\n    function max_rate() internal pure returns (uint256) { return MAX_RATE; }\r\n    function max_decimals() internal pure returns (uint256) { return MAX_DECIMALS; }\r\n    function eth_decimals() internal pure returns (uint256) { return ETH_DECIMALS; }\r\n    function max_uint() internal pure returns (uint256) { return MAX_UINT; }\r\n\r\n    /// @notice Retrieve the number of decimals used for a given ERC20 token\r\n    /// @dev As decimals are an optional feature in ERC20, this contract uses `call` to\r\n    /// ensure that an exception doesn't cause transaction failure\r\n    /// @param token the token for which we should retrieve the decimals\r\n    /// @return decimals the number of decimals in the given token\r\n    function getDecimals(address token)\r\n        internal\r\n        view\r\n        returns (uint256 decimals)\r\n    {\r\n        bytes4 functionSig = bytes4(keccak256(\"decimals()\"));\r\n\r\n        /// @dev Using assembly due to issues with current solidity `address.call()`\r\n        /// implementation: https://github.com/ethereum/solidity/issues/2884\r\n        assembly {\r\n            // Pointer to next free memory slot\r\n            let ptr := mload(0x40)\r\n            // Store functionSig variable at ptr\r\n            mstore(ptr,functionSig)\r\n            let functionSigLength := 0x04\r\n            let wordLength := 0x20\r\n\r\n            let success := call(\r\n                                5000, // Amount of gas\r\n                                token, // Address to call\r\n                                0, // ether to send\r\n                                ptr, // ptr to input data\r\n                                functionSigLength, // size of data\r\n                                ptr, // where to store output data (overwrite input)\r\n                                wordLength // size of output data (32 bytes)\r\n                               )\r\n\r\n            switch success\r\n            case 0 {\r\n                decimals := 18 // If the token doesn't implement `decimals()`, return 18 as default\r\n            }\r\n            case 1 {\r\n                decimals := mload(ptr) // Set decimals to return data from call\r\n            }\r\n            mstore(0x40,add(ptr,0x04)) // Reset the free memory pointer to the next known free location\r\n        }\r\n    }\r\n\r\n    /// @dev Checks that a given address has its token allowance and balance set above the given amount\r\n    /// @param tokenOwner the address which should have custody of the token\r\n    /// @param tokenAddress the address of the token to check\r\n    /// @param tokenAmount the amount of the token which should be set\r\n    /// @param addressToAllow the address which should be allowed to transfer the token\r\n    /// @return bool true if the allowance and balance is set, false if not\r\n    function tokenAllowanceAndBalanceSet(\r\n        address tokenOwner,\r\n        address tokenAddress,\r\n        uint256 tokenAmount,\r\n        address addressToAllow\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        return (\r\n            ERC20(tokenAddress).allowance(tokenOwner, addressToAllow) >= tokenAmount &&\r\n            ERC20(tokenAddress).balanceOf(tokenOwner) >= tokenAmount\r\n        );\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns (uint) {\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns (uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns (uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns (uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n\r\n    /// @notice Bringing this in from the Math library as we've run out of space in TotlePrimary (see EIP-170)\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\nlibrary ERC20SafeTransfer {\r\n    function safeTransfer(address _tokenAddress, address _to, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"transfer(address,uint256)\")), _to, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeTransferFrom(address _tokenAddress, address _from, address _to, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, _to, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function safeApprove(address _tokenAddress, address _spender, uint256 _value) internal returns (bool success) {\r\n\r\n        require(_tokenAddress.call(bytes4(keccak256(\"approve(address,uint256)\")), _spender, _value));\r\n\r\n        return fetchReturnData();\r\n    }\r\n\r\n    function fetchReturnData() internal returns (bool success){\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 {\r\n                success := 1\r\n            }\r\n            case 32 {\r\n                returndatacopy(0, 0, 32)\r\n                success := mload(0)\r\n            }\r\n            default {\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/// @title A contract which is used to check and set allowances of tokens\r\n/// @dev In order to use this contract is must be inherited in the contract which is using\r\n/// its functionality\r\ncontract AllowanceSetter {\r\n    uint256 constant MAX_UINT = 2**256 - 1;\r\n\r\n    /// @notice A function which allows the caller to approve the max amount of any given token\r\n    /// @dev In order to function correctly, token allowances should not be set anywhere else in\r\n    /// the inheriting contract\r\n    /// @param addressToApprove the address which we want to approve to transfer the token\r\n    /// @param token the token address which we want to call approve on\r\n    function approveAddress(address addressToApprove, address token) internal {\r\n        if(ERC20(token).allowance(address(this), addressToApprove) == 0) {\r\n            require(ERC20SafeTransfer.safeApprove(token, addressToApprove, MAX_UINT));\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/// @title A contract which can be used to ensure only the TotlePrimary contract can call\r\n/// some functions\r\n/// @dev Defines a modifier which should be used when only the totle contract should\r\n/// able able to call a function\r\ncontract TotleControl is Ownable {\r\n    address public totlePrimary;\r\n\r\n    /// @dev A modifier which only allows code execution if msg.sender equals totlePrimary address\r\n    modifier onlyTotle() {\r\n        require(msg.sender == totlePrimary);\r\n        _;\r\n    }\r\n\r\n    /// @notice Contract constructor\r\n    /// @dev As this contract inherits ownable, msg.sender will become the contract owner\r\n    /// @param _totlePrimary the address of the contract to be set as totlePrimary\r\n    constructor(address _totlePrimary) public {\r\n        require(_totlePrimary != address(0x0));\r\n        totlePrimary = _totlePrimary;\r\n    }\r\n\r\n    /// @notice A function which allows only the owner to change the address of totlePrimary\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _totlePrimary the address of the contract to be set as totlePrimary\r\n    function setTotle(\r\n        address _totlePrimary\r\n    ) external onlyOwner {\r\n        require(_totlePrimary != address(0x0));\r\n        totlePrimary = _totlePrimary;\r\n    }\r\n}\r\n\r\n/// @title A contract which allows its owner to withdraw any ether which is contained inside\r\ncontract Withdrawable is Ownable {\r\n\r\n    /// @notice Withdraw ether contained in this contract and send it back to owner\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _token The address of the token that the user wants to withdraw\r\n    /// @param _amount The amount of tokens that the caller wants to withdraw\r\n    /// @return bool value indicating whether the transfer was successful\r\n    function withdrawToken(address _token, uint256 _amount) external onlyOwner returns (bool) {\r\n        return ERC20SafeTransfer.safeTransfer(_token, owner, _amount);\r\n    }\r\n\r\n    /// @notice Withdraw ether contained in this contract and send it back to owner\r\n    /// @dev onlyOwner modifier only allows the contract owner to run the code\r\n    /// @param _amount The amount of ether that the caller wants to withdraw\r\n    function withdrawETH(uint256 _amount) external onlyOwner {\r\n        owner.transfer(_amount);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns (bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused, \"Contract is paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused, \"Contract not paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\ncontract ErrorReporter {\r\n    function revertTx(string reason) public pure {\r\n        revert(reason);\r\n    }\r\n}\r\n\r\ncontract SelectorProvider {\r\n    bytes4 constant getAmountToGive = bytes4(keccak256(\"getAmountToGive(bytes)\"));\r\n    bytes4 constant staticExchangeChecks = bytes4(keccak256(\"staticExchangeChecks(bytes)\"));\r\n    bytes4 constant performBuyOrder = bytes4(keccak256(\"performBuyOrder(bytes,uint256)\"));\r\n    bytes4 constant performSellOrder = bytes4(keccak256(\"performSellOrder(bytes,uint256)\"));\r\n\r\n    function getSelector(bytes4 genericSelector) public pure returns (bytes4);\r\n}\r\n\r\n/// @title Interface for all exchange handler contracts\r\ncontract ExchangeHandler is TotleControl, Withdrawable, Pausable {\r\n\r\n    /*\r\n    *   State Variables\r\n    */\r\n\r\n    SelectorProvider public selectorProvider;\r\n    ErrorReporter public errorReporter;\r\n    /* Logger public logger; */\r\n    /*\r\n    *   Modifiers\r\n    */\r\n\r\n    modifier onlySelf() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    /// @notice Constructor\r\n    /// @dev Calls the constructor of the inherited TotleControl\r\n    /// @param _selectorProvider the provider for this exchanges function selectors\r\n    /// @param totlePrimary the address of the totlePrimary contract\r\n    constructor(\r\n        address _selectorProvider,\r\n        address totlePrimary,\r\n        address _errorReporter\r\n        /* ,address _logger */\r\n    )\r\n        TotleControl(totlePrimary)\r\n        public\r\n    {\r\n        require(_selectorProvider != address(0x0));\r\n        require(_errorReporter != address(0x0));\r\n        /* require(_logger != address(0x0)); */\r\n        selectorProvider = SelectorProvider(_selectorProvider);\r\n        errorReporter = ErrorReporter(_errorReporter);\r\n        /* logger = Logger(_logger); */\r\n    }\r\n\r\n    /// @notice Gets the amount that Totle needs to give for this order\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @return amountToGive amount taker needs to give in order to fill the order\r\n    function getAmountToGive(\r\n        bytes genericPayload\r\n    )\r\n        public\r\n        view\r\n        onlyTotle\r\n        whenNotPaused\r\n        returns (uint256 amountToGive)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = selectorProvider.getSelector(this.getAmountToGive.selector);\r\n\r\n        assembly {\r\n            let functionSelectorLength := 0x04\r\n            let functionSelectorOffset := 0x1C\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let bytesLength := mload(genericPayload)\r\n            let totalLength := add(functionSelectorLength, bytesLength)\r\n            let startOfNewData := add(genericPayload, functionSelectorOffset)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n            mstore(genericPayload, functionSelectorCorrect)\r\n\r\n            success := call(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            callvalue,\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            wordLength // Length of return variable is one word\r\n                           )\r\n            amountToGive := mload(scratchSpace)\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform exchange-specific checks on the given order\r\n    /// @dev this should be called to check for payload errors\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @return checksPassed value representing pass or fail\r\n    function staticExchangeChecks(\r\n        bytes genericPayload\r\n    )\r\n        public\r\n        view\r\n        onlyTotle\r\n        whenNotPaused\r\n        returns (bool checksPassed)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = selectorProvider.getSelector(this.staticExchangeChecks.selector);\r\n        assembly {\r\n            let functionSelectorLength := 0x04\r\n            let functionSelectorOffset := 0x1C\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let bytesLength := mload(genericPayload)\r\n            let totalLength := add(functionSelectorLength, bytesLength)\r\n            let startOfNewData := add(genericPayload, functionSelectorOffset)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n            mstore(genericPayload, functionSelectorCorrect)\r\n\r\n            success := call(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            callvalue,\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            wordLength // Length of return variable is one word\r\n                           )\r\n            checksPassed := mload(scratchSpace)\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform a buy order at the exchange\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @param  amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performBuyOrder(\r\n        bytes genericPayload,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        payable\r\n        onlyTotle\r\n        whenNotPaused\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = selectorProvider.getSelector(this.performBuyOrder.selector);\r\n        assembly {\r\n            let callDataOffset := 0x44\r\n            let functionSelectorOffset := 0x1C\r\n            let functionSelectorLength := 0x04\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let startOfFreeMemory := mload(0x40)\r\n\r\n            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\r\n\r\n            let bytesLength := mload(startOfFreeMemory)\r\n            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n\r\n            mstore(startOfFreeMemory, functionSelectorCorrect)\r\n\r\n            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\r\n\r\n            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\r\n\r\n            success := call(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            callvalue,\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            mul(wordLength, 0x02) // Length of return variables is two words\r\n                          )\r\n            amountSpentOnOrder := mload(scratchSpace)\r\n            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n\r\n    /// @notice Perform a sell order at the exchange\r\n    /// @param genericPayload the data for this order in a generic format\r\n    /// @param  amountToGiveForOrder amount that should be spent on this order\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performSellOrder(\r\n        bytes genericPayload,\r\n        uint256 amountToGiveForOrder\r\n    )\r\n        public\r\n        onlyTotle\r\n        whenNotPaused\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        bool success;\r\n        bytes4 functionSelector = selectorProvider.getSelector(this.performSellOrder.selector);\r\n        assembly {\r\n            let callDataOffset := 0x44\r\n            let functionSelectorOffset := 0x1C\r\n            let functionSelectorLength := 0x04\r\n            let scratchSpace := 0x0\r\n            let wordLength := 0x20\r\n            let startOfFreeMemory := mload(0x40)\r\n\r\n            calldatacopy(startOfFreeMemory, callDataOffset, calldatasize)\r\n\r\n            let bytesLength := mload(startOfFreeMemory)\r\n            let totalLength := add(add(functionSelectorLength, bytesLength), wordLength)\r\n\r\n            mstore(add(scratchSpace, functionSelectorOffset), functionSelector)\r\n\r\n            let functionSelectorCorrect := mload(scratchSpace)\r\n\r\n            mstore(startOfFreeMemory, functionSelectorCorrect)\r\n\r\n            mstore(add(startOfFreeMemory, add(wordLength, bytesLength)), amountToGiveForOrder)\r\n\r\n            let startOfNewData := add(startOfFreeMemory,functionSelectorOffset)\r\n\r\n            success := call(\r\n                            gas,\r\n                            address, // This address of the current contract\r\n                            callvalue,\r\n                            startOfNewData, // Start data at the beginning of the functionSelector\r\n                            totalLength, // Total length of all data, including functionSelector\r\n                            scratchSpace, // Use the first word of memory (scratch space) to store our return variable.\r\n                            mul(wordLength, 0x02) // Length of return variables is two words\r\n                          )\r\n            amountSpentOnOrder := mload(scratchSpace)\r\n            amountReceivedFromOrder := mload(add(scratchSpace, wordLength))\r\n            if eq(success, 0) { revert(0, 0) }\r\n        }\r\n    }\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2018 ZeroEx Intl.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract LibEIP712 {\r\n\r\n    // EIP191 header for EIP712 prefix\r\n    string constant internal EIP191_HEADER = \"\\x19\\x01\";\r\n\r\n    // EIP712 Domain Name value\r\n    string constant internal EIP712_DOMAIN_NAME = \"0x Protocol\";\r\n\r\n    // EIP712 Domain Version value\r\n    string constant internal EIP712_DOMAIN_VERSION = \"2\";\r\n\r\n    // Hash of the EIP712 Domain Separator Schema\r\n    bytes32 constant internal EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH = keccak256(abi.encodePacked(\r\n        \"EIP712Domain(\",\r\n        \"string name,\",\r\n        \"string version,\",\r\n        \"address verifyingContract\",\r\n        \")\"\r\n    ));\r\n\r\n    // Hash of the EIP712 Domain Separator data\r\n    // solhint-disable-next-line var-name-mixedcase\r\n    bytes32 public EIP712_DOMAIN_HASH;\r\n\r\n    constructor ()\r\n        public\r\n    {\r\n        EIP712_DOMAIN_HASH = keccak256(abi.encodePacked(\r\n            EIP712_DOMAIN_SEPARATOR_SCHEMA_HASH,\r\n            keccak256(bytes(EIP712_DOMAIN_NAME)),\r\n            keccak256(bytes(EIP712_DOMAIN_VERSION)),\r\n            bytes32(address(this))\r\n        ));\r\n    }\r\n\r\n    /// @dev Calculates EIP712 encoding for a hash struct in this EIP712 Domain.\r\n    /// @param hashStruct The EIP712 hash struct.\r\n    /// @return EIP712 hash applied to this EIP712 Domain.\r\n    function hashEIP712Message(bytes32 hashStruct)\r\n        internal\r\n        view\r\n        returns (bytes32 result)\r\n    {\r\n        bytes32 eip712DomainHash = EIP712_DOMAIN_HASH;\r\n\r\n        // Assembly for more efficient computing:\r\n        // keccak256(abi.encodePacked(\r\n        //     EIP191_HEADER,\r\n        //     EIP712_DOMAIN_HASH,\r\n        //     hashStruct\r\n        // ));\r\n\r\n        assembly {\r\n            // Load free memory pointer\r\n            let memPtr := mload(64)\r\n\r\n            mstore(memPtr, 0x1901000000000000000000000000000000000000000000000000000000000000)  // EIP191 header\r\n            mstore(add(memPtr, 2), eip712DomainHash)                                            // EIP712 domain hash\r\n            mstore(add(memPtr, 34), hashStruct)                                                 // Hash of struct\r\n\r\n            // Compute hash\r\n            result := keccak256(memPtr, 66)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2018 ZeroEx Intl.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\ncontract LibOrder is\r\n    LibEIP712\r\n{\r\n    // Hash for the EIP712 Order Schema\r\n    bytes32 constant internal EIP712_ORDER_SCHEMA_HASH = keccak256(abi.encodePacked(\r\n        \"Order(\",\r\n        \"address makerAddress,\",\r\n        \"address takerAddress,\",\r\n        \"address feeRecipientAddress,\",\r\n        \"address senderAddress,\",\r\n        \"uint256 makerAssetAmount,\",\r\n        \"uint256 takerAssetAmount,\",\r\n        \"uint256 makerFee,\",\r\n        \"uint256 takerFee,\",\r\n        \"uint256 expirationTimeSeconds,\",\r\n        \"uint256 salt,\",\r\n        \"bytes makerAssetData,\",\r\n        \"bytes takerAssetData\",\r\n        \")\"\r\n    ));\r\n\r\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\r\n    // An order's state is unaffected by external factors, like account balances.\r\n    enum OrderStatus {\r\n        INVALID,                     // Default value\r\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\r\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\r\n        FILLABLE,                    // Order is fillable\r\n        EXPIRED,                     // Order has already expired\r\n        FULLY_FILLED,                // Order is fully filled\r\n        CANCELLED                    // Order has been cancelled\r\n    }\r\n\r\n    // solhint-disable max-line-length\r\n    struct Order {\r\n        address makerAddress;           // Address that created the order.\r\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\r\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\r\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\r\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\r\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\r\n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\r\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\r\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\r\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\r\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\r\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\r\n    }\r\n    // solhint-enable max-line-length\r\n\r\n    struct OrderInfo {\r\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\r\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\r\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\r\n    }\r\n\r\n    /// @dev Calculates Keccak-256 hash of the order.\r\n    /// @param order The order structure.\r\n    /// @return Keccak-256 EIP712 hash of the order.\r\n    function getOrderHash(Order memory order)\r\n        internal\r\n        view\r\n        returns (bytes32 orderHash)\r\n    {\r\n        orderHash = hashEIP712Message(hashOrder(order));\r\n        return orderHash;\r\n    }\r\n\r\n    /// @dev Calculates EIP712 hash of the order.\r\n    /// @param order The order structure.\r\n    /// @return EIP712 hash of the order.\r\n    function hashOrder(Order memory order)\r\n        internal\r\n        pure\r\n        returns (bytes32 result)\r\n    {\r\n        bytes32 schemaHash = EIP712_ORDER_SCHEMA_HASH;\r\n        bytes32 makerAssetDataHash = keccak256(order.makerAssetData);\r\n        bytes32 takerAssetDataHash = keccak256(order.takerAssetData);\r\n\r\n        // Assembly for more efficiently computing:\r\n        // keccak256(abi.encodePacked(\r\n        //     EIP712_ORDER_SCHEMA_HASH,\r\n        //     bytes32(order.makerAddress),\r\n        //     bytes32(order.takerAddress),\r\n        //     bytes32(order.feeRecipientAddress),\r\n        //     bytes32(order.senderAddress),\r\n        //     order.makerAssetAmount,\r\n        //     order.takerAssetAmount,\r\n        //     order.makerFee,\r\n        //     order.takerFee,\r\n        //     order.expirationTimeSeconds,\r\n        //     order.salt,\r\n        //     keccak256(order.makerAssetData),\r\n        //     keccak256(order.takerAssetData)\r\n        // ));\r\n\r\n        assembly {\r\n            // Calculate memory addresses that will be swapped out before hashing\r\n            let pos1 := sub(order, 32)\r\n            let pos2 := add(order, 320)\r\n            let pos3 := add(order, 352)\r\n\r\n            // Backup\r\n            let temp1 := mload(pos1)\r\n            let temp2 := mload(pos2)\r\n            let temp3 := mload(pos3)\r\n\r\n            // Hash in place\r\n            mstore(pos1, schemaHash)\r\n            mstore(pos2, makerAssetDataHash)\r\n            mstore(pos3, takerAssetDataHash)\r\n            result := keccak256(pos1, 416)\r\n\r\n            // Restore\r\n            mstore(pos1, temp1)\r\n            mstore(pos2, temp2)\r\n            mstore(pos3, temp3)\r\n        }\r\n        return result;\r\n    }\r\n}\r\n\r\n/*\r\n\r\n  Copyright 2018 ZeroEx Intl.\r\n\r\n  Licensed under the Apache License, Version 2.0 (the \"License\");\r\n  you may not use this file except in compliance with the License.\r\n  You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n  Unless required by applicable law or agreed to in writing, software\r\n  distributed under the License is distributed on an \"AS IS\" BASIS,\r\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n  See the License for the specific language governing permissions and\r\n  limitations under the License.\r\n\r\n*/\r\n\r\ncontract LibFillResults\r\n{\r\n    struct FillResults {\r\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\r\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\r\n        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\r\n        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\r\n    }\r\n\r\n    struct MatchedFillResults {\r\n        FillResults left;                    // Amounts filled and fees paid of left order.\r\n        FillResults right;                   // Amounts filled and fees paid of right order.\r\n        uint256 leftMakerAssetSpreadAmount;  // Spread between price of left and right order, denominated in the left order's makerAsset, paid to taker.\r\n    }\r\n\r\n    /// @dev Adds properties of both FillResults instances.\r\n    ///      Modifies the first FillResults instance specified.\r\n    /// @param totalFillResults Fill results instance that will be added onto.\r\n    /// @param singleFillResults Fill results instance that will be added to totalFillResults.\r\n    function addFillResults(FillResults memory totalFillResults, FillResults memory singleFillResults)\r\n        internal\r\n        pure\r\n    {\r\n        totalFillResults.makerAssetFilledAmount = SafeMath.add(totalFillResults.makerAssetFilledAmount, singleFillResults.makerAssetFilledAmount);\r\n        totalFillResults.takerAssetFilledAmount = SafeMath.add(totalFillResults.takerAssetFilledAmount, singleFillResults.takerAssetFilledAmount);\r\n        totalFillResults.makerFeePaid = SafeMath.add(totalFillResults.makerFeePaid, singleFillResults.makerFeePaid);\r\n        totalFillResults.takerFeePaid = SafeMath.add(totalFillResults.takerFeePaid, singleFillResults.takerFeePaid);\r\n    }\r\n}\r\n\r\ncontract IExchangeCore {\r\n\r\n    bytes public ZRX_ASSET_DATA;\r\n\r\n    /// @dev Fills the input order.\r\n    /// @param order Order struct containing order specifications.\r\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\r\n    /// @param signature Proof that order has been created by maker.\r\n    /// @return Amounts filled and fees paid by maker and taker.\r\n    function fillOrder(\r\n        LibOrder.Order memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory fillResults);\r\n\r\n    function fillOrderNoThrow(\r\n        LibOrder.Order memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory fillResults);\r\n\r\n    /// @dev Gets information about an order: status, hash, and amount filled.\r\n    /// @param order Order to gather information on.\r\n    /// @return OrderInfo Information about the order and its state.\r\n    ///                   See LibOrder.OrderInfo for a complete description.\r\n    function getOrderInfo(LibOrder.Order memory order)\r\n        public\r\n        view\r\n        returns (LibOrder.OrderInfo memory orderInfo);\r\n\r\n    /// @dev Gets an asset proxy.\r\n    /// @param assetProxyId Id of the asset proxy.\r\n    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\r\n    function getAssetProxy(bytes4 assetProxyId)\r\n        external\r\n        view\r\n        returns (address);\r\n\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        address signerAddress,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        view\r\n        returns (bool isValid);\r\n}\r\n\r\ninterface WETH {\r\n    function deposit() external payable;\r\n    function withdraw(uint256 amount) external;\r\n}\r\n\r\n/// @title ZeroExExchangeSelectorProvider\r\n/// @notice Provides this exchange implementation with correctly formatted function selectors\r\ncontract ZeroExExchangeSelectorProvider is SelectorProvider {\r\n    function getSelector(bytes4 genericSelector) public pure returns (bytes4) {\r\n        if (genericSelector == getAmountToGive) {\r\n            return bytes4(keccak256(\"getAmountToGive_((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes))\"));\r\n        } else if (genericSelector == staticExchangeChecks) {\r\n            return bytes4(keccak256(\"staticExchangeChecks_((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes))\"));\r\n        } else if (genericSelector == performBuyOrder) {\r\n            return bytes4(keccak256(\"performBuyOrder_((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes))\"));\r\n        } else if (genericSelector == performSellOrder) {\r\n            return bytes4(keccak256(\"performSellOrder_((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes,bytes))\"));\r\n        } else {\r\n            return bytes4(0x0);\r\n        }\r\n    }\r\n}\r\n\r\n// \"((address,address,address,address,uint256,uint256,uint256,uint256,uint256,uint256,bytes,bytes),bytes)\"\r\n\r\n/// @title ZeroExExchangeHandler\r\n/// @notice Handles the all ZeroExExchange trades for the primary contract\r\ncontract ZeroExExchangeHandler is ExchangeHandler, AllowanceSetter  {\r\n\r\n    /*\r\n    *   State Variables\r\n    */\r\n\r\n    IExchangeCore public exchange;\r\n    /// @dev note that this is dependent on the deployment of 0xV2. This is the ERC20 asset proxy + the mainnet address of the ZRX token\r\n    bytes constant ZRX_ASSET_DATA = \"\\xf4\\x72\\x61\\xb0\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xe4\\x1d\\x24\\x89\\x57\\x1d\\x32\\x21\\x89\\x24\\x6d\\xaf\\xa5\\xeb\\xde\\x1f\\x46\\x99\\xf4\\x98\";\r\n    address ERC20_ASSET_PROXY;\r\n    WETH weth;\r\n\r\n    /*\r\n    *   Types\r\n    */\r\n\r\n    /// @notice Constructor\r\n    /// @param _exchange Address of the IExchangeCore exchange\r\n    /// @param selectorProvider the provider for this exchanges function selectors\r\n    /// @param totlePrimary the address of the totlePrimary contract\r\n    constructor(\r\n        address _exchange,\r\n        address selectorProvider,\r\n        address totlePrimary,\r\n        address _weth,\r\n        address errorReporter\r\n        /* ,address logger */\r\n    )\r\n        ExchangeHandler(selectorProvider, totlePrimary, errorReporter/*, logger*/)\r\n        public\r\n    {\r\n        require(_exchange != address(0x0));\r\n        exchange = IExchangeCore(_exchange);\r\n        ERC20_ASSET_PROXY = exchange.getAssetProxy(toBytes4(ZRX_ASSET_DATA, 0));\r\n        weth = WETH(_weth);\r\n    }\r\n\r\n    struct OrderData {\r\n        address makerAddress;           // Address that created the order.\r\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\r\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\r\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\r\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\r\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\r\n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\r\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\r\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\r\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\r\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\r\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\r\n        bytes signature;\r\n    }\r\n\r\n    /*\r\n    *   Public functions\r\n    */\r\n\r\n    /*\r\n    *   Internal functions\r\n    */\r\n\r\n    /// @notice Gets the amount that Totle needs to give for this order\r\n    /// @param data LibOrder.Order struct containing order values\r\n    /// @return amountToGive amount taker needs to give in order to fill the order\r\n    function getAmountToGive_(\r\n        OrderData data\r\n    )\r\n      public\r\n      view\r\n      onlySelf\r\n      returns (uint256 amountToGive)\r\n    {\r\n        LibOrder.OrderInfo memory orderInfo = exchange.getOrderInfo(\r\n            getZeroExOrder(data)\r\n        );\r\n        uint makerAssetAvailable = getAssetDataAvailable(data.makerAssetData, data.makerAddress);\r\n        uint feeAssetAvailable = getAssetDataAvailable(ZRX_ASSET_DATA, data.makerAddress);\r\n\r\n        uint maxFromMakerFee = data.makerFee == 0 ? Utils.max_uint() : getPartialAmount(feeAssetAvailable, data.makerFee, data.takerAssetAmount);\r\n        amountToGive = Math.min(Math.min(\r\n            getPartialAmount(makerAssetAvailable, data.makerAssetAmount, data.takerAssetAmount),\r\n            maxFromMakerFee),\r\n            SafeMath.sub(data.takerAssetAmount, orderInfo.orderTakerAssetFilledAmount)\r\n        );\r\n        /* logger.log(\"Getting amountToGive from ZeroEx arg2: amountToGive\", amountToGive); */\r\n    }\r\n\r\n    function getAssetDataAvailable(bytes assetData, address account) internal view returns (uint){\r\n        address tokenAddress = toAddress(assetData, 16);\r\n        ERC20 token = ERC20(tokenAddress);\r\n        return Math.min(token.balanceOf(account), token.allowance(account, ERC20_ASSET_PROXY));\r\n    }\r\n\r\n    function getZeroExOrder(OrderData data) internal pure returns (LibOrder.Order) {\r\n        return LibOrder.Order({\r\n            makerAddress: data.makerAddress,\r\n            takerAddress: data.takerAddress,\r\n            feeRecipientAddress: data.feeRecipientAddress,\r\n            senderAddress: data.senderAddress,\r\n            makerAssetAmount: data.makerAssetAmount,\r\n            takerAssetAmount: data.takerAssetAmount,\r\n            makerFee: data.makerFee,\r\n            takerFee: data.takerFee,\r\n            expirationTimeSeconds: data.expirationTimeSeconds,\r\n            salt: data.salt,\r\n            makerAssetData: data.makerAssetData,\r\n            takerAssetData: data.takerAssetData\r\n        });\r\n    }\r\n\r\n    /// @notice Perform exchange-specific checks on the given order\r\n    /// @dev This should be called to check for payload errors\r\n    /// @param data LibOrder.Order struct containing order values\r\n    /// @return checksPassed value representing pass or fail\r\n    function staticExchangeChecks_(\r\n        OrderData data\r\n    )\r\n        public\r\n        view\r\n        onlySelf\r\n        returns (bool checksPassed)\r\n    {\r\n\r\n        // Make sure that:\r\n        //  The order is not expired\r\n        //  Both the maker and taker assets are ERC20 tokens\r\n        //  The taker does not have to pay a fee (we don't support fees yet)\r\n        //  We are permitted to take this order\r\n        //  We are permitted to send this order\r\n        // TODO: Should we check signatures here?\r\n        return (block.timestamp <= data.expirationTimeSeconds &&\r\n                toBytes4(data.takerAssetData, 0) == bytes4(0xf47261b0) &&\r\n                toBytes4(data.makerAssetData, 0) == bytes4(0xf47261b0) &&\r\n                data.takerFee == 0 &&\r\n                (data.takerAddress == address(0x0) || data.takerAddress == address(this)) &&\r\n                (data.senderAddress == address(0x0) || data.senderAddress == address(this))\r\n        );\r\n    }\r\n\r\n    /// @notice Perform a buy order at the exchange\r\n    /// @param data LibOrder.Order struct containing order values\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performBuyOrder_(\r\n        OrderData data\r\n    )\r\n        public\r\n        payable\r\n        onlySelf\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        uint256 amountToGiveForOrder = toUint(msg.data, msg.data.length - 32);\r\n\r\n        approveAddress(ERC20_ASSET_PROXY, toAddress(data.takerAssetData, 16));\r\n\r\n        weth.deposit.value(amountToGiveForOrder)();\r\n\r\n        LibFillResults.FillResults memory results = exchange.fillOrder(\r\n            getZeroExOrder(data),\r\n            amountToGiveForOrder,\r\n            data.signature\r\n        );\r\n        require(ERC20SafeTransfer.safeTransfer(toAddress(data.makerAssetData, 16), totlePrimary, results.makerAssetFilledAmount));\r\n\r\n        amountSpentOnOrder = results.takerAssetFilledAmount;\r\n        amountReceivedFromOrder = results.makerAssetFilledAmount;\r\n        /* logger.log(\"Performed buy order on ZeroEx arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder\", amountSpentOnOrder, amountReceivedFromOrder); */\r\n    }\r\n\r\n    /// @notice Perform a sell order at the exchange\r\n    /// @param data LibOrder.Order struct containing order values\r\n    /// @return amountSpentOnOrder the amount that would be spent on the order\r\n    /// @return amountReceivedFromOrder the amount that was received from this order\r\n    function performSellOrder_(\r\n        OrderData data\r\n    )\r\n        public\r\n        onlySelf\r\n        returns (uint256 amountSpentOnOrder, uint256 amountReceivedFromOrder)\r\n    {\r\n        uint256 amountToGiveForOrder = toUint(msg.data, msg.data.length - 32);\r\n        approveAddress(ERC20_ASSET_PROXY, toAddress(data.takerAssetData, 16));\r\n\r\n        LibFillResults.FillResults memory results = exchange.fillOrder(\r\n            getZeroExOrder(data),\r\n            amountToGiveForOrder,\r\n            data.signature\r\n        );\r\n\r\n        weth.withdraw(results.makerAssetFilledAmount);\r\n        totlePrimary.transfer(results.makerAssetFilledAmount);\r\n\r\n        amountSpentOnOrder = results.takerAssetFilledAmount;\r\n        amountReceivedFromOrder = results.makerAssetFilledAmount;\r\n        /* logger.log(\"Performed sell order on ZeroEx arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder\", amountSpentOnOrder, amountReceivedFromOrder); */\r\n    }\r\n\r\n    /// @notice Calculate the result of ((numerator * target) / denominator)\r\n    /// @param numerator the numerator in the equation\r\n    /// @param denominator the denominator in the equation\r\n    /// @param target the target for the equations\r\n    /// @return partialAmount the resultant value\r\n    function getPartialAmount(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(numerator, target), denominator);\r\n    }\r\n\r\n    // @notice Extract an address from a string of bytes\r\n    // @param _bytes a string of at least 20 bytes\r\n    // @param _start the offset of the address within the byte stream\r\n    // @return tempAddress the address encoded in the bytestring beginning at _start\r\n    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toBytes4(bytes _bytes, uint _start) internal pure returns (bytes4) {\r\n        require(_bytes.length >= (_start + 4));\r\n        bytes4 tempBytes4;\r\n\r\n        assembly {\r\n            tempBytes4 := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n        return tempBytes4;\r\n    }\r\n\r\n    // @notice Extract a uint256 from a string of bytes\r\n    // @param _bytes a string of at least 32 bytes\r\n    // @param _start the offset of the uint256 within the byte stream\r\n    // @return tempUint the uint encoded in the bytestring beginning at _start\r\n    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    /*\r\n    *   Payable fallback function\r\n    */\r\n\r\n    /// @notice payable fallback to allow the exchange to return ether directly to this contract\r\n    /// @dev note that only the exchange should be able to send ether to this contract\r\n    function() public payable {\r\n        require(msg.sender == address(weth) || msg.sender == totlePrimary);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"takerAddress\",\"type\":\"address\"},{\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"makerFee\",\"type\":\"uint256\"},{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"name\":\"takerAssetData\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"performSellOrder_\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_totlePrimary\",\"type\":\"address\"}],\"name\":\"setTotle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"errorReporter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selectorProvider\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"takerAddress\",\"type\":\"address\"},{\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"makerFee\",\"type\":\"uint256\"},{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"name\":\"takerAssetData\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"getAmountToGive_\",\"outputs\":[{\"name\":\"amountToGive\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performSellOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"components\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"takerAddress\",\"type\":\"address\"},{\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"makerFee\",\"type\":\"uint256\"},{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"name\":\"takerAssetData\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"staticExchangeChecks_\",\"outputs\":[{\"name\":\"checksPassed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totlePrimary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"components\":[{\"name\":\"makerAddress\",\"type\":\"address\"},{\"name\":\"takerAddress\",\"type\":\"address\"},{\"name\":\"feeRecipientAddress\",\"type\":\"address\"},{\"name\":\"senderAddress\",\"type\":\"address\"},{\"name\":\"makerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"takerAssetAmount\",\"type\":\"uint256\"},{\"name\":\"makerFee\",\"type\":\"uint256\"},{\"name\":\"takerFee\",\"type\":\"uint256\"},{\"name\":\"expirationTimeSeconds\",\"type\":\"uint256\"},{\"name\":\"salt\",\"type\":\"uint256\"},{\"name\":\"makerAssetData\",\"type\":\"bytes\"},{\"name\":\"takerAssetData\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"data\",\"type\":\"tuple\"}],\"name\":\"performBuyOrder_\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"}],\"name\":\"getAmountToGive\",\"outputs\":[{\"name\":\"amountToGive\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"}],\"name\":\"staticExchangeChecks\",\"outputs\":[{\"name\":\"checksPassed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"genericPayload\",\"type\":\"bytes\"},{\"name\":\"amountToGiveForOrder\",\"type\":\"uint256\"}],\"name\":\"performBuyOrder\",\"outputs\":[{\"name\":\"amountSpentOnOrder\",\"type\":\"uint256\"},{\"name\":\"amountReceivedFromOrder\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_exchange\",\"type\":\"address\"},{\"name\":\"selectorProvider\",\"type\":\"address\"},{\"name\":\"totlePrimary\",\"type\":\"address\"},{\"name\":\"_weth\",\"type\":\"address\"},{\"name\":\"errorReporter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ZeroExExchangeHandler","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"0000000000000000000000004f833a24e1f95d70f028921e27040ca56e09ab0b0000000000000000000000005b011899a4c9565b43f3d8fffb583164ebc33a530000000000000000000000009a806ea1755364a327df817e5bd700a2b9bf1c08000000000000000000000000c02aaa39b223fe8d0a0e5c4f27ead9083c756cc200000000000000000000000076b87390400359941561956632bbbe3f42439e32","Library":"","SwarmSource":"bzzr://ddc933030022c73b50e6e1e591f1bc944077029a23da0acb54162a713a23f471"}]}