{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall,\r\n        Create\r\n    }\r\n}\r\n\r\ncontract EtherPaymentFallback {\r\n\r\n    /// @dev Fallback function accepts Ether transactions.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n\r\n    }\r\n}\r\n\r\ncontract Executor is EtherPaymentFallback {\r\n\r\n    event ContractCreation(address newContract);\r\n\r\n    function execute(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else {\r\n            address newContract = executeCreate(data);\r\n            success = newContract != 0;\r\n            emit ContractCreation(newContract);\r\n        }\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeCreate(bytes data)\r\n        internal\r\n        returns (address newContract)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            newContract := create(0, add(data, 0x20), mload(data))\r\n        }\r\n    }\r\n}\r\n\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n\r\n    address public constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address => address) internal modules;\r\n    \r\n    function setupModules(address to, bytes data)\r\n        internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == 0, \"Modules have already been initialized\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != 0)\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != 0 && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        // Module cannot be added twice.\r\n        require(modules[module] == 0, \"Module has already been added\");\r\n        modules[module] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = module;\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != 0 && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        require(modules[prevModule] == address(module), \"Invalid prevModule, module pair provided\");\r\n        modules[prevModule] = modules[module];\r\n        modules[module] = 0;\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes data, Enum.Operation operation)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(modules[msg.sender] != 0, \"Method can only be called from an enabled module\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        // Calculate module count\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        address[] memory array = new address[](moduleCount);\r\n\r\n        // populate return array\r\n        moduleCount = 0;\r\n        currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\ncontract MasterCopy is SelfAuthorized {\r\n  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n  // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address masterCopy;\r\n\r\n  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n  /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != 0, \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n}\r\n\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n        internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == 0, \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\ncontract CreateAndAddModules {\r\n\r\n    /// @dev Function required to compile contract. Gnosis Safe function is called instead.\r\n    /// @param module Not used.\r\n    function enableModule(Module module)\r\n        public\r\n    {\r\n        revert();\r\n    }\r\n\r\n    /// @dev Allows to create and add multiple module in one transaction.\r\n    /// @param proxyFactory Module proxy factory contract.\r\n    /// @param data Modules constructor payload. This is the data for each proxy factory call concatinated. (e.g. <byte_array_len_1><byte_array_data_1><byte_array_len_2><byte_array_data_2>)\r\n    function createAndAddModules(address proxyFactory, bytes data)\r\n        public\r\n    {\r\n        uint256 length = data.length;\r\n        Module module;\r\n        uint256 i = 0;\r\n        while (i < length) {\r\n            // solium-disable-next-line security/no-inline-assembly\r\n            assembly {\r\n                let createBytesLength := mload(add(0x20, add(data, i)))\r\n                let createBytes := add(0x40, add(data, i))\r\n\r\n                let output := mload(0x40)\r\n                if eq(delegatecall(gas, proxyFactory, createBytes, createBytesLength, output, 0x20), 0) { revert(0, 0) }\r\n                module := and(mload(output), 0xffffffffffffffffffffffffffffffffffffffff)\r\n\r\n                // Data is always padded to 32 bytes\r\n                i := add(i, add(0x20, mul(div(add(createBytesLength, 0x1f), 0x20), 0x20)))\r\n            }\r\n            this.enableModule(module);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"proxyFactory\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"createAndAddModules\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"module\",\"type\":\"address\"}],\"name\":\"enableModule\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"CreateAndAddModules","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d82c871c112219982572ba550d0139d109aab04fb60ddac71332df0d5be66dac"}]}