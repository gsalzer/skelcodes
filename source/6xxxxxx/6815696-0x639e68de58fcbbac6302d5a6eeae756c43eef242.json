{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != owner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n* @title -Name Filter- v0.1.9\r\n*/\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.\r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n    internal\r\n    pure\r\n    returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n\r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n\r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n\r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n\r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                // require character is a space\r\n                    _temp[i] == 0x20 ||\r\n                // OR lowercase a-z\r\n                (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                // or 0-9\r\n                (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n\r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;\r\n            }\r\n        }\r\n\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract CelebrityGame is Ownable {\r\n    using SafeMath for *;\r\n    using NameFilter for string;\r\n\r\n    string constant public gameName = \"Celebrity Game\";\r\n\r\n    // fired whenever a card is created\r\n    event LogNewCard(string name, uint256 id);\r\n    // fired whenever a player is registered\r\n    event LogNewPlayer(string name, uint256 id);\r\n\r\n    //just for isStartEnable modifier\r\n    bool private isStart = false;\r\n    uint256 private roundId = 0;\r\n\r\n    struct Card {\r\n        bytes32 name;           // card owner name\r\n        uint256 fame;           // The number of times CARDS were liked\r\n        uint256 fameValue;      // The charge for the current card to be liked once\r\n        uint256 notorious;      // The number of times CARDS were disliked\r\n        uint256 notoriousValue; // The charge for the current card to be disliked once\r\n    }\r\n\r\n    struct CardForPlayer {\r\n        uint256 likeCount;      // The number of times the player likes it\r\n        uint256 dislikeCount;   // The number of times the player disliked it\r\n    }\r\n\r\n    struct CardWinner {\r\n        bytes32  likeWinner;\r\n        bytes32  dislikeWinner;\r\n    }\r\n\r\n    Card[] public cards;\r\n    bytes32[] public players;\r\n\r\n    mapping (uint256 => mapping (uint256 => mapping ( uint256 => CardForPlayer))) public playerCard;      // returns cards of this player like or dislike by playerId and roundId and cardId\r\n    mapping (uint256 => mapping (uint256 => CardWinner)) public cardWinnerMap; // (roundId => (cardId => winner)) returns winner by roundId and cardId\r\n    mapping (uint256 => Card[]) public rounCardMap;                            // returns Card info by roundId\r\n\r\n    mapping (bytes32 => uint256) private plyNameXId;                           // (playerName => Id) returns playerId by playerName\r\n    mapping (bytes32 => uint256) private cardNameXId;                          // (cardName => Id) returns cardId by cardName\r\n    mapping (bytes32 => bool) private cardIsReg;                               // (cardName => cardCount) returns cardCount by cardNameï¼Œjust for createCard function\r\n    mapping (bytes32 => bool) private playerIsReg;                             // (playerName => isRegister) returns registerInfo by playerName, just for registerPlayer funciton\r\n    mapping (uint256 => bool) private cardIdIsReg;                             // (cardId => card info) returns card info by cardId\r\n    mapping (uint256 => bool) private playerIdIsReg;                           // (playerId => id) returns player index of players by playerId\r\n    mapping (uint256 => uint256) private cardIdXSeq;\r\n    mapping (uint256 => uint256) private playerIdXSeq;\r\n\r\n    /**\r\n\t * @dev used to make sure no one can interact with contract until it has been started\r\n\t */\r\n    modifier isStartEnable {\r\n        require(isStart == true);\r\n        _;\r\n    }\r\n\t/**\r\n\t * the contract  precision is 1000\r\n\t */\r\n    constructor() public {\r\n        string[8]  memory names= [\"SatoshiNakamoto\",\"CZ\",\"HeYi\",\"LiXiaolai\",\"GuoHongcai\",\"VitalikButerin\",\"StarXu\",\"ByteMaster\"];\r\n        uint256[8] memory _ids = [uint256(183946248739),536269148721,762415028463,432184367532,398234673241,264398721023,464325189620,217546321806];\r\n        for (uint i = 0; i < 8; i++){\r\n             string  memory _nameString = names[i];\r\n             uint256 _id = _ids[i];\r\n             bytes32 _name = _nameString.nameFilter();\r\n             require(cardIsReg[_name] == false);\r\n             uint256 _seq = cards.push(Card(_name, 1, 1000, 1, 1000)) - 1;\r\n             cardIdXSeq[_id] = _seq;\r\n             cardNameXId[_name] = _id;\r\n             cardIsReg[_name] = true;\r\n            cardIdIsReg[_id] = true;\r\n        }\r\n\r\n    }\r\n    /**\r\n\t * @dev use this function to create card.\r\n\t * - must pay some create fees.\r\n\t * - name must be unique\r\n\t * - max length of 32 characters long\r\n\t * @param _nameString owner desired name for card\r\n\t * @param _id card id\r\n\t * (this might cost a lot of gas)\r\n\t */\r\n    function createCard(string _nameString, uint256 _id) public onlyOwner() {\r\n        require(keccak256(abi.encodePacked(_name)) != keccak256(abi.encodePacked(\"\")));\r\n\r\n        bytes32 _name = _nameString.nameFilter();\r\n        require(cardIsReg[_name] == false);\r\n        uint256 _seq = cards.push(Card(_name, 1, 1000, 1, 1000)) - 1;\r\n        cardIdXSeq[_id] = _seq;\r\n        cardNameXId[_name] = _id;\r\n        cardIsReg[_name] = true;\r\n        cardIdIsReg[_id] = true;\r\n        emit LogNewCard(_nameString, _id);\r\n    }\r\n\r\n    /**\r\n\t * @dev use this function to register player.\r\n\t * - must pay some register fees.\r\n\t * - name must be unique\r\n\t * - name cannot be null\r\n\t * - max length of 32 characters long\r\n\t * @param _nameString team desired name for player\r\n\t * @param _id player id\r\n\t * (this might cost a lot of gas)\r\n\t */\r\n    function registerPlayer(string _nameString, uint256 _id)  external {\r\n        require(keccak256(abi.encodePacked(_name)) != keccak256(abi.encodePacked(\"\")));\r\n\r\n        bytes32 _name = _nameString.nameFilter();\r\n        require(playerIsReg[_name] == false);\r\n        uint256 _seq = players.push(_name) - 1;\r\n        playerIdXSeq[_id] = _seq;\r\n        plyNameXId[_name] = _id;\r\n        playerIsReg[_name] = true;\r\n        playerIdIsReg[_id] = true;\r\n\r\n        emit LogNewPlayer(_nameString, _id);\r\n    }\r\n\r\n    /**\r\n\t * @dev this function for One player likes the CARD once.\r\n\t * @param _cardId must be returned when creating CARD\r\n\t * @param _playerId must be returned when registering player\r\n\t * (this might cost a lot of gas)\r\n\t */\r\n    function likeCelebrity(uint256 _cardId, uint256 _playerId) external isStartEnable {\r\n        require(cardIdIsReg[_cardId] == true, \"sorry create this card first\");\r\n        require(playerIdIsReg[_playerId] == true, \"sorry register the player name first\");\r\n\r\n        Card storage queryCard = cards[cardIdXSeq[_cardId]];\r\n        queryCard.fame = queryCard.fame.add(1);\r\n        queryCard.fameValue = queryCard.fameValue.add(queryCard.fameValue / 100*1000);\r\n\r\n        playerCard[_playerId][roundId][_cardId].likeCount == (playerCard[_playerId][roundId][_cardId].likeCount).add(1);\r\n        cardWinnerMap[roundId][_cardId].likeWinner = players[playerIdXSeq[_playerId]];\r\n    }\r\n\r\n    /**\r\n\t * @dev this function for One player dislikes the CARD once.\r\n\t * @param _cardId must be returned when creating CARD\r\n\t * @param _playerId must be created when registering player\r\n\t * (this might cost a lot of gas)\r\n\t */\r\n    function dislikeCelebrity(uint256 _cardId, uint256 _playerId) external isStartEnable {\r\n        require(cardIdIsReg[_cardId] == true, \"sorry create this card first\");\r\n        require(playerIdIsReg[_playerId] == true, \"sorry register the player name first\");\r\n\r\n        Card storage queryCard = cards[cardIdXSeq[_cardId]];\r\n        queryCard.notorious = queryCard.notorious.add(1);\r\n        queryCard.notoriousValue = queryCard.notoriousValue.add(queryCard.notoriousValue / 100*1000);\r\n\r\n        playerCard[_playerId][roundId][_cardId].dislikeCount == (playerCard[_playerId][roundId][_cardId].dislikeCount).add(1);\r\n        cardWinnerMap[roundId][_cardId].dislikeWinner = players[playerIdXSeq[_playerId]];\r\n    }\r\n\r\n    /**\r\n\t * @dev use this function to reset card properties.\r\n\t * - must be called when game is not started by team.\r\n\t * @param _id must be returned when creating CARD\r\n\t * (this might cost a lot of gas)\r\n\t */\r\n    function reset(uint256 _id) external onlyOwner() {\r\n        require(isStart == false);\r\n\r\n        Card storage queryCard = cards[cardIdXSeq[_id]];\r\n        queryCard.fame = 1;\r\n        queryCard.fameValue = 1000;\r\n        queryCard.notorious = 1;\r\n        queryCard.notoriousValue = 1000;\r\n    }\r\n\r\n    /**\r\n\t * @dev use this function to start the game.\r\n\t * - must be called by owner.\r\n\t * (this might cost a lot of gas)\r\n\t */\r\n    function gameStart() external onlyOwner() {\r\n        isStart = true;\r\n        roundId = roundId.add(1);\r\n    }\r\n\r\n    /**\r\n\t * @dev use this function to end the game. Just for emergency control by owner\r\n\t * (this might cost a lot of gas)\r\n\t */\r\n    function gameEnd() external onlyOwner() {\r\n        isStart = false;\r\n        rounCardMap[roundId] = cards;\r\n    }\r\n\r\n    /**\r\n\t * @dev use this function to get CARDS count\r\n\t * @return Total all CARDS in the current game\r\n\t */\r\n    function getCardsCount() public view returns(uint256) {\r\n        return cards.length;\r\n    }\r\n\r\n    /**\r\n\t * @dev use this function to get CARDS id by its name.\r\n\t * @param _nameString must be created when creating CARD\r\n\t * @return the card id\r\n\t */\r\n    function getCardId(string _nameString) public view returns(uint256) {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        require(cardIsReg[_name] == true, \"sorry create this card first\");\r\n        return cardNameXId[_name];\r\n    }\r\n\r\n    /**\r\n\t * @dev use this function to get player id by the name.\r\n\t * @param _nameString must be created when creating CARD\r\n\t * @return the player id\r\n\t */\r\n    function getPlayerId(string _nameString) public view returns(uint256) {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        require(playerIsReg[_name] == true, \"sorry register the player name first\");\r\n        return plyNameXId[_name];\r\n    }\r\n\r\n    /**\r\n\t * @dev use this function to get player bet count.\r\n\t * @param _playerName must be created when registering player\r\n\t * @param _roundId must be a game that has already started\r\n\t * @param _cardName the player id must be created when creating CARD\r\n\t * @return likeCount\r\n\t * @return dislikeCount\r\n\t */\r\n    function getPlayerBetCount(string _playerName, uint256 _roundId, string _cardName) public view returns(uint256 likeCount, uint256 dislikeCount) {\r\n        bytes32 _cardNameByte = _cardName.nameFilter();\r\n        require(cardIsReg[_cardNameByte] == false);\r\n\r\n        bytes32 _playerNameByte = _playerName.nameFilter();\r\n        require(playerIsReg[_playerNameByte] == false);\r\n        return (playerCard[plyNameXId[_playerNameByte]][_roundId][cardNameXId[_cardNameByte]].likeCount, playerCard[plyNameXId[_playerNameByte]][_roundId][cardNameXId[_cardNameByte]].dislikeCount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cardWinnerMap\",\"outputs\":[{\"name\":\"likeWinner\",\"type\":\"bytes32\"},{\"name\":\"dislikeWinner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"gameEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCardsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"reset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"gameStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"registerPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cardId\",\"type\":\"uint256\"},{\"name\":\"_playerId\",\"type\":\"uint256\"}],\"name\":\"dislikeCelebrity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"createCard\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"getCardId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cards\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"fame\",\"type\":\"uint256\"},{\"name\":\"fameValue\",\"type\":\"uint256\"},{\"name\":\"notorious\",\"type\":\"uint256\"},{\"name\":\"notoriousValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounCardMap\",\"outputs\":[{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"fame\",\"type\":\"uint256\"},{\"name\":\"fameValue\",\"type\":\"uint256\"},{\"name\":\"notorious\",\"type\":\"uint256\"},{\"name\":\"notoriousValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cardId\",\"type\":\"uint256\"},{\"name\":\"_playerId\",\"type\":\"uint256\"}],\"name\":\"likeCelebrity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"getPlayerId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerName\",\"type\":\"string\"},{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"_cardName\",\"type\":\"string\"}],\"name\":\"getPlayerBetCount\",\"outputs\":[{\"name\":\"likeCount\",\"type\":\"uint256\"},{\"name\":\"dislikeCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerCard\",\"outputs\":[{\"name\":\"likeCount\",\"type\":\"uint256\"},{\"name\":\"dislikeCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogNewCard\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"LogNewPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CelebrityGame","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://00a04526b794e11f8a1e19c5ffd942c6230694cf452c9a905198fe809f4e3b62"}]}