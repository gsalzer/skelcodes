{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal constant returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  // state variables\r\n  address owner;\r\n\r\n  // modifiers\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  // constructor\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n  function transferOwnership(address newOwner) onlyOwner {\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Transaction is Ownable {\r\n  // custom types\r\n  struct TransactionNeoPlace {\r\n    uint id;\r\n    address seller;\r\n    address buyer;\r\n    bytes16 itemId;\r\n    bytes8 typeItem;\r\n    string location;\r\n    string pictureHash;\r\n    bytes16 receiptHash;\r\n    string comment;\r\n    bytes8 status;\r\n    uint256 _price;\r\n  }\r\n\r\n  // state variables\r\n  mapping(uint => TransactionNeoPlace) public transactions;\r\n  mapping(bytes16 => uint256) public fundsLocked;\r\n\r\n  uint transactionCounter;\r\n\r\n  // events\r\n  event BuyItem(\r\n    uint indexed _id,\r\n    bytes16 indexed _itemId,\r\n    address _seller,\r\n    address _buyer,\r\n    uint256 _price\r\n  );\r\n\r\n  function kill() public onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  // fetch the number of transactions in the contract\r\n  function getNumberOfTransactions() public view returns (uint) {\r\n    return transactionCounter;\r\n  }\r\n\r\n  // fetch and return all sales of the seller\r\n  function getSales() public view returns (uint[]) {\r\n    // prepare output array\r\n    uint[] memory transactionIds = new uint[](transactionCounter);\r\n\r\n    uint numberOfSales = 0;\r\n\r\n    // iterate over transactions\r\n    for(uint i = 1; i <= transactionCounter; i++) {\r\n      // keep the ID if the transaction owns to the seller\r\n      if(transactions[i].seller == msg.sender) {\r\n        transactionIds[numberOfSales] = transactions[i].id;\r\n        numberOfSales++;\r\n      }\r\n    }\r\n\r\n    // copy the transactionIds array into a smaller getSales array\r\n    uint[] memory sales = new uint[](numberOfSales);\r\n    for(uint j = 0; j < numberOfSales; j++) {\r\n      sales[j] = transactionIds[j];\r\n    }\r\n    return sales;\r\n  }\r\n\r\n  // fetch and return all purchases of the buyer\r\n  function getPurchases() public view returns (uint[]) {\r\n    // prepare output array\r\n    uint[] memory transactionIds = new uint[](transactionCounter);\r\n\r\n    uint numberOfBuy = 0;\r\n\r\n    // iterate over transactions\r\n    for(uint i = 1; i <= transactionCounter; i++) {\r\n      // keep the ID if the transaction owns to the seller\r\n      if(transactions[i].buyer == msg.sender) {\r\n        transactionIds[numberOfBuy] = transactions[i].id;\r\n        numberOfBuy++;\r\n      }\r\n    }\r\n\r\n    // copy the transactionIds array into a smaller getBuy array\r\n    uint[] memory buy = new uint[](numberOfBuy);\r\n    for(uint j = 0; j < numberOfBuy; j++) {\r\n      buy[j] = transactionIds[j];\r\n    }\r\n    return buy;\r\n  }\r\n\r\n  // new transaction / buy item\r\n  function buyItem(address _seller, bytes16 _itemId, bytes8 _typeItem, string _location, string _pictureHash, string _comment, bytes8 _status, uint256 _price) payable public {\r\n    // address not null\r\n    require(_seller != 0x0);\r\n    // seller don't allow to buy his own item\r\n    require(msg.sender != _seller);\r\n\r\n    require(_itemId.length > 0);\r\n    require(_typeItem.length > 0);\r\n    require(bytes(_location).length > 0);\r\n    require(bytes(_pictureHash).length > 0);\r\n    //require(bytes(_comment).length > 0);\r\n\r\n    require(msg.value == _price);\r\n\r\n\r\n    // lock and put the funds in escrow\r\n    //_seller.transfer(msg.value);\r\n    fundsLocked[_itemId]=fundsLocked[_itemId] + _price;\r\n\r\n    // new transaction\r\n    transactionCounter++;\r\n\r\n    // store the new transaction\r\n    transactions[transactionCounter] = TransactionNeoPlace(\r\n      transactionCounter,\r\n      _seller,\r\n      msg.sender,\r\n      _itemId,\r\n      _typeItem,\r\n      _location,\r\n      _pictureHash,\r\n      \"\",\r\n      _comment,\r\n      _status,\r\n      _price\r\n    );\r\n\r\n    // trigger the new transaction\r\n    BuyItem(transactionCounter, _itemId, _seller, msg.sender, _price);\r\n  }\r\n\r\n  // send additional funds\r\n  //TODO merge with unlockFunds\r\n  function sendAdditionalFunds(address _seller, bytes16 _itemId, uint256 _price) payable public {\r\n    // address not null\r\n    require(_seller != 0x0);\r\n    // seller don't allow to buy his own item\r\n    require(msg.sender != _seller);\r\n\r\n    require(_itemId.length > 0);\r\n\r\n    require(msg.value == _price);\r\n\r\n    for(uint i = 0; i <= transactionCounter; i++) {\r\n      if(transactions[i].itemId == _itemId) {\r\n\r\n        require(msg.sender == transactions[i].buyer);\r\n        require(stringToBytes8(\"paid\") == transactions[i].status);\r\n        address seller = transactions[i].seller;\r\n        transactions[i]._price = transactions[i]._price + msg.value;\r\n\r\n        //transfer fund from client to vendor\r\n        seller.transfer(msg.value);\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function unlockFunds(bytes16 _itemId) public {\r\n\r\n    for(uint i = 0; i <= transactionCounter; i++) {\r\n      if(transactions[i].itemId == _itemId) {\r\n\r\n        require(msg.sender == transactions[i].buyer);\r\n        require(stringToBytes8(\"paid\") != transactions[i].status);\r\n        address buyer = transactions[i].buyer;\r\n        address seller = transactions[i].seller;\r\n        uint256 priceTransaction = transactions[i]._price;\r\n\r\n        require(fundsLocked[_itemId]>0);\r\n        fundsLocked[_itemId]=fundsLocked[_itemId] - (priceTransaction);\r\n\r\n        //transfer fund from client to vendor\r\n        seller.transfer(priceTransaction);\r\n\r\n        transactions[i].status = stringToBytes8('paid');\r\n\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n   function sendAmount(address seller) payable public {\r\n      // address not null\r\n      require(seller != 0x0);\r\n      // seller don't allow to buy his own item\r\n      require(msg.sender != seller);\r\n\r\n      seller.transfer(msg.value);\r\n   }\r\n\r\n  function stringToBytes8(string memory source) returns (bytes8 result) {\r\n    bytes memory tempEmptyStringTest = bytes(source);\r\n    if (tempEmptyStringTest.length == 0) {\r\n      return 0x0;\r\n    }\r\n\r\n    assembly {\r\n      result := mload(add(source, 8))\r\n    }\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Ownable","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://bad0cd5b97c4e46112f0ffe8fab6098c22204f4a50ed08abd0d9b61ce79722d8"}]}