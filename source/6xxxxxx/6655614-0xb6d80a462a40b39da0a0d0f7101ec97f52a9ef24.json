{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n// 문자열 처리 유틸리티\r\nlibrary StringUtil {\r\n\t\r\n\t// 두 문자열을 합칩니다.\r\n\tfunction concat(string a, string b) internal pure returns (string c) {\r\n\t\t\r\n\t\tbytes memory ba = bytes(a);\r\n\t\tbytes memory bb = bytes(b);\r\n\t\tbytes memory bc = bytes(new string(ba.length + bb.length));\r\n\t\t\r\n\t\tuint256 i = 0;\r\n\t\tuint256 j = 0;\r\n\t\t\r\n\t\tfor (j = 0; j < ba.length; j += 1) {\r\n\t\t\tbc[i] = ba[j];\r\n\t\t\ti += 1;\r\n\t\t}\r\n\t\t\r\n\t\tfor (j = 0; j < bb.length; j += 1) {\r\n\t\t\tbc[i] = bb[j];\r\n\t\t\ti += 1;\r\n\t\t}\r\n\t\t\r\n\t\treturn string(bc);\r\n    }\r\n\t\r\n\t// uint256를 문자열로 변경합니다.\r\n\tfunction uint256ToString(uint256 i) internal pure returns (string str) {\r\n        if (i == 0) {\r\n        \treturn \"0\";\r\n        }\r\n        \r\n        uint256 j = i;\r\n        uint256 length;\r\n        while (j != 0){\r\n            length += 1;\r\n            j /= 10;\r\n        }\r\n        \r\n        bytes memory bstr = new bytes(length);\r\n        uint256 k = length - 1;\r\n        while (i != 0){\r\n            bstr[k] = byte(48 + i % 10);\r\n            i /= 10;\r\n            k -= 1;\r\n        }\r\n        \r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n// Ether Fairy의 기본적인 내용을 담고있는 계약\r\ncontract EtherFairyBase is ERC721Metadata {\r\n\t\r\n\t// 토큰 정보\r\n\tstring constant public NAME = \"Ether Fairy\";\r\n\tstring constant public SYMBOL = \"FAIRY\";\r\n\tstring public tokenMetadataBaseURI = \"https://etherfairy.com/api/tokenmetadata/\";\r\n\t\r\n\t// 요정 원본의 가격\r\n\tuint256 public fairyOriginPrice = 0.05 ether;\r\n\t\r\n\t// 임의 레벨업 가격\r\n\tuint256 public customLevelUpPrice = 0.01 ether;\r\n\t\r\n\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격\r\n\tuint256 public increasePointPricePerPoint = 0.01 ether;\r\n\t\r\n\t// 요정 정보\r\n\tstruct Fairy {\r\n\t\t\r\n\t\t// 회사 서버에 저장된 요정 원본의 ID\r\n\t\tstring fairyOriginId;\r\n\t\t\r\n\t\t// 요정 디자이너의 지갑\r\n\t\taddress designer;\r\n\t\t\r\n\t\t// 요정의 이름\r\n\t\tstring name;\r\n\t\t\r\n\t\t// 탄생 시간\r\n\t\tuint256 birthTime;\r\n\t\t\r\n\t\t// 소유주에 의해 추가된 레벨\r\n\t\tuint256 appendedLevel;\r\n\t\t\r\n\t\t// 기본 속성에 대한 레벨 당 증가 포인트들\r\n\t\tuint256 hpPointPerLevel;\r\n\t\tuint256 attackPointPerLevel;\r\n\t\tuint256 defencePointPerLevel;\r\n\t\tuint256 agilityPointPerLevel;\r\n\t\tuint256 dexterityPointPerLevel;\r\n\t\t\r\n\t\t// 원소 속성에 대한 레벨 당 증가 포인트들\r\n\t\tuint256 firePointPerLevel;\r\n\t\tuint256 waterPointPerLevel;\r\n\t\tuint256 windPointPerLevel;\r\n\t\tuint256 earthPointPerLevel;\r\n\t\tuint256 lightPointPerLevel;\r\n\t\tuint256 darkPointPerLevel;\r\n\t}\r\n\t\r\n\t// 요정들의 저장소\r\n\tFairy[] internal fairies;\r\n\t\r\n\tfunction getFairyCount() view public returns (uint256) {\r\n\t\treturn fairies.length;\r\n\t}\r\n\t\r\n\t// 원본 ID에 해당하는 요정의 개수를 반환합니다.\r\n\tfunction getFairyCountByOriginId(string fairyOriginId) view public returns (uint256) {\r\n\t\tbytes32 hash = keccak256(bytes(fairyOriginId));\r\n\t\t\r\n\t\tuint256 fairyCount = 0;\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\tif (keccak256(bytes(fairies[i].fairyOriginId)) == hash) {\r\n\t\t\t\tfairyCount += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyCount;\r\n\t}\r\n\t\r\n\t// 원본 ID에 해당하는 요정의 ID 목록을 반환합니다.\r\n\tfunction getFairyIdsByOriginId(string fairyOriginId) view public returns (uint256[]) {\r\n\t\tbytes32 hash = keccak256(bytes(fairyOriginId));\r\n\t\t\r\n\t\tuint256[] memory fairyIds = new uint256[](getFairyCountByOriginId(fairyOriginId));\r\n\t\tuint256 j = 0;\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\tif (keccak256(bytes(fairies[i].fairyOriginId)) == hash) {\r\n\t\t\t\tfairyIds[j] = i;\r\n\t\t\t\tj += 1;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 소유주들 주소\r\n\taddress[] public masters;\r\n\t\r\n\tfunction getMasterCount() view public returns (uint256) {\r\n\t\treturn masters.length;\r\n\t}\r\n\t\r\n\t// 소유주가 이미 존재하는지\r\n\tmapping(address => bool) internal masterToIsExisted;\r\n\t\r\n\t// 소유주가 차단되었는지\r\n\tmapping(address => bool) public masterToIsBlocked;\r\n\t\r\n\t// 요정이 차단되었는지\r\n\tmapping(uint256 => bool) public fairyIdToIsBlocked;\r\n\t\r\n\t// 회사의 지갑 주소\r\n\taddress public company;\r\n\t\r\n\t// 공식 마켓 계약 주소\r\n\taddress public officialMarket;\r\n\t\r\n\tconstructor() public {\r\n\t\t// 계약 생성자를 초기 회사 및 공식 마켓 주소로 등록\r\n\t\tcompany = msg.sender;\r\n\t\tofficialMarket = msg.sender;\r\n\t}\r\n\t\r\n\t// 서비스가 일시중지 상태인지\r\n\tbool public servicePaused = false;\r\n\t\r\n\t// 서비스가 구동중일때만\r\n\tmodifier whenServiceRunning() {\r\n\t\trequire(servicePaused != true);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t// 서비스가 일시정지 상태일때만\r\n\tmodifier whenServicePaused() {\r\n\t\trequire(servicePaused == true);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t// 차단된 소유주가 아닐 경우에만\r\n\tmodifier whenNotBlocked() {\r\n\t\t// 회사는 차단 불가\r\n\t\trequire(msg.sender == company || masterToIsBlocked[msg.sender] != true);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t// 차단된 요정이 아닐 경우에만\r\n\tmodifier whenNotBlockedFairy(uint256 fairyId) {\r\n\t\t// 회사는 차단 불가\r\n\t\trequire(msg.sender == company || fairyIdToIsBlocked[fairyId] != true);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t// 주소를 잘못 사용하는 것인지 체크\r\n\tfunction checkAddressMisused(address target) internal view returns (bool) {\r\n\t\treturn\r\n\t\t\ttarget == address(0) ||\r\n\t\t\ttarget == address(this);\r\n\t}\r\n\t\r\n\t//ERC721Metadata: 토큰의 이름 반환\r\n\tfunction name() view external returns (string) {\r\n\t\treturn NAME;\r\n\t}\r\n\t\r\n\t//ERC721Metadata: 토큰의 심볼 반환\r\n\tfunction symbol() view external returns (string) {\r\n\t\treturn SYMBOL;\r\n\t}\r\n\t\r\n\t//ERC721Metadata: 요정 정보의 메타데이터를 가져오는 경로를 반환합니다.\r\n\tfunction tokenURI(uint256 fairyId) view external returns (string) {\r\n\t\treturn StringUtil.concat(tokenMetadataBaseURI, StringUtil.uint256ToString(fairyId));\r\n\t}\r\n}\r\n\r\n// Ether Fairy를 운영하는 회사에서 사용하는 기능들\r\ncontract EtherFairyCompany is EtherFairyBase {\r\n\t\r\n\t// 소유권 이전 이벤트\r\n\tevent TransferOwnership(address oldCompany, address newCompany);\r\n\t\r\n\t// 서비스를 일시중지하거나 재개하면 발생하는 이벤트\r\n\tevent PauseService();\r\n\tevent ResumeService();\r\n\t\r\n\t// 기타 이벤트\r\n\tevent ChangeFairyOriginPrice(uint256 price);\r\n\tevent ChangeCustomLevelUpPrice(uint256 price);\r\n\tevent ChangeIncreasePointPricePerPoint(uint256 price);\r\n\tevent ChangeTokenMetadataBaseURI(string tokenMetadataBaseURI);\r\n\tevent ChangeOfficialMarket(address officialMarket);\r\n\tevent BlockMaster(address masterToBlock);\r\n\tevent BlockFairy(uint256 fairyIdToBlock);\r\n\tevent UnblockMaster(address masterToUnlock);\r\n\tevent UnblockFairy(uint256 fairyIdToUnblock);\r\n\t\r\n\t// 회사만 처리 가능\r\n\tmodifier onlyCompany {\r\n\t\trequire(msg.sender == company);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t// 소유권을 이전합니다.\r\n\tfunction transferOwnership(address newCompany) onlyCompany public {\r\n\t\taddress oldCompany = company;\r\n\t\tcompany = newCompany;\r\n\t\temit TransferOwnership(oldCompany, newCompany);\r\n\t}\r\n\t\r\n\t// 서비스의 작동을 중지합니다.\r\n\tfunction pauseService() onlyCompany whenServiceRunning public {\r\n\t\tservicePaused = true;\r\n\t\temit PauseService();\r\n\t}\r\n\t\r\n\t// 서비스를 재개합니다.\r\n\tfunction resumeService() onlyCompany whenServicePaused public {\r\n\t\tservicePaused = false;\r\n\t\temit ResumeService();\r\n\t}\r\n\t\r\n\t// 요정 원본의 가격을 변경합니다.\r\n\tfunction changeFairyOriginPrice(uint256 newFairyOriginPrice) onlyCompany public {\r\n\t\tfairyOriginPrice = newFairyOriginPrice;\r\n\t\temit ChangeFairyOriginPrice(newFairyOriginPrice);\r\n\t}\r\n\t\r\n\t// 임의 레벨업 가격을 변경합니다.\r\n\tfunction changeCustomLevelUpPrice(uint256 newCustomLevelUpPrice) onlyCompany public {\r\n\t\tcustomLevelUpPrice = newCustomLevelUpPrice;\r\n\t\temit ChangeCustomLevelUpPrice(newCustomLevelUpPrice);\r\n\t}\r\n\t\r\n\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격을 변경합니다.\r\n\tfunction changeIncreasePointPricePerPoint(uint256 newIncreasePointPricePerPoint) onlyCompany public {\r\n\t\tincreasePointPricePerPoint = newIncreasePointPricePerPoint;\r\n\t\temit ChangeIncreasePointPricePerPoint(newIncreasePointPricePerPoint);\r\n\t}\r\n\t\r\n\t// tokenMetadataBaseURI을 변경합니다.\r\n\tfunction changeTokenMetadataBaseURI(string newTokenMetadataBaseURI) onlyCompany public {\r\n\t\ttokenMetadataBaseURI = newTokenMetadataBaseURI;\r\n\t\temit ChangeTokenMetadataBaseURI(newTokenMetadataBaseURI);\r\n\t}\r\n\t\r\n\t// 공식 마켓 계약을 변경합니다.\r\n\tfunction changeOfficialMarket(address newOfficialMarket) onlyCompany public {\r\n\t\tofficialMarket = newOfficialMarket;\r\n\t\temit ChangeOfficialMarket(newOfficialMarket);\r\n\t}\r\n\t\r\n\t// 특정 소유주를 차단합니다.\r\n\tfunction blockMaster(address masterToBlock) onlyCompany public {\r\n\t\tmasterToIsBlocked[masterToBlock] = true;\r\n\t\temit BlockMaster(masterToBlock);\r\n\t}\r\n\t\r\n\t// 특정 요정을 차단합니다.\r\n\tfunction blockFairy(uint256 fairyIdToBlock) onlyCompany public {\r\n\t\tfairyIdToIsBlocked[fairyIdToBlock] = true;\r\n\t\temit BlockFairy(fairyIdToBlock);\r\n\t}\r\n\t\r\n\t// 소유주 차단을 해제합니다.\r\n\tfunction unblockMaster(address masterToUnlock) onlyCompany public {\r\n\t\tdelete masterToIsBlocked[masterToUnlock];\r\n\t\temit UnblockMaster(masterToUnlock);\r\n\t}\r\n\t\r\n\t// 요정 차단을 해제합니다.\r\n\tfunction unblockFairy(uint256 fairyIdToUnblock) onlyCompany public {\r\n\t\tdelete fairyIdToIsBlocked[fairyIdToUnblock];\r\n\t\temit UnblockFairy(fairyIdToUnblock);\r\n\t}\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n// 숫자 계산 시 오버플로우 문제를 방지하기 위한 라이브러리\r\nlibrary SafeMath {\r\n\t\r\n\tfunction add(uint256 a, uint256 b) pure internal returns (uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\tfunction sub(uint256 a, uint256 b) pure internal returns (uint256 c) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\t\r\n\tfunction mul(uint256 a, uint256 b) pure internal returns (uint256 c) {\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\t\r\n\tfunction div(uint256 a, uint256 b) pure internal returns (uint256 c) {\r\n\t\treturn a / b;\r\n\t}\r\n}\r\n\r\n// 요정 소유권 관련 기능\r\ncontract FairyOwnership is EtherFairyBase, ERC721 {\r\n\tusing SafeMath for uint256;\r\n\t\r\n\t// 요정의 소유주 정보\r\n\tmapping(uint256 => address) public fairyIdToMaster;\r\n\t\r\n\t// 소유주의 요정 ID 목록 정보\r\n\tmapping(address => uint256[]) public masterToFairyIds;\r\n\t\r\n\t// 요정의 요정 ID 목록에서의 index 정보\r\n\tmapping(uint256 => uint256) internal fairyIdToFairyIdsIndex;\r\n\t\r\n\t// 요정 거래 권한이 승인된 지갑 정보\r\n\tmapping(uint256 => address) private fairyIdToApproved;\r\n\t\r\n\t// 오퍼레이터가 승인되었는지에 대한 정보\r\n\tmapping(address => mapping(address => bool)) private masterToOperatorToIsApprovedForAll;\r\n\t\r\n\t// 요정 소유주만\r\n\tmodifier onlyMasterOf(uint256 fairyId) {\r\n\t\trequire(msg.sender == ownerOf(fairyId));\r\n\t\t_;\r\n\t}\r\n\t\r\n\t// 승인된 지갑만\r\n\tmodifier onlyApprovedOf(uint256 fairyId) {\r\n\t\trequire(\r\n\t\t\tmsg.sender == ownerOf(fairyId) ||\r\n\t\t\tmsg.sender == getApproved(fairyId) ||\r\n\t\t\tisApprovedForAll(ownerOf(fairyId), msg.sender) == true ||\r\n\t\t\tmsg.sender == officialMarket\r\n\t\t);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t//ERC721: 요정의 개수를 가져옵니다.\r\n\tfunction balanceOf(address master) view public returns (uint256) {\r\n\t\t// 주소 오용 차단\r\n\t\trequire(checkAddressMisused(master) != true);\r\n\t\treturn masterToFairyIds[master].length;\r\n\t}\r\n\t\r\n\t//ERC721: 요정의 소유주 지갑 주소를 가져옵니다.\r\n\tfunction ownerOf(uint256 fairyId) view public returns (address) {\r\n\t\taddress master = fairyIdToMaster[fairyId];\r\n\t\trequire(checkAddressMisused(master) != true);\r\n\t\treturn master;\r\n\t}\r\n\t\r\n\t// 주어진 주소가 스마트 계약인지 확인합니다.\r\n\tfunction checkIsSmartContract(address addr) view private returns (bool) {\r\n\t\tuint32 size;\r\n\t\tassembly { size := extcodesize(addr) }\r\n\t\treturn size > 0;\r\n\t}\r\n\t\r\n\t//ERC721: 요정을 받는 대상이 스마트 계약인 경우, onERC721Received 함수를 실행합니다.\r\n\tfunction safeTransferFrom(address from, address to, uint256 fairyId, bytes data) whenServiceRunning payable external {\r\n\t\ttransferFrom(from, to, fairyId);\r\n\t\tif (checkIsSmartContract(to) == true) {\r\n\t\t\t// ERC721TokenReceiver\r\n\t\t\trequire(ERC721TokenReceiver(to).onERC721Received(msg.sender, from, fairyId, data) == 0x150b7a02);\r\n\t\t}\r\n\t}\r\n\t\r\n\t//ERC721: 요정을 받는 대상이 스마트 계약인 경우, onERC721Received 함수를 실행합니다.\r\n\tfunction safeTransferFrom(address from, address to, uint256 fairyId) whenServiceRunning payable external {\r\n\t\ttransferFrom(from, to, fairyId);\r\n\t\tif (checkIsSmartContract(to) == true) {\r\n\t\t\t// ERC721TokenReceiver\r\n\t\t\trequire(ERC721TokenReceiver(to).onERC721Received(msg.sender, from, fairyId, \"\") == 0x150b7a02);\r\n\t\t}\r\n\t}\r\n\t\r\n\t//ERC721: 요정을 이전합니다.\r\n\tfunction transferFrom(address from, address to, uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyApprovedOf(fairyId) payable public {\r\n\t\t// 주소 오용 차단\r\n\t\trequire(checkAddressMisused(to) != true);\r\n\t\t\r\n\t\trequire(from == ownerOf(fairyId));\r\n\t\trequire(to != ownerOf(fairyId));\r\n\t\t\r\n\t\t// 거래 권한 제거\r\n\t\tdelete fairyIdToApproved[fairyId];\r\n\t\temit Approval(from, 0, fairyId);\r\n\t\t\r\n\t\t// 기존 소유주로부터 요정 제거\r\n\t\tuint256 index = fairyIdToFairyIdsIndex[fairyId];\r\n\t\tuint256 lastIndex = balanceOf(from).sub(1);\r\n\t\t\r\n\t\tuint256 lastFairyId = masterToFairyIds[from][lastIndex];\r\n\t\tmasterToFairyIds[from][index] = lastFairyId;\r\n\t\t\r\n\t\tdelete masterToFairyIds[from][lastIndex];\r\n\t\tmasterToFairyIds[from].length -= 1;\r\n\t\t\r\n\t\tfairyIdToFairyIdsIndex[lastFairyId] = index;\r\n\t\t\r\n\t\t// 요정 이전\r\n\t\tfairyIdToMaster[fairyId] = to;\r\n\t\tfairyIdToFairyIdsIndex[fairyId] = masterToFairyIds[to].push(fairyId).sub(1);\r\n\t\t\r\n\t\temit Transfer(from, to, fairyId);\r\n\t}\r\n\t\r\n\t//ERC721: 특정 계약에 거래 권한을 부여합니다.\r\n\tfunction approve(address approved, uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable external {\r\n\t\t\r\n\t\taddress master = ownerOf(fairyId);\r\n\t\t\r\n\t\t// 주소 오용 차단\r\n\t\trequire(approved != master);\r\n\t\trequire(checkAddressMisused(approved) != true);\r\n\t\t\r\n\t\tfairyIdToApproved[fairyId] = approved;\r\n\t\temit Approval(master, approved, fairyId);\r\n\t}\r\n\t\r\n\t//ERC721: 오퍼레이터에게 거래 권한을 부여하거나 뺏습니다.\r\n\tfunction setApprovalForAll(address operator, bool isApproved) whenServiceRunning whenNotBlocked external {\r\n\t\t// 주소 오용 차단\r\n\t\trequire(operator != msg.sender);\r\n\t\trequire(checkAddressMisused(operator) != true);\r\n\t\t\r\n\t\tif (isApproved == true) {\r\n\t\t\tmasterToOperatorToIsApprovedForAll[msg.sender][operator] = true;\r\n\t\t} else {\r\n\t\t\tdelete masterToOperatorToIsApprovedForAll[msg.sender][operator];\r\n\t\t}\r\n\t\t\r\n\t\temit ApprovalForAll(msg.sender, operator, isApproved);\r\n\t}\r\n\t\r\n\t//ERC721: 요정 거래 권한이 승인된 지갑 주소를 가져옵니다.\r\n\tfunction getApproved(uint256 fairyId) public view returns (address) {\r\n\t\treturn fairyIdToApproved[fairyId];\r\n\t}\r\n\t\r\n\t//ERC721: 오퍼레이터가 거래 권한을 가지고 있는지 확인합니다.\r\n\tfunction isApprovedForAll(address master, address operator) view public returns (bool) {\r\n\t\treturn masterToOperatorToIsApprovedForAll[master][operator] == true;\r\n\t}\r\n}\r\n\r\n// 돈을 지불하고 요정을 업그레이드 하는 기능들\r\ncontract FairyPayToUpgrade is FairyOwnership {\r\n\t\r\n    event CustomLevelUp(uint256 indexed fairyId);\r\n    event IncreaseHPPointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseAttackPointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseDefencePointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseAgilityPointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseDexterityPointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseFirePointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseWaterPointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseWindPointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseEarthPointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseLightPointPerLevel(uint256 indexed fairyId);\r\n    event IncreaseDarkPointPerLevel(uint256 indexed fairyId);\r\n\r\n\t// 돈을 지불하고 레벨업 합니다.\r\n\tfunction levelUpFairy(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\t// 임의 레벨업 가격과 비교합니다.\r\n\t\trequire(msg.value == customLevelUpPrice);\r\n\t\t\r\n\t\t// 요정의 레벨을 올립니다.\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\tfairy.appendedLevel = fairy.appendedLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit CustomLevelUp(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 HP 증가 포인트를 올립니다.\r\n\tfunction increaseHPPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.hpPointPerLevel);\r\n\t\t\r\n\t\t// 레벨 당 HP 증가 포인트를 올립니다.\r\n\t\tfairy.hpPointPerLevel = fairy.hpPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseHPPointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 공격 증가 포인트를 올립니다.\r\n\tfunction increaseAttackPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.attackPointPerLevel);\r\n\t\t\r\n\t\t// 레벨 당 공격 증가 포인트를 올립니다.\r\n\t\tfairy.attackPointPerLevel = fairy.attackPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseAttackPointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 방어 증가 포인트를 올립니다.\r\n\tfunction increaseDefencePointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.defencePointPerLevel);\r\n\t\t\r\n\t\t// 레벨 당 방어 증가 포인트를 올립니다.\r\n\t\tfairy.defencePointPerLevel = fairy.defencePointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseDefencePointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 민첩 증가 포인트를 올립니다.\r\n\tfunction increaseAgilityPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.agilityPointPerLevel);\r\n\t\t\r\n\t\t// 레벨 당 민첩 증가 포인트를 올립니다.\r\n\t\tfairy.agilityPointPerLevel = fairy.agilityPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseAgilityPointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 재치 증가 포인트를 올립니다.\r\n\tfunction increaseDexterityPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.dexterityPointPerLevel);\r\n\t\t\r\n\t\t// 레벨 당 재치 증가 포인트를 올립니다.\r\n\t\tfairy.dexterityPointPerLevel = fairy.dexterityPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseDexterityPointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 불 속성 증가 포인트를 올립니다.\r\n\tfunction increaseFirePointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.firePointPerLevel.add(1));\r\n\t\t\r\n\t\t// 레벨 당 불 속성 증가 포인트를 올립니다.\r\n\t\tfairy.firePointPerLevel = fairy.firePointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseFirePointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 물 속성 증가 포인트를 올립니다.\r\n\tfunction increaseWaterPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.waterPointPerLevel.add(1));\r\n\t\t\r\n\t\t// 레벨 당 물 속성 증가 포인트를 올립니다.\r\n\t\tfairy.waterPointPerLevel = fairy.waterPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseWaterPointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 바람 속성 증가 포인트를 올립니다.\r\n\tfunction increaseWindPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.windPointPerLevel.add(1));\r\n\t\t\r\n\t\t// 레벨 당 바람 속성 증가 포인트를 올립니다.\r\n\t\tfairy.windPointPerLevel = fairy.windPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseWindPointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 대지 속성 증가 포인트를 올립니다.\r\n\tfunction increaseEarthPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.earthPointPerLevel.add(1));\r\n\t\t\r\n\t\t// 레벨 당 대지 속성 증가 포인트를 올립니다.\r\n\t\tfairy.earthPointPerLevel = fairy.earthPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseEarthPointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 빛 속성 증가 포인트를 올립니다.\r\n\tfunction increaseLightPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.lightPointPerLevel.add(1));\r\n\t\t\r\n\t\t// 레벨 당 빛 속성 증가 포인트를 올립니다.\r\n\t\tfairy.lightPointPerLevel = fairy.lightPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseLightPointPerLevel(fairyId);\r\n\t}\r\n\t\r\n\t// 돈을 지불하고 레벨 당 어둠 속성 증가 포인트를 올립니다.\r\n\tfunction increaseDarkPointPerLevel(uint256 fairyId) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) payable public {\r\n\t\t\r\n\t\tFairy storage fairy = fairies[fairyId];\r\n\t\t\r\n\t\t// 임의로 포인트를 증가시키는데 드는 포인트당 가격과 비교합니다.\r\n\t\trequire(msg.value == increasePointPricePerPoint * fairy.darkPointPerLevel.add(1));\r\n\t\t\r\n\t\t// 레벨 당 어둠 속성 증가 포인트를 올립니다.\r\n\t\tfairy.darkPointPerLevel = fairy.darkPointPerLevel.add(1);\r\n\t\t\r\n        uint256 companyRevenue = msg.value.div(2);\r\n        uint256 designerRevenue = msg.value.div(2);\r\n        \r\n        require(companyRevenue.add(designerRevenue) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(companyRevenue);\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tfairy.designer.transfer(designerRevenue);\r\n\t\t\r\n\t\temit IncreaseDarkPointPerLevel(fairyId);\r\n\t}\r\n}\r\n\r\n// 요정 소유주가 사용하는 기능들\r\ncontract FairyMaster is FairyOwnership, FairyPayToUpgrade {\r\n\tusing SafeMath for uint256;\r\n\t\r\n\t// 이벤트\r\n    event BirthFairy(address indexed master, uint256 fairyId);\r\n    event ChangeFairyName(uint256 indexed fairyId, string name);\r\n\t\r\n\t// 요정을 탄생시킵니다.\r\n\tfunction birthFairy(\r\n\t\t\r\n\t\t// 회사 서버에 저장된 요정 원본 ID\r\n\t\tstring fairyOriginId,\r\n\t\t\r\n\t\t// 요정 디자이너의 지갑 주소\r\n\t\taddress designer,\r\n\t\t\r\n\t\t// 요정의 이름\r\n\t\tstring name,\r\n\t\t\r\n\t\t// 원소 속성에 대한 레벨 당 증가 포인트들\r\n\t\tuint256 firePointPerLevel,\r\n\t\tuint256 waterPointPerLevel,\r\n\t\tuint256 windPointPerLevel,\r\n\t\tuint256 earthPointPerLevel,\r\n\t\tuint256 lightPointPerLevel,\r\n\t\tuint256 darkPointPerLevel\r\n\t\t) whenServiceRunning whenNotBlocked payable public {\r\n\t\t\r\n\t\t// 주소 오용 차단\r\n\t\trequire(checkAddressMisused(designer) != true);\r\n\t\t\r\n\t\t// 요정 원본의 가격과 비교합니다.\r\n\t\trequire(msg.value == fairyOriginPrice);\r\n\t\t\r\n\t\t// 초기 속성 값들의 총합은 5가 되어야 합니다.\r\n\t\tuint256 totalPointPerLevel = firePointPerLevel;\r\n\t\ttotalPointPerLevel = totalPointPerLevel.add(waterPointPerLevel);\r\n\t\ttotalPointPerLevel = totalPointPerLevel.add(windPointPerLevel);\r\n\t\ttotalPointPerLevel = totalPointPerLevel.add(earthPointPerLevel);\r\n\t\ttotalPointPerLevel = totalPointPerLevel.add(lightPointPerLevel);\r\n\t\ttotalPointPerLevel = totalPointPerLevel.add(darkPointPerLevel);\r\n\t\trequire(totalPointPerLevel == 5);\r\n\t\t\r\n\t\t// 요정 데이터 생성\r\n\t\tuint256 fairyId = fairies.push(Fairy({\r\n\t\t\t\r\n\t\t\tfairyOriginId : fairyOriginId,\r\n\t\t\tdesigner : designer,\r\n\t\t\tname : name,\r\n\t\t\tbirthTime : now,\r\n\t\t\tappendedLevel : 0,\r\n\t\t\t\r\n\t\t\t// EVM의 특성 상 너무 많은 변수를 한번에 할당 할 수 없으므로,\r\n\t\t\t// 기본 속성은 1로 통일하여 지정합니다.\r\n\t\t\thpPointPerLevel : 1,\r\n\t\t\tattackPointPerLevel : 1,\r\n\t\t\tdefencePointPerLevel : 1,\r\n\t\t\tagilityPointPerLevel : 1,\r\n\t\t\tdexterityPointPerLevel : 1,\r\n\t\t\t\r\n\t\t\tfirePointPerLevel : firePointPerLevel,\r\n\t\t\twaterPointPerLevel : waterPointPerLevel,\r\n\t\t\twindPointPerLevel : windPointPerLevel,\r\n\t\t\tearthPointPerLevel : earthPointPerLevel,\r\n\t\t\tlightPointPerLevel : lightPointPerLevel,\r\n\t\t\tdarkPointPerLevel : darkPointPerLevel\r\n\t\t})).sub(1);\r\n\t\t\r\n\t\t// msg.sender를 소유주로 등록\r\n\t\tfairyIdToMaster[fairyId] = msg.sender;\r\n\t\tfairyIdToFairyIdsIndex[fairyId] = masterToFairyIds[msg.sender].push(fairyId).sub(1);\r\n\t\t\r\n\t\t// 소유주 주소 등록\r\n\t\tif (masterToIsExisted[msg.sender] != true) {\r\n\t\t\tmasters.push(msg.sender);\r\n\t\t\tmasterToIsExisted[msg.sender] = true;\r\n\t\t}\r\n\t\t\r\n\t\trequire(msg.value.div(2).mul(2) == msg.value);\r\n\t\t\r\n\t\t// 회사에게 금액의 50%를 지급합니다.\r\n\t\tcompany.transfer(msg.value.div(2));\r\n\t\t\r\n\t\t// 요정의 디자이너에게 금액의 50%를 지급합니다.\r\n\t\tdesigner.transfer(msg.value.div(2));\r\n\t\t\r\n\t\t// 이벤트 발생\r\n\t\temit BirthFairy(msg.sender, fairyId);\r\n\t\temit Transfer(0x0, msg.sender, fairyId);\r\n\t}\r\n\r\n\t// 요정의 이름을 변경합니다.\r\n\tfunction changeFairyName(uint256 fairyId, string newName) whenServiceRunning whenNotBlocked whenNotBlockedFairy(fairyId) onlyMasterOf(fairyId) public {\r\n\t\tfairies[fairyId].name = newName;\r\n\t\t\r\n\t\temit ChangeFairyName(fairyId, newName);\r\n\t}\r\n\t\r\n\t// 요정을 많이 가진 순서대로 소유주의 ID 목록을 가져옵니다.\r\n\tfunction getMasterIdsByFairyCount() view public returns (uint256[]) {\r\n\t\tuint256[] memory masterIds = new uint256[](masters.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < masters.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 fairyCount = balanceOf(masters[i]);\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (balanceOf(masters[masterIds[j - 1]]) < fairyCount) {\r\n\t\t\t\t\tmasterIds[j] = masterIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tmasterIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn masterIds;\r\n\t}\r\n}\r\n\r\n// 요정 정보를 제공하는 계약\r\ncontract FairyInfo is EtherFairyBase {\r\n\t\r\n\t// 요정의 기본 정보를 반환합니다.\r\n\tfunction getFairyBasicInfo(uint256 fairyId) view public returns (\r\n\t\tstring fairyOriginId,\r\n\t\taddress designer,\r\n\t\tstring name,\r\n\t\tuint256 birthTime,\r\n\t\tuint256 appendedLevel) {\r\n\t\t\r\n\t\tFairy memory fairy = fairies[fairyId];\r\n\t\t\r\n\t\treturn (\r\n\t\t\tfairy.fairyOriginId,\r\n\t\t\tfairy.designer,\r\n\t\t\tfairy.name,\r\n\t\t\tfairy.birthTime,\r\n\t\t\tfairy.appendedLevel\r\n\t\t);\r\n\t}\r\n\t\r\n\t// 요정의 기본 속성에 대한 레벨 당 증가 포인트들을 반환합니다.\r\n\tfunction getFairyBasicPointsPerLevel(uint256 fairyId) view public returns (\r\n\t\tuint256 hpPointPerLevel,\r\n\t\tuint256 attackPointPerLevel,\r\n\t\tuint256 defencePointPerLevel,\r\n\t\tuint256 agilityPointPerLevel,\r\n\t\tuint256 dexterityPointPerLevel) {\r\n\t\t\r\n\t\tFairy memory fairy = fairies[fairyId];\r\n\t\t\r\n\t\treturn (\r\n\t\t\tfairy.hpPointPerLevel,\r\n\t\t\tfairy.attackPointPerLevel,\r\n\t\t\tfairy.defencePointPerLevel,\r\n\t\t\tfairy.agilityPointPerLevel,\r\n\t\t\tfairy.dexterityPointPerLevel\r\n\t\t);\r\n\t}\r\n\t\r\n\t// 요정의 원소 속성에 대한 레벨 당 증가 포인트들을 반환합니다.\r\n\tfunction getFairyElementPointsPerLevel(uint256 fairyId) view public returns (\r\n\t\tuint256 firePointPerLevel,\r\n\t\tuint256 waterPointPerLevel,\r\n\t\tuint256 windPointPerLevel,\r\n\t\tuint256 earthPointPerLevel,\r\n\t\tuint256 lightPointPerLevel,\r\n\t\tuint256 darkPointPerLevel) {\r\n\t\t\r\n\t\tFairy memory fairy = fairies[fairyId];\r\n\t\t\r\n\t\treturn (\r\n\t\t\tfairy.firePointPerLevel,\r\n\t\t\tfairy.waterPointPerLevel,\r\n\t\t\tfairy.windPointPerLevel,\r\n\t\t\tfairy.earthPointPerLevel,\r\n\t\t\tfairy.lightPointPerLevel,\r\n\t\t\tfairy.darkPointPerLevel\r\n\t\t);\r\n\t}\r\n}\r\n\r\n// 요정의 랭킹을 제공하는 계약\r\ncontract FairyRank is EtherFairyBase {\r\n\t\r\n\t// 최근에 태어난 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByBirthTime() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 birthTime = fairies[i].birthTime;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].birthTime < birthTime) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 소유주에 의해 추가된 레벨이 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByAppendedLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 appendedLevel = fairies[i].appendedLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].appendedLevel < appendedLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 HP 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByHPPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 hpPointPerLevel = fairies[i].hpPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].hpPointPerLevel < hpPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 공격 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByAttackPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 attackPointPerLevel = fairies[i].attackPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].attackPointPerLevel < attackPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 방어 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByDefencePointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 defencePointPerLevel = fairies[i].defencePointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].defencePointPerLevel < defencePointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 민첩 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByAgilityPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 agilityPointPerLevel = fairies[i].agilityPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].agilityPointPerLevel < agilityPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 재치 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByDexterityPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 dexterityPointPerLevel = fairies[i].dexterityPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].dexterityPointPerLevel < dexterityPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 불 속성 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByFirePointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 firePointPerLevel = fairies[i].firePointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].firePointPerLevel < firePointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 물 속성 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByWaterPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 waterPointPerLevel = fairies[i].waterPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].waterPointPerLevel < waterPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 바람 속성 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByWindPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 windPointPerLevel = fairies[i].windPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].windPointPerLevel < windPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 대지 속성 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByEarthPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 earthPointPerLevel = fairies[i].earthPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].earthPointPerLevel < earthPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 빛 속성 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByLightPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 lightPointPerLevel = fairies[i].lightPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].lightPointPerLevel < lightPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n\t\r\n\t// 레벨 당 어둠 속성 증가 포인트가 높은 순서대로 요정의 ID 목록을 가져옵니다.\r\n\tfunction getFairyIdsByDarkPointPerLevel() view public returns (uint256[]) {\r\n\t\tuint256[] memory fairyIds = new uint256[](fairies.length);\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < fairies.length; i += 1) {\r\n\t\t\t\r\n\t\t\tuint256 darkPointPerLevel = fairies[i].darkPointPerLevel;\r\n\t\t\t\r\n\t\t\tfor (uint256 j = i; j > 0; j -= 1) {\r\n\t\t\t\tif (fairies[fairyIds[j - 1]].darkPointPerLevel < darkPointPerLevel) {\r\n\t\t\t\t\tfairyIds[j] = fairyIds[j - 1];\r\n\t\t\t\t} else {\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tfairyIds[j] = i;\r\n\t\t}\r\n\t\t\r\n\t\treturn fairyIds;\r\n\t}\r\n}\r\n\r\n// Ether Fairy 스마트 계약\r\ncontract EtherFairy is EtherFairyCompany, FairyMaster, FairyInfo, FairyRank, ERC165 {\r\n\t\r\n\t//ERC165: 주어진 인터페이스가 구현되어 있는지 확인합니다.\r\n\tfunction supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n\t\treturn\r\n\t\t\t// ERC165\r\n\t\t\tinterfaceID == this.supportsInterface.selector ||\r\n\t\t\t// ERC721\r\n\t\t\tinterfaceID == 0x80ac58cd ||\r\n\t\t\t// ERC721Metadata\r\n\t\t\tinterfaceID == 0x5b5e139f ||\r\n\t\t\t// ERC721Enumerable\r\n\t\t\tinterfaceID == 0x780e9d63;\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"masterToBlock\",\"type\":\"address\"}],\"name\":\"blockMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fairyOriginPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approved\",\"type\":\"address\"},{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"getFairyBasicPointsPerLevel\",\"outputs\":[{\"name\":\"hpPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"attackPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"defencePointPerLevel\",\"type\":\"uint256\"},{\"name\":\"agilityPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"dexterityPointPerLevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseFirePointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"levelUpFairy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fairyIdToIsBlocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokenMetadataBaseURI\",\"type\":\"string\"}],\"name\":\"changeTokenMetadataBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"officialMarket\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"increasePointPricePerPoint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fairyOriginId\",\"type\":\"string\"}],\"name\":\"getFairyIdsByOriginId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMasterIdsByFairyCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByBirthTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByAttackPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseDarkPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"servicePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByAgilityPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyOriginId\",\"type\":\"string\"},{\"name\":\"designer\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"firePointPerLevel\",\"type\":\"uint256\"},{\"name\":\"waterPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"windPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"earthPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"lightPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"darkPointPerLevel\",\"type\":\"uint256\"}],\"name\":\"birthFairy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseAttackPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByFirePointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"masters\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fairyIdToMaster\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"masterToIsBlocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"company\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"getFairyElementPointsPerLevel\",\"outputs\":[{\"name\":\"firePointPerLevel\",\"type\":\"uint256\"},{\"name\":\"waterPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"windPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"earthPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"lightPointPerLevel\",\"type\":\"uint256\"},{\"name\":\"darkPointPerLevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFairyOriginPrice\",\"type\":\"uint256\"}],\"name\":\"changeFairyOriginPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCustomLevelUpPrice\",\"type\":\"uint256\"}],\"name\":\"changeCustomLevelUpPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyIdToUnblock\",\"type\":\"uint256\"}],\"name\":\"unblockFairy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"masterToUnlock\",\"type\":\"address\"}],\"name\":\"unblockMaster\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByWindPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseAgilityPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByWaterPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"},{\"name\":\"isApproved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOfficialMarket\",\"type\":\"address\"}],\"name\":\"changeOfficialMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"masterToFairyIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"getFairyBasicInfo\",\"outputs\":[{\"name\":\"fairyOriginId\",\"type\":\"string\"},{\"name\":\"designer\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"birthTime\",\"type\":\"uint256\"},{\"name\":\"appendedLevel\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseDefencePointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMetadataBaseURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMasterCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"fairyId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseEarthPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByHPPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyIdToBlock\",\"type\":\"uint256\"}],\"name\":\"blockFairy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByAppendedLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByDarkPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseLightPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseWindPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resumeService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"customLevelUpPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByLightPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newIncreasePointPricePerPoint\",\"type\":\"uint256\"}],\"name\":\"changeIncreasePointPricePerPoint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"master\",\"type\":\"address\"},{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"},{\"name\":\"newName\",\"type\":\"string\"}],\"name\":\"changeFairyName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCompany\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByEarthPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByDexterityPointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseDexterityPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SYMBOL\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFairyIdsByDefencePointPerLevel\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseHPPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"fairyOriginId\",\"type\":\"string\"}],\"name\":\"getFairyCountByOriginId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"increaseWaterPointPerLevel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"master\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"BirthFairy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"ChangeFairyName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"CustomLevelUp\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseHPPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseAttackPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseDefencePointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseAgilityPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseDexterityPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseFirePointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseWaterPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseWindPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseEarthPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseLightPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fairyId\",\"type\":\"uint256\"}],\"name\":\"IncreaseDarkPointPerLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldCompany\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newCompany\",\"type\":\"address\"}],\"name\":\"TransferOwnership\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"PauseService\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ResumeService\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ChangeFairyOriginPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ChangeCustomLevelUpPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"ChangeIncreasePointPricePerPoint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenMetadataBaseURI\",\"type\":\"string\"}],\"name\":\"ChangeTokenMetadataBaseURI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"officialMarket\",\"type\":\"address\"}],\"name\":\"ChangeOfficialMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"masterToBlock\",\"type\":\"address\"}],\"name\":\"BlockMaster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fairyIdToBlock\",\"type\":\"uint256\"}],\"name\":\"BlockFairy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"masterToUnlock\",\"type\":\"address\"}],\"name\":\"UnblockMaster\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fairyIdToUnblock\",\"type\":\"uint256\"}],\"name\":\"UnblockFairy\",\"type\":\"event\"}]","ContractName":"EtherFairy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://3cee229dbe0a934f04e79b306f1edca4e8f537851e29777f87c83103d931af26"}]}