{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n  Zethr | https://zethr.io\r\n  (c) Copyright 2018 | All Rights Reserved\r\n  This smart contract was developed by the Zethr Dev Team and its source code remains property of the Zethr Project.\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n// File: contracts/Libraries/SafeMath.sol\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/Bankroll/ZethrSnap.sol\r\n\r\ncontract ZethrInterface {\r\n  function transfer(address _from, uint _amount) public;\r\n\r\n  function myFrontEndTokens() public view returns (uint);\r\n}\r\n\r\ncontract ZethrMultiSigWalletInterface {\r\n  mapping(address => bool) public isOwner;\r\n}\r\n\r\ncontract ZethrSnap {\r\n\r\n  struct SnapEntry {\r\n    uint blockNumber;\r\n    uint profit;\r\n  }\r\n\r\n  struct Sig {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n  }\r\n\r\n  // Reference to the Zethr multi sig wallet for authentication\r\n  ZethrMultiSigWalletInterface public multiSigWallet;\r\n\r\n  // Reference to Zethr token contract\r\n  ZethrInterface zethr;\r\n\r\n  // The server's public address (used to confirm valid claims)\r\n  address signer;\r\n\r\n  // Mapping of user address => snap.id => claimStatus\r\n  mapping(address => mapping(uint => bool)) public claimedMap;\r\n\r\n  // Array of all snaps\r\n  SnapEntry[] public snaps;\r\n\r\n  // Used to pause the contract in an emergency\r\n  bool public paused;\r\n\r\n  // The number of tokens in this contract allocated to snaps\r\n  uint public allocatedTokens;\r\n\r\n  constructor(address _multiSigWalletAddress, address _zethrAddress, address _signer)\r\n  public\r\n  {\r\n    multiSigWallet = ZethrMultiSigWalletInterface(_multiSigWalletAddress);\r\n    zethr = ZethrInterface(_zethrAddress);\r\n    signer = _signer;\r\n    paused = false;\r\n  }\r\n\r\n  /**\r\n   * @dev Needs to accept ETH dividends from Zethr token contract\r\n   */\r\n  function()\r\n  public payable\r\n  {}\r\n\r\n  /**\r\n   * @dev Paused claims in an emergency\r\n   * @param _paused The new pause state\r\n   */\r\n  function ownerSetPaused(bool _paused)\r\n  public\r\n  ownerOnly\r\n  {\r\n    paused = _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the multi sig wallet reference\r\n   * @param _multiSigWalletAddress The new multi sig wallet address\r\n   */\r\n  function walletSetWallet(address _multiSigWalletAddress)\r\n  public\r\n  walletOnly\r\n  {\r\n    multiSigWallet = ZethrMultiSigWalletInterface(_multiSigWalletAddress);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraws dividends to multi sig wallet\r\n   */\r\n  function withdraw()\r\n  public\r\n  {\r\n    (address(multiSigWallet)).transfer(address(this).balance);\r\n  }\r\n\r\n  /**\r\n   * @dev Updates the signer address\r\n   */\r\n  function walletSetSigner(address _signer)\r\n  public walletOnly\r\n  {\r\n    signer = _signer;\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraws tokens (for migrating to a new contract)\r\n   */\r\n  function walletWithdrawTokens(uint _amount)\r\n  public walletOnly\r\n  {\r\n    zethr.transfer(address(multiSigWallet), _amount);\r\n  }\r\n\r\n  /**\r\n   * @return Total number of snaps stored\r\n   */\r\n  function getSnapsLength()\r\n  public view\r\n  returns (uint)\r\n  {\r\n    return snaps.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a new snap\r\n   * @param _blockNumber The block number the server should use to calculate ownership\r\n   * @param _profitToShare The amount of profit to divide between all holders\r\n   */\r\n  function walletCreateSnap(uint _blockNumber, uint _profitToShare)\r\n  public\r\n  walletOnly\r\n  {\r\n    uint index = snaps.length;\r\n    snaps.length++;\r\n\r\n    snaps[index].blockNumber = _blockNumber;\r\n    snaps[index].profit = _profitToShare;\r\n\r\n    // Make sure we have enough free tokens to create this snap\r\n    uint balance = zethr.myFrontEndTokens();\r\n    balance = balance - allocatedTokens;\r\n    require(balance >= _profitToShare);\r\n\r\n    // Update allocation token count\r\n    allocatedTokens = allocatedTokens + _profitToShare;\r\n  }\r\n\r\n  /**\r\n   * @dev Retrieves snap details\r\n   * @param _snapId The ID of the snap to get details of\r\n   */\r\n  function getSnap(uint _snapId)\r\n  public view\r\n  returns (uint blockNumber, uint profit, bool claimed)\r\n  {\r\n    SnapEntry storage entry = snaps[_snapId];\r\n    return (entry.blockNumber, entry.profit, claimedMap[msg.sender][_snapId]);\r\n  }\r\n\r\n  /**\r\n   * @dev Process a claim\r\n   * @param _snapId ID of the snap this claim is for\r\n   * @param _payTo Address to send the proceeds to\r\n   * @param _amount The amount of profit claiming\r\n   * @param _signatureBytes Signature of the server approving this claim\r\n   */\r\n  function claim(uint _snapId, address _payTo, uint _amount, bytes _signatureBytes)\r\n  public\r\n  {\r\n    // Check pause state\r\n    require(!paused);\r\n\r\n    // Prevent multiple calls\r\n    require(claimedMap[msg.sender][_snapId] == false);\r\n    claimedMap[msg.sender][_snapId] = true;\r\n\r\n    // Confirm that the server has approved this claim\r\n    // Note: the player cannot modify the _amount arbitrarily because it will invalidate the signature\r\n    Sig memory sig = toSig(_signatureBytes);\r\n    bytes32 hash = keccak256(abi.encodePacked(\"SNAP\", _snapId, msg.sender, _amount));\r\n    address recoveredSigner = ecrecover(hash, sig.v, sig.r, sig.s);\r\n    require(signer == recoveredSigner);\r\n\r\n    // Reduce allocated tokens by claim amount\r\n    require(_amount <= allocatedTokens);\r\n    allocatedTokens = allocatedTokens - _amount;\r\n\r\n    // Send tokens\r\n    zethr.transfer(_payTo, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev The contract accepts ZTH tokens in order to pay out claims\r\n   */\r\n  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes /*_data*/)\r\n  public view\r\n  returns (bool)\r\n  {\r\n    require(msg.sender == address(zethr), \"Tokens must be ZTH\");\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Extract a Sig struct from given bytes\r\n   */\r\n  function toSig(bytes b)\r\n  internal pure\r\n  returns (Sig memory sig)\r\n  {\r\n    sig.r = bytes32(toUint(b, 0));\r\n    sig.s = bytes32(toUint(b, 32));\r\n    sig.v = uint8(b[64]);\r\n  }\r\n\r\n  /**\r\n   * @dev Extracts a uint from bytes\r\n   */\r\n  function toUint(bytes _bytes, uint _start)\r\n  internal pure\r\n  returns (uint256)\r\n  {\r\n    require(_bytes.length >= (_start + 32));\r\n    uint256 tempUint;\r\n\r\n    assembly {\r\n      tempUint := mload(add(add(_bytes, 0x20), _start))\r\n    }\r\n\r\n    return tempUint;\r\n  }\r\n\r\n  // Only the multi sig wallet can call this method\r\n  modifier walletOnly()\r\n  {\r\n    require(msg.sender == address(multiSigWallet));\r\n    _;\r\n  }\r\n\r\n  // Only an owner can call this method (multi sig is always an owner)\r\n  modifier ownerOnly()\r\n  {\r\n    require(msg.sender == address(multiSigWallet) || multiSigWallet.isOwner(msg.sender));\r\n    _;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"allocatedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_multiSigWalletAddress\",\"type\":\"address\"}],\"name\":\"walletSetWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"walletWithdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_snapId\",\"type\":\"uint256\"}],\"name\":\"getSnap\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"profit\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiSigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signer\",\"type\":\"address\"}],\"name\":\"walletSetSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"claimedMap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_snapId\",\"type\":\"uint256\"},{\"name\":\"_payTo\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_signatureBytes\",\"type\":\"bytes\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"ownerSetPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSnapsLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"snaps\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"profit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"_profitToShare\",\"type\":\"uint256\"}],\"name\":\"walletCreateSnap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multiSigWalletAddress\",\"type\":\"address\"},{\"name\":\"_zethrAddress\",\"type\":\"address\"},{\"name\":\"_signer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ZethrSnap","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003efb18ae1d4b436881d6aa651b650c23f7b4cda2000000000000000000000000d48b633045af65ff636f3c6edd744748351e020d0000000000000000000000009f2c4ba023191cccfd15429431a18e5569f87f0d","Library":"","SwarmSource":"bzzr://c2a6e45b1f833a8aa209be8146ed93eaa102f38efa7a51043c63db4ae601b4ee"}]}