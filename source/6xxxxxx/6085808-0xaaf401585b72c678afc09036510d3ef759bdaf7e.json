{"status":"1","message":"OK","result":[{"SourceCode":"// Author: Nick Mudge <nick@perfectabstractions.com>\r\n// Perfect Abstractions LLC\r\n\r\npragma solidity 0.4.24;\r\n\r\ninterface ERC721TokenReceiver {\r\n\r\n\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `safetransfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns (bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/eips/issues/721\r\n */\r\ninterface ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _tokenOwner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _tokenOwner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _tokenOwner) external view returns (uint256 _balance);\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address _tokenOwner);\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external;\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    function approve(address _to, uint256 _tokenId) external;\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address _operator);\r\n\r\n    function isApprovedForAll(address _tokenOwner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC20AndERC223 {\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function transfer(address to, uint value) external returns (bool success);\r\n    function transfer(address to, uint value, bytes data) external returns (bool success);\r\n}\r\n\r\n\r\ninterface ERC998ERC721BottomUp {\r\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;\r\n\r\n}\r\n\r\ncontract AbstractMokens {\r\n    address public owner;\r\n\r\n    struct Moken {\r\n        string name;\r\n        uint256 data;\r\n        uint256 parentTokenId;\r\n    }\r\n\r\n    //tokenId to moken\r\n    mapping(uint256 => Moken) internal mokens;\r\n    uint256 internal mokensLength = 0;\r\n\r\n    // tokenId => token API URL\r\n    string public defaultURIStart = \"https://api.mokens.io/moken/\";\r\n    string public defaultURIEnd = \".json\";\r\n\r\n    // the block number Mokens is deployed in\r\n    uint256 public blockNum;\r\n\r\n    // index to era\r\n    mapping(uint256 => bytes32) internal eras;\r\n    uint256 internal eraLength = 0;\r\n    // era to index+1\r\n    mapping(bytes32 => uint256) internal eraIndex;\r\n\r\n    uint256 public mintPriceOffset = 0 szabo;\r\n    uint256 public mintStepPrice = 500 szabo;\r\n    uint256 public mintPriceBuffer = 5000 szabo;\r\n\r\n    /// @dev Magic value to be returned upon successful reception of an NFT\r\n    bytes4 constant ERC721_RECEIVED_NEW = 0x150b7a02;\r\n    bytes4 constant ERC721_RECEIVED_OLD = 0xf0b9e5ba;\r\n    bytes32 constant ERC998_MAGIC_VALUE = 0xcd740db5;\r\n\r\n    uint256 constant UINT16_MASK = 0x000000000000000000000000000000000000000000000000000000000000ffff;\r\n    uint256 constant MOKEN_LINK_HASH_MASK = 0xffffffffffffffff000000000000000000000000000000000000000000000000;\r\n    uint256 constant MOKEN_DATA_MASK = 0x0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant MAX_MOKENS = 4294967296;\r\n    uint256 constant MAX_OWNER_MOKENS = 65536;\r\n\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) internal ownedTokens;\r\n\r\n    // child address => child tokenId => tokenId+1\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n\r\n    // tokenId => (child address => (child token => child index)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n\r\n    // tokenId => (child address => contract index)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) internal erc20Contracts;\r\n\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\r\n\r\n    // parent address => (parent tokenId => array of child tokenIds)\r\n    mapping(address => mapping(uint256 => uint32[])) internal parentToChildTokenIds;\r\n\r\n    // tokenId => position in childTokens array\r\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\r\n\r\n    address[] internal mintContracts;\r\n    mapping(address => uint256) internal mintContractIndex;\r\n\r\n    //moken name to tokenId+1\r\n    mapping(string => uint256) internal tokenByName_;\r\n\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n\r\n    // contract that contains other functions needed\r\n    address public delegate;\r\n\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n\r\n    // Events\r\n    // ERC721\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _tokenOwner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _tokenOwner, address indexed _operator, bool _approved);\r\n    //ERC998ERC721TopDown\r\n    event ReceivedChild(address indexed _from, uint256 indexed _tokenId, address indexed _childContract, uint256 _childTokenId);\r\n    event TransferChild(uint256 indexed tokenId, address indexed _to, address indexed _childContract, uint256 _childTokenId);\r\n    //ERC998ERC20TopDown\r\n    event ReceivedERC20(address indexed _from, uint256 indexed _tokenId, address indexed _erc20Contract, uint256 _value);\r\n    event TransferERC20(uint256 indexed _tokenId, address indexed _to, address indexed _erc20Contract, uint256 _value);\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(addr)}\r\n        return size > 0;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Must be the contract owner.\");\r\n        _;\r\n    }\r\n\r\n    /*\r\n    function getSize() external view returns (uint256) {\r\n        uint256 size;\r\n        address addr = address(this);\r\n        assembly {size := extcodesize(addr)}\r\n        return size;\r\n    }\r\n    */\r\n\r\n    // Use Cases handled:\r\n    // Case 1: Token owner is this contract and token\r\n    // Case 2: Token owner is this contract and top-down composable.\r\n    // Case 3: Token owner is top-down composable\r\n    // Case 4: Token owner is an unknown contract\r\n    // Case 5: Token owner is a user\r\n    // Case 6: Token owner is a bottom-up composable\r\n    // Case 7: Token owner is ERC721 token owned by top-down token\r\n    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n    // Case 9: Token owner is ERC721 token owned by user\r\n    function rootOwnerOf(uint256 _tokenId) public view returns (bytes32 rootOwner) {\r\n        address rootOwnerAddress = address(mokens[_tokenId].data);\r\n        require(rootOwnerAddress != address(0), \"tokenId not found.\");\r\n        uint256 parentTokenId;\r\n        bool isParent;\r\n\r\n        while (rootOwnerAddress == address(this)) {\r\n            parentTokenId = mokens[_tokenId].parentTokenId;\r\n            isParent = parentTokenId > 0;\r\n            if(isParent) {\r\n                // Case 1: Token owner is this contract and token\r\n                _tokenId = parentTokenId - 1;\r\n            }\r\n            else {\r\n                // Case 2: Token owner is this contract and top-down composable.\r\n                _tokenId = childTokenOwner[rootOwnerAddress][_tokenId]-1;\r\n            }\r\n            rootOwnerAddress = address(mokens[_tokenId].data);\r\n        }\r\n\r\n        parentTokenId = mokens[_tokenId].parentTokenId;\r\n        isParent = parentTokenId > 0;\r\n        if(isParent) {\r\n            parentTokenId--;\r\n        }\r\n\r\n        bytes memory calldata;\r\n        bool callSuccess;\r\n\r\n        if (isParent == false) {\r\n\r\n            // success if this token is owned by a top-down token\r\n            // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n            calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 3: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // Case 4: Token owner is an unknown contract\r\n                // Or\r\n                // Case 5: Token owner is a user\r\n                return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n            }\r\n        }\r\n        else {\r\n\r\n            // 0x43a61a8e == rootOwnerOf(uint256)\r\n            calldata = abi.encodeWithSelector(0x43a61a8e, parentTokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 6: Token owner is a bottom-up composable\r\n                // Or\r\n                // Case 2: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // token owner is ERC721\r\n                address childContract = rootOwnerAddress;\r\n                //0x6352211e == \"ownerOf(uint256)\"\r\n                calldata = abi.encodeWithSelector(0x6352211e, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwnerAddress := mload(calldata)\r\n                    }\r\n                }\r\n                require(callSuccess, \"Call to ownerOf failed\");\r\n\r\n                // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n                calldata = abi.encodeWithSelector(0xed81cdda, childContract, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwner := mload(calldata)\r\n                    }\r\n                }\r\n                if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                    // Case 7: Token owner is ERC721 token owned by top-down token\r\n                    return rootOwner;\r\n                }\r\n                else {\r\n                    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n                    // Or\r\n                    // Case 9: Token owner is ERC721 token owned by user\r\n                    return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // returns the owner at the top of the tree of composables\r\n    function rootOwnerOfChild(address _childContract, uint256 _childTokenId) public view returns (bytes32 rootOwner) {\r\n        uint256 tokenId;\r\n        if (_childContract != address(0)) {\r\n            tokenId = childTokenOwner[_childContract][_childTokenId];\r\n            require(tokenId != 0, \"Child token does not exist\");\r\n            tokenId--;\r\n        }\r\n        else {\r\n            tokenId = _childTokenId;\r\n        }\r\n        return rootOwnerOf(tokenId);\r\n    }\r\n\r\n\r\n    function childApproved(address _from, uint256 _tokenId) internal {\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n        if(msg.sender != _from) {\r\n            bytes32 tokenOwner;\r\n            bool callSuccess;\r\n            // 0xeadb80b8 == ownerOfChild(address,uint256)\r\n            bytes memory calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, _from, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    tokenOwner := mload(calldata)\r\n                }\r\n            }\r\n            if(callSuccess == true) {\r\n                require(tokenOwner >> 224 != ERC998_MAGIC_VALUE, \"Token is child of top down composable\");\r\n            }\r\n            require(tokenOwnerToOperators[_from][msg.sender] || approvedAddress == msg.sender, \"msg.sender not _from/operator/approved.\");\r\n        }\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n            emit Approval(_from, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    function _transferFrom(uint256 data, address _to, uint256 _tokenId) internal {\r\n        address _from = address(data);\r\n        //removing the tokenId\r\n        // 1. We replace _tokenId in ownedTokens[_from] with the last token id\r\n        //    in ownedTokens[_from]\r\n        uint256 lastTokenIndex = ownedTokens[_from].length - 1;\r\n        uint256 lastTokenId = ownedTokens[_from][lastTokenIndex];\r\n        if (lastTokenId != _tokenId) {\r\n            uint256 tokenIndex = data >> 160 & UINT16_MASK;\r\n            ownedTokens[_from][tokenIndex] = uint32(lastTokenId);\r\n            // 2. We set lastTokeId to point to its new position in ownedTokens[_from]\r\n            mokens[lastTokenId].data = mokens[lastTokenId].data & 0xffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff | tokenIndex << 160;\r\n        }\r\n        // 3. We remove lastTokenId from the end of ownedTokens[_from]\r\n        ownedTokens[_from].length--;\r\n\r\n        //adding the tokenId\r\n        uint256 ownedTokensIndex = ownedTokens[_to].length;\r\n        // prevents 16 bit overflow\r\n        require(ownedTokensIndex < MAX_OWNER_MOKENS, \"A token owner address cannot possess more than 65,536 mokens.\");\r\n        mokens[_tokenId].data = data & 0xffffffffffffffffffff00000000000000000000000000000000000000000000 | ownedTokensIndex << 160 | uint256(_to);\r\n        ownedTokens[_to].push(uint32(_tokenId));\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n}\r\n\r\n// Author: Nick Mudge <nick@perfectabstractions.com>\r\n// Perfect Abstractions LLC\r\n\r\ncontract Mokens is AbstractMokens {\r\n\r\n    constructor(address _delegate) public {\r\n        delegate = _delegate;\r\n        blockNum = block.number;\r\n        owner = msg.sender;\r\n        bytes32 startingEra = \"Genesis\";\r\n        bytes memory calldata = abi.encodeWithSignature(\"startNextEra(bytes32)\", startingEra);\r\n        bool callSuccess;\r\n        assembly {\r\n            callSuccess := delegatecall(gas, _delegate, add(calldata, 0x20), mload(calldata), 0, 0)\r\n        }\r\n        require(callSuccess);\r\n\r\n        //ERC165\r\n        supportedInterfaces[0x01ffc9a7] = true;\r\n        //ERC721\r\n        supportedInterfaces[0x80ac58cd] = true;\r\n        //ERC721Metadata\r\n        supportedInterfaces[0x5b5e139f] = true;\r\n        //ERC721Enumerable\r\n        supportedInterfaces[0x780e9d63] = true;\r\n        //onERC721Received new\r\n        supportedInterfaces[0x150b7a02] = true;\r\n        //onERC721Received old\r\n        supportedInterfaces[0xf0b9e5ba] = true;\r\n        //ERC998ERC721TopDown\r\n        supportedInterfaces[0x1efdf36a] = true;\r\n        //ERC998ERC721TopDownEnumerable\r\n        supportedInterfaces[0xa344afe4] = true;\r\n        //ERC998ERC20TopDown\r\n        supportedInterfaces[0x7294ffed] = true;\r\n        //ERC998ERC20TopDownEnumerable\r\n        supportedInterfaces[0xc5fd96cd] = true;\r\n        //ERC998ERC721BottomUp\r\n        supportedInterfaces[0xa1b23002] = true;\r\n        //ERC998ERC721BottomUpEnumerable\r\n        supportedInterfaces[0x8318b539] = true;\r\n    }\r\n\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* ERC165Impl ***********************************************************/\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* ERC721Impl  & ERC998 Authentication ****************************************/\r\n\r\n    function balanceOf(address _tokenOwner) external view returns (uint256 totalMokensOwned) {\r\n        require(_tokenOwner != address(0), \"Moken owner cannot be the 0 address.\");\r\n        return ownedTokens[_tokenOwner].length;\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address tokenOwner) {\r\n        tokenOwner = address(mokens[_tokenId].data);\r\n        require(tokenOwner != address(0), \"The tokenId does not exist.\");\r\n        return tokenOwner;\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) external {\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender], \"Must be rootOwner or operator.\");\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] = _approved;\r\n        emit Approval(rootOwner, _approved, _tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) external view returns (address approvedAddress) {\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        return rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n    }\r\n\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        require(_operator != address(0), \"Operator cannot be 0 address.\");\r\n        tokenOwnerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _tokenOwner, address _operator) external view returns (bool approved) {\r\n        return tokenOwnerToOperators[_tokenOwner][_operator];\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        require(_from != address(0), \"_from cannot be the 0 address.\");\r\n        require(_to != address(0), \"_to cannot be the 0 address.\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _from, \"The tokenId is not owned by _from.\");\r\n        require(_to != address(this), \"Cannot transfer to this contract.\");\r\n        require(mokens[_tokenId].parentTokenId == 0, \"Cannot transfer from an address when owned by a token.\");\r\n        childApproved(_from, _tokenId);\r\n        _transferFrom(data, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        require(_from != address(0), \"_from cannot be the 0 address.\");\r\n        require(_to != address(0), \"_to cannot be the 0 address.\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _from, \"The tokenId is not owned by _from.\");\r\n        require(mokens[_tokenId].parentTokenId == 0, \"Cannot transfer from an address when owned by a token.\");\r\n        childApproved(_from, _tokenId);\r\n        _transferFrom(data, _to, _tokenId);\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, \"\");\r\n            require(retval == ERC721_RECEIVED_NEW, \"_to contract cannot receive ERC721 tokens.\");\r\n        }\r\n\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\r\n        require(_from != address(0), \"_from cannot be the 0 address.\");\r\n        require(_to != address(0), \"_to cannot be the 0 address.\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _from, \"The tokenId is not owned by _from.\");\r\n        require(mokens[_tokenId].parentTokenId == 0, \"Cannot transfer from an address when owned by a token.\");\r\n        childApproved(_from, _tokenId);\r\n        _transferFrom(data, _to, _tokenId);\r\n\r\n        if (_to == address(this)) {\r\n            require(_data.length > 0, \"_data must contain the uint256 tokenId to transfer the token to.\");\r\n            uint256 toTokenId;\r\n            assembly {toTokenId := calldataload(164)}\r\n            if (_data.length < 32) {\r\n                toTokenId = toTokenId >> 256 - _data.length * 8;\r\n            }\r\n            receiveChild(_from, toTokenId, _to, _tokenId);\r\n        }\r\n        else {\r\n            if (isContract(_to)) {\r\n                bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n                require(retval == ERC721_RECEIVED_NEW, \"_to contract cannot receive ERC721 tokens.\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* ERC721EnumerableImpl **************************************************/\r\n\r\n    function exists(uint256 _tokenId) external view returns (bool) {\r\n        return _tokenId < mokensLength;\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _tokenOwner, uint256 _index) external view returns (uint256 tokenId) {\r\n        require(_index < ownedTokens[_tokenOwner].length, \"_tokenOwner does not own a moken at this index.\");\r\n        return ownedTokens[_tokenOwner][_index];\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256 totalMokens) {\r\n        return mokensLength;\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external view returns (uint256 tokenId) {\r\n        require(_index < mokensLength, \"A tokenId at index does not exist.\");\r\n        return _index;\r\n    }\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* ERC721MetadataImpl **************************************************/\r\n\r\n    function name() external pure returns (string) {\r\n        return \"Mokens\";\r\n    }\r\n\r\n    function symbol() external pure returns (string) {\r\n        return \"MKN\";\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* Eras  **************************************************/\r\n\r\n\r\n    function eraByIndex(uint256 _index) external view returns (bytes32 era) {\r\n        require(_index < eraLength, \"No era at this index.\");\r\n        return eras[_index];\r\n    }\r\n\r\n\r\n    function eraByName(bytes32 _eraName) external view returns (uint256 indexOfEra) {\r\n        uint256 index = eraIndex[_eraName];\r\n        require(index != 0, \"No era exists with this name.\");\r\n        return index - 1;\r\n    }\r\n\r\n    function currentEra() external view returns (bytes32 era) {\r\n        return eras[eraLength - 1];\r\n    }\r\n\r\n    function currentEraIndex() external view returns (uint256 indexOfEra) {\r\n        return eraLength - 1;\r\n    }\r\n\r\n    function eraExists(bytes32 _eraName) external view returns (bool) {\r\n        return eraIndex[_eraName] != 0;\r\n    }\r\n\r\n    function totalEras() external view returns (uint256 totalEras_) {\r\n        return eraLength;\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* Minting  **************************************************/\r\n    event Mint(\r\n        address indexed mintContract,\r\n        address indexed owner,\r\n        bytes32 indexed era,\r\n        string mokenName,\r\n        bytes32 data,\r\n        uint256 tokenId,\r\n        bytes32 currencyName,\r\n        uint256 price\r\n    );\r\n\r\n\r\n    event MintPriceChange(\r\n        uint256 mintPrice\r\n    );\r\n\r\n    function mintData() external view returns (uint256 mokensLength_, uint256 mintStepPrice_, uint256 mintPriceOffset_) {\r\n        return (mokensLength, mintStepPrice, mintPriceOffset);\r\n    }\r\n\r\n    function mintPrice() external view returns (uint256) {\r\n        return (mokensLength * mintStepPrice) - mintPriceOffset;\r\n    }\r\n\r\n\r\n    function mint(address _tokenOwner, string _mokenName, bytes32 _linkHash) external payable returns (uint256 tokenId) {\r\n\r\n        require(_tokenOwner != address(0), \"Owner cannot be the 0 address.\");\r\n\r\n        tokenId = mokensLength++;\r\n        // prevents 32 bit overflow\r\n        require(tokenId < MAX_MOKENS, \"Only 4,294,967,296 mokens can be created.\");\r\n        uint256 mintStepPrice_ = mintStepPrice;\r\n        uint256 mintPriceBuffer_ = mintPriceBuffer;\r\n\r\n        //Was enough ether passed in?\r\n        uint256 currentMintPrice = (tokenId * mintStepPrice_) - mintPriceOffset;\r\n        uint256 pricePaid = currentMintPrice;\r\n        if (msg.value < currentMintPrice) {\r\n            require(mintPriceBuffer_ > currentMintPrice || msg.value > currentMintPrice - mintPriceBuffer_, \"Paid ether is lower than mint price.\");\r\n            pricePaid = msg.value;\r\n        }\r\n\r\n        string memory lowerMokenName = validateAndLower(_mokenName);\r\n        require(tokenByName_[lowerMokenName] == 0, \"Moken name already exists.\");\r\n\r\n        uint256 eraIndex_ = eraLength - 1;\r\n        uint256 ownedTokensIndex = ownedTokens[_tokenOwner].length;\r\n        // prevents 16 bit overflow\r\n        require(ownedTokensIndex < MAX_OWNER_MOKENS, \"An single owner address cannot possess more than 65,536 mokens.\");\r\n\r\n        // adding the current era index, ownedTokenIndex and owner address to data\r\n        // this saves gas for each mint.\r\n        uint256 data = uint256(_linkHash) & MOKEN_LINK_HASH_MASK | eraIndex_ << 176 | ownedTokensIndex << 160 | uint160(_tokenOwner);\r\n\r\n        // create moken\r\n        mokens[tokenId].name = _mokenName;\r\n        mokens[tokenId].data = data;\r\n        tokenByName_[lowerMokenName] = tokenId + 1;\r\n\r\n        //add moken to the specific owner\r\n        ownedTokens[_tokenOwner].push(uint32(tokenId));\r\n\r\n        //emit events\r\n        emit Transfer(address(0), _tokenOwner, tokenId);\r\n        emit Mint(this, _tokenOwner, eras[eraIndex_], _mokenName, bytes32(data), tokenId, \"Ether\", pricePaid);\r\n        emit MintPriceChange(currentMintPrice + mintStepPrice_);\r\n\r\n        //send minter the change if any\r\n        if (msg.value > currentMintPrice) {\r\n            msg.sender.transfer(msg.value - currentMintPrice);\r\n        }\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    function isMintContract(address _contract) public view returns (bool) {\r\n        return mintContractIndex[_contract] != 0;\r\n    }\r\n\r\n    function totalMintContracts() external view returns (uint256 totalMintContracts_) {\r\n        return mintContracts.length;\r\n    }\r\n\r\n    function mintContractByIndex(uint256 index) external view returns (address contract_) {\r\n        require(index < mintContracts.length, \"Contract index does not exist.\");\r\n        return mintContracts[index];\r\n    }\r\n\r\n    // enables third-party contracts to mint mokens.\r\n    // enables the ability to accept other currency/tokens for payment.\r\n    function contractMint(address _tokenOwner, string _mokenName, bytes32 _linkHash, bytes32 _currencyName, uint256 _pricePaid) external returns (uint256 tokenId) {\r\n\r\n        require(_tokenOwner != address(0), \"Token owner cannot be the 0 address.\");\r\n        require(isMintContract(msg.sender), \"Not an approved mint contract.\");\r\n\r\n        tokenId = mokensLength++;\r\n        uint256 mokensLength_ = tokenId + 1;\r\n        // prevents 32 bit overflow\r\n        require(tokenId < MAX_MOKENS, \"Only 4,294,967,296 mokens can be created.\");\r\n\r\n        string memory lowerMokenName = validateAndLower(_mokenName);\r\n        require(tokenByName_[lowerMokenName] == 0, \"Moken name already exists.\");\r\n\r\n        uint256 eraIndex_ = eraLength - 1;\r\n        uint256 ownedTokensIndex = ownedTokens[_tokenOwner].length;\r\n        // prevents 16 bit overflow\r\n        require(ownedTokensIndex < MAX_OWNER_MOKENS, \"An single token owner address cannot possess more than 65,536 mokens.\");\r\n\r\n        // adding the current era index, ownedTokenIndex and owner address to data\r\n        // this saves gas for each mint.\r\n        uint256 data = uint256(_linkHash) & MOKEN_LINK_HASH_MASK | eraIndex_ << 176 | ownedTokensIndex << 160 | uint160(_tokenOwner);\r\n\r\n        // create moken\r\n        mokens[tokenId].name = _mokenName;\r\n        mokens[tokenId].data = data;\r\n        tokenByName_[lowerMokenName] = mokensLength_;\r\n\r\n        //add moken to the specific owner\r\n        ownedTokens[_tokenOwner].push(uint32(tokenId));\r\n\r\n        emit Transfer(address(0), _tokenOwner, tokenId);\r\n        emit Mint(msg.sender, _tokenOwner, eras[eraIndex_], _mokenName, bytes32(data), tokenId, _currencyName, _pricePaid);\r\n        emit MintPriceChange((mokensLength_ * mintStepPrice) - mintPriceOffset);\r\n\r\n        return tokenId;\r\n    }\r\n\r\n\r\n    function validateAndLower(string _s) private pure returns (string mokenName) {\r\n        assembly {\r\n        // get length of _s\r\n            let len := mload(_s)\r\n        // get position of _s\r\n            let p := add(_s, 0x20)\r\n        // _s cannot be 0 characters\r\n            if eq(len, 0) {\r\n                revert(0, 0)\r\n            }\r\n        // _s cannot be more than 100 characters\r\n            if gt(len, 100) {\r\n                revert(0, 0)\r\n            }\r\n        // get first character\r\n            let b := byte(0, mload(add(_s, 0x20)))\r\n        // first character cannot be whitespace/unprintable\r\n            if lt(b, 0x21) {\r\n                revert(0, 0)\r\n            }\r\n        // get last character\r\n            b := byte(0, mload(add(p, sub(len, 1))))\r\n        // last character cannot be whitespace/unprintable\r\n            if lt(b, 0x21) {\r\n                revert(0, 0)\r\n            }\r\n        // loop through _s and lowercase uppercase characters\r\n            for {let end := add(p, len)}\r\n            lt(p, end)\r\n            {p := add(p, 1)}\r\n            {\r\n                b := byte(0, mload(p))\r\n                if lt(b, 0x5b) {\r\n                    if gt(b, 0x40) {\r\n                        mstore8(p, add(b, 32))\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return _s;\r\n    }\r\n\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /******************************************************************************/\r\n    /* Mokens  **************************************************/\r\n\r\n    function mokenNameExists(string _mokenName) external view returns (bool) {\r\n        return tokenByName_[validateAndLower(_mokenName)] != 0;\r\n    }\r\n\r\n    function mokenId(string _mokenName) external view returns (uint256 tokenId) {\r\n        tokenId = tokenByName_[validateAndLower(_mokenName)];\r\n        require(tokenId != 0, \"No moken exists with this name.\");\r\n        return tokenId - 1;\r\n    }\r\n\r\n    function mokenData(uint256 _tokenId) external view returns (bytes32 data) {\r\n        data = bytes32(mokens[_tokenId].data);\r\n        require(data != 0, \"The tokenId does not exist.\");\r\n        return data;\r\n    }\r\n\r\n    function eraFromMokenData(bytes32 _data) public view returns (bytes32 era) {\r\n        return eras[uint256(_data) >> 176 & UINT16_MASK];\r\n    }\r\n\r\n    function eraFromMokenData(uint256 _data) public view returns (bytes32 era) {\r\n        return eras[_data >> 176 & UINT16_MASK];\r\n    }\r\n\r\n    function mokenEra(uint256 _tokenId) external view returns (bytes32 era) {\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(data != 0, \"The tokenId does not exist.\");\r\n        return eraFromMokenData(data);\r\n    }\r\n\r\n    function moken(uint256 _tokenId) external view\r\n    returns (string memory mokenName, bytes32 era, bytes32 data, address tokenOwner) {\r\n        data = bytes32(mokens[_tokenId].data);\r\n        require(data != 0, \"The tokenId does not exist.\");\r\n        return (\r\n        mokens[_tokenId].name,\r\n        eraFromMokenData(data),\r\n        data,\r\n        address(data)\r\n        );\r\n    }\r\n\r\n    function mokenBytes32(uint256 _tokenId) external view\r\n    returns (bytes32 mokenNameBytes32, bytes32 era, bytes32 data, address tokenOwner) {\r\n        data = bytes32(mokens[_tokenId].data);\r\n        require(data != 0, \"The tokenId does not exist.\");\r\n        bytes memory mokenNameBytes = bytes(mokens[_tokenId].name);\r\n        require(mokenNameBytes.length != 0, \"The tokenId does not exist.\");\r\n        assembly {\r\n            mokenNameBytes32 := mload(add(mokenNameBytes, 32))\r\n        }\r\n        return (\r\n        mokenNameBytes32,\r\n        eraFromMokenData(data),\r\n        data,\r\n        address(data)\r\n        );\r\n    }\r\n\r\n\r\n    function mokenNoName(uint256 _tokenId) external view\r\n    returns (bytes32 era, bytes32 data, address tokenOwner) {\r\n        data = bytes32(mokens[_tokenId].data);\r\n        require(data != 0, \"The tokenId does not exist.\");\r\n        return (\r\n        eraFromMokenData(data),\r\n        data,\r\n        address(data)\r\n        );\r\n    }\r\n\r\n    function mokenName(uint256 _tokenId) external view returns (string memory mokenName_) {\r\n        mokenName_ = mokens[_tokenId].name;\r\n        require(bytes(mokenName_).length != 0, \"The tokenId does not exist.\");\r\n        return mokenName_;\r\n    }\r\n\r\n    function mokenNameBytes32(uint256 _tokenId) external view returns (bytes32 mokenNameBytes32_) {\r\n        bytes memory mokenNameBytes = bytes(mokens[_tokenId].name);\r\n        require(mokenNameBytes.length != 0, \"The tokenId does not exist.\");\r\n        assembly {\r\n            mokenNameBytes32_ := mload(add(mokenNameBytes, 32))\r\n        }\r\n        return mokenNameBytes32_;\r\n    }\r\n\r\n\r\n    function() external {\r\n        bytes memory data = msg.data;\r\n        assembly {\r\n            let result := delegatecall(gas, sload(delegate_slot), add(data, 0x20), mload(data), 0, 0)\r\n            let size := returndatasize\r\n            let ptr := mload(0x40)\r\n            returndatacopy(ptr, 0, size)\r\n            switch result\r\n            case 0 {revert(ptr, size)}\r\n            default {return (ptr, size)}\r\n        }\r\n    }\r\n\r\n    // functions added here to reduce gas cost\r\n\r\n    //////////////////////////////////////////////////////////\r\n    //ERC721 top down\r\n\r\n    function receiveChild(address _from, uint256 _toTokenId, address _childContract, uint256 _childTokenId) internal {\r\n        require(address(mokens[_toTokenId].data) != address(0), \"_tokenId does not exist.\");\r\n        require(childTokenOwner[_childContract][_childTokenId] == 0, \"Child token already received.\");\r\n        uint256 childTokensLength = childTokens[_toTokenId][_childContract].length;\r\n        if (childTokensLength == 0) {\r\n            childContractIndex[_toTokenId][_childContract] = childContracts[_toTokenId].length;\r\n            childContracts[_toTokenId].push(_childContract);\r\n        }\r\n        childTokenIndex[_toTokenId][_childContract][_childTokenId] = childTokensLength;\r\n        childTokens[_toTokenId][_childContract].push(_childTokenId);\r\n        childTokenOwner[_childContract][_childTokenId] = _toTokenId + 1;\r\n        emit ReceivedChild(_from, _toTokenId, _childContract, _childTokenId);\r\n    }\r\n\r\n    // this contract has to be approved first in _childContract\r\n    function getChild(address _from, uint256 _toTokenId, address _childContract, uint256 _childTokenId) external {\r\n        receiveChild(_from, _toTokenId, _childContract, _childTokenId);\r\n        require(_from == msg.sender ||\r\n        ERC721(_childContract).getApproved(_childTokenId) == msg.sender ||\r\n        ERC721(_childContract).isApprovedForAll(_from, msg.sender), \"msg.sender is not owner/operator/approved for child token.\");\r\n        ERC721(_childContract).transferFrom(_from, this, _childTokenId);\r\n    }\r\n\r\n    function onERC721Received(address _from, uint256 _childTokenId, bytes _data) external returns (bytes4) {\r\n        require(_data.length > 0, \"_data must contain the uint256 tokenId to transfer the child token to.\");\r\n        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes\r\n        uint256 toTokenId;\r\n        assembly {toTokenId := calldataload(132)}\r\n        if (_data.length < 32) {\r\n            toTokenId = toTokenId >> 256 - _data.length * 8;\r\n        }\r\n        receiveChild(_from, toTokenId, msg.sender, _childTokenId);\r\n        require(ERC721(msg.sender).ownerOf(_childTokenId) != address(0), \"Child token not owned.\");\r\n        return ERC721_RECEIVED_OLD;\r\n    }\r\n\r\n\r\n    function onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) external returns (bytes4) {\r\n        require(_data.length > 0, \"_data must contain the uint256 tokenId to transfer the child token to.\");\r\n        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes\r\n        uint256 toTokenId;\r\n        assembly {toTokenId := calldataload(164)}\r\n        if (_data.length < 32) {\r\n            toTokenId = toTokenId >> 256 - _data.length * 8;\r\n        }\r\n        receiveChild(_from, toTokenId, msg.sender, _childTokenId);\r\n        require(ERC721(msg.sender).ownerOf(_childTokenId) != address(0), \"Child token not owned.\");\r\n        return ERC721_RECEIVED_NEW;\r\n    }\r\n\r\n    function ownerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId) {\r\n        parentTokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(parentTokenId != 0, \"ERC721 token is not a child in this contract.\");\r\n        parentTokenId--;\r\n        return (ERC998_MAGIC_VALUE << 224 | bytes32(address(mokens[parentTokenId].data)), parentTokenId);\r\n    }\r\n\r\n    function childExists(address _childContract, uint256 _childTokenId) external view returns (bool) {\r\n        return childTokenOwner[_childContract][_childTokenId] != 0;\r\n    }\r\n\r\n    function totalChildContracts(uint256 _tokenId) external view returns (uint256) {\r\n        return childContracts[_tokenId].length;\r\n    }\r\n\r\n    function childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract) {\r\n        require(_index < childContracts[_tokenId].length, \"Contract address does not exist for this token and index.\");\r\n        return childContracts[_tokenId][_index];\r\n    }\r\n\r\n    function totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256) {\r\n        return childTokens[_tokenId][_childContract].length;\r\n    }\r\n\r\n    function childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId) {\r\n        require(_index < childTokens[_tokenId][_childContract].length, \"Token does not own a child token at contract address and index.\");\r\n        return childTokens[_tokenId][_childContract][_index];\r\n    }\r\n\r\n\r\n    //////////////////////////////////////////////////////////\r\n    //ERC20 top down\r\n    function balanceOfERC20(uint256 _tokenId, address _erc20Contract) external view returns (uint256) {\r\n        return erc20Balances[_tokenId][_erc20Contract];\r\n    }\r\n\r\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address) {\r\n        require(_index < erc20Contracts[_tokenId].length, \"Contract address does not exist for this token and index.\");\r\n        return erc20Contracts[_tokenId][_index];\r\n    }\r\n\r\n    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256) {\r\n        return erc20Contracts[_tokenId].length;\r\n    }\r\n\r\n    //////////////////////////////////////////////////////////\r\n    //ERC721 bottom up\r\n\r\n    function tokenOwnerOf(uint256 _tokenId) external view returns (bytes32 tokenOwner, uint256 parentTokenId, bool isParent) {\r\n        address tokenOwnerAddress = address(mokens[_tokenId].data);\r\n        require(tokenOwnerAddress != address(0), \"tokenId not found.\");\r\n        parentTokenId = mokens[_tokenId].parentTokenId;\r\n        isParent = parentTokenId > 0;\r\n        if (isParent) {\r\n            parentTokenId--;\r\n        }\r\n        return (ERC998_MAGIC_VALUE << 224 | bytes32(tokenOwnerAddress), parentTokenId, isParent);\r\n    }\r\n\r\n\r\n    function totalChildTokens(address _parentContract, uint256 _parentTokenId) public view returns (uint256) {\r\n        return parentToChildTokenIds[_parentContract][_parentTokenId].length;\r\n    }\r\n\r\n    function childTokenByIndex(address _parentContract, uint256 _parentTokenId, uint256 _index) public view returns (uint256) {\r\n        require(parentToChildTokenIds[_parentContract][_parentTokenId].length > _index, \"Child not found at index.\");\r\n        return parentToChildTokenIds[_parentContract][_parentTokenId][_index];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"defaultURIEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_parentContract\",\"type\":\"address\"},{\"name\":\"_parentTokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"childTokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"approvedAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_mokenName\",\"type\":\"string\"},{\"name\":\"_linkHash\",\"type\":\"bytes32\"},{\"name\":\"_currencyName\",\"type\":\"bytes32\"},{\"name\":\"_pricePaid\",\"type\":\"uint256\"}],\"name\":\"contractMint\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"childContractByIndex\",\"outputs\":[{\"name\":\"childContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"childTokenByIndex\",\"outputs\":[{\"name\":\"childTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mokenName\",\"type\":\"string\"}],\"name\":\"mokenNameExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"totalMokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"moken\",\"outputs\":[{\"name\":\"mokenName\",\"type\":\"string\"},{\"name\":\"era\",\"type\":\"bytes32\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPriceOffset\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mokenNameBytes32\",\"outputs\":[{\"name\":\"mokenNameBytes32_\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_childContract\",\"type\":\"address\"}],\"name\":\"totalChildTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"eraByIndex\",\"outputs\":[{\"name\":\"era\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mokenName\",\"outputs\":[{\"name\":\"mokenName_\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMintContracts\",\"outputs\":[{\"name\":\"totalMintContracts_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"rootOwnerOf\",\"outputs\":[{\"name\":\"rootOwner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintData\",\"outputs\":[{\"name\":\"mokensLength_\",\"type\":\"uint256\"},{\"name\":\"mintStepPrice_\",\"type\":\"uint256\"},{\"name\":\"mintPriceOffset_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"childExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"uint256\"}],\"name\":\"eraFromMokenData\",\"outputs\":[{\"name\":\"era\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"erc20ContractByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"totalMokensOwned\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"mintContractByIndex\",\"outputs\":[{\"name\":\"contract_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mokenName\",\"type\":\"string\"}],\"name\":\"mokenId\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mokenBytes32\",\"outputs\":[{\"name\":\"mokenNameBytes32\",\"type\":\"bytes32\"},{\"name\":\"era\",\"type\":\"bytes32\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_parentContract\",\"type\":\"address\"},{\"name\":\"_parentTokenId\",\"type\":\"uint256\"}],\"name\":\"totalChildTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenOwnerOf\",\"outputs\":[{\"name\":\"tokenOwner\",\"type\":\"bytes32\"},{\"name\":\"parentTokenId\",\"type\":\"uint256\"},{\"name\":\"isParent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mokenData\",\"outputs\":[{\"name\":\"data\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"totalChildContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEra\",\"outputs\":[{\"name\":\"era\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_data\",\"type\":\"bytes32\"}],\"name\":\"eraFromMokenData\",\"outputs\":[{\"name\":\"era\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"totalERC20Contracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eraName\",\"type\":\"bytes32\"}],\"name\":\"eraExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_eraName\",\"type\":\"bytes32\"}],\"name\":\"eraByName\",\"outputs\":[{\"name\":\"indexOfEra\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEras\",\"outputs\":[{\"name\":\"totalEras_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mokenEra\",\"outputs\":[{\"name\":\"era\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"isMintContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"getChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintPriceBuffer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"mokenNoName\",\"outputs\":[{\"name\":\"era\",\"type\":\"bytes32\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_mokenName\",\"type\":\"string\"},{\"name\":\"_linkHash\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentEraIndex\",\"outputs\":[{\"name\":\"indexOfEra\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"}],\"name\":\"balanceOfERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"approved\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOfChild\",\"outputs\":[{\"name\":\"parentTokenOwner\",\"type\":\"bytes32\"},{\"name\":\"parentTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"rootOwnerOfChild\",\"outputs\":[{\"name\":\"rootOwner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultURIStart\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintStepPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"mintContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"era\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"mokenName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currencyName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"mintPrice\",\"type\":\"uint256\"}],\"name\":\"MintPriceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_childContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"ReceivedChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_childContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"TransferChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ReceivedERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferERC20\",\"type\":\"event\"}]","ContractName":"Mokens","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"0000000000000000000000008e332fe4df2876cce3b9e6cab160c61ef4c31f77","Library":"","SwarmSource":"bzzr://e32748984db21c30a547d6a3f79d03e4e627fbf4514028d43ce72190101c79dc"}]}