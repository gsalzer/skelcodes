{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/***\r\n *     ____ _  _    __ _ __ _  __   ___ __ _ __  _  _ ____ \r\n *    (___ ( \\/ )  (  / (  ( \\/  \\ / __(  / /  \\/ )( (_  _)\r\n *     / __/)  (    )  (/    (  O ( (__ )  (  O ) \\/ ( )(  \r\n *    (____(_/\\_)  (__\\_\\_)__)\\__/ \\___(__\\_\\__/\\____/(__) \r\n * \r\n *                         HAMSTER LEAGUE\r\n *                     \r\n *                     https://2Xknockout.me\r\n * \r\n * COMMUNITY\r\n * https://discord.gg/GKHnMBs\r\n * http://t.me/Knockout2x\r\n * \r\n * HOW IT WORKS\r\n * Join the queue and wait. Each new user moves you down. \r\n * When you reach last place and someone join the list you will exit with X2\r\n * \r\n * #   Users    Deposit        Description\r\n * 2 | USER B | 0.1 ETH | 0.1 ETH moves to USER A\r\n * 1 | USER A | 0.1 ETH | +0.1 ETH\r\n *   |  EXIT  |         | USER A exit with +0.2 ETH\r\n * \r\n * FEATURES\r\n * -- VIP\r\n * Don't want to wait? Up your position in the list to penult place. Fee is 10% of league deposit and it is allowed once per 10 minutes.\r\n * -- TIMER & AUTO RESET\r\n * Timer is set for 24 hours. When it's up, queue drops and league starts over \r\n * from the beginning. Every +100 new users in the list decrease remaining \r\n * time by half. This is automated!\r\n * -- LUCKY CHANCE\r\n * When someone UP first time, he gives an amazing chance to the last one \r\n * shift to his place at regular queue\r\n * -- JACKPOT ON RESET \r\n * Any ETH stored at contract transfers to the latest VIP as a bonus\r\n * \r\n * GAS LIMITS\r\n * Dealing with arrays in Solidity is a pain.\r\n * Set gas limit to 300000\r\n * In the wild it uses 160k-230k, but anyway set it to 300k (unused gas will refund)\r\n * \r\n */\r\n\r\ncontract XKnockoutHamster2 {\r\n    \r\n  using SafeMath for uint256;\r\n\r\n  struct EntityStruct {\r\n    bool active;\r\n    bool vip;\r\n    uint listPointer;\r\n    uint256 date;\r\n    uint256 update;\r\n    uint256 exit;\r\n    uint256 profit;\r\n  }\r\n  \r\n  mapping(address => EntityStruct) public entityStructs;\r\n  address[] public entityList;\r\n  address[] public vipList;\r\n  address dev;\r\n  uint256 base = 100000000000000000; //base is 0.1 ETH\r\n  uint256 public startedAt = now; //every new deposit updates start timetoRegular\r\n  uint256 public timeRemaining = 24 hours; //every +100 users in queue half decrease timeRemaining\r\n  uint256 public devreward; //buy me a coffee\r\n  uint public round = 1; //when time is up, contract will reset automatically to next round\r\n  uint public shift = 0; //regular queue shift\r\n  uint public joined = 0; //stats\r\n  uint public exited = 0; //stats\r\n  bool public timetoRegular = true; //flag to switch queue\r\n  \r\n  constructor() public {\r\n     dev = msg.sender;\r\n  }\r\n  \r\n  function() public payable {\r\n    if(!checkRemaining()) { \r\n        if(msg.value == base) {\r\n            addToList();\r\n        } else if(msg.value == base.div(10)) {\r\n            up();\r\n        } else {\r\n            revert(\"Send 0.1 ETH to join the list or 0.01 ETH to up\");\r\n        }   \r\n    }\r\n  }\r\n  \r\n  function addToList() internal {\r\n      if(entityStructs[msg.sender].active) revert(\"You are already in the list\");\r\n      \r\n      newEntity(msg.sender, true);\r\n      joined++;\r\n\t  startedAt = now;\r\n      entityStructs[msg.sender].date = now;\r\n      entityStructs[msg.sender].profit = 0;\r\n      entityStructs[msg.sender].update = 0;\r\n      entityStructs[msg.sender].exit = 0;\r\n      entityStructs[msg.sender].active = true;\r\n      entityStructs[msg.sender].vip = false;\r\n      \r\n      /* EXIT */\r\n    \r\n      if(timetoRegular) {   \r\n        //Regular exit\r\n        entityStructs[entityList[shift]].profit += base;\r\n        if(entityStructs[entityList[shift]].profit == 2*base) {\r\n            exitREG();\r\n        }\r\n      } else {\r\n        //VIP exit\r\n        uint lastVIP = lastVIPkey();\r\n        entityStructs[vipList[lastVIP]].profit += base;\r\n          if(entityStructs[vipList[lastVIP]].profit == 2*base) {\r\n              exitVIP(vipList[lastVIP]);\r\n          }     \r\n      }\r\n  }\r\n  \r\n  function up() internal {\r\n      if(joined.sub(exited) < 3) revert(\"You are too alone to up\");\r\n      if(!entityStructs[msg.sender].active) revert(\"You are not in the list\");\r\n      if(entityStructs[msg.sender].vip && (now.sub(entityStructs[msg.sender].update)) < 600) revert (\"Up allowed once per 10 min\");\r\n      \r\n      if(!entityStructs[msg.sender].vip) {\r\n          \r\n          /*\r\n           * When somebody UP first time, he gives an amazing chance to the last one in the list\r\n           * shift to his place at regular queue\r\n           */\r\n           \r\n            uint rowToDelete = entityStructs[msg.sender].listPointer;\r\n            address keyToMove = entityList[entityList.length-1];\r\n            entityList[rowToDelete] = keyToMove;\r\n            entityStructs[keyToMove].listPointer = rowToDelete;\r\n            entityList.length--;\r\n           \r\n           //Add to VIP\r\n           entityStructs[msg.sender].update = now;\r\n           entityStructs[msg.sender].vip = true;\r\n           newVip(msg.sender, true);\r\n           \r\n           devreward += msg.value; //goes to marketing\r\n           \r\n      } else if (entityStructs[msg.sender].vip) {\r\n          \r\n          //User up again\r\n          entityStructs[msg.sender].update = now;\r\n          delete vipList[entityStructs[msg.sender].listPointer];\r\n          newVip(msg.sender, true);\r\n          devreward += msg.value; //goes to marketing\r\n      }\r\n  }\r\n\r\n  function newEntity(address entityAddress, bool entityData) internal returns(bool success) {\r\n    entityStructs[entityAddress].active = entityData;\r\n    entityStructs[entityAddress].listPointer = entityList.push(entityAddress) - 1;\r\n    return true;\r\n  }\r\n\r\n  function exitREG() internal returns(bool success) {\r\n    entityStructs[entityList[shift]].active = false;\r\n    entityStructs[entityList[shift]].exit = now;\r\n    entityList[shift].transfer( entityStructs[entityList[shift]].profit.mul(90).div(100) );\r\n    devreward += entityStructs[entityList[shift]].profit.mul(10).div(100);\r\n    exited++;\r\n    delete entityList[shift];\r\n    shift++;\r\n    //Switch queue to vip\r\n    if(lastVIPkey() != 9999) {\r\n     timetoRegular = false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  function newVip(address entityAddress, bool entityData) internal returns(bool success) {\r\n    entityStructs[entityAddress].vip = entityData;\r\n    entityStructs[entityAddress].listPointer = vipList.push(entityAddress) - 1;\r\n    return true;\r\n  }\r\n\r\n  function exitVIP(address entityAddress) internal returns(bool success) {\r\n    uint lastVIP = lastVIPkey();\r\n    entityStructs[vipList[lastVIP]].active = false;\r\n    entityStructs[vipList[lastVIP]].exit = now;\r\n    vipList[lastVIP].transfer( entityStructs[vipList[lastVIP]].profit.mul(90).div(100) );\r\n    devreward += entityStructs[vipList[lastVIP]].profit.mul(10).div(100);\r\n    //Supa dupa method to deal with arrays ^_^ \r\n    uint rowToDelete = entityStructs[entityAddress].listPointer;\r\n    address keyToMove = vipList[vipList.length-1];\r\n    vipList[rowToDelete] = keyToMove;\r\n    entityStructs[keyToMove].listPointer = rowToDelete;\r\n    vipList.length--;\r\n    exited++;\r\n    //Switch queue to regular\r\n    timetoRegular = true;\r\n    return true;\r\n  }\r\n  \r\n    function lastREGkey() public constant returns(uint) {\r\n        if(entityList.length == 0) return 9999;\r\n        if(shift == entityList.length) return 9999; //empty reg queue\r\n        \r\n        uint limit = entityList.length-1;\r\n        for(uint l=limit; l >= 0; l--) {\r\n            if(entityList[l] != address(0)) {\r\n                return l;\r\n            } \r\n        }\r\n        return 9999;\r\n    }\r\n  \r\n  function lastVIPkey() public constant returns(uint) {\r\n        if(vipList.length == 0) return 9999;\r\n        uint limit = vipList.length-1;\r\n        for(uint j=limit; j >= 0; j--) {\r\n            if(vipList[j] != address(0)) {\r\n                return j;\r\n            } \r\n        }\r\n        return 9999;\r\n    }\r\n  \r\n  function checkRemaining() public returns (bool) {\r\n      /* If time has come, reset the contract\r\n       * It's public because of possible gas issues, but nothing can happen\r\n       * while now < timeRemaining.add(startedAt)\r\n       */\r\n      if(now >= timeRemaining.add(startedAt)) {\r\n        //Killing VIP struct\r\n        if(lastVIPkey() != 9999) {\r\n            uint limit = vipList.length-1;\r\n            for(uint l=limit; l >= 0; l--) {\r\n                if(vipList[l] != address(0)) {\r\n                    entityStructs[vipList[l]].active = false;\r\n                    entityStructs[vipList[l]].vip = false;\r\n                    entityStructs[vipList[l]].date = 0;\r\n                }\r\n                if(l == 0) break;\r\n            }\r\n        }\r\n        //Killing Regular struct\r\n        if(lastREGkey() != 9999) {\r\n            for(uint r = shift; r <= entityList.length-1; r++) {\r\n                entityStructs[entityList[r]].active = false;\r\n                entityStructs[entityList[r]].date = 0;\r\n            }\r\n        }\r\n        //Buy me a coffee\r\n        rewardDev();\r\n        //If any ETH stored at contract, send it to latest VIP as a bonus\r\n        if(address(this).balance.sub(devreward) > 0) {\r\n            if(lastVIPkey() != 9999) {\r\n                vipList[lastVIPkey()].transfer(address(this).balance);\r\n            }\r\n        }\r\n        //Switch vars to initial state\r\n        vipList.length=0;\r\n        entityList.length=0;\r\n        shift = 0;\r\n        startedAt = now;\r\n        timeRemaining = 24 hours;\r\n        timetoRegular = true;\r\n        exited = joined = 0;\r\n        round++;\r\n        return true;\r\n      }\r\n      \r\n      //Decrease timeRemaining: every 100 users in queue divides it by half \r\n      uint range = joined.sub(exited).div(100);\r\n      if(range != 0) {\r\n        timeRemaining = timeRemaining.div(range.mul(2));  \r\n      } \r\n      return false;\r\n  }    \r\n  \r\n  function rewardDev() public {\r\n      //No one can modify devreward constant, it's safe from manipulations\r\n      dev.transfer(devreward);\r\n      devreward = 0;\r\n  }  \r\n  \r\n  function queueVIP() public view returns (address[]) {\r\n      //Return durty queue\r\n      return vipList;\r\n  }\r\n  \r\n  function queueREG() public view returns (address[]) {\r\n      //Return durty queue\r\n      return entityList;\r\n  }\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n   /* \r\n    * Message to other devs:\r\n    * Dealing with arrays in Solidity is a pain. Here we realized some supa dupa methods\r\n    * and decreased gas limit up to 220k. \r\n    * Lame auditors who can't understand the code, ping me at Discord.\r\n    * IF YOU RIP THIS CODE YOU WILL DIE WITH CANCER\r\n    */\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"shift\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timetoRegular\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entityList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devreward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"entityStructs\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"vip\",\"type\":\"bool\"},{\"name\":\"listPointer\",\"type\":\"uint256\"},{\"name\":\"date\",\"type\":\"uint256\"},{\"name\":\"update\",\"type\":\"uint256\"},{\"name\":\"exit\",\"type\":\"uint256\"},{\"name\":\"profit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"rewardDev\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vipList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queueVIP\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"joined\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"queueREG\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastREGkey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastVIPkey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"XKnockoutHamster2","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3fbee9ade4972e58e3869010086c7873badd54c47ec6e392f84d10958bdfae1c"}]}