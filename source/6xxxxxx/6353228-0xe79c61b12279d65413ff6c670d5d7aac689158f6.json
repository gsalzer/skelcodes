{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * Owned contract\r\n */\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Only the owner of contract\r\n     */ \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev transfer the ownership to other\r\n     *      - Only the owner can operate\r\n     */ \r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /** \r\n     * @dev Accept the ownership from last owner\r\n     */ \r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\ncontract TRNData is Owned {\r\n    TripioRoomNightData dataSource;\r\n    /**\r\n     * Only the valid vendor and the vendor is valid\r\n     */ \r\n    modifier onlyVendor {\r\n        uint256 vendorId = dataSource.vendorIds(msg.sender);\r\n        require(vendorId > 0);\r\n        (,,,bool valid) = dataSource.getVendor(vendorId);\r\n        require(valid);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * The vendor is valid\r\n     */\r\n    modifier vendorValid(address _vendor) {\r\n        uint256 vendorId = dataSource.vendorIds(_vendor);\r\n        require(vendorId > 0);\r\n        (,,,bool valid) = dataSource.getVendor(vendorId);\r\n        require(valid);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * The vendorId is valid\r\n     */\r\n    modifier vendorIdValid(uint256 _vendorId) {\r\n        (,,,bool valid) = dataSource.getVendor(_vendorId);\r\n        require(valid);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Rate plan exist.\r\n     */\r\n    modifier ratePlanExist(uint256 _vendorId, uint256 _rpid) {\r\n        (,,,bool valid) = dataSource.getVendor(_vendorId);\r\n        require(valid);\r\n        require(dataSource.ratePlanIsExist(_vendorId, _rpid));\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Token is valid\r\n     */\r\n    modifier validToken(uint256 _tokenId) {\r\n        require(_tokenId > 0);\r\n        require(dataSource.roomNightIndexToOwner(_tokenId) != address(0));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Tokens are valid\r\n     */\r\n    modifier validTokenInBatch(uint256[] _tokenIds) {\r\n        for(uint256 i = 0; i < _tokenIds.length; i++) {\r\n            require(_tokenIds[i] > 0);\r\n            require(dataSource.roomNightIndexToOwner(_tokenIds[i]) != address(0));\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Whether the `_tokenId` can be transfered\r\n     */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address owner = dataSource.roomNightIndexToOwner(_tokenId);\r\n        bool isOwner = (msg.sender == owner);\r\n        bool isApproval = (msg.sender == dataSource.roomNightApprovals(_tokenId));\r\n        bool isOperator = (dataSource.operatorApprovals(owner, msg.sender));\r\n        require(isOwner || isApproval || isOperator);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Whether the `_tokenIds` can be transfered\r\n     */\r\n    modifier canTransferInBatch(uint256[] _tokenIds) {\r\n        for(uint256 i = 0; i < _tokenIds.length; i++) {\r\n            address owner = dataSource.roomNightIndexToOwner(_tokenIds[i]);\r\n            bool isOwner = (msg.sender == owner);\r\n            bool isApproval = (msg.sender == dataSource.roomNightApprovals(_tokenIds[i]));\r\n            bool isOperator = (dataSource.operatorApprovals(owner, msg.sender));\r\n            require(isOwner || isApproval || isOperator);\r\n        }\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * Whether the `_tokenId` can be operated by `msg.sender`\r\n     */\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address owner = dataSource.roomNightIndexToOwner(_tokenId);\r\n        bool isOwner = (msg.sender == owner);\r\n        bool isOperator = (dataSource.operatorApprovals(owner, msg.sender));\r\n        require(isOwner || isOperator);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Whether the `_date` is valid(no hours, no seconds)\r\n     */\r\n    modifier validDate(uint256 _date) {\r\n        require(_date > 0);\r\n        require(dateIsLegal(_date));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Whether the `_dates` are valid(no hours, no seconds)\r\n     */\r\n    modifier validDates(uint256[] _dates) {\r\n        for(uint256 i = 0;i < _dates.length; i++) {\r\n            require(_dates[i] > 0);\r\n            require(dateIsLegal(_dates[i]));\r\n        }\r\n        _;\r\n    }\r\n\r\n    function dateIsLegal(uint256 _date) pure private returns(bool) {\r\n        uint256 year = _date / 10000;\r\n        uint256 mon = _date / 100 - year * 100;\r\n        uint256 day = _date - mon * 100 - year * 10000;\r\n        \r\n        if(year < 1970 || mon <= 0 || mon > 12 || day <= 0 || day > 31)\r\n            return false;\r\n\r\n        if(4 == mon || 6 == mon || 9 == mon || 11 == mon){\r\n            if (day == 31) {\r\n                return false;\r\n            }\r\n        }\r\n        if(((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0)) {\r\n            if(2 == mon && day > 29) {\r\n                return false;\r\n            }\r\n        }else {\r\n            if(2 == mon && day > 28){\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() public {\r\n\r\n    }\r\n}\r\n\r\n\r\ncontract TRNPrices is TRNData {\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    /**\r\n     * This emits when rate plan price changed\r\n     */\r\n    event RatePlanPriceChanged(uint256 indexed _rpid);\r\n\r\n    /**\r\n     * This emits when rate plan inventory changed\r\n     */\r\n    event RatePlanInventoryChanged(uint256 indexed _rpid);\r\n\r\n    /**\r\n     * This emits when rate plan base price changed\r\n     */\r\n    event RatePlanBasePriceChanged(uint256 indexed _rpid);\r\n    \r\n    function _updatePrices(uint256 _rpid, uint256 _date, uint16 _inventory, uint256[] _tokens, uint256[] _prices) private {\r\n        uint256 vendorId = dataSource.vendorIds(msg.sender);\r\n        dataSource.updateInventories(vendorId, _rpid, _date, _inventory);\r\n        for (uint256 tindex = 0; tindex < _tokens.length; tindex++) {\r\n            dataSource.updatePrice(vendorId, _rpid, _date, _tokens[tindex], _prices[tindex]);\r\n        }\r\n    }\r\n\r\n    function _updateInventories(uint256 _rpid, uint256 _date, uint16 _inventory) private {\r\n        uint256 vendorId = dataSource.vendorIds(msg.sender);\r\n        dataSource.updateInventories(vendorId, _rpid, _date, _inventory);\r\n    }\r\n\r\n    /**\r\n     * @dev Update base price assigned to a vendor by `_rpid`, `msg.sender`, `_dates`\r\n     *      Throw when `msg.sender` is not a vendor\r\n     *      Throw when `_rpid` not exist\r\n     *      Throw when `_tokens`'s length is not equal to `_prices`'s length or `_tokens`'s length is equal to zero\r\n     * @param _rpid The rate plan identifier\r\n     * @param _inventory The amount that can be sold\r\n     * @param _tokens The pricing currency token\r\n     * @param _prices The currency token selling price  \r\n     */\r\n    function updateBasePrice(uint256 _rpid, uint256[] _tokens, uint256[] _prices, uint16 _inventory) \r\n        external \r\n        ratePlanExist(dataSource.vendorIds(msg.sender), _rpid) \r\n        returns(bool) {\r\n        require(_tokens.length == _prices.length);\r\n        require(_prices.length > 0);\r\n        uint256 vendorId = dataSource.vendorIds(msg.sender);\r\n        dataSource.updateBaseInventory(vendorId, _rpid, _inventory);\r\n        for (uint256 tindex = 0; tindex < _tokens.length; tindex++) {\r\n            dataSource.updateBasePrice(vendorId, _rpid, _tokens[tindex], _prices[tindex]);\r\n        }\r\n        // Event \r\n        emit RatePlanBasePriceChanged(_rpid);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update prices assigned to a vendor by `_rpid`, `msg.sender`, `_dates`\r\n     *      Throw when `msg.sender` is not a vendor\r\n     *      Throw when `_rpid` not exist\r\n     *      Throw when `_dates`'s length lte 0\r\n     *      Throw when `_tokens`'s length is not equal to `_prices`'s length or `_tokens`'s length is equal to zero\r\n     * @param _rpid The rate plan identifier\r\n     * @param _dates The prices to be modified of `_dates`\r\n     * @param _inventory The amount that can be sold\r\n     * @param _tokens The pricing currency token\r\n     * @param _prices The currency token selling price  \r\n     */\r\n    function updatePrices(uint256 _rpid, uint256[] _dates, uint16 _inventory, uint256[] _tokens, uint256[] _prices)\r\n        external \r\n        ratePlanExist(dataSource.vendorIds(msg.sender), _rpid) \r\n        returns(bool) {\r\n        require(_dates.length > 0);\r\n        require(_tokens.length == _prices.length);\r\n        require(_prices.length > 0);\r\n        for (uint256 index = 0; index < _dates.length; index++) {\r\n            _updatePrices(_rpid, _dates[index], _inventory, _tokens, _prices);\r\n        }\r\n        // Event \r\n        emit RatePlanPriceChanged(_rpid);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Update inventory assigned to a vendor by `_rpid`, `msg.sender`, `_dates`\r\n     *      Throw when `msg.sender` is not a vendor\r\n     *      Throw when `_rpid` not exist\r\n     *      Throw when `_dates`'s length lte 0\r\n     * @param _rpid The rate plan identifier\r\n     * @param _dates The prices to be modified of `_dates`\r\n     * @param _inventory The amount that can be sold\r\n     */\r\n    function updateInventories(uint256 _rpid, uint256[] _dates, uint16 _inventory) \r\n        external \r\n        ratePlanExist(dataSource.vendorIds(msg.sender), _rpid) \r\n        returns(bool) {\r\n        for (uint256 index = 0; index < _dates.length; index++) {\r\n            _updateInventories(_rpid, _dates[index], _inventory);\r\n        }\r\n\r\n        // Event\r\n        emit RatePlanInventoryChanged(_rpid);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the inventories of `_vendor`'s RP(`_rpid`) on `_dates`\r\n     *      Throw when `_rpid` not exist\r\n     *      Throw when `_dates`'s count lte 0\r\n     * @param _vendorId The vendor Id\r\n     * @param _rpid The rate plan identifier\r\n     * @param _dates The inventories to be returned of `_dates`\r\n     * @return The inventories\r\n     */\r\n    function inventoriesOfDate(uint256 _vendorId, uint256 _rpid, uint256[] _dates) \r\n        external \r\n        view\r\n        ratePlanExist(_vendorId, _rpid) \r\n        returns(uint16[]) {\r\n        require(_dates.length > 0);\r\n        uint16[] memory result = new uint16[](_dates.length);\r\n        for (uint256 index = 0; index < _dates.length; index++) {\r\n            uint256 date = _dates[index];\r\n            (uint16 inventory,) = dataSource.getInventory(_vendorId, _rpid, date);\r\n            result[index] = inventory;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the prices of `_vendor`'s RP(`_rpid`) on `_dates`\r\n     *      Throw when `_rpid` not exist\r\n     *      Throw when `_dates`'s count lte 0\r\n     * @param _vendorId The vendor Id\r\n     * @param _rpid The rate plan identifier\r\n     * @param _dates The inventories to be returned of `_dates`\r\n     * @param _token The digital currency token\r\n     * @return The prices\r\n     */\r\n    function pricesOfDate(uint256 _vendorId, uint256 _rpid, uint256[] _dates, uint256 _token)\r\n        external \r\n        view\r\n        ratePlanExist(_vendorId, _rpid) \r\n        returns(uint256[]) {\r\n        require(_dates.length > 0);\r\n        uint256[] memory result = new uint256[](_dates.length);\r\n        for (uint256 index = 0; index < _dates.length; index++) {\r\n            (,, uint256 _price) = dataSource.getPrice(_vendorId, _rpid, _dates[index], _token);\r\n            result[index] = _price;\r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the prices and inventories of `_vendor`'s RP(`_rpid`) on `_dates`\r\n     *      Throw when `_rpid` not exist\r\n     *      Throw when `_dates`'s count lte 0\r\n     * @param _vendorId The vendor Id\r\n     * @param _rpid The rate plan identifier\r\n     * @param _dates The inventories to be returned of `_dates`\r\n     * @param _token The digital currency token\r\n     * @return The prices and inventories\r\n     */\r\n    function pricesAndInventoriesOfDate(uint256 _vendorId, uint256 _rpid, uint256[] _dates, uint256 _token)\r\n        external \r\n        view\r\n        returns(uint256[], uint16[]) {\r\n        uint256[] memory prices = new uint256[](_dates.length);\r\n        uint16[] memory inventories = new uint16[](_dates.length);\r\n        for (uint256 index = 0; index < _dates.length; index++) {\r\n            (uint16 _inventory,, uint256 _price) = dataSource.getPrice(_vendorId, _rpid, _dates[index], _token);\r\n            prices[index] = _price;\r\n            inventories[index] = _inventory;\r\n        }\r\n        return (prices, inventories);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the RP's price and inventory of `_date`.\r\n     *      Throw when `_rpid` not exist\r\n     * @param _vendorId The vendor Id\r\n     * @param _rpid The rate plan identifier\r\n     * @param _date The price and inventory to be returneed of `_date`\r\n     * @param _token The digital currency token\r\n     * @return The price and inventory\r\n     */\r\n    function priceOfDate(uint256 _vendorId, uint256 _rpid, uint256 _date, uint256 _token) \r\n        external \r\n        view\r\n        ratePlanExist(_vendorId, _rpid) \r\n        returns(uint16 _inventory, uint256 _price) {\r\n        (_inventory, , _price) = dataSource.getPrice(_vendorId, _rpid, _date, _token);\r\n    }\r\n}\r\n\r\n/**\r\n * This utility library was forked from https://github.com/o0ragman0o/LibCLL\r\n */\r\nlibrary LinkedListLib {\r\n\r\n    uint256 constant NULL = 0;\r\n    uint256 constant HEAD = 0;\r\n    bool constant PREV = false;\r\n    bool constant NEXT = true;\r\n\r\n    struct LinkedList {\r\n        mapping (uint256 => mapping (bool => uint256)) list;\r\n        uint256 length;\r\n        uint256 index;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if the list exists\r\n     * @param self stored linked list from contract\r\n     */\r\n    function listExists(LinkedList storage self)\r\n        internal\r\n        view returns (bool) {\r\n        return self.length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev returns true if the node exists\r\n     * @param self stored linked list from contract\r\n     * @param _node a node to search for\r\n     */\r\n    function nodeExists(LinkedList storage self, uint256 _node)\r\n        internal\r\n        view returns (bool) {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of elements in the list\r\n     * @param self stored linked list from contract\r\n     */ \r\n    function sizeOf(LinkedList storage self) \r\n        internal \r\n        view \r\n        returns (uint256 numElements) {\r\n        return self.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the links of a node as a tuple\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to get\r\n     */\r\n    function getNode(LinkedList storage self, uint256 _node)\r\n        public \r\n        view \r\n        returns (bool, uint256, uint256) {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false, 0, 0);\r\n        } else {\r\n            return (true, self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the link of a node `_node` in direction `_direction`.\r\n     * @param self stored linked list from contract\r\n     * @param _node id of the node to step from\r\n     * @param _direction direction to step in\r\n     */\r\n    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\r\n        public \r\n        view \r\n        returns (bool, uint256) {\r\n        if (!nodeExists(self,_node)) {\r\n            return (false,0);\r\n        } else {\r\n            return (true,self.list[_node][_direction]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Can be used before `insert` to build an ordered list\r\n     * @param self stored linked list from contract\r\n     * @param _node an existing node to search from, e.g. HEAD.\r\n     * @param _value value to seek\r\n     * @param _direction direction to seek in\r\n     * @return next first node beyond '_node' in direction `_direction`\r\n     */\r\n    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\r\n        public \r\n        view \r\n        returns (uint256) {\r\n        if (sizeOf(self) == 0) { \r\n            return 0; \r\n        }\r\n        require((_node == 0) || nodeExists(self,_node));\r\n        bool exists;\r\n        uint256 next;\r\n        (exists,next) = getAdjacent(self, _node, _direction);\r\n        while  ((next != 0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction];\r\n        return next;\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n     * @param self stored linked list from contract\r\n     * @param _node first node for linking\r\n     * @param _link  node to link to in the _direction\r\n     */\r\n    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction) \r\n        private {\r\n        self.list[_link][!_direction] = _node;\r\n        self.list[_node][_direction] = _link;\r\n    }\r\n\r\n    /**\r\n     * @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n     * @param self stored linked list from contract\r\n     * @param _node existing node\r\n     * @param _new  new node to insert\r\n     * @param _direction direction to insert node in\r\n     */\r\n    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) \r\n        internal \r\n        returns (bool) {\r\n        if(!nodeExists(self,_new) && nodeExists(self,_node)) {\r\n            uint256 c = self.list[_node][_direction];\r\n            createLink(self, _node, _new, _direction);\r\n            createLink(self, _new, c, _direction);\r\n            self.length++;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev removes an entry from the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _node node to remove from the list\r\n     */\r\n    function remove(LinkedList storage self, uint256 _node) \r\n        internal \r\n        returns (uint256) {\r\n        if ((_node == NULL) || (!nodeExists(self,_node))) { \r\n            return 0; \r\n        }\r\n        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n        self.length--;\r\n        return _node;\r\n    }\r\n\r\n    /**\r\n     * @dev pushes an enrty to the head of the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _index The node Id\r\n     * @param _direction push to the head (NEXT) or tail (PREV)\r\n     */\r\n    function add(LinkedList storage self, uint256 _index, bool _direction) \r\n        internal \r\n        returns (uint256) {\r\n        insert(self, HEAD, _index, _direction);\r\n        return self.index;\r\n    }\r\n\r\n    /**\r\n     * @dev pushes an enrty to the head of the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _direction push to the head (NEXT) or tail (PREV)\r\n     */\r\n    function push(LinkedList storage self, bool _direction) \r\n        internal \r\n        returns (uint256) {\r\n        self.index++;\r\n        insert(self, HEAD, self.index, _direction);\r\n        return self.index;\r\n    }\r\n\r\n    /**\r\n     * @dev pops the first entry from the linked list\r\n     * @param self stored linked list from contract\r\n     * @param _direction pop from the head (NEXT) or the tail (PREV)\r\n     */\r\n    function pop(LinkedList storage self, bool _direction) \r\n        internal \r\n        returns (uint256) {\r\n        bool exists;\r\n        uint256 adj;\r\n        (exists,adj) = getAdjacent(self, HEAD, _direction);\r\n        return remove(self, adj);\r\n    }\r\n}\r\n\r\n\r\ncontract TripioToken {\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n}\r\n\r\ncontract TripioRoomNightData is Owned {\r\n    using LinkedListLib for LinkedListLib.LinkedList;\r\n    // Interface signature of erc165.\r\n    // bytes4(keccak256(\"supportsInterface(bytes4)\"))\r\n    bytes4 constant public interfaceSignature_ERC165 = 0x01ffc9a7;\r\n\r\n    // Interface signature of erc721 metadata.\r\n    // bytes4(keccak256(\"name()\")) ^ bytes4(keccak256(\"symbol()\")) ^ bytes4(keccak256(\"tokenURI(uint256)\"));\r\n    bytes4 constant public interfaceSignature_ERC721Metadata = 0x06fdde03 ^ 0x95d89b41 ^ 0xc87b56dd;\r\n        \r\n    // Interface signature of erc721.\r\n    // bytes4(keccak256(\"balanceOf(address)\")) ^\r\n    // bytes4(keccak256(\"ownerOf(uint256)\")) ^\r\n    // bytes4(keccak256(\"safeTransferFrom(address,address,uint256,bytes)\")) ^\r\n    // bytes4(keccak256(\"safeTransferFrom(address,address,uint256)\")) ^\r\n    // bytes4(keccak256(\"transferFrom(address,address,uint256)\")) ^\r\n    // bytes4(keccak256(\"approve(address,uint256)\")) ^\r\n    // bytes4(keccak256(\"setApprovalForAll(address,bool)\")) ^\r\n    // bytes4(keccak256(\"getApproved(uint256)\")) ^\r\n    // bytes4(keccak256(\"isApprovedForAll(address,address)\"));\r\n    bytes4 constant public interfaceSignature_ERC721 = 0x70a08231 ^ 0x6352211e ^ 0xb88d4fde ^ 0x42842e0e ^ 0x23b872dd ^ 0x095ea7b3 ^ 0xa22cb465 ^ 0x081812fc ^ 0xe985e9c5;\r\n\r\n    // Base URI of token asset\r\n    string public tokenBaseURI;\r\n\r\n    // Authorized contracts\r\n    struct AuthorizedContract {\r\n        string name;\r\n        address acontract;\r\n    }\r\n    mapping (address=>uint256) public authorizedContractIds;\r\n    mapping (uint256 => AuthorizedContract) public authorizedContracts;\r\n    LinkedListLib.LinkedList public authorizedContractList = LinkedListLib.LinkedList(0, 0);\r\n\r\n    // Rate plan prices\r\n    struct Price {\r\n        uint16 inventory;       // Rate plan inventory\r\n        bool init;              // Whether the price is initied\r\n        mapping (uint256 => uint256) tokens;\r\n    }\r\n\r\n    // Vendor hotel RPs\r\n    struct RatePlan {\r\n        string name;            // Name of rate plan.\r\n        uint256 timestamp;      // Create timestamp.\r\n        bytes32 ipfs;           // The address of rate plan detail on IPFS.\r\n        Price basePrice;        // The base price of rate plan\r\n        mapping (uint256 => Price) prices;   // date -> Price\r\n    }\r\n\r\n    // Vendors\r\n    struct Vendor {\r\n        string name;            // Name of vendor.\r\n        address vendor;         // Address of vendor.\r\n        uint256 timestamp;      // Create timestamp.\r\n        bool valid;             // Whether the vendor is valid(default is true)\r\n        LinkedListLib.LinkedList ratePlanList;\r\n        mapping (uint256=>RatePlan) ratePlans;\r\n    }\r\n    mapping (address => uint256) public vendorIds;\r\n    mapping (uint256 => Vendor) vendors;\r\n    LinkedListLib.LinkedList public vendorList = LinkedListLib.LinkedList(0, 0);\r\n\r\n    // Supported digital currencies\r\n    mapping (uint256 => address) public tokenIndexToAddress;\r\n    LinkedListLib.LinkedList public tokenList = LinkedListLib.LinkedList(0, 0);\r\n\r\n    // RoomNight tokens\r\n    struct RoomNight {\r\n        uint256 vendorId;\r\n        uint256 rpid;\r\n        uint256 token;          // The digital currency token \r\n        uint256 price;          // The digital currency price\r\n        uint256 timestamp;      // Create timestamp.\r\n        uint256 date;           // The checkin date\r\n        bytes32 ipfs;           // The address of rate plan detail on IPFS.\r\n    }\r\n    RoomNight[] public roomnights;\r\n    // rnid -> owner\r\n    mapping (uint256 => address) public roomNightIndexToOwner;\r\n\r\n    // Owner Account\r\n    mapping (address => LinkedListLib.LinkedList) public roomNightOwners;\r\n\r\n    // Vendor Account\r\n    mapping (address => LinkedListLib.LinkedList) public roomNightVendors;\r\n\r\n    // The authorized address for each TRN\r\n    mapping (uint256 => address) public roomNightApprovals;\r\n\r\n    // The authorized operators for each address\r\n    mapping (address => mapping (address => bool)) public operatorApprovals;\r\n\r\n    // The applications of room night redund\r\n    mapping (address => mapping (uint256 => bool)) public refundApplications;\r\n\r\n    // The signature of `onERC721Received(address,uint256,bytes)`\r\n    // bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"));\r\n    bytes4 constant public ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    /**\r\n     * This emits when contract authorized\r\n     */\r\n    event ContractAuthorized(address _contract);\r\n\r\n    /**\r\n     * This emits when contract deauthorized\r\n     */\r\n    event ContractDeauthorized(address _contract);\r\n\r\n    /**\r\n     * The contract is valid\r\n     */\r\n    modifier authorizedContractValid(address _contract) {\r\n        require(authorizedContractIds[_contract] > 0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * The contract is valid\r\n     */\r\n    modifier authorizedContractIdValid(uint256 _cid) {\r\n        require(authorizedContractList.nodeExists(_cid));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Only the owner or authorized contract is valid\r\n     */\r\n    modifier onlyOwnerOrAuthorizedContract {\r\n        require(msg.sender == owner || authorizedContractIds[msg.sender] > 0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() public {\r\n        // Add one invalid RoomNight, avoid subscript 0\r\n        roomnights.push(RoomNight(0, 0, 0, 0, 0, 0, 0));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the node list and next node as a tuple\r\n     * @param self stored linked list from contract\r\n     * @param _node the begin id of the node to get\r\n     * @param _limit the total nodes of one page\r\n     * @param _direction direction to step in\r\n     */\r\n    function getNodes(LinkedListLib.LinkedList storage self, uint256 _node, uint256 _limit, bool _direction) \r\n        private\r\n        view \r\n        returns (uint256[], uint256) {\r\n        bool exists;\r\n        uint256 i = 0;\r\n        uint256 ei = 0;\r\n        uint256 index = 0;\r\n        uint256 count = _limit;\r\n        if(count > self.length) {\r\n            count = self.length;\r\n        }\r\n        (exists, i) = self.getAdjacent(_node, _direction);\r\n        if(!exists || count == 0) {\r\n            return (new uint256[](0), 0);\r\n        }else {\r\n            uint256[] memory temp = new uint256[](count);\r\n            if(_node != 0) {\r\n                index++;\r\n                temp[0] = _node;\r\n            }\r\n            while (i != 0 && index < count) {\r\n                temp[index] = i;\r\n                (exists,i) = self.getAdjacent(i, _direction);\r\n                index++;\r\n            }\r\n            ei = i;\r\n            if(index < count) {\r\n                uint256[] memory result = new uint256[](index);\r\n                for(i = 0; i < index; i++) {\r\n                    result[i] = temp[i];\r\n                }\r\n                return (result, ei);\r\n            }else {\r\n                return (temp, ei);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Authorize `_contract` to execute this contract's funs\r\n     * @param _contract The contract address\r\n     * @param _name The contract name\r\n     */\r\n    function authorizeContract(address _contract, string _name) \r\n        public \r\n        onlyOwner \r\n        returns(bool) {\r\n        uint256 codeSize;\r\n        assembly { codeSize := extcodesize(_contract) }\r\n        require(codeSize != 0);\r\n        // Not exists\r\n        require(authorizedContractIds[_contract] == 0);\r\n\r\n        // Add\r\n        uint256 id = authorizedContractList.push(false);\r\n        authorizedContractIds[_contract] = id;\r\n        authorizedContracts[id] = AuthorizedContract(_name, _contract);\r\n\r\n        // Event\r\n        emit ContractAuthorized(_contract);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Deauthorized `_contract` by address\r\n     * @param _contract The contract address\r\n     */\r\n    function deauthorizeContract(address _contract) \r\n        public \r\n        onlyOwner\r\n        authorizedContractValid(_contract)\r\n        returns(bool) {\r\n        uint256 id = authorizedContractIds[_contract];\r\n        authorizedContractList.remove(id);\r\n        authorizedContractIds[_contract] = 0;\r\n        delete authorizedContracts[id];\r\n        \r\n        // Event \r\n        emit ContractDeauthorized(_contract);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Deauthorized `_contract` by contract id\r\n     * @param _cid The contract id\r\n     */\r\n    function deauthorizeContractById(uint256 _cid) \r\n        public\r\n        onlyOwner\r\n        authorizedContractIdValid(_cid)\r\n        returns(bool) {\r\n        address acontract = authorizedContracts[_cid].acontract;\r\n        authorizedContractList.remove(_cid);\r\n        authorizedContractIds[acontract] = 0;\r\n        delete authorizedContracts[_cid];\r\n\r\n        // Event \r\n        emit ContractDeauthorized(acontract);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Get authorize contract ids by page\r\n     * @param _from The begin authorize contract id\r\n     * @param _limit How many authorize contract ids one page\r\n     * @return The authorize contract ids and the next authorize contract id as tuple, the next page not exists when next eq 0\r\n     */\r\n    function getAuthorizeContractIds(uint256 _from, uint256 _limit) \r\n        external \r\n        view \r\n        returns(uint256[], uint256){\r\n        return getNodes(authorizedContractList, _from, _limit, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Get authorize contract by id\r\n     * @param _cid Then authorize contract id\r\n     * @return The authorize contract info(_name, _acontract)\r\n     */\r\n    function getAuthorizeContract(uint256 _cid) \r\n        external \r\n        view \r\n        returns(string _name, address _acontract) {\r\n        AuthorizedContract memory acontract = authorizedContracts[_cid]; \r\n        _name = acontract.name;\r\n        _acontract = acontract.acontract;\r\n    }\r\n\r\n    /*************************************** GET ***************************************/\r\n\r\n    /**\r\n     * @dev Get the rate plan by `_vendorId` and `_rpid`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     */\r\n    function getRatePlan(uint256 _vendorId, uint256 _rpid) \r\n        public \r\n        view \r\n        returns (string _name, uint256 _timestamp, bytes32 _ipfs) {\r\n        _name = vendors[_vendorId].ratePlans[_rpid].name;\r\n        _timestamp = vendors[_vendorId].ratePlans[_rpid].timestamp;\r\n        _ipfs = vendors[_vendorId].ratePlans[_rpid].ipfs;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the rate plan price by `_vendorId`, `_rpid`, `_date` and `_tokenId`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _date The date desc (20180723)\r\n     * @param _tokenId The digital token id\r\n     * @return The price info(inventory, init, price)\r\n     */\r\n    function getPrice(uint256 _vendorId, uint256 _rpid, uint256 _date, uint256 _tokenId) \r\n        public\r\n        view \r\n        returns(uint16 _inventory, bool _init, uint256 _price) {\r\n        _inventory = vendors[_vendorId].ratePlans[_rpid].prices[_date].inventory;\r\n        _init = vendors[_vendorId].ratePlans[_rpid].prices[_date].init;\r\n        _price = vendors[_vendorId].ratePlans[_rpid].prices[_date].tokens[_tokenId];\r\n        if(!_init) {\r\n            // Get the base price\r\n            _inventory = vendors[_vendorId].ratePlans[_rpid].basePrice.inventory;\r\n            _price = vendors[_vendorId].ratePlans[_rpid].basePrice.tokens[_tokenId];\r\n            _init = vendors[_vendorId].ratePlans[_rpid].basePrice.init;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Get the rate plan prices by `_vendorId`, `_rpid`, `_dates` and `_tokenId`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _dates The dates desc ([20180723,20180724,20180725])\r\n     * @param _tokenId The digital token id\r\n     * @return The price info(inventory, init, price)\r\n     */\r\n    function getPrices(uint256 _vendorId, uint256 _rpid, uint256[] _dates, uint256 _tokenId) \r\n        public\r\n        view \r\n        returns(uint16[] _inventories, uint256[] _prices) {\r\n        uint16[] memory inventories = new uint16[](_dates.length);\r\n        uint256[] memory prices = new uint256[](_dates.length);\r\n        uint256 date;\r\n        for(uint256 i = 0; i < _dates.length; i++) {\r\n            date = _dates[i];\r\n            uint16 inventory = vendors[_vendorId].ratePlans[_rpid].prices[date].inventory;\r\n            bool init = vendors[_vendorId].ratePlans[_rpid].prices[date].init;\r\n            uint256 price = vendors[_vendorId].ratePlans[_rpid].prices[date].tokens[_tokenId];\r\n            if(!init) {\r\n                // Get the base price\r\n                inventory = vendors[_vendorId].ratePlans[_rpid].basePrice.inventory;\r\n                price = vendors[_vendorId].ratePlans[_rpid].basePrice.tokens[_tokenId];\r\n                init = vendors[_vendorId].ratePlans[_rpid].basePrice.init;\r\n            }\r\n            inventories[i] = inventory;\r\n            prices[i] = price;\r\n        }\r\n        return (inventories, prices);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the inventory by  by `_vendorId`, `_rpid` and `_date`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _date The date desc (20180723)\r\n     * @return The inventory info(inventory, init)\r\n     */\r\n    function getInventory(uint256 _vendorId, uint256 _rpid, uint256 _date) \r\n        public\r\n        view \r\n        returns(uint16 _inventory, bool _init) {\r\n        _inventory = vendors[_vendorId].ratePlans[_rpid].prices[_date].inventory;\r\n        _init = vendors[_vendorId].ratePlans[_rpid].prices[_date].init;\r\n        if(!_init) {\r\n            // Get the base price\r\n            _inventory = vendors[_vendorId].ratePlans[_rpid].basePrice.inventory;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Whether the rate plan is exist\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @return If the rate plan of the vendor is exist returns true otherwise return false\r\n     */\r\n    function ratePlanIsExist(uint256 _vendorId, uint256 _rpid) \r\n        public \r\n        view \r\n        returns (bool) {\r\n        return vendors[_vendorId].ratePlanList.nodeExists(_rpid);\r\n    }\r\n\r\n    /**\r\n     * @dev Get orders of owner by page\r\n     * @param _owner The owner address\r\n     * @param _from The begin id of the node to get\r\n     * @param _limit The total nodes of one page\r\n     * @param _direction Direction to step in\r\n     * @return The order ids and the next id\r\n     */\r\n    function getOrdersOfOwner(address _owner, uint256 _from, uint256 _limit, bool _direction) \r\n        public \r\n        view \r\n        returns (uint256[], uint256) {\r\n        return getNodes(roomNightOwners[_owner], _from, _limit, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Get orders of vendor by page\r\n     * @param _owner The vendor address\r\n     * @param _from The begin id of the node to get\r\n     * @param _limit The total nodes of on page\r\n     * @param _direction Direction to step in \r\n     * @return The order ids and the next id\r\n     */\r\n    function getOrdersOfVendor(address _owner, uint256 _from, uint256 _limit, bool _direction) \r\n        public \r\n        view \r\n        returns (uint256[], uint256) {\r\n        return getNodes(roomNightVendors[_owner], _from, _limit, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the token count of somebody \r\n     * @param _owner The owner of token\r\n     * @return The token count of `_owner`\r\n     */\r\n    function balanceOf(address _owner) \r\n        public \r\n        view \r\n        returns(uint256) {\r\n        return roomNightOwners[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Get rate plan ids of `_vendorId`\r\n     * @param _from The begin id of the node to get\r\n     * @param _limit The total nodes of on page\r\n     * @param _direction Direction to step in \r\n     * @return The rate plan ids and the next id\r\n     */\r\n    function getRatePlansOfVendor(uint256 _vendorId, uint256 _from, uint256 _limit, bool _direction) \r\n        public \r\n        view \r\n        returns(uint256[], uint256) {\r\n        return getNodes(vendors[_vendorId].ratePlanList, _from, _limit, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Get token ids\r\n     * @param _from The begin id of the node to get\r\n     * @param _limit The total nodes of on page\r\n     * @param _direction Direction to step in \r\n     * @return The token ids and the next id\r\n     */\r\n    function getTokens(uint256 _from, uint256 _limit, bool _direction) \r\n        public \r\n        view \r\n        returns(uint256[], uint256) {\r\n        return getNodes(tokenList, _from, _limit, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Get token Info\r\n     * @param _tokenId The token id\r\n     * @return The token info(symbol, name, decimals)\r\n     */\r\n    function getToken(uint256 _tokenId)\r\n        public \r\n        view \r\n        returns(string _symbol, string _name, uint8 _decimals, address _token) {\r\n        _token = tokenIndexToAddress[_tokenId];\r\n        TripioToken tripio = TripioToken(_token);\r\n        _symbol = tripio.symbol();\r\n        _name = tripio.name();\r\n        _decimals = tripio.decimals();\r\n    }\r\n\r\n    /**\r\n     * @dev Get vendor ids\r\n     * @param _from The begin id of the node to get\r\n     * @param _limit The total nodes of on page\r\n     * @param _direction Direction to step in \r\n     * @return The vendor ids and the next id\r\n     */\r\n    function getVendors(uint256 _from, uint256 _limit, bool _direction) \r\n        public \r\n        view \r\n        returns(uint256[], uint256) {\r\n        return getNodes(vendorList, _from, _limit, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the vendor infomation by vendorId\r\n     * @param _vendorId The vendor id\r\n     * @return The vendor infomation(name, vendor, timestamp, valid)\r\n     */\r\n    function getVendor(uint256 _vendorId) \r\n        public \r\n        view \r\n        returns(string _name, address _vendor,uint256 _timestamp, bool _valid) {\r\n        _name = vendors[_vendorId].name;\r\n        _vendor = vendors[_vendorId].vendor;\r\n        _timestamp = vendors[_vendorId].timestamp;\r\n        _valid = vendors[_vendorId].valid;\r\n    }\r\n\r\n    /*************************************** SET ***************************************/\r\n    /**\r\n     * @dev Update base uri of token metadata\r\n     * @param _tokenBaseURI The base uri\r\n     */\r\n    function updateTokenBaseURI(string _tokenBaseURI) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        tokenBaseURI = _tokenBaseURI;\r\n    }\r\n\r\n    /**\r\n     * @dev Push order to user's order list\r\n     * @param _owner The buyer address\r\n     * @param _rnid The room night order id\r\n     * @param _direction direction to step in\r\n     */\r\n    function pushOrderOfOwner(address _owner, uint256 _rnid, bool _direction) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        if(!roomNightOwners[_owner].listExists()) {\r\n            roomNightOwners[_owner] = LinkedListLib.LinkedList(0, 0);\r\n        }\r\n        roomNightOwners[_owner].add(_rnid, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove order from owner's order list\r\n     * @param _owner The owner address\r\n     * @param _rnid The room night order id\r\n     */\r\n    function removeOrderOfOwner(address _owner, uint _rnid) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        require(roomNightOwners[_owner].nodeExists(_rnid));\r\n        roomNightOwners[_owner].remove(_rnid);\r\n    }\r\n\r\n    /**\r\n     * @dev Push order to the vendor's order list\r\n     * @param _vendor The vendor address\r\n     * @param _rnid The room night order id\r\n     * @param _direction direction to step in\r\n     */\r\n    function pushOrderOfVendor(address _vendor, uint256 _rnid, bool _direction) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        if(!roomNightVendors[_vendor].listExists()) {\r\n            roomNightVendors[_vendor] = LinkedListLib.LinkedList(0, 0);\r\n        }\r\n        roomNightVendors[_vendor].add(_rnid, _direction);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove order from vendor's order list\r\n     * @param _vendor The vendor address\r\n     * @param _rnid The room night order id\r\n     */\r\n    function removeOrderOfVendor(address _vendor, uint256 _rnid) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        require(roomNightVendors[_vendor].nodeExists(_rnid));\r\n        roomNightVendors[_vendor].remove(_rnid);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token to somebody\r\n     * @param _tokenId The token id \r\n     * @param _to The target owner of the token\r\n     */\r\n    function transferTokenTo(uint256 _tokenId, address _to) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        roomNightIndexToOwner[_tokenId] = _to;\r\n        roomNightApprovals[_tokenId] = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `_to` to operate the `_tokenId`\r\n     * @param _tokenId The token id\r\n     * @param _to Somebody to be approved\r\n     */\r\n    function approveTokenTo(uint256 _tokenId, address _to) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        roomNightApprovals[_tokenId] = _to;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve `_operator` to operate all the Token of `_to`\r\n     * @param _operator The operator to be approved\r\n     * @param _to The owner of tokens to be operate\r\n     * @param _approved Approved or not\r\n     */\r\n    function approveOperatorTo(address _operator, address _to, bool _approved) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        operatorApprovals[_to][_operator] = _approved;\r\n    } \r\n\r\n    /**\r\n     * @dev Update base price of rate plan\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _tokenId The digital token id\r\n     * @param _price The price to be updated\r\n     */\r\n    function updateBasePrice(uint256 _vendorId, uint256 _rpid, uint256 _tokenId, uint256 _price)\r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        vendors[_vendorId].ratePlans[_rpid].basePrice.init = true;\r\n        vendors[_vendorId].ratePlans[_rpid].basePrice.tokens[_tokenId] = _price;\r\n    }\r\n\r\n    /**\r\n     * @dev Update base inventory of rate plan \r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _inventory The inventory to be updated\r\n     */\r\n    function updateBaseInventory(uint256 _vendorId, uint256 _rpid, uint16 _inventory)\r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        vendors[_vendorId].ratePlans[_rpid].basePrice.inventory = _inventory;\r\n    }\r\n\r\n    /**\r\n     * @dev Update price by `_vendorId`, `_rpid`, `_date`, `_tokenId` and `_price`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _date The date desc (20180723)\r\n     * @param _tokenId The digital token id\r\n     * @param _price The price to be updated\r\n     */\r\n    function updatePrice(uint256 _vendorId, uint256 _rpid, uint256 _date, uint256 _tokenId, uint256 _price)\r\n        public\r\n        onlyOwnerOrAuthorizedContract {\r\n        if (vendors[_vendorId].ratePlans[_rpid].prices[_date].init) {\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date].tokens[_tokenId] = _price;\r\n        } else {\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date] = Price(0, true);\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date].tokens[_tokenId] = _price;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update inventory by `_vendorId`, `_rpid`, `_date`, `_inventory`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _date The date desc (20180723)\r\n     * @param _inventory The inventory to be updated\r\n     */\r\n    function updateInventories(uint256 _vendorId, uint256 _rpid, uint256 _date, uint16 _inventory)\r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        if (vendors[_vendorId].ratePlans[_rpid].prices[_date].init) {\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date].inventory = _inventory;\r\n        } else {\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date] = Price(_inventory, true);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reduce inventories\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _date The date desc (20180723)\r\n     * @param _inventory The amount to be reduced\r\n     */\r\n    function reduceInventories(uint256 _vendorId, uint256 _rpid, uint256 _date, uint16 _inventory) \r\n        public  \r\n        onlyOwnerOrAuthorizedContract {\r\n        uint16 a = 0;\r\n        if(vendors[_vendorId].ratePlans[_rpid].prices[_date].init) {\r\n            a = vendors[_vendorId].ratePlans[_rpid].prices[_date].inventory;\r\n            require(_inventory <= a);\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date].inventory = a - _inventory;\r\n        }else if(vendors[_vendorId].ratePlans[_rpid].basePrice.init){\r\n            a = vendors[_vendorId].ratePlans[_rpid].basePrice.inventory;\r\n            require(_inventory <= a);\r\n            vendors[_vendorId].ratePlans[_rpid].basePrice.inventory = a - _inventory;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add inventories\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _date The date desc (20180723)\r\n     * @param _inventory The amount to be add\r\n     */\r\n    function addInventories(uint256 _vendorId, uint256 _rpid, uint256 _date, uint16 _inventory) \r\n        public  \r\n        onlyOwnerOrAuthorizedContract {\r\n        uint16 c = 0;\r\n        if(vendors[_vendorId].ratePlans[_rpid].prices[_date].init) {\r\n            c = _inventory + vendors[_vendorId].ratePlans[_rpid].prices[_date].inventory;\r\n            require(c >= _inventory);\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date].inventory = c;\r\n        }else if(vendors[_vendorId].ratePlans[_rpid].basePrice.init) {\r\n            c = _inventory + vendors[_vendorId].ratePlans[_rpid].basePrice.inventory;\r\n            require(c >= _inventory);\r\n            vendors[_vendorId].ratePlans[_rpid].basePrice.inventory = c;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Update inventory and price by `_vendorId`, `_rpid`, `_date`, `_tokenId`, `_price` and `_inventory`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _date The date desc (20180723)\r\n     * @param _tokenId The digital token id\r\n     * @param _price The price to be updated\r\n     * @param _inventory The inventory to be updated\r\n     */\r\n    function updatePriceAndInventories(uint256 _vendorId, uint256 _rpid, uint256 _date, uint256 _tokenId, uint256 _price, uint16 _inventory)\r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        if (vendors[_vendorId].ratePlans[_rpid].prices[_date].init) {\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date].inventory = _inventory;\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date].tokens[_tokenId] = _price;\r\n        } else {\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date] = Price(_inventory, true);\r\n            vendors[_vendorId].ratePlans[_rpid].prices[_date].tokens[_tokenId] = _price;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Push rate plan to `_vendorId`'s rate plan list\r\n     * @param _vendorId The vendor id\r\n     * @param _name The name of rate plan\r\n     * @param _ipfs The rate plan IPFS address\r\n     * @param _direction direction to step in\r\n     */\r\n    function pushRatePlan(uint256 _vendorId, string _name, bytes32 _ipfs, bool _direction) \r\n        public \r\n        onlyOwnerOrAuthorizedContract\r\n        returns(uint256) {\r\n        RatePlan memory rp = RatePlan(_name, uint256(now), _ipfs, Price(0, false));\r\n        \r\n        uint256 id = vendors[_vendorId].ratePlanList.push(_direction);\r\n        vendors[_vendorId].ratePlans[id] = rp;\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove rate plan of `_vendorId` by `_rpid`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     */\r\n    function removeRatePlan(uint256 _vendorId, uint256 _rpid) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        delete vendors[_vendorId].ratePlans[_rpid];\r\n        vendors[_vendorId].ratePlanList.remove(_rpid);\r\n    }\r\n\r\n    /**\r\n     * @dev Update `_rpid` of `_vendorId` by `_name` and `_ipfs`\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _name The rate plan name\r\n     * @param _ipfs The rate plan IPFS address\r\n     */\r\n    function updateRatePlan(uint256 _vendorId, uint256 _rpid, string _name, bytes32 _ipfs)\r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        vendors[_vendorId].ratePlans[_rpid].ipfs = _ipfs;\r\n        vendors[_vendorId].ratePlans[_rpid].name = _name;\r\n    }\r\n    \r\n    /**\r\n     * @dev Push token contract to the token list\r\n     * @param _direction direction to step in\r\n     */\r\n    function pushToken(address _contract, bool _direction)\r\n        public \r\n        onlyOwnerOrAuthorizedContract \r\n        returns(uint256) {\r\n        uint256 id = tokenList.push(_direction);\r\n        tokenIndexToAddress[id] = _contract;\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove token by `_tokenId`\r\n     * @param _tokenId The digital token id\r\n     */\r\n    function removeToken(uint256 _tokenId) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        delete tokenIndexToAddress[_tokenId];\r\n        tokenList.remove(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Generate room night token\r\n     * @param _vendorId The vendor id\r\n     * @param _rpid The rate plan id\r\n     * @param _date The date desc (20180723)\r\n     * @param _token The token id\r\n     * @param _price The token price\r\n     * @param _ipfs The rate plan IPFS address\r\n     */\r\n    function generateRoomNightToken(uint256 _vendorId, uint256 _rpid, uint256 _date, uint256 _token, uint256 _price, bytes32 _ipfs)\r\n        public \r\n        onlyOwnerOrAuthorizedContract \r\n        returns(uint256) {\r\n        roomnights.push(RoomNight(_vendorId, _rpid, _token, _price, now, _date, _ipfs));\r\n\r\n        // Give the token to `_customer`\r\n        uint256 rnid = uint256(roomnights.length - 1);\r\n        return rnid;\r\n    }\r\n\r\n    /**\r\n     * @dev Update refund applications\r\n     * @param _buyer The room night token holder\r\n     * @param _rnid The room night token id\r\n     * @param _isRefund Is redund or not\r\n     */\r\n    function updateRefundApplications(address _buyer, uint256 _rnid, bool _isRefund) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        refundApplications[_buyer][_rnid] = _isRefund;\r\n    }\r\n\r\n    /**\r\n     * @dev Push vendor info to the vendor list\r\n     * @param _name The name of vendor\r\n     * @param _vendor The vendor address\r\n     * @param _direction direction to step in\r\n     */\r\n    function pushVendor(string _name, address _vendor, bool _direction)\r\n        public \r\n        onlyOwnerOrAuthorizedContract \r\n        returns(uint256) {\r\n        uint256 id = vendorList.push(_direction);\r\n        vendorIds[_vendor] = id;\r\n        vendors[id] = Vendor(_name, _vendor, uint256(now), true, LinkedListLib.LinkedList(0, 0));\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove vendor from vendor list\r\n     * @param _vendorId The vendor id\r\n     */\r\n    function removeVendor(uint256 _vendorId) \r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        vendorList.remove(_vendorId);\r\n        address vendor = vendors[_vendorId].vendor;\r\n        vendorIds[vendor] = 0;\r\n        delete vendors[_vendorId];\r\n    }\r\n\r\n    /**\r\n     * @dev Make vendor valid or invalid\r\n     * @param _vendorId The vendor id\r\n     * @param _valid The vendor is valid or not\r\n     */\r\n    function updateVendorValid(uint256 _vendorId, bool _valid)\r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        vendors[_vendorId].valid = _valid;\r\n    }\r\n\r\n    /**\r\n     * @dev Modify vendor's name\r\n     * @param _vendorId The vendor id\r\n     * @param _name Then vendor name\r\n     */\r\n    function updateVendorName(uint256 _vendorId, string _name)\r\n        public \r\n        onlyOwnerOrAuthorizedContract {\r\n        vendors[_vendorId].name = _name;\r\n    }\r\n}\r\n\r\n\r\ncontract TRNRatePlans is TRNData {\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor() public {\r\n\r\n    }\r\n\r\n    /**\r\n     * This emits when rate plan created\r\n     */\r\n    event RatePlanCreated(address indexed _vendor, string _name, bytes32 indexed _ipfs);\r\n\r\n    /**\r\n     * This emits when rate plan removed\r\n     */\r\n    event RatePlanRemoved(address indexed _vendor, uint256 indexed _rpid);\r\n\r\n    /**\r\n     * This emits when rate plan modified\r\n     */\r\n    event RatePlanModified(address indexed _vendor, uint256 indexed _rpid, string name, bytes32 _ipfs);\r\n\r\n    /**\r\n     * @dev Create rate plan\r\n     *      Only vendor can operate\r\n     *      Throw when `_name`'s length lte 0 or mte 100.\r\n     * @param _name The name of rate plan\r\n     * @param _ipfs The address of the rate plan detail info on IPFS.\r\n     */\r\n    function createRatePlan(string _name, bytes32 _ipfs) \r\n        external \r\n        // onlyVendor \r\n        returns(uint256) {\r\n        // if vendor not exist create it\r\n        if(dataSource.vendorIds(msg.sender) == 0) {\r\n            dataSource.pushVendor(\"\", msg.sender, false);\r\n        }\r\n        bytes memory nameBytes = bytes(_name);\r\n        require(nameBytes.length > 0 && nameBytes.length < 200);\r\n    \r\n        uint256 vendorId = dataSource.vendorIds(msg.sender);\r\n        uint256 id = dataSource.pushRatePlan(vendorId, _name, _ipfs, false);\r\n        \r\n        // Event \r\n        emit RatePlanCreated(msg.sender, _name, _ipfs);\r\n\r\n        return id;\r\n    }\r\n    \r\n    /**\r\n     * @dev Remove rate plan\r\n     *      Only vendor can operate\r\n     *      Throw when `_rpid` not exist\r\n     * @param _rpid The rate plan identifier\r\n     */\r\n    function removeRatePlan(uint256 _rpid) \r\n        external \r\n        onlyVendor \r\n        ratePlanExist(dataSource.vendorIds(msg.sender), _rpid) \r\n        returns(bool) {\r\n        uint256 vendorId = dataSource.vendorIds(msg.sender);\r\n\r\n        // Delete rate plan\r\n        dataSource.removeRatePlan(vendorId, _rpid);\r\n        \r\n        // Event \r\n        emit RatePlanRemoved(msg.sender, _rpid);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Modify rate plan\r\n     *      Throw when `_rpid` not exist\r\n     * @param _rpid The rate plan identifier\r\n     * @param _ipfs The address of the rate plan detail info on IPFS\r\n     */\r\n    function modifyRatePlan(uint256 _rpid, string _name, bytes32 _ipfs) \r\n        external \r\n        onlyVendor \r\n        ratePlanExist(dataSource.vendorIds(msg.sender), _rpid) \r\n        returns(bool) {\r\n\r\n        uint256 vendorId = dataSource.vendorIds(msg.sender);\r\n        dataSource.updateRatePlan(vendorId, _rpid, _name, _ipfs);\r\n\r\n        // Event \r\n        emit RatePlanModified(msg.sender, _rpid, _name, _ipfs);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns a list of all rate plan IDs assigned to a vendor.\r\n     * @param _vendorId The Id of vendor\r\n     * @param _from The begin ratePlan Id\r\n     * @param _limit How many ratePlan Ids one page \r\n     * @return A list of all rate plan IDs assigned to a vendor\r\n     */\r\n    function ratePlansOfVendor(uint256 _vendorId, uint256 _from, uint256 _limit) \r\n        external\r\n        view\r\n        vendorIdValid(_vendorId)  \r\n        returns(uint256[], uint256) {\r\n        return dataSource.getRatePlansOfVendor(_vendorId, _from, _limit, true);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns ratePlan info of vendor\r\n     * @param _vendorId The address of vendor\r\n     * @param _rpid The ratePlan id\r\n     * @return The ratePlan info(_name, _timestamp, _ipfs)\r\n     */\r\n    function ratePlanOfVendor(uint256 _vendorId, uint256 _rpid) \r\n        external \r\n        view \r\n        vendorIdValid(_vendorId) \r\n        returns(string _name, uint256 _timestamp, bytes32 _ipfs) {\r\n        (_name, _timestamp, _ipfs) = dataSource.getRatePlan(_vendorId, _rpid);\r\n    }\r\n}\r\n\r\ncontract TripioRoomNightVendor is TRNPrices, TRNRatePlans {\r\n    /**\r\n     * Constructor\r\n     */\r\n    constructor(address _dataSource) public {\r\n        // Init the data source\r\n        dataSource = TripioRoomNightData(_dataSource);\r\n    }\r\n    \r\n    /**\r\n     * @dev Destory the contract\r\n     */\r\n    function destroy() external onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ipfs\",\"type\":\"bytes32\"}],\"name\":\"createRatePlan\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vendorId\",\"type\":\"uint256\"},{\"name\":\"_rpid\",\"type\":\"uint256\"},{\"name\":\"_date\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"priceOfDate\",\"outputs\":[{\"name\":\"_inventory\",\"type\":\"uint16\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vendorId\",\"type\":\"uint256\"},{\"name\":\"_rpid\",\"type\":\"uint256\"},{\"name\":\"_dates\",\"type\":\"uint256[]\"},{\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"pricesAndInventoriesOfDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rpid\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_ipfs\",\"type\":\"bytes32\"}],\"name\":\"modifyRatePlan\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vendorId\",\"type\":\"uint256\"},{\"name\":\"_rpid\",\"type\":\"uint256\"}],\"name\":\"ratePlanOfVendor\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"},{\"name\":\"_ipfs\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vendorId\",\"type\":\"uint256\"},{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"ratePlansOfVendor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rpid\",\"type\":\"uint256\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_prices\",\"type\":\"uint256[]\"},{\"name\":\"_inventory\",\"type\":\"uint16\"}],\"name\":\"updateBasePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vendorId\",\"type\":\"uint256\"},{\"name\":\"_rpid\",\"type\":\"uint256\"},{\"name\":\"_dates\",\"type\":\"uint256[]\"},{\"name\":\"_token\",\"type\":\"uint256\"}],\"name\":\"pricesOfDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rpid\",\"type\":\"uint256\"},{\"name\":\"_dates\",\"type\":\"uint256[]\"},{\"name\":\"_inventory\",\"type\":\"uint16\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_prices\",\"type\":\"uint256[]\"}],\"name\":\"updatePrices\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vendorId\",\"type\":\"uint256\"},{\"name\":\"_rpid\",\"type\":\"uint256\"},{\"name\":\"_dates\",\"type\":\"uint256[]\"}],\"name\":\"inventoriesOfDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rpid\",\"type\":\"uint256\"}],\"name\":\"removeRatePlan\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rpid\",\"type\":\"uint256\"},{\"name\":\"_dates\",\"type\":\"uint256[]\"},{\"name\":\"_inventory\",\"type\":\"uint16\"}],\"name\":\"updateInventories\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dataSource\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vendor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"_ipfs\",\"type\":\"bytes32\"}],\"name\":\"RatePlanCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vendor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_rpid\",\"type\":\"uint256\"}],\"name\":\"RatePlanRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_vendor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_rpid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_ipfs\",\"type\":\"bytes32\"}],\"name\":\"RatePlanModified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_rpid\",\"type\":\"uint256\"}],\"name\":\"RatePlanPriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_rpid\",\"type\":\"uint256\"}],\"name\":\"RatePlanInventoryChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_rpid\",\"type\":\"uint256\"}],\"name\":\"RatePlanBasePriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TripioRoomNightVendor","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000052ef5080612920a0365be1d382765089b596c708","Library":"","SwarmSource":"bzzr://879d9a62b68e6f7f7913838c43650796d7fc912d6c807b3d8a16203d03aed23b"}]}