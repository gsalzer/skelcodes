{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\ncontract ADM312 {\r\n\r\n  address public COO;\r\n  address public CTO;\r\n  address public CFO;\r\n  address private coreAddress;\r\n  address public logicAddress;\r\n  address public superAddress;\r\n\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == COO || msg.sender == CTO || msg.sender == CFO);\r\n    _;\r\n  }\r\n  \r\n  modifier onlyContract() {\r\n    require(msg.sender == coreAddress || msg.sender == logicAddress || msg.sender == superAddress);\r\n    _;\r\n  }\r\n    \r\n  modifier onlyContractAdmin() {\r\n    require(msg.sender == coreAddress || msg.sender == logicAddress || msg.sender == superAddress || msg.sender == COO || msg.sender == CTO || msg.sender == CFO);\r\n     _;\r\n  }\r\n  \r\n  function transferAdmin(address _newAdminAddress1, address _newAdminAddress2) public onlyAdmin {\r\n    if(msg.sender == COO)\r\n    {\r\n        CTO = _newAdminAddress1;\r\n        CFO = _newAdminAddress2;\r\n    }\r\n    if(msg.sender == CTO)\r\n    {\r\n        COO = _newAdminAddress1;\r\n        CFO = _newAdminAddress2;\r\n    }\r\n    if(msg.sender == CFO)\r\n    {\r\n        COO = _newAdminAddress1;\r\n        CTO = _newAdminAddress2;\r\n    }\r\n  }\r\n  \r\n  function transferContract(address _newCoreAddress, address _newLogicAddress, address _newSuperAddress) external onlyAdmin {\r\n    coreAddress  = _newCoreAddress;\r\n    logicAddress = _newLogicAddress;\r\n    superAddress = _newSuperAddress;\r\n    SetCoreInterface(_newLogicAddress).setCoreContract(_newCoreAddress);\r\n    SetCoreInterface(_newSuperAddress).setCoreContract(_newCoreAddress);\r\n  }\r\n\r\n\r\n}\r\n\r\ncontract ERC721 {\r\n    \r\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n\r\n  function totalSupply() public view returns (uint256 total);\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n  function transfer(address _to, uint256 _tokenId) public;\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function takeOwnership(uint256 _tokenId) public;\r\n  \r\n}\r\n\r\ncontract SetCoreInterface {\r\n   function setCoreContract(address _neWCoreAddress) external; \r\n}\r\n\r\ncontract CaData is ADM312, ERC721 {\r\n    \r\n    function CaData() public {\r\n        COO = msg.sender;\r\n        CTO = msg.sender;\r\n        CFO = msg.sender;\r\n        createCustomAtom(0,0,4,0,0,0,0);\r\n    }\r\n    \r\n    function kill() external\r\n\t{\r\n\t    require(msg.sender == COO);\r\n\t\tselfdestruct(msg.sender);\r\n\t}\r\n    \r\n    function() public payable{}\r\n    \r\n    uint public randNonce  = 0;\r\n    \r\n    struct Atom \r\n    {\r\n      uint64   dna;\r\n      uint8    gen;\r\n      uint8    lev;\r\n      uint8    cool;\r\n      uint32   sons;\r\n      uint64   fath;\r\n\t  uint64   moth;\r\n\t  uint128  isRent;\r\n\t  uint128  isBuy;\r\n\t  uint32   isReady;\r\n    }\r\n    \r\n    Atom[] public atoms;\r\n    \r\n    mapping (uint64  => bool) public dnaExist;\r\n    mapping (address => bool) public bonusReceived;\r\n    mapping (address => uint) public ownerAtomsCount;\r\n    mapping (uint => address) public atomOwner;\r\n    \r\n    event NewWithdraw(address sender, uint balance);\r\n    \r\n    function createCustomAtom(uint64 _dna, uint8 _gen, uint8 _lev, uint8 _cool, uint128 _isRent, uint128 _isBuy, uint32 _isReady) public onlyAdmin {\r\n        require(dnaExist[_dna]==false && _cool+_lev>=4);\r\n        Atom memory newAtom = Atom(_dna, _gen, _lev, _cool, 0, 2**50, 2**50, _isRent, _isBuy, _isReady);\r\n        uint id = atoms.push(newAtom) - 1;\r\n        atomOwner[id] = msg.sender;\r\n        ownerAtomsCount[msg.sender]++;\r\n        dnaExist[_dna] = true;\r\n    }\r\n    \r\n    function withdrawBalance() public payable onlyAdmin {\r\n\t\tNewWithdraw(msg.sender, address(this).balance);\r\n        CFO.transfer(address(this).balance);\r\n    }\r\n        \r\n    function incRandNonce() external onlyContract {\r\n        randNonce++;\r\n    }\r\n    \r\n    function setDnaExist(uint64 _dna, bool _newDnaLocking) external onlyContractAdmin {\r\n        dnaExist[_dna] = _newDnaLocking;\r\n    }\r\n    \r\n    function setBonusReceived(address _add, bool _newBonusLocking) external onlyContractAdmin {\r\n        bonusReceived[_add] = _newBonusLocking;\r\n    }\r\n    \r\n    function setOwnerAtomsCount(address _owner, uint _newCount) external onlyContract {\r\n        ownerAtomsCount[_owner] = _newCount;\r\n    }\r\n    \r\n    function setAtomOwner(uint _atomId, address _owner) external onlyContract {\r\n        atomOwner[_atomId] = _owner;\r\n    }\r\n        \r\n    function pushAtom(uint64 _dna, uint8 _gen, uint8 _lev, uint8 _cool, uint32 _sons, uint64 _fathId, uint64 _mothId, uint128 _isRent, uint128 _isBuy, uint32 _isReady) external onlyContract returns (uint id) {\r\n        Atom memory newAtom = Atom(_dna, _gen, _lev, _cool, _sons, _fathId, _mothId, _isRent, _isBuy, _isReady);\r\n        id = atoms.push(newAtom) -1;\r\n    }\r\n\t\r\n\tfunction setAtomDna(uint _atomId, uint64 _dna) external onlyAdmin {\r\n        atoms[_atomId].dna = _dna;\r\n    }\r\n\t\r\n\tfunction setAtomGen(uint _atomId, uint8 _gen) external onlyAdmin {\r\n        atoms[_atomId].gen = _gen;\r\n    }\r\n    \r\n    function setAtomLev(uint _atomId, uint8 _lev) external onlyContract {\r\n        atoms[_atomId].lev = _lev;\r\n    }\r\n    \r\n    function setAtomCool(uint _atomId, uint8 _cool) external onlyContract {\r\n        atoms[_atomId].cool = _cool;\r\n    }\r\n    \r\n    function setAtomSons(uint _atomId, uint32 _sons) external onlyContract {\r\n        atoms[_atomId].sons = _sons;\r\n    }\r\n    \r\n    function setAtomFath(uint _atomId, uint64 _fath) external onlyContract {\r\n        atoms[_atomId].fath = _fath;\r\n    }\r\n    \r\n    function setAtomMoth(uint _atomId, uint64 _moth) external onlyContract {\r\n        atoms[_atomId].moth = _moth;\r\n    }\r\n    \r\n    function setAtomIsRent(uint _atomId, uint128 _isRent) external onlyContract {\r\n        atoms[_atomId].isRent = _isRent;\r\n    }\r\n    \r\n    function setAtomIsBuy(uint _atomId, uint128 _isBuy) external onlyContract {\r\n        atoms[_atomId].isBuy = _isBuy;\r\n    }\r\n    \r\n    function setAtomIsReady(uint _atomId, uint32 _isReady) external onlyContractAdmin {\r\n        atoms[_atomId].isReady = _isReady;\r\n    }\r\n    \r\n    //ERC721\r\n    \r\n    mapping (uint => address) tokenApprovals;\r\n    \r\n    function totalSupply() public view returns (uint256 total){\r\n  \t    return atoms.length;\r\n  \t}\r\n  \t\r\n  \tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return ownerAtomsCount[_owner];\r\n    }\r\n    \r\n    function ownerOf(uint256 _tokenId) public view returns (address owner) {\r\n        return atomOwner[_tokenId];\r\n    }\r\n      \r\n    function _transfer(address _from, address _to, uint256 _tokenId) private {\r\n        atoms[_tokenId].isBuy  = 0;\r\n        atoms[_tokenId].isRent = 0;\r\n        ownerAtomsCount[_to]++;\r\n        ownerAtomsCount[_from]--;\r\n        atomOwner[_tokenId] = _to;\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n  \r\n    function transfer(address _to, uint256 _tokenId) public {\r\n        require(msg.sender == atomOwner[_tokenId]);\r\n        _transfer(msg.sender, _to, _tokenId);\r\n    }\r\n    \r\n    function approve(address _to, uint256 _tokenId) public {\r\n        require(msg.sender == atomOwner[_tokenId]);\r\n        tokenApprovals[_tokenId] = _to;\r\n        Approval(msg.sender, _to, _tokenId);\r\n    }\r\n    \r\n    function takeOwnership(uint256 _tokenId) public {\r\n        require(tokenApprovals[_tokenId] == msg.sender);\r\n        _transfer(ownerOf(_tokenId), msg.sender, _tokenId);\r\n    }\r\n    \r\n}\r\n\r\ncontract Ownable {\r\n    \r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\ninterface ERC721Metadata {\r\n    function name() external view returns (string _name);\r\n    function symbol() external view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ninterface ERC721Enumerable {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n          \r\ncontract CryptoAtomsToken is Ownable {\r\n    \r\n    address public CaDataAddress = 0x9b3554E6FC4F81531F6D43b611258bd1058ef6D5;\r\n    CaData public CaDataContract = CaData(CaDataAddress);\r\n\r\n    function kill() external\r\n\t{\r\n\t    require(msg.sender == CaDataContract.COO());\r\n\t\tselfdestruct(msg.sender);\r\n\t}\r\n    \r\n    function() public payable{}\r\n    \r\n    function withdrawBalance() public payable {\r\n        require(msg.sender == CaDataContract.COO() || msg.sender == CaDataContract.CTO() || msg.sender == CaDataContract.CFO());\r\n        CaDataContract.CFO().transfer(address(this).balance);\r\n    }\r\n    \r\n    mapping (address => bool) transferEmittables;\r\n    \r\n    function setTransferEmittables(address _addr, bool _bool) external {\r\n        require(msg.sender == CaDataContract.COO() || msg.sender == CaDataContract.CTO() || msg.sender == CaDataContract.CFO());\r\n        transferEmittables[_addr] = _bool;\r\n    }\r\n    \r\n    function emitTransfer(address _from, address _to, uint256 _tokenId) external{\r\n        require(transferEmittables[msg.sender]);\r\n        Transfer(_from, _to, _tokenId);\r\n    }\r\n    \r\n    //ERC721\r\n    \r\n        event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n        event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n        event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    \r\n        mapping (uint => address) tokenApprovals;\r\n        mapping (uint => address) tokenOperators;\r\n        mapping (address => mapping (address => bool)) ownerOperators;\r\n    \r\n        function _transfer(address _from, address _to, uint256 _tokenId) private {\r\n            CaDataContract.setAtomIsBuy(_tokenId,0);\r\n            CaDataContract.setAtomIsRent(_tokenId,0);\r\n            CaDataContract.setOwnerAtomsCount(_to,CaDataContract.ownerAtomsCount(_to)+1);\r\n            CaDataContract.setOwnerAtomsCount(_from,CaDataContract.ownerAtomsCount(_from)-1);\r\n            CaDataContract.setAtomOwner(_tokenId,_to);\r\n            Transfer(_from, _to, _tokenId);\r\n        }\r\n        \r\n        function _isContract(address _addr) private returns (bool check) {\r\n            uint size;\r\n            assembly { size := extcodesize(_addr) }\r\n            return size > 0;\r\n        }\r\n        \r\n      \tfunction balanceOf(address _owner) external view returns (uint256 balance) {\r\n            return CaDataContract.balanceOf(_owner);\r\n        }\r\n    \r\n        function ownerOf(uint256 _tokenId) external view returns (address owner) {\r\n            return CaDataContract.ownerOf(_tokenId);\r\n        }\r\n        \r\n        /// @notice Transfers the ownership of an NFT from one address to another address\r\n        /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n        ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n        ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n        ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n        ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n        ///  `onERC721Received` on `_to` and throws if the return value is not\r\n        ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n        /// @param _from The current owner of the NFT\r\n        /// @param _to The new owner\r\n        /// @param _tokenId The NFT to transfer\r\n        /// @param _data Additional data with no specified format, sent in call to `_to`\r\n        function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external payable{\r\n            require(msg.sender == CaDataContract.ownerOf(_tokenId) || ownerOperators[CaDataContract.atomOwner(_tokenId)][msg.sender] == true || msg.sender == tokenApprovals[_tokenId]);\r\n            require(_from == CaDataContract.ownerOf(_tokenId) && _to != 0x0);\r\n            require(_tokenId < totalSupply());\r\n            _transfer(_from, _to, _tokenId);\r\n            if(_isContract(_to))\r\n            {\r\n                require(ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data) == ERC721_RECEIVED);\r\n            }\r\n        }\r\n    \r\n        /// @notice Transfers the ownership of an NFT from one address to another address\r\n        /// @dev This works identically to the other function with an extra data parameter,\r\n        ///  except this function just sets data to \"\"\r\n        /// @param _from The current owner of the NFT\r\n        /// @param _to The new owner\r\n        /// @param _tokenId The NFT to transfer\r\n        function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable{\r\n            require(msg.sender == CaDataContract.ownerOf(_tokenId) || ownerOperators[CaDataContract.atomOwner(_tokenId)][msg.sender] == true || msg.sender == tokenApprovals[_tokenId]);\r\n            require(_from == CaDataContract.ownerOf(_tokenId) && _to != 0x0);\r\n            require(_tokenId < totalSupply());\r\n            _transfer(_from, _to, _tokenId);\r\n            if(_isContract(_to))\r\n            {\r\n                require(ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, \"\") == ERC721_RECEIVED);\r\n            }\r\n        }\r\n        \r\n        \r\n        /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n        ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n        ///  THEY MAY BE PERMANENTLY LOST\r\n        /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n        ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n        ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n        ///  `_tokenId` is not a valid NFT.\r\n        /// @param _from The current owner of the NFT\r\n        /// @param _to The new owner\r\n        /// @param _tokenId The NFT to transfer\r\n        function transferFrom(address _from, address _to, uint256 _tokenId) external payable{\r\n            require(msg.sender == CaDataContract.ownerOf(_tokenId) || ownerOperators[CaDataContract.atomOwner(_tokenId)][msg.sender] == true || msg.sender == tokenApprovals[_tokenId]);\r\n            require(_from == CaDataContract.ownerOf(_tokenId) && _to != 0x0);\r\n            require(_tokenId < totalSupply());\r\n            _transfer(_from, _to, _tokenId);\r\n        }\r\n        \r\n        \r\n        /// @notice Set or reaffirm the approved address for an NFT\r\n        /// @dev The zero address indicates there is no approved address.\r\n        /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n        ///  operator of the current owner.\r\n        /// @param _approved The new approved NFT controller\r\n        /// @param _tokenId The NFT to approve\r\n        function approve(address _approved, uint256 _tokenId) external payable {\r\n            require(msg.sender == CaDataContract.atomOwner(_tokenId) || ownerOperators[CaDataContract.atomOwner(_tokenId)][msg.sender]);\r\n            tokenApprovals[_tokenId] = _approved;\r\n            Approval(CaDataContract.atomOwner(_tokenId), _approved, _tokenId);\r\n        }\r\n        \r\n        /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n        ///  all of `msg.sender`'s assets.\r\n        /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n        ///  multiple operators per owner.\r\n        /// @param _operator Address to add to the set of authorized operators.\r\n        /// @param _approved True if the operator is approved, false to revoke approval\r\n        function setApprovalForAll(address _operator, bool _approved) external {\r\n            ownerOperators[msg.sender][_operator] = _approved;\r\n            ApprovalForAll(msg.sender, _operator, _approved);\r\n        }\r\n    \r\n        /// @notice Get the approved address for a single NFT\r\n        /// @dev Throws if `_tokenId` is not a valid NFT\r\n        /// @param _tokenId The NFT to find the approved address for\r\n        /// @return The approved address for this NFT, or the zero address if there is none\r\n        function getApproved(uint256 _tokenId) external view returns (address) {\r\n            return tokenApprovals[_tokenId];\r\n        }\r\n    \r\n        /// @notice Query if an address is an authorized operator for another address\r\n        /// @param _owner The address that owns the NFTs\r\n        /// @param _operator The address that acts on behalf of the owner\r\n        /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n        function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n            return ownerOperators[_owner][_operator];\r\n        }\r\n    \r\n    //ERC165\r\n\r\n        bytes4 constant Sign_ERC165 =\r\n            bytes4(keccak256('supportsInterface(bytes4)'));\r\n        \r\n        bytes4 constant Sign_ERC721 =\r\n            bytes4(keccak256('balanceOf(address)')) ^\r\n            bytes4(keccak256('ownerOf(uint256)')) ^\r\n            bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) ^\r\n            bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n            bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n            bytes4(keccak256('approve(address,uint256)')) ^\r\n            bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n            bytes4(keccak256('getApproved(uint256)')) ^\r\n            bytes4(keccak256('isApprovedForAll(address,address)'));\r\n            \r\n        function supportsInterface(bytes4 interfaceID) external view returns (bool)\r\n        {\r\n            return ((interfaceID == Sign_ERC165) || (interfaceID == Sign_ERC721));\r\n        }\r\n    \r\n    //ERC721TokenReceiver\r\n    \r\n        /// @notice Handle the receipt of an NFT\r\n        /// @dev The ERC721 smart contract calls this function on the\r\n        /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n        /// of other than the magic value MUST result in the transaction being reverted.\r\n        /// @notice The contract address is always the message sender. \r\n        /// @param _operator The address which called `safeTransferFrom` function\r\n        /// @param _from The address which previously owned the token\r\n        /// @param _tokenId The NFT identifier which is being transferred\r\n        /// @param _data Additional data with no specified format\r\n        /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n        /// unless throwing \r\n        \r\n        bytes4 constant ERC721_RECEIVED = bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"));\r\n        \r\n        function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4){\r\n            return ERC721_RECEIVED;\r\n        }\r\n    \r\n    //ERC721MetaData\r\n    \r\n        string baseUri = \"https://www.cryptoatoms.org/cres/uri/\";\r\n    \r\n        function name() external view returns (string _name) {\r\n            return \"Atom\";\r\n        }\r\n    \r\n        function symbol() external view returns (string _symbol){\r\n            return \"ATH\";\r\n        }\r\n    \r\n        /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n        /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n        ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n        ///  Metadata JSON Schema\".\r\n        function tokenURI(uint256 _tokenId) external view returns (string){\r\n            require(_tokenId < totalSupply());\r\n            uint256 uid;\r\n            bytes32 bid;\r\n            uid = _tokenId;\r\n            if (uid == 0) \r\n            {\r\n                bid = '0';\r\n            }\r\n            else \r\n            {\r\n                while (uid > 0) \r\n                {\r\n                    bid = bytes32(uint(bid) / (2 ** 8));\r\n                    bid |= bytes32(((uid % 10) + 48) * 2 ** (8 * 31));\r\n                    uid /= 10;\r\n                }\r\n            }\r\n            return string(abi.encodePacked(baseUri, bid));\r\n        }\r\n        \r\n        function setBaseUri (string _newBaseUri) external {\r\n            require(msg.sender == CaDataContract.COO() || msg.sender == CaDataContract.CTO() || msg.sender == CaDataContract.CFO());\r\n            baseUri = _newBaseUri;\r\n        }\r\n    \r\n    //ERC721Enumerable\r\n        \r\n        function totalSupply() public view returns (uint256 total){\r\n      \t    return CaDataContract.totalSupply();\r\n      \t}\r\n      \t   \r\n      \t/// @notice Enumerate valid NFTs\r\n        /// @dev Throws if `_index` >= `totalSupply()`.\r\n        /// @param _index A counter less than `totalSupply()`\r\n        /// @return The token identifier for the `_index`th NFT,\r\n        ///  (sort order not specified)\r\n        function tokenByIndex(uint256 _index) external view returns (uint256){\r\n            require(_index < totalSupply());\r\n            return _index;\r\n        }\r\n    \r\n        /// @notice Enumerate NFTs assigned to an owner\r\n        /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n        ///  `_owner` is the zero address, representing invalid NFTs.\r\n        /// @param _owner An address where we are interested in NFTs owned by them\r\n        /// @param _index A counter less than `balanceOf(_owner)`\r\n        /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n        ///   (sort order not specified)\r\n        function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256){\r\n            require(_index < CaDataContract.balanceOf(_owner));\r\n            uint64 counter = 0;\r\n            for (uint64 i = 0; i < CaDataContract.totalSupply(); i++)\r\n            {\r\n                if (CaDataContract.atomOwner(i) == _owner) {\r\n                    if(counter == _index)\r\n                    {\r\n                        uint256 result = i;\r\n                        i = uint64(CaDataContract.totalSupply());\r\n                    }\r\n                    else\r\n                    {\r\n                        counter++;\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        }\r\n    \r\n    \r\n    //ERC20\r\n        \r\n        function decimals() external view returns (uint8 _decimals){\r\n            return 0;\r\n        }\r\n        \r\n        function implementsERC721() public pure returns (bool){\r\n            return true;\r\n        }\r\n        \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"emitTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"_decimals\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_bool\",\"type\":\"bool\"}],\"name\":\"setTransferEmittables\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CaDataContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CaDataAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBaseUri\",\"type\":\"string\"}],\"name\":\"setBaseUri\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CryptoAtomsToken","CompilerVersion":"v0.4.24-nightly.2018.5.16+commit.7f965c86","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://008a0d11f9b4dbf810ac043abccc430755c7a3f30dfe4b519b4ac974d1fbc7aa"}]}