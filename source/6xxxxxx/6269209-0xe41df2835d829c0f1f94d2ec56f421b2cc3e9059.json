{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n// ----------------------------------------------------------------------------\r\n// 'XFB' '幸福宝' token contract\r\n//\r\n// Symbol      : XFB\r\n// Name        : 信福宝\r\n// Total supply: 700,000,000.0000000000\r\n// Decimals    : 8\r\n//\r\n// Enjoy.\r\n//\r\n// (c) WeiChun / Wedoops International 2018. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\ncontract MultiOwner {\r\n    /* Constructor */\r\n    event OwnerAdded(address newOwner);\r\n    event OwnerRemoved(address oldOwner);\r\n\tevent RequirementChanged(uint256 newRequirement);\r\n\t\r\n    uint256 public ownerRequired;\r\n    mapping (address => bool) public isOwner;\r\n\tmapping (address => bool) public RequireDispose;\r\n\taddress[] owners;\r\n\t\r\n\tfunction MultiOwner(address[] _owners, uint256 _required) public {\r\n        ownerRequired = _required;\r\n        isOwner[msg.sender] = true;\r\n        owners.push(msg.sender);\r\n        \r\n        for (uint256 i = 0; i < _owners.length; ++i){\r\n\t\t\trequire(!isOwner[_owners[i]]);\r\n\t\t\tisOwner[_owners[i]] = true;\r\n\t\t\towners.push(_owners[i]);\r\n        }\r\n    }\r\n    \r\n\tmodifier onlyOwner {\r\n\t    require(isOwner[msg.sender]);\r\n        _;\r\n    }\r\n    \r\n\tmodifier ownerDoesNotExist(address owner) {\r\n\t\trequire(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n\t\trequire(isOwner[owner]);\r\n        _;\r\n    }\r\n    \r\n    function addOwner(address owner) onlyOwner ownerDoesNotExist(owner) external{\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        OwnerAdded(owner);\r\n    }\r\n    \r\n\tfunction numberOwners() public constant returns (uint256 NumberOwners){\r\n\t    NumberOwners = owners.length;\r\n\t}\r\n\t\r\n    function removeOwner(address owner) onlyOwner ownerExists(owner) external{\r\n\t\trequire(owners.length > 2);\r\n        isOwner[owner] = false;\r\n\t\tRequireDispose[owner] = false;\r\n        for (uint256 i=0; i<owners.length - 1; i++){\r\n            if (owners[i] == owner) {\r\n\t\t\t\towners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n\t\t}\r\n\t\towners.length -= 1;\r\n        OwnerRemoved(owner);\r\n    }\r\n    \r\n\tfunction changeRequirement(uint _newRequired) onlyOwner external {\r\n\t\trequire(_newRequired >= owners.length);\r\n        ownerRequired = _newRequired;\r\n        RequirementChanged(_newRequired);\r\n    }\r\n\t\r\n\tfunction ConfirmDispose() onlyOwner() public view returns (bool){\r\n\t\tuint count = 0;\r\n\t\tfor (uint i=0; i<owners.length - 1; i++)\r\n            if (RequireDispose[owners[i]])\r\n                count += 1;\r\n            if (count == ownerRequired)\r\n                return true;\r\n\t}\r\n\t\r\n\tfunction kill() onlyOwner() public{\r\n\t\tRequireDispose[msg.sender] = true;\r\n\t\tif(ConfirmDispose()){\r\n\t\t\tselfdestruct(msg.sender);\r\n\t\t}\r\n    }\r\n}\r\n\r\ninterface ERC20{\r\n    function transfer(address _to, uint _value, bytes _data) public;\r\n    function transfer(address _to, uint256 _value) public;\r\n    function transferFrom(address _from, address _to, uint256 _value, bool _feed, uint256 _fees) public returns (bool success);\r\n    function setPrices(uint256 newValue) public;\r\n    function freezeAccount(address target, bool freeze) public;\r\n    function() payable public;\r\n\tfunction remainBalanced() public constant returns (uint256);\r\n\tfunction execute(address _to, uint _value, bytes _data) external returns (bytes32 _r);\r\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool);\r\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count);\r\n    function confirmTransaction(bytes32 TransHash) public;\r\n    function executeTransaction(bytes32 TransHash) public;\r\n\tfunction AccountVoid(address _from) public;\r\n\tfunction burn(uint amount) public;\r\n\tfunction bonus(uint amount) public;\r\n    \r\n    event SubmitTransaction(bytes32 transactionHash);\r\n\tevent Confirmation(address sender, bytes32 transactionHash);\r\n\tevent Execution(bytes32 transactionHash);\r\n\tevent FrozenFunds(address target, bool frozen);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\tevent FeePaid(address indexed from, address indexed to, uint256 value);\r\n\tevent VoidAccount(address indexed from, address indexed to, uint256 value);\r\n\tevent Bonus(uint256 value);\r\n\tevent Burn(uint256 value);\r\n}\r\n\r\ninterface ERC223 {\r\n    function transfer(address to, uint value, bytes data) public;\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n}\r\n\r\ncontract Token is MultiOwner, ERC20, ERC223{\r\n\tusing SafeMath for uint256;\r\n\t\r\n\tstring public name = \"信福宝\";\r\n\tstring public symbol = \"XFB\";\r\n\tuint8 public decimals = 8;\r\n\tuint256 public totalSupply = 700000000 * 10 ** uint256(decimals);\r\n\tuint256 public EthPerToken = 700000;\r\n\t\r\n\tmapping(address => uint256) public balanceOf;\r\n\tmapping(address => bool) public frozenAccount;\r\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\r\n\tmapping (bytes32 => Transaction) public Transactions;\r\n\t\r\n\tstruct Transaction {\r\n\t\taddress destination;\r\n\t\tuint value;\r\n\t\tbytes data;\r\n\t\tbool executed;\r\n    }\r\n\t\r\n\tmodifier notNull(address destination) {\r\n\t\trequire (destination != 0x0);\r\n        _;\r\n    }\r\n\t\r\n\tmodifier confirmed(bytes32 transactionHash) {\r\n\t\trequire (Confirmations[transactionHash][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(bytes32 transactionHash) {\r\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\r\n        _;\r\n    }\r\n\t\r\n\tmodifier notExecuted(bytes32 TransHash) {\r\n\t\trequire (!Transactions[TransHash].executed);\r\n        _;\r\n    }\r\n    \r\n\tfunction Token(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\r\n\t\tbalanceOf[msg.sender] = totalSupply;\r\n    }\r\n\t\r\n\t/* Internal transfer, only can be called by this contract */\r\n    function _transfer(address _from, address _to, uint256 _value) internal {\r\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\r\n        require (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the sender\r\n        balanceOf[_to] = balanceOf[_to].add(_value);                           // Add the same to the recipient\r\n        Transfer(_from, _to, _value);\r\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n    }\r\n    \r\n    function transfer(address _to, uint _value, bytes _data) public {\r\n        require(_value > 0 );\r\n        if(isContract(_to)) {\r\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\r\n            receiver.tokenFallback(msg.sender, _value, _data);\r\n        }\r\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        Transfer(msg.sender, _to, _value, _data);\r\n    }\r\n    \r\n    function isContract(address _addr) private view returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length>0);\r\n    }\r\n\t\r\n\t/* Internal transfer, only can be called by this contract */\r\n    function _collect_fee(address _from, address _to, uint256 _value) internal {\r\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\r\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\r\n        require (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\r\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\r\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the sender\r\n        balanceOf[_to] = balanceOf[_to].add(_value);                           // Add the same to the recipient\r\n\t\tFeePaid(_from, _to, _value);\r\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\r\n    }\r\n\t\r\n\tfunction transfer(address _to, uint256 _value) public {\r\n\t\t_transfer(msg.sender, _to, _value);\r\n\t}\r\n\t\t\r\n\tfunction transferFrom(address _from, address _to, uint256 _value, bool _feed, uint256 _fees) onlyOwner public returns (bool success) {\r\n\t\tuint256 charge = 0 ;\r\n\t\tuint256 t_value = _value;\r\n\t\tif(_feed){\r\n\t\t\tcharge = _value * _fees / 100;\r\n\t\t}else{\r\n\t\t\tcharge = _value - (_value / (_fees + 100) * 100);\r\n\t\t}\r\n\t\tt_value = _value.sub(charge);\r\n\t\trequire(t_value.add(charge) == _value);\r\n        _transfer(_from, _to, t_value);\r\n\t\t_collect_fee(_from, this, charge);\r\n        return true;\r\n    }\r\n\t\r\n\tfunction setPrices(uint256 newValue) onlyOwner public {\r\n        EthPerToken = newValue;\r\n    }\r\n\t\r\n    function freezeAccount(address target, bool freeze) onlyOwner public {\r\n        frozenAccount[target] = freeze;\r\n        FrozenFunds(target, freeze);\r\n    }\r\n\t\r\n\tfunction() payable public{\r\n\t\trequire(msg.value > 0);\r\n\t\tuint amount = msg.value * 10 ** uint256(decimals) * EthPerToken / 1 ether;\r\n        _transfer(this, msg.sender, amount);\r\n    }\r\n\t\r\n\tfunction remainBalanced() public constant returns (uint256){\r\n        return balanceOf[this];\r\n    }\r\n\t\r\n\t/*Transfer Eth */\r\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\r\n\t\t_r = addTransaction(_to, _value, _data);\r\n\t\tconfirmTransaction(_r);\r\n    }\r\n\t\r\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\r\n        TransHash = keccak256(destination, value, data);\r\n        if (Transactions[TransHash].destination == 0) {\r\n            Transactions[TransHash] = Transaction({\r\n                destination: destination,\r\n                value: value,\r\n                data: data,\r\n                executed: false\r\n            });\r\n            SubmitTransaction(TransHash);\r\n        }\r\n    }\r\n\t\r\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\r\n        Confirmations[TransHash][msg.sender] = true;\r\n        Confirmation(msg.sender, TransHash);\r\n    }\r\n\t\r\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\r\n        uint count = 0;\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (Confirmations[TransHash][owners[i]])\r\n                count += 1;\r\n            if (count == ownerRequired)\r\n                return true;\r\n    }\r\n\t\r\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\r\n        for (uint i=0; i<owners.length; i++)\r\n            if (Confirmations[TransHash][owners[i]])\r\n                count += 1;\r\n    }\r\n    \r\n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\r\n        addConfirmation(TransHash);\r\n        executeTransaction(TransHash);\r\n    }\r\n    \r\n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\r\n        if (isConfirmed(TransHash)) {\r\n\t\t\tTransactions[TransHash].executed = true;\r\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\r\n            Execution(TransHash);\r\n        }\r\n    }\r\n\t\r\n\tfunction AccountVoid(address _from) onlyOwner public{\r\n\t\trequire (balanceOf[_from] > 0); \r\n\t\tuint256 CurrentBalances = balanceOf[_from];\r\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender];\r\n        balanceOf[_from] -= CurrentBalances;                         \r\n        balanceOf[msg.sender] += CurrentBalances;\r\n\t\tVoidAccount(_from, msg.sender, CurrentBalances);\r\n\t\tassert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances);\t\r\n\t}\r\n\t\r\n\tfunction burn(uint amount) onlyOwner public{\r\n\t\tuint BurnValue = amount * 10 ** uint256(decimals);\r\n\t\trequire(balanceOf[this] >= BurnValue);\r\n\t\tbalanceOf[this] -= BurnValue;\r\n\t\ttotalSupply -= BurnValue;\r\n\t\tBurn(BurnValue);\r\n\t}\r\n\t\r\n\tfunction bonus(uint amount) onlyOwner public{\r\n\t\tuint BonusValue = amount * 10 ** uint256(decimals);\r\n\t\trequire(balanceOf[this] + BonusValue > balanceOf[this]);\r\n\t\tbalanceOf[this] += BonusValue;\r\n\t\ttotalSupply += BonusValue;\r\n\t\tBonus(BonusValue);\r\n\t}\r\n}\r\n\r\ncontract ERC223ReceivingContract { \r\n/**\r\n * @dev Standard ERC223 function that will handle incoming token transfers.\r\n *\r\n * @param _from  Token sender address.\r\n * @param _value Amount of tokens.\r\n * @param _data  Transaction metadata.\r\n */\r\n    function tokenFallback(address _from, uint _value, bytes _data) public;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"}],\"name\":\"AccountVoid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"removeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ConfirmDispose\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"Transactions\",\"outputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"executed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"TransHash\",\"type\":\"bytes32\"}],\"name\":\"confirmationCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"TransHash\",\"type\":\"bytes32\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOwners\",\"outputs\":[{\"name\":\"NumberOwners\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"TransHash\",\"type\":\"bytes32\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainBalanced\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newValue\",\"type\":\"uint256\"}],\"name\":\"setPrices\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerRequired\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"RequireDispose\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"_r\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRequired\",\"type\":\"uint256\"}],\"name\":\"changeRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"TransHash\",\"type\":\"bytes32\"}],\"name\":\"executeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Confirmations\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_feed\",\"type\":\"bool\"},{\"name\":\"_fees\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EthPerToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"SubmitTransaction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"Confirmation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"transactionHash\",\"type\":\"bytes32\"}],\"name\":\"Execution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"FeePaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"VoidAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Bonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"}],\"name\":\"OwnerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRequirement\",\"type\":\"uint256\"}],\"name\":\"RequirementChanged\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000001000000000000000000000000ba196e5575638372895b8e447b0f974acc414c7f","Library":"","SwarmSource":"bzzr://7d76a37c1e20722572d899f02c436f2fecc0ac82dacd3e55416ae0dd6d648d5f"}]}