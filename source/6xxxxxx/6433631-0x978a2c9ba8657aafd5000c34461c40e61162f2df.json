{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract DelegateERC20 {\r\n  function delegateTotalSupply() public view returns (uint256);\r\n  function delegateBalanceOf(address who) public view returns (uint256);\r\n  function delegateTransfer(address to, uint256 value, address origSender) public returns (bool);\r\n  function delegateAllowance(address owner, address spender) public view returns (uint256);\r\n  function delegateTransferFrom(address from, address to, uint256 value, address origSender) public returns (bool);\r\n  function delegateApprove(address spender, uint256 value, address origSender) public returns (bool);\r\n  function delegateIncreaseApproval(address spender, uint addedValue, address origSender) public returns (bool);\r\n  function delegateDecreaseApproval(address spender, uint subtractedValue, address origSender) public returns (bool);\r\n}\r\ncontract Ownable {\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  function transferOwnership(address newOwner) public;\r\n}\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n  function pause() public;\r\n  function unpause() public;\r\n}\r\ncontract CanReclaimToken is Ownable {\r\n  function reclaimToken(ERC20Basic token) external;\r\n}\r\ncontract Claimable is Ownable {\r\n  function transferOwnership(address newOwner) public;\r\n  function claimOwnership() public;\r\n}\r\ncontract AddressList is Claimable {\r\n    event ChangeWhiteList(address indexed to, bool onList);\r\n    function changeList(address _to, bool _onList) public;\r\n}\r\ncontract HasNoContracts is Ownable {\r\n  function reclaimContract(address contractAddr) external;\r\n}\r\ncontract HasNoEther is Ownable {\r\n  function() external;\r\n  function reclaimEther() external;\r\n}\r\ncontract HasNoTokens is CanReclaimToken {\r\n  function tokenFallback(address from_, uint256 value_, bytes data_) external;\r\n}\r\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\r\n}\r\ncontract AllowanceSheet is Claimable {\r\n    function addAllowance(address tokenHolder, address spender, uint256 value) public;\r\n    function subAllowance(address tokenHolder, address spender, uint256 value) public;\r\n    function setAllowance(address tokenHolder, address spender, uint256 value) public;\r\n}\r\ncontract BalanceSheet is Claimable {\r\n    function addBalance(address addr, uint256 value) public;\r\n    function subBalance(address addr, uint256 value) public;\r\n    function setBalance(address addr, uint256 value) public;\r\n}\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\ncontract BasicToken is ERC20Basic, Claimable {\r\n  function setBalanceSheet(address sheet) external;\r\n  function totalSupply() public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  function transferAllArgsNoAllowance(address _from, address _to, uint256 _value) internal;\r\n  function balanceOf(address _owner) public view returns (uint256 balance);\r\n}\r\ncontract BurnableToken is BasicToken {\r\n  event Burn(address indexed burner, uint256 value);\r\n  function burn(uint256 _value) public;\r\n}\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\nlibrary SafeERC20 {\r\n}\r\ncontract StandardToken is ERC20, BasicToken {\r\n  function setAllowanceSheet(address sheet) external;\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n  function transferAllArgsYesAllowance(address _from, address _to, uint256 _value, address spender) internal;\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  function approveAllArgs(address _spender, uint256 _value, address _tokenHolder) internal;\r\n  function allowance(address _owner, address _spender) public view returns (uint256);\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool);\r\n  function increaseApprovalAllArgs(address _spender, uint _addedValue, address tokenHolder) internal;\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool);\r\n  function decreaseApprovalAllArgs(address _spender, uint _subtractedValue, address tokenHolder) internal;\r\n}\r\ncontract CanDelegate is StandardToken {\r\n    event DelegatedTo(address indexed newContract);\r\n    function delegateToNewContract(DelegateERC20 newContract) public;\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function allowance(address _owner, address spender) public view returns (uint256);\r\n    function totalSupply() public view returns (uint256);\r\n    function increaseApproval(address spender, uint addedValue) public returns (bool);\r\n    function decreaseApproval(address spender, uint subtractedValue) public returns (bool);\r\n}\r\ncontract StandardDelegate is StandardToken, DelegateERC20 {\r\n    function setDelegatedFrom(address addr) public;\r\n    function delegateTotalSupply() public view returns (uint256);\r\n    function delegateBalanceOf(address who) public view returns (uint256);\r\n    function delegateTransfer(address to, uint256 value, address origSender) public returns (bool);\r\n    function delegateAllowance(address owner, address spender) public view returns (uint256);\r\n    function delegateTransferFrom(address from, address to, uint256 value, address origSender) public returns (bool);\r\n    function delegateApprove(address spender, uint256 value, address origSender) public returns (bool);\r\n    function delegateIncreaseApproval(address spender, uint addedValue, address origSender) public returns (bool);\r\n    function delegateDecreaseApproval(address spender, uint subtractedValue, address origSender) public returns (bool);\r\n}\r\ncontract PausableToken is StandardToken, Pausable {\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool);\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool success);\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success);\r\n}\r\ncontract TrueUSD is StandardDelegate, PausableToken, BurnableToken, NoOwner, CanDelegate {\r\n    event ChangeBurnBoundsEvent(uint256 newMin, uint256 newMax);\r\n    event Mint(address indexed to, uint256 amount);\r\n    event WipedAccount(address indexed account, uint256 balance);\r\n    function setLists(AddressList _canReceiveMintWhiteList, AddressList _canBurnWhiteList, AddressList _blackList, AddressList _noFeesList) public;\r\n    function changeName(string _name, string _symbol) public;\r\n    function burn(uint256 _value) public;\r\n    function mint(address _to, uint256 _amount) public;\r\n    function changeBurnBounds(uint newMin, uint newMax) public;\r\n    function transferAllArgsNoAllowance(address _from, address _to, uint256 _value) internal;\r\n    function wipeBlacklistedAccount(address account) public;\r\n    function payStakingFee(address payer, uint256 value, uint80 numerator, uint80 denominator, uint256 flatRate, address otherParticipant) private returns (uint256);\r\n    function changeStakingFees(uint80 _transferFeeNumerator, uint80 _transferFeeDenominator, uint80 _mintFeeNumerator, uint80 _mintFeeDenominator, uint256 _mintFeeFlat, uint80 _burnFeeNumerator, uint80 _burnFeeDenominator, uint256 _burnFeeFlat) public;\r\n    function changeStaker(address newStaker) public;\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary NewSafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Cash311\r\n * @dev The main contract of the project.\r\n */\r\n  /**\r\n    * @title Cash311\r\n    * @dev https://311.cash/;\r\n    */\r\n    contract Cash311 {\r\n        // Connecting SafeMath for safe calculations.\r\n          // Подключает библиотеку безопасных вычислений к контракту.\r\n        using NewSafeMath for uint;\r\n\r\n        // A variable for address of the owner;\r\n          // Переменная для хранения адреса владельца контракта;\r\n        address owner;\r\n\r\n        // A variable for address of the ERC20 token;\r\n          // Переменная для хранения адреса токена ERC20;\r\n        TrueUSD public token = TrueUSD(0x8dd5fbce2f6a956c3022ba3663759011dd51e73e);\r\n\r\n        // A variable for decimals of the token;\r\n          // Переменная для количества знаков после запятой у токена;\r\n        uint private decimals = 10**16;\r\n\r\n        // A variable for storing deposits of investors.\r\n          // Переменная для хранения записей о сумме инвестиций инвесторов.\r\n        mapping (address => uint) deposit;\r\n        uint deposits;\r\n\r\n        // A variable for storing amount of withdrawn money of investors.\r\n          // Переменная для хранения записей о сумме снятых средств.\r\n        mapping (address => uint) withdrawn;\r\n\r\n        // A variable for storing reference point to count available money to withdraw.\r\n          // Переменная для хранения времени отчета для инвесторов.\r\n        mapping (address => uint) lastTimeWithdraw;\r\n\r\n\r\n        // RefSystem\r\n        mapping (address => uint) referals1;\r\n        mapping (address => uint) referals2;\r\n        mapping (address => uint) referals3;\r\n        mapping (address => uint) referals1m;\r\n        mapping (address => uint) referals2m;\r\n        mapping (address => uint) referals3m;\r\n        mapping (address => address) referers;\r\n        mapping (address => bool) refIsSet;\r\n        mapping (address => uint) refBonus;\r\n\r\n\r\n        // A constructor function for the contract. It used single time as contract is deployed.\r\n          // Единоразовая функция вызываемая при деплое контракта.\r\n        function Cash311() public {\r\n            // Sets an owner for the contract;\r\n              // Устанавливает владельца контракта;\r\n            owner = msg.sender;\r\n        }\r\n\r\n        // A function for transferring ownership of the contract (available only for the owner).\r\n          // Функция для переноса права владения контракта (доступна только для владельца).\r\n        function transferOwnership(address _newOwner) external {\r\n            require(msg.sender == owner);\r\n            require(_newOwner != address(0));\r\n            owner = _newOwner;\r\n        }\r\n\r\n        // RefSystem\r\n        function bytesToAddress1(bytes source) internal pure returns(address parsedReferer) {\r\n            assembly {\r\n                parsedReferer := mload(add(source,0x14))\r\n            }\r\n            return parsedReferer;\r\n        }\r\n\r\n        // A function for getting key info for investors.\r\n          // Функция для вызова ключевой информации для инвестора.\r\n        function getInfo(address _address) public view returns(uint Deposit, uint Withdrawn, uint AmountToWithdraw, uint Bonuses) {\r\n\r\n            // 1) Amount of invested tokens;\r\n              // 1) Сумма вложенных токенов;\r\n            Deposit = deposit[_address].div(decimals);\r\n            // 2) Amount of withdrawn tokens;\r\n              // 3) Сумма снятых средств;\r\n            Withdrawn = withdrawn[_address].div(decimals);\r\n            // 3) Amount of tokens which is available to withdraw;\r\n            // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 period)) * (Deposit * 0.0311) / decimals / 1 period\r\n              // 4) Сумма токенов доступных к выводу;\r\n              // Формула без библиотеки безопасных вычислений: ((Текущее время - Отчетное время) - ((Текущее время - Отчетное время) % 1 period)) * (Сумма депозита * 0.0311) / decimals / 1 period\r\n            uint _a = (block.timestamp.sub(lastTimeWithdraw[_address]).sub((block.timestamp.sub(lastTimeWithdraw[_address])).mod(1 days))).mul(deposit[_address].mul(311).div(10000)).div(1 days);\r\n            AmountToWithdraw = _a.div(decimals);\r\n            // RefSystem\r\n            Bonuses = refBonus[_address].div(decimals);\r\n        }\r\n\r\n        // RefSystem\r\n        function getRefInfo(address _address) public view returns(uint Referals1, uint Referals1m, uint Referals2, uint Referals2m, uint Referals3, uint Referals3m) {\r\n            Referals1 = referals1[_address];\r\n            Referals1m = referals1m[_address].div(decimals);\r\n            Referals2 = referals2[_address];\r\n            Referals2m = referals2m[_address].div(decimals);\r\n            Referals3 = referals3[_address];\r\n            Referals3m = referals3m[_address].div(decimals);\r\n        }\r\n\r\n        function getNumber() public view returns(uint) {\r\n            return deposits;\r\n        }\r\n\r\n        function getTime(address _address) public view returns(uint Hours, uint Minutes) {\r\n            Hours = (lastTimeWithdraw[_address] % 1 days) / 1 hours;\r\n            Minutes = (lastTimeWithdraw[_address] % 1 days) % 1 hours / 1 minutes;\r\n        }\r\n\r\n\r\n\r\n\r\n        // A \"fallback\" function. It is automatically being called when anybody sends ETH to the contract. Even if the amount of ETH is ecual to 0;\r\n          // Функция автоматически вызываемая при получении ETH контрактом (даже если было отправлено 0 эфиров);\r\n        function() external payable {\r\n\r\n            // If investor accidentally sent ETH then function send it back;\r\n              // Если инвестором был отправлен ETH то средства возвращаются отправителю;\r\n            msg.sender.transfer(msg.value);\r\n            // If the value of sent ETH is equal to 0 then function executes special algorithm:\r\n            // 1) Gets amount of intended deposit (approved tokens).\r\n            // 2) If there are no approved tokens then function \"withdraw\" is called for investors;\r\n              // Если было отправлено 0 эфиров то исполняется следующий алгоритм:\r\n              // 1) Заправшивается количество токенов для инвестирования (кол-во одобренных к выводу токенов).\r\n              // 2) Если одобрены токенов нет, для действующих инвесторов вызывается функция инвестирования (после этого действие функции прекращается);\r\n            uint _approvedTokens = token.allowance(msg.sender, address(this));\r\n            if (_approvedTokens == 0 && deposit[msg.sender] > 0) {\r\n                withdraw();\r\n                return;\r\n            // If there are some approved tokens to invest then function \"invest\" is called;\r\n              // Если были одобрены токены то вызывается функция инвестирования (после этого действие функции прекращается);\r\n            } else {\r\n                invest();\r\n                return;\r\n            }\r\n        }\r\n\r\n        // RefSystem\r\n        function refSystem(uint _value, address _referer) internal {\r\n            refBonus[_referer] = refBonus[_referer].add(_value.div(40));\r\n            referals1m[_referer] = referals1m[_referer].add(_value);\r\n            if (refIsSet[_referer]) {\r\n                address ref2 = referers[_referer];\r\n                refBonus[ref2] = refBonus[ref2].add(_value.div(50));\r\n                referals2m[ref2] = referals2m[ref2].add(_value);\r\n                if (refIsSet[referers[_referer]]) {\r\n                    address ref3 = referers[referers[_referer]];\r\n                    refBonus[ref3] = refBonus[ref3].add(_value.mul(3).div(200));\r\n                    referals3m[ref3] = referals3m[ref3].add(_value);\r\n                }\r\n            }\r\n        }\r\n\r\n        // RefSystem\r\n        function setRef(uint _value) internal {\r\n            address referer = bytesToAddress1(bytes(msg.data));\r\n            if (deposit[referer] > 0) {\r\n                referers[msg.sender] = referer;\r\n                refIsSet[msg.sender] = true;\r\n                referals1[referer] = referals1[referer].add(1);\r\n                if (refIsSet[referer]) {\r\n                    referals2[referers[referer]] = referals2[referers[referer]].add(1);\r\n                    if (refIsSet[referers[referer]]) {\r\n                        referals3[referers[referers[referer]]] = referals3[referers[referers[referer]]].add(1);\r\n                    }\r\n                }\r\n                refBonus[msg.sender] = refBonus[msg.sender].add(_value.div(50));\r\n                refSystem(_value, referer);\r\n            }\r\n        }\r\n\r\n\r\n\r\n        // A function which accepts tokens of investors.\r\n          // Функция для перевода токенов на контракт.\r\n        function invest() public {\r\n\r\n            // Gets amount of deposit (approved tokens);\r\n              // Заправшивает количество токенов для инвестирования (кол-во одобренных к выводу токенов);\r\n            uint _value = token.allowance(msg.sender, address(this));\r\n\r\n            // Transfers approved ERC20 tokens from investors address;\r\n              // Переводит одобренные к выводу токены ERC20 на данный контракт;\r\n            token.transferFrom(msg.sender, address(this), _value);\r\n            // Transfers a fee to the owner of the contract. The fee is 10% of the deposit (or Deposit / 10)\r\n              // Начисляет комиссию владельцу (10%);\r\n            refBonus[owner] = refBonus[owner].add(_value.div(10));\r\n\r\n            // The special algorithm for investors who increases their deposits:\r\n              // Специальный алгоритм для инвесторов увеличивающих их вклад;\r\n            if (deposit[msg.sender] > 0) {\r\n                // Amount of tokens which is available to withdraw;\r\n                // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 period)) * (Deposit * 0.0311) / 1 period\r\n                  // Расчет количества токенов доступных к выводу;\r\n                  // Формула без библиотеки безопасных вычислений: ((Текущее время - Отчетное время) - ((Текущее время - Отчетное время) % 1 period)) * (Сумма депозита * 0.0311) / 1 period\r\n                uint amountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(311).div(10000)).div(1 days);\r\n                // The additional algorithm for investors who need to withdraw available dividends:\r\n                  // Дополнительный алгоритм для инвесторов которые имеют средства к снятию;\r\n                if (amountToWithdraw != 0) {\r\n                    // Increasing the withdrawn tokens by the investor.\r\n                      // Увеличение количества выведенных средств инвестором;\r\n                    withdrawn[msg.sender] = withdrawn[msg.sender].add(amountToWithdraw);\r\n                    // Transferring available dividends to the investor.\r\n                      // Перевод доступных к выводу средств на кошелек инвестора;\r\n                    token.transfer(msg.sender, amountToWithdraw);\r\n\r\n                    // RefSystem\r\n                    uint _bonus = refBonus[msg.sender];\r\n                    if (_bonus != 0) {\r\n                        refBonus[msg.sender] = 0;\r\n                        token.transfer(msg.sender, _bonus);\r\n                        withdrawn[msg.sender] = withdrawn[msg.sender].add(_bonus);\r\n                    }\r\n\r\n                }\r\n                // Setting the reference point to the current time.\r\n                  // Установка нового отчетного времени для инвестора;\r\n                lastTimeWithdraw[msg.sender] = block.timestamp;\r\n                // Increasing of the deposit of the investor.\r\n                  // Увеличение Суммы депозита инвестора;\r\n                deposit[msg.sender] = deposit[msg.sender].add(_value);\r\n                // End of the function for investors who increases their deposits.\r\n                  // Конец функции для инвесторов увеличивающих свои депозиты;\r\n\r\n                // RefSystem\r\n                if (refIsSet[msg.sender]) {\r\n                      refSystem(_value, referers[msg.sender]);\r\n                  } else if (msg.data.length == 20) {\r\n                      setRef(_value);\r\n                  }\r\n                return;\r\n            }\r\n            // The algorithm for new investors:\r\n            // Setting the reference point to the current time.\r\n              // Алгоритм для новых инвесторов:\r\n              // Установка нового отчетного времени для инвестора;\r\n            lastTimeWithdraw[msg.sender] = block.timestamp;\r\n            // Storing the amount of the deposit for new investors.\r\n            // Установка суммы внесенного депозита;\r\n            deposit[msg.sender] = (_value);\r\n            deposits += 1;\r\n\r\n            // RefSystem\r\n            if (refIsSet[msg.sender]) {\r\n                refSystem(_value, referers[msg.sender]);\r\n            } else if (msg.data.length == 20) {\r\n                setRef(_value);\r\n            }\r\n        }\r\n\r\n        // A function for getting available dividends of the investor.\r\n          // Функция для вывода средств доступных к снятию;\r\n        function withdraw() public {\r\n\r\n            // Amount of tokens which is available to withdraw.\r\n            // Formula without SafeMath: ((Current Time - Reference Point) - ((Current Time - Reference Point) % 1 period)) * (Deposit * 0.0311) / 1 period\r\n              // Расчет количества токенов доступных к выводу;\r\n              // Формула без библиотеки безопасных вычислений: ((Текущее время - Отчетное время) - ((Текущее время - Отчетное время) % 1 period)) * (Сумма депозита * 0.0311) / 1 period\r\n            uint amountToWithdraw = (block.timestamp.sub(lastTimeWithdraw[msg.sender]).sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days))).mul(deposit[msg.sender].mul(311).div(10000)).div(1 days);\r\n            // Reverting the whole function for investors who got nothing to withdraw yet.\r\n              // В случае если к выводу нет средств то функция отменяется;\r\n            if (amountToWithdraw == 0) {\r\n                revert();\r\n            }\r\n            // Increasing the withdrawn tokens by the investor.\r\n              // Увеличение количества выведенных средств инвестором;\r\n            withdrawn[msg.sender] = withdrawn[msg.sender].add(amountToWithdraw);\r\n            // Updating the reference point.\r\n            // Formula without SafeMath: Current Time - ((Current Time - Previous Reference Point) % 1 period)\r\n              // Обновление отчетного времени инвестора;\r\n              // Формула без библиотеки безопасных вычислений: Текущее время - ((Текущее время - Предыдущее отчетное время) % 1 period)\r\n            lastTimeWithdraw[msg.sender] = block.timestamp.sub((block.timestamp.sub(lastTimeWithdraw[msg.sender])).mod(1 days));\r\n            // Transferring the available dividends to the investor.\r\n              // Перевод выведенных средств;\r\n            token.transfer(msg.sender, amountToWithdraw);\r\n\r\n            // RefSystem\r\n            uint _bonus = refBonus[msg.sender];\r\n            if (_bonus != 0) {\r\n                refBonus[msg.sender] = 0;\r\n                token.transfer(msg.sender, _bonus);\r\n                withdrawn[msg.sender] = withdrawn[msg.sender].add(_bonus);\r\n            }\r\n\r\n        }\r\n    }","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getRefInfo\",\"outputs\":[{\"name\":\"Referals1\",\"type\":\"uint256\"},{\"name\":\"Referals1m\",\"type\":\"uint256\"},{\"name\":\"Referals2\",\"type\":\"uint256\"},{\"name\":\"Referals2m\",\"type\":\"uint256\"},{\"name\":\"Referals3\",\"type\":\"uint256\"},{\"name\":\"Referals3m\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getTime\",\"outputs\":[{\"name\":\"Hours\",\"type\":\"uint256\"},{\"name\":\"Minutes\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"Deposit\",\"type\":\"uint256\"},{\"name\":\"Withdrawn\",\"type\":\"uint256\"},{\"name\":\"AmountToWithdraw\",\"type\":\"uint256\"},{\"name\":\"Bonuses\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Cash311","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6937c211a4d25c0cac069bd2466ff28a03342622434eb1a15b2e41bbc9e45e2b"}]}