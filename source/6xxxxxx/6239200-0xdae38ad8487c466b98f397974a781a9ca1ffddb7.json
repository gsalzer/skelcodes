{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\nlibrary AddressSet {\r\n\r\n    struct Instance {\r\n        address[] list;\r\n        mapping(address => uint256) idx; // actually stores indexes incremented by 1\r\n    }\r\n\r\n    function push(Instance storage self, address addr) internal returns (bool) {\r\n        if (self.idx[addr] != 0) return false;\r\n        self.idx[addr] = self.list.push(addr);\r\n        return true;\r\n    }\r\n\r\n    function sizeOf(Instance storage self) internal view returns (uint256) {\r\n        return self.list.length;\r\n    }\r\n\r\n    function getAddress(Instance storage self, uint256 index) internal view returns (address) {\r\n        return (index < self.list.length) ? self.list[index] : address(0);\r\n    }\r\n\r\n    function remove(Instance storage self, address addr) internal returns (bool) {\r\n        if (self.idx[addr] == 0) return false;\r\n        uint256 idx = self.idx[addr];\r\n        delete self.idx[addr];\r\n        if (self.list.length == idx) {\r\n            self.list.length--;\r\n        } else {\r\n            address last = self.list[self.list.length-1];\r\n            self.list.length--;\r\n            self.list[idx-1] = last;\r\n            self.idx[last] = idx;\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract ERC20 {\r\n    function totalSupply() external view returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract UHCToken is ERC20 {\r\n    using SafeMath for uint256;\r\n    using AddressSet for AddressSet.Instance;\r\n\r\n    address public owner;\r\n    address public subowner;\r\n\r\n    bool    public              paused         = false;\r\n    bool    public              contractEnable = true;\r\n\r\n    string  public              name = \"UHC\";\r\n    string  public              symbol = \"UHC\";\r\n    uint8   public              decimals = 4;\r\n    uint256 private             summarySupply;\r\n    uint8   public              transferFeePercent = 3;\r\n    uint8   public              refererFeePercent = 1;\r\n\r\n    struct account{\r\n        uint256 balance;\r\n        uint8 group;\r\n        uint8 status;\r\n        address referer;\r\n        bool isBlocked;\r\n    }\r\n\r\n    mapping(address => account)                      private   accounts;\r\n    mapping(address => mapping (address => uint256)) private   allowed;\r\n    mapping(bytes => address)                        private   promos;\r\n\r\n    AddressSet.Instance                             private   holders;\r\n\r\n    struct groupPolicy {\r\n        uint8 _default;\r\n        uint8 _backend;\r\n        uint8 _admin;\r\n        uint8 _owner;\r\n    }\r\n\r\n    groupPolicy public groupPolicyInstance = groupPolicy(0, 3, 4, 9);\r\n\r\n    event EvGroupChanged(address indexed _address, uint8 _oldgroup, uint8 _newgroup);\r\n    event EvMigration(address indexed _address, uint256 _balance, uint256 _secret);\r\n    event EvUpdateStatus(address indexed _address, uint8 _oldstatus, uint8 _newstatus);\r\n    event EvSetReferer(address indexed _referal, address _referer);\r\n    event SwitchPause(bool isPaused);\r\n\r\n    constructor (string _name, string _symbol, uint8 _decimals,uint256 _summarySupply, uint8 _transferFeePercent, uint8 _refererFeePercent) public {\r\n        require(_refererFeePercent < _transferFeePercent);\r\n        owner = msg.sender;\r\n\r\n        accounts[owner] = account(_summarySupply,groupPolicyInstance._owner,3, address(0), false);\r\n\r\n        holders.push(msg.sender);\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n        summarySupply = _summarySupply;\r\n        transferFeePercent = _transferFeePercent;\r\n        refererFeePercent = _refererFeePercent;\r\n        emit Transfer(address(0), msg.sender, _summarySupply);\r\n    }\r\n\r\n    modifier minGroup(int _require) {\r\n        require(accounts[msg.sender].group >= _require);\r\n        _;\r\n    }\r\n\r\n    modifier onlySubowner() {\r\n        require(msg.sender == subowner);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused || accounts[msg.sender].group >= groupPolicyInstance._backend);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotMigrating {\r\n        require(contractEnable);\r\n        _;\r\n    }\r\n\r\n    modifier whenMigrating {\r\n        require(!contractEnable);\r\n        _;\r\n    }\r\n\r\n    function servicePause() minGroup(groupPolicyInstance._admin) whenNotPaused public {\r\n        paused = true;\r\n        emit SwitchPause(paused);\r\n    }\r\n\r\n    function serviceUnpause() minGroup(groupPolicyInstance._admin) whenPaused public {\r\n        paused = false;\r\n        emit SwitchPause(paused);\r\n    }\r\n\r\n    function serviceGroupChange(address _address, uint8 _group) minGroup(groupPolicyInstance._admin) external returns(uint8) {\r\n        require(_address != address(0));\r\n        require(_group <= groupPolicyInstance._admin);\r\n\r\n        uint8 old = accounts[_address].group;\r\n        require(old < accounts[msg.sender].group);\r\n\r\n        accounts[_address].group = _group;\r\n        emit EvGroupChanged(_address, old, _group);\r\n\r\n        return accounts[_address].group;\r\n    }\r\n\r\n    function serviceTransferOwnership(address newOwner) minGroup(groupPolicyInstance._owner) external {\r\n        require(newOwner != address(0));\r\n\r\n        subowner = newOwner;\r\n    }\r\n\r\n    function serviceClaimOwnership() onlySubowner() external {\r\n        address temp = owner;\r\n        uint256 value = accounts[owner].balance;\r\n\r\n        accounts[owner].balance = accounts[owner].balance.sub(value);\r\n        holders.remove(owner);\r\n        accounts[msg.sender].balance = accounts[msg.sender].balance.add(value);\r\n        holders.push(msg.sender);\r\n\r\n        owner = msg.sender;\r\n        subowner = address(0);\r\n\r\n        delete accounts[temp].group;\r\n        uint8 oldGroup = accounts[msg.sender].group;\r\n        accounts[msg.sender].group = groupPolicyInstance._owner;\r\n\r\n        emit EvGroupChanged(msg.sender, oldGroup, groupPolicyInstance._owner);\r\n        emit Transfer(temp, owner, value);\r\n    }\r\n\r\n    function serviceSwitchTransferAbility(address _address) external minGroup(groupPolicyInstance._admin) returns(bool) {\r\n        require(accounts[_address].group < accounts[msg.sender].group);\r\n\r\n        accounts[_address].isBlocked = !accounts[_address].isBlocked;\r\n\r\n        return true;\r\n    }\r\n\r\n    function serviceUpdateTransferFeePercent(uint8 newFee) external minGroup(groupPolicyInstance._admin) {\r\n        require(newFee < 100);\r\n        require(newFee > refererFeePercent);\r\n        transferFeePercent = newFee;\r\n    }\r\n\r\n    function serviceUpdateRefererFeePercent(uint8 newFee) external minGroup(groupPolicyInstance._admin) {\r\n        require(newFee < 100);\r\n        require(transferFeePercent > newFee);\r\n        refererFeePercent = newFee;\r\n    }\r\n\r\n    function serviceSetPromo(bytes num, address _address) external minGroup(groupPolicyInstance._admin) {\r\n        promos[num] = _address;\r\n    }\r\n\r\n    function backendSetStatus(address _address, uint8 status) external minGroup(groupPolicyInstance._backend) returns(bool){\r\n        require(_address != address(0));\r\n        require(status >= 0 && status <= 4);\r\n        uint8 oldStatus = accounts[_address].status;\r\n        accounts[_address].status = status;\r\n\r\n        emit EvUpdateStatus(_address, oldStatus, status);\r\n\r\n        return true;\r\n    }\r\n\r\n    function backendSetReferer(address _referal, address _referer) external minGroup(groupPolicyInstance._backend) returns(bool) {\r\n        require(accounts[_referal].referer == address(0));\r\n        require(_referal != address(0));\r\n        require(_referal != _referer);\r\n        require(accounts[_referal].referer != _referer);\r\n\r\n        accounts[_referal].referer = _referer;\r\n\r\n        emit EvSetReferer(_referal, _referer);\r\n\r\n        return true;\r\n    }\r\n\r\n    function backendSendBonus(address _to, uint256 _value) external minGroup(groupPolicyInstance._backend) returns(bool) {\r\n        require(_to != address(0));\r\n        require(_value > 0);\r\n        require(accounts[owner].balance >= _value);\r\n\r\n        accounts[owner].balance = accounts[owner].balance.sub(_value);\r\n        accounts[_to].balance = accounts[_to].balance.add(_value);\r\n\r\n        emit Transfer(owner, _to, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    function backendRefund(address _from, uint256 _value) external minGroup(groupPolicyInstance._backend) returns(uint256 balance) {\r\n        require(_from != address(0));\r\n        require(_value > 0);\r\n        require(accounts[_from].balance >= _value);\r\n \r\n        accounts[_from].balance = accounts[_from].balance.sub(_value);\r\n        accounts[owner].balance = accounts[owner].balance.add(_value);\r\n        if(accounts[_from].balance == 0){\r\n            holders.remove(_from);\r\n        }\r\n        emit Transfer(_from, owner, _value);\r\n        return accounts[_from].balance;\r\n    }\r\n\r\n    function getGroup(address _check) external view returns(uint8 _group) {\r\n        return accounts[_check].group;\r\n    }\r\n\r\n    function getHoldersLength() external view returns(uint256){\r\n        return holders.sizeOf();\r\n    }\r\n\r\n    function getHolderByIndex(uint256 _index) external view returns(address){\r\n        return holders.getAddress(_index);\r\n    }\r\n\r\n    function getPromoAddress(bytes _promo) external view returns(address) {\r\n        return promos[_promo];\r\n    }\r\n\r\n    function getAddressTransferAbility(address _check) external view returns(bool) {\r\n        return !accounts[_check].isBlocked;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) external returns (bool success) {\r\n        return _transfer(msg.sender, _to, address(0), _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n        return _transfer(_from, _to, msg.sender, _value);\r\n    }\r\n\r\n    function _transfer(address _from, address _to, address _allow, uint256 _value) minGroup(groupPolicyInstance._default) whenNotMigrating whenNotPaused internal returns(bool) {\r\n        require(!accounts[_from].isBlocked);\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n        uint256 transferFee = accounts[_from].group == 0 ? _value.div(100).mul(accounts[_from].referer == address(0) ? transferFeePercent : transferFeePercent - refererFeePercent) : 0;\r\n        uint256 transferRefererFee = accounts[_from].referer == address(0) || accounts[_from].group != 0 ? 0 : _value.div(100).mul(refererFeePercent);\r\n        uint256 summaryValue = _value.add(transferFee).add(transferRefererFee);\r\n        require(accounts[_from].balance >= summaryValue);\r\n        require(_allow == address(0) || allowed[_from][_allow] >= summaryValue);\r\n\r\n        accounts[_from].balance = accounts[_from].balance.sub(summaryValue);\r\n        if(_allow != address(0)) {\r\n            allowed[_from][_allow] = allowed[_from][_allow].sub(summaryValue);\r\n        }\r\n\r\n        if(accounts[_from].balance == 0){\r\n            holders.remove(_from);\r\n        }\r\n        accounts[_to].balance = accounts[_to].balance.add(_value);\r\n        holders.push(_to);\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        if(transferFee > 0) {\r\n            accounts[owner].balance = accounts[owner].balance.add(transferFee);\r\n            emit Transfer(_from, owner, transferFee);\r\n        }\r\n\r\n        if(transferRefererFee > 0) {\r\n            accounts[accounts[_from].referer].balance = accounts[accounts[_from].referer].balance.add(transferRefererFee);\r\n            holders.push(accounts[_from].referer);\r\n            emit Transfer(_from, accounts[_from].referer, transferRefererFee);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) minGroup(groupPolicyInstance._default) whenNotPaused external returns (bool success) {\r\n        require (_value == 0 || allowed[msg.sender][_spender] == 0);\r\n        require(_spender != address(0));\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint256 _addedValue) minGroup(groupPolicyInstance._default) whenNotPaused external returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint256 _subtractedValue) minGroup(groupPolicyInstance._default) whenNotPaused external returns (bool)\r\n    {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function balanceOf(address _owner) external view returns (uint256 balance) {\r\n        return accounts[_owner].balance;\r\n    }\r\n\r\n    function statusOf(address _owner) external view returns (uint8) {\r\n        return accounts[_owner].status;\r\n    }\r\n\r\n    function refererOf(address _owner) external constant returns (address) {\r\n        return accounts[_owner].referer;\r\n    }\r\n\r\n    function totalSupply() external constant returns (uint256 _totalSupply) {\r\n        _totalSupply = summarySupply;\r\n    }\r\n\r\n    function settingsSwitchState() external minGroup(groupPolicyInstance._owner) returns (bool state) {\r\n\r\n        contractEnable = !contractEnable;\r\n\r\n        return contractEnable;\r\n    }\r\n\r\n    function userMigration(uint256 _secret) external whenMigrating returns (bool successful) {\r\n        uint256 balance = accounts[msg.sender].balance;\r\n\r\n        require (balance > 0);\r\n\r\n        accounts[msg.sender].balance = accounts[msg.sender].balance.sub(balance);\r\n        holders.remove(msg.sender);\r\n        accounts[owner].balance = accounts[owner].balance.add(balance);\r\n        holders.push(owner);\r\n        emit EvMigration(msg.sender, balance, _secret);\r\n        emit Transfer(msg.sender, owner, balance);\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract EtherReceiver {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public      startTime;\r\n    uint256 public      durationOfStatusSell;\r\n    uint256 public      weiPerMinToken;\r\n    uint256 public      softcap;\r\n    uint256 public      totalSold;\r\n    uint8   public      referalBonusPercent;\r\n    uint8   public      refererFeePercent;\r\n\r\n    uint256 public      refundStageStartTime;\r\n    uint256 public      maxRefundStageDuration;\r\n\r\n    mapping(uint256 => uint256) public      soldOnVersion;\r\n    mapping(address => uint8)   private     group;\r\n\r\n    uint256 public     version;\r\n    uint256 public      etherTotal;\r\n\r\n    bool    public     isActive = false;\r\n    \r\n    struct Account{\r\n        // Hack to save gas\r\n        // if > 0 then value + 1\r\n        uint256 spent;\r\n        uint256 allTokens;\r\n        uint256 statusTokens;\r\n        uint256 version;\r\n        // if > 0 then value + 1\r\n        uint256 versionTokens;\r\n        // if > 0 then value + 1\r\n        uint256 versionStatusTokens;\r\n        // if > 0 then value + 1\r\n        uint256 versionRefererTokens;\r\n        uint8 versionBeforeStatus;\r\n    }\r\n\r\n    mapping(address => Account) public accounts;\r\n\r\n    struct groupPolicy {\r\n        uint8 _backend;\r\n        uint8 _admin;\r\n    }\r\n\r\n    groupPolicy public groupPolicyInstance = groupPolicy(3,4);\r\n\r\n    uint256[4] public statusMinBorders;\r\n\r\n    UHCToken public            token;\r\n\r\n    event EvAccountPurchase(address indexed _address, uint256 _newspent, uint256 _newtokens, uint256 _totalsold);\r\n    //Используем на бекенде для возврата BTC по версии\r\n    event EvWithdraw(address indexed _address, uint256 _spent, uint256 _version);\r\n    event EvSwitchActivate(address indexed _switcher, bool _isActivate);\r\n    event EvSellStatusToken(address indexed _owner, uint256 _oldtokens, uint256 _newtokens);\r\n    event EvUpdateVersion(address indexed _owner, uint256 _version);\r\n    event EvGroupChanged(address _address, uint8 _oldgroup, uint8 _newgroup);\r\n\r\n    constructor (\r\n        address _token,\r\n        uint256 _startTime,\r\n        uint256 _weiPerMinToken, \r\n        uint256 _softcap,\r\n        uint256 _durationOfStatusSell,\r\n        uint[4] _statusMinBorders, \r\n        uint8 _referalBonusPercent, \r\n        uint8 _refererFeePercent,\r\n        uint256 _maxRefundStageDuration,\r\n        bool _activate\r\n    ) public\r\n    {\r\n        token = UHCToken(_token);\r\n        startTime = _startTime;\r\n        weiPerMinToken = _weiPerMinToken;\r\n        softcap = _softcap;\r\n        durationOfStatusSell = _durationOfStatusSell;\r\n        statusMinBorders = _statusMinBorders;\r\n        referalBonusPercent = _referalBonusPercent;\r\n        refererFeePercent = _refererFeePercent;\r\n        maxRefundStageDuration = _maxRefundStageDuration;\r\n        isActive = _activate;\r\n        group[msg.sender] = groupPolicyInstance._admin;\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == token.owner());\r\n        _;\r\n    }\r\n\r\n    modifier saleIsOn() {\r\n        require(now > startTime && isActive && soldOnVersion[version] < softcap);\r\n        _;\r\n    }\r\n\r\n    modifier minGroup(int _require) {\r\n        require(group[msg.sender] >= _require || msg.sender == token.owner());\r\n        _;\r\n    }\r\n\r\n    function refresh(\r\n        uint256 _startTime, \r\n        uint256 _softcap,\r\n        uint256 _durationOfStatusSell,\r\n        uint[4] _statusMinBorders,\r\n        uint8 _referalBonusPercent, \r\n        uint8 _refererFeePercent,\r\n        uint256 _maxRefundStageDuration,\r\n        bool _activate\r\n    ) \r\n        external\r\n        minGroup(groupPolicyInstance._admin) \r\n    {\r\n        require(!isActive && etherTotal == 0);\r\n        startTime = _startTime;\r\n        softcap = _softcap;\r\n        durationOfStatusSell = _durationOfStatusSell;\r\n        statusMinBorders = _statusMinBorders;\r\n        referalBonusPercent = _referalBonusPercent;\r\n        refererFeePercent = _refererFeePercent;\r\n        version = version.add(1);\r\n        maxRefundStageDuration = _maxRefundStageDuration;\r\n        isActive = _activate;\r\n\r\n        refundStageStartTime = 0;\r\n\r\n        emit EvUpdateVersion(msg.sender, version);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) external minGroup(groupPolicyInstance._backend) saleIsOn() {\r\n        token.transfer( _to, _value);\r\n\r\n        updateAccountInfo(_to, 0, _value);\r\n\r\n        address referer = token.refererOf(_to);\r\n        trySendBonuses(_to, referer, _value);\r\n    }\r\n\r\n    function withdraw() external minGroup(groupPolicyInstance._admin) returns(bool success) {\r\n        require(!isActive && (soldOnVersion[version] >= softcap || now > refundStageStartTime + maxRefundStageDuration));\r\n        uint256 contractBalance = address(this).balance;\r\n        token.owner().transfer(contractBalance);\r\n        etherTotal = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    function activateVersion(bool _isActive) external minGroup(groupPolicyInstance._admin) {\r\n        require(isActive != _isActive);\r\n        isActive = _isActive;\r\n        refundStageStartTime = isActive ? 0 : now;\r\n        emit EvSwitchActivate(msg.sender, isActive);\r\n    }\r\n\r\n    function setWeiPerMinToken(uint256 _weiPerMinToken) external minGroup(groupPolicyInstance._backend)  {\r\n        require (_weiPerMinToken > 0);\r\n\r\n        weiPerMinToken = _weiPerMinToken;\r\n    }\r\n\r\n    function refund() external {\r\n        require(!isActive && soldOnVersion[version] < softcap && now <= refundStageStartTime + maxRefundStageDuration);\r\n\r\n        tryUpdateVersion(msg.sender);\r\n\r\n        Account storage account = accounts[msg.sender];\r\n\r\n        require(account.spent > 1);\r\n\r\n        uint256 value = account.spent.sub(1);\r\n        account.spent = 1;\r\n        etherTotal = etherTotal.sub(value);\r\n        \r\n        msg.sender.transfer(value);\r\n\r\n        if(account.versionTokens > 0) {\r\n            token.backendRefund(msg.sender, account.versionTokens.sub(1));\r\n            account.allTokens = account.allTokens.sub(account.versionTokens.sub(1));\r\n            account.statusTokens = account.statusTokens.sub(account.versionStatusTokens.sub(1));\r\n            account.versionStatusTokens = 1;\r\n            account.versionTokens = 1;\r\n        }\r\n\r\n        address referer = token.refererOf(msg.sender);\r\n        if(account.versionRefererTokens > 0 && referer != address(0)) {\r\n            token.backendRefund(referer, account.versionRefererTokens.sub(1));\r\n            account.versionRefererTokens = 1;\r\n        }\r\n\r\n        uint8 currentStatus = token.statusOf(msg.sender);\r\n        if(account.versionBeforeStatus != currentStatus){\r\n            token.backendSetStatus(msg.sender, account.versionBeforeStatus);\r\n        }\r\n\r\n        emit EvWithdraw(msg.sender, value, version);\r\n    }\r\n\r\n    function serviceGroupChange(address _address, uint8 _group) minGroup(groupPolicyInstance._admin) external returns(uint8) {\r\n        uint8 old = group[_address];\r\n        if(old <= groupPolicyInstance._admin) {\r\n            group[_address] = _group;\r\n            emit EvGroupChanged(_address, old, _group);\r\n        }\r\n        return group[_address];\r\n    }\r\n\r\n    function () external saleIsOn() payable{\r\n        uint256 tokenCount = msg.value.div(weiPerMinToken);\r\n        require(tokenCount > 0);\r\n\r\n        token.transfer( msg.sender, tokenCount);\r\n\r\n        updateAccountInfo(msg.sender, msg.value, tokenCount);\r\n\r\n        address referer = token.refererOf(msg.sender);\r\n        if (msg.data.length > 0 && referer == address(0)) {\r\n            referer = token.getPromoAddress(bytes(msg.data));\r\n            if(referer != address(0)) {\r\n                require(referer != msg.sender);\r\n                require(token.backendSetReferer(msg.sender, referer));\r\n            }\r\n        }\r\n        trySendBonuses(msg.sender, referer, tokenCount);\r\n    }\r\n\r\n    function updateAccountInfo(address _address, uint256 incSpent, uint256 incTokenCount) private returns(bool){\r\n        tryUpdateVersion(_address);\r\n        Account storage account = accounts[_address];\r\n        account.spent = account.spent.add(incSpent);\r\n        account.allTokens = account.allTokens.add(incTokenCount);\r\n        \r\n        account.versionTokens = account.versionTokens.add(incTokenCount);\r\n        \r\n        totalSold = totalSold.add(incTokenCount);\r\n        soldOnVersion[version] = soldOnVersion[version].add(incTokenCount);\r\n        etherTotal = etherTotal.add(incSpent);\r\n\r\n        emit EvAccountPurchase(_address, account.spent.sub(1), account.allTokens, totalSold);\r\n\r\n        if(now < startTime + durationOfStatusSell && now >= startTime){\r\n\r\n            uint256 lastStatusTokens = account.statusTokens;\r\n\r\n            account.statusTokens = account.statusTokens.add(incTokenCount);\r\n            account.versionStatusTokens = account.versionStatusTokens.add(incTokenCount);\r\n\r\n            uint256 currentStatus = uint256(token.statusOf(_address));\r\n\r\n            uint256 newStatus = currentStatus;\r\n\r\n            for(uint256 i = currentStatus; i < 4; i++){\r\n\r\n                if(account.statusTokens > statusMinBorders[i]){\r\n                    newStatus = i + 1;\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            if(currentStatus < newStatus){\r\n                token.backendSetStatus(_address, uint8(newStatus));\r\n            }\r\n            emit EvSellStatusToken(_address, lastStatusTokens, account.statusTokens);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function tryUpdateVersion(address _address) private {\r\n        Account storage account = accounts[_address];\r\n        if(account.version != version){\r\n            account.version = version;\r\n            account.versionBeforeStatus = token.statusOf(_address);\r\n        }\r\n        if(account.version != version || account.spent == 0){\r\n            account.spent = 1;\r\n            account.versionTokens = 1;\r\n            account.versionRefererTokens = 1;\r\n            account.versionStatusTokens = 1;\r\n        }\r\n    }\r\n\r\n    function trySendBonuses(address _address, address _referer, uint256 _tokenCount) private {\r\n        if(_referer != address(0)) {\r\n            uint256 refererFee = _tokenCount.div(100).mul(refererFeePercent);\r\n            uint256 referalBonus = _tokenCount.div(100).mul(referalBonusPercent);\r\n            if(refererFee > 0) {\r\n                token.backendSendBonus(_referer, refererFee);\r\n                \r\n                accounts[_address].versionRefererTokens = accounts[_address].versionRefererTokens.add(refererFee);\r\n                \r\n            }\r\n            if(referalBonus > 0) {\r\n                token.backendSendBonus(_address, referalBonus);\r\n                \r\n                accounts[_address].versionTokens = accounts[_address].versionTokens.add(referalBonus);\r\n                accounts[_address].allTokens = accounts[_address].allTokens.add(referalBonus);\r\n            }\r\n        }\r\n    }\r\n\r\n    function calculateTokenCount(uint256 weiAmount) external view returns(uint256 summary){\r\n        return weiAmount.div(weiPerMinToken);\r\n    }\r\n\r\n    function isSelling() external view returns(bool){\r\n        return now > startTime && soldOnVersion[version] < softcap && isActive;\r\n    }\r\n\r\n    function getGroup(address _check) external view returns(uint8 _group) {\r\n        return group[_check];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"weiPerMinToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"durationOfStatusSell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"soldOnVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundStageStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_check\",\"type\":\"address\"}],\"name\":\"getGroup\",\"outputs\":[{\"name\":\"_group\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_group\",\"type\":\"uint8\"}],\"name\":\"serviceGroupChange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refererFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"spent\",\"type\":\"uint256\"},{\"name\":\"allTokens\",\"type\":\"uint256\"},{\"name\":\"statusTokens\",\"type\":\"uint256\"},{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"versionTokens\",\"type\":\"uint256\"},{\"name\":\"versionStatusTokens\",\"type\":\"uint256\"},{\"name\":\"versionRefererTokens\",\"type\":\"uint256\"},{\"name\":\"versionBeforeStatus\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"statusMinBorders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_softcap\",\"type\":\"uint256\"},{\"name\":\"_durationOfStatusSell\",\"type\":\"uint256\"},{\"name\":\"_statusMinBorders\",\"type\":\"uint256[4]\"},{\"name\":\"_referalBonusPercent\",\"type\":\"uint8\"},{\"name\":\"_refererFeePercent\",\"type\":\"uint8\"},{\"name\":\"_maxRefundStageDuration\",\"type\":\"uint256\"},{\"name\":\"_activate\",\"type\":\"bool\"}],\"name\":\"refresh\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referalBonusPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isActive\",\"type\":\"bool\"}],\"name\":\"activateVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSelling\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_weiPerMinToken\",\"type\":\"uint256\"}],\"name\":\"setWeiPerMinToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxRefundStageDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"groupPolicyInstance\",\"outputs\":[{\"name\":\"_backend\",\"type\":\"uint8\"},{\"name\":\"_admin\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"calculateTokenCount\",\"outputs\":[{\"name\":\"summary\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_weiPerMinToken\",\"type\":\"uint256\"},{\"name\":\"_softcap\",\"type\":\"uint256\"},{\"name\":\"_durationOfStatusSell\",\"type\":\"uint256\"},{\"name\":\"_statusMinBorders\",\"type\":\"uint256[4]\"},{\"name\":\"_referalBonusPercent\",\"type\":\"uint8\"},{\"name\":\"_refererFeePercent\",\"type\":\"uint8\"},{\"name\":\"_maxRefundStageDuration\",\"type\":\"uint256\"},{\"name\":\"_activate\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newspent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newtokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_totalsold\",\"type\":\"uint256\"}],\"name\":\"EvAccountPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_spent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"EvWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_switcher\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_isActivate\",\"type\":\"bool\"}],\"name\":\"EvSwitchActivate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldtokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newtokens\",\"type\":\"uint256\"}],\"name\":\"EvSellStatusToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"EvUpdateVersion\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_oldgroup\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_newgroup\",\"type\":\"uint8\"}],\"name\":\"EvGroupChanged\",\"type\":\"event\"}]","ContractName":"EtherReceiver","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000087fe4ee2ed12c2582daf0c3829792004ffd1ff78000000000000000000000000000000000000000000000000000000005b878d1a000000000000000000000000000000000000000000000000000000517da02c00000000000000000000000000000000000000000000000000000000367b7ca400000000000000000000000000000000000000000000000000000000000076a70000000000000000000000000000000000000000000000000000000000000061a7000000000000000000000000000000000000000000000000000000000001869f000000000000000000000000000000000000000000000000000000000005572f000000000000000000000000000000000000000000000000000000000013d61f0000000000000000000000000000000000000000000000000000000000000005000000000000000000000000000000000000000000000000000000000000000500000000000000000000000000000000000000000000000000000000000d2f000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://0b337c5b8eb44133c05bc8ded8997635b150009e6598723a01d0603cfcfd2ddb"}]}