{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// SafeMath library\r\nlibrary SafeMath {\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\t\tuint256 c = _a + _b;\r\n\t\tassert(c >= _a);\r\n\t\treturn c;\r\n\t}\r\n\r\n\tfunction sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\t\tassert(_a >= _b);\r\n\t\treturn _a - _b;\r\n\t}\r\n\r\n\tfunction mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    if (_a == 0) {\r\n     return 0;\r\n    }\r\n\t\tuint256 c = _a * _b;\r\n\t\tassert(c / _a == _b);\r\n\t\treturn c;\r\n\t}\r\n\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n\t\treturn _a / _b;\r\n\t}\r\n}\r\n\r\n// Contract must have an owner\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"onlyOwner wrong\");\r\n    _;\r\n  }\r\n\r\n  function setOwner(address _owner) onlyOwner public {\r\n    owner = _owner;\r\n  }\r\n}\r\n\r\ninterface WTAGameBook {\r\n  function getPlayerIdByAddress(address _addr) external view returns (uint256);\r\n  function getPlayerAddressById(uint256 _id) external view returns (address);\r\n  function getPlayerRefById(uint256 _id) external view returns (uint256);\r\n  function getGameIdByAddress(address _addr) external view returns (uint256);\r\n  function getGameAddressById(uint256 _id) external view returns (address);\r\n  function isAdmin(address _addr) external view returns (bool);\r\n}\r\n\r\ninterface WTAGameRun {\r\n  function getCurrentRoundStartTime() external view returns (uint256);\r\n  function getCurrentRoundEndTime() external view returns (uint256);\r\n  function getCurrentRoundWinner() external view returns (uint256);\r\n}\r\n\r\ninterface ERC20Token {\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n  function balanceOf(address _addr) external view returns (uint256);\r\n  function decimals() external view returns (uint8);\r\n}\r\n\r\n// The WTA Token Pool that stores and handles token information\r\ncontract WTATokenPool is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 constant private DAY_IN_SECONDS = 86400;\r\n  string public name = \"WTATokenPool V0.5\";\r\n  string public version = \"0.5\";\r\n\r\n  // various token related stuff\r\n  struct TokenInfo {\r\n    ERC20Token token;\r\n    address addr;\r\n    uint8 decimals;\r\n    address payaddr;\r\n    uint256 bought;\r\n    uint256 safed;\r\n    uint256 potted;\r\n    uint256 price;\r\n    uint256 buypercent;\r\n    uint256 potpercent;\r\n    uint256 lockperiod;\r\n    uint256 tid;\r\n    bool active;\r\n  }\r\n\r\n  // Player's time-locked safe to store tokens\r\n  struct PlayerSafe {\r\n    mapping (uint256 => uint256) lockValue;\r\n    mapping (uint256 => uint256) lockTime;\r\n    uint256 locks;\r\n    uint256 withdraws;\r\n    uint256 withdrawn;\r\n  }\r\n\r\n  uint256 public tokenNum = 0;\r\n  mapping (uint256 => TokenInfo) public tokenPool;\r\n  mapping (address => bool) public tokenInPool;\r\n\r\n  mapping (uint256 => mapping(uint256 => PlayerSafe)) public playerSafes;\r\n  WTAGameBook public gamebook;\r\n\r\n  event TokenBought(uint256 _tid, uint256 _pid, uint256 _amount);\r\n  event TokenLocked(uint256 _tid, uint256 _pid, uint256 _amount, uint256 _locktime);\r\n  event TokenFundPaid(uint256 _tid, address indexed _paddr, uint256 _value);\r\n  event TokenPotFunded(uint256 _tid, uint256 _amount);\r\n  event TokenPotWon(uint256 _tid, uint256 _pid, uint256 _amount);\r\n  event TokenWithdrawn(uint256 _tid, uint256 _pid, uint256 _amount);\r\n\r\n  event InactiveTokenEmptied(uint256 _tid, address indexed _addr, uint256 _amount);\r\n  event WrongTokenEmptied(address indexed _token, address indexed _addr, uint256 _amount);\r\n  event WrongEtherEmptied(address indexed _addr, uint256 _amount);\r\n\r\n  // initial tokens\r\n  // IMPORTANT: price needs to be in Wei per 1 unit of token\r\n  // IMPORTANT: percent needs to be in %\r\n  // _tokenAddress: list of token addresses need to be added to the pool at contract creation\r\n  // _payAddress: list of token owner addresses which receives the payments\r\n  // _price: list of token prices\r\n  // _buypercent: list of how much token needs to be allocated to players relative to the listed buying price, in percentage form, for example 200 means 200%\r\n  // _potpercent: list of how much token needs to be allocated to the pot relative to the listed buying price, in percentage form, for example 40 means 40%\r\n  // _lockperiod: list of timelock periods for tokens allocated to the players before they can withdraw them, in seconds\r\n  // _gamebook: the address of the GameBook contract\r\n  constructor(address[] _tokenAddress, address[] _payAddress, uint256[] _price, uint256[] _buypercent, uint256[] _potpercent, uint256[] _lockperiod, address _gamebook) public {\r\n    require((_tokenAddress.length == _payAddress.length) && (_payAddress.length == _price.length) && (_price.length == _buypercent.length) && (_buypercent.length == _potpercent.length), \"TokenPool constructor wrong\");\r\n    tokenNum = _tokenAddress.length;\r\n    for (uint256 i = 0; i < tokenNum; i++) {\r\n      tokenPool[i].token = ERC20Token(_tokenAddress[i]);\r\n      tokenPool[i].addr = _tokenAddress[i];\r\n      tokenPool[i].decimals = tokenPool[i].token.decimals();\r\n      tokenPool[i].payaddr = _payAddress[i];\r\n      tokenPool[i].bought = 0;\r\n      tokenPool[i].safed = 0;\r\n      tokenPool[i].potted = 0;\r\n      tokenPool[i].price = _price[i];\r\n      tokenPool[i].buypercent = _buypercent[i];\r\n      tokenPool[i].potpercent = _potpercent[i];\r\n      tokenPool[i].lockperiod = _lockperiod[i];\r\n      tokenPool[i].tid = i;\r\n      tokenPool[i].active = true;\r\n      tokenInPool[_tokenAddress[i]] = true;\r\n    }\r\n    gamebook = WTAGameBook(_gamebook);\r\n  }\r\n\r\n  modifier isAdmin() {\r\n    require(gamebook.isAdmin(msg.sender), \"isAdmin wrong\");\r\n    _;\r\n  }\r\n\r\n  modifier isGame() {\r\n    require(gamebook.getGameIdByAddress(msg.sender) > 0, \"isGame wrong\");\r\n    _;\r\n  }\r\n\r\n  modifier isPaid() {\r\n    // paymnent must be greater than 1GWei and less than 100k ETH\r\n    require((msg.value > 1000000000) && (msg.value < 100000000000000000000000), \"isPaid wrong\");\r\n    _;\r\n  }\r\n\r\n  // admins may set a token to be active or inactive in the games\r\n  function setTokenActive(uint256 _tid, bool _active) isAdmin public {\r\n    require(_tid < tokenNum, \"setTokenActive wrong\");\r\n    tokenPool[_tid].active = _active;\r\n  }\r\n\r\n  // IMPORTANT: price needs to be in Wei per 1 unit of token\r\n  // admins may add new tokens into the pool\r\n  function addToken(address _tokenAddress, address _payAddress, uint256 _price, uint256 _buypercent, uint256 _potpercent, uint256 _lockperiod) isAdmin public {\r\n    tokenPool[tokenNum].token = ERC20Token(_tokenAddress);\r\n    tokenPool[tokenNum].addr = _tokenAddress;\r\n    tokenPool[tokenNum].decimals = tokenPool[tokenNum].token.decimals();\r\n    tokenPool[tokenNum].payaddr = _payAddress;\r\n    tokenPool[tokenNum].bought = 0;\r\n    tokenPool[tokenNum].safed = 0;\r\n    tokenPool[tokenNum].potted = 0;\r\n    tokenPool[tokenNum].price = _price;\r\n    tokenPool[tokenNum].buypercent = _buypercent;\r\n    tokenPool[tokenNum].potpercent = _potpercent;\r\n    tokenPool[tokenNum].lockperiod = _lockperiod;\r\n    tokenPool[tokenNum].tid = tokenNum;\r\n    tokenPool[tokenNum].active = true;\r\n    tokenInPool[_tokenAddress] = true;\r\n    tokenNum++;\r\n  }\r\n\r\n  function tokenBalance(uint256 _tid) public view returns (uint256 _balance) {\r\n    return tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted);\r\n  }\r\n\r\n  function tokenBuyable(uint256 _tid, uint256 _eth) public view returns (bool _buyable) {\r\n    if (!tokenPool[_tid].active) return false;\r\n    uint256 buyAmount = (_eth).mul(tokenPool[_tid].buypercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\r\n    uint256 potAmount = (_eth).mul(tokenPool[_tid].potpercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\r\n    return (tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted) > (buyAmount + potAmount));\r\n  }\r\n\r\n  // Handles the buying of Tokens\r\n  function buyToken(uint256 _tid, uint256 _pid) isGame isPaid public payable {\r\n    require(gamebook.getPlayerAddressById(_pid) != address(0x0), \"buyToken need valid player\");\r\n    require(_tid < tokenNum, \"buyToken need valid token\");\r\n    require(tokenPool[_tid].active, \"buyToken need active token\");\r\n\r\n    uint256 buyAmount = (msg.value).mul(tokenPool[_tid].buypercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\r\n    uint256 potAmount = (msg.value).mul(tokenPool[_tid].potpercent).div(100).mul(uint256(10)**tokenPool[_tid].decimals).div(tokenPool[_tid].price);\r\n    require(tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed).sub(tokenPool[_tid].potted) > (buyAmount + potAmount), \"buyToken need more balance\");\r\n\r\n    tokenPool[_tid].bought = tokenPool[_tid].bought.add(buyAmount);\r\n    tokenPool[_tid].safed = tokenPool[_tid].safed.add(buyAmount);\r\n    tokenPool[_tid].potted = tokenPool[_tid].potted.add(potAmount);\r\n\r\n    emit TokenBought(_tid, _pid, buyAmount);\r\n    emit TokenPotFunded(_tid, potAmount);\r\n\r\n    uint256 lockStartTime = WTAGameRun(msg.sender).getCurrentRoundStartTime();\r\n    tokenSafeLock(_tid, _pid, buyAmount, lockStartTime);\r\n\r\n    tokenPool[_tid].payaddr.transfer(msg.value);\r\n\r\n    emit TokenFundPaid(_tid, tokenPool[_tid].payaddr, msg.value);\r\n  }\r\n\r\n  // handling the Pot Winning\r\n  function winPot(uint256[] _tids) isGame public {\r\n    require(now > WTAGameRun(msg.sender).getCurrentRoundEndTime(), \"winPot need round end\");\r\n    uint256 lockStartTime = WTAGameRun(msg.sender).getCurrentRoundStartTime();\r\n    uint256 winnerId = WTAGameRun(msg.sender).getCurrentRoundWinner();\r\n    require(gamebook.getPlayerAddressById(winnerId) != address(0x0), \"winPot need valid player\");\r\n    for (uint256 i = 0; i< _tids.length; i++) {\r\n      uint256 tid = _tids[i];\r\n      if (tokenPool[tid].active) {\r\n        uint256 potAmount = tokenPool[tid].potted;\r\n        tokenPool[tid].potted = 0;\r\n        tokenPool[tid].safed = tokenPool[tid].safed.add(potAmount);\r\n\r\n        tokenSafeLock(tid, winnerId, potAmount, lockStartTime);\r\n\r\n        emit TokenPotWon(tid, winnerId, potAmount);\r\n      }\r\n    }\r\n  }\r\n\r\n  // lock the Tokens allocated to players with a timelock\r\n  function tokenSafeLock(uint256 _tid, uint256 _pid, uint256 _amount, uint256 _start) private {\r\n    uint256 lockTime = _start + tokenPool[_tid].lockperiod;\r\n    uint256 lockNum = playerSafes[_pid][_tid].locks;\r\n    uint256 withdrawNum = playerSafes[_pid][_tid].withdraws;\r\n\r\n    if (lockNum > 0 && lockNum > withdrawNum) {\r\n      if (playerSafes[_pid][_tid].lockTime[lockNum-1] == lockTime) {\r\n        playerSafes[_pid][_tid].lockValue[lockNum-1] = playerSafes[_pid][_tid].lockValue[lockNum-1].add(_amount);\r\n      } else {\r\n        playerSafes[_pid][_tid].lockTime[lockNum] = lockTime;\r\n        playerSafes[_pid][_tid].lockValue[lockNum] = _amount;\r\n        playerSafes[_pid][_tid].locks++;\r\n      }\r\n    } else {\r\n      playerSafes[_pid][_tid].lockTime[lockNum] = lockTime;\r\n      playerSafes[_pid][_tid].lockValue[lockNum] = _amount;\r\n      playerSafes[_pid][_tid].locks++;\r\n    }\r\n\r\n    emit TokenLocked(_tid, _pid, _amount, lockTime);\r\n  }\r\n\r\n  // show a player's allocated tokens\r\n  function showPlayerSafeByAddress(address _addr, uint256 _tid) public view returns (uint256 _locked, uint256 _unlocked, uint256 _withdrawable) {\r\n    uint256 pid = gamebook.getPlayerIdByAddress(_addr);\r\n    require(pid > 0, \"showPlayerSafeByAddress wrong\");\r\n    return showPlayerSafeById(pid, _tid);\r\n  }\r\n\r\n  function showPlayerSafeById(uint256 _pid, uint256 _tid) public view returns (uint256 _locked, uint256 _unlocked, uint256 _withdrawable) {\r\n    require(gamebook.getPlayerAddressById(_pid) != address(0x0), \"showPlayerSafeById need valid player\");\r\n    require(_tid < tokenNum, \"showPlayerSafeById need valid token\");\r\n    uint256 locked = 0;\r\n    uint256 unlocked = 0;\r\n    uint256 withdrawable = 0;\r\n    uint256 withdraws = playerSafes[_pid][_tid].withdraws;\r\n    uint256 locks = playerSafes[_pid][_tid].locks;\r\n    uint256 count = 0;\r\n    for (uint256 i = withdraws; i < locks; i++) {\r\n      if (playerSafes[_pid][_tid].lockTime[i] < now) {\r\n        unlocked = unlocked.add(playerSafes[_pid][_tid].lockValue[i]);\r\n        if (count < 50) withdrawable = withdrawable.add(playerSafes[_pid][_tid].lockValue[i]);\r\n      } else {\r\n        locked = locked.add(playerSafes[_pid][_tid].lockValue[i]);\r\n      }\r\n      count++;\r\n    }\r\n    return (locked, unlocked, withdrawable);\r\n  }\r\n\r\n  // player may withdraw tokens after the timelock period\r\n  function withdraw(uint256 _tid) public {\r\n    require(_tid < tokenNum, \"withdraw need valid token\");\r\n    uint256 pid = gamebook.getPlayerIdByAddress(msg.sender);\r\n    require(pid > 0, \"withdraw need valid player\");\r\n    uint256 withdrawable = 0;\r\n    uint256 i = playerSafes[pid][_tid].withdraws;\r\n    uint256 count = 0;\r\n    uint256 locks = playerSafes[pid][_tid].locks;\r\n    for (; (i < locks) && (count < 50); i++) {\r\n      if (playerSafes[pid][_tid].lockTime[i] < now) {\r\n        withdrawable = withdrawable.add(playerSafes[pid][_tid].lockValue[i]);\r\n        playerSafes[pid][_tid].withdraws = i + 1;\r\n      } else {\r\n        break;\r\n      }\r\n      count++;\r\n    }\r\n\r\n    assert((tokenPool[_tid].token.balanceOf(address(this)) >= withdrawable) && (tokenPool[_tid].safed >= withdrawable));\r\n    tokenPool[_tid].safed = tokenPool[_tid].safed.sub(withdrawable);\r\n    playerSafes[pid][_tid].withdrawn = playerSafes[pid][_tid].withdrawn.add(withdrawable);\r\n    require(tokenPool[_tid].token.transfer(msg.sender, withdrawable), \"withdraw transfer wrong\");\r\n\r\n    emit TokenWithdrawn(_tid, pid, withdrawable);\r\n  }\r\n\r\n  // Safety measures\r\n  function () public payable {\r\n    revert();\r\n  }\r\n\r\n  function emptyInactiveToken(uint256 _tid) isAdmin public {\r\n    require(_tid < tokenNum, \"emptyInactiveToken need valid token\");\r\n    require(tokenPool[_tid].active == false, \"emptyInactiveToken need token inactive\");\r\n    uint256 amount = tokenPool[_tid].token.balanceOf(address(this)).sub(tokenPool[_tid].safed);\r\n    tokenPool[_tid].potted = 0;\r\n    require(tokenPool[_tid].token.transfer(msg.sender, amount), \"emptyInactiveToken transfer wrong\");\r\n\r\n    emit InactiveTokenEmptied(_tid, msg.sender, amount);\r\n  }\r\n\r\n  function emptyWrongToken(address _addr) isAdmin public {\r\n    require(tokenInPool[_addr] == false, \"emptyWrongToken need wrong token\");\r\n    ERC20Token wrongToken = ERC20Token(_addr);\r\n    uint256 amount = wrongToken.balanceOf(address(this));\r\n    require(amount > 0, \"emptyWrongToken need more balance\");\r\n    require(wrongToken.transfer(msg.sender, amount), \"emptyWrongToken transfer wrong\");\r\n\r\n    emit WrongTokenEmptied(_addr, msg.sender, amount);\r\n  }\r\n\r\n  function emptyWrongEther() isAdmin public {\r\n    // require all tokens to be inactive before emptying ether\r\n    for (uint256 i=0; i < tokenNum; i++) {\r\n      require(tokenPool[i].active == false, \"emptyWrongEther need all tokens inactive\");\r\n    }\r\n    uint256 amount = address(this).balance;\r\n    require(amount > 0, \"emptyWrongEther need more balance\");\r\n    msg.sender.transfer(amount);\r\n\r\n    emit WrongEtherEmptied(msg.sender, amount);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"},{\"name\":\"_pid\",\"type\":\"uint256\"}],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"emptyInactiveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_payAddress\",\"type\":\"address\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_buypercent\",\"type\":\"uint256\"},{\"name\":\"_potpercent\",\"type\":\"uint256\"},{\"name\":\"_lockperiod\",\"type\":\"uint256\"}],\"name\":\"addToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"_balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"tokenBuyable\",\"outputs\":[{\"name\":\"_buyable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"showPlayerSafeByAddress\",\"outputs\":[{\"name\":\"_locked\",\"type\":\"uint256\"},{\"name\":\"_unlocked\",\"type\":\"uint256\"},{\"name\":\"_withdrawable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamebook\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerSafes\",\"outputs\":[{\"name\":\"locks\",\"type\":\"uint256\"},{\"name\":\"withdraws\",\"type\":\"uint256\"},{\"name\":\"withdrawn\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPool\",\"outputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"payaddr\",\"type\":\"address\"},{\"name\":\"bought\",\"type\":\"uint256\"},{\"name\":\"safed\",\"type\":\"uint256\"},{\"name\":\"potted\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"buypercent\",\"type\":\"uint256\"},{\"name\":\"potpercent\",\"type\":\"uint256\"},{\"name\":\"lockperiod\",\"type\":\"uint256\"},{\"name\":\"tid\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"emptyWrongToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"emptyWrongEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenInPool\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pid\",\"type\":\"uint256\"},{\"name\":\"_tid\",\"type\":\"uint256\"}],\"name\":\"showPlayerSafeById\",\"outputs\":[{\"name\":\"_locked\",\"type\":\"uint256\"},{\"name\":\"_unlocked\",\"type\":\"uint256\"},{\"name\":\"_withdrawable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tids\",\"type\":\"uint256[]\"}],\"name\":\"winPot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tid\",\"type\":\"uint256\"},{\"name\":\"_active\",\"type\":\"bool\"}],\"name\":\"setTokenActive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address[]\"},{\"name\":\"_payAddress\",\"type\":\"address[]\"},{\"name\":\"_price\",\"type\":\"uint256[]\"},{\"name\":\"_buypercent\",\"type\":\"uint256[]\"},{\"name\":\"_potpercent\",\"type\":\"uint256[]\"},{\"name\":\"_lockperiod\",\"type\":\"uint256[]\"},{\"name\":\"_gamebook\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_pid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenBought\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_pid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_locktime\",\"type\":\"uint256\"}],\"name\":\"TokenLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_paddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TokenFundPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenPotFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_pid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenPotWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_pid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"InactiveTokenEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WrongTokenEmptied\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WrongEtherEmptied\",\"type\":\"event\"}]","ContractName":"WTATokenPool","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000e0000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000001a00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000026000000000000000000000000000000000000000000000000000000000000002c00000000000000000000000001359bcedd3ed488709e5b6c22d2b2e6ba165fa3e0000000000000000000000000000000000000000000000000000000000000002000000000000000000000000a149bf8a64ef4a57ab368f789b490fd096769127000000000000000000000000414b597d3edb8cf24a56da088647efa649eee98800000000000000000000000000000000000000000000000000000000000000020000000000000000000000002c658d63c91fef643ba252c67c69e11d5cdfd7950000000000000000000000006963264f00dd9c726dc84a3d9ba4985a9d3c82220000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000106bc1dc860000000000000000000000000000000000000000000000000000000f2869e936800000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000c800000000000000000000000000000000000000000000000000000000000000c80000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000002800000000000000000000000000000000000000000000000000000000000000280000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000076a700000000000000000000000000000000000000000000000000000000000076a700","Library":"","SwarmSource":"bzzr://6049cc047bdaaca7cc6154f5ebc4dcee4a20689de41d2e03ae5b80a4fde65232"}]}