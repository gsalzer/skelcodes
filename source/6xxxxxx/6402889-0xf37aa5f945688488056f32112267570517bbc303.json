{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n    function multiplication(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function division(uint a, uint b) internal pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function subtraction(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function addition(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract LottoEvents {\r\n    event BuyTicket(uint indexed _gameIndex, address indexed from, bytes numbers, uint _prizePool, uint _bonusPool);\r\n    event LockRound(uint indexed _gameIndex, uint _state, uint indexed _blockIndex);\r\n    event DrawRound(uint indexed _gameIndex, uint _state, uint indexed _blockIndex, string _blockHash, uint[] _winNumbers);\r\n    event EndRound(uint indexed _gameIndex, uint _state, uint _jackpot, uint _bonusAvg, address[] _jackpotWinners, address[] _goldKeyWinners, bool _autoStartNext);\r\n    event NewRound(uint indexed _gameIndex, uint _state, uint _initPrizeIn);\r\n    event DumpPrize(uint indexed _gameIndex, uint _jackpot);\r\n    event Transfer(uint indexed _gameIndex, uint value);\r\n    event Activated(uint indexed _gameIndex);\r\n    event Deactivated(uint indexed _gameIndex);\r\n    event SelfDestroy(uint indexed _gameIndex);\r\n}\r\n\r\nlibrary LottoModels {\r\n\r\n    // data struct hold each ticket info\r\n    struct Ticket {\r\n        uint rId;           // round identity\r\n        address player;     // the buyer\r\n        uint btime;         // buy time\r\n        uint[] numbers;     // buy numbers, idx 0,1,2,3,4 are red balls, idx 5 are blue balls\r\n        bool joinBonus;     // join bonus ?\r\n        bool useGoldKey;    // use gold key ?\r\n    }\r\n\r\n    // if round ended, each state is freeze, just for view\r\n    struct Round {\r\n        uint rId;            // current id\r\n        uint stime;          // start time\r\n        uint etime;          // end time\r\n        uint8 state;         // 0: live, 1: locked, 2: drawed, 7: ended\r\n\r\n        uint[] winNumbers;   // idx 0,1,2,3,4 are red balls, idx 5 are blue balls\r\n        address[] winners;   // the winner's addresses\r\n\r\n        uint ethIn;          // how much eth in this Round\r\n        uint prizePool;      // how much eth in prize pool, 40% of ethIn add init prize in\r\n        uint bonusPool;      // how much eth in bonus pool, 40% of ethIn\r\n        uint teamFee;        // how much eth to team, 20% of ethIn\r\n\r\n        uint btcBlockNoWhenLock; // the btc block no when lock this round\r\n        uint btcBlockNo;         // use for get win numbers, must higer than btcBlockNoWhenLock;\r\n        string btcBlockHash;     // use for get win numbers\r\n\r\n        uint bonusAvg;       // average bouns price for players\r\n        uint jackpot;        // the jackpot to pay\r\n        uint genGoldKeys;    // how many gold key gens\r\n    }\r\n}\r\n\r\ncontract Lottery is Owned, SafeMath, LottoEvents {\r\n    string constant version = \"1.0.1\";\r\n\r\n    uint constant private GOLD_KEY_CAP = 1500 ether;\r\n    uint constant private BUY_LIMIT_CAP = 100;\r\n    uint8 constant private ROUND_STATE_LIVE = 0;\r\n    uint8 constant private ROUND_STATE_LOCKED = 1;\r\n    uint8 constant private ROUND_STATE_DRAWED = 2;\r\n    uint8 constant private ROUND_STATE_ENDED = 7;\r\n\r\n    mapping (uint => LottoModels.Round) public rounds;       // all rounds, rid -> round\r\n    mapping (uint => LottoModels.Ticket[]) public tickets;   // all tickets, rid -> ticket array\r\n    mapping (address => uint) public goldKeyRepo;            // all gold key repo, keeper address -> key count\r\n    address[] private goldKeyKeepers;                           // all gold key keepers, just for clear mapping?!\r\n\r\n    uint public goldKeyCounter = 0;               // count for gold keys\r\n    uint public unIssuedGoldKeys = 0;             // un issued gold keys\r\n    uint public price = 0.01 ether;               // the price for each bet\r\n    bool public activated = false;                // contract live?\r\n    uint public rId;                              // current round id\r\n\r\n    constructor() public {\r\n        rId = 0;\r\n        activated = true;\r\n        internalNewRound(0, 0); // init with prize 0, bonus 0\r\n    }\r\n\r\n    // buy ticket\r\n    // WARNING!!!solidity only allow 16 local variables\r\n    function()\r\n        isHuman()\r\n        isActivated()\r\n        public\r\n        payable {\r\n\r\n        require(owner != msg.sender, \"owner cannot buy.\");\r\n        require(address(this) != msg.sender, \"contract cannot buy.\");\r\n        require(rounds[rId].state == ROUND_STATE_LIVE,  \"this round not start yet, please wait.\");\r\n        // data format check\r\n        require(msg.data.length > 9,  \"data struct not valid\");\r\n        require(msg.data.length % 9 == 1, \"data struct not valid\");\r\n        // price check\r\n        require(uint(msg.data[0]) < BUY_LIMIT_CAP, \"out of buy limit one time.\");\r\n        require(msg.value == uint(msg.data[0]) * price, \"price not right, please check.\");\r\n\r\n\r\n        uint i = 1;\r\n        while(i < msg.data.length) {\r\n            // fill data\r\n            // [0]: how many\r\n            // [1]: how many gold key use?\r\n            // [2]: join bonus?\r\n            // [3-7]: red balls, [8]: blue ball\r\n            uint _times = uint(msg.data[i++]);\r\n            uint _goldKeys = uint(msg.data[i++]);\r\n            bool _joinBonus = uint(msg.data[i++]) > 0;\r\n            uint[] memory _numbers = new uint[](6);\r\n            for(uint j = 0; j < 6; j++) {\r\n                _numbers[j] = uint(msg.data[i++]);\r\n            }\r\n\r\n            // every ticket\r\n            for (uint k = 0; k < _times; k++) {\r\n                bool _useGoldKey = false;\r\n                if (_goldKeys > 0 && goldKeyRepo[msg.sender] > 0) { // can use gold key?\r\n                    _goldKeys--; // reduce you keys you want\r\n                    goldKeyRepo[msg.sender]--; // reduce you keys in repo\r\n                    _useGoldKey = true;\r\n                }\r\n                tickets[rId].push(LottoModels.Ticket(rId, msg.sender,  now, _numbers, _joinBonus, _useGoldKey));\r\n            }\r\n        }\r\n\r\n        // update round data\r\n        rounds[rId].ethIn = addition(rounds[rId].ethIn, msg.value);\r\n        uint _amount = msg.value * 4 / 10;\r\n        rounds[rId].prizePool = addition(rounds[rId].prizePool, _amount); // 40% for prize\r\n        rounds[rId].bonusPool = addition(rounds[rId].bonusPool, _amount); // 40% for bonus\r\n        rounds[rId].teamFee = addition(rounds[rId].teamFee, division(_amount, 2));   // 20% for team\r\n        // check gen gold key?\r\n        internalIncreaseGoldKeyCounter(_amount);\r\n\r\n        emit BuyTicket(rId, msg.sender, msg.data, rounds[rId].prizePool, rounds[rId].bonusPool);\r\n    }\r\n\r\n\r\n    // core logic\r\n    //\r\n    // 1. lock the round, can't buy this round\r\n    // 2. on-chain calc win numbuers\r\n    // 3. off-chain calc jackpot, jackpot winners, goldkey winners, average bonus, blue number hits not share bonus.\r\n    // if compute on-chain, out of gas\r\n    // 4. end this round\r\n\r\n    // 1. lock the round, can't buy this round\r\n    function lockRound(uint btcBlockNo)\r\n    isActivated()\r\n    onlyOwner()\r\n    public {\r\n        require(rounds[rId].state == ROUND_STATE_LIVE, \"this round not live yet, no need lock\");\r\n        rounds[rId].btcBlockNoWhenLock = btcBlockNo;\r\n        rounds[rId].state = ROUND_STATE_LOCKED;\r\n        emit LockRound(rId, ROUND_STATE_LOCKED, btcBlockNo);\r\n    }\r\n\r\n    // 2. on-chain calc win numbuers\r\n    function drawRound(\r\n        uint  btcBlockNo,\r\n        string  btcBlockHash\r\n    )\r\n    isActivated()\r\n    onlyOwner()\r\n    public {\r\n        require(rounds[rId].state == ROUND_STATE_LOCKED, \"this round not locked yet, please lock it first\");\r\n        require(rounds[rId].btcBlockNoWhenLock < btcBlockNo,  \"the btc block no should higher than the btc block no when lock this round\");\r\n\r\n        // calculate winner\r\n        rounds[rId].winNumbers = calcWinNumbers(btcBlockHash);\r\n        rounds[rId].btcBlockHash = btcBlockHash;\r\n        rounds[rId].btcBlockNo = btcBlockNo;\r\n        rounds[rId].state = ROUND_STATE_DRAWED;\r\n\r\n        emit DrawRound(rId, ROUND_STATE_DRAWED, btcBlockNo, btcBlockHash, rounds[rId].winNumbers);\r\n    }\r\n\r\n    // 3. off-chain calc\r\n    // 4. end this round\r\n    function endRound(\r\n        uint jackpot,\r\n        uint bonusAvg,\r\n        address[] jackpotWinners,\r\n        address[] goldKeyWinners,\r\n        bool autoStartNext\r\n    )\r\n    isActivated()\r\n    onlyOwner()\r\n    public {\r\n        require(rounds[rId].state == ROUND_STATE_DRAWED, \"this round not drawed yet, please draw it first\");\r\n\r\n        // end this round\r\n        rounds[rId].state = ROUND_STATE_ENDED;\r\n        rounds[rId].etime = now;\r\n        rounds[rId].jackpot = jackpot;\r\n        rounds[rId].bonusAvg = bonusAvg;\r\n        rounds[rId].winners = jackpotWinners;\r\n\r\n        // if jackpot is this contract addr or owner addr, delete it\r\n\r\n        // if have winners, all keys will gone.\r\n        if (jackpotWinners.length > 0 && jackpot > 0) {\r\n            unIssuedGoldKeys = 0; // clear un issued gold keys\r\n            // clear players gold key\r\n            // no direct delete mapping in solidity\r\n            // we give an array to store gold key keepers\r\n            // clearing mapping from key keepers\r\n            // delete keepers\r\n            for (uint i = 0; i < goldKeyKeepers.length; i++) {\r\n                goldKeyRepo[goldKeyKeepers[i]] = 0;\r\n            }\r\n            delete goldKeyKeepers;\r\n        } else {\r\n            // else reward gold keys\r\n            if (unIssuedGoldKeys > 0) {\r\n                for (uint k = 0; k < goldKeyWinners.length; k++) {\r\n                    // update repo\r\n                    address _winner = goldKeyWinners[k];\r\n\r\n                    // except this address\r\n                    if (_winner == address(this)) {\r\n                        continue;\r\n                    }\r\n\r\n                    goldKeyRepo[_winner]++;\r\n\r\n                    // update keepers\r\n                    bool _hasKeeper = false;\r\n                    for (uint j = 0; j < goldKeyKeepers.length; j++) {\r\n                        if (goldKeyKeepers[j] == _winner) {\r\n                            _hasKeeper = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (!_hasKeeper) { // no keeper? push it in.\r\n                        goldKeyKeepers.push(_winner);\r\n                    }\r\n\r\n                    unIssuedGoldKeys--;\r\n                    if (unIssuedGoldKeys <= 0) { // no more gold keys, let's break;\r\n                        break;\r\n                    }\r\n\r\n                }\r\n            }\r\n            // move this round gen gold key to un issued gold keys\r\n            unIssuedGoldKeys = addition(unIssuedGoldKeys, rounds[rId].genGoldKeys);\r\n        }\r\n\r\n        emit EndRound(rId, ROUND_STATE_ENDED, jackpot, bonusAvg, jackpotWinners, goldKeyWinners, autoStartNext);\r\n        // round ended\r\n\r\n        // start next?\r\n        if (autoStartNext) {\r\n            newRound();\r\n        }\r\n    }\r\n\r\n    function newRound()\r\n    isActivated()\r\n    onlyOwner()\r\n    public {\r\n        // check this round is ended?\r\n        require(rounds[rId].state == ROUND_STATE_ENDED, \"this round not ended yet, please end it first\");\r\n\r\n        // lets start next round\r\n        // calculate prize to move, (prize pool - jackpot to pay)\r\n        uint _initPrizeIn = subtraction(rounds[rId].prizePool, rounds[rId].jackpot);\r\n        // move bonus pool, if no one share bonus(maybe)\r\n        uint _initBonusIn = rounds[rId].bonusPool;\r\n        if (rounds[rId].bonusAvg > 0) { // if someone share bonus, bonusAvg > 0, move 0\r\n            _initBonusIn = 0;\r\n        }\r\n        // move to new round\r\n        internalNewRound(_initPrizeIn, _initBonusIn);\r\n\r\n        emit NewRound(rId, ROUND_STATE_LIVE, _initPrizeIn);\r\n    }\r\n\r\n    function internalNewRound(uint _initPrizeIn, uint _initBonusIn) internal {\r\n        rId++;\r\n        rounds[rId].rId = rId;\r\n        rounds[rId].stime = now;\r\n        rounds[rId].state = ROUND_STATE_LIVE;\r\n        rounds[rId].prizePool = _initPrizeIn;\r\n        rounds[rId].bonusPool = _initBonusIn;\r\n    }\r\n    \r\n    function internalIncreaseGoldKeyCounter(uint _amount) internal {\r\n        goldKeyCounter = addition(goldKeyCounter, _amount);\r\n        if (goldKeyCounter >= GOLD_KEY_CAP) {\r\n            rounds[rId].genGoldKeys = addition(rounds[rId].genGoldKeys, 1);\r\n            goldKeyCounter = subtraction(goldKeyCounter, GOLD_KEY_CAP);\r\n        }\r\n    }\r\n\r\n    // utils\r\n    function calcWinNumbers(string blockHash)\r\n    public\r\n    pure\r\n    returns (uint[]) {\r\n        bytes32 random = keccak256(bytes(blockHash));\r\n        uint[] memory allRedNumbers = new uint[](40);\r\n        uint[] memory allBlueNumbers = new uint[](10);\r\n        uint[] memory winNumbers = new uint[](6);\r\n        for (uint i = 0; i < 40; i++) {\r\n            allRedNumbers[i] = i + 1;\r\n            if(i < 10) {\r\n                allBlueNumbers[i] = i;\r\n            }\r\n        }\r\n        for (i = 0; i < 5; i++) {\r\n            uint n = 40 - i;\r\n            uint r = (uint(random[i * 4]) + (uint(random[i * 4 + 1]) << 8) + (uint(random[i * 4 + 2]) << 16) + (uint(random[i * 4 + 3]) << 24)) % (n + 1);\r\n            winNumbers[i] = allRedNumbers[r];\r\n            allRedNumbers[r] = allRedNumbers[n - 1];\r\n        }\r\n        uint t = (uint(random[i * 4]) + (uint(random[i * 4 + 1]) << 8) + (uint(random[i * 4 + 2]) << 16) + (uint(random[i * 4 + 3]) << 24)) % 10;\r\n        winNumbers[5] = allBlueNumbers[t];\r\n        return winNumbers;\r\n    }\r\n\r\n    // for views\r\n    function getKeys() public view returns(uint) {\r\n        return goldKeyRepo[msg.sender];\r\n    }\r\n    \r\n    function getRoundByRId(uint _rId)\r\n    public\r\n    view\r\n    returns (uint[] res){\r\n        if(_rId > rId) return res;\r\n        res = new uint[](18);\r\n        uint k;\r\n        res[k++] = _rId;\r\n        res[k++] = uint(rounds[_rId].state);\r\n        res[k++] = rounds[_rId].ethIn;\r\n        res[k++] = rounds[_rId].prizePool;\r\n        res[k++] = rounds[_rId].bonusPool;\r\n        res[k++] = rounds[_rId].teamFee;\r\n        if (rounds[_rId].winNumbers.length == 0) {\r\n            for (uint j = 0; j < 6; j++)\r\n                res[k++] = 0;\r\n        } else {\r\n            for (j = 0; j < 6; j++)\r\n                res[k++] = rounds[_rId].winNumbers[j];\r\n        }\r\n        res[k++] = rounds[_rId].bonusAvg;\r\n        res[k++] = rounds[_rId].jackpot;\r\n        res[k++] = rounds[_rId].genGoldKeys;\r\n        res[k++] = rounds[_rId].btcBlockNo;\r\n        res[k++] = rounds[_rId].stime;\r\n        res[k++] = rounds[_rId].etime;\r\n    }\r\n\r\n    // --- danger ops ---\r\n\r\n    // angel send luck for players\r\n    function dumpPrize()\r\n    isActivated()\r\n    onlyOwner()\r\n    public\r\n    payable {\r\n        require(rounds[rId].state == ROUND_STATE_LIVE, \"this round not live yet.\");\r\n        rounds[rId].ethIn = addition(rounds[rId].ethIn, msg.value);\r\n        rounds[rId].prizePool = addition(rounds[rId].prizePool, msg.value);\r\n        // check gen gold key?\r\n        internalIncreaseGoldKeyCounter(msg.value);\r\n        emit DumpPrize(rId, msg.value);\r\n    }\r\n\r\n    function activate() public onlyOwner {\r\n        activated = true;\r\n        emit Activated(rId);\r\n    }\r\n\r\n    function deactivate() public onlyOwner {\r\n        activated = false;\r\n        emit Deactivated(rId);\r\n    }\r\n\r\n    function selfDestroy() public onlyOwner {\r\n        selfdestruct(msg.sender);\r\n        emit SelfDestroy(rId);\r\n    }\r\n\r\n    function transferToOwner(uint amount) public payable onlyOwner {\r\n        msg.sender.transfer(amount);\r\n        emit Transfer(rId, amount);\r\n    }\r\n    // --- danger ops end ---\r\n\r\n    // modifiers\r\n    modifier isActivated() {\r\n        require(activated == true, \"its not ready yet.\");\r\n        _;\r\n    }\r\n\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        require (_addr == tx.origin);\r\n\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getRoundByRId\",\"outputs\":[{\"name\":\"res\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deactivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferToOwner\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"btcBlockNo\",\"type\":\"uint256\"}],\"name\":\"lockRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"rId\",\"type\":\"uint256\"},{\"name\":\"stime\",\"type\":\"uint256\"},{\"name\":\"etime\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"ethIn\",\"type\":\"uint256\"},{\"name\":\"prizePool\",\"type\":\"uint256\"},{\"name\":\"bonusPool\",\"type\":\"uint256\"},{\"name\":\"teamFee\",\"type\":\"uint256\"},{\"name\":\"btcBlockNoWhenLock\",\"type\":\"uint256\"},{\"name\":\"btcBlockNo\",\"type\":\"uint256\"},{\"name\":\"btcBlockHash\",\"type\":\"string\"},{\"name\":\"bonusAvg\",\"type\":\"uint256\"},{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"genGoldKeys\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tickets\",\"outputs\":[{\"name\":\"rId\",\"type\":\"uint256\"},{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"btime\",\"type\":\"uint256\"},{\"name\":\"joinBonus\",\"type\":\"bool\"},{\"name\":\"useGoldKey\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"goldKeyRepo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"bonusAvg\",\"type\":\"uint256\"},{\"name\":\"jackpotWinners\",\"type\":\"address[]\"},{\"name\":\"goldKeyWinners\",\"type\":\"address[]\"},{\"name\":\"autoStartNext\",\"type\":\"bool\"}],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goldKeyCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"selfDestroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"dumpPrize\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"newRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unIssuedGoldKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockHash\",\"type\":\"string\"}],\"name\":\"calcWinNumbers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"btcBlockNo\",\"type\":\"uint256\"},{\"name\":\"btcBlockHash\",\"type\":\"string\"}],\"name\":\"drawRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numbers\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"_prizePool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bonusPool\",\"type\":\"uint256\"}],\"name\":\"BuyTicket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_state\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_blockIndex\",\"type\":\"uint256\"}],\"name\":\"LockRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_state\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_blockIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_blockHash\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_winNumbers\",\"type\":\"uint256[]\"}],\"name\":\"DrawRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_state\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_jackpot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bonusAvg\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_jackpotWinners\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_goldKeyWinners\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"_autoStartNext\",\"type\":\"bool\"}],\"name\":\"EndRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_state\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_initPrizeIn\",\"type\":\"uint256\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_jackpot\",\"type\":\"uint256\"}],\"name\":\"DumpPrize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"}],\"name\":\"Activated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"}],\"name\":\"Deactivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_gameIndex\",\"type\":\"uint256\"}],\"name\":\"SelfDestroy\",\"type\":\"event\"}]","ContractName":"Lottery","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://959c0480c3b699fb97291f37ffe0fb648a6618d7752fc73dcc73f0fb797a1c7d"}]}