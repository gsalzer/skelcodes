{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\ncontract Governable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    address public governor;\r\n    bool public paused = false;\r\n\r\n    constructor() public {\r\n        governor = msg.sender;\r\n    }\r\n\r\n    function setGovernor(address _gov) public onlyGovernor {\r\n        governor = _gov;\r\n    }\r\n\r\n    modifier onlyGovernor {\r\n        require(msg.sender == governor);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyGovernor whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyGovernor whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n\r\n}\r\n\r\ncontract CardBase is Governable {\r\n\r\n\r\n    struct Card {\r\n        uint16 proto;\r\n        uint16 purity;\r\n    }\r\n\r\n    function getCard(uint id) public view returns (uint16 proto, uint16 purity) {\r\n        Card memory card = cards[id];\r\n        return (card.proto, card.purity);\r\n    }\r\n\r\n    function getShine(uint16 purity) public pure returns (uint8) {\r\n        return uint8(purity / 1000);\r\n    }\r\n\r\n    Card[] public cards;\r\n    \r\n}\r\n\r\ncontract CardProto is CardBase {\r\n\r\n    event NewProtoCard(\r\n        uint16 id, uint8 season, uint8 god, \r\n        Rarity rarity, uint8 mana, uint8 attack, \r\n        uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    );\r\n\r\n    struct Limit {\r\n        uint64 limit;\r\n        bool exists;\r\n    }\r\n\r\n    // limits for mythic cards\r\n    mapping(uint16 => Limit) public limits;\r\n\r\n    // can only set limits once\r\n    function setLimit(uint16 id, uint64 limit) public onlyGovernor {\r\n        Limit memory l = limits[id];\r\n        require(!l.exists);\r\n        limits[id] = Limit({\r\n            limit: limit,\r\n            exists: true\r\n        });\r\n    }\r\n\r\n    function getLimit(uint16 id) public view returns (uint64 limit, bool set) {\r\n        Limit memory l = limits[id];\r\n        return (l.limit, l.exists);\r\n    }\r\n\r\n    // could make these arrays to save gas\r\n    // not really necessary - will be update a very limited no of times\r\n    mapping(uint8 => bool) public seasonTradable;\r\n    mapping(uint8 => bool) public seasonTradabilityLocked;\r\n    uint8 public currentSeason;\r\n\r\n    function makeTradable(uint8 season) public onlyGovernor {\r\n        seasonTradable[season] = true;\r\n    }\r\n\r\n    function makeUntradable(uint8 season) public onlyGovernor {\r\n        require(!seasonTradabilityLocked[season]);\r\n        seasonTradable[season] = false;\r\n    }\r\n\r\n    function makePermanantlyTradable(uint8 season) public onlyGovernor {\r\n        require(seasonTradable[season]);\r\n        seasonTradabilityLocked[season] = true;\r\n    }\r\n\r\n    function isTradable(uint16 proto) public view returns (bool) {\r\n        return seasonTradable[protos[proto].season];\r\n    }\r\n\r\n    function nextSeason() public onlyGovernor {\r\n        //Seasons shouldn't go to 0 if there is more than the uint8 should hold, the governor should know this ¯\\_(ツ)_/¯ -M\r\n        require(currentSeason <= 255); \r\n\r\n        currentSeason++;\r\n        mythic.length = 0;\r\n        legendary.length = 0;\r\n        epic.length = 0;\r\n        rare.length = 0;\r\n        common.length = 0;\r\n    }\r\n\r\n    enum Rarity {\r\n        Common,\r\n        Rare,\r\n        Epic,\r\n        Legendary, \r\n        Mythic\r\n    }\r\n\r\n    uint8 constant SPELL = 1;\r\n    uint8 constant MINION = 2;\r\n    uint8 constant WEAPON = 3;\r\n    uint8 constant HERO = 4;\r\n\r\n    struct ProtoCard {\r\n        bool exists;\r\n        uint8 god;\r\n        uint8 season;\r\n        uint8 cardType;\r\n        Rarity rarity;\r\n        uint8 mana;\r\n        uint8 attack;\r\n        uint8 health;\r\n        uint8 tribe;\r\n    }\r\n\r\n    // there is a particular design decision driving this:\r\n    // need to be able to iterate over mythics only for card generation\r\n    // don't store 5 different arrays: have to use 2 ids\r\n    // better to bear this cost (2 bytes per proto card)\r\n    // rather than 1 byte per instance\r\n\r\n    uint16 public protoCount;\r\n    \r\n    mapping(uint16 => ProtoCard) protos;\r\n\r\n    uint16[] public mythic;\r\n    uint16[] public legendary;\r\n    uint16[] public epic;\r\n    uint16[] public rare;\r\n    uint16[] public common;\r\n\r\n    function addProtos(\r\n        uint16[] externalIDs, uint8[] gods, Rarity[] rarities, uint8[] manas, uint8[] attacks, \r\n        uint8[] healths, uint8[] cardTypes, uint8[] tribes, bool[] packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        for (uint i = 0; i < externalIDs.length; i++) {\r\n\r\n            ProtoCard memory card = ProtoCard({\r\n                exists: true,\r\n                god: gods[i],\r\n                season: currentSeason,\r\n                cardType: cardTypes[i],\r\n                rarity: rarities[i],\r\n                mana: manas[i],\r\n                attack: attacks[i],\r\n                health: healths[i],\r\n                tribe: tribes[i]\r\n            });\r\n\r\n            _addProto(externalIDs[i], card, packable[i]);\r\n        }\r\n        \r\n    }\r\n\r\n    function addProto(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 cardType, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: cardType,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addWeapon(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 durability, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: WEAPON,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: durability,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addSpell(uint16 externalID, uint8 god, Rarity rarity, uint8 mana, bool packable) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: SPELL,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: 0,\r\n            health: 0,\r\n            tribe: 0\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function addMinion(\r\n        uint16 externalID, uint8 god, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe, bool packable\r\n    ) public onlyGovernor returns(uint16) {\r\n\r\n        ProtoCard memory card = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: currentSeason,\r\n            cardType: MINION,\r\n            rarity: rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n\r\n        _addProto(externalID, card, packable);\r\n    }\r\n\r\n    function _addProto(uint16 externalID, ProtoCard memory card, bool packable) internal {\r\n\r\n        require(!protos[externalID].exists);\r\n\r\n        card.exists = true;\r\n\r\n        protos[externalID] = card;\r\n\r\n        protoCount++;\r\n\r\n        emit NewProtoCard(\r\n            externalID, currentSeason, card.god, \r\n            card.rarity, card.mana, card.attack, \r\n            card.health, card.cardType, card.tribe, packable\r\n        );\r\n\r\n        if (packable) {\r\n            Rarity rarity = card.rarity;\r\n            if (rarity == Rarity.Common) {\r\n                common.push(externalID);\r\n            } else if (rarity == Rarity.Rare) {\r\n                rare.push(externalID);\r\n            } else if (rarity == Rarity.Epic) {\r\n                epic.push(externalID);\r\n            } else if (rarity == Rarity.Legendary) {\r\n                legendary.push(externalID);\r\n            } else if (rarity == Rarity.Mythic) {\r\n                mythic.push(externalID);\r\n            } else {\r\n                require(false);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getProto(uint16 id) public view returns(\r\n        bool exists, uint8 god, uint8 season, uint8 cardType, Rarity rarity, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) {\r\n        ProtoCard memory proto = protos[id];\r\n        return (\r\n            proto.exists,\r\n            proto.god,\r\n            proto.season,\r\n            proto.cardType,\r\n            proto.rarity,\r\n            proto.mana,\r\n            proto.attack,\r\n            proto.health,\r\n            proto.tribe\r\n        );\r\n    }\r\n\r\n    function getRandomCard(Rarity rarity, uint16 random) public view returns (uint16) {\r\n        // modulo bias is fine - creates rarity tiers etc\r\n        // will obviously revert is there are no cards of that type: this is expected - should never happen\r\n        if (rarity == Rarity.Common) {\r\n            return common[random % common.length];\r\n        } else if (rarity == Rarity.Rare) {\r\n            return rare[random % rare.length];\r\n        } else if (rarity == Rarity.Epic) {\r\n            return epic[random % epic.length];\r\n        } else if (rarity == Rarity.Legendary) {\r\n            return legendary[random % legendary.length];\r\n        } else if (rarity == Rarity.Mythic) {\r\n            // make sure a mythic is available\r\n            uint16 id;\r\n            uint64 limit;\r\n            bool set;\r\n            for (uint i = 0; i < mythic.length; i++) {\r\n                id = mythic[(random + i) % mythic.length];\r\n                (limit, set) = getLimit(id);\r\n                if (set && limit > 0){\r\n                    return id;\r\n                }\r\n            }\r\n            // if not, they get a legendary :(\r\n            return legendary[random % legendary.length];\r\n        }\r\n        require(false);\r\n        return 0;\r\n    }\r\n\r\n    // can never adjust tradable cards\r\n    // each season gets a 'balancing beta'\r\n    // totally immutable: season, rarity\r\n    function replaceProto(\r\n        uint16 index, uint8 god, uint8 cardType, uint8 mana, uint8 attack, uint8 health, uint8 tribe\r\n    ) public onlyGovernor {\r\n        ProtoCard memory pc = protos[index];\r\n        require(!seasonTradable[pc.season]);\r\n        protos[index] = ProtoCard({\r\n            exists: true,\r\n            god: god,\r\n            season: pc.season,\r\n            cardType: cardType,\r\n            rarity: pc.rarity,\r\n            mana: mana,\r\n            attack: attack,\r\n            health: health,\r\n            tribe: tribe\r\n        });\r\n    }\r\n\r\n}\r\n\r\ncontract MigrationInterface {\r\n\r\n    function createCard(address user, uint16 proto, uint16 purity) public returns (uint);\r\n\r\n    function getRandomCard(CardProto.Rarity rarity, uint16 random) public view returns (uint16);\r\n\r\n    function migrate(uint id) public;\r\n\r\n}\r\n\r\ncontract CardPackFour {\r\n\r\n    MigrationInterface public migration;\r\n    uint public creationBlock;\r\n\r\n    constructor(MigrationInterface _core) public payable {\r\n        migration = _core;\r\n        creationBlock = 5939061 + 2000; // set to creation block of first contracts + 8 hours for down time\r\n    }\r\n\r\n    event Referral(address indexed referrer, uint value, address purchaser);\r\n\r\n    /**\r\n    * purchase 'count' of this type of pack\r\n    */\r\n    function purchase(uint16 packCount, address referrer) public payable;\r\n\r\n    // store purity and shine as one number to save users gas\r\n    function _getPurity(uint16 randOne, uint16 randTwo) internal pure returns (uint16) {\r\n        if (randOne >= 998) {\r\n            return 3000 + randTwo;\r\n        } else if (randOne >= 988) {\r\n            return 2000 + randTwo;\r\n        } else if (randOne >= 938) {\r\n            return 1000 + randTwo;\r\n        } else {\r\n            return randTwo;\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address _owner) public onlyOwner {\r\n        owner = _owner;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    \r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to pause, triggers stopped state\r\n    */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n    * @dev called by the owner to unpause, returns to normal state\r\n    */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary SafeMath64 {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint64 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint64 a, uint64 b) internal pure returns (uint64 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract AuctionPack is CardPackFour, Pausable {\r\n\r\n    using SafeMath for uint;\r\n    // probably a better way to do this/don't need to do it at all\r\n    using SafeMath64 for uint64;\r\n\r\n    mapping(address => uint) owed;\r\n\r\n    event Created(uint indexed id, uint16 proto, uint16 purity, uint minBid, uint length);\r\n    event Opened(uint indexed id, uint64 start);\r\n    event Extended(uint indexed id, uint64 length);\r\n    event Bid(uint indexed id, address indexed bidder, uint value);\r\n    event Claimed(uint indexed id, uint indexed cardID, address indexed bidder, uint value, uint16 proto, uint16 purity);\r\n    event Bonus(uint indexed id, uint indexed cardID, address indexed bidder, uint16 proto, uint16 purity);\r\n\r\n    enum Status {\r\n        Closed,\r\n        Open,\r\n        Claimed\r\n    }\r\n\r\n    struct Auction {\r\n        Status status;\r\n        uint16 proto;\r\n        uint16 purity;\r\n        uint highestBid;\r\n        address highestBidder;\r\n        uint64 start;\r\n        uint64 length;\r\n        address beneficiary;\r\n        uint16 bonusProto;\r\n        uint16 bonusPurity;\r\n        uint64 bufferPeriod;\r\n        uint minIncreasePercent;\r\n    }\r\n\r\n    Auction[] auctions;\r\n\r\n    constructor(MigrationInterface _migration) public CardPackFour(_migration) {\r\n        \r\n    }\r\n\r\n    function getAuction(uint id) public view returns (\r\n        Status status,\r\n        uint16 proto,\r\n        uint16 purity,\r\n        uint highestBid,\r\n        address highestBidder,\r\n        uint64 start,\r\n        uint64 length,\r\n        uint16 bonusProto,\r\n        uint16 bonusPurity,\r\n        uint64 bufferPeriod,\r\n        uint minIncreasePercent,\r\n        address beneficiary\r\n    ) {\r\n        require(auctions.length > id);\r\n        Auction memory a = auctions[id];\r\n        return (\r\n            a.status, a.proto, a.purity, a.highestBid, \r\n            a.highestBidder, a.start, a.length, a.bonusProto, \r\n            a.bonusPurity, a.bufferPeriod, a.minIncreasePercent, a.beneficiary\r\n        );\r\n    }\r\n\r\n    function createAuction(\r\n        address beneficiary, uint16 proto, uint16 purity, \r\n        uint minBid, uint64 length, uint16 bonusProto, uint16 bonusPurity,\r\n        uint64 bufferPeriod, uint minIncrease\r\n    ) public onlyOwner whenNotPaused returns (uint) {\r\n\r\n        require(beneficiary != address(0));\r\n        require(minBid >= 100 wei);\r\n\r\n        Auction memory auction = Auction({\r\n            status: Status.Closed,\r\n            proto: proto,\r\n            purity: purity,\r\n            highestBid: minBid,\r\n            highestBidder: address(0),\r\n            start: 0,\r\n            length: length,\r\n            beneficiary: beneficiary,\r\n            bonusProto: bonusProto,\r\n            bonusPurity: bonusPurity,\r\n            bufferPeriod: bufferPeriod,\r\n            minIncreasePercent: minIncrease\r\n        });\r\n\r\n        uint id = auctions.push(auction) - 1;\r\n\r\n        emit Created(id, proto, purity, minBid, length);\r\n\r\n        return id;\r\n    }\r\n\r\n    function openAuction(uint id) public onlyOwner {\r\n        Auction storage auction = auctions[id];\r\n        require(auction.status == Status.Closed);\r\n        auction.status = Status.Open;\r\n        auction.start = uint64(block.number);\r\n        emit Opened(id, auction.start);\r\n    }\r\n\r\n    // dummy implementation to support interface\r\n    function purchase(uint16, address) public payable { \r\n        \r\n    }\r\n\r\n    function getMinBid(uint id) public view returns (uint) {\r\n\r\n        Auction memory auction = auctions[id];\r\n\r\n        uint highest = auction.highestBid;\r\n        \r\n        // calculate one percent of the number\r\n        // highest will always be >= 100\r\n        uint numerator = highest.div(100);\r\n\r\n        // calculate the minimum increase required\r\n        uint minIncrease = numerator.mul(auction.minIncreasePercent);\r\n\r\n        uint threshold = highest + minIncrease;\r\n\r\n        return threshold;\r\n    }\r\n\r\n    function bid(uint id) public payable {\r\n\r\n        Auction storage auction = auctions[id];\r\n\r\n        require(auction.status == Status.Open);\r\n\r\n        uint64 end = auction.start.add(auction.length);\r\n\r\n        require(end >= block.number);\r\n\r\n        uint threshold = getMinBid(id);\r\n        \r\n        require(msg.value >= threshold);\r\n\r\n        \r\n        // if within the buffer period of the auction\r\n        // extend to the buffer period of blocks\r\n\r\n        uint64 differenceToEnd = end.sub(uint64(block.number));\r\n\r\n        if (auction.bufferPeriod > differenceToEnd) {\r\n            \r\n            // extend the auction period to be at least the buffer period\r\n            uint64 toAdd = auction.bufferPeriod.sub(differenceToEnd);\r\n\r\n            auction.length = auction.length.add(toAdd);\r\n\r\n            emit Extended(id, auction.length);\r\n        }\r\n\r\n        emit Bid(id, msg.sender, msg.value);\r\n\r\n        if (auction.highestBidder != address(0)) {\r\n\r\n            // let's just go with the safe option rather than using send(): probably fine but no loss\r\n            owed[auction.highestBidder] = owed[auction.highestBidder].add(auction.highestBid);\r\n\r\n            // give the previous bidder their bonus/consolation card \r\n            if (auction.bonusProto != 0) {\r\n                uint cardID = migration.createCard(auction.highestBidder, auction.bonusProto, auction.bonusPurity);\r\n                emit Bonus(id, cardID, auction.highestBidder, auction.bonusProto, auction.bonusPurity);\r\n            }\r\n        }\r\n\r\n        auction.highestBid = msg.value;\r\n        auction.highestBidder = msg.sender;\r\n    }\r\n\r\n    // anyone can claim the card/pay gas for them\r\n    function claim(uint id) public returns (uint) {\r\n\r\n        Auction storage auction = auctions[id];\r\n\r\n        uint64 end = auction.start.add(auction.length);\r\n\r\n        require(block.number > end);\r\n\r\n        require(auction.status == Status.Open);\r\n        \r\n        auction.status = Status.Claimed;\r\n\r\n        uint cardID = migration.createCard(auction.highestBidder, auction.proto, auction.purity);\r\n\r\n        emit Claimed(id, cardID, auction.highestBidder, auction.highestBid, auction.proto, auction.purity);\r\n\r\n        // don't require this to be a trusted address\r\n        owed[auction.beneficiary] = owed[auction.beneficiary].add(auction.highestBid);\r\n\r\n        return cardID;\r\n    }\r\n\r\n    function withdraw(address user) public {\r\n        uint balance = owed[user];\r\n        require(balance > 0);\r\n        owed[user] = 0;\r\n        user.transfer(balance);\r\n    }\r\n\r\n    function getOwed(address user) public view returns (uint) {\r\n        return owed[user];\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migration\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"openAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"purchase\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getOwed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"proto\",\"type\":\"uint16\"},{\"name\":\"purity\",\"type\":\"uint16\"},{\"name\":\"highestBid\",\"type\":\"uint256\"},{\"name\":\"highestBidder\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint64\"},{\"name\":\"length\",\"type\":\"uint64\"},{\"name\":\"bonusProto\",\"type\":\"uint16\"},{\"name\":\"bonusPurity\",\"type\":\"uint16\"},{\"name\":\"bufferPeriod\",\"type\":\"uint64\"},{\"name\":\"minIncreasePercent\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getMinBid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"proto\",\"type\":\"uint16\"},{\"name\":\"purity\",\"type\":\"uint16\"},{\"name\":\"minBid\",\"type\":\"uint256\"},{\"name\":\"length\",\"type\":\"uint64\"},{\"name\":\"bonusProto\",\"type\":\"uint16\"},{\"name\":\"bonusPurity\",\"type\":\"uint16\"},{\"name\":\"bufferPeriod\",\"type\":\"uint64\"},{\"name\":\"minIncrease\",\"type\":\"uint256\"}],\"name\":\"createAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_migration\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proto\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"purity\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"minBid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"start\",\"type\":\"uint64\"}],\"name\":\"Opened\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"length\",\"type\":\"uint64\"}],\"name\":\"Extended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Bid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cardID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proto\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"Claimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"cardID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"bidder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"proto\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"purity\",\"type\":\"uint16\"}],\"name\":\"Bonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"purchaser\",\"type\":\"address\"}],\"name\":\"Referral\",\"type\":\"event\"}]","ContractName":"AuctionPack","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006ebeaf8e8e946f0716e6533a6f2cefc83f60e8ab","Library":"","SwarmSource":"bzzr://096faa617f5bec77ba4bdcbd58cf2f8edee63a314764ae7261d42e0795990ffb"}]}