{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    hasMintPermission\r\n    canMint\r\n    public\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner canMint public returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/NectarToken.sol\r\n\r\ncontract NectarToken is MintableToken {\r\n    string public name = \"Nectar\";\r\n    string public symbol = \"NCT\";\r\n    uint8 public decimals = 18;\r\n\r\n    bool public transfersEnabled = false;\r\n    event TransfersEnabled();\r\n\r\n    // Disable transfers until after the sale\r\n    modifier whenTransfersEnabled() {\r\n        require(transfersEnabled, \"Transfers not enabled\");\r\n        _;\r\n    }\r\n\r\n    modifier whenTransfersNotEnabled() {\r\n        require(!transfersEnabled, \"Transfers enabled\");\r\n        _;\r\n    }\r\n\r\n    function enableTransfers() public onlyOwner whenTransfersNotEnabled {\r\n        transfersEnabled = true;\r\n        emit TransfersEnabled();\r\n    }\r\n\r\n    function transfer(address to, uint256 value) public whenTransfersEnabled returns (bool) {\r\n        return super.transfer(to, value);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint256 value) public whenTransfersEnabled returns (bool) {\r\n        return super.transferFrom(from, to, value);\r\n    }\r\n\r\n    // Approves and then calls the receiving contract\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n\r\n        // Call the receiveApproval function on the contract you want to be notified.\r\n        // This crafts the function signature manually so one doesn't have to include a contract in here just for this.\r\n        //\r\n        // receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData)\r\n        //\r\n        // It is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead.\r\n\r\n        // solium-disable-next-line security/no-low-level-calls, indentation\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))),\r\n            msg.sender, _value, this, _extraData), \"receiveApproval failed\");\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/ArbiterStaking.sol\r\n\r\n//import \"./ArbiterStaking.sol\";\r\n\r\n\r\n\r\ncontract BountyRegistry is Pausable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for NectarToken;\r\n\r\n    string public constant VERSION = \"1.0.0\";\r\n\r\n    struct Bounty {\r\n        uint128 guid;\r\n        address author;\r\n        uint256 amount;\r\n        string artifactURI;\r\n        uint256 numArtifacts;\r\n        uint256 expirationBlock;\r\n        address assignedArbiter;\r\n        bool quorumReached;\r\n        uint256 quorumBlock;\r\n        uint256 quorumMask;\r\n    }\r\n\r\n    struct Assertion {\r\n        address author;\r\n        uint256 bid;\r\n        uint256 mask;\r\n        uint256 commitment;\r\n        uint256 nonce;\r\n        uint256 verdicts;\r\n        string metadata;\r\n    }\r\n\r\n    struct Vote {\r\n        address author;\r\n        uint256 votes;\r\n        bool validBloom;\r\n    }\r\n\r\n    event AddedArbiter(\r\n        address arbiter,\r\n        uint256 blockNumber\r\n    );\r\n\r\n    event RemovedArbiter(\r\n        address arbiter,\r\n        uint256 blockNumber\r\n    );\r\n\r\n    event NewBounty(\r\n        uint128 guid,\r\n        address author,\r\n        uint256 amount,\r\n        string artifactURI,\r\n        uint256 expirationBlock\r\n    );\r\n\r\n    event NewAssertion(\r\n        uint128 bountyGuid,\r\n        address author,\r\n        uint256 index,\r\n        uint256 bid,\r\n        uint256 mask,\r\n        uint256 numArtifacts,\r\n        uint256 commitment\r\n    );\r\n\r\n    event RevealedAssertion(\r\n        uint128 bountyGuid,\r\n        address author,\r\n        uint256 index,\r\n        uint256 nonce,\r\n        uint256 verdicts,\r\n        uint256 numArtifacts,\r\n        string metadata\r\n    );\r\n\r\n    event NewVote(\r\n        uint128 bountyGuid,\r\n        uint256 votes,\r\n        uint256 numArtifacts,\r\n        address voter\r\n    );\r\n\r\n    event QuorumReached(\r\n        uint128 bountyGuid\r\n    );\r\n\r\n    event SettledBounty(\r\n        uint128 bountyGuid,\r\n        address settler,\r\n        uint256 payout\r\n    );\r\n\r\n    ArbiterStaking public staking;\r\n    NectarToken internal token;\r\n\r\n    uint256 public constant BOUNTY_FEE = 62500000000000000;\r\n    uint256 public constant ASSERTION_FEE = 31250000000000000;\r\n    uint256 public constant BOUNTY_AMOUNT_MINIMUM = 62500000000000000;\r\n    uint256 public constant ASSERTION_BID_MINIMUM = 62500000000000000;\r\n    uint256 public constant ARBITER_LOOKBACK_RANGE = 100;\r\n    uint256 public constant MAX_DURATION = 100; // BLOCKS\r\n    uint256 public constant ASSERTION_REVEAL_WINDOW = 25; // BLOCKS\r\n    uint256 public constant MALICIOUS_VOTE_COEFFICIENT = 10;\r\n    uint256 public constant BENIGN_VOTE_COEFFICIENT = 1;\r\n    uint256 public constant VALID_HASH_PERIOD = 256; // number of blocks in the past you can still get a blockhash\r\n\r\n\r\n    uint256 public arbiterCount;\r\n    uint256 public arbiterVoteWindow;\r\n    uint128[] public bountyGuids;\r\n    mapping (uint128 => Bounty) public bountiesByGuid;\r\n    mapping (uint128 => Assertion[]) public assertionsByGuid;\r\n    mapping (uint128 => Vote[]) public votesByGuid;\r\n    mapping (uint128 => uint256[8]) public bloomByGuid;\r\n    mapping (uint128 => mapping (uint256 => uint256)) public quorumVotesByGuid;\r\n    mapping (address => bool) public arbiters;\r\n    mapping (uint256 => mapping (uint256 => uint256)) public voteCountByGuid;\r\n    mapping (uint256 => mapping (address => bool)) public arbiterVoteRegistryByGuid;\r\n    mapping (uint256 => mapping (address => bool)) public expertAssertionResgistryByGuid;\r\n    mapping (uint128 => mapping (address => bool)) public bountySettled;\r\n\r\n    /**\r\n     * Construct a new BountyRegistry\r\n     *\r\n     * @param _token address of NCT token to use\r\n     */\r\n    constructor(address _token, address _arbiterStaking, uint256 _arbiterVoteWindow) Ownable() public {\r\n        owner = msg.sender;\r\n        token = NectarToken(_token);\r\n        staking = ArbiterStaking(_arbiterStaking);\r\n        arbiterVoteWindow = _arbiterVoteWindow;\r\n    }\r\n\r\n    /**\r\n     * Function to check if an address is a valid arbiter\r\n     *\r\n     * @param addr The address to check\r\n     * @return true if addr is a valid arbiter else false\r\n     */\r\n    function isArbiter(address addr) public view returns (bool) {\r\n        // Remove arbiter requirements for now, while we are whitelisting\r\n        // arbiters on the platform\r\n        //return arbiters[addr] && staking.isEligible(addr);\r\n        return arbiters[addr];\r\n    }\r\n\r\n    /** Function only callable by arbiter */\r\n    modifier onlyArbiter() {\r\n        require(isArbiter(msg.sender), \"msg.sender is not an arbiter\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Function called to add an arbiter, emits an evevnt with the added arbiter\r\n     * and block number used to calculate their arbiter status based on public\r\n     * arbiter selection algorithm.\r\n     *\r\n     * @param newArbiter the arbiter to add\r\n     * @param blockNumber the block number the determination to add was\r\n     *      calculated from\r\n     */\r\n    function addArbiter(address newArbiter, uint256 blockNumber) external whenNotPaused onlyOwner {\r\n        require(newArbiter != address(0), \"Invalid arbiter address\");\r\n        require(!arbiters[newArbiter], \"Address is already an arbiter\");\r\n        arbiterCount = arbiterCount.add(1);\r\n        arbiters[newArbiter] = true;\r\n        emit AddedArbiter(newArbiter, blockNumber);\r\n    }\r\n\r\n    /**\r\n     * Function called to remove an arbiter, emits an evevnt with the removed\r\n     * arbiter and block number used to calculate their arbiter status based on\r\n     * public arbiter selection algorithm.\r\n     *\r\n     * @param arbiter the arbiter to remove\r\n     * @param blockNumber the block number the determination to remove was\r\n     *      calculated from\r\n     */\r\n    function removeArbiter(address arbiter, uint256 blockNumber) external whenNotPaused onlyOwner {\r\n        arbiters[arbiter] = false;\r\n        arbiterCount = arbiterCount.sub(1);\r\n        emit RemovedArbiter(arbiter, blockNumber);\r\n    }\r\n\r\n    /**\r\n     * Function called by end users and ambassadors to post a bounty\r\n     *\r\n     * @param guid the guid of the bounty, must be unique\r\n     * @param amount the amount of NCT to post as a reward\r\n     * @param artifactURI uri of the artifacts comprising this bounty\r\n     * @param durationBlocks duration of this bounty in blocks\r\n     */\r\n    function postBounty(\r\n        uint128 guid,\r\n        uint256 amount,\r\n        string artifactURI,\r\n        uint256 numArtifacts,\r\n        uint256 durationBlocks,\r\n        uint256[8] bloom\r\n    )\r\n    external\r\n    whenNotPaused\r\n    {\r\n        // Check if a bounty with this GUID has already been initialized\r\n        require(bountiesByGuid[guid].author == address(0), \"GUID already in use\");\r\n        // Check that our bounty amount is sufficient\r\n        require(amount >= BOUNTY_AMOUNT_MINIMUM, \"Bounty amount below minimum\");\r\n        // Check that our URI is non-empty\r\n        require(bytes(artifactURI).length > 0, \"Invalid artifact URI\");\r\n        // Check that our number of artifacts is valid\r\n        require(numArtifacts <= 256, \"Too many artifacts in bounty\");\r\n        require(numArtifacts > 0, \"Not enough artifacts in bounty\");\r\n        // Check that our duration is non-zero and less than or equal to the max\r\n        require(durationBlocks > 0 && durationBlocks <= MAX_DURATION, \"Invalid bounty duration\");\r\n\r\n        // Assess fees and transfer bounty amount into escrow\r\n        token.safeTransferFrom(msg.sender, address(this), amount.add(BOUNTY_FEE));\r\n\r\n        bountiesByGuid[guid].guid = guid;\r\n        bountiesByGuid[guid].author = msg.sender;\r\n        bountiesByGuid[guid].amount = amount;\r\n        bountiesByGuid[guid].artifactURI = artifactURI;\r\n\r\n        // Number of artifacts is submitted as part of the bounty, we have no\r\n        // way to check how many exist in this IPFS resource. For an IPFS\r\n        // resource with N artifacts, if numArtifacts < N only the first\r\n        // numArtifacts artifacts are included in this bounty, if numArtifacts >\r\n        // N then the last N - numArtifacts bounties are considered benign.\r\n        bountiesByGuid[guid].numArtifacts = numArtifacts;\r\n        bountiesByGuid[guid].expirationBlock = durationBlocks.add(block.number);\r\n\r\n        bountyGuids.push(guid);\r\n\r\n        bloomByGuid[guid] = bloom;\r\n\r\n        emit NewBounty(\r\n            bountiesByGuid[guid].guid,\r\n            bountiesByGuid[guid].author,\r\n            bountiesByGuid[guid].amount,\r\n            bountiesByGuid[guid].artifactURI,\r\n            bountiesByGuid[guid].expirationBlock\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Function called by security experts to post an assertion on a bounty\r\n     *\r\n     * @param bountyGuid the guid of the bounty to assert on\r\n     * @param bid the amount of NCT to stake\r\n     * @param mask the artifacts to assert on from the set in the bounty\r\n     * @param commitment a commitment hash of the verdicts being asserted, equal\r\n     *      to keccak256(verdicts ^ keccak256(nonce)) where nonce != 0\r\n     */\r\n    function postAssertion(\r\n        uint128 bountyGuid,\r\n        uint256 bid,\r\n        uint256 mask,\r\n        uint256 commitment\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Check if this bounty has been initialized\r\n        require(bountiesByGuid[bountyGuid].author != address(0), \"Bounty has not been initialized\");\r\n        // Check that our bid amount is sufficient\r\n        require(bid >= ASSERTION_BID_MINIMUM, \"Assertion bid below minimum\");\r\n        // Check if this bounty is active\r\n        require(bountiesByGuid[bountyGuid].expirationBlock > block.number, \"Bounty inactive\");\r\n        // Check if the sender has already made an assertion\r\n        require(expertAssertionResgistryByGuid[bountyGuid][msg.sender] == false, \"Sender has already asserted\");\r\n        // Assess fees and transfer bid amount into escrow\r\n        token.safeTransferFrom(msg.sender, address(this), bid.add(ASSERTION_FEE));\r\n\r\n        expertAssertionResgistryByGuid[bountyGuid][msg.sender] = true;\r\n\r\n        Assertion memory a = Assertion(\r\n            msg.sender,\r\n            bid,\r\n            mask,\r\n            commitment,\r\n            0,\r\n            0,\r\n            \"\"\r\n        );\r\n\r\n        uint256 index = assertionsByGuid[bountyGuid].push(a) - 1;\r\n        uint256 numArtifacts = bountiesByGuid[bountyGuid].numArtifacts;\r\n\r\n        emit NewAssertion(\r\n            bountyGuid,\r\n            a.author,\r\n            index,\r\n            a.bid,\r\n            a.mask,\r\n            numArtifacts,\r\n            a.commitment\r\n        );\r\n    }\r\n\r\n    // https://ethereum.stackexchange.com/questions/4170/how-to-convert-a-uint-to-bytes-in-solidity\r\n    function uint256_to_bytes(uint256 x) internal pure returns (bytes b) {\r\n        b = new bytes(32);\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { mstore(add(b, 32), x) }\r\n    }\r\n\r\n    /**\r\n     * Function called by security experts to reveal an assertion after bounty\r\n     * expiration\r\n     *\r\n     * @param bountyGuid the guid of the bounty to assert on\r\n     * @param assertionId the id of the assertion to reveal\r\n     * @param assertionId the id of the assertion to reveal\r\n     * @param nonce the nonce used to generate the commitment hash\r\n     * @param verdicts the verdicts making up this assertion\r\n     * @param metadata optional metadata to include in the assertion\r\n     */\r\n    function revealAssertion(\r\n        uint128 bountyGuid,\r\n        uint256 assertionId,\r\n        uint256 nonce,\r\n        uint256 verdicts,\r\n        string metadata\r\n    )\r\n        external\r\n        whenNotPaused\r\n    {\r\n        // Check if this bounty has been initialized\r\n        require(bountiesByGuid[bountyGuid].author != address(0), \"Bounty has not been initialized\");\r\n        // Check that the bounty is no longer active\r\n        require(bountiesByGuid[bountyGuid].expirationBlock <= block.number, \"Bounty is still active\");\r\n        // Check if the reveal round has closed\r\n        require(bountiesByGuid[bountyGuid].expirationBlock.add(ASSERTION_REVEAL_WINDOW) > block.number, \"Reveal round has closed\");\r\n        // Get numArtifacts to help decode all zero verdicts\r\n        uint256 numArtifacts = bountiesByGuid[bountyGuid].numArtifacts;\r\n\r\n        // Zero is defined as an invalid nonce\r\n        require(nonce != 0, \"Invalid nonce\");\r\n\r\n        // Check our id\r\n        require(assertionId < assertionsByGuid[bountyGuid].length, \"Invalid assertion ID\");\r\n\r\n        Assertion storage a = assertionsByGuid[bountyGuid][assertionId];\r\n        require(a.author == msg.sender, \"Incorrect assertion author\");\r\n        require(a.nonce == 0, \"Bounty already revealed\");\r\n\r\n        // Check our commitment hash, by xor-ing verdicts with the hashed nonce\r\n        // and the sender's address prevent copying assertions by submitting the\r\n        // same commitment hash and nonce during the reveal round\r\n        uint256 hashed_nonce = uint256(keccak256(uint256_to_bytes(nonce)));\r\n        uint256 commitment = uint256(keccak256(uint256_to_bytes(verdicts ^ hashed_nonce ^ uint256(msg.sender))));\r\n        require(commitment == a.commitment, \"Commitment hash mismatch\");\r\n\r\n        a.nonce = nonce;\r\n        a.verdicts = verdicts;\r\n        a.metadata = metadata;\r\n\r\n        emit RevealedAssertion(\r\n            bountyGuid,\r\n            a.author,\r\n            assertionId,\r\n            a.nonce,\r\n            a.verdicts,\r\n            numArtifacts,\r\n            a.metadata\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Function called by arbiter after bounty expiration to settle with their\r\n     * ground truth determination and pay out assertion rewards\r\n     *\r\n     * @param bountyGuid the guid of the bounty to settle\r\n     * @param votes bitset of votes representing ground truth for the\r\n     *      bounty's artifacts\r\n     */\r\n    function voteOnBounty(\r\n        uint128 bountyGuid,\r\n        uint256 votes,\r\n        bool validBloom\r\n    )\r\n        external\r\n        onlyArbiter\r\n        whenNotPaused\r\n    {\r\n        Bounty storage bounty = bountiesByGuid[bountyGuid];\r\n        Vote[] storage bountyVotes = votesByGuid[bountyGuid];\r\n\r\n        // Check if this bounty has been initialized\r\n        require(bounty.author != address(0), \"Bounty has not been initialized\");\r\n        // Check that the reveal round has closed\r\n        require(bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW) <= block.number, \"Reveal round is still active\");\r\n        // Check if the voting round has closed\r\n        require(bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW).add(arbiterVoteWindow) > block.number, \"Voting round has closed\");\r\n        // Check to make sure arbiters can't double vote\r\n        require(arbiterVoteRegistryByGuid[bountyGuid][msg.sender] == false, \"Arbiter has already voted\");\r\n\r\n        Vote memory a = Vote(\r\n            msg.sender,\r\n            votes,\r\n            validBloom\r\n        );\r\n\r\n        votesByGuid[bountyGuid].push(a);\r\n\r\n        staking.recordBounty(msg.sender, bountyGuid, block.number);\r\n        arbiterVoteRegistryByGuid[bountyGuid][msg.sender] = true;\r\n        uint256 tempQuorumMask = 0;\r\n        uint256 quorumCount = 0;\r\n        mapping (uint256 => uint256) quorumVotes = quorumVotesByGuid[bountyGuid];\r\n        for (uint256 i = 0; i < bounty.numArtifacts; i++) {\r\n\r\n            if (bounty.quorumMask != 0 && (bounty.quorumMask & (1 << i) != 0)) {\r\n                tempQuorumMask = tempQuorumMask.add(calculateMask(i, 1));\r\n                quorumCount = quorumCount.add(1);\r\n                continue;\r\n            }\r\n\r\n            if (votes & (1 << i) != 0) {\r\n                quorumVotes[i] = quorumVotes[i].add(1);\r\n            }\r\n\r\n            uint256 benignVotes = bountyVotes.length.sub(quorumVotes[i]);\r\n            uint256 maxBenignValue = arbiterCount.sub(quorumVotes[i]).mul(BENIGN_VOTE_COEFFICIENT);\r\n            uint256 maxMalValue = arbiterCount.sub(benignVotes).mul(MALICIOUS_VOTE_COEFFICIENT);\r\n\r\n            if (quorumVotes[i].mul(MALICIOUS_VOTE_COEFFICIENT) >= maxBenignValue || benignVotes.mul(BENIGN_VOTE_COEFFICIENT) > maxMalValue) {\r\n                tempQuorumMask = tempQuorumMask.add(calculateMask(i, 1));\r\n                quorumCount = quorumCount.add(1);\r\n            }\r\n        }\r\n\r\n        // set new mask\r\n        bounty.quorumMask = tempQuorumMask;\r\n\r\n        // check if all arbiters have voted or if we have quorum for all the artifacts\r\n        if ((bountyVotes.length == arbiterCount || quorumCount == bounty.numArtifacts) && !bounty.quorumReached)  {\r\n            bounty.quorumReached = true;\r\n            bounty.quorumBlock = block.number.sub(bountiesByGuid[bountyGuid].expirationBlock);\r\n            emit QuorumReached(bountyGuid);\r\n        }\r\n\r\n        emit NewVote(bountyGuid, votes, bounty.numArtifacts, msg.sender);\r\n    }\r\n\r\n    // This struct exists to move state from settleBounty into memory from stack\r\n    // to avoid solidity limitations\r\n    struct ArtifactPot {\r\n        uint256 numWinners;\r\n        uint256 numLosers;\r\n        uint256 winnerPool;\r\n        uint256 loserPool;\r\n    }\r\n\r\n    /**\r\n     * Function to calculate the reward disbursment of a bounty\r\n     *\r\n     * @param bountyGuid the guid of the bounty to calculate\r\n     * @return Rewards distributed by the bounty\r\n     */\r\n    function calculateBountyRewards(\r\n        uint128 bountyGuid\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 bountyRefund, uint256 arbiterReward, uint256[] expertRewards)\r\n    {\r\n        Bounty storage bounty = bountiesByGuid[bountyGuid];\r\n        Assertion[] storage assertions = assertionsByGuid[bountyGuid];\r\n        Vote[] storage votes = votesByGuid[bountyGuid];\r\n        mapping (uint256 => uint256) quorumVotes = quorumVotesByGuid[bountyGuid];\r\n\r\n        // Check if this bountiesByGuid[bountyGuid] has been initialized\r\n        require(bounty.author != address(0), \"Bounty has not been initialized\");\r\n        // Check if this bounty has been previously resolved for the sender\r\n        require(!bountySettled[bountyGuid][msg.sender], \"Bounty has already been settled for sender\");\r\n        // Check that the voting round has closed\r\n        // solium-disable-next-line indentation\r\n        require(bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW).add(arbiterVoteWindow) <= block.number || bounty.quorumReached,\r\n            \"Voting round is still active and quorum has not been reached\");\r\n\r\n        expertRewards = new uint256[](assertions.length);\r\n\r\n        ArtifactPot memory ap = ArtifactPot({numWinners: 0, numLosers: 0, winnerPool: 0, loserPool: 0});\r\n\r\n        uint256 i = 0;\r\n        uint256 j = 0;\r\n\r\n        if (assertions.length == 0 && votes.length == 0) {\r\n            // Refund the bounty amount and fees to ambassador\r\n            bountyRefund = bounty.numArtifacts.mul(bounty.amount.add(BOUNTY_FEE));\r\n        } else if (assertions.length == 0) {\r\n            // Refund the bounty amount ambassador\r\n            bountyRefund = bounty.amount.mul(bounty.numArtifacts);\r\n        } else if (votes.length == 0) {\r\n            // Refund bids, fees, and distribute the bounty amount evenly to experts\r\n            bountyRefund = BOUNTY_FEE.mul(bounty.numArtifacts);\r\n            for (j = 0; j < assertions.length; j++) {\r\n                expertRewards[j] = expertRewards[j].add(ASSERTION_FEE);\r\n                expertRewards[j] = expertRewards[j].add(assertions[j].bid);\r\n                expertRewards[j] = expertRewards[j].add(bounty.amount.div(assertions.length));\r\n                expertRewards[j] = expertRewards[j].mul(bounty.numArtifacts);\r\n            }\r\n        } else {\r\n            for (i = 0; i < bounty.numArtifacts; i++) {\r\n                ap = ArtifactPot({numWinners: 0, numLosers: 0, winnerPool: 0, loserPool: 0});\r\n                bool consensus = quorumVotes[i].mul(MALICIOUS_VOTE_COEFFICIENT) >= votes.length.sub(quorumVotes[i]).mul(BENIGN_VOTE_COEFFICIENT);\r\n\r\n                for (j = 0; j < assertions.length; j++) {\r\n                    bool malicious;\r\n\r\n                    // If we didn't assert on this artifact\r\n                    if (assertions[j].mask & (1 << i) == 0) {\r\n                        continue;\r\n                    }\r\n\r\n                    // If we haven't revealed set to incorrect value\r\n                    if (assertions[j].nonce == 0) {\r\n                        malicious = !consensus;\r\n                    } else {\r\n                        malicious = (assertions[j].verdicts & assertions[j].mask) & (1 << i) != 0;\r\n                    }\r\n\r\n                    if (malicious == consensus) {\r\n                        ap.numWinners = ap.numWinners.add(1);\r\n                        ap.winnerPool = ap.winnerPool.add(assertions[j].bid);\r\n                    } else {\r\n                        ap.numLosers = ap.numLosers.add(1);\r\n                        ap.loserPool = ap.loserPool.add(assertions[j].bid);\r\n                    }\r\n                }\r\n\r\n                // If nobody asserted on this artifact, refund the ambassador\r\n                if (ap.numWinners == 0 && ap.numLosers == 0) {\r\n                    bountyRefund = bountyRefund.add(bounty.amount);\r\n                    for (j = 0; j < assertions.length; j++) {\r\n                        expertRewards[j] = expertRewards[j].add(assertions[j].bid);\r\n                    }\r\n                } else {\r\n                    for (j = 0; j < assertions.length; j++) {\r\n                        expertRewards[j] = expertRewards[j].add(assertions[j].bid);\r\n\r\n                        // If we didn't assert on this artifact\r\n                        if (assertions[j].mask & (1 << i) == 0) {\r\n                            continue;\r\n                        }\r\n\r\n                        // If we haven't revealed set to incorrect value\r\n                        if (assertions[j].nonce == 0) {\r\n                            malicious = !consensus;\r\n                        } else {\r\n                            malicious = (assertions[j].verdicts & assertions[j].mask) & (1 << i) != 0;\r\n                        }\r\n\r\n                        if (malicious == consensus) {\r\n                            expertRewards[j] = expertRewards[j].add(assertions[j].bid.mul(ap.loserPool).div(ap.winnerPool));\r\n                            expertRewards[j] = expertRewards[j].add(bounty.amount.mul(assertions[j].bid).div(ap.winnerPool));\r\n                        } else {\r\n                            expertRewards[j] = expertRewards[j].sub(assertions[j].bid);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Calculate rewards\r\n        uint256 pot = bounty.amount.add(BOUNTY_FEE.add(ASSERTION_FEE.mul(assertions.length)));\r\n        for (i = 0; i < assertions.length; i++) {\r\n            pot = pot.add(assertions[i].bid);\r\n        }\r\n\r\n        bountyRefund = bountyRefund.div(bounty.numArtifacts);\r\n        pot = pot.sub(bountyRefund);\r\n\r\n        for (i = 0; i < assertions.length; i++) {\r\n            expertRewards[i] = expertRewards[i].div(bounty.numArtifacts);\r\n            pot = pot.sub(expertRewards[i]);\r\n        }\r\n\r\n        arbiterReward = pot;\r\n    }\r\n\r\n    /**\r\n     * Function called after window has closed to handle reward disbursal\r\n     *\r\n     * This function will pay out rewards if the the bounty has a super majority\r\n     * @param bountyGuid the guid of the bounty to settle\r\n     */\r\n    function settleBounty(uint128 bountyGuid) external whenNotPaused {\r\n        Bounty storage bounty = bountiesByGuid[bountyGuid];\r\n        Assertion[] storage assertions = assertionsByGuid[bountyGuid];\r\n\r\n        // Check if this bountiesByGuid[bountyGuid] has been initialized\r\n        require(bounty.author != address(0), \"Bounty has not been initialized\");\r\n        // Check if this bounty has been previously resolved for the sender\r\n        require(!bountySettled[bountyGuid][msg.sender], \"Bounty has already been settled for sender\");\r\n        // Check that the voting round has closed\r\n        // solium-disable-next-line indentation\r\n        require(bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW).add(arbiterVoteWindow) <= block.number || bounty.quorumReached,\r\n            \"Voting round is still active and quorum has not been reached\");\r\n\r\n        if (isArbiter(msg.sender)) {\r\n            require(bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW).add(arbiterVoteWindow) <= block.number, \"Voting round still active\");\r\n            if (bounty.assignedArbiter == address(0)) {\r\n                if (bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW).add(arbiterVoteWindow).add(VALID_HASH_PERIOD) >= block.number) {\r\n                    bounty.assignedArbiter = getWeightedRandomArbiter(bountyGuid);\r\n                } else {\r\n                    bounty.assignedArbiter = msg.sender;\r\n                }\r\n            }\r\n        }\r\n\r\n        uint256 payout = 0;\r\n        uint256 bountyRefund;\r\n        uint256 arbiterReward;\r\n        uint256[] memory expertRewards;\r\n        (bountyRefund, arbiterReward, expertRewards) = calculateBountyRewards(bountyGuid);\r\n\r\n        bountySettled[bountyGuid][msg.sender] = true;\r\n\r\n        // Disburse rewards\r\n        if (bountyRefund != 0 && bounty.author == msg.sender) {\r\n            token.safeTransfer(bounty.author, bountyRefund);\r\n            payout = payout.add(bountyRefund);\r\n        }\r\n\r\n        for (uint256 i = 0; i < assertions.length; i++) {\r\n            if (expertRewards[i] != 0 && assertions[i].author == msg.sender) {\r\n                token.safeTransfer(assertions[i].author, expertRewards[i]);\r\n                payout = payout.add(expertRewards[i]);\r\n            }\r\n        }\r\n\r\n        if (arbiterReward != 0 && bounty.assignedArbiter == msg.sender) {\r\n            token.safeTransfer(bounty.assignedArbiter, arbiterReward);\r\n            payout = payout.add(arbiterReward);\r\n        }\r\n\r\n        emit SettledBounty(bountyGuid, msg.sender, payout);\r\n    }\r\n\r\n    /**\r\n     *  Generates a random number from 0 to range based on the last block hash\r\n     *\r\n     *  @param seed random number for reproducing\r\n     *  @param range end range for random number\r\n     */\r\n    function randomGen(uint256 targetBlock, uint seed, uint256 range) private view returns (int256 randomNumber) {\r\n        return int256(uint256(keccak256(abi.encodePacked(blockhash(targetBlock), seed))) % range);\r\n    }\r\n\r\n    /**\r\n     * Gets a random Arbiter weighted by the amount of Nectar they have\r\n     *\r\n     * @param bountyGuid the guid of the bounty\r\n     */\r\n    function getWeightedRandomArbiter(uint128 bountyGuid) public view returns (address voter) {\r\n        require(bountiesByGuid[bountyGuid].author != address(0), \"Bounty has not been initialized\");\r\n\r\n        Bounty memory bounty = bountiesByGuid[bountyGuid];\r\n        Vote[] memory votes = votesByGuid[bountyGuid];\r\n\r\n        if (votes.length == 0) {\r\n            return address(0);\r\n        }\r\n\r\n        uint i;\r\n        uint256 sum = 0;\r\n        int256 randomNum;\r\n\r\n        for (i = 0; i < votes.length; i++) {\r\n            sum = sum.add(staking.balanceOf(votes[i].author));\r\n        }\r\n\r\n        randomNum = randomGen(bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW).add(arbiterVoteWindow), block.number, sum);\r\n\r\n        for (i = 0; i < votes.length; i++) {\r\n            randomNum -= int256(staking.balanceOf(votes[i].author));\r\n\r\n            if (randomNum <= 0) {\r\n                voter = votes[i].author;\r\n                break;\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Get the total number of bounties tracked by the contract\r\n     * @return total number of bounties\r\n     */\r\n    function getNumberOfBounties() external view returns (uint) {\r\n        return bountyGuids.length;\r\n    }\r\n\r\n    /**\r\n     * Get the current round for a bounty\r\n     *\r\n     * @param bountyGuid the guid of the bounty\r\n     * @return the current round\r\n     *      0 = assertions being accepted\r\n     *      1 = assertions being revealed\r\n     *      2 = arbiters voting\r\n     *      3 = bounty finished\r\n     */\r\n    function getCurrentRound(uint128 bountyGuid) external view returns (uint) {\r\n        // Check if this bounty has been initialized\r\n        require(bountiesByGuid[bountyGuid].author != address(0), \"Bounty has not been initialized\");\r\n\r\n        Bounty memory bounty = bountiesByGuid[bountyGuid];\r\n\r\n        if (bounty.expirationBlock > block.number) {\r\n            return 0;\r\n        } else if (bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW) > block.number) {\r\n            return 1;\r\n        } else if (bounty.expirationBlock.add(ASSERTION_REVEAL_WINDOW).add(arbiterVoteWindow) > block.number &&\r\n                  !bounty.quorumReached) {\r\n            return 2;\r\n        } else {\r\n            return 3;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the number of assertions for a bounty\r\n     *\r\n     * @param bountyGuid the guid of the bounty\r\n     * @return number of assertions for the given bounty\r\n     */\r\n    function getNumberOfAssertions(uint128 bountyGuid) external view returns (uint) {\r\n        // Check if this bounty has been initialized\r\n        require(bountiesByGuid[bountyGuid].author != address(0), \"Bounty has not been initialized\");\r\n\r\n        return assertionsByGuid[bountyGuid].length;\r\n    }\r\n\r\n    /**\r\n     * Gets the vote count for a specific bounty\r\n     *\r\n     * @param bountyGuid the guid of the bounty\r\n     */\r\n    function getNumberOfVotes(uint128 bountyGuid) external view returns (uint) {\r\n        require(bountiesByGuid[bountyGuid].author != address(0), \"Bounty has not been initialized\");\r\n\r\n        return votesByGuid[bountyGuid].length;\r\n    }\r\n\r\n    /**\r\n     * Gets all the voters for a specific bounty\r\n     *\r\n     * @param bountyGuid the guid of the bounty\r\n     */\r\n    function getVoters(uint128 bountyGuid) external view returns (address[]) {\r\n        require(bountiesByGuid[bountyGuid].author != address(0), \"Bounty has not been initialized\");\r\n\r\n        Vote[] memory votes = votesByGuid[bountyGuid];\r\n        uint count = votes.length;\r\n\r\n        address[] memory voters = new address[](count);\r\n\r\n        for (uint i = 0; i < count; i++) {\r\n            voters[i] = votes[i].author;\r\n        }\r\n\r\n        return voters;\r\n    }\r\n\r\n    /** Candidate for future arbiter */\r\n    struct Candidate {\r\n        address addr;\r\n        uint256 count;\r\n    }\r\n\r\n    /**\r\n     * View function displays most active bounty posters over past\r\n     * ARBITER_LOOKBACK_RANGE bounties to select future arbiters\r\n     *\r\n     * @return sorted array of most active bounty posters\r\n     */\r\n    function getArbiterCandidates() external view returns (address[]) {\r\n        require(bountyGuids.length > 0, \"No bounties have been placed\");\r\n\r\n        uint256 count = 0;\r\n        Candidate[] memory candidates = new Candidate[](ARBITER_LOOKBACK_RANGE);\r\n\r\n        uint256 lastBounty = 0;\r\n        if (bountyGuids.length > ARBITER_LOOKBACK_RANGE) {\r\n            lastBounty = bountyGuids.length.sub(ARBITER_LOOKBACK_RANGE);\r\n        }\r\n\r\n        for (uint256 i = bountyGuids.length; i > lastBounty; i--) {\r\n            address addr = bountiesByGuid[bountyGuids[i.sub(1)]].author;\r\n            bool found = false;\r\n            for (uint256 j = 0; j < count; j++) {\r\n                if (candidates[j].addr == addr) {\r\n                    candidates[j].count = candidates[j].count.add(1);\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (!found) {\r\n                candidates[count] = Candidate(addr, 1);\r\n                count = count.add(1);\r\n            }\r\n        }\r\n\r\n        address[] memory ret = new address[](count);\r\n\r\n        for (i = 0; i < ret.length; i++) {\r\n            uint256 next = 0;\r\n            uint256 value = candidates[0].count;\r\n\r\n\r\n\r\n            for (j = 0; j < count; j++) {\r\n                if (candidates[j].count > value) {\r\n                    next = j;\r\n                    value = candidates[j].count;\r\n                }\r\n            }\r\n\r\n            ret[i] = candidates[next].addr;\r\n            candidates[next] = candidates[count.sub(1)];\r\n            count = count.sub(1);\r\n        }\r\n\r\n        return ret;\r\n    }\r\n\r\n    function calculateMask(uint256 i, uint256 b) public pure returns(uint256) {\r\n        if (b != 0) {\r\n            return 1 << i;\r\n        }\r\n\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * View function displays the most active bounty voters over past\r\n     * ARBITER_LOOKBACK_RANGE bounties to select future arbiters\r\n     *\r\n     * @return a sorted array of most active bounty voters and a boolean array of whether\r\n     * or not they were active in 90% of bounty votes\r\n     */\r\n\r\n    function getActiveArbiters() external view returns (address[], bool[]) {\r\n        require(bountyGuids.length > 0, \"No bounties have been placed\");\r\n        uint256 count = 0;\r\n        uint256 threshold = bountyGuids.length.div(10).mul(9);\r\n        address[] memory ret_addr = new address[](count);\r\n        bool[] memory ret_arbiter_ativity_threshold = new bool[](count);\r\n\r\n        Candidate[] memory candidates = new Candidate[](ARBITER_LOOKBACK_RANGE);\r\n\r\n        uint256 lastBounty = 0;\r\n        if (bountyGuids.length > ARBITER_LOOKBACK_RANGE) {\r\n            lastBounty = bountyGuids.length.sub(ARBITER_LOOKBACK_RANGE);\r\n            threshold = lastBounty.div(10).mul(9);\r\n        }\r\n\r\n        for (uint256 i = bountyGuids.length.sub(1); i > lastBounty; i--) {\r\n            Vote[] memory votes = votesByGuid[bountyGuids[i]];\r\n\r\n            for (uint256 j = 0; j < votes.length; j++) {\r\n                bool found = false;\r\n                address addr = votes[j].author;\r\n\r\n                for (uint256 k = 0; k < count; k++) {\r\n                    if (candidates[k].addr == addr) {\r\n                        candidates[k].count = candidates[k].count.add(1);\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if (!found) {\r\n                    candidates[count] = Candidate(addr, 1);\r\n                    count = count.add(1);\r\n                }\r\n\r\n            }\r\n\r\n        }\r\n\r\n\r\n        for (i = 0; i < ret_addr.length; i++) {\r\n            uint256 next = 0;\r\n            uint256 value = candidates[0].count;\r\n\r\n            for (j = 0; j < count; j++) {\r\n                if (candidates[j].count > value) {\r\n                    next = j;\r\n                    value = candidates[j].count;\r\n                }\r\n            }\r\n\r\n            ret_addr[i] = candidates[next].addr;\r\n            if (candidates[next].count.div(10).mul(9) < threshold) {\r\n                ret_arbiter_ativity_threshold[i] = false;\r\n            } else {\r\n                ret_arbiter_ativity_threshold[i] = true;\r\n            }\r\n\r\n            count = count.sub(1);\r\n            candidates[next] = candidates[count];\r\n        }\r\n\r\n        return (ret_addr, ret_arbiter_ativity_threshold);\r\n\r\n    }\r\n\r\n}\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n//import \"./BountyRegistry.sol\";\r\n\r\ncontract ArbiterStaking is Pausable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for NectarToken;\r\n\r\n    uint256 public constant MINIMUM_STAKE = 10000000 * 10 ** 18;\r\n    uint256 public constant MAXIMUM_STAKE = 100000000 * 10 ** 18;\r\n    uint8 public constant VOTE_RATIO_NUMERATOR = 9;\r\n    uint8 public constant VOTE_RATIO_DENOMINATOR = 10;\r\n    string public constant VERSION = \"1.0.0\";\r\n\r\n    // Deposits\r\n    struct Deposit {\r\n        uint256 blockNumber;\r\n        uint256 value;\r\n    }\r\n\r\n    event NewDeposit(\r\n        address indexed from,\r\n        uint256 value\r\n    );\r\n\r\n    event NewWithdrawal(\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    mapping(address => Deposit[]) public deposits;\r\n\r\n    // Bounties\r\n    event BountyRecorded(\r\n        uint128 indexed guid,\r\n        uint256 blockNumber\r\n    );\r\n\r\n    event BountyVoteRecorded(\r\n        address arbiter\r\n    );\r\n\r\n    uint256 public numBounties;\r\n    mapping(uint128 => bool) public bounties;\r\n    mapping(address => uint256) public bountyResponses;\r\n    mapping(uint128 => mapping(address => bool)) public bountyResponseByGuidAndAddress;\r\n\r\n    uint256 public stakeDuration;\r\n    NectarToken internal token;\r\n    BountyRegistry internal registry;\r\n\r\n    /**\r\n     * Construct a new ArbiterStaking\r\n     *\r\n     * @param _token address of NCT token to use\r\n     */\r\n    constructor(address _token, uint256 _stakeDuration) Ownable() public {\r\n        token = NectarToken(_token);\r\n        stakeDuration = _stakeDuration;\r\n    }\r\n\r\n    /**\r\n     * Sets the registry value with the live BountyRegistry\r\n\r\n     * @param _bountyRegistry Address of BountyRegistry contract\r\n     */\r\n    function setBountyRegistry(address _bountyRegistry) public onlyOwner {\r\n        registry = BountyRegistry(_bountyRegistry);\r\n    }\r\n\r\n    /**\r\n     * Handle a deposit upon receiving approval for a token transfer\r\n     * Called from NectarToken.approveAndCall\r\n     *\r\n     * @param _from Account depositing NCT\r\n     * @param _value Amount of NCT being deposited\r\n     * @param _tokenContract Address of the NCT contract\r\n     * @return true if successful else false\r\n     */\r\n    function receiveApproval(\r\n        address _from,\r\n        uint256 _value,\r\n        address _tokenContract,\r\n        bytes\r\n    )\r\n        public\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == address(token), \"Must be called from the token.\");\r\n        return receiveApprovalInternal(_from, _value, _tokenContract, new bytes(0));\r\n    }\r\n\r\n    function receiveApprovalInternal(\r\n        address _from,\r\n        uint256 _value,\r\n        address _tokenContract,\r\n        bytes\r\n    )\r\n        internal\r\n        whenNotPaused\r\n        returns (bool)\r\n    {\r\n        require(registry.isArbiter(_from), \"Deposit target is not an arbiter\");\r\n        // Ensure we are depositing something\r\n        require(_value > 0, \"Zero value being deposited\");\r\n        // Ensure we are called from he right token contract\r\n        require(_tokenContract == address(token), \"Invalid token being deposited\");\r\n        // Ensure that we are not staking more than the maximum\r\n        require(balanceOf(_from).add(_value) <= MAXIMUM_STAKE, \"Value greater than maximum stake\");\r\n\r\n        token.safeTransferFrom(_from, this, _value);\r\n        deposits[_from].push(Deposit(block.number, _value));\r\n        emit NewDeposit(_from, _value);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Deposit NCT (requires prior approval)\r\n     *\r\n     * @param value The amount of NCT to deposit\r\n     */\r\n    function deposit(uint256 value) public whenNotPaused {\r\n        require(receiveApprovalInternal(msg.sender, value, token, new bytes(0)), \"Depositing stake failed\");\r\n    }\r\n\r\n    /**\r\n     * Retrieve the (total) current balance of staked NCT for an account\r\n     *\r\n     * @param addr The account whos balance to retrieve\r\n     * @return The current (total) balance of the account\r\n     */\r\n    function balanceOf(address addr) public view returns (uint256) {\r\n        uint256 ret = 0;\r\n        Deposit[] storage ds = deposits[addr];\r\n        for (uint256 i = 0; i < ds.length; i++) {\r\n            ret = ret.add(ds[i].value);\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the withdrawable current balance of staked NCT for an account\r\n     *\r\n     * @param addr The account whos balance to retrieve\r\n     * @return The current withdrawable balance of the account\r\n     */\r\n    function withdrawableBalanceOf(address addr) public view returns (uint256) {\r\n        uint256 ret = 0;\r\n        if (block.number < stakeDuration) {\r\n            return ret;\r\n        }\r\n        uint256 latest_block = block.number.sub(stakeDuration);\r\n        Deposit[] storage ds = deposits[addr];\r\n        for (uint256 i = 0; i < ds.length; i++) {\r\n            if (ds[i].blockNumber <= latest_block) {\r\n                ret = ret.add(ds[i].value);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * Withdraw staked NCT\r\n     * @param value The amount of NCT to withdraw\r\n     */\r\n    function withdraw(uint256 value) public whenNotPaused {\r\n        require(deposits[msg.sender].length > 0, \"Cannot withdraw without some deposits.\");\r\n        uint256 remaining = value;\r\n        uint256 latest_block = block.number.sub(stakeDuration);\r\n        Deposit[] storage ds = deposits[msg.sender];\r\n\r\n        require(value <= withdrawableBalanceOf(msg.sender), \"Value exceeds withdrawable balance\");\r\n\r\n        // Determine which deposits we will modifiy\r\n        for (uint256 end = 0; end < ds.length; end++) {\r\n            if (ds[end].blockNumber <= latest_block) {\r\n                if (ds[end].value >= remaining) {\r\n                    ds[end].value = ds[end].value.sub(remaining);\r\n                    if (ds[end].value == 0) {\r\n                        end++;\r\n                    }\r\n                    remaining = 0;\r\n                    break;\r\n                } else {\r\n                    remaining = remaining.sub(ds[end].value);\r\n                }\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        // If we haven't hit our value by now, we don't have enough available\r\n        // funds\r\n        require(remaining == 0, \"Value exceeds withdrawable balance\");\r\n\r\n        // Delete the obsolete deposits\r\n        for (uint256 i = 0; i < ds.length.sub(end); i++) {\r\n            ds[i] = ds[i.add(end)];\r\n        }\r\n\r\n        for (i = ds.length.sub(end); i < ds.length; i++) {\r\n            delete ds[i];\r\n        }\r\n\r\n        ds.length = ds.length.sub(end);\r\n\r\n        // Do the transfer\r\n        token.safeTransfer(msg.sender, value);\r\n        emit NewWithdrawal(msg.sender, value);\r\n    }\r\n\r\n    /**\r\n     * Is an address an eligible arbiter?\r\n     * @param addr The address to validate\r\n     * @return true if address is eligible else false\r\n     */\r\n    function isEligible(address addr) public view returns (bool) {\r\n        uint256 num;\r\n        uint256 den;\r\n        (num, den) = arbiterResponseRate(addr);\r\n\r\n        return balanceOf(addr) >= MINIMUM_STAKE &&\r\n            (den < VOTE_RATIO_DENOMINATOR || num.mul(VOTE_RATIO_DENOMINATOR).div(den) >= VOTE_RATIO_NUMERATOR);\r\n    }\r\n\r\n    /**\r\n     * Record a bounty that an arbiter has voted on\r\n     *\r\n     * @param arbiter The address of the arbiter\r\n     * @param bountyGuid The guid of the bounty\r\n     */\r\n    function recordBounty(address arbiter, uint128 bountyGuid, uint256 blockNumber) public {\r\n        require(msg.sender == address(registry), \"Can only be called by the BountyRegistry.\");\r\n        require(arbiter != address(0), \"Invalid arbiter address\");\r\n        require(blockNumber != 0, \"Invalid block number\");\r\n\r\n        // New bounty\r\n        if (!bounties[bountyGuid]) {\r\n            bounties[bountyGuid] = true;\r\n            numBounties = numBounties.add(1);\r\n            emit BountyRecorded(bountyGuid, blockNumber);\r\n        }\r\n\r\n        // First response to this bounty by this arbiter\r\n        if (!bountyResponseByGuidAndAddress[bountyGuid][arbiter]) {\r\n            bountyResponseByGuidAndAddress[bountyGuid][arbiter] = true;\r\n            bountyResponses[arbiter] = bountyResponses[arbiter].add(1);\r\n        }\r\n\r\n        emit BountyVoteRecorded(arbiter);\r\n    }\r\n\r\n    /**\r\n     * Determines the ratio of past bounties that the arbiter has responded to\r\n     *\r\n     * @param arbiter The address of the arbiter\r\n     * @return number of bounties responded to, number of bounties considered\r\n     */\r\n    function arbiterResponseRate(address arbiter) public view returns (uint256 num, uint256 den) {\r\n        num = bountyResponses[arbiter];\r\n        den = numBounties;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_STAKE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"arbiter\",\"type\":\"address\"},{\"name\":\"bountyGuid\",\"type\":\"uint128\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"recordBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bountyResponses\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawableBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"arbiterResponseRate\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bountyRegistry\",\"type\":\"address\"}],\"name\":\"setBountyRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isEligible\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint128\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bountyResponseByGuidAndAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTE_RATIO_NUMERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTE_RATIO_DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBounties\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_STAKE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deposits\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"name\":\"bounties\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_stakeDuration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"guid\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"BountyRecorded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"arbiter\",\"type\":\"address\"}],\"name\":\"BountyVoteRecorded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ArbiterStaking","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000009e46a38f5daabe8683e10793b06749eef7d733d100000000000000000000000000000000000000000000000000000000000ab395","Library":"","SwarmSource":"bzzr://65507cdef04b9df3302f57cf6a84af7ca3a309b505ccabf5bfff401c74ef9fd3"}]}