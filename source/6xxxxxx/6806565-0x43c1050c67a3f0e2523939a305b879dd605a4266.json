{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/FreeDnaCardRepositoryInterface.sol\r\n\r\ninterface FreeDnaCardRepositoryInterface {\r\n    function airdrop(address to, uint256 animalId) external;\r\n\r\n    function giveaway(\r\n        address to,\r\n        uint256 animalId,\r\n        uint8 effectiveness\r\n    )\r\n    external;\r\n}\r\n\r\n// File: contracts/Airdrop.sol\r\n\r\ninterface CryptoServal {\r\n    function getAnimalsCount() external view returns(uint256 animalsCount);\r\n}\r\n\r\n\r\ncontract Airdrop {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => mapping (uint256 => bool)) private addressHasWithdraw;\r\n    mapping (uint256 => uint256) private periodDonationCount;\r\n\r\n    CryptoServal private cryptoServal;\r\n    FreeDnaCardRepositoryInterface private freeDnaCardRepository;\r\n\r\n    uint256 private startTimestamp;\r\n    uint256 private endTimestamp;\r\n    uint256 private periodDuration; // 23 hours (82800 seconds)?\r\n    uint16 private cardsByPeriod; // number of cards dropped by period\r\n\r\n    constructor(\r\n        address _cryptoServalAddress,\r\n        address _freeDnaCardRepositoryAddress,\r\n        uint _startTimestamp,\r\n        uint _endTimestamp,\r\n        uint256 _periodDuration,\r\n        uint16 _cardsByPeriod\r\n    )\r\n    public {\r\n        freeDnaCardRepository =\r\n            FreeDnaCardRepositoryInterface(_freeDnaCardRepositoryAddress);\r\n        cryptoServal = CryptoServal(_cryptoServalAddress);\r\n        startTimestamp = _startTimestamp;\r\n        endTimestamp = _endTimestamp;\r\n        periodDuration = _periodDuration;\r\n        cardsByPeriod = _cardsByPeriod;\r\n    }\r\n\r\n    function withdraw() external {\r\n        require(now >= startTimestamp, \"not started yet\");\r\n        require(now <= endTimestamp, \"ended\");\r\n\r\n        mapping (uint256 => bool) senderHasWithdraw = addressHasWithdraw[msg.sender];\r\n        uint256 currentPeriodKey = getCurrentPeriodKey();\r\n\r\n        // Ensure the sender has not already withdraw during the current period\r\n        require(senderHasWithdraw[currentPeriodKey] == false, \"once / period\");\r\n\r\n        // Ensure we didn't reached the daily (period) limit\r\n        require(\r\n            periodDonationCount[currentPeriodKey] < cardsByPeriod,\r\n            \"period maximum donations reached\"\r\n        );\r\n\r\n        // Donate the card\r\n        freeDnaCardRepository.airdrop(msg.sender, getRandomAnimalId());\r\n\r\n        // And record his withdrawal\r\n        periodDonationCount[currentPeriodKey]++;\r\n        senderHasWithdraw[currentPeriodKey] = true;\r\n    }\r\n\r\n    function hasAvailableCard() external view returns(bool) {\r\n        uint256 currentPeriodKey = getCurrentPeriodKey();\r\n        mapping (uint256 => bool) senderHasWithdraw = addressHasWithdraw[msg.sender];\r\n\r\n        return (senderHasWithdraw[currentPeriodKey] == false &&\r\n                periodDonationCount[currentPeriodKey] < cardsByPeriod);\r\n    }\r\n\r\n    function getAvailableCardCount() external view returns(uint256) {\r\n        return cardsByPeriod - periodDonationCount[getCurrentPeriodKey()];\r\n    }\r\n\r\n    function getNextPeriodTimestamp() external view returns(uint256) {\r\n        uint256 nextPeriodKey = getCurrentPeriodKey() + 1;\r\n        return nextPeriodKey.mul(periodDuration);\r\n    }\r\n\r\n    function getRandomNumber(uint256 max) public view returns(uint256) {\r\n        require(max != 0);\r\n        return now % max;\r\n    }\r\n\r\n    function getAnimalCount() public view returns(uint256) {\r\n        return cryptoServal.getAnimalsCount();\r\n    }\r\n\r\n    function getRandomAnimalId() public view returns(uint256) {\r\n        return getRandomNumber(getAnimalCount());\r\n    }\r\n\r\n    function getPeriodKey(uint atTime) private view returns(uint256) {\r\n        return atTime.div(periodDuration);\r\n    }\r\n\r\n    function getCurrentPeriodKey() private view returns(uint256) {\r\n        return getPeriodKey(now);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hasAvailableCard\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAnimalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNextPeriodTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRandomAnimalId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableCardCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"max\",\"type\":\"uint256\"}],\"name\":\"getRandomNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_cryptoServalAddress\",\"type\":\"address\"},{\"name\":\"_freeDnaCardRepositoryAddress\",\"type\":\"address\"},{\"name\":\"_startTimestamp\",\"type\":\"uint256\"},{\"name\":\"_endTimestamp\",\"type\":\"uint256\"},{\"name\":\"_periodDuration\",\"type\":\"uint256\"},{\"name\":\"_cardsByPeriod\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Airdrop","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000003a1957a0b9755d78c77e301410b254b6147a400c000000000000000000000000ad4da252d5b4ecb8a01dbad477cca24ee7a53af0000000000000000000000000000000000000000000000000000000005c093970000000000000000000000000000000000000000000000000000000005c5af67000000000000000000000000000000000000000000000000000000000000143700000000000000000000000000000000000000000000000000000000000000019","Library":"","SwarmSource":"bzzr://a9cdc9f4a45bb3409c0eaf206724731942254c6d497ef24f7d60017f8ab6b0b9"}]}