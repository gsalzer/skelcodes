{"status":"1","message":"OK","result":[{"SourceCode":"/** Orgon Token Smart Contract.  Copyright Â© 2019 by Oris.Space. v25 */\r\npragma solidity ^0.4.25;\r\n\r\nlibrary SafeMath {\r\n \r\n  /**\r\n   * Add two uint256 values, throw in case of overflow.\r\n   * @param x first value to add\r\n   * @param y second value to add\r\n   * @return x + y\r\n   */\r\n  function safeAdd (uint256 x, uint256 y) internal pure returns (uint256) {\r\n    uint256 z = x + y;\r\n    require(z >= x);\r\n    return z;\r\n  }\r\n\r\n  /**\r\n   * Subtract one uint256 value from another, throw in case of underflow.\r\n   * @param x value to subtract from\r\n   * @param y value to subtract\r\n   * @return x - y\r\n   */\r\n  function safeSub (uint256 x, uint256 y) internal pure returns (uint256) {\r\n    require (x >= y);\r\n    uint256 z = x - y;\r\n    return z;\r\n  }\r\n}\r\n\r\ncontract Token {\r\n  /**\r\n   * Get total number of tokens in circulation.\r\n   *\r\n   * @return total number of tokens in circulation\r\n   */\r\n  function totalSupply () public view returns (uint256 supply);\r\n\r\n  /**\r\n   * Get number of tokens currently belonging to given owner.\r\n   *\r\n   * @param _owner address to get number of tokens currently belonging to the\r\n   *        owner of\r\n   * @return number of tokens currently belonging to the owner of given address\r\n   */\r\n  function balanceOf (address _owner) public view returns (uint256 balance);\r\n\r\n  /**\r\n   * Transfer given number of tokens from message sender to given recipient.\r\n   *\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer to the owner of given address\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transfer (address _to, uint256 _value)\r\n  public returns (bool success);\r\n\r\n  /**\r\n   * Transfer given number of tokens from given owner to given recipient.\r\n   *\r\n   * @param _from address to transfer tokens from the owner of\r\n   * @param _to address to transfer tokens to the owner of\r\n   * @param _value number of tokens to transfer from given owner to given\r\n   *        recipient\r\n   * @return true if tokens were transferred successfully, false otherwise\r\n   */\r\n  function transferFrom (address _from, address _to, uint256 _value)\r\n  public returns (bool success);\r\n\r\n  /**\r\n   * Allow given spender to transfer given number of tokens from message sender.\r\n   *\r\n   * @param _spender address to allow the owner of to transfer tokens from\r\n   *        message sender\r\n   * @param _value number of tokens to allow to transfer\r\n   * @return true if token transfer was successfully approved, false otherwise\r\n   */\r\n  function approve (address _spender, uint256 _value)\r\n  public returns (bool success);\r\n\r\n  /**\r\n   * Tell how many tokens given spender is currently allowed to transfer from\r\n   * given owner.\r\n   *\r\n   * @param _owner address to get number of tokens allowed to be transferred\r\n   *        from the owner of\r\n   * @param _spender address to get number of tokens allowed to be transferred\r\n   *        by the owner of\r\n   * @return number of tokens given spender is currently allowed to transfer\r\n   *         from given owner\r\n   */\r\n  function allowance (address _owner, address _spender)\r\n  public view returns (uint256 remaining);\r\n\r\n  /**\r\n   * Logged when tokens were transferred from one owner to another.\r\n   *\r\n   * @param _from address of the owner, tokens were transferred from\r\n   * @param _to address of the owner, tokens were transferred to\r\n   * @param _value number of tokens transferred\r\n   */\r\n  event Transfer (address indexed _from, address indexed _to, uint256 _value);\r\n\r\n  /**\r\n   * Logged when owner approved his tokens to be transferred by some spender.\r\n   *\r\n   * @param _owner owner who approved his tokens to be transferred\r\n   * @param _spender spender who were allowed to transfer the tokens belonging\r\n   *        to the owner\r\n   * @param _value number of tokens belonging to the owner, approved to be\r\n   *        transferred by the spender\r\n   */\r\n  event Approval (\r\n    address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n/** Orgon Token smart contract */\r\ncontract OrgonToken is Token {\r\n    \r\nusing SafeMath for uint256;\r\n\r\n/* Maximum allowed number of tokens in circulation (2^256 - 1). */\r\nuint256 constant MAX_TOKEN_COUNT =\r\n0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n/* Full life start time (2021-10-18 18:10:21 UTC) */\r\nuint256 private constant LIFE_START_TIME = 1634559021;\r\n\r\n/* Number of tokens to be send for Full life start 642118523.280000000000000000 */\r\nuint256 private constant LIFE_START_TOKENS = 642118523280000000000000000;\r\n  \r\n/** Deploy Orgon Token smart contract and make message sender to be the owner\r\n   of the smart contract */\r\n/* *********************************************** */\r\nconstructor() public {\r\n    owner = msg.sender;\r\n    mint = msg.sender;\r\n}\r\n  \r\n  \r\n/** Get name,symbol of this token, number of decimals for this token  \r\n * @return name of this token */\r\n/* *********************************************** */\r\nfunction name () public pure returns (string) {\r\n    \r\n    return \"ORGON\";\r\n}\r\n\r\n/* *********************************************** */\r\nfunction symbol () public pure returns (string) {\r\n    \r\n    return \"ORGON\";\r\n}\r\n/* *********************************************** */\r\nfunction decimals () public pure returns (uint8) {\r\n    \r\n    return 18;\r\n}\r\n\r\n/** Get total number of tokens in circulation\r\n * @return total number of tokens in circulation */\r\n \r\n/* *********************************************** */ \r\nfunction totalSupply () public view returns (uint256 supply) {\r\n     \r\n     return tokenCount;\r\n }\r\n\r\n/* *********************************************** */\r\nfunction totalICO () public view returns (uint256) {\r\n     \r\n     return tokenICO;\r\n }\r\n\r\n/* *********************************************** */\r\nfunction theMint () public view returns (address) {\r\n     \r\n     return mint;\r\n }\r\n \r\n /* *********************************************** */\r\nfunction theStage () public view returns (Stage) {\r\n     \r\n     return stage;\r\n }\r\n \r\n /* *********************************************** */\r\nfunction theOwner () public view returns (address) {\r\n     \r\n     return owner;\r\n }\r\n \r\n \r\n/** Get balance */\r\n\r\n/* *********************************************** */\r\nfunction balanceOf (address _owner) public view returns (uint256 balance) {\r\n\r\n    return accounts [_owner];\r\n}\r\n\r\n\r\n/** Transfer given number of tokens from message sender to given recipient.\r\n * @param _to address to transfer tokens to the owner of\r\n * @param _value number of tokens to transfer to the owner of given address\r\n * @return true if tokens were transferred successfully, false otherwise */\r\n \r\n /* *********************************************** */\r\n function transfer (address _to, uint256 _value)\r\n public validDestination(_to) returns (bool success) {\r\n    \r\n    require (accounts [msg.sender]>=_value);\r\n    \r\n    uint256 fromBalance = accounts [msg.sender];\r\n    if (fromBalance < _value) return false;\r\n    \r\n    if (stage != Stage.ICO){\r\n        accounts [msg.sender] = fromBalance.safeSub(_value);\r\n        accounts [_to] = accounts[_to].safeAdd(_value);\r\n    }\r\n    else if (msg.sender == owner){ // stage == Stage.ICO\r\n        accounts [msg.sender] = fromBalance.safeSub(_value);\r\n        accounts [_to] = accounts[_to].safeAdd(_value);\r\n        tokenICO = tokenICO.safeAdd(_value);\r\n    }\r\n    else if (_to == owner){ // stage == Stage.ICO\r\n        accounts [msg.sender] = fromBalance.safeSub(_value);\r\n        accounts [_to] = accounts[_to].safeAdd(_value);\r\n        tokenICO = tokenICO.safeSub(_value);\r\n    }\r\n    else if (forPartners[msg.sender] >= _value){ // (sender is Partner)\r\n        accounts [msg.sender] = fromBalance.safeSub(_value);\r\n        forPartners [msg.sender] = forPartners[msg.sender].safeSub(_value);\r\n        accounts [_to] = accounts[_to].safeAdd(_value);\r\n    }\r\n    else revert();\r\n    \r\n    emit Transfer (msg.sender, _to, _value);\r\n    return true;\r\n}\r\n\r\n\r\n/** Transfer given number of tokens from given owner to given recipient.\r\n * @param _from address to transfer tokens from the owner of\r\n * @param _to address to transfer tokens to the owner of\r\n * @param _value number of tokens to transfer from given owner to given\r\n *        recipient\r\n * @return true if tokens were transferred successfully, false otherwise */\r\n \r\n/* *********************************************** */\r\nfunction transferFrom (address _from, address _to, uint256 _value)\r\npublic validDestination(_to) returns (bool success) {\r\n\r\n    require (stage != Stage.ICO);\r\n    require(_from!=_to);\r\n    uint256 spenderAllowance = allowances [_from][msg.sender];\r\n    if (spenderAllowance < _value) return false;\r\n    uint256 fromBalance = accounts [_from];\r\n    if (fromBalance < _value) return false;\r\n\r\n    allowances [_from][msg.sender] =  spenderAllowance.safeSub(_value);\r\n\r\n    if (_value > 0) {\r\n      accounts [_from] = fromBalance.safeSub(_value);\r\n      accounts [_to] = accounts[_to].safeAdd(_value);\r\n    }\r\n    emit Transfer (_from, _to, _value);\r\n    return true;\r\n}\r\n\r\n\r\n/** Allow given spender to transfer given number of tokens from message sender\r\n * @param _spender address to allow the owner of to transfer tokens from\r\n *        message sender\r\n * @param _value number of tokens to allow to transfer\r\n * @return true if token transfer was successfully approved, false otherwise */\r\n \r\n/* *********************************************** */\r\nfunction approve (address _spender, uint256 _value)\r\npublic returns (bool success) {\r\n    require(_spender != address(0));\r\n    \r\n    allowances [msg.sender][_spender] = _value;\r\n    emit Approval (msg.sender, _spender, _value);\r\n    return true;\r\n}\r\n\r\n\r\n/** Allow Partner to transfer given number of tokens \r\n * @param _partner Partner address \r\n * @param _value number of tokens to allow to transfer\r\n * @return true if token transfer was successfully approved, false otherwise */\r\n \r\n/* *********************************************** */\r\nfunction addToPartner (address _partner, uint256 _value)\r\npublic returns (bool success) {\r\n    \r\n    require (msg.sender == owner);\r\n    forPartners [_partner] = forPartners[_partner].safeAdd(_value);\r\n    return true;\r\n}\r\n\r\n/** Disallow Partner to transfer given number of tokens \r\n * @param _partner Partner address\r\n * @param _value number of tokens to allow to transfer\r\n * @return true if token transfer was successfully approved, false otherwise */\r\n\r\n/* *********************************************** */\r\nfunction subFromPartner (address _partner, uint256 _value)\r\npublic returns (bool success) {\r\n    \r\n    require (msg.sender == owner);\r\n    if (forPartners [_partner] < _value) {\r\n        forPartners [_partner] = 0;\r\n    }\r\n    else {\r\n        forPartners [_partner] = forPartners[_partner].safeSub(_value);\r\n    }\r\n    return true;\r\n}\r\n\r\n/** Tell how many tokens given partner is currently allowed to transfer from\r\n  given him.\r\n  @param _partner address to get number of tokens allowed to be transferred         \r\n  @return number of tokens given spender is currently allowed to transfer\r\n  from given owner */\r\n  \r\n/* *********************************************** */\r\nfunction partners (address _partner)\r\npublic view returns (uint256 remaining) {\r\n\r\n    return forPartners [_partner];\r\n  }\r\n\r\n\r\n/** Create _value new tokens and give new created tokens to msg.sender.\r\n * May only be called by smart contract owner.\r\n * @param _value number of tokens to create\r\n * @return true if tokens were created successfully, false otherwise*/\r\n \r\n/* *********************************************** */\r\nfunction createTokens (uint256 _value) public returns (bool) {\r\n\r\n    require (msg.sender == mint);\r\n    \r\n    if (_value > 0) {\r\n        if (_value > MAX_TOKEN_COUNT.safeSub(tokenCount)) return false;\r\n        accounts [msg.sender] = accounts[msg.sender].safeAdd(_value);\r\n        tokenCount = tokenCount.safeAdd(_value);\r\n        emit Transfer (address (0), msg.sender, _value);\r\n    }\r\n    return true;\r\n}\r\n\r\n\r\n/** Burn given number of tokens belonging to owner.\r\n * May only be called by smart contract owner.\r\n * @param _value number of tokens to burn\r\n * @return true on success, false on error */\r\n \r\n/* *********************************************** */\r\nfunction burnTokens (uint256 _value) public returns (bool) {\r\n\r\n    require (msg.sender == mint);\r\n    require (accounts [msg.sender]>=_value);\r\n    \r\n    if (_value > accounts [mint]) return false;\r\n    else if (_value > 0) {\r\n        accounts [mint] = accounts[mint].safeSub(_value);\r\n        tokenCount = tokenCount.safeSub(_value);\r\n        emit Transfer (mint, address (0), _value);\r\n        return true;\r\n    }\r\n    else return true;\r\n}\r\n\r\n\r\n/** Set new owner for the smart contract.\r\n * May only be called by smart contract owner.\r\n * @param _newOwner address of new owner of the smart contract */\r\n \r\n/* *********************************************** */\r\nfunction setOwner (address _newOwner) public validDestination(_newOwner) {\r\n \r\n    require (msg.sender == owner);\r\n    \r\n    owner = _newOwner;\r\n    uint256 fromBalance = accounts [msg.sender];\r\n    if (fromBalance > 0 && msg.sender != _newOwner) {\r\n        accounts [msg.sender] = fromBalance.safeSub(fromBalance);\r\n        accounts [_newOwner] = accounts[_newOwner].safeAdd(fromBalance);\r\n        emit Transfer (msg.sender, _newOwner, fromBalance);\r\n    }\r\n}\r\n\r\n/** Set new owner for the smart contract.\r\n * May only be called by smart contract owner.\r\n * @param _newMint address of new owner of the smart contract */\r\n\r\n/* *********************************************** */\r\nfunction setMint (address _newMint) public {\r\n \r\n if (stage != Stage.LIFE && (msg.sender == owner || msg.sender == mint )){\r\n    mint = _newMint;\r\n }\r\n else if (msg.sender == mint){\r\n    mint = _newMint;\r\n }\r\n else revert();\r\n}\r\n\r\n/** Chech and Get current stage\r\n * @return current stage */\r\n \r\n/* *********************************************** */\r\nfunction checkStage () public returns (Stage) {\r\n\r\n    require (stage != Stage.LIFE);\r\n    \r\n    Stage currentStage = stage;\r\n    if (currentStage == Stage.ICO) {\r\n        if (block.timestamp >= LIFE_START_TIME || tokenICO > LIFE_START_TOKENS) {\r\n            currentStage = Stage.LIFE;\r\n            stage = Stage.LIFE;\r\n        }\r\n    else return currentStage;\r\n    }\r\n    return currentStage;\r\n}\r\n\r\n/** Change stage by Owner */\r\n\r\n/* *********************************************** */\r\nfunction changeStage () public {\r\n    \r\n    require (msg.sender == owner);\r\n    require (stage != Stage.LIFE);\r\n    if (stage == Stage.ICO) {stage = Stage.LIFEBYOWNER;}\r\n    else stage = Stage.ICO;\r\n}\r\n\r\n\r\n\r\n/** Tell how many tokens given spender is currently allowed to transfer from\r\n * given owner.\r\n * @param _owner address to get number of tokens allowed to be transferred\r\n *        from the owner of\r\n * @param _spender address to get number of tokens allowed to be transferred\r\n *        by the owner of\r\n * @return number of tokens given spender is currently allowed to transfer\r\n *         from given owner */\r\n \r\n/* *********************************************** */\r\nfunction allowance (address _owner, address _spender)\r\npublic view returns (uint256 remaining) {\r\n\r\n    return allowances [_owner][_spender];\r\n  }\r\n\r\n/**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n   \r\n/* *********************************************** */\r\nfunction increaseAllowance(address spender, uint256 addedValue) public returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    allowances[msg.sender][spender] = allowances[msg.sender][spender].safeAdd(addedValue);\r\n    emit Approval(msg.sender, spender, allowances[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    allowances[msg.sender][spender] = allowances[msg.sender][spender].safeSub(subtractedValue);\r\n    emit Approval(msg.sender, spender, allowances[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n\r\n\r\n/** Get current time in seconds since epoch.\r\n * @return current time in seconds since epoch */\r\nfunction currentTime () public view returns (uint256) {\r\n    return block.timestamp;\r\n}\r\n\r\n/** Total number of tokens in circulation */\r\nuint256 private  tokenCount;\r\n\r\n/** Total number of tokens in ICO */\r\nuint256 private  tokenICO;\r\n\r\n/** Owner of the smart contract */\r\naddress private  owner;\r\n\r\n/** Mint of the smart contract */\r\naddress private  mint;\r\n\r\n\r\n  \r\nenum Stage {\r\n    ICO, // \r\n    LIFEBYOWNER,\r\n    LIFE// \r\n}\r\n  \r\n/** Last known stage of token*/\r\nStage private stage = Stage.ICO;\r\n  \r\n/** Mapping from addresses of token holders to the numbers of tokens belonging\r\n * to these token holders */\r\nmapping (address => uint256) private accounts;\r\n\r\n/** Mapping from addresses of partners to the numbers of tokens belonging\r\n * to these partners. */\r\nmapping (address => uint256) private forPartners;\r\n\r\n/** Mapping from addresses of token holders to the mapping of addresses of\r\n * spenders to the allowances set by these token holders to these spenders */\r\nmapping (address => mapping (address => uint256)) private allowances;\r\n\r\nmodifier validDestination (address to) {\r\n    require (to != address(0x0));\r\n    require (to != address(this));\r\n    _;\r\n}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addToPartner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMint\",\"type\":\"address\"}],\"name\":\"setMint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"createTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theMint\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"}],\"name\":\"partners\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"changeStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"subFromPartner\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"OrgonToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a567eaf35428e78df81d8d5cd83605e89b68f095525f934226eaad204341cbaf"}]}