{"status":"1","message":"OK","result":[{"SourceCode":"//  simple reputations store\r\n//  https://azimuth.network\r\n\r\npragma solidity 0.4.24;\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//  Imports\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n// OpenZeppelin's Owneable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// Azimuth's Azimuth.sol\r\n\r\n//  Azimuth: point state data contract\r\n//\r\n//    This contract is used for storing all data related to Azimuth points\r\n//    and their ownership. Consider this contract the Azimuth ledger.\r\n//\r\n//    It also contains permissions data, which ties in to ERC721\r\n//    functionality. Operators of an address are allowed to transfer\r\n//    ownership of all points owned by their associated address\r\n//    (ERC721's approveAll()). A transfer proxy is allowed to transfer\r\n//    ownership of a single point (ERC721's approve()).\r\n//    Separate from ERC721 are managers, assigned per point. They are\r\n//    allowed to perform \"low-impact\" operations on the owner's points,\r\n//    like configuring public keys and making escape requests.\r\n//\r\n//    Since data stores are difficult to upgrade, this contract contains\r\n//    as little actual business logic as possible. Instead, the data stored\r\n//    herein can only be modified by this contract's owner, which can be\r\n//    changed and is thus upgradable/replaceable.\r\n//\r\n//    This contract will be owned by the Ecliptic contract.\r\n//\r\ncontract Azimuth is Ownable\r\n{\r\n//\r\n//  Events\r\n//\r\n\r\n  //  OwnerChanged: :point is now owned by :owner\r\n  //\r\n  event OwnerChanged(uint32 indexed point, address indexed owner);\r\n\r\n  //  Activated: :point is now active\r\n  //\r\n  event Activated(uint32 indexed point);\r\n\r\n  //  Spawned: :prefix has spawned :child\r\n  //\r\n  event Spawned(uint32 indexed prefix, uint32 indexed child);\r\n\r\n  //  EscapeRequested: :point has requested a new :sponsor\r\n  //\r\n  event EscapeRequested(uint32 indexed point, uint32 indexed sponsor);\r\n\r\n  //  EscapeCanceled: :point's :sponsor request was canceled or rejected\r\n  //\r\n  event EscapeCanceled(uint32 indexed point, uint32 indexed sponsor);\r\n\r\n  //  EscapeAccepted: :point confirmed with a new :sponsor\r\n  //\r\n  event EscapeAccepted(uint32 indexed point, uint32 indexed sponsor);\r\n\r\n  //  LostSponsor: :point's :sponsor is now refusing it service\r\n  //\r\n  event LostSponsor(uint32 indexed point, uint32 indexed sponsor);\r\n\r\n  //  ChangedKeys: :point has new network public keys\r\n  //\r\n  event ChangedKeys( uint32 indexed point,\r\n                     bytes32 encryptionKey,\r\n                     bytes32 authenticationKey,\r\n                     uint32 cryptoSuiteVersion,\r\n                     uint32 keyRevisionNumber );\r\n\r\n  //  BrokeContinuity: :point has a new continuity number, :number\r\n  //\r\n  event BrokeContinuity(uint32 indexed point, uint32 number);\r\n\r\n  //  ChangedSpawnProxy: :spawnProxy can now spawn using :point\r\n  //\r\n  event ChangedSpawnProxy(uint32 indexed point, address indexed spawnProxy);\r\n\r\n  //  ChangedTransferProxy: :transferProxy can now transfer ownership of :point\r\n  //\r\n  event ChangedTransferProxy( uint32 indexed point,\r\n                              address indexed transferProxy );\r\n\r\n  //  ChangedManagementProxy: :managementProxy can now manage :point\r\n  //\r\n  event ChangedManagementProxy( uint32 indexed point,\r\n                                address indexed managementProxy );\r\n\r\n  //  ChangedVotingProxy: :votingProxy can now vote using :point\r\n  //\r\n  event ChangedVotingProxy(uint32 indexed point, address indexed votingProxy);\r\n\r\n  //  ChangedDns: dnsDomains have been updated\r\n  //\r\n  event ChangedDns(string primary, string secondary, string tertiary);\r\n\r\n//\r\n//  Structures\r\n//\r\n\r\n  //  Size: kinds of points registered on-chain\r\n  //\r\n  //    NOTE: the order matters, because of Solidity enum numbering\r\n  //\r\n  enum Size\r\n  {\r\n    Galaxy, // = 0\r\n    Star,   // = 1\r\n    Planet  // = 2\r\n  }\r\n\r\n  //  Point: state of a point\r\n  //\r\n  //    While the ordering of the struct members is semantically chaotic,\r\n  //    they are ordered to tightly pack them into Ethereum's 32-byte storage\r\n  //    slots, which reduces gas costs for some function calls.\r\n  //    The comment ticks indicate assumed slot boundaries.\r\n  //\r\n  struct Point\r\n  {\r\n    //  encryptionKey: (curve25519) encryption public key, or 0 for none\r\n    //\r\n    bytes32 encryptionKey;\r\n  //\r\n    //  authenticationKey: (ed25519) authentication public key, or 0 for none\r\n    //\r\n    bytes32 authenticationKey;\r\n  //\r\n    //  spawned: for stars and galaxies, all :active children\r\n    //\r\n    uint32[] spawned;\r\n  //\r\n    //  hasSponsor: true if the sponsor still supports the point\r\n    //\r\n    bool hasSponsor;\r\n\r\n    //  active: whether point can be linked\r\n    //\r\n    //    false: point belongs to prefix, cannot be configured or linked\r\n    //    true: point no longer belongs to prefix, can be configured and linked\r\n    //\r\n    bool active;\r\n\r\n    //  escapeRequested: true if the point has requested to change sponsors\r\n    //\r\n    bool escapeRequested;\r\n\r\n    //  sponsor: the point that supports this one on the network, or,\r\n    //           if :hasSponsor is false, the last point that supported it.\r\n    //           (by default, the point's half-width prefix)\r\n    //\r\n    uint32 sponsor;\r\n\r\n    //  escapeRequestedTo: if :escapeRequested is true, new sponsor requested\r\n    //\r\n    uint32 escapeRequestedTo;\r\n\r\n    //  cryptoSuiteVersion: version of the crypto suite used for the pubkeys\r\n    //\r\n    uint32 cryptoSuiteVersion;\r\n\r\n    //  keyRevisionNumber: incremented every time the public keys change\r\n    //\r\n    uint32 keyRevisionNumber;\r\n\r\n    //  continuityNumber: incremented to indicate network-side state loss\r\n    //\r\n    uint32 continuityNumber;\r\n  }\r\n\r\n  //  Deed: permissions for a point\r\n  //\r\n  struct Deed\r\n  {\r\n    //  owner: address that owns this point\r\n    //\r\n    address owner;\r\n\r\n    //  managementProxy: 0, or another address with the right to perform\r\n    //                   low-impact, managerial operations on this point\r\n    //\r\n    address managementProxy;\r\n\r\n    //  spawnProxy: 0, or another address with the right to spawn children\r\n    //              of this point\r\n    //\r\n    address spawnProxy;\r\n\r\n    //  votingProxy: 0, or another address with the right to vote as this point\r\n    //\r\n    address votingProxy;\r\n\r\n    //  transferProxy: 0, or another address with the right to transfer\r\n    //                 ownership of this point\r\n    //\r\n    address transferProxy;\r\n  }\r\n\r\n//\r\n//  General state\r\n//\r\n\r\n  //  points: per point, general network-relevant point state\r\n  //\r\n  mapping(uint32 => Point) public points;\r\n\r\n  //  rights: per point, on-chain ownership and permissions\r\n  //\r\n  mapping(uint32 => Deed) public rights;\r\n\r\n  //  operators: per owner, per address, has the right to transfer ownership\r\n  //             of all the owner's points (ERC721)\r\n  //\r\n  mapping(address => mapping(address => bool)) public operators;\r\n\r\n  //  dnsDomains: base domains for contacting galaxies\r\n  //\r\n  //    dnsDomains[0] is primary, the others are used as fallbacks\r\n  //\r\n  string[3] public dnsDomains;\r\n\r\n//\r\n//  Lookups\r\n//\r\n\r\n  //  sponsoring: per point, the points they are sponsoring\r\n  //\r\n  mapping(uint32 => uint32[]) public sponsoring;\r\n\r\n  //  sponsoringIndexes: per point, per point, (index + 1) in\r\n  //                     the sponsoring array\r\n  //\r\n  mapping(uint32 => mapping(uint32 => uint256)) public sponsoringIndexes;\r\n\r\n  //  escapeRequests: per point, the points they have open escape requests from\r\n  //\r\n  mapping(uint32 => uint32[]) public escapeRequests;\r\n\r\n  //  escapeRequestsIndexes: per point, per point, (index + 1) in\r\n  //                         the escapeRequests array\r\n  //\r\n  mapping(uint32 => mapping(uint32 => uint256)) public escapeRequestsIndexes;\r\n\r\n  //  pointsOwnedBy: per address, the points they own\r\n  //\r\n  mapping(address => uint32[]) public pointsOwnedBy;\r\n\r\n  //  pointOwnerIndexes: per owner, per point, (index + 1) in\r\n  //                     the pointsOwnedBy array\r\n  //\r\n  //    We delete owners by moving the last entry in the array to the\r\n  //    newly emptied slot, which is (n - 1) where n is the value of\r\n  //    pointOwnerIndexes[owner][point].\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public pointOwnerIndexes;\r\n\r\n  //  managerFor: per address, the points they are the management proxy for\r\n  //\r\n  mapping(address => uint32[]) public managerFor;\r\n\r\n  //  managerForIndexes: per address, per point, (index + 1) in\r\n  //                     the managerFor array\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public managerForIndexes;\r\n\r\n  //  spawningFor: per address, the points they can spawn with\r\n  //\r\n  mapping(address => uint32[]) public spawningFor;\r\n\r\n  //  spawningForIndexes: per address, per point, (index + 1) in\r\n  //                      the spawningFor array\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public spawningForIndexes;\r\n\r\n  //  votingFor: per address, the points they can vote with\r\n  //\r\n  mapping(address => uint32[]) public votingFor;\r\n\r\n  //  votingForIndexes: per address, per point, (index + 1) in\r\n  //                    the votingFor array\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public votingForIndexes;\r\n\r\n  //  transferringFor: per address, the points they can transfer\r\n  //\r\n  mapping(address => uint32[]) public transferringFor;\r\n\r\n  //  transferringForIndexes: per address, per point, (index + 1) in\r\n  //                          the transferringFor array\r\n  //\r\n  mapping(address => mapping(uint32 => uint256)) public transferringForIndexes;\r\n\r\n//\r\n//  Logic\r\n//\r\n\r\n  //  constructor(): configure default dns domains\r\n  //\r\n  constructor()\r\n    public\r\n  {\r\n    setDnsDomains(\"example.com\", \"example.com\", \"example.com\");\r\n  }\r\n\r\n  //  setDnsDomains(): set the base domains used for contacting galaxies\r\n  //\r\n  //    Note: since a string is really just a byte[], and Solidity can't\r\n  //    work with two-dimensional arrays yet, we pass in the three\r\n  //    domains as individual strings.\r\n  //\r\n  function setDnsDomains(string _primary, string _secondary, string _tertiary)\r\n    onlyOwner\r\n    public\r\n  {\r\n    dnsDomains[0] = _primary;\r\n    dnsDomains[1] = _secondary;\r\n    dnsDomains[2] = _tertiary;\r\n    emit ChangedDns(_primary, _secondary, _tertiary);\r\n  }\r\n\r\n  //\r\n  //  Point reading\r\n  //\r\n\r\n    //  isActive(): return true if _point is active\r\n    //\r\n    function isActive(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool equals)\r\n    {\r\n      return points[_point].active;\r\n    }\r\n\r\n    //  getKeys(): returns the public keys and their details, as currently\r\n    //             registered for _point\r\n    //\r\n    function getKeys(uint32 _point)\r\n      view\r\n      external\r\n      returns (bytes32 crypt, bytes32 auth, uint32 suite, uint32 revision)\r\n    {\r\n      Point storage point = points[_point];\r\n      return (point.encryptionKey,\r\n              point.authenticationKey,\r\n              point.cryptoSuiteVersion,\r\n              point.keyRevisionNumber);\r\n    }\r\n\r\n    //  getKeyRevisionNumber(): gets the revision number of _point's current\r\n    //                          public keys\r\n    //\r\n    function getKeyRevisionNumber(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 revision)\r\n    {\r\n      return points[_point].keyRevisionNumber;\r\n    }\r\n\r\n    //  hasBeenLinked(): returns true if the point has ever been assigned keys\r\n    //\r\n    function hasBeenLinked(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return ( points[_point].keyRevisionNumber > 0 );\r\n    }\r\n\r\n    //  isLive(): returns true if _point currently has keys properly configured\r\n    //\r\n    function isLive(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Point storage point = points[_point];\r\n      return ( point.encryptionKey != 0 &&\r\n               point.authenticationKey != 0 &&\r\n               point.cryptoSuiteVersion != 0 );\r\n    }\r\n\r\n    //  getContinuityNumber(): returns _point's current continuity number\r\n    //\r\n    function getContinuityNumber(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 continuityNumber)\r\n    {\r\n      return points[_point].continuityNumber;\r\n    }\r\n\r\n    //  getSpawnCount(): return the number of children spawned by _point\r\n    //\r\n    function getSpawnCount(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 spawnCount)\r\n    {\r\n      uint256 len = points[_point].spawned.length;\r\n      assert(len < 2**32);\r\n      return uint32(len);\r\n    }\r\n\r\n    //  getSpawned(): return array of points created under _point\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getSpawned(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32[] spawned)\r\n    {\r\n      return points[_point].spawned;\r\n    }\r\n\r\n    //  hasSponsor(): returns true if _point's sponsor is providing it service\r\n    //\r\n    function hasSponsor(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool has)\r\n    {\r\n      return points[_point].hasSponsor;\r\n    }\r\n\r\n    //  getSponsor(): returns _point's current (or most recent) sponsor\r\n    //\r\n    function getSponsor(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 sponsor)\r\n    {\r\n      return points[_point].sponsor;\r\n    }\r\n\r\n    //  isSponsor(): returns true if _sponsor is currently providing service\r\n    //               to _point\r\n    //\r\n    function isSponsor(uint32 _point, uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Point storage point = points[_point];\r\n      return ( point.hasSponsor &&\r\n               (point.sponsor == _sponsor) );\r\n    }\r\n\r\n    //  getSponsoringCount(): returns the number of points _sponsor is\r\n    //                        providing service to\r\n    //\r\n    function getSponsoringCount(uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return sponsoring[_sponsor].length;\r\n    }\r\n\r\n    //  getSponsoring(): returns a list of points _sponsor is providing\r\n    //                   service to\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getSponsoring(uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (uint32[] sponsees)\r\n    {\r\n      return sponsoring[_sponsor];\r\n    }\r\n\r\n    //  escaping\r\n\r\n    //  isEscaping(): returns true if _point has an outstanding escape request\r\n    //\r\n    function isEscaping(uint32 _point)\r\n      view\r\n      external\r\n      returns (bool escaping)\r\n    {\r\n      return points[_point].escapeRequested;\r\n    }\r\n\r\n    //  getEscapeRequest(): returns _point's current escape request\r\n    //\r\n    //    the returned escape request is only valid as long as isEscaping()\r\n    //    returns true\r\n    //\r\n    function getEscapeRequest(uint32 _point)\r\n      view\r\n      external\r\n      returns (uint32 escape)\r\n    {\r\n      return points[_point].escapeRequestedTo;\r\n    }\r\n\r\n    //  isRequestingEscapeTo(): returns true if _point has an outstanding\r\n    //                          escape request targetting _sponsor\r\n    //\r\n    function isRequestingEscapeTo(uint32 _point, uint32 _sponsor)\r\n      view\r\n      public\r\n      returns (bool equals)\r\n    {\r\n      Point storage point = points[_point];\r\n      return (point.escapeRequested && (point.escapeRequestedTo == _sponsor));\r\n    }\r\n\r\n    //  getEscapeRequestsCount(): returns the number of points _sponsor\r\n    //                            is providing service to\r\n    //\r\n    function getEscapeRequestsCount(uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return escapeRequests[_sponsor].length;\r\n    }\r\n\r\n    //  getEscapeRequests(): get the points _sponsor has received escape\r\n    //                       requests from\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getEscapeRequests(uint32 _sponsor)\r\n      view\r\n      external\r\n      returns (uint32[] requests)\r\n    {\r\n      return escapeRequests[_sponsor];\r\n    }\r\n\r\n  //\r\n  //  Point writing\r\n  //\r\n\r\n    //  activatePoint(): activate a point, register it as spawned by its prefix\r\n    //\r\n    function activatePoint(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      //  make a point active, setting its sponsor to its prefix\r\n      //\r\n      Point storage point = points[_point];\r\n      require(!point.active);\r\n      point.active = true;\r\n      registerSponsor(_point, true, getPrefix(_point));\r\n      emit Activated(_point);\r\n    }\r\n\r\n    //  setKeys(): set network public keys of _point to _encryptionKey and\r\n    //            _authenticationKey, with the specified _cryptoSuiteVersion\r\n    //\r\n    function setKeys(uint32 _point,\r\n                     bytes32 _encryptionKey,\r\n                     bytes32 _authenticationKey,\r\n                     uint32 _cryptoSuiteVersion)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      if ( point.encryptionKey == _encryptionKey &&\r\n           point.authenticationKey == _authenticationKey &&\r\n           point.cryptoSuiteVersion == _cryptoSuiteVersion )\r\n      {\r\n        return;\r\n      }\r\n\r\n      point.encryptionKey = _encryptionKey;\r\n      point.authenticationKey = _authenticationKey;\r\n      point.cryptoSuiteVersion = _cryptoSuiteVersion;\r\n      point.keyRevisionNumber++;\r\n\r\n      emit ChangedKeys(_point,\r\n                       _encryptionKey,\r\n                       _authenticationKey,\r\n                       _cryptoSuiteVersion,\r\n                       point.keyRevisionNumber);\r\n    }\r\n\r\n    //  incrementContinuityNumber(): break continuity for _point\r\n    //\r\n    function incrementContinuityNumber(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      point.continuityNumber++;\r\n      emit BrokeContinuity(_point, point.continuityNumber);\r\n    }\r\n\r\n    //  registerSpawn(): add a point to its prefix's list of spawned points\r\n    //\r\n    function registerSpawned(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      //  if a point is its own prefix (a galaxy) then don't register it\r\n      //\r\n      uint32 prefix = getPrefix(_point);\r\n      if (prefix == _point)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  register a new spawned point for the prefix\r\n      //\r\n      points[prefix].spawned.push(_point);\r\n      emit Spawned(prefix, _point);\r\n    }\r\n\r\n    //  loseSponsor(): indicates that _point's sponsor is no longer providing\r\n    //                 it service\r\n    //\r\n    function loseSponsor(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      if (!point.hasSponsor)\r\n      {\r\n        return;\r\n      }\r\n      registerSponsor(_point, false, point.sponsor);\r\n      emit LostSponsor(_point, point.sponsor);\r\n    }\r\n\r\n    //  setEscapeRequest(): for _point, start an escape request to _sponsor\r\n    //\r\n    function setEscapeRequest(uint32 _point, uint32 _sponsor)\r\n      onlyOwner\r\n      external\r\n    {\r\n      if (isRequestingEscapeTo(_point, _sponsor))\r\n      {\r\n        return;\r\n      }\r\n      registerEscapeRequest(_point, true, _sponsor);\r\n      emit EscapeRequested(_point, _sponsor);\r\n    }\r\n\r\n    //  cancelEscape(): for _point, stop the current escape request, if any\r\n    //\r\n    function cancelEscape(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      if (!point.escapeRequested)\r\n      {\r\n        return;\r\n      }\r\n      uint32 request = point.escapeRequestedTo;\r\n      registerEscapeRequest(_point, false, 0);\r\n      emit EscapeCanceled(_point, request);\r\n    }\r\n\r\n    //  doEscape(): perform the requested escape\r\n    //\r\n    function doEscape(uint32 _point)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Point storage point = points[_point];\r\n      require(point.escapeRequested);\r\n      registerSponsor(_point, true, point.escapeRequestedTo);\r\n      registerEscapeRequest(_point, false, 0);\r\n      emit EscapeAccepted(_point, point.sponsor);\r\n    }\r\n\r\n  //\r\n  //  Point utils\r\n  //\r\n\r\n    //  getPrefix(): compute prefix (\"parent\") of _point\r\n    //\r\n    function getPrefix(uint32 _point)\r\n      pure\r\n      public\r\n      returns (uint16 prefix)\r\n    {\r\n      if (_point < 0x10000)\r\n      {\r\n        return uint16(_point % 0x100);\r\n      }\r\n      return uint16(_point % 0x10000);\r\n    }\r\n\r\n    //  getPointSize(): return the size of _point\r\n    //\r\n    function getPointSize(uint32 _point)\r\n      external\r\n      pure\r\n      returns (Size _size)\r\n    {\r\n      if (_point < 0x100) return Size.Galaxy;\r\n      if (_point < 0x10000) return Size.Star;\r\n      return Size.Planet;\r\n    }\r\n\r\n    //  internal use\r\n\r\n    //  registerSponsor(): set the sponsorship state of _point and update the\r\n    //                     reverse lookup for sponsors\r\n    //\r\n    function registerSponsor(uint32 _point, bool _hasSponsor, uint32 _sponsor)\r\n      internal\r\n    {\r\n      Point storage point = points[_point];\r\n      bool had = point.hasSponsor;\r\n      uint32 prev = point.sponsor;\r\n\r\n      //  if we didn't have a sponsor, and won't get one,\r\n      //  or if we get the sponsor we already have,\r\n      //  nothing will change, so jump out early.\r\n      //\r\n      if ( (!had && !_hasSponsor) ||\r\n           (had && _hasSponsor && prev == _sponsor) )\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different sponsor, do some gymnastics\r\n      //  to keep the reverse lookup gapless.  delete the point from the old\r\n      //  sponsor's list, then fill that gap with the list tail.\r\n      //\r\n      if (had)\r\n      {\r\n        //  i: current index in previous sponsor's list of sponsored points\r\n        //\r\n        uint256 i = sponsoringIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :sponsoringIndexes reference\r\n        //\r\n        uint32[] storage prevSponsoring = sponsoring[prev];\r\n        uint256 last = prevSponsoring.length - 1;\r\n        uint32 moved = prevSponsoring[last];\r\n        prevSponsoring[i] = moved;\r\n        sponsoringIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevSponsoring[last]);\r\n        prevSponsoring.length = last;\r\n        sponsoringIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (_hasSponsor)\r\n      {\r\n        uint32[] storage newSponsoring = sponsoring[_sponsor];\r\n        newSponsoring.push(_point);\r\n        sponsoringIndexes[_sponsor][_point] = newSponsoring.length;\r\n      }\r\n\r\n      point.sponsor = _sponsor;\r\n      point.hasSponsor = _hasSponsor;\r\n    }\r\n\r\n    //  registerEscapeRequest(): set the escape state of _point and update the\r\n    //                           reverse lookup for sponsors\r\n    //\r\n    function registerEscapeRequest( uint32 _point,\r\n                                    bool _isEscaping, uint32 _sponsor )\r\n      internal\r\n    {\r\n      Point storage point = points[_point];\r\n      bool was = point.escapeRequested;\r\n      uint32 prev = point.escapeRequestedTo;\r\n\r\n      //  if we weren't escaping, and won't be,\r\n      //  or if we were escaping, and the new target is the same,\r\n      //  nothing will change, so jump out early.\r\n      //\r\n      if ( (!was && !_isEscaping) ||\r\n           (was && _isEscaping && prev == _sponsor) )\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different request, do some gymnastics\r\n      //  to keep the reverse lookup gapless.  delete the point from the old\r\n      //  sponsor's list, then fill that gap with the list tail.\r\n      //\r\n      if (was)\r\n      {\r\n        //  i: current index in previous sponsor's list of sponsored points\r\n        //\r\n        uint256 i = escapeRequestsIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :escapeRequestsIndexes reference\r\n        //\r\n        uint32[] storage prevRequests = escapeRequests[prev];\r\n        uint256 last = prevRequests.length - 1;\r\n        uint32 moved = prevRequests[last];\r\n        prevRequests[i] = moved;\r\n        escapeRequestsIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevRequests[last]);\r\n        prevRequests.length = last;\r\n        escapeRequestsIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (_isEscaping)\r\n      {\r\n        uint32[] storage newRequests = escapeRequests[_sponsor];\r\n        newRequests.push(_point);\r\n        escapeRequestsIndexes[_sponsor][_point] = newRequests.length;\r\n      }\r\n\r\n      point.escapeRequestedTo = _sponsor;\r\n      point.escapeRequested = _isEscaping;\r\n    }\r\n\r\n  //\r\n  //  Deed reading\r\n  //\r\n\r\n    //  owner\r\n\r\n    //  getOwner(): return owner of _point\r\n    //\r\n    function getOwner(uint32 _point)\r\n      view\r\n      external\r\n      returns (address owner)\r\n    {\r\n      return rights[_point].owner;\r\n    }\r\n\r\n    //  isOwner(): true if _point is owned by _address\r\n    //\r\n    function isOwner(uint32 _point, address _address)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].owner == _address);\r\n    }\r\n\r\n    //  getOwnedPointCount(): return length of array of points that _whose owns\r\n    //\r\n    function getOwnedPointCount(address _whose)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return pointsOwnedBy[_whose].length;\r\n    }\r\n\r\n    //  getOwnedPoints(): return array of points that _whose owns\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getOwnedPoints(address _whose)\r\n      view\r\n      external\r\n      returns (uint32[] ownedPoints)\r\n    {\r\n      return pointsOwnedBy[_whose];\r\n    }\r\n\r\n    //  getOwnedPointAtIndex(): get point at _index from array of points that\r\n    //                         _whose owns\r\n    //\r\n    function getOwnedPointAtIndex(address _whose, uint256 _index)\r\n      view\r\n      external\r\n      returns (uint32 point)\r\n    {\r\n      uint32[] storage owned = pointsOwnedBy[_whose];\r\n      require(_index < owned.length);\r\n      return owned[_index];\r\n    }\r\n\r\n    //  management proxy\r\n\r\n    //  getManagementProxy(): returns _point's current management proxy\r\n    //\r\n    function getManagementProxy(uint32 _point)\r\n      view\r\n      external\r\n      returns (address manager)\r\n    {\r\n      return rights[_point].managementProxy;\r\n    }\r\n\r\n    //  isManagementProxy(): returns true if _proxy is _point's management proxy\r\n    //\r\n    function isManagementProxy(uint32 _point, address _proxy)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].managementProxy == _proxy);\r\n    }\r\n\r\n    //  canManage(): true if _who is the owner or manager of _point\r\n    //\r\n    function canManage(uint32 _point, address _who)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      return ( (0x0 != _who) &&\r\n               ( (_who == deed.owner) ||\r\n                 (_who == deed.managementProxy) ) );\r\n    }\r\n\r\n    //  getManagerForCount(): returns the amount of points _proxy can manage\r\n    //\r\n    function getManagerForCount(address _proxy)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return managerFor[_proxy].length;\r\n    }\r\n\r\n    //  getManagerFor(): returns the points _proxy can manage\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getManagerFor(address _proxy)\r\n      view\r\n      external\r\n      returns (uint32[] mfor)\r\n    {\r\n      return managerFor[_proxy];\r\n    }\r\n\r\n    //  spawn proxy\r\n\r\n    //  getSpawnProxy(): returns _point's current spawn proxy\r\n    //\r\n    function getSpawnProxy(uint32 _point)\r\n      view\r\n      external\r\n      returns (address spawnProxy)\r\n    {\r\n      return rights[_point].spawnProxy;\r\n    }\r\n\r\n    //  isSpawnProxy(): returns true if _proxy is _point's spawn proxy\r\n    //\r\n    function isSpawnProxy(uint32 _point, address _proxy)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].spawnProxy == _proxy);\r\n    }\r\n\r\n    //  canSpawnAs(): true if _who is the owner or spawn proxy of _point\r\n    //\r\n    function canSpawnAs(uint32 _point, address _who)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      return ( (0x0 != _who) &&\r\n               ( (_who == deed.owner) ||\r\n                 (_who == deed.spawnProxy) ) );\r\n    }\r\n\r\n    //  getSpawningForCount(): returns the amount of points _proxy\r\n    //                         can spawn with\r\n    //\r\n    function getSpawningForCount(address _proxy)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return spawningFor[_proxy].length;\r\n    }\r\n\r\n    //  getSpawningFor(): get the points _proxy can spawn with\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getSpawningFor(address _proxy)\r\n      view\r\n      external\r\n      returns (uint32[] sfor)\r\n    {\r\n      return spawningFor[_proxy];\r\n    }\r\n\r\n    //  voting proxy\r\n\r\n    //  getVotingProxy(): returns _point's current voting proxy\r\n    //\r\n    function getVotingProxy(uint32 _point)\r\n      view\r\n      external\r\n      returns (address voter)\r\n    {\r\n      return rights[_point].votingProxy;\r\n    }\r\n\r\n    //  isVotingProxy(): returns true if _proxy is _point's voting proxy\r\n    //\r\n    function isVotingProxy(uint32 _point, address _proxy)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].votingProxy == _proxy);\r\n    }\r\n\r\n    //  canVoteAs(): true if _who is the owner of _point,\r\n    //               or the voting proxy of _point's owner\r\n    //\r\n    function canVoteAs(uint32 _point, address _who)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      return ( (0x0 != _who) &&\r\n               ( (_who == deed.owner) ||\r\n                 (_who == deed.votingProxy) ) );\r\n    }\r\n\r\n    //  getVotingForCount(): returns the amount of points _proxy can vote as\r\n    //\r\n    function getVotingForCount(address _proxy)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return votingFor[_proxy].length;\r\n    }\r\n\r\n    //  getVotingFor(): returns the points _proxy can vote as\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getVotingFor(address _proxy)\r\n      view\r\n      external\r\n      returns (uint32[] vfor)\r\n    {\r\n      return votingFor[_proxy];\r\n    }\r\n\r\n    //  transfer proxy\r\n\r\n    //  getTransferProxy(): returns _point's current transfer proxy\r\n    //\r\n    function getTransferProxy(uint32 _point)\r\n      view\r\n      external\r\n      returns (address transferProxy)\r\n    {\r\n      return rights[_point].transferProxy;\r\n    }\r\n\r\n    //  isTransferProxy(): returns true if _proxy is _point's transfer proxy\r\n    //\r\n    function isTransferProxy(uint32 _point, address _proxy)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return (rights[_point].transferProxy == _proxy);\r\n    }\r\n\r\n    //  canTransfer(): true if _who is the owner or transfer proxy of _point,\r\n    //                 or is an operator for _point's current owner\r\n    //\r\n    function canTransfer(uint32 _point, address _who)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      return ( (0x0 != _who) &&\r\n               ( (_who == deed.owner) ||\r\n                 (_who == deed.transferProxy) ||\r\n                 operators[deed.owner][_who] ) );\r\n    }\r\n\r\n    //  getTransferringForCount(): returns the amount of points _proxy\r\n    //                             can transfer\r\n    //\r\n    function getTransferringForCount(address _proxy)\r\n      view\r\n      external\r\n      returns (uint256 count)\r\n    {\r\n      return transferringFor[_proxy].length;\r\n    }\r\n\r\n    //  getTransferringFor(): get the points _proxy can transfer\r\n    //\r\n    //    Note: only useful for clients, as Solidity does not currently\r\n    //    support returning dynamic arrays.\r\n    //\r\n    function getTransferringFor(address _proxy)\r\n      view\r\n      external\r\n      returns (uint32[] tfor)\r\n    {\r\n      return transferringFor[_proxy];\r\n    }\r\n\r\n    //  isOperator(): returns true if _operator is allowed to transfer\r\n    //                ownership of _owner's points\r\n    //\r\n    function isOperator(address _owner, address _operator)\r\n      view\r\n      external\r\n      returns (bool result)\r\n    {\r\n      return operators[_owner][_operator];\r\n    }\r\n\r\n  //\r\n  //  Deed writing\r\n  //\r\n\r\n    //  setOwner(): set owner of _point to _owner\r\n    //\r\n    //    Note: setOwner() only implements the minimal data storage\r\n    //    logic for a transfer; the full transfer is implemented in\r\n    //    Ecliptic.\r\n    //\r\n    //    Note: _owner must not be the zero address.\r\n    //\r\n    function setOwner(uint32 _point, address _owner)\r\n      onlyOwner\r\n      external\r\n    {\r\n      //  prevent burning of points by making zero the owner\r\n      //\r\n      require(0x0 != _owner);\r\n\r\n      //  prev: previous owner, if any\r\n      //\r\n      address prev = rights[_point].owner;\r\n\r\n      if (prev == _owner)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different owner, do some gymnastics to\r\n      //  keep the list of owned points gapless.  delete this point from the\r\n      //  list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous owner's list of owned points\r\n        //\r\n        uint256 i = pointOwnerIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :pointOwnerIndexes reference\r\n        //\r\n        uint32[] storage owner = pointsOwnedBy[prev];\r\n        uint256 last = owner.length - 1;\r\n        uint32 moved = owner[last];\r\n        owner[i] = moved;\r\n        pointOwnerIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(owner[last]);\r\n        owner.length = last;\r\n        pointOwnerIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      //  update the owner list and the owner's index list\r\n      //\r\n      rights[_point].owner = _owner;\r\n      pointsOwnedBy[_owner].push(_point);\r\n      pointOwnerIndexes[_owner][_point] = pointsOwnedBy[_owner].length;\r\n      emit OwnerChanged(_point, _owner);\r\n    }\r\n\r\n    //  setManagementProxy(): makes _proxy _point's management proxy\r\n    //\r\n    function setManagementProxy(uint32 _point, address _proxy)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      address prev = deed.managementProxy;\r\n      if (prev == _proxy)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different manager, do some gymnastics\r\n      //  to keep the reverse lookup gapless.  delete the point from the\r\n      //  old manager's list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous manager's list of managed points\r\n        //\r\n        uint256 i = managerForIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :managerForIndexes reference\r\n        //\r\n        uint32[] storage prevMfor = managerFor[prev];\r\n        uint256 last = prevMfor.length - 1;\r\n        uint32 moved = prevMfor[last];\r\n        prevMfor[i] = moved;\r\n        managerForIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevMfor[last]);\r\n        prevMfor.length = last;\r\n        managerForIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (0x0 != _proxy)\r\n      {\r\n        uint32[] storage mfor = managerFor[_proxy];\r\n        mfor.push(_point);\r\n        managerForIndexes[_proxy][_point] = mfor.length;\r\n      }\r\n\r\n      deed.managementProxy = _proxy;\r\n      emit ChangedManagementProxy(_point, _proxy);\r\n    }\r\n\r\n    //  setSpawnProxy(): makes _proxy _point's spawn proxy\r\n    //\r\n    function setSpawnProxy(uint32 _point, address _proxy)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      address prev = deed.spawnProxy;\r\n      if (prev == _proxy)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different spawn proxy, do some\r\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\r\n      //  from the old proxy's list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous proxy's list of spawning points\r\n        //\r\n        uint256 i = spawningForIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :spawningForIndexes reference\r\n        //\r\n        uint32[] storage prevSfor = spawningFor[prev];\r\n        uint256 last = prevSfor.length - 1;\r\n        uint32 moved = prevSfor[last];\r\n        prevSfor[i] = moved;\r\n        spawningForIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevSfor[last]);\r\n        prevSfor.length = last;\r\n        spawningForIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (0x0 != _proxy)\r\n      {\r\n        uint32[] storage sfor = spawningFor[_proxy];\r\n        sfor.push(_point);\r\n        spawningForIndexes[_proxy][_point] = sfor.length;\r\n      }\r\n\r\n      deed.spawnProxy = _proxy;\r\n      emit ChangedSpawnProxy(_point, _proxy);\r\n    }\r\n\r\n    //  setVotingProxy(): makes _proxy _point's voting proxy\r\n    //\r\n    function setVotingProxy(uint32 _point, address _proxy)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      address prev = deed.votingProxy;\r\n      if (prev == _proxy)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different voter, do some gymnastics\r\n      //  to keep the reverse lookup gapless.  delete the point from the\r\n      //  old voter's list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous voter's list of points it was\r\n        //     voting for\r\n        //\r\n        uint256 i = votingForIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :votingForIndexes reference\r\n        //\r\n        uint32[] storage prevVfor = votingFor[prev];\r\n        uint256 last = prevVfor.length - 1;\r\n        uint32 moved = prevVfor[last];\r\n        prevVfor[i] = moved;\r\n        votingForIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevVfor[last]);\r\n        prevVfor.length = last;\r\n        votingForIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (0x0 != _proxy)\r\n      {\r\n        uint32[] storage vfor = votingFor[_proxy];\r\n        vfor.push(_point);\r\n        votingForIndexes[_proxy][_point] = vfor.length;\r\n      }\r\n\r\n      deed.votingProxy = _proxy;\r\n      emit ChangedVotingProxy(_point, _proxy);\r\n    }\r\n\r\n    //  setManagementProxy(): makes _proxy _point's transfer proxy\r\n    //\r\n    function setTransferProxy(uint32 _point, address _proxy)\r\n      onlyOwner\r\n      external\r\n    {\r\n      Deed storage deed = rights[_point];\r\n      address prev = deed.transferProxy;\r\n      if (prev == _proxy)\r\n      {\r\n        return;\r\n      }\r\n\r\n      //  if the point used to have a different transfer proxy, do some\r\n      //  gymnastics to keep the reverse lookup gapless.  delete the point\r\n      //  from the old proxy's list, then fill that gap with the list tail.\r\n      //\r\n      if (0x0 != prev)\r\n      {\r\n        //  i: current index in previous proxy's list of transferable points\r\n        //\r\n        uint256 i = transferringForIndexes[prev][_point];\r\n\r\n        //  we store index + 1, because 0 is the solidity default value\r\n        //\r\n        assert(i > 0);\r\n        i--;\r\n\r\n        //  copy the last item in the list into the now-unused slot,\r\n        //  making sure to update its :transferringForIndexes reference\r\n        //\r\n        uint32[] storage prevTfor = transferringFor[prev];\r\n        uint256 last = prevTfor.length - 1;\r\n        uint32 moved = prevTfor[last];\r\n        prevTfor[i] = moved;\r\n        transferringForIndexes[prev][moved] = i + 1;\r\n\r\n        //  delete the last item\r\n        //\r\n        delete(prevTfor[last]);\r\n        prevTfor.length = last;\r\n        transferringForIndexes[prev][_point] = 0;\r\n      }\r\n\r\n      if (0x0 != _proxy)\r\n      {\r\n        uint32[] storage tfor = transferringFor[_proxy];\r\n        tfor.push(_point);\r\n        transferringForIndexes[_proxy][_point] = tfor.length;\r\n      }\r\n\r\n      deed.transferProxy = _proxy;\r\n      emit ChangedTransferProxy(_point, _proxy);\r\n    }\r\n\r\n    //  setOperator(): dis/allow _operator to transfer ownership of all points\r\n    //                 owned by _owner\r\n    //\r\n    //    operators are part of the ERC721 standard\r\n    //\r\n    function setOperator(address _owner, address _operator, bool _approved)\r\n      onlyOwner\r\n      external\r\n    {\r\n      operators[_owner][_operator] = _approved;\r\n    }\r\n}\r\n\r\n// Azimuth's ReadsAzimuth.sol\r\n\r\n//  ReadsAzimuth: referring to and testing against the Azimuth\r\n//                data contract\r\n//\r\n//    To avoid needless repetition, this contract provides common\r\n//    checks and operations using the Azimuth contract.\r\n//\r\ncontract ReadsAzimuth\r\n{\r\n  //  azimuth: points data storage contract.\r\n  //\r\n  Azimuth public azimuth;\r\n\r\n  //  constructor(): set the Azimuth data contract's address\r\n  //\r\n  constructor(Azimuth _azimuth)\r\n    public\r\n  {\r\n    azimuth = _azimuth;\r\n  }\r\n\r\n  //  activePointOwner(): require that :msg.sender is the owner of _point,\r\n  //                      and that _point is active\r\n  //\r\n  modifier activePointOwner(uint32 _point)\r\n  {\r\n    require( azimuth.isOwner(_point, msg.sender) &&\r\n             azimuth.isActive(_point) );\r\n    _;\r\n  }\r\n\r\n  //  activePointManager(): require that :msg.sender can manage _point,\r\n  //                        and that _point is active\r\n  //\r\n  modifier activePointManager(uint32 _point)\r\n  {\r\n    require( azimuth.canManage(_point, msg.sender) &&\r\n             azimuth.isActive(_point) );\r\n    _;\r\n  }\r\n}\r\n\r\n////////////////////////////////////////////////////////////////////////////////\r\n//  Censures\r\n////////////////////////////////////////////////////////////////////////////////\r\n\r\n//  Censures: simple reputation management\r\n//\r\n//    This contract allows stars and galaxies to assign a negative\r\n//    reputation (censure) to other points of the same or lower rank.\r\n//    These censures are not permanent, they can be forgiven.\r\n//\r\n//    Since Azimuth-based networks provide incentives for good behavior,\r\n//    making bad behavior the exception rather than the rule, this\r\n//    contract only provides registration of negative reputation.\r\n//\r\ncontract Censures is ReadsAzimuth\r\n{\r\n  //  Censured: :who got censured by :by\r\n  //\r\n  event Censured(uint16 indexed by, uint32 indexed who);\r\n\r\n  //  Forgiven: :who is no longer censured by :by\r\n  //\r\n  event Forgiven(uint16 indexed by, uint32 indexed who);\r\n\r\n  //  censuring: per point, the points they're censuring\r\n  //\r\n  mapping(uint16 => uint32[]) public censuring;\r\n\r\n  //  censuredBy: per point, those who have censured them\r\n  //\r\n  mapping(uint32 => uint16[]) public censuredBy;\r\n\r\n  //  censuringIndexes: per point per censure, (index + 1) in censures array\r\n  //\r\n  //    We delete censures by moving the last entry in the array to the\r\n  //    newly emptied slot, which is (n - 1) where n is the value of\r\n  //    indexes[point][censure].\r\n  //\r\n  mapping(uint16 => mapping(uint32 => uint256)) public censuringIndexes;\r\n\r\n  //  censuredByIndexes: per censure per point, (index + 1) in censured array\r\n  //\r\n  //    see also explanation for indexes_censures above\r\n  //\r\n  mapping(uint32 => mapping(uint16 => uint256)) public censuredByIndexes;\r\n\r\n  //  constructor(): register the azimuth contract\r\n  //\r\n  constructor(Azimuth _azimuth)\r\n    ReadsAzimuth(_azimuth)\r\n    public\r\n  {\r\n    //\r\n  }\r\n\r\n  //  getCensuringCount(): return length of array of censures made by _whose\r\n  //\r\n  function getCensuringCount(uint16 _whose)\r\n    view\r\n    public\r\n    returns (uint256 count)\r\n  {\r\n    return censuring[_whose].length;\r\n  }\r\n\r\n  //  getCensuring(): return array of censures made by _whose\r\n  //\r\n  //    Note: only useful for clients, as Solidity does not currently\r\n  //    support returning dynamic arrays.\r\n  //\r\n  function getCensuring(uint16 _whose)\r\n    view\r\n    public\r\n    returns (uint32[] cens)\r\n  {\r\n    return censuring[_whose];\r\n  }\r\n\r\n  //  getCensuredByCount(): return length of array of censures made against _who\r\n  //\r\n  function getCensuredByCount(uint16 _who)\r\n    view\r\n    public\r\n    returns (uint256 count)\r\n  {\r\n    return censuredBy[_who].length;\r\n  }\r\n\r\n  //  getCensuredBy(): return array of censures made against _who\r\n  //\r\n  //    Note: only useful for clients, as Solidity does not currently\r\n  //    support returning dynamic arrays.\r\n  //\r\n  function getCensuredBy(uint16 _who)\r\n    view\r\n    public\r\n    returns (uint16[] cens)\r\n  {\r\n    return censuredBy[_who];\r\n  }\r\n\r\n  //  censure(): register a censure of _who as _as\r\n  //\r\n  function censure(uint16 _as, uint32 _who)\r\n    external\r\n    activePointManager(_as)\r\n  {\r\n    require( //  can't censure self\r\n             //\r\n             (_as != _who) &&\r\n             //\r\n             //  must not haven censured _who already\r\n             //\r\n             (censuringIndexes[_as][_who] == 0) );\r\n\r\n    //  only stars and galaxies may censure, and only galaxies may censure\r\n    //  other galaxies. (enum gets smaller for higher point sizes)\r\n    //  this function's signature makes sure planets cannot censure.\r\n    //\r\n    Azimuth.Size asSize = azimuth.getPointSize(_as);\r\n    Azimuth.Size whoSize = azimuth.getPointSize(_who);\r\n    require( whoSize >= asSize );\r\n\r\n    //  update contract state with the new censure\r\n    //\r\n    censuring[_as].push(_who);\r\n    censuringIndexes[_as][_who] = censuring[_as].length;\r\n\r\n    //  and update the reverse lookup\r\n    //\r\n    censuredBy[_who].push(_as);\r\n    censuredByIndexes[_who][_as] = censuredBy[_who].length;\r\n\r\n    emit Censured(_as, _who);\r\n  }\r\n\r\n  //  forgive(): unregister a censure of _who as _as\r\n  //\r\n  function forgive(uint16 _as, uint32 _who)\r\n    external\r\n    activePointManager(_as)\r\n  {\r\n    //  below, we perform the same logic twice: once on the canonical data,\r\n    //  and once on the reverse lookup\r\n    //\r\n    //  i: current index in _as's list of censures\r\n    //  j: current index in _who's list of points that have censured it\r\n    //\r\n    uint256 i = censuringIndexes[_as][_who];\r\n    uint256 j = censuredByIndexes[_who][_as];\r\n\r\n    //  we store index + 1, because 0 is the eth default value\r\n    //  can only delete an existing censure\r\n    //\r\n    require( (i > 0) && (j > 0) );\r\n    i--;\r\n    j--;\r\n\r\n    //  copy last item in the list into the now-unused slot,\r\n    //  making sure to update the :indexes_ references\r\n    //\r\n    uint32[] storage cens = censuring[_as];\r\n    uint16[] storage cend = censuredBy[_who];\r\n    uint256 lastCens = cens.length - 1;\r\n    uint256 lastCend = cend.length - 1;\r\n    uint32 movedCens = cens[lastCens];\r\n    uint16 movedCend = cend[lastCend];\r\n    cens[i] = movedCens;\r\n    cend[j] = movedCend;\r\n    censuringIndexes[_as][movedCens] = i + 1;\r\n    censuredByIndexes[_who][movedCend] = j + 1;\r\n\r\n    //  delete the last item\r\n    //\r\n    cens.length = lastCens;\r\n    cend.length = lastCend;\r\n    censuringIndexes[_as][_who] = 0;\r\n    censuredByIndexes[_who][_as] = 0;\r\n\r\n    emit Forgiven(_as, _who);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"uint16\"}],\"name\":\"getCensuredBy\",\"outputs\":[{\"name\":\"cens\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"censuring\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whose\",\"type\":\"uint16\"}],\"name\":\"getCensuringCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"censuredByIndexes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_as\",\"type\":\"uint16\"},{\"name\":\"_who\",\"type\":\"uint32\"}],\"name\":\"censure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whose\",\"type\":\"uint16\"}],\"name\":\"getCensuring\",\"outputs\":[{\"name\":\"cens\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"azimuth\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_as\",\"type\":\"uint16\"},{\"name\":\"_who\",\"type\":\"uint32\"}],\"name\":\"forgive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"censuringIndexes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"censuredBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"uint16\"}],\"name\":\"getCensuredByCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_azimuth\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"uint32\"}],\"name\":\"Censured\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"uint32\"}],\"name\":\"Forgiven\",\"type\":\"event\"}]","ContractName":"Censures","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000223c067f8cf28ae173ee5cafea60ca44c335fecb","Library":"","SwarmSource":"bzzr://926f826b9b6bba7cd8a2e38d3476912561510f19de893417d907e48248ff37df"}]}