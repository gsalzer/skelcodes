{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t * @dev Multiplies two numbers, reverts on overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\t// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 c = a * b;\r\n\t\trequire(c / a == b);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\trequire(b > 0); // Solidity only automatically asserts when dividing by 0\r\n\t\tuint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\trequire(b <= a);\r\n\t\tuint256 c = a - b;\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Adds two numbers, reverts on overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\tuint256 c = a + b;\r\n\t\trequire(c >= a);\r\n\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n\t * reverts when dividing by zero.\r\n\t */\r\n\tfunction mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n\t\trequire(b != 0);\r\n\t\treturn a % b;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title BaseAccessControl\r\n * @dev Basic control permissions are setting here\r\n */\r\ncontract BaseAccessControl {\r\n\r\n\taddress public ceo;\r\n\taddress public coo;\r\n\taddress public cfo;\r\n\r\n\tconstructor() public {\r\n\t\tceo = msg.sender;\r\n\t\tcoo = msg.sender;\r\n\t\tcfo = msg.sender;\r\n\t}\r\n\r\n\t/** roles modifer */\r\n\tmodifier onlyCEO() {\r\n\t\trequire(msg.sender == ceo, \"CEO Only\");\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyCOO() {\r\n\t\trequire(msg.sender == coo, \"COO Only\");\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyCFO() {\r\n\t\trequire(msg.sender == cfo, \"CFO Only\");\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyCLevel() {\r\n\t\trequire(msg.sender == ceo || msg.sender == coo || msg.sender == cfo, \"CLevel Only\");\r\n\t\t_;\r\n\t}\r\n\t/** end modifier */\r\n\r\n\t/** util modifer */\r\n\tmodifier required(address addr) {\r\n\t\trequire(addr != address(0), \"Address is required.\");\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyHuman(address addr) {\r\n\t\tuint256 codeLength;\r\n\t\tassembly {\r\n\t\t\tcodeLength: = extcodesize(addr)\r\n\t\t}\r\n\t\trequire(codeLength == 0, \"Humans only\");\r\n\t\t_;\r\n\t}\r\n\tmodifier onlyContract(address addr) {\r\n\t\tuint256 codeLength;\r\n\t\tassembly {\r\n\t\t\tcodeLength: = extcodesize(addr)\r\n\t\t}\r\n\t\trequire(codeLength > 0, \"Contracts only\");\r\n\t\t_;\r\n\t}\r\n\t/** end util modifier */\r\n\r\n\t/** setter */\r\n\tfunction setCEO(address addr) external onlyCEO() required(addr) onlyHuman(addr) {\r\n\t\tceo = addr;\r\n\t}\r\n\r\n\tfunction setCOO(address addr) external onlyCEO() required(addr) onlyHuman(addr) {\r\n\t\tcoo = addr;\r\n\t}\r\n\r\n\tfunction setCFO(address addr) external onlyCEO() required(addr) onlyHuman(addr) {\r\n\t\tcfo = addr;\r\n\t}\r\n\t/** end setter */\r\n}\r\n\r\n/**\r\n * @title MinerAccessControl\r\n * @dev Expanding the access control module for miner contract, especially for B1MP contract here\r\n */\r\ncontract MinerAccessControl is BaseAccessControl {\r\n\r\n\taddress public companyWallet;\r\n\r\n\tbool public paused = false;\r\n\r\n\t/** modifer */\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!paused, \"Paused\");\r\n\t\t_;\r\n\t}\r\n\tmodifier whenPaused() {\r\n\t\trequire(paused, \"Running\");\r\n\t\t_;\r\n\t}\r\n\t/** end modifier */\r\n\r\n\t/** setter */\r\n\tfunction setCompanyWallet(address newCompanyWallet) external onlyCEO() required(newCompanyWallet) {\r\n\t\tcompanyWallet = newCompanyWallet;\r\n\t}\r\n\r\n\tfunction paused() public onlyCLevel() whenNotPaused() {\r\n\t\tpaused = true;\r\n\t}\r\n\r\n\tfunction unpaused() external onlyCEO() whenPaused() {\r\n\t\tpaused = false;\r\n\t}\r\n\t/** end setter */\r\n}\r\n\r\n/**\r\n * @title B1MPToken\r\n * @dev This contract is One-Minute Profit Option Contract.\r\n * And all users can get their one-minute profit option as a ERC721 token through this contract.\r\n * Even more, all users can exchange their one-minute profit option in the future.\r\n */\r\ninterface B1MPToken {\r\n\tfunction mintByTokenId(address to, uint256 tokenId) external returns(bool);\r\n}\r\n\r\n/**\r\n * @title B1MP\r\n * @dev This is the old B1MP contract.\r\n * Because of some problem, we have decided to migrate all data and use a new one contract.\r\n */\r\ninterface B1MP {\r\n\tfunction _global() external view returns(uint256 revenue, uint256 g_positionAmount, uint256 earlierPayoffPerPosition, uint256 totalRevenue);\r\n\tfunction _userAddrBook(uint256 index) external view returns(address addr);\r\n\tfunction _users(address addr) external view returns(uint256 id, uint256 positionAmount, uint256 earlierPayoffMask, uint256 lastRefId);\r\n\tfunction _invitations(address addr) external view returns(uint256 invitationAmount, uint256 invitationPayoff);\r\n\tfunction _positionBook(uint256 index1, uint256 index2) external view returns(uint256 minute);\r\n\tfunction _positionOnwers(uint256 minute) external view returns(address addr);\r\n\tfunction totalUsers() external view returns(uint256);\r\n\tfunction getUserPositionIds(address addr) external view returns(uint256[]);\r\n}\r\n\r\n/**\r\n * @title NewB1MP\r\n * @dev Because the old one has some problem, we re-devise the whole contract.\r\n * All actions, such as buying, withdrawing, and etc., are responding and recording by this contract.\r\n */\r\ncontract NewB1MP is MinerAccessControl {\r\n\r\n\tusing SafeMath for * ;\r\n\r\n\t// the activity configurations\r\n\tstruct Config {\r\n\t\tuint256 start; // the activity's start-time\r\n\t\tuint256 end; // the activity's end-time\r\n\t\tuint256 price; // the price of any one-minute profit option\r\n\t\tuint256 withdrawFee; // the basic fee for withdrawal request\r\n\t\tuint8 earlierPayoffRate; // the proportion of dividends to early buyers\r\n\t\tuint8 invitationPayoffRate; // the proportion of dividends to inviters\r\n\t\tuint256 finalPrizeThreshold; // the threshold for opening the final prize\r\n\t\tuint8[10] finalPrizeRates; // a group proportions for the final prize, the final selected proportion will be decided by some parameters\r\n\t}\r\n\r\n\tstruct Global {\r\n\t\tuint256 revenue; // reserved revenue of the project holder\r\n\t\tuint256 positionAmount; // the total amount of minutes been sold\r\n\t\tuint256 earlierPayoffPerPosition; // the average dividends for every minute been sold before\r\n\t\tuint256 totalRevenue; // total amount of revenue\r\n\t}\r\n\r\n\tstruct User {\r\n\t\tuint256 id; // user's id, equal to user's index + 1, increment\r\n\t\tuint256 positionAmount; // the total amount of minutes bought by this user\r\n\t\tuint256 earlierPayoffMask; // the pre-purchaser dividend that the user should not receive\r\n\t\tuint256 lastRefId; // the inviter's user-id\r\n\t\tuint256[] positionIds; // all position ids hold by this user\r\n\t}\r\n\r\n\tstruct Invitation {\r\n\t\tuint256 amount; // how many people invited\r\n\t\tuint256 payoff; // how much payoff through invitation\r\n\t}\r\n\r\n\tB1MP public oldB1MPContract; // the old B1MP contract, just for data migration\r\n\tB1MPToken public tokenContract; // the one-minute profit option contract\r\n\tConfig public _config; // configurations\r\n\tGlobal public _global; // globa info\r\n\taddress[] public _userAddrBook; // users' addresses list, for registration\r\n\tmapping(address => User) public _users; // all users' detail info\r\n\tmapping(address => Invitation) public _invitations; // the invitations info\r\n\r\n\tuint256[2][] public _positionBook; // all positions list\r\n\tmapping(uint256 => address) public _positionOwners; // positionId (index + 1) => owner\r\n\tmapping(uint256 => address) public _positionMiners; // position minute => miner\r\n\r\n\tuint256 public _prizePool; // the pool of final prize\r\n\tuint256 public _prizePoolWithdrawn; // how much money been withdrawn through final prize pool\r\n\tbool public _isPrizeActivated; // whether the final prize is activated\r\n\r\n\taddress[] public _winnerPurchaseListForAddr; // final prize winners list\r\n\tuint256[] public _winnerPurchaseListForPositionAmount; // the purchase history of final prize winners\r\n\tmapping(address => uint256) public _winnerPositionAmounts; // the total position amount of any final prize winner\r\n\tuint256 public _currentWinnerIndex; // the index of current winner, using for a looping array of all winners\r\n\tuint256 private _winnerCounter; // the total amount of final prize winners\r\n\tuint256 public _winnerTotalPositionAmount; // the total amount of positons bought by all final prize winners\r\n\r\n\tbool private _isReady; // whether the data migration has been completed\r\n\tuint256 private _userMigrationCounter; // how many users have been migrated\r\n\r\n\t/** modifer */\r\n\tmodifier paymentLimit(uint256 ethVal) {\r\n\t\trequire(ethVal > 0, \"Too poor.\");\r\n\t\trequire(ethVal <= 100000 ether, \"Too rich.\");\r\n\t\t_;\r\n\t}\r\n\tmodifier buyLimit(uint256 ethVal) {\r\n\t\trequire(ethVal >= _config.price, 'Not enough.');\r\n\t\t_;\r\n\t}\r\n\tmodifier withdrawLimit(uint256 ethVal) {\r\n\t\trequire(ethVal == _config.withdrawFee, 'Not enough.');\r\n\t\t_;\r\n\t}\r\n\tmodifier whenNotEnded() {\r\n\t\trequire(_config.end == 0 || now < _config.end, 'Ended.');\r\n\t\t_;\r\n\t}\r\n\tmodifier whenEnded() {\r\n\t\trequire(_config.end != 0 && now >= _config.end, 'Not ended.');\r\n\t\t_;\r\n\t}\r\n\tmodifier whenPrepare() {\r\n\t\trequire(_config.end == 0, 'Started.');\r\n\t\trequire(_isReady == false, 'Ready.');\r\n\t\t_;\r\n\t}\r\n\tmodifier whenReady() {\r\n\t\trequire(_isReady == true, 'Not ready.');\r\n\t\t_;\r\n\t}\r\n\t/** end modifier */\r\n\r\n\t// initialize\r\n\tconstructor(address tokenAddr, address oldB1MPContractAddr) onlyContract(tokenAddr) onlyContract(oldB1MPContractAddr) public {\r\n\t\t// ready for migration\r\n\t\toldB1MPContract = B1MP(oldB1MPContractAddr);\r\n\t\t_isReady = false;\r\n\t\t_userMigrationCounter = 0;\r\n\t\t// initialize base info\r\n\t\ttokenContract = B1MPToken(tokenAddr);\r\n\t\t_config = Config(1541993890, 0, 90 finney, 5 finney, 10, 20, 20000 ether, [\r\n\t\t\t5, 6, 7, 8, 10, 13, 15, 17, 20, 25\r\n\t\t]);\r\n\t\t_global = Global(0, 0, 0, 0);\r\n\r\n\t\t// ready for final prize\r\n\t\t_currentWinnerIndex = 0;\r\n\t\t_isPrizeActivated = false;\r\n\t}\r\n\r\n\tfunction migrateUserData(uint256 n) whenPrepare() onlyCEO() public {\r\n\t\t// intialize _userAddrBook & _users\r\n\t\tuint256 userAmount = oldB1MPContract.totalUsers();\r\n\t\t_userAddrBook.length = userAmount;\r\n\t\t// migrate n users per time\r\n\t\tuint256 lastMigrationNumber = _userMigrationCounter;\r\n\t\tfor (_userMigrationCounter; _userMigrationCounter < userAmount && _userMigrationCounter < lastMigrationNumber + n; _userMigrationCounter++) {\r\n\t\t\t// A. get user address\r\n\t\t\taddress userAddr = oldB1MPContract._userAddrBook(_userMigrationCounter);\r\n\t\t\t/// save to _userAddrBook\r\n\t\t\t_userAddrBook[_userMigrationCounter] = userAddr;\r\n\t\t\t// B. get user info\r\n\t\t\t(uint256 id, uint256 positionAmount, uint256 earlierPayoffMask, uint256 lastRefId) = oldB1MPContract._users(userAddr);\r\n\t\t\tuint256[] memory positionIds = oldB1MPContract.getUserPositionIds(userAddr);\r\n\t\t\t/// save to _users\r\n\t\t\t_users[userAddr] = User(id, positionAmount, earlierPayoffMask, lastRefId, positionIds);\r\n\t\t\t// C. get invitation info\r\n\t\t\t(uint256 invitationAmount, uint256 invitationPayoff) = oldB1MPContract._invitations(userAddr);\r\n\t\t\t/// save to _invitations\r\n\t\t\t_invitations[userAddr] = Invitation(invitationAmount, invitationPayoff);\r\n\t\t\t// D. get & save position info\r\n\t\t\tfor (uint256 i = 0; i < positionIds.length; i++) {\r\n\t\t\t\tuint256 pid = positionIds[i];\r\n\t\t\t\tif (pid > 0) {\r\n\t\t\t\t\tif (pid > _positionBook.length) {\r\n\t\t\t\t\t\t_positionBook.length = pid;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tuint256 pIndex = pid.sub(1);\r\n\t\t\t\t\t_positionBook[pIndex] = [oldB1MPContract._positionBook(pIndex, 0), oldB1MPContract._positionBook(pIndex, 1)];\r\n\t\t\t\t\t_positionOwners[pIndex] = userAddr;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction migrateGlobalData() whenPrepare() onlyCEO() public {\r\n\t\t// intialize _global\r\n\t\t(uint256 revenue, uint256 g_positionAmount, uint256 earlierPayoffPerPosition, uint256 totalRevenue) = oldB1MPContract._global();\r\n\t\t_global = Global(revenue, g_positionAmount, earlierPayoffPerPosition, totalRevenue);\r\n\t}\r\n\r\n\tfunction depositeForMigration() whenPrepare() onlyCEO() public payable {\r\n\t\trequire(_userMigrationCounter == oldB1MPContract.totalUsers(), 'Continue to migrate.');\r\n\t\trequire(msg.value >= address(oldB1MPContract).balance, 'Not enough.');\r\n\t\t// update revenue, but don't update totalRevenue\r\n\t\t// because it's the dust of deposit, but not the revenue of sales\r\n\t\t// it will be not used for final prize\r\n\t\t_global.revenue = _global.revenue.add(msg.value.sub(address(oldB1MPContract).balance));\r\n\t\t_isReady = true;\r\n\t}\r\n\r\n\tfunction () whenReady() whenNotEnded() whenNotPaused() onlyHuman(msg.sender) paymentLimit(msg.value) buyLimit(msg.value) public payable {\r\n\t\tbuyCore(msg.sender, msg.value, 0);\r\n\t}\r\n\r\n\tfunction buy(uint256 refId) whenReady() whenNotEnded() whenNotPaused() onlyHuman(msg.sender) paymentLimit(msg.value) buyLimit(msg.value) public payable {\r\n\t\tbuyCore(msg.sender, msg.value, refId);\r\n\t}\r\n\r\n\tfunction buyCore(address addr_, uint256 revenue_, uint256 refId_) private {\r\n\t\t// 1. prepare some data\r\n\t\tuint256 _positionAmount_ = (revenue_).div(_config.price); // actual amount \r\n\t\tuint256 _realCost_ = _positionAmount_.mul(_config.price);\r\n\t\tuint256 _invitationPayoffPart_ = _realCost_.mul(_config.invitationPayoffRate).div(100);\r\n\t\tuint256 _earlierPayoffPart_ = _realCost_.mul(_config.earlierPayoffRate).div(100);\r\n\t\trevenue_ = revenue_.sub(_invitationPayoffPart_).sub(_earlierPayoffPart_);\r\n\t\tuint256 _earlierPayoffMask_ = 0;\r\n\r\n\t\t// 2. register a new user\r\n\t\tif (_users[addr_].id == 0) {\r\n\t\t\t_userAddrBook.push(addr_); // add to user address list\r\n\t\t\t_users[addr_].id = _userAddrBook.length; // assign the user id, especially id = userAddrBook.index + 1\r\n\t\t}\r\n\r\n\t\t// 3. update global info\r\n\t\tif (_global.positionAmount > 0) {\r\n\t\t\tuint256 eppp = _earlierPayoffPart_.div(_global.positionAmount);\r\n\t\t\t_global.earlierPayoffPerPosition = eppp.add(_global.earlierPayoffPerPosition); // update global earlier payoff for per position\r\n\t\t\trevenue_ = revenue_.add(_earlierPayoffPart_.sub(eppp.mul(_global.positionAmount))); // the dust for this dividend\r\n\t\t} else {\r\n\t\t\trevenue_ = revenue_.add(_earlierPayoffPart_); // no need to dividend, especially for first one\r\n\t\t}\r\n\t\t// update the total position amount\r\n\t\t_global.positionAmount = _positionAmount_.add(_global.positionAmount);\r\n\t\t// calculate the current user's earlier payoff mask for this tx\r\n\t\t_earlierPayoffMask_ = _positionAmount_.mul(_global.earlierPayoffPerPosition);\r\n\r\n\t\t// 4. update referral data\r\n\t\tif (refId_ <= 0 || refId_ > _userAddrBook.length || refId_ == _users[addr_].id) { // the referrer doesn't exist, or is clien self\r\n\t\t\trefId_ = _users[addr_].lastRefId;\r\n\t\t} else if (refId_ != _users[addr_].lastRefId) {\r\n\t\t\t_users[addr_].lastRefId = refId_;\r\n\t\t}\r\n\t\t// update referrer's invitation info if he exists\r\n\t\tif (refId_ != 0) {\r\n\t\t\taddress refAddr = _userAddrBook[refId_.sub(1)];\r\n\t\t\t// modify old one or create a new on if it doesn't exist\r\n\t\t\t_invitations[refAddr].amount = (1).add(_invitations[refAddr].amount); // update invitation amount\r\n\t\t\t_invitations[refAddr].payoff = _invitationPayoffPart_.add(_invitations[refAddr].payoff); // update invitation payoff\r\n\t\t} else {\r\n\t\t\trevenue_ = revenue_.add(_invitationPayoffPart_); // no referrer\r\n\t\t}\r\n\r\n\t\t// 5. update user info\r\n\t\t_users[addr_].positionAmount = _positionAmount_.add(_users[addr_].positionAmount);\r\n\t\t_users[addr_].earlierPayoffMask = _earlierPayoffMask_.add(_users[addr_].earlierPayoffMask);\r\n\t\t// update user's positions details, and record the position\r\n\t\t_positionBook.push([_global.positionAmount.sub(_positionAmount_).add(1), _global.positionAmount]);\r\n\t\t_positionOwners[_positionBook.length] = addr_;\r\n\t\t_users[addr_].positionIds.push(_positionBook.length);\r\n\r\n\t\t// 6. archive revenue\r\n\t\t_global.revenue = revenue_.add(_global.revenue);\r\n\t\t_global.totalRevenue = revenue_.add(_global.totalRevenue);\r\n\r\n\t\t// 7. select 1% user for final prize when the revenue is more than final prize threshold\r\n\t\tif (_global.totalRevenue > _config.finalPrizeThreshold) {\r\n\t\t\tuint256 maxWinnerAmount = countWinners(); // the max amount of winners, 1% of total users\r\n\t\t\t// activate final prize module at least there are more than 100 users\r\n\t\t\tif (maxWinnerAmount > 0) {\r\n\t\t\t\tif (maxWinnerAmount > _winnerPurchaseListForAddr.length) {\r\n\t\t\t\t\t_winnerPurchaseListForAddr.length = maxWinnerAmount;\r\n\t\t\t\t\t_winnerPurchaseListForPositionAmount.length = maxWinnerAmount;\r\n\t\t\t\t}\r\n\t\t\t\t// get the last winner's address\r\n\t\t\t\taddress lwAddr = _winnerPurchaseListForAddr[_currentWinnerIndex];\r\n\t\t\t\tif (lwAddr != address(0)) { // deal the last winner's info\r\n\t\t\t\t\t// deduct this purchase record's positions amount from total amount\r\n\t\t\t\t\t_winnerTotalPositionAmount = _winnerTotalPositionAmount.sub(_winnerPurchaseListForPositionAmount[_currentWinnerIndex]);\r\n\t\t\t\t\t// deduct the winner's position amount from  this winner's amount\r\n\t\t\t\t\t_winnerPositionAmounts[lwAddr] = _winnerPositionAmounts[lwAddr].sub(_winnerPurchaseListForPositionAmount[_currentWinnerIndex]);\r\n\t\t\t\t\t// this is the winner's last record\r\n\t\t\t\t\tif (_winnerPositionAmounts[lwAddr] == 0) {\r\n\t\t\t\t\t\t// delete the winner's info\r\n\t\t\t\t\t\t_winnerCounter = _winnerCounter.sub(1);\r\n\t\t\t\t\t\tdelete _winnerPositionAmounts[lwAddr];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t// set the new winner's info, or update old winner's info\r\n\t\t\t\t// register a new winner\r\n\t\t\t\tif (_winnerPositionAmounts[msg.sender] == 0) {\r\n\t\t\t\t\t// add a new winner\r\n\t\t\t\t\t_winnerCounter = _winnerCounter.add(1);\r\n\t\t\t\t}\r\n\t\t\t\t// update total amount of winner's positions bought finally\r\n\t\t\t\t_winnerTotalPositionAmount = _positionAmount_.add(_winnerTotalPositionAmount);\r\n\t\t\t\t// update winner's position amount\r\n\t\t\t\t_winnerPositionAmounts[msg.sender] = _positionAmount_.add(_winnerPositionAmounts[msg.sender]);\r\n\t\t\t\t// directly reset the winner list\r\n\t\t\t\t_winnerPurchaseListForAddr[_currentWinnerIndex] = msg.sender;\r\n\t\t\t\t_winnerPurchaseListForPositionAmount[_currentWinnerIndex] = _positionAmount_;\r\n\t\t\t\t// move the index to next\r\n\t\t\t\t_currentWinnerIndex = _currentWinnerIndex.add(1);\r\n\t\t\t\tif (_currentWinnerIndex >= maxWinnerAmount) { // the max index = total amount - 1\r\n\t\t\t\t\t_currentWinnerIndex = 0; // start a new loop when the number of winners exceed over the max amount allowed\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t// 8. update end time\r\n\t\t_config.end = (now).add(2 days); // expand the end time for every tx\r\n\t}\r\n\r\n\tfunction redeemOptionContract(uint256 positionId, uint256 minute) whenReady() whenNotPaused() onlyHuman(msg.sender) public {\r\n\t\trequire(_users[msg.sender].id != 0, 'Unauthorized.');\r\n\t\trequire(positionId <= _positionBook.length && positionId > 0, 'Position Id error.');\r\n\t\trequire(_positionOwners[positionId] == msg.sender, 'No permission.');\r\n\t\trequire(minute >= _positionBook[positionId - 1][0] && minute <= _positionBook[positionId - 1][1], 'Wrong interval.');\r\n\t\trequire(_positionMiners[minute] == address(0), 'Minted.');\r\n\r\n\t\t// record the miner\r\n\t\t_positionMiners[minute] = msg.sender;\r\n\r\n\t\t// mint this minute's token\r\n\t\trequire(tokenContract.mintByTokenId(msg.sender, minute), \"Mining Error.\");\r\n\t}\r\n\r\n\tfunction activateFinalPrize() whenReady() whenEnded() whenNotPaused() onlyCOO() public {\r\n\t\trequire(_isPrizeActivated == false, 'Activated.');\r\n\t\t// total revenue should be more than final prize threshold\r\n\t\tif (_global.totalRevenue > _config.finalPrizeThreshold) {\r\n\t\t\t// calculate the prize pool\r\n\t\t\tuint256 selectedfinalPrizeRatesIndex = _winnerCounter.mul(_winnerTotalPositionAmount).mul(_currentWinnerIndex).mod(_config.finalPrizeRates.length);\r\n\t\t\t_prizePool = _global.totalRevenue.mul(_config.finalPrizeRates[selectedfinalPrizeRatesIndex]).div(100);\r\n\t\t\t// deduct the final prize pool from the reserved revenue\r\n\t\t\t_global.revenue = _global.revenue.sub(_prizePool);\r\n\t\t}\r\n\t\t// maybe not enough to final prize\r\n\t\t_isPrizeActivated = true;\r\n\t}\r\n\r\n\tfunction withdraw() whenReady() whenNotPaused() onlyHuman(msg.sender) withdrawLimit(msg.value) public payable {\r\n\t\t_global.revenue = _global.revenue.add(msg.value); // archive withdrawal fee to revenue, but not total revenue which is for final prize\r\n\r\n\t\t// 1. deduct invitation payoff\r\n\t\tuint256 amount = _invitations[msg.sender].payoff;\r\n\t\t_invitations[msg.sender].payoff = 0; // clear the user's invitation payoff\r\n\r\n\t\t// 2. deduct earlier payoff\r\n\t\tuint256 ep = (_global.earlierPayoffPerPosition).mul(_users[msg.sender].positionAmount);\r\n\t\tamount = amount.add(ep.sub(_users[msg.sender].earlierPayoffMask));\r\n\t\t_users[msg.sender].earlierPayoffMask = ep; // reset the user's earlier payoff mask which include this withdrawal part\r\n\r\n\t\t// 3. get the user's final prize, and deduct it\r\n\t\tif (_isPrizeActivated == true && _winnerPositionAmounts[msg.sender] > 0 &&\r\n\t\t\t_winnerTotalPositionAmount > 0 && _winnerCounter > 0 && _prizePool > _prizePoolWithdrawn) {\r\n\t\t\t// calculate the user's prize amount\r\n\t\t\tuint256 prizeAmount = prize(msg.sender);\r\n\t\t\t// set the user withdrawal amount\r\n\t\t\tamount = amount.add(prizeAmount);\r\n\t\t\t// refresh withdrawal amount of prize pool\r\n\t\t\t_prizePoolWithdrawn = _prizePoolWithdrawn.add(prizeAmount);\r\n\t\t\t// clear the user's finally bought position amount, so clear the user's final prize\r\n\t\t\tclearPrize(msg.sender);\r\n\t\t\t_winnerCounter = _winnerCounter.sub(1);\r\n\t\t}\r\n\r\n\t\t// 4. send eth\r\n\t\t(msg.sender).transfer(amount);\r\n\t}\r\n\r\n\tfunction withdrawByCFO(uint256 amount) whenReady() whenNotPaused() onlyCFO() required(companyWallet) public {\r\n\t\trequire(amount > 0, 'Payoff too samll.');\r\n\t\tuint256 max = _global.revenue;\r\n\t\tif (_isPrizeActivated == false) { // when haven't sent final prize\r\n\t\t\t// deduct the max final prize pool\r\n\t\t\tmax = max.sub(_global.totalRevenue.mul(_config.finalPrizeRates[_config.finalPrizeRates.length.sub(1)]).div(100));\r\n\t\t}\r\n\t\trequire(amount <= max, 'Payoff too big.');\r\n\r\n\t\t// deduct the withdrawal amount\r\n\t\t_global.revenue = _global.revenue.sub(amount);\r\n\r\n\t\t// send eth\r\n\t\tcompanyWallet.transfer(amount);\r\n\t}\r\n\r\n\tfunction withdrawByCFO(address addr) whenReady() whenNotPaused() onlyCFO() onlyContract(addr) required(companyWallet) public {\r\n\t\t// send all erc20\r\n\t\trequire(IERC20(addr).transfer(companyWallet, IERC20(addr).balanceOf(this)));\r\n\t}\r\n\r\n\tfunction collectPrizePoolDust() whenReady() whenNotPaused() onlyCOO() public {\r\n\t\t// when final prize has been sent, and all winners have received prizes\r\n\t\trequire(_isPrizeActivated == true, 'Not activited.');\r\n\t\t// collect the prize pool dust\r\n\t\tif (_winnerCounter == 0 || now > _config.end.add(180 days)) {\r\n\t\t\t_global.revenue = _global.revenue.add(_prizePool.sub(_prizePoolWithdrawn));\r\n\t\t\t_prizePoolWithdrawn = _prizePool;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction totalUsers() public view returns(uint256) {\r\n\t\treturn _userAddrBook.length;\r\n\t}\r\n\r\n\tfunction getUserAddress(uint256 id) public view returns(address userAddrRet) {\r\n\t\tif (id <= _userAddrBook.length && id > 0) {\r\n\t\t\tuserAddrRet = _userAddrBook[id.sub(1)];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getUserPositionIds(address addr) public view returns(uint256[]) {\r\n\t\treturn _users[addr].positionIds;\r\n\t}\r\n\r\n\tfunction countPositions() public view returns(uint256) {\r\n\t\treturn _positionBook.length;\r\n\t}\r\n\r\n\tfunction getPositions(uint256 id) public view returns(uint256[2] positionsRet) {\r\n\t\tif (id <= _positionBook.length && id > 0) {\r\n\t\t\tpositionsRet = _positionBook[id.sub(1)];\r\n\t\t}\r\n\t}\r\n\r\n\tfunction prize(address addr) public view returns(uint256) {\r\n\t\tif (_winnerTotalPositionAmount == 0 || _prizePool == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn _winnerPositionAmounts[addr].mul(_prizePool).div(_winnerTotalPositionAmount);\r\n\t}\r\n\r\n\tfunction clearPrize(address addr) private {\r\n\t\tdelete _winnerPositionAmounts[addr];\r\n\t}\r\n\r\n\tfunction countWinners() public view returns(uint256) {\r\n\t\treturn _userAddrBook.length.div(100);\r\n\t}\r\n\r\n\tfunction allWinners() public view returns(address[]) {\r\n\t\treturn _winnerPurchaseListForAddr;\r\n\t}\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n\tfunction totalSupply() external view returns(uint256);\r\n\r\n\tfunction balanceOf(address who) external view returns(uint256);\r\n\r\n\tfunction allowance(address owner, address spender)\r\n\texternal view returns(uint256);\r\n\r\n\tfunction transfer(address to, uint256 value) external returns(bool);\r\n\r\n\tfunction approve(address spender, uint256 value)\r\n\texternal returns(bool);\r\n\r\n\tfunction transferFrom(address from, address to, uint256 value)\r\n\texternal returns(bool);\r\n\r\n\tevent Transfer(\r\n\t\taddress indexed from,\r\n\t\taddress indexed to,\r\n\t\tuint256 value\r\n\t);\r\n\r\n\tevent Approval(\r\n\t\taddress indexed owner,\r\n\t\taddress indexed spender,\r\n\t\tuint256 value\r\n\t);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"coo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_prizePoolWithdrawn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_winnerPositionAmounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositeForMigration\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_invitations\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"payoff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_winnerPurchaseListForAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collectPrizePoolDust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"migrateUserData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCompanyWallet\",\"type\":\"address\"}],\"name\":\"setCompanyWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_config\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"withdrawFee\",\"type\":\"uint256\"},{\"name\":\"earlierPayoffRate\",\"type\":\"uint8\"},{\"name\":\"invitationPayoffRate\",\"type\":\"uint8\"},{\"name\":\"finalPrizeThreshold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getPositions\",\"outputs\":[{\"name\":\"positionsRet\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"withdrawByCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawByCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"_users\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"positionAmount\",\"type\":\"uint256\"},{\"name\":\"earlierPayoffMask\",\"type\":\"uint256\"},{\"name\":\"lastRefId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_global\",\"outputs\":[{\"name\":\"revenue\",\"type\":\"uint256\"},{\"name\":\"positionAmount\",\"type\":\"uint256\"},{\"name\":\"earlierPayoffPerPosition\",\"type\":\"uint256\"},{\"name\":\"totalRevenue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_prizePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"migrateGlobalData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_winnerPurchaseListForPositionAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"paused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateFinalPrize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_winnerTotalPositionAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldB1MPContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"prize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_userAddrBook\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"id\",\"type\":\"uint256\"}],\"name\":\"getUserAddress\",\"outputs\":[{\"name\":\"userAddrRet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_positionBook\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_positionMiners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_positionOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"positionId\",\"type\":\"uint256\"},{\"name\":\"minute\",\"type\":\"uint256\"}],\"name\":\"redeemOptionContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalUsers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_isPrizeActivated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countPositions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_currentWinnerIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"refId\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getUserPositionIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddr\",\"type\":\"address\"},{\"name\":\"oldB1MPContractAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"NewB1MP","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000af8d39416474817a677ef6a32abb425dbc74e2a40000000000000000000000001d42a7bc62c4b377105e0de6707a77fcfc71957f","Library":"","SwarmSource":"bzzr://2c5b465b9a8fe801419de2d9a04d4096430a388868c816be41f9813a31d6b793"}]}