{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract owned {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner , \"Unauthorized Access\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\ninterface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; }\r\ninterface ERC20Interface {\r\n   \r\n      /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) view external returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    \r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n   \r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function disApprove(address _spender)  external returns (bool success);\r\n   function increaseApproval(address _spender, uint _addedValue) external returns (bool success);\r\n   function decreaseApproval(address _spender, uint _subtractedValue) external returns (bool success);\r\n     /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n     function name() external view returns (string _name);\r\n\r\n    /* Get the contract constant _symbol */\r\n    function symbol() external view returns (string _symbol);\r\n\r\n    /* Get the contract constant _decimals */\r\n    function decimals() external view returns (uint8 _decimals); \r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\nlibrary SafeERC20{\r\n\r\n  function safeTransfer(ERC20Interface token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }    \r\n    \r\n  \r\n\r\n  function safeTransferFrom(ERC20Interface token, address from, address to, uint256 value) internal {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20Interface token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\ncontract TansalICOTokenVault is owned{\r\n    \r\n     using SafeERC20 for ERC20Interface;\r\n     ERC20Interface TansalCoin;\r\n      struct Investor {\r\n        string fName;\r\n        string lName;\r\n        uint256 totalTokenWithdrawn;\r\n        bool exists;\r\n    }\r\n    \r\n    mapping (address => Investor) public investors;\r\n    address[] public investorAccts;\r\n    uint256 public numberOFApprovedInvestorAccounts;\r\n\r\n     constructor() public\r\n     {\r\n         \r\n         TansalCoin = ERC20Interface(0x0EF0183E9Db9069a7207543db99a4Ec4d06f11cB);\r\n     }\r\n    \r\n     function() public {\r\n         //not payable fallback function\r\n          revert();\r\n    }\r\n    \r\n     function sendApprovedTokensToInvestor(address _benificiary,uint256 _approvedamount,string _fName, string _lName) public onlyOwner\r\n    {\r\n        uint256 totalwithdrawnamount;\r\n        require(TansalCoin.balanceOf(address(this)) > _approvedamount);\r\n        if(investors[_benificiary].exists)\r\n        {\r\n            uint256 alreadywithdrawn = investors[_benificiary].totalTokenWithdrawn;\r\n            totalwithdrawnamount = alreadywithdrawn + _approvedamount;\r\n            \r\n        }\r\n        else\r\n        {\r\n          totalwithdrawnamount = _approvedamount;\r\n          investorAccts.push(_benificiary) -1;\r\n        }\r\n         investors[_benificiary] = Investor({\r\n                                            fName: _fName,\r\n                                            lName: _lName,\r\n                                            totalTokenWithdrawn: totalwithdrawnamount,\r\n                                            exists: true\r\n            \r\n        });\r\n        numberOFApprovedInvestorAccounts = investorAccts.length;\r\n        TansalCoin.safeTransfer(_benificiary , _approvedamount);\r\n    }\r\n    \r\n     function onlyPayForFuel() public payable onlyOwner{\r\n        // Owner will pay in contract to bear the gas price if transactions made from contract\r\n        \r\n    }\r\n    function withdrawEtherFromcontract(uint _amountInwei) public onlyOwner{\r\n        require(address(this).balance > _amountInwei);\r\n      require(msg.sender == owner);\r\n      owner.transfer(_amountInwei);\r\n     \r\n    }\r\n    function withdrawTokenFromcontract(ERC20Interface _token, uint256 _tamount) public onlyOwner{\r\n        require(_token.balanceOf(address(this)) > _tamount);\r\n         _token.safeTransfer(owner, _tamount);\r\n     \r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorAccts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOFApprovedInvestorAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"onlyPayForFuel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"fName\",\"type\":\"string\"},{\"name\":\"lName\",\"type\":\"string\"},{\"name\":\"totalTokenWithdrawn\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tamount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokenFromcontract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_benificiary\",\"type\":\"address\"},{\"name\":\"_approvedamount\",\"type\":\"uint256\"},{\"name\":\"_fName\",\"type\":\"string\"},{\"name\":\"_lName\",\"type\":\"string\"}],\"name\":\"sendApprovedTokensToInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountInwei\",\"type\":\"uint256\"}],\"name\":\"withdrawEtherFromcontract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TansalICOTokenVault","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b87ef701513cd678dc5bc34dd3453ac44ce1fa1afd4995d5331b94ea72e1be90"}]}