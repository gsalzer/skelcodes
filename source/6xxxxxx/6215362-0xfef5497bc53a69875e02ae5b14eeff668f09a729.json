{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n *\r\n *\r\n *  http://fairdapp.com     http://fairdapp.com     http://fairdapp.com\r\n *   \r\n *                       _______     _       ______  _______ ______ ______  \r\n *                      (_______)   (_)     (______)(_______|_____ (_____ \\ \r\n *                       _____ _____ _  ____ _     _ _______ _____) )____) )\r\n *                      |  ___|____ | |/ ___) |   | |  ___  |  ____/  ____/ \r\n *                      | |   / ___ | | |   | |__/ /| |   | | |    | |      \r\n *                      |_|   \\_____|_|_|   |_____/ |_|   |_|_|    |_|      \r\n *                                                                    \r\n *                               _         ___ _       _             \r\n *                              | |       / __|_)     (_)  _         \r\n *                              | |____ _| |__ _ ____  _ _| |_ _   _ \r\n *                              | |  _ (_   __) |  _ \\| (_   _) | | |\r\n *                              | | | | || |  | | | | | | | |_| |_| |\r\n *                              |_|_| |_||_|  |_|_| |_|_|  \\__)\\__  |\r\n *                                                            (____/                                                                  \r\n *   \r\n *  Warning:\r\n *     \r\n *  FairDAPP â€“ Infinity is a system designed to explore human behavior\r\n *  using infinite loops of token redistribution through open source \r\n *  smart contract codes and pre-defined rules.\r\n *   \r\n *  This system is for internal use only and all could be lost\r\n *  by sending anything to this contract address.\r\n *   \r\n *  -The contract has an activation switch to activate the system.\r\n *  -No one can change anything once the contract has been deployed.\r\n *   \r\n *  -Built in Antiwhale for initial stages for a fairer system.\r\n *\r\n**/\r\n\r\n\r\ncontract Infinity {\r\n    using SafeMath for uint256;\r\n    \r\n    /*------------------------------\r\n                CONFIGURABLES\r\n     ------------------------------*/\r\n    string public name = \"Infinity\";    // Contract name\r\n    string public symbol = \"Inf\";\r\n    \r\n    uint256 public initAmount;          // Initial stage target\r\n    uint256 public amountProportion;    // Stage target growth rate %\r\n    uint256 public dividend;            // Input to Dividend %\r\n    uint256 public jackpot;             // Input to Jackpot %\r\n    uint256 public jackpotProportion;   // Jackpot payout %\r\n    uint256 public scientists;          // Donation Fee % to scientists\r\n    uint256 public promotionRatio;      // Promotion %\r\n    uint256 public duration;            // Duration per stage\r\n    bool public activated = false;\r\n    \r\n    address public developerAddr;\r\n    \r\n    /*------------------------------\r\n                DATASETS\r\n     ------------------------------*/\r\n    uint256 public rId;   // Current round id number\r\n    uint256 public sId;   // Current stage id number\r\n    \r\n    mapping (uint256 => Indatasets.Round) public round; // (rId => data) round data by round id\r\n    mapping (uint256 => mapping (uint256 => Indatasets.Stage)) public stage;    // (rId => sId => data) stage data by round id & stage id\r\n    mapping (address => Indatasets.Player) public player;   // (address => data) player data\r\n    mapping (uint256 => mapping (address => uint256)) public playerRoundAmount; // (rId => address => playerRoundAmount) round data by round id\r\n    mapping (uint256 => mapping (address => uint256)) public playerRoundSid; \r\n    mapping (uint256 => mapping (address => uint256)) public playerRoundwithdrawAmountFlag; \r\n    mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAmount;    // (rId => sId => address => playerStageAmount) round data by round id & stage id\r\n    mapping (uint256 => mapping (uint256 => mapping (address => uint256))) public playerStageAccAmount;  \r\n    \r\n    //Antiwhale setting, max 5% of stage target for the first 10 stages per address\r\n    uint256[] amountLimit = [0, 50, 50, 50, 50, 50, 50, 50, 50, 50, 50];\r\n\r\n    /*------------------------------\r\n                PUBLIC FUNCTIONS\r\n    ------------------------------*/\r\n    \r\n    constructor()\r\n        public\r\n    {\r\n        developerAddr = msg.sender;\r\n    }\r\n    \r\n    /*------------------------------\r\n                MODIFIERS\r\n     ------------------------------*/\r\n     \r\n    modifier isActivated() {\r\n        require(activated == true, \"its not ready yet.  check ?eta in discord\"); \r\n        _;\r\n    }\r\n    \r\n    modifier senderVerify() {\r\n        require (msg.sender == tx.origin);\r\n        _;\r\n    }\r\n    \r\n    modifier stageVerify(uint256 _rId, uint256 _sId, uint256 _amount) {\r\n        require(stage[_rId][_sId].amount.add(_amount) <= stage[_rId][_sId].targetAmount);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Don't toy or spam the contract.\r\n     * The scientists will take anything below 0.0001 ETH sent to the contract.\r\n     * Thank you for your donation.\r\n     */\r\n    modifier amountVerify() {\r\n        if(msg.value < 100000000000000){\r\n            developerAddr.transfer(msg.value);\r\n        }else{\r\n            require(msg.value >= 100000000000000);\r\n            _;\r\n        }\r\n    }\r\n    \r\n    modifier playerVerify() {\r\n        require(player[msg.sender].active == true);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Activation of contract with settings\r\n     */\r\n    function activate()\r\n        public\r\n    {\r\n        require(msg.sender == developerAddr);\r\n        require(activated == false, \"Infinity already activated\");\r\n        \r\n        activated = true;\r\n        initAmount = 10000000000000000000;\r\n        amountProportion = 10;\r\n        dividend = 70;\r\n        jackpot = 28;  \r\n        jackpotProportion = 70;  \r\n        scientists = 2;\r\n        promotionRatio = 10;\r\n        duration = 86400;\r\n        rId = 1;\r\n        sId = 1;\r\n        \r\n        round[rId].start = now;\r\n        initStage(rId, sId);\r\n    \r\n    }\r\n    \r\n    /**\r\n     * Fallback function to handle ethereum that was send straight to the contract\r\n     * Unfortunately we cannot use a referral address this way.\r\n     */\r\n    function()\r\n        isActivated()\r\n        senderVerify()\r\n        amountVerify()\r\n        payable\r\n        public\r\n    {\r\n        buyAnalysis(0x0);\r\n    }\r\n\r\n    /**\r\n     * Standard buy function.\r\n     */\r\n    function buy(address _recommendAddr)\r\n        isActivated()\r\n        senderVerify()\r\n        amountVerify()\r\n        public\r\n        payable\r\n        returns(uint256)\r\n    {\r\n        buyAnalysis(_recommendAddr);\r\n    }\r\n    \r\n    /**\r\n     * Withdraw function.\r\n     * Withdraw 50 stages at once on current settings.\r\n     * May require to request withdraw more than once to withdraw everything.\r\n     */\r\n    function withdraw()\r\n        isActivated()\r\n        senderVerify()\r\n        playerVerify()\r\n        public\r\n    {\r\n        uint256 _rId = rId;\r\n        uint256 _sId = sId;\r\n        uint256 _amount;\r\n        uint256 _playerWithdrawAmountFlag;\r\n        \r\n        (_amount, player[msg.sender].withdrawRid, player[msg.sender].withdrawSid, _playerWithdrawAmountFlag) = getPlayerDividendByStage(_rId, _sId, msg.sender);\r\n\r\n        if(_playerWithdrawAmountFlag > 0)\r\n            playerRoundwithdrawAmountFlag[player[msg.sender].withdrawRid][msg.sender] = _playerWithdrawAmountFlag;\r\n        \r\n        if(player[msg.sender].promotionAmount > 0 ){\r\n            _amount = _amount.add(player[msg.sender].promotionAmount);\r\n            player[msg.sender].promotionAmount = 0;\r\n        }    \r\n        msg.sender.transfer(_amount);\r\n    }\r\n\r\n    \r\n    /**\r\n     * Core logic to analyse buy behaviour. \r\n     */\r\n    function buyAnalysis(address _recommendAddr)\r\n        private\r\n    {\r\n        uint256 _rId = rId;\r\n        uint256 _sId = sId;\r\n        uint256 _amount = msg.value;\r\n        uint256 _promotionRatio = promotionRatio;\r\n        \r\n        if(now > stage[_rId][_sId].end && stage[_rId][_sId].targetAmount > stage[_rId][_sId].amount){\r\n            \r\n            endRound(_rId, _sId);\r\n            \r\n            _rId = rId;\r\n            _sId = sId;\r\n            round[_rId].start = now;\r\n            initStage(_rId, _sId);\r\n            \r\n            _amount = limitAmount(_rId, _sId);\r\n            buyRoundDataRecord(_rId, _amount);\r\n            _promotionRatio = promotionDataRecord(_recommendAddr, _amount);\r\n            buyStageDataRecord(_rId, _sId, _promotionRatio, _amount);\r\n            buyPlayerDataRecord(_rId, _sId, _amount);\r\n            \r\n        }else if(now <= stage[_rId][_sId].end){\r\n            \r\n            _amount = limitAmount(_rId, _sId);\r\n            buyRoundDataRecord(_rId, _amount);\r\n            _promotionRatio = promotionDataRecord(_recommendAddr, _amount);\r\n            \r\n            if(stage[_rId][_sId].amount.add(_amount) >= stage[_rId][_sId].targetAmount){\r\n                \r\n                uint256 differenceAmount = (stage[_rId][_sId].targetAmount).sub(stage[_rId][_sId].amount);\r\n                buyStageDataRecord(_rId, _sId, _promotionRatio, differenceAmount);\r\n                buyPlayerDataRecord(_rId, _sId, differenceAmount);\r\n                \r\n                endStage(_rId, _sId);\r\n\r\n                _sId = sId;\r\n                initStage(_rId, _sId);\r\n                round[_rId].endSid = _sId;\r\n                buyStageDataRecord(_rId, _sId, _promotionRatio, _amount.sub(differenceAmount));\r\n                buyPlayerDataRecord(_rId, _sId, _amount.sub(differenceAmount));\r\n                \r\n            }else{\r\n                buyStageDataRecord(_rId, _sId, _promotionRatio, _amount);\r\n                buyPlayerDataRecord(_rId, _sId, _amount);\r\n                \r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Sets the initial stage parameter. \r\n     */\r\n    function initStage(uint256 _rId, uint256 _sId)\r\n        private\r\n    {\r\n        uint256 _targetAmount;\r\n        stage[_rId][_sId].start = now;\r\n        stage[_rId][_sId].end = now.add(duration);\r\n        if(_sId > 1){\r\n            stage[_rId][_sId - 1].end = now;\r\n            stage[_rId][_sId - 1].ended = true;\r\n            _targetAmount = (stage[_rId][_sId - 1].targetAmount.mul(amountProportion + 100)) / 100;\r\n        }else\r\n            _targetAmount = initAmount;\r\n            \r\n        stage[_rId][_sId].targetAmount = _targetAmount;\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Execution of antiwhale. \r\n     */\r\n    function limitAmount(uint256 _rId, uint256 _sId)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        uint256 _amount = msg.value;\r\n        \r\n        if(amountLimit.length > _sId)\r\n            _amount = ((stage[_rId][_sId].targetAmount.mul(amountLimit[_sId])) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender]);\r\n        else\r\n            _amount = ((stage[_rId][_sId].targetAmount.mul(500)) / 1000).sub(playerStageAmount[_rId][_sId][msg.sender]);\r\n            \r\n        if(_amount >= msg.value)\r\n            return msg.value;\r\n        else\r\n            msg.sender.transfer(msg.value.sub(_amount));\r\n        \r\n        return _amount;\r\n    }\r\n    \r\n    /**\r\n     * Record the addresses eligible for promotion links.\r\n     */\r\n    function promotionDataRecord(address _recommendAddr, uint256 _amount)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        uint256 _promotionRatio = promotionRatio;\r\n        \r\n        if(_recommendAddr != 0x0000000000000000000000000000000000000000 \r\n            && _recommendAddr != msg.sender \r\n            && player[_recommendAddr].active == true\r\n        )\r\n            player[_recommendAddr].promotionAmount = player[_recommendAddr].promotionAmount.add((_amount.mul(_promotionRatio)) / 100);\r\n        else\r\n            _promotionRatio = 0;\r\n        \r\n        return _promotionRatio;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Records the round data.\r\n     */\r\n    function buyRoundDataRecord(uint256 _rId, uint256 _amount)\r\n        private\r\n    {\r\n\r\n        round[_rId].amount = round[_rId].amount.add(_amount);\r\n        developerAddr.transfer(_amount.mul(scientists) / 100);\r\n    }\r\n    \r\n    /**\r\n     * Records the stage data.\r\n     */\r\n    function buyStageDataRecord(uint256 _rId, uint256 _sId, uint256 _promotionRatio, uint256 _amount)\r\n        stageVerify(_rId, _sId, _amount)\r\n        private\r\n    {\r\n        if(_amount <= 0)\r\n            return;\r\n        stage[_rId][_sId].amount = stage[_rId][_sId].amount.add(_amount);\r\n        stage[_rId][_sId].dividendAmount = stage[_rId][_sId].dividendAmount.add((_amount.mul(dividend.sub(_promotionRatio))) / 100);\r\n    }\r\n    \r\n    /**\r\n     * Records the player data.\r\n     */\r\n    function buyPlayerDataRecord(uint256 _rId, uint256 _sId, uint256 _amount)\r\n        private\r\n    {\r\n        if(_amount <= 0)\r\n            return;\r\n            \r\n        if(player[msg.sender].active == false){\r\n            player[msg.sender].active = true;\r\n            player[msg.sender].withdrawRid = _rId;\r\n            player[msg.sender].withdrawSid = _sId;\r\n        }\r\n            \r\n        if(playerRoundAmount[_rId][msg.sender] == 0){\r\n            round[_rId].players++;\r\n            playerRoundSid[_rId][msg.sender] = _sId;\r\n        }\r\n            \r\n        if(playerStageAmount[_rId][_sId][msg.sender] == 0)\r\n            stage[_rId][_sId].players++;\r\n            \r\n        playerRoundAmount[_rId][msg.sender] = playerRoundAmount[_rId][msg.sender].add(_amount);\r\n        playerStageAmount[_rId][_sId][msg.sender] = playerStageAmount[_rId][_sId][msg.sender].add(_amount);\r\n        \r\n        player[msg.sender].amount = player[msg.sender].amount.add(_amount);\r\n        \r\n        if(playerRoundSid[_rId][msg.sender] > 0){\r\n            \r\n            if(playerStageAccAmount[_rId][_sId][msg.sender] == 0){\r\n                \r\n                for(uint256 i = playerRoundSid[_rId][msg.sender]; i < _sId; i++){\r\n                \r\n                    if(playerStageAmount[_rId][i][msg.sender] > 0)\r\n                        playerStageAccAmount[_rId][_sId][msg.sender] = playerStageAccAmount[_rId][_sId][msg.sender].add(playerStageAmount[_rId][i][msg.sender]);\r\n                    \r\n                }\r\n            }\r\n            \r\n            playerStageAccAmount[_rId][_sId][msg.sender] = playerStageAccAmount[_rId][_sId][msg.sender].add(_amount);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Execute end of round events.\r\n     */\r\n    function endRound(uint256 _rId, uint256 _sId)\r\n        private\r\n    {\r\n        round[_rId].end = now;\r\n        round[_rId].ended = true;\r\n        round[_rId].endSid = _sId;\r\n        stage[_rId][_sId].end = now;\r\n        stage[_rId][_sId].ended = true;\r\n        \r\n        if(stage[_rId][_sId].players == 0)\r\n            round[_rId + 1].jackpotAmount = round[_rId + 1].jackpotAmount.add(round[_rId].jackpotAmount);\r\n        else\r\n            round[_rId + 1].jackpotAmount = round[_rId + 1].jackpotAmount.add(round[_rId].jackpotAmount.mul(100 - jackpotProportion) / 100);\r\n        \r\n        rId++;\r\n        sId = 1;\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Execute end of stage events.\r\n     */\r\n    function endStage(uint256 _rId, uint256 _sId)\r\n        private\r\n    {\r\n        uint256 _jackpotAmount = stage[_rId][_sId].amount.mul(jackpot) / 100;\r\n        round[_rId].endSid = _sId;\r\n        round[_rId].jackpotAmount = round[_rId].jackpotAmount.add(_jackpotAmount);\r\n        stage[_rId][_sId].end = now;\r\n        stage[_rId][_sId].ended = true;\r\n        if(_sId > 1)\r\n            stage[_rId][_sId].accAmount = stage[_rId][_sId].targetAmount.add(stage[_rId][_sId - 1].accAmount);\r\n        else\r\n            stage[_rId][_sId].accAmount = stage[_rId][_sId].targetAmount;\r\n        \r\n        sId++;\r\n    }\r\n    \r\n    /**\r\n     * Precalculations for withdraws to conserve gas.\r\n     */\r\n    function getPlayerDividendByStage(uint256 _rId, uint256 _sId, address _playerAddr)\r\n        private\r\n        view\r\n        returns(uint256, uint256, uint256, uint256)\r\n    {\r\n        \r\n        uint256 _dividend;\r\n        uint256 _stageNumber;\r\n        uint256 _startSid;\r\n        uint256 _playerAmount;    \r\n        \r\n        for(uint256 i = player[_playerAddr].withdrawRid; i <= _rId; i++){\r\n            \r\n            if(playerRoundAmount[i][_playerAddr] == 0)\r\n                continue;\r\n            \r\n            _playerAmount = 0;    \r\n            _startSid = i == player[_playerAddr].withdrawRid ? player[_playerAddr].withdrawSid : 1;\r\n            for(uint256 j = _startSid; j < round[i].endSid; j++){\r\n                    \r\n                if(playerStageAccAmount[i][j][_playerAddr] > 0)\r\n                    _playerAmount = playerStageAccAmount[i][j][_playerAddr];\r\n                    \r\n                if(_playerAmount == 0)\r\n                    _playerAmount = playerRoundwithdrawAmountFlag[i][_playerAddr];\r\n                    \r\n                if(_playerAmount == 0)\r\n                    continue;\r\n                _dividend = _dividend.add(\r\n                    (\r\n                        _playerAmount.mul(stage[i][j].dividendAmount)\r\n                    ).div(stage[i][j].accAmount)\r\n                );\r\n                \r\n                _stageNumber++;\r\n                if(_stageNumber >= 50)\r\n                    return (_dividend, i, j + 1, _playerAmount);\r\n            }\r\n            \r\n            if(round[i].ended == true\r\n                && stage[i][round[i].endSid].amount > 0\r\n                && playerStageAmount[i][round[i].endSid][_playerAddr] > 0\r\n            ){\r\n                _dividend = _dividend.add(getPlayerJackpot(_playerAddr, i));\r\n                _stageNumber++;\r\n                if(_stageNumber >= 50)\r\n                    return (_dividend, i + 1, 1, 0);\r\n            }\r\n        }\r\n        return (_dividend, _rId, _sId, _playerAmount);\r\n    }\r\n    \r\n    /**\r\n     * Get player current withdrawable dividend.\r\n     */\r\n    function getPlayerDividend(address _playerAddr)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _endRid = rId;\r\n        uint256 _startRid = player[_playerAddr].withdrawRid;\r\n        uint256 _startSid;\r\n        uint256 _dividend;\r\n        \r\n        for(uint256 i = _startRid; i <= _endRid; i++){\r\n            \r\n            if(i == _startRid)\r\n                _startSid = player[_playerAddr].withdrawSid;\r\n            else\r\n                _startSid = 1;\r\n            _dividend = _dividend.add(getPlayerDividendByRound(_playerAddr, i, _startSid));\r\n        }\r\n        \r\n        return _dividend;\r\n    }\r\n    \r\n    /**\r\n     * Get player data for rounds and stages.\r\n     */\r\n    function getPlayerDividendByRound(address _playerAddr, uint256 _rId, uint256 _sId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividend;\r\n        uint256 _startSid = _sId;\r\n        uint256 _endSid = round[_rId].endSid;\r\n        \r\n        uint256 _playerAmount;\r\n        uint256 _totalAmount;\r\n        for(uint256 i = _startSid; i < _endSid; i++){\r\n            \r\n            if(stage[_rId][i].ended == false)\r\n                continue;\r\n                \r\n            _playerAmount = 0;    \r\n            _totalAmount = 0;\r\n            for(uint256 j = 1; j <= i; j++){\r\n                \r\n                if(playerStageAmount[_rId][j][_playerAddr] > 0)\r\n                    _playerAmount = _playerAmount.add(playerStageAmount[_rId][j][_playerAddr]);\r\n                \r\n                _totalAmount = _totalAmount.add(stage[_rId][j].amount);\r\n            }\r\n            \r\n            if(_playerAmount == 0 || stage[_rId][i].dividendAmount == 0)\r\n                continue;\r\n            _dividend = _dividend.add((_playerAmount.mul(stage[_rId][i].dividendAmount)).div(_totalAmount));\r\n        }\r\n        \r\n        if(round[_rId].ended == true)\r\n            _dividend = _dividend.add(getPlayerJackpot(_playerAddr, _rId));\r\n\r\n        return _dividend;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Get player data for jackpot winnings.\r\n     */\r\n    function getPlayerJackpot(address _playerAddr, uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _dividend;\r\n        \r\n        if(round[_rId].ended == false)\r\n            return _dividend;\r\n        \r\n        uint256 _endSid = round[_rId].endSid;\r\n        uint256 _playerStageAmount = playerStageAmount[_rId][_endSid][_playerAddr];\r\n        uint256 _stageAmount = stage[_rId][_endSid].amount;\r\n        if(_stageAmount <= 0)\r\n            return _dividend;\r\n            \r\n        uint256 _jackpotAmount = round[_rId].jackpotAmount.mul(jackpotProportion) / 100;\r\n        uint256 _stageDividendAmount = stage[_rId][_endSid].dividendAmount;\r\n        uint256 _stageJackpotAmount = (_stageAmount.mul(jackpot) / 100).add(_stageDividendAmount);\r\n        \r\n        _dividend = _dividend.add(((_playerStageAmount.mul(_jackpotAmount)).div(_stageAmount)));\r\n        _dividend = _dividend.add(((_playerStageAmount.mul(_stageJackpotAmount)).div(_stageAmount)));\r\n        \r\n        return _dividend;\r\n    }\r\n    \r\n    /**\r\n     * For frontend.\r\n     */\r\n    function getHeadInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, bool)\r\n    {\r\n        return\r\n            (\r\n                rId,\r\n                sId,\r\n                round[rId].jackpotAmount,\r\n                stage[rId][sId].targetAmount,\r\n                stage[rId][sId].amount,\r\n                stage[rId][sId].end,\r\n                stage[rId][sId].ended\r\n            );\r\n    }\r\n    \r\n    /**\r\n     * For frontend.\r\n     */\r\n    function getPersonalStatus(address _playerAddr)\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256)\r\n    {\r\n        if (player[_playerAddr].active == true){\r\n            return\r\n            (\r\n                round[rId].jackpotAmount,\r\n                playerRoundAmount[rId][_playerAddr],\r\n                getPlayerDividendByRound(_playerAddr, rId, 1)\r\n            );\r\n        }else{\r\n            return\r\n            (\r\n                round[rId].jackpotAmount,\r\n                0,\r\n                0\r\n            );\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * For frontend.\r\n     */\r\n    function getValueInfo(address _playerAddr)\r\n        public\r\n        view\r\n        returns(uint256, uint256)\r\n    {\r\n        if (player[_playerAddr].active == true){\r\n            return\r\n            (\r\n                getPlayerDividend(_playerAddr),\r\n                player[_playerAddr].promotionAmount\r\n            );\r\n        }else{\r\n            return\r\n            (\r\n                0,\r\n                0\r\n            );\r\n        }\r\n    }\r\n    \r\n}\r\n\r\nlibrary Indatasets {\r\n    \r\n    struct Round {\r\n        uint256 start;          // time round started\r\n        uint256 end;            // time round ends/ended\r\n        bool ended;             // has round end function been ran\r\n        uint256 endSid;         // last stage for current round\r\n        uint256 amount;         // Eth recieved for current round\r\n        uint256 jackpotAmount;  // total jackpot for current round\r\n        uint256 players;        // total players for current round\r\n    }\r\n    \r\n    struct Stage {\r\n        uint256 start;          // time stage started\r\n        uint256 end;            // time strage ends/ended\r\n        bool ended;             // has stage end function been ran\r\n        uint256 targetAmount;   // amount needed for current stage\r\n        uint256 amount;         // Eth received for current stage\r\n        uint256 dividendAmount; // total dividend for current stage\r\n        uint256 accAmount;      // total accumulative amount for current stage\r\n        uint256 players;        // total players for current stage\r\n    }\r\n    \r\n    struct Player {\r\n        bool active;                // Activation status of player, if false player has not been activated.\r\n        uint256 amount;             // Total player input.\r\n        uint256 promotionAmount;    // Total promotion amount of the player.\r\n        uint256 withdrawRid;        // Last withdraw round of the player.\r\n        uint256 withdrawSid;        // Last withdraw stage of the player.\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerRoundwithdrawAmountFlag\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"scientists\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerStageAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddr\",\"type\":\"address\"}],\"name\":\"getPlayerDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stage\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"targetAmount\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"dividendAmount\",\"type\":\"uint256\"},{\"name\":\"accAmount\",\"type\":\"uint256\"},{\"name\":\"players\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"endSid\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"jackpotAmount\",\"type\":\"uint256\"},{\"name\":\"players\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerRoundAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"promotionAmount\",\"type\":\"uint256\"},{\"name\":\"withdrawRid\",\"type\":\"uint256\"},{\"name\":\"withdrawSid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerStageAccAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerRoundSid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promotionRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotProportion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddr\",\"type\":\"address\"},{\"name\":\"_rId\",\"type\":\"uint256\"},{\"name\":\"_sId\",\"type\":\"uint256\"}],\"name\":\"getPlayerDividendByRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountProportion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddr\",\"type\":\"address\"},{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getPlayerJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddr\",\"type\":\"address\"}],\"name\":\"getPersonalStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddr\",\"type\":\"address\"}],\"name\":\"getValueInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHeadInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recommendAddr\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Infinity","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c491b4fa52ea9260696dea5aea7bcb79914b0e65fee8a5f24dad8ff5c6bdd54e"}]}