{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/** \r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n* \r\n* Web              - https://333eth.io\r\n* \r\n* Twitter          - https://twitter.com/333eth_io\r\n* \r\n* Telegram_channel - https://t.me/Ethereum333\r\n* \r\n* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\r\n* \r\n* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\r\n* \r\n* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\r\n* \r\n* Email:             mailto:support(at sign)333eth.io\r\n* \r\n* \r\n* \r\n* AO Rules:\r\n* \r\n* Shareholders are all participants of 333eth v1, v2 projects without exception\r\n* \r\n* Received ETH share as follows:\r\n* \r\n* 97% for losers, in projects 333eth v1, v2 in proportion to their losses\r\n* \r\n* 3% for winners - the same amount.\r\n* \r\n* \r\n* \r\n* Payment of dividends - every Saturday at 18.00 Moscow time.\r\n* \r\n* The contract of the JSC prescribed a waiver of ownership. And payments are unchanged.\r\n* \r\n* The specific amount of payments to each shareholder is determined by the success of the project. Your participation in previous projects determines your % in AO.\r\n*/\r\n\r\n\r\nlibrary RecipientsStorage {\r\n  struct Storage {\r\n    mapping(address => Recipient) data;\r\n    KeyFlag[] keys;\r\n    uint size;\r\n    uint losersValSum;\r\n    uint winnersNum;\r\n  }\r\n\r\n  struct Recipient { \r\n    uint keyIndex;\r\n    uint value;\r\n    bool isWinner;\r\n  }\r\n\r\n  struct KeyFlag { \r\n    address key; \r\n    bool deleted;\r\n  }\r\n\r\n  function init(Storage storage s) internal {\r\n    s.keys.length++;\r\n  }\r\n\r\n  function insert(Storage storage s, address key, uint value, bool isWinner) internal returns (bool) {\r\n    uint keyIndex = s.data[key].keyIndex;\r\n   \r\n    if (!s.data[key].isWinner) {\r\n      s.losersValSum -= s.data[key].value;\r\n    }\r\n\r\n    if (!isWinner) {\r\n      s.losersValSum += value;\r\n    }\r\n\r\n    if (isWinner && !s.data[key].isWinner) {\r\n      s.winnersNum++;\r\n    }\r\n    s.data[key].value = value;\r\n    s.data[key].isWinner = isWinner;\r\n\r\n    if (keyIndex > 0) {\r\n      return true;\r\n    }\r\n\r\n    keyIndex = s.keys.length++;\r\n    s.data[key].keyIndex = keyIndex;\r\n    s.keys[keyIndex].key = key;\r\n    s.size++;\r\n    return true;\r\n  }\r\n\r\n  function remove(Storage storage s, address key) internal returns (bool) {\r\n    uint keyIndex = s.data[key].keyIndex;\r\n    if (keyIndex == 0) {\r\n      return false;\r\n    }\r\n\r\n    if (s.data[key].isWinner) {\r\n      s.winnersNum--;\r\n    } else {\r\n      s.losersValSum -= s.data[key].value;\r\n    }\r\n    \r\n      \r\n    delete s.data[key];\r\n    s.keys[keyIndex].deleted = true;\r\n    s.size--;\r\n    return true;\r\n  }\r\n\r\n  function recipient(Storage storage s, address key) internal view returns (Recipient memory r) {\r\n    return Recipient(s.data[key].keyIndex, s.data[key].value, s.data[key].isWinner);\r\n  }\r\n  \r\n  function iterStart(Storage storage s) internal view returns (uint keyIndex) {\r\n    return iterNext(s, 0);\r\n  }\r\n\r\n  function iterValid(Storage storage s, uint keyIndex) internal view returns (bool) {\r\n    return keyIndex < s.keys.length;\r\n  }\r\n\r\n  function iterNext(Storage storage s, uint keyIndex) internal view returns (uint r_keyIndex) {\r\n    r_keyIndex = keyIndex + 1;\r\n    while (r_keyIndex < s.keys.length && s.keys[r_keyIndex].deleted) {\r\n      r_keyIndex++;\r\n    }\r\n  }\r\n\r\n  function iterGet(Storage storage s, uint keyIndex) internal view returns (address key, Recipient storage r) {\r\n    key = s.keys[keyIndex].key;\r\n    r = s.data[key];\r\n  }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n  enum AccessRank { None, Payout, Manager, Full }\r\n  mapping(address => AccessRank) internal m_admins;\r\n  modifier onlyAdmin(AccessRank  r) {\r\n    require(\r\n      m_admins[msg.sender] == r || m_admins[msg.sender] == AccessRank.Full,\r\n      \"access denied\"\r\n    );\r\n    _;\r\n  }\r\n  event LogProvideAccess(address indexed whom, AccessRank rank, uint when);\r\n\r\n  constructor() public {\r\n    m_admins[msg.sender] = AccessRank.Full;\r\n    emit LogProvideAccess(msg.sender, AccessRank.Full, now);\r\n  }\r\n  \r\n  function provideAccess(address addr, AccessRank rank) public onlyAdmin(AccessRank.Manager) {\r\n    require(rank <= AccessRank.Manager, \"cannot to give full access rank\");\r\n    if (m_admins[addr] != rank) {\r\n      m_admins[addr] = rank;\r\n      emit LogProvideAccess(addr, rank, now);\r\n    }\r\n  }\r\n\r\n  function access(address addr) public view returns(AccessRank rank) {\r\n    rank = m_admins[addr];\r\n  }\r\n}\r\n\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  // storage operations\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b >= a) return 0; // solium-disable-line lbrace\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a + mul(p, a);\r\n  }\r\n\r\n  // memory operations\r\n  function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function msub(percent memory p, uint a) internal pure returns (uint) {\r\n    uint b = mmul(p, a);\r\n    if (b >= a) return 0; // solium-disable-line lbrace\r\n    return a - b;\r\n  }\r\n\r\n  function madd(percent memory p, uint a) internal pure returns (uint) {\r\n    return a + mmul(p, a);\r\n  }\r\n}\r\n\r\n\r\ncontract AO is Accessibility {\r\n  using Percent for Percent.percent;\r\n  using RecipientsStorage for RecipientsStorage.Storage;\r\n  \r\n  uint public payPaymentTime;\r\n  uint public payKeyIndex;\r\n  uint public payValue;\r\n\r\n  RecipientsStorage.Storage private m_recipients;\r\n  Percent.percent private m_winnersPercent = Percent.percent(3, 100);\r\n  Percent.percent private m_losersPercent = Percent.percent(97, 100);\r\n\r\n  event LogPayDividends(address indexed addr, uint dividends, bool isWinner, uint when);\r\n  event LogInsertRecipient(address indexed addr, uint value, bool isWinner, uint when);\r\n  event LogRemoveRecipient(address indexed addr, uint when);\r\n\r\n  constructor() public {\r\n    m_recipients.init();\r\n    payKeyIndex = m_recipients.iterStart();\r\n  }\r\n\r\n  function() external payable {}\r\n\r\n  function payoutIsDone() public view returns(bool done) {\r\n    return payKeyIndex == m_recipients.iterStart();\r\n  }\r\n\r\n  function losersValueSum() public view returns(uint sum) {\r\n    return m_recipients.losersValSum;\r\n  }\r\n\r\n  function winnersNumber() public view returns(uint number) {\r\n    return m_recipients.winnersNum;\r\n  }\r\n\r\n  function recipient(address addr) public view returns(uint value, bool isWinner, uint numerator, uint denominator) {\r\n    RecipientsStorage.Recipient memory r = m_recipients.recipient(addr);\r\n    (value, isWinner) = (r.value, r.isWinner);\r\n\r\n    if (r.isWinner) {\r\n      numerator = m_winnersPercent.num;\r\n      denominator = m_winnersPercent.den * m_recipients.winnersNum;\r\n    } else {\r\n      numerator = m_losersPercent.num * r.value;\r\n      denominator = m_losersPercent.den * m_recipients.losersValSum;\r\n    }\r\n  }\r\n\r\n  function recipientsSize() public view returns(uint size) {\r\n    return m_recipients.size;\r\n  }\r\n\r\n  function recipients() public view returns(address[] memory addrs, uint[] memory values, bool[] memory isWinners) {\r\n    addrs = new address[](m_recipients.size);\r\n    values = new uint[](m_recipients.size);\r\n    isWinners = new bool[](m_recipients.size);\r\n    RecipientsStorage.Recipient memory r;\r\n    uint i = m_recipients.iterStart();\r\n    uint c;\r\n\r\n    for (i; m_recipients.iterValid(i); i = m_recipients.iterNext(i)) {\r\n      (addrs[c], r) = m_recipients.iterGet(i);\r\n      values[c] = r.value;\r\n      isWinners[c] = r.isWinner;\r\n      c++;\r\n    }\r\n  }\r\n\r\n  function insertRecipients(address[] memory addrs, uint[] memory values, bool[] memory isWinners) public onlyAdmin(AccessRank.Full) {\r\n    require(addrs.length == values.length && values.length == isWinners.length, \"invalid arguments length\");\r\n    for (uint i; i < addrs.length; i++) {\r\n      if (addrs[i] == address(0x0)) {\r\n        continue;\r\n      }\r\n      if (m_recipients.insert(addrs[i], values[i], isWinners[i])) {\r\n        emit LogInsertRecipient(addrs[i], values[i], isWinners[i], now);\r\n      }\r\n    }\r\n  }\r\n\r\n  function removeRecipients(address[] memory addrs) public onlyAdmin(AccessRank.Full) {\r\n    for (uint i; i < addrs.length; i++) {\r\n      if (m_recipients.remove(addrs[i])) {\r\n        emit LogRemoveRecipient(addrs[i], now);\r\n      }\r\n    }\r\n  }\r\n\r\n  function payout() public onlyAdmin(AccessRank.Payout) { \r\n    if (payKeyIndex == m_recipients.iterStart()) {\r\n      require(address(this).balance > 0, \"zero balance\");\r\n      require(now > payPaymentTime + 12 hours, \"the latest payment was earlier than 12 hours\");\r\n      payPaymentTime = now;\r\n      payValue = address(this).balance;\r\n    }\r\n\r\n    uint dividends;\r\n    uint i = payKeyIndex;\r\n    uint valueForWinner = m_winnersPercent.mul(payValue) / m_recipients.winnersNum;\r\n    uint valueForLosers = m_losersPercent.mul(payValue);\r\n    RecipientsStorage.Recipient memory r;\r\n    address rAddr;\r\n\r\n    for (i; m_recipients.iterValid(i) && gasleft() > 60000; i = m_recipients.iterNext(i)) {\r\n      (rAddr, r) = m_recipients.iterGet(i);\r\n      if (r.isWinner) {\r\n        dividends = valueForWinner;\r\n      } else {\r\n        dividends = valueForLosers * r.value / m_recipients.losersValSum;\r\n      }\r\n      if (rAddr.send(dividends)) {\r\n        emit LogPayDividends(rAddr, dividends, r.isWinner, now);\r\n      }\r\n    }\r\n\r\n    if (m_recipients.iterValid(i)) {\r\n      payKeyIndex = i;\r\n    } else {\r\n      payKeyIndex = m_recipients.iterStart();\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"recipients\",\"outputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"},{\"name\":\"isWinners\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"losersValueSum\",\"outputs\":[{\"name\":\"sum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"}],\"name\":\"removeRecipients\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnersNumber\",\"outputs\":[{\"name\":\"number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"access\",\"outputs\":[{\"name\":\"rank\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payKeyIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"recipient\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"isWinner\",\"type\":\"bool\"},{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addrs\",\"type\":\"address[]\"},{\"name\":\"values\",\"type\":\"uint256[]\"},{\"name\":\"isWinners\",\"type\":\"bool[]\"}],\"name\":\"insertRecipients\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payPaymentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"rank\",\"type\":\"uint8\"}],\"name\":\"provideAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"recipientsSize\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payoutIsDone\",\"outputs\":[{\"name\":\"done\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dividends\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isWinner\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isWinner\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogInsertRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogRemoveRecipient\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rank\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogProvideAccess\",\"type\":\"event\"}]","ContractName":"AO","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://382317e87283a45bbee04d7438c83d4bf51a7cda359f148c7801cbd5ff3073eb"}]}