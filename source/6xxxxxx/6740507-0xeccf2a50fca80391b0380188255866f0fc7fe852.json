{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n*\r\n* ETH INVESTMENT SMART PLATFORM - ETHUP\r\n* Web              - https://ethup.io\r\n* GitHub           - https://github.com/ethup/ethup\r\n* Twitter          - https://twitter.com/ethup1\r\n* Youtube          - https://www.youtube.com/channel/UC4JMZcpySACj4lGbXLJm9KQ\r\n* Telegram_channel - https://t.me/Ethereum333\r\n* EN  Telegram_chat: https://t.me/Ethup_en\r\n* RU  Telegram_chat: https://t.me/Ethup_ru\r\n* KOR Telegram_chat: https://t.me/Ethup_kor\r\n* CN  Telegram_chat: https://t.me/Ethup_cn\r\n* Email:             mailto:info(at sign)ethup.io\r\n* \r\n* \r\n*  - GAIN 1% - 4% PER 24 HOURS\r\n*  - Life-long payments\r\n*  - The revolutionary reliability\r\n*  - Minimal contribution 0.01 eth\r\n*  - Currency and payment - ETH\r\n*  - Contribution allocation schemes:\r\n*    -- 85,0% payments\r\n*    --   10% marketing\r\n*    --    5% technical support\r\n*\r\n*   ---About the Project\r\n*  Blockchain-enabled smart contracts have opened a new era of trustless relationships without \r\n*  intermediaries. This technology opens incredible financial possibilities. Our automated investment \r\n*  smart platform is written into a smart contract, uploaded to the Ethereum blockchain and can be \r\n*  freely accessed online. In order to insure our investors' complete security, full control over the \r\n*  project has been transferred from the organizers to the smart contract: nobody can influence the \r\n*  system's permanent autonomous functioning.\r\n* \r\n* ---How to use:\r\n*  1. Select a level and send from ETH wallet to the smart contract address 0xeccf2a50fca80391b0380188255866f0fc7fe852\r\n*     any amount from 0.01 to 50 ETH.\r\n*\r\n*       Level 1: from 0.01 to 0.1 ETH - 1%\r\n*       Level 2: from 0.1 to 1 ETH - 1.5%\r\n*       Level 3: from 1 to 5 ETH - 2.0%\r\n*       Level 4: from 5 to 10 ETH - 2.5%\r\n*       Level 5: from 10 to 20 ETH - 3%.\r\n*       Level 6: from 20 to 30 ETH - 3.5%\r\n*       Level 7: from 30 to 50 ETH - 4%\r\n*\r\n*  2. Verify your transaction in the history of your application (wallet) or etherscan.io, specifying the address \r\n*     of your wallet.\r\n*  3a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're \r\n*      spending too much on GAS) to the smart contract address 0xeccf2a50fca80391b0380188255866f0fc7fe852.\r\n*  OR\r\n*  3b. For add investment, you need to deposit the amount that you want to add and the \r\n*      accrued interest automatically summed to your new contribution.\r\n*  \r\n* RECOMMENDED GAS LIMIT: 200000\r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n* You can check the payments on the etherscan.io site, in the \"Internal Txns\" tab of your wallet.\r\n*\r\n* Every 24 hours from the moment of the deposit or from the last successful write-off of the accrued interest, \r\n* the smart contract will transfer your dividends to your account that corresponds to the number of your wallet. \r\n* Dividends are accrued until 150% of the investment is paid.\r\n* After receiving 150% of all invested funds (or 50% of profits), your wallet will disconnected from payments. \r\n* You can make reinvestment by receiving an additional + 10% for the deposit amount and continue the participation. \r\n* The bonus will received only by the participant who has already received 150% of the profits and invests again.\r\n*\r\n* The amount of daily charges depends on the sum of all the participant's contributions to the smart contract.\r\n*\r\n* In case you make a contribution without first removing the accrued interest,\r\n* it is added to your new contribution and credited to your account in smart contract\r\n*\r\n* ---Additional tools embedded in the smart contract:\r\n*     - Referral program 5%. The same bonus gets referral and referrer.\r\n*     - Reinvestment. After full payment of your first investment, you can receive a 10% bonus for reinvesting funds. \r\n*       You can reinvest any amount.\r\n*     - BOOST mode. Get the percentage of your funds remaining in the system. \r\n*\r\n* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \r\n* have private keys.\r\n* \r\n* Contracts reviewed and approved by pros!\r\n* \r\n* Main contract - EthUp. Scroll down to find it.\r\n*/ \r\n\r\n\r\nlibrary Zero {\r\n    function requireNotZero(address addr) internal pure {\r\n        require(addr != address(0), \"require not zero address\");\r\n    }\r\n\r\n    function requireNotZero(uint val) internal pure {\r\n        require(val != 0, \"require not zero value\");\r\n    }\r\n\r\n    function notZero(address addr) internal pure returns(bool) {\r\n        return !(addr == address(0));\r\n    }\r\n\r\n    function isZero(address addr) internal pure returns(bool) {\r\n        return addr == address(0);\r\n    }\r\n\r\n    function isZero(uint a) internal pure returns(bool) {\r\n        return a == 0;\r\n    }\r\n\r\n    function notZero(uint a) internal pure returns(bool) {\r\n        return a != 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\nlibrary Percent {\r\n    using SafeMath for uint;\r\n\r\n    // Solidity automatically throws when dividing by 0\r\n    struct percent {\r\n        uint num;\r\n        uint den;\r\n    }\r\n\r\n    function mul(percent storage p, uint a) internal view returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a.mul(p.num).div(p.den);\r\n    }\r\n\r\n    function div(percent storage p, uint a) internal view returns (uint) {\r\n        return a.div(p.num).mul(p.den);\r\n    }\r\n\r\n    function sub(percent storage p, uint a) internal view returns (uint) {\r\n        uint b = mul(p, a);\r\n        if (b >= a) {\r\n            return 0; // solium-disable-line lbrace\r\n        }\r\n        return a.sub(b);\r\n    }\r\n\r\n    function add(percent storage p, uint a) internal view returns (uint) {\r\n        return a.add(mul(p, a));\r\n    }\r\n\r\n    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n        return Percent.percent(p.num, p.den);\r\n    }\r\n\r\n    // memory\r\n    function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        return a.mul(p.num).div(p.den);\r\n    }\r\n\r\n    function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n        return a.div(p.num).mul(p.den);\r\n    }\r\n\r\n    function msub(percent memory p, uint a) internal pure returns (uint) {\r\n        uint b = mmul(p, a);\r\n        if (b >= a) {\r\n            return 0;\r\n        }\r\n        return a.sub(b);\r\n    }\r\n\r\n    function madd(percent memory p, uint a) internal pure returns (uint) {\r\n        return a.add(mmul(p, a));\r\n    }\r\n}\r\n\r\nlibrary ToAddress {\r\n\r\n    function toAddress(bytes source) internal pure returns(address addr) {\r\n        assembly { addr := mload(add(source, 0x14)) }\r\n        return addr;\r\n    }\r\n\r\n    function isNotContract(address addr) internal view returns(bool) {\r\n        uint length;\r\n        assembly { length := extcodesize(addr) }\r\n        return length == 0;\r\n    }\r\n}\r\n\r\ncontract Accessibility {\r\n\r\n    address private owner;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"access denied\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function disown() internal {\r\n        delete owner;\r\n    }\r\n}\r\n\r\ncontract InvestorsStorage is Accessibility {\r\n    using SafeMath for uint;\r\n\r\n    struct Dividends {\r\n        uint value;     //paid\r\n        uint limit;\r\n        uint deferred;  //not paid yet\r\n    }\r\n\r\n    struct Investor {\r\n        uint investment;\r\n        uint paymentTime;\r\n        Dividends dividends;\r\n    }\r\n\r\n    uint public size;\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    function isInvestor(address addr) public view returns (bool) {\r\n        return investors[addr].investment > 0;\r\n    }\r\n\r\n    function investorInfo(\r\n        address addr\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint investment,\r\n            uint paymentTime,\r\n            uint value,\r\n            uint limit,\r\n            uint deferred\r\n        )\r\n    {\r\n        investment = investors[addr].investment;\r\n        paymentTime = investors[addr].paymentTime;\r\n        value = investors[addr].dividends.value;\r\n        limit = investors[addr].dividends.limit;\r\n        deferred = investors[addr].dividends.deferred;\r\n    }\r\n\r\n    function newInvestor(\r\n        address addr,\r\n        uint investment,\r\n        uint paymentTime,\r\n        uint dividendsLimit\r\n    )\r\n        public\r\n        onlyOwner\r\n        returns (\r\n            bool\r\n        )\r\n    {\r\n        Investor storage inv = investors[addr];\r\n        if (inv.investment != 0 || investment == 0) {\r\n            return false;\r\n        }\r\n        inv.investment = investment;\r\n        inv.paymentTime = paymentTime;\r\n        inv.dividends.limit = dividendsLimit;\r\n        size++;\r\n        return true;\r\n    }\r\n\r\n    function addInvestment(address addr, uint investment) public onlyOwner returns (bool) {\r\n        if (investors[addr].investment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].investment = investors[addr].investment.add(investment);\r\n        return true;\r\n    }\r\n\r\n    function setPaymentTime(address addr, uint paymentTime) public onlyOwner returns (bool) {\r\n        if (investors[addr].investment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].paymentTime = paymentTime;\r\n        return true;\r\n    }\r\n\r\n    function addDeferredDividends(address addr, uint dividends) public onlyOwner returns (bool) {\r\n        if (investors[addr].investment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].dividends.deferred = investors[addr].dividends.deferred.add(dividends);\r\n        return true;\r\n    }\r\n\r\n    function addDividends(address addr, uint dividends) public onlyOwner returns (bool) {\r\n        if (investors[addr].investment == 0) {\r\n            return false;\r\n        }\r\n        if (investors[addr].dividends.value + dividends > investors[addr].dividends.limit) {\r\n            investors[addr].dividends.value = investors[addr].dividends.limit;\r\n        } else {\r\n            investors[addr].dividends.value = investors[addr].dividends.value.add(dividends);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function setNewInvestment(address addr, uint investment, uint limit) public onlyOwner returns (bool) {\r\n        if (investors[addr].investment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].investment = investment;\r\n        investors[addr].dividends.limit = limit;\r\n        // reset payment dividends\r\n        investors[addr].dividends.value = 0;\r\n        investors[addr].dividends.deferred = 0;\r\n\r\n        return true;\r\n    }\r\n\r\n    function addDividendsLimit(address addr, uint limit) public onlyOwner returns (bool) {\r\n        if (investors[addr].investment == 0) {\r\n            return false;\r\n        }\r\n        investors[addr].dividends.limit = investors[addr].dividends.limit.add(limit);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract EthUp is Accessibility {\r\n    using Percent for Percent.percent;\r\n    using SafeMath for uint;\r\n    using Zero for *;\r\n    using ToAddress for *;\r\n\r\n    // investors storage - iterable map;\r\n    InvestorsStorage private m_investors;\r\n    mapping(address => bool) private m_referrals;\r\n\r\n    // automatically generates getters\r\n    address public advertisingAddress;\r\n    address public adminsAddress;\r\n    uint public investmentsNumber;\r\n    uint public constant MIN_INVESTMENT = 10 finney; // 0.01 eth\r\n    uint public constant MAX_INVESTMENT = 50 ether;\r\n    uint public constant MAX_BALANCE = 1e5 ether; // 100 000 eth\r\n\r\n    // percents\r\n    Percent.percent private m_1_percent = Percent.percent(1, 100);          //  1/100   *100% = 1%\r\n    Percent.percent private m_1_5_percent = Percent.percent(15, 1000);      //  15/1000 *100% = 1.5%\r\n    Percent.percent private m_2_percent = Percent.percent(2, 100);          //  2/100   *100% = 2%\r\n    Percent.percent private m_2_5_percent = Percent.percent(25, 1000);      //  25/1000 *100% = 2.5%\r\n    Percent.percent private m_3_percent = Percent.percent(3, 100);          //  3/100   *100% = 3%\r\n    Percent.percent private m_3_5_percent = Percent.percent(35, 1000);      //  35/1000 *100% = 3.5%\r\n    Percent.percent private m_4_percent = Percent.percent(4, 100);          //  4/100   *100% = 4%\r\n\r\n    Percent.percent private m_refPercent = Percent.percent(5, 100);         //  5/100   *100% = 5%\r\n    Percent.percent private m_adminsPercent = Percent.percent(5, 100);      //  5/100   *100% = 5%\r\n    Percent.percent private m_advertisingPercent = Percent.percent(1, 10);  //  1/10    *100% = 10%\r\n\r\n    Percent.percent private m_maxDepositPercent = Percent.percent(15, 10);  //  15/10   *100% = 150%\r\n    Percent.percent private m_reinvestPercent = Percent.percent(1, 10);     //  10/100  *100% = 10%\r\n\r\n    // more events for easy read from blockchain\r\n    event LogSendExcessOfEther(address indexed addr, uint when, uint value, uint investment, uint excess);\r\n    event LogNewInvestor(address indexed addr, uint when);\r\n    event LogNewInvestment(address indexed addr, uint when, uint investment, uint value);\r\n    event LogNewReferral(address indexed addr, address indexed referrerAddr, uint when, uint refBonus);\r\n    event LogReinvest(address indexed addr, uint when, uint investment);\r\n    event LogPayDividends(address indexed addr, uint when, uint value);\r\n    event LogPayReferrerBonus(address indexed addr, uint when, uint value);\r\n    event LogBalanceChanged(uint when, uint balance);\r\n    event LogDisown(uint when);\r\n\r\n    modifier balanceChanged() {\r\n        _;\r\n        emit LogBalanceChanged(now, address(this).balance);\r\n    }\r\n\r\n    modifier notFromContract() {\r\n        require(msg.sender.isNotContract(), \"only externally accounts\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        adminsAddress = msg.sender;\r\n        advertisingAddress = msg.sender;\r\n\r\n        m_investors = new InvestorsStorage();\r\n        investmentsNumber = 0;\r\n    }\r\n\r\n    function() public payable {\r\n        // investor get him dividends\r\n        if (msg.value.isZero()) {\r\n            getMyDividends();\r\n            return;\r\n        }\r\n\r\n        // sender do invest\r\n        doInvest(msg.data.toAddress());\r\n    }\r\n\r\n    function doDisown() public onlyOwner {\r\n        disown();\r\n        emit LogDisown(now);\r\n    }\r\n\r\n    function investorsNumber() public view returns(uint) {\r\n        return m_investors.size();\r\n    }\r\n\r\n    function balanceETH() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function percent1() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_1_percent.num, m_1_percent.den);\r\n    }\r\n\r\n    function percent1_5() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_1_5_percent.num, m_1_5_percent.den);\r\n    }\r\n\r\n    function percent2() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_2_percent.num, m_2_percent.den);\r\n    }\r\n\r\n    function percent2_5() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_2_5_percent.num, m_2_5_percent.den);\r\n    }\r\n\r\n    function percent3() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_3_percent.num, m_3_percent.den);\r\n    }\r\n\r\n    function percent3_5() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_3_5_percent.num, m_3_5_percent.den);\r\n    }\r\n\r\n    function percent4() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_4_percent.num, m_4_percent.den);\r\n    }\r\n\r\n    function advertisingPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_advertisingPercent.num, m_advertisingPercent.den);\r\n    }\r\n\r\n    function adminsPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\r\n    }\r\n\r\n    function maxDepositPercent() public view returns(uint numerator, uint denominator) {\r\n        (numerator, denominator) = (m_maxDepositPercent.num, m_maxDepositPercent.den);\r\n    }\r\n\r\n    function investorInfo(\r\n        address investorAddr\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint investment,\r\n            uint paymentTime,\r\n            uint dividends,\r\n            uint dividendsLimit,\r\n            uint dividendsDeferred,\r\n            bool isReferral\r\n        )\r\n    {\r\n        (\r\n            investment,\r\n            paymentTime,\r\n            dividends,\r\n            dividendsLimit,\r\n            dividendsDeferred\r\n        ) = m_investors.investorInfo(investorAddr);\r\n\r\n        isReferral = m_referrals[investorAddr];\r\n    }\r\n\r\n    function getInvestorDividendsAtNow(\r\n        address investorAddr\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint dividends\r\n        )\r\n    {\r\n        dividends = calcDividends(investorAddr);\r\n    }\r\n\r\n    function getDailyPercentAtNow(\r\n        address investorAddr\r\n    )\r\n        public\r\n        view\r\n        returns (\r\n            uint numerator,\r\n            uint denominator\r\n        )\r\n    {\r\n        InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\r\n\r\n        Percent.percent memory p = getDailyPercent(investor.investment);\r\n        (numerator, denominator) = (p.num, p.den);\r\n    }\r\n\r\n    function getRefBonusPercentAtNow() public view returns(uint numerator, uint denominator) {\r\n        Percent.percent memory p = getRefBonusPercent();\r\n        (numerator, denominator) = (p.num, p.den);\r\n    }\r\n\r\n    function getMyDividends() public notFromContract balanceChanged {\r\n        // calculate dividends\r\n        uint dividends = calcDividends(msg.sender);\r\n        require(dividends.notZero(), \"cannot to pay zero dividends\");\r\n\r\n        // update investor payment timestamp\r\n        assert(m_investors.setPaymentTime(msg.sender, now));\r\n\r\n        // check enough eth\r\n        if (address(this).balance < dividends) {\r\n            dividends = address(this).balance;\r\n        }\r\n\r\n        // update payouts dividends\r\n        assert(m_investors.addDividends(msg.sender, dividends));\r\n\r\n        // transfer dividends to investor\r\n        msg.sender.transfer(dividends);\r\n        emit LogPayDividends(msg.sender, now, dividends);\r\n    }\r\n\r\n    function doInvest(address referrerAddr) public payable notFromContract balanceChanged {\r\n        uint investment = msg.value;\r\n        uint receivedEther = msg.value;\r\n\r\n        require(investment >= MIN_INVESTMENT, \"investment must be >= MIN_INVESTMENT\");\r\n        require(address(this).balance + investment <= MAX_BALANCE, \"the contract eth balance limit\");\r\n\r\n        // send excess of ether if needed\r\n        if (receivedEther > MAX_INVESTMENT) {\r\n            uint excess = receivedEther - MAX_INVESTMENT;\r\n            investment = MAX_INVESTMENT;\r\n            msg.sender.transfer(excess);\r\n            emit LogSendExcessOfEther(msg.sender, now, receivedEther, investment, excess);\r\n        }\r\n\r\n        // commission\r\n        uint advertisingCommission = m_advertisingPercent.mul(investment);\r\n        uint adminsCommission = m_adminsPercent.mul(investment);\r\n\r\n        bool senderIsInvestor = m_investors.isInvestor(msg.sender);\r\n\r\n        // ref system works only once and only on first invest\r\n        if (referrerAddr.notZero() &&\r\n            !senderIsInvestor &&\r\n            !m_referrals[msg.sender] &&\r\n            referrerAddr != msg.sender &&\r\n            m_investors.isInvestor(referrerAddr)) {\r\n\r\n            // add referral bonus to investor`s and referral`s investments\r\n            uint refBonus = getRefBonusPercent().mmul(investment);\r\n            assert(m_investors.addInvestment(referrerAddr, refBonus)); // add referrer bonus\r\n            investment = investment.add(refBonus);                     // add referral bonus\r\n            m_referrals[msg.sender] = true;\r\n            emit LogNewReferral(msg.sender, referrerAddr, now, refBonus);\r\n        }\r\n\r\n        // Dividends cannot be greater then 150% from investor investment\r\n        uint maxDividends = getMaxDepositPercent().mmul(investment);\r\n\r\n        if (senderIsInvestor) {\r\n            // check for reinvest\r\n            InvestorsStorage.Investor memory investor = getMemInvestor(msg.sender);\r\n            if (investor.dividends.value == investor.dividends.limit) {\r\n                uint reinvestBonus = getReinvestBonusPercent().mmul(investment);\r\n                investment = investment.add(reinvestBonus);\r\n                maxDividends = getMaxDepositPercent().mmul(investment);\r\n                // reinvest\r\n                assert(m_investors.setNewInvestment(msg.sender, investment, maxDividends));\r\n                emit LogReinvest(msg.sender, now, investment);\r\n            } else {\r\n                // prevent burning dividends\r\n                uint dividends = calcDividends(msg.sender);\r\n                if (dividends.notZero()) {\r\n                    assert(m_investors.addDeferredDividends(msg.sender, dividends));\r\n                }\r\n                // update existing investor investment\r\n                assert(m_investors.addInvestment(msg.sender, investment));\r\n                assert(m_investors.addDividendsLimit(msg.sender, maxDividends));\r\n            }\r\n            assert(m_investors.setPaymentTime(msg.sender, now));\r\n        } else {\r\n            // create new investor\r\n            assert(m_investors.newInvestor(msg.sender, investment, now, maxDividends));\r\n            emit LogNewInvestor(msg.sender, now);\r\n        }\r\n\r\n        investmentsNumber++;\r\n        advertisingAddress.transfer(advertisingCommission);\r\n        adminsAddress.transfer(adminsCommission);\r\n        emit LogNewInvestment(msg.sender, now, investment, receivedEther);\r\n    }\r\n\r\n    function setAdvertisingAddress(address addr) public onlyOwner {\r\n        addr.requireNotZero();\r\n        advertisingAddress = addr;\r\n    }\r\n\r\n    function setAdminsAddress(address addr) public onlyOwner {\r\n        addr.requireNotZero();\r\n        adminsAddress = addr;\r\n    }\r\n\r\n    function getMemInvestor(\r\n        address investorAddr\r\n    )\r\n        internal\r\n        view\r\n        returns (\r\n            InvestorsStorage.Investor memory\r\n        )\r\n    {\r\n        (\r\n            uint investment,\r\n            uint paymentTime,\r\n            uint dividends,\r\n            uint dividendsLimit,\r\n            uint dividendsDeferred\r\n        ) = m_investors.investorInfo(investorAddr);\r\n\r\n        return InvestorsStorage.Investor(\r\n            investment,\r\n            paymentTime,\r\n            InvestorsStorage.Dividends(\r\n                dividends,\r\n                dividendsLimit,\r\n                dividendsDeferred)\r\n        );\r\n    }\r\n\r\n    function calcDividends(address investorAddr) internal view returns(uint dividends) {\r\n        InvestorsStorage.Investor memory investor = getMemInvestor(investorAddr);\r\n        uint interval = 1 days;\r\n        uint pastTime = now.sub(investor.paymentTime);\r\n\r\n        // safe gas if dividends will be 0\r\n        if (investor.investment.isZero() || pastTime < interval) {\r\n            return 0;\r\n        }\r\n\r\n        // paid dividends cannot be greater then 150% from investor investment\r\n        if (investor.dividends.value >= investor.dividends.limit) {\r\n            return 0;\r\n        }\r\n\r\n        Percent.percent memory p = getDailyPercent(investor.investment);\r\n        Percent.percent memory c = Percent.percent(p.num + p.den, p.den);\r\n\r\n        uint intervals = pastTime.div(interval);\r\n        uint totalDividends = investor.dividends.limit.add(investor.investment).sub(investor.dividends.value).sub(investor.dividends.deferred);\r\n\r\n        dividends = investor.investment;\r\n        for (uint i = 0; i < intervals; i++) {\r\n            dividends = c.mmul(dividends);\r\n            if (dividends > totalDividends) {\r\n                dividends = totalDividends.add(investor.dividends.deferred);\r\n                break;\r\n            }\r\n        }\r\n\r\n        dividends = dividends.sub(investor.investment);\r\n\r\n        //uint totalDividends = dividends + investor.dividends;\r\n        //if (totalDividends >= investor.dividendsLimit) {\r\n        //    dividends = investor.dividendsLimit - investor.dividends;\r\n        //}\r\n    }\r\n\r\n    function getMaxDepositPercent() internal view returns(Percent.percent memory p) {\r\n        p = m_maxDepositPercent.toMemory();\r\n    }\r\n\r\n    function getDailyPercent(uint value) internal view returns(Percent.percent memory p) {\r\n        // (1) 1% if 0.01 ETH <= value < 0.1 ETH\r\n        // (2) 1.5% if 0.1 ETH <= value < 1 ETH\r\n        // (3) 2% if 1 ETH <= value < 5 ETH\r\n        // (4) 2.5% if 5 ETH <= value < 10 ETH\r\n        // (5) 3% if 10 ETH <= value < 20 ETH\r\n        // (6) 3.5% if 20 ETH <= value < 30 ETH\r\n        // (7) 4% if 30 ETH <= value <= 50 ETH\r\n\r\n        if (MIN_INVESTMENT <= value && value < 100 finney) {\r\n            p = m_1_percent.toMemory();                     // (1)\r\n        } else if (100 finney <= value && value < 1 ether) {\r\n            p = m_1_5_percent.toMemory();                   // (2)\r\n        } else if (1 ether <= value && value < 5 ether) {\r\n            p = m_2_percent.toMemory();                     // (3)\r\n        } else if (5 ether <= value && value < 10 ether) {\r\n            p = m_2_5_percent.toMemory();                   // (4)\r\n        } else if (10 ether <= value && value < 20 ether) {\r\n            p = m_3_percent.toMemory();                     // (5)\r\n        } else if (20 ether <= value && value < 30 ether) {\r\n            p = m_3_5_percent.toMemory();                   // (6)\r\n        } else if (30 ether <= value && value <= MAX_INVESTMENT) {\r\n            p = m_4_percent.toMemory();                     // (7)\r\n        }\r\n    }\r\n\r\n    function getRefBonusPercent() internal view returns(Percent.percent memory p) {\r\n        p = m_refPercent.toMemory();\r\n    }\r\n\r\n    function getReinvestBonusPercent() internal view returns(Percent.percent memory p) {\r\n        p = m_reinvestPercent.toMemory();\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"percent2\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"getDailyPercentAtNow\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent3_5\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent1\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent1_5\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRefBonusPercentAtNow\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"getInvestorDividendsAtNow\",\"outputs\":[{\"name\":\"dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent2_5\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investmentsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent3\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getMyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrerAddr\",\"type\":\"address\"}],\"name\":\"doInvest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"investment\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"dividends\",\"type\":\"uint256\"},{\"name\":\"dividendsLimit\",\"type\":\"uint256\"},{\"name\":\"dividendsDeferred\",\"type\":\"uint256\"},{\"name\":\"isReferral\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BALANCE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent4\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDepositPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doDisown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"excess\",\"type\":\"uint256\"}],\"name\":\"LogSendExcessOfEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refBonus\",\"type\":\"uint256\"}],\"name\":\"LogNewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"}],\"name\":\"LogReinvest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPayDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogPayReferrerBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogDisown\",\"type\":\"event\"}]","ContractName":"EthUp","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a41ad3536a9fca52c6968c775f0a0fa039ab4ce922736908768c6c48714fa406"}]}