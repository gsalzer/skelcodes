{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/* \r\n    Contract for DeltaBalances.github.io V4.\r\n    Check ERC20 token balances & allowances for multiple tokens in 1 batched request.\r\n    \r\n    V4 changes:\r\n    - Small optimizations.\r\n    - Add token allowances.\r\n    - Removed unused functions.\r\n    \r\n    For the previous versions, see 0x3E25F0BA291F202188Ae9Bda3004A7B3a803599a for code and comments.\r\n    \r\n    Address 0x0 is used to indicate ETH (as used in EtherDelta, IDEX and more).\r\n*/\r\n\r\n// Exchange contract Interface for EtherDelta and forks.\r\ncontract Exchange {\r\n  function balanceOf(address token, address user) public view returns (uint);\r\n}\r\n\r\n// ERC20 contract interface.\r\ncontract Token {\r\n  function balanceOf(address tokenOwner) public view returns (uint balance);\r\n  function transfer(address to, uint tokens) public returns (bool success);\r\n  function allowance(address tokenOwner, address spenderContract) public view returns (uint remaining);\r\n}\r\n\r\ncontract DeltaBalances {\r\n    \r\n  address public admin; \r\n\r\n  constructor() public {\r\n    admin = msg.sender;\r\n  }\r\n\r\n  // Limit withdrawals to the contract creator.\r\n  modifier isAdmin() {\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n\r\n\r\n  // Backup withdraw, in case ETH gets in here.\r\n  function withdraw() external isAdmin {\r\n    admin.transfer(address(this).balance);\r\n  }\r\n\r\n  // Backup withdraw, in case ERC20 tokens get in here.\r\n  function withdrawToken(address token, uint amount) external isAdmin {\r\n    require(token != address(0x0) && Token(token).transfer(msg.sender, amount));\r\n  }\r\n\r\n\r\n  /* Check the token balances of a wallet for multiple tokens.\r\n     Returns array of token balances in wei units. */\r\n  function tokenBalances(address user,  address[] tokens) external view returns (uint[]) {\r\n    uint[] memory balances = new uint[](tokens.length);\r\n    \r\n    for(uint i = 0; i < tokens.length; i++) {\r\n      if(tokens[i] != address(0x0)) { \r\n        balances[i] = tokenBalance(user, tokens[i]); // check token balance and catch errors\r\n      } else {\r\n        balances[i] = user.balance; // ETH balance    \r\n      }\r\n    }    \r\n    return balances;\r\n  }\r\n\r\n\r\n  /* Get multiple token balances deposited on a DEX (EtherDelta, IDEX, or similar exchange).\r\n     Returns array of deposited token balances in wei units. */\r\n  function depositedBalances(address exchange, address user, address[] tokens) external view returns (uint[]) {\r\n    Exchange ex = Exchange(exchange);\r\n    uint[] memory balances = new uint[](tokens.length);\r\n    \r\n    for(uint i = 0; i < tokens.length; i++) {\r\n      balances[i] = ex.balanceOf(tokens[i], user); //might error if exchange does not implement balanceOf correctly\r\n    }    \r\n    return balances;\r\n  }\r\n\r\n  /* Get multiple token allowances for a contract.\r\n     Returns array of deposited token balances in wei units. */\r\n  function tokenAllowances(address spenderContract, address user, address[] tokens) external view returns (uint[]) {\r\n    uint[] memory allowances = new uint[](tokens.length);\r\n    \r\n    for(uint i = 0; i < tokens.length; i++) {\r\n      allowances[i] = tokenAllowance(spenderContract, user, tokens[i]); // check token allowance and catch errors\r\n    }    \r\n    return allowances;\r\n  }\r\n\r\n\r\n /* Check the token balance of a wallet in a token contract.\r\n    Returns 0 on a bad token contract   */\r\n  function tokenBalance(address user, address token) internal view returns (uint) {\r\n    // check if token is actually a contract\r\n    uint256 tokenCode;\r\n    assembly { tokenCode := extcodesize(token) } // contract code size\r\n   \r\n   // is it a contract and does it implement balanceOf() \r\n    if(tokenCode > 0 && token.call(0x70a08231, user)) {    // bytes4(keccak256(\"balanceOf(address)\")) == 0x70a08231  \r\n      return Token(token).balanceOf(user);\r\n    } else {\r\n      return 0; // not a valid token, return 0 instead of error\r\n    }\r\n  }\r\n  \r\n  \r\n  /* Check the token allowance of a wallet for a specific contract.\r\n     Returns 0 on a bad token contract.   */\r\n  function tokenAllowance(address spenderContract, address user, address token) internal view returns (uint) {\r\n    // check if token is actually a contract\r\n    uint256 tokenCode;\r\n    assembly { tokenCode := extcodesize(token) } // contract code size\r\n   \r\n   // is it a contract and does it implement allowance() \r\n    if(tokenCode > 0 && token.call(0xdd62ed3e, user, spenderContract)) {    // bytes4(keccak256(\"allowance(address,address)\")) == 0xdd62ed3e\r\n      return Token(token).allowance(user, spenderContract);\r\n    } else {\r\n      return 0; // not a valid token, return 0 instead of error\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"exchange\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"depositedBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"tokenBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"spenderContract\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"tokenAllowances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"DeltaBalances","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://045d535b6d5ce7605d3e076616b0859a93bba3a5f3f00de0d534d3dba357160b"}]}