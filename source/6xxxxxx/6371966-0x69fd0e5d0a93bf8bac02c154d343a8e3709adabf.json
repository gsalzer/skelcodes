{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\ncontract PullPayment {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public payments;\r\n  uint256 public totalPayments;\r\n\r\n  /**\r\n  * @dev Withdraw accumulated balance, called by payee.\r\n  */\r\n  function withdrawPayments() public {\r\n    address payee = msg.sender;\r\n    uint256 payment = payments[payee];\r\n\r\n    require(payment != 0);\r\n    require(address(this).balance >= payment);\r\n\r\n    totalPayments = totalPayments.sub(payment);\r\n    payments[payee] = 0;\r\n\r\n    payee.transfer(payment);\r\n  }\r\n\r\n  /**\r\n  * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n  * @param dest The destination address of the funds.\r\n  * @param amount The amount to transfer.\r\n  */\r\n  function asyncSend(address dest, uint256 amount) internal {\r\n    payments[dest] = payments[dest].add(amount);\r\n    totalPayments = totalPayments.add(amount);\r\n  }\r\n}\r\ncontract CryptoMiningWarInterface {\r\n    address public sponsor;\r\n    address public administrator;\r\n    mapping(address => PlayerData) public players;\r\n    struct PlayerData {\r\n        uint256 roundNumber;\r\n        mapping(uint256 => uint256) minerCount;\r\n        uint256 hashrate;\r\n        uint256 crystals;\r\n        uint256 lastUpdateTime;\r\n        uint256 referral_count;\r\n        uint256 noQuest;\r\n    }\r\n    function getHashratePerDay(address /*minerAddr*/) public pure returns (uint256 /*personalProduction*/) {}\r\n    function addCrystal( address /*_addr*/, uint256 /*_value*/ ) public pure {}\r\n    function subCrystal( address /*_addr*/, uint256 /*_value*/ ) public pure {}\r\n    function fallback() public payable {}\r\n}\r\ninterface MiniGameInterface {\r\n    function isContractMiniGame() external pure returns( bool _isContractMiniGame );\r\n    function fallback() external payable;\r\n}\r\ncontract CryptoEngineer is PullPayment{\r\n    // engineer info\r\n\taddress public administrator;\r\n    uint256 public prizePool = 0;\r\n    uint256 public engineerRoundNumber = 0;\r\n    uint256 public numberOfEngineer;\r\n    uint256 public numberOfBoosts;\r\n    address public gameSponsor;\r\n    uint256 public gameSponsorPrice;\r\n    uint256 private randNonce;\r\n    uint256 constant public VIRUS_MINING_PERIOD = 86400; \r\n    uint256 constant public VIRUS_NORMAL = 0;\r\n    uint256 constant public HALF_TIME_ATK = 60 * 15;   \r\n    \r\n    // mining war game infomation\r\n    address public miningWarContractAddress;\r\n    address public miningWarAdministrator;\r\n    uint256 constant public CRTSTAL_MINING_PERIOD = 86400;\r\n    uint256 constant public BASE_PRICE = 0.01 ether;\r\n\r\n    CryptoMiningWarInterface public MiningWarContract;\r\n    \r\n    // engineer player information\r\n    mapping(address => PlayerData) public players;\r\n    // engineer boost information\r\n    mapping(uint256 => BoostData) public boostData;\r\n    // engineer information\r\n    mapping(uint256 => EngineerData) public engineers;\r\n    // engineer virut information\r\n    mapping(uint256 => VirusData) public virus;\r\n    \r\n    // minigame info\r\n    mapping(address => bool) public miniGames; \r\n    \r\n    struct PlayerData {\r\n        uint256 engineerRoundNumber;\r\n        mapping(uint256 => uint256) engineersCount;\r\n        uint256 virusNumber;\r\n        uint256 virusDefence;\r\n        uint256 research;\r\n        uint256 lastUpdateTime;\r\n        uint256 nextTimeAtk;\r\n        uint256 endTimeUnequalledDef;\r\n    }\r\n    struct BoostData {\r\n        address owner;\r\n        uint256 boostRate;\r\n        uint256 basePrice;\r\n    }\r\n    struct EngineerData {\r\n        uint256 basePrice;\r\n        uint256 baseETH;\r\n        uint256 baseResearch;\r\n        uint256 limit;\r\n    }\r\n    struct VirusData {\r\n        uint256 atk;\r\n        uint256 def;\r\n    }\r\n    event eventEndAttack(\r\n        address playerAtk,\r\n        address playerDef,\r\n        bool isWin,\r\n        uint256 winCrystals,\r\n        uint256 virusPlayerAtkDead,\r\n        uint256 virusPlayerDefDead,\r\n        uint256 timeAtk,\r\n        uint256 engineerRoundNumber,\r\n        uint256 atk,\r\n        uint256 def // def of player \r\n    );\r\n    modifier disableContract()\r\n    {\r\n        require(tx.origin == msg.sender);\r\n        _;\r\n    }\r\n    modifier isAdministrator()\r\n    {\r\n        require(msg.sender == administrator);\r\n        _;\r\n    }\r\n    modifier onlyContractsMiniGame() \r\n    {\r\n        require(miniGames[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        administrator = msg.sender;\r\n\r\n        //default game sponsor\r\n        gameSponsor = administrator;\r\n        gameSponsorPrice = 0.32 ether;\r\n        // set interface main contract\r\n        miningWarContractAddress = address(0xf84c61bb982041c030b8580d1634f00fffb89059);\r\n        MiningWarContract = CryptoMiningWarInterface(miningWarContractAddress);\r\n        miningWarAdministrator = MiningWarContract.administrator();\r\n        \r\n        numberOfEngineer = 8;\r\n        numberOfBoosts = 5;\r\n        // setting virusupd\r\n        virus[VIRUS_NORMAL] = VirusData(1,1);\r\n\r\n        //                          price crystals    price ETH         research  limit                         \r\n        engineers[0] = EngineerData(10,               BASE_PRICE * 0,   10,       10   );   //lv1 \r\n        engineers[1] = EngineerData(50,               BASE_PRICE * 1,   200,      2    );   //lv2\r\n        engineers[2] = EngineerData(200,              BASE_PRICE * 2,   800,      4    );   //lv3\r\n        engineers[3] = EngineerData(800,              BASE_PRICE * 4,   3200,     8    );   //lv4\r\n        engineers[4] = EngineerData(3200,             BASE_PRICE * 8,   9600,     16   );   //lv5\r\n        engineers[5] = EngineerData(12800,            BASE_PRICE * 16,  38400,    32   );   //lv6\r\n        engineers[6] = EngineerData(102400,           BASE_PRICE * 32,  204800,   64   );   //lv7\r\n        engineers[7] = EngineerData(819200,           BASE_PRICE * 64,  819200,   65536);   //lv8\r\n        initData();\r\n    }\r\n    function () public payable\r\n    {\r\n        addPrizePool(msg.value);\r\n    }\r\n    function initData() private\r\n    {\r\n        //init booster data\r\n        boostData[0] = BoostData(0x0, 150, BASE_PRICE * 1);\r\n        boostData[1] = BoostData(0x0, 175, BASE_PRICE * 2);\r\n        boostData[2] = BoostData(0x0, 200, BASE_PRICE * 4);\r\n        boostData[3] = BoostData(0x0, 225, BASE_PRICE * 8);\r\n        boostData[4] = BoostData(0x0, 250, BASE_PRICE * 16);\r\n    }\r\n    /** \r\n    * @dev MainContract used this function to verify game's contract\r\n    */\r\n    function isContractMiniGame() public pure returns( bool _isContractMiniGame )\r\n    {\r\n    \t_isContractMiniGame = true;\r\n    }\r\n\r\n    /** \r\n    * @dev Main Contract call this function to setup mini game.\r\n    */\r\n    function setupMiniGame( uint256 /*_miningWarRoundNumber*/, uint256 /*_miningWarDeadline*/ ) public\r\n    {\r\n    \r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // SETTING CONTRACT MINI GAME \r\n    //--------------------------------------------------------------------------\r\n    function setContractsMiniGame( address _contractMiniGameAddress ) public isAdministrator \r\n    {\r\n        MiniGameInterface MiniGame = MiniGameInterface( _contractMiniGameAddress );\r\n        if( MiniGame.isContractMiniGame() == false ) { revert(); }\r\n\r\n        miniGames[_contractMiniGameAddress] = true;\r\n    }\r\n    /**\r\n    * @dev remove mini game contract from main contract\r\n    * @param _contractMiniGameAddress mini game contract address\r\n    */\r\n    function removeContractMiniGame(address _contractMiniGameAddress) public isAdministrator\r\n    {\r\n        miniGames[_contractMiniGameAddress] = false;\r\n    }\r\n    //@dev use this function in case of bug\r\n    function upgrade(address addr) public \r\n    {\r\n        require(msg.sender == administrator);\r\n        selfdestruct(addr);\r\n    }\r\n\r\n    //--------------------------------------------------------------------------\r\n    // BOOSTER \r\n    //--------------------------------------------------------------------------\r\n    function buyBooster(uint256 idx) public payable \r\n    {\r\n        require(idx < numberOfBoosts);\r\n        BoostData storage b = boostData[idx];\r\n        if (msg.value < b.basePrice || msg.sender == b.owner) {\r\n            revert();\r\n        }\r\n        address beneficiary = b.owner;\r\n        uint256 devFeePrize = devFee(b.basePrice);\r\n        \r\n        distributedToOwner(devFeePrize);\r\n        addMiningWarPrizePool(devFeePrize);\r\n        addPrizePool(SafeMath.sub(msg.value, SafeMath.mul(devFeePrize,3)));\r\n        \r\n        updateVirus(msg.sender);\r\n        if ( beneficiary != 0x0 ) {\r\n            updateVirus(beneficiary);\r\n        }\r\n        // transfer ownership    \r\n        b.owner = msg.sender;\r\n    }\r\n    function getBoosterData(uint256 idx) public view returns (address _owner,uint256 _boostRate, uint256 _basePrice)\r\n    {\r\n        require(idx < numberOfBoosts);\r\n        BoostData memory b = boostData[idx];\r\n        _owner = b.owner;\r\n        _boostRate = b.boostRate; \r\n        _basePrice = b.basePrice;\r\n    }\r\n    function hasBooster(address addr) public view returns (uint256 _boostIdx)\r\n    {         \r\n        _boostIdx = 999;\r\n        for(uint256 i = 0; i < numberOfBoosts; i++){\r\n            uint256 revert_i = numberOfBoosts - i - 1;\r\n            if(boostData[revert_i].owner == addr){\r\n                _boostIdx = revert_i;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // GAME SPONSOR\r\n    //--------------------------------------------------------------------------\r\n    /**\r\n    */\r\n    function becomeGameSponsor() public payable disableContract\r\n    {\r\n        uint256 gameSponsorPriceFee = SafeMath.div(SafeMath.mul(gameSponsorPrice, 150), 100);\r\n        require(msg.value >= gameSponsorPriceFee);\r\n        require(msg.sender != gameSponsor);\r\n        // \r\n        uint256 repayPrice = SafeMath.div(SafeMath.mul(gameSponsorPrice, 110), 100);\r\n        gameSponsor.send(repayPrice);\r\n        \r\n        // add to prize pool\r\n        addPrizePool(SafeMath.sub(msg.value, repayPrice));\r\n        // update game sponsor info\r\n        gameSponsor = msg.sender;\r\n        gameSponsorPrice = gameSponsorPriceFee;\r\n    }\r\n    /**\r\n    * @dev add virus for player\r\n    * @param _addr player address\r\n    * @param _value number of virus\r\n    */\r\n    function addVirus(address _addr, uint256 _value) public onlyContractsMiniGame\r\n    {\r\n        PlayerData storage p = players[_addr];\r\n        uint256 additionalVirus = SafeMath.mul(_value,VIRUS_MINING_PERIOD);\r\n        p.virusNumber = SafeMath.add(p.virusNumber, additionalVirus);\r\n    }\r\n    /**\r\n    * @dev subtract virus of player\r\n    * @param _addr player address \r\n    * @param _value number virus subtract \r\n    */\r\n    function subVirus(address _addr, uint256 _value) public onlyContractsMiniGame\r\n    {\r\n        updateVirus(_addr);\r\n        PlayerData storage p = players[_addr];\r\n        uint256 subtractVirus = SafeMath.mul(_value,VIRUS_MINING_PERIOD);\r\n        if ( p.virusNumber < subtractVirus ) { revert(); }\r\n\r\n        p.virusNumber = SafeMath.sub(p.virusNumber, subtractVirus);\r\n    }\r\n    /**\r\n    * @dev additional time unequalled defence \r\n    * @param _addr player address \r\n    */\r\n    function setAtkNowForPlayer(address _addr) public onlyContractsMiniGame\r\n    {\r\n        PlayerData storage p = players[_addr];\r\n        p.nextTimeAtk = now;\r\n    }\r\n    function addTimeUnequalledDefence(address _addr, uint256 _value) public onlyContractsMiniGame\r\n    {\r\n        PlayerData storage p = players[_addr];\r\n        uint256 currentTimeUnequalled = p.endTimeUnequalledDef;\r\n        if (currentTimeUnequalled < now) {\r\n            currentTimeUnequalled = now;\r\n        }\r\n        p.endTimeUnequalledDef = SafeMath.add(currentTimeUnequalled, _value);\r\n    }\r\n    /**\r\n    * @dev claim price pool to next new game\r\n    * @param _addr mini game contract address\r\n    * @param _value eth claim;\r\n    */\r\n    function claimPrizePool(address _addr, uint256 _value) public onlyContractsMiniGame \r\n    {\r\n        require(prizePool > _value);\r\n\r\n        prizePool = SafeMath.sub(prizePool, _value);\r\n        MiniGameInterface MiniGame = MiniGameInterface( _addr );\r\n        MiniGame.fallback.value(_value)();\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // WARS\r\n    //--------------------------------------------------------------------------\r\n    function setVirusInfo(uint256 _atk, uint256 _def) public isAdministrator\r\n    {\r\n        VirusData storage v = virus[VIRUS_NORMAL];\r\n        v.atk = _atk;\r\n        v.def = _def;\r\n    }\r\n    /**\r\n    * @dev add virus defence \r\n    * @param _value number of virus defence\r\n    */\r\n    function addVirusDefence(uint256 _value) public disableContract \r\n    {        \r\n        updateVirus(msg.sender);\r\n        PlayerData storage p = players[msg.sender];\r\n        uint256 _virus = SafeMath.mul(_value,VIRUS_MINING_PERIOD);\r\n\r\n        if ( p.virusNumber < _virus ) { revert(); }\r\n\r\n        p.virusDefence = SafeMath.add(p.virusDefence, _virus);\r\n        p.virusNumber  = SafeMath.sub(p.virusNumber, _virus);\r\n    }\r\n    /**\r\n    * @dev atk and def ramdom from 50% to 150%\r\n    * @param _defAddress player address to attack\r\n    * @param _value number of virus send to attack\r\n    */\r\n    function attack( address _defAddress, uint256 _value) public disableContract\r\n    {\r\n        require(canAttack(msg.sender, _defAddress) == true);\r\n\r\n        updateVirus(msg.sender);\r\n\r\n        PlayerData storage pAtk = players[msg.sender];\r\n        PlayerData storage pDef = players[_defAddress];\r\n        uint256 virusAtk = SafeMath.mul(_value,VIRUS_MINING_PERIOD);\r\n\r\n        if (pAtk.virusNumber < virusAtk) { revert(); }\r\n        // current crystals of defence geater 5000 crystals\r\n        if (calCurrentCrystals(_defAddress) < 5000) { revert(); }\r\n\r\n        // virus normal info\r\n        VirusData memory v = virus[VIRUS_NORMAL];\r\n        // ramdom attack and defence for players from 50% to 150%\r\n        uint256 rateAtk = 50 + randomNumber(msg.sender, 100);\r\n        uint256 rateDef = 50 + randomNumber(_defAddress, 100);\r\n        // calculate attack of player attack and defence of player defence\r\n        uint256 atk = SafeMath.div(SafeMath.mul(SafeMath.mul(virusAtk, v.atk), rateAtk), 100);\r\n        uint256 def = SafeMath.div(SafeMath.mul(SafeMath.mul(pDef.virusDefence, v.def), rateDef), 100);\r\n        bool isWin = false;\r\n        uint256 virusPlayerAtkDead = 0;\r\n        uint256 virusPlayerDefDead = 0;\r\n        /**\r\n        * @dev calculate virus dead in war \r\n        */\r\n        // if attack > defense, sub virus of player atk and player def.\r\n        // number virus for kin\r\n        if (atk > def) {\r\n            virusPlayerAtkDead = SafeMath.min(virusAtk, SafeMath.div(SafeMath.mul(def, 100), SafeMath.mul(v.atk, rateAtk)));\r\n            virusPlayerDefDead = pDef.virusDefence;\r\n            isWin = true;\r\n        }\r\n        /**\r\n        * @dev update result of war and call end attack\r\n        */\r\n        pAtk.virusNumber = SafeMath.sub(pAtk.virusNumber, virusPlayerAtkDead);\r\n        pDef.virusDefence = SafeMath.sub(pDef.virusDefence, virusPlayerDefDead);\r\n        //update player attack\r\n        pAtk.nextTimeAtk = now + HALF_TIME_ATK;\r\n\r\n        endAttack(msg.sender,_defAddress,isWin, virusPlayerAtkDead, virusPlayerDefDead, atk, def);\r\n    }\r\n    /**\r\n    * @dev check player can atk or not\r\n    * @param _atkAddress player address attack\r\n    * @param _defAddress player address defence\r\n    */\r\n    function canAttack(address _atkAddress, address _defAddress) public view returns(bool _canAtk)\r\n    {\r\n        if ( \r\n            _atkAddress != _defAddress &&\r\n            players[_atkAddress].nextTimeAtk <= now &&\r\n            players[_defAddress].endTimeUnequalledDef < now\r\n        ) \r\n        {\r\n            _canAtk = true;\r\n        }\r\n    }\r\n    /**\r\n    * @dev result of war\r\n    * @param _atkAddress player address attack\r\n    * @param _defAddress player address defence\r\n    */\r\n    function endAttack(\r\n        address _atkAddress, \r\n        address _defAddress, \r\n        bool _isWin, \r\n        uint256 _virusPlayerAtkDead, \r\n        uint256 _virusPlayerDefDead, \r\n        uint256 _atk,\r\n        uint256 _def\r\n    ) private\r\n    {\r\n        uint256 winCrystals;\r\n        if ( _isWin == true ) {\r\n            uint256 pDefCrystals = calCurrentCrystals(_defAddress);\r\n            // subtract random 10% to 50% current crystals of player defence\r\n            uint256 rate =10 + randomNumber(_defAddress, 40);\r\n            winCrystals = SafeMath.div(SafeMath.mul(pDefCrystals,rate),100);\r\n\r\n            if (winCrystals > 0) {\r\n                MiningWarContract.subCrystal(_defAddress, winCrystals);    \r\n                MiningWarContract.addCrystal(_atkAddress, winCrystals);\r\n            }\r\n        }\r\n        emit eventEndAttack(_atkAddress, _defAddress, _isWin, winCrystals, _virusPlayerAtkDead, _virusPlayerDefDead, now, engineerRoundNumber, _atk, _def);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // PLAYERS\r\n    //--------------------------------------------------------------------------\r\n    /**\r\n    */\r\n    function buyEngineer(uint256[] engineerNumbers) public payable disableContract\r\n    {\r\n        require(engineerNumbers.length == numberOfEngineer);\r\n        \r\n        updateVirus(msg.sender);\r\n        PlayerData storage p = players[msg.sender];\r\n        \r\n        uint256 priceCrystals = 0;\r\n        uint256 priceEth = 0;\r\n        uint256 research = 0;\r\n        for (uint256 engineerIdx = 0; engineerIdx < numberOfEngineer; engineerIdx++) {\r\n            uint256 engineerNumber = engineerNumbers[engineerIdx];\r\n            EngineerData memory e = engineers[engineerIdx];\r\n            // require for engineerNumber \r\n            if(engineerNumber > e.limit || engineerNumber < 0) {\r\n                revert();\r\n            }\r\n            // engineer you want buy\r\n            if (engineerNumber > 0) {\r\n                uint256 currentEngineerCount = p.engineersCount[engineerIdx];\r\n                // update player data\r\n                p.engineersCount[engineerIdx] = SafeMath.min(e.limit, SafeMath.add(p.engineersCount[engineerIdx], engineerNumber));\r\n                // calculate no research you want buy\r\n                research = SafeMath.add(research, SafeMath.mul(SafeMath.sub(p.engineersCount[engineerIdx],currentEngineerCount), e.baseResearch));\r\n                // calculate price crystals and eth you will pay\r\n                priceCrystals = SafeMath.add(priceCrystals, SafeMath.mul(e.basePrice, engineerNumber));\r\n                priceEth = SafeMath.add(priceEth, SafeMath.mul(e.baseETH, engineerNumber));\r\n            }\r\n        }\r\n        // check price eth\r\n        if (priceEth < msg.value) {\r\n            revert();\r\n        }\r\n\r\n        uint256 devFeePrize = devFee(priceEth);\r\n        distributedToOwner(devFeePrize);\r\n        addMiningWarPrizePool(devFeePrize);\r\n        addPrizePool(SafeMath.sub(msg.value, SafeMath.mul(devFeePrize,3)));        \r\n\r\n        // pay and update\r\n        MiningWarContract.subCrystal(msg.sender, priceCrystals);\r\n        updateResearch(msg.sender, research);\r\n    }\r\n     /**\r\n    * @dev update virus for player \r\n    * @param _addr player address\r\n    */\r\n    function updateVirus(address _addr) private\r\n    {\r\n        if (players[_addr].engineerRoundNumber != engineerRoundNumber) {\r\n            return resetPlayer(_addr);\r\n        }\r\n        PlayerData storage p = players[_addr]; \r\n        p.virusNumber = calculateCurrentVirus(_addr);\r\n        p.lastUpdateTime = now;\r\n    }\r\n    function calculateCurrentVirus(address _addr) public view returns(uint256 _currentVirus)\r\n    {\r\n        PlayerData memory p = players[_addr]; \r\n        uint256 secondsPassed = SafeMath.sub(now, p.lastUpdateTime);\r\n        uint256 researchPerDay = getResearchPerDay(_addr);   \r\n        _currentVirus = p.virusNumber;\r\n        if (researchPerDay > 0) {\r\n            _currentVirus = SafeMath.add(_currentVirus, SafeMath.mul(researchPerDay, secondsPassed));\r\n        }   \r\n    }\r\n    /**\r\n    * @dev reset player data\r\n    * @param _addr player address\r\n    */\r\n    function resetPlayer(address _addr) private\r\n    {\r\n        require(players[_addr].engineerRoundNumber != engineerRoundNumber);\r\n\r\n        PlayerData storage p = players[_addr];\r\n        p.engineerRoundNumber = engineerRoundNumber;\r\n        p.virusNumber = 0;\r\n        p.virusDefence = 0;\r\n        p.research = 0;        \r\n        p.lastUpdateTime = now;\r\n        p.nextTimeAtk = now;\r\n        p.endTimeUnequalledDef = now;\r\n        // reset player engineer data\r\n        for ( uint256 idx = 0; idx < numberOfEngineer; idx++ ) {\r\n            p.engineersCount[idx] = 0;\r\n        }   \r\n    }\r\n    /**\r\n    * @dev update research for player\r\n    * @param _addr player address\r\n    * @param _research number research want to add\r\n    */\r\n    function updateResearch(address _addr, uint256 _research) private \r\n    {\r\n        PlayerData storage p = players[_addr];\r\n        p.research = SafeMath.add(p.research, _research);\r\n    }\r\n    function getResearchPerDay(address _addr) public view returns( uint256 _researchPerDay)\r\n    {\r\n        PlayerData memory p = players[_addr];\r\n        _researchPerDay =  p.research;\r\n        uint256 boosterIdx = hasBooster(_addr);\r\n        if (boosterIdx != 999) {\r\n            BoostData memory b = boostData[boosterIdx];\r\n            _researchPerDay = SafeMath.div(SafeMath.mul(_researchPerDay, b.boostRate), 100);\r\n        } \r\n    }\r\n    /**\r\n    * @dev get player data\r\n    * @param _addr player address\r\n    */\r\n    function getPlayerData(address _addr) \r\n    public \r\n    view \r\n    returns(\r\n        uint256 _engineerRoundNumber, \r\n        uint256 _virusNumber, \r\n        uint256 _virusDefence, \r\n        uint256 _research, \r\n        uint256 _researchPerDay, \r\n        uint256 _lastUpdateTime, \r\n        uint256[8] _engineersCount, \r\n        uint256 _nextTimeAtk,\r\n        uint256 _endTimeUnequalledDef\r\n    )\r\n    {\r\n        PlayerData storage p = players[_addr];\r\n        for ( uint256 idx = 0; idx < numberOfEngineer; idx++ ) {\r\n            _engineersCount[idx] = p.engineersCount[idx];\r\n        }\r\n        _engineerRoundNumber = p.engineerRoundNumber;\r\n        _virusNumber = SafeMath.div(p.virusNumber, VIRUS_MINING_PERIOD);\r\n        _virusDefence = SafeMath.div(p.virusDefence, VIRUS_MINING_PERIOD);\r\n        _nextTimeAtk = p.nextTimeAtk;\r\n        _lastUpdateTime = p.lastUpdateTime;\r\n        _endTimeUnequalledDef = p.endTimeUnequalledDef;\r\n        _research = p.research;\r\n        _researchPerDay = getResearchPerDay(_addr);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    // INTERNAL \r\n    //--------------------------------------------------------------------------\r\n    function addPrizePool(uint256 _value) private \r\n    {\r\n        prizePool = SafeMath.add(prizePool, _value);\r\n    }\r\n    /**\r\n    * @dev add 5% value of transaction payable\r\n    */\r\n    function addMiningWarPrizePool(uint256 _value) private\r\n    {\r\n        MiningWarContract.fallback.value(_value)();\r\n    }\r\n    /**\r\n    * @dev calculate current crystals of player\r\n    * @param _addr player address\r\n    */\r\n    function calCurrentCrystals(address _addr) public view returns(uint256 _currentCrystals)\r\n    {\r\n        uint256 lastUpdateTime;\r\n        (,, _currentCrystals, lastUpdateTime) = getMiningWarPlayerData(_addr);\r\n        uint256 hashratePerDay = getHashratePerDay(_addr);     \r\n        uint256 secondsPassed = SafeMath.sub(now, lastUpdateTime);      \r\n        if (hashratePerDay > 0) {\r\n            _currentCrystals = SafeMath.add(_currentCrystals, SafeMath.mul(hashratePerDay, secondsPassed));\r\n        }\r\n        _currentCrystals = SafeMath.div(_currentCrystals, CRTSTAL_MINING_PERIOD);\r\n    }\r\n    function devFee(uint256 _amount) private pure returns(uint256)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(_amount, 5), 100);\r\n    }\r\n    /**\r\n    * @dev with transaction payable send 5% value for admin and sponsor\r\n    * @param _value fee \r\n    */\r\n    function distributedToOwner(uint256 _value) private\r\n    {\r\n        gameSponsor.send(_value);\r\n        miningWarAdministrator.send(_value);\r\n    }\r\n    function randomNumber(address _addr, uint256 _maxNumber) private returns(uint256)\r\n    {\r\n        randNonce = randNonce + 1;\r\n        return uint256(keccak256(abi.encodePacked(now, _addr, randNonce))) % _maxNumber;\r\n    }\r\n    function getMiningWarPlayerData(address _addr) private view returns(uint256 _roundNumber, uint256 _hashrate, uint256 _crytals, uint256 _lastUpdateTime)\r\n    {\r\n        (_roundNumber,_hashrate,_crytals,_lastUpdateTime,,)= MiningWarContract.players(_addr);\r\n    }\r\n    function getHashratePerDay(address _addr) private view returns(uint256)\r\n    {\r\n        return MiningWarContract.getHashratePerDay(_addr);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"calculateCurrentVirus\",\"outputs\":[{\"name\":\"_currentVirus\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getResearchPerDay\",\"outputs\":[{\"name\":\"_researchPerDay\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"engineerRoundNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerData\",\"outputs\":[{\"name\":\"_engineerRoundNumber\",\"type\":\"uint256\"},{\"name\":\"_virusNumber\",\"type\":\"uint256\"},{\"name\":\"_virusDefence\",\"type\":\"uint256\"},{\"name\":\"_research\",\"type\":\"uint256\"},{\"name\":\"_researchPerDay\",\"type\":\"uint256\"},{\"name\":\"_lastUpdateTime\",\"type\":\"uint256\"},{\"name\":\"_engineersCount\",\"type\":\"uint256[8]\"},{\"name\":\"_nextTimeAtk\",\"type\":\"uint256\"},{\"name\":\"_endTimeUnequalledDef\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractMiniGame\",\"outputs\":[{\"name\":\"_isContractMiniGame\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getBoosterData\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_boostRate\",\"type\":\"uint256\"},{\"name\":\"_basePrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"engineers\",\"outputs\":[{\"name\":\"basePrice\",\"type\":\"uint256\"},{\"name\":\"baseETH\",\"type\":\"uint256\"},{\"name\":\"baseResearch\",\"type\":\"uint256\"},{\"name\":\"limit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"engineerNumbers\",\"type\":\"uint256[]\"}],\"name\":\"buyEngineer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_atk\",\"type\":\"uint256\"},{\"name\":\"_def\",\"type\":\"uint256\"}],\"name\":\"setVirusInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningWarAdministrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_atkAddress\",\"type\":\"address\"},{\"name\":\"_defAddress\",\"type\":\"address\"}],\"name\":\"canAttack\",\"outputs\":[{\"name\":\"_canAtk\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_defAddress\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"attack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addVirusDefence\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningWarContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfEngineer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"prizePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameSponsorPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"claimPrizePool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setAtkNowForPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractMiniGameAddress\",\"type\":\"address\"}],\"name\":\"setContractsMiniGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"subVirus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"calCurrentCrystals\",\"outputs\":[{\"name\":\"_currentCrystals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"virus\",\"outputs\":[{\"name\":\"atk\",\"type\":\"uint256\"},{\"name\":\"def\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractMiniGameAddress\",\"type\":\"address\"}],\"name\":\"removeContractMiniGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"boostData\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"boostRate\",\"type\":\"uint256\"},{\"name\":\"basePrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"hasBooster\",\"outputs\":[{\"name\":\"_boostIdx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"miniGames\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameSponsor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"setupMiniGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MiningWarContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CRTSTAL_MINING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"buyBooster\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"becomeGameSponsor\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VIRUS_MINING_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"engineerRoundNumber\",\"type\":\"uint256\"},{\"name\":\"virusNumber\",\"type\":\"uint256\"},{\"name\":\"virusDefence\",\"type\":\"uint256\"},{\"name\":\"research\",\"type\":\"uint256\"},{\"name\":\"lastUpdateTime\",\"type\":\"uint256\"},{\"name\":\"nextTimeAtk\",\"type\":\"uint256\"},{\"name\":\"endTimeUnequalledDef\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBoosts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addVirus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"addTimeUnequalledDefence\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"administrator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HALF_TIME_ATK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BASE_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VIRUS_NORMAL\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAtk\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerDef\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isWin\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"winCrystals\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virusPlayerAtkDead\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"virusPlayerDefDead\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeAtk\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"engineerRoundNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"atk\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"def\",\"type\":\"uint256\"}],\"name\":\"eventEndAttack\",\"type\":\"event\"}]","ContractName":"CryptoEngineer","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a64ce8b681b3b7ef5c3dacf2430a77d102547c666093c10c4346e5ca65d28b4d"}]}