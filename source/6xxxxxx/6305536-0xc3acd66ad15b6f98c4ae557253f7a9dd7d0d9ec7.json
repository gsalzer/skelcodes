{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\ncontract Staff is Ownable, RBAC {\r\n\r\n\tstring public constant ROLE_STAFF = \"staff\";\r\n\r\n\tfunction addStaff(address _staff) public onlyOwner {\r\n\t\taddRole(_staff, ROLE_STAFF);\r\n\t}\r\n\r\n\tfunction removeStaff(address _staff) public onlyOwner {\r\n\t\tremoveRole(_staff, ROLE_STAFF);\r\n\t}\r\n\r\n\tfunction isStaff(address _staff) view public returns (bool) {\r\n\t\treturn hasRole(_staff, ROLE_STAFF);\r\n\t}\r\n}\r\n\r\ncontract StaffUtil {\r\n\tStaff public staffContract;\r\n\r\n\tconstructor (Staff _staffContract) public {\r\n\t\trequire(msg.sender == _staffContract.owner());\r\n\t\tstaffContract = _staffContract;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == staffContract.owner());\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyOwnerOrStaff() {\r\n\t\trequire(msg.sender == staffContract.owner() || staffContract.isStaff(msg.sender));\r\n\t\t_;\r\n\t}\r\n}\r\n\r\ncontract DiscountPhases is StaffUtil {\r\n\r\n\tevent DiscountPhaseAdded(uint index, string name, uint8 percent, uint fromDate, uint toDate, uint timestamp, address byStaff);\r\n\tevent DiscountPhaseRemoved(uint index, uint timestamp, address byStaff);\r\n\r\n\tstruct DiscountPhase {\r\n\t\tuint8 percent;\r\n\t\tuint fromDate;\r\n\t\tuint toDate;\r\n\t}\r\n\r\n\tDiscountPhase[] public discountPhases;\r\n\r\n\tconstructor(Staff _staffContract) StaffUtil(_staffContract) public {\r\n\t}\r\n\r\n\tfunction calculateBonusAmount(uint256 _purchasedAmount) public constant returns (uint256) {\r\n\t\tfor (uint i = 0; i < discountPhases.length; i++) {\r\n\t\t\tif (now >= discountPhases[i].fromDate && now <= discountPhases[i].toDate) {\r\n\t\t\t\treturn _purchasedAmount * discountPhases[i].percent / 100;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addDiscountPhase(string _name, uint8 _percent, uint _fromDate, uint _toDate) public onlyOwnerOrStaff {\r\n\t\trequire(bytes(_name).length > 0);\r\n\t\trequire(_percent > 0);\r\n\r\n\t\tif (now > _fromDate) {\r\n\t\t\t_fromDate = now;\r\n\t\t}\r\n\t\trequire(_fromDate < _toDate);\r\n\r\n\t\tfor (uint i = 0; i < discountPhases.length; i++) {\r\n\t\t\trequire(_fromDate > discountPhases[i].toDate || _toDate < discountPhases[i].fromDate);\r\n\t\t}\r\n\r\n\t\tuint index = discountPhases.push(DiscountPhase({percent : _percent, fromDate : _fromDate, toDate : _toDate})) - 1;\r\n\r\n\t\temit DiscountPhaseAdded(index, _name, _percent, _fromDate, _toDate, now, msg.sender);\r\n\t}\r\n\r\n\tfunction removeDiscountPhase(uint _index) public onlyOwnerOrStaff {\r\n\t\trequire(now < discountPhases[_index].toDate);\r\n\t\tdelete discountPhases[_index];\r\n\t\temit DiscountPhaseRemoved(_index, now, msg.sender);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"discountPhases\",\"outputs\":[{\"name\":\"percent\",\"type\":\"uint8\"},{\"name\":\"fromDate\",\"type\":\"uint256\"},{\"name\":\"toDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_percent\",\"type\":\"uint8\"},{\"name\":\"_fromDate\",\"type\":\"uint256\"},{\"name\":\"_toDate\",\"type\":\"uint256\"}],\"name\":\"addDiscountPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_purchasedAmount\",\"type\":\"uint256\"}],\"name\":\"calculateBonusAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeDiscountPhase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staffContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_staffContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"percent\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"fromDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"toDate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"byStaff\",\"type\":\"address\"}],\"name\":\"DiscountPhaseAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"byStaff\",\"type\":\"address\"}],\"name\":\"DiscountPhaseRemoved\",\"type\":\"event\"}]","ContractName":"DiscountPhases","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000001dbaddf4e9b51e7e66ef541b8a7fc900b0b2dcd","Library":"","SwarmSource":"bzzr://e88ae1679817d25e2d1a678cfd42730928173f24b4b37a764879c1aef0dfba8a"}]}