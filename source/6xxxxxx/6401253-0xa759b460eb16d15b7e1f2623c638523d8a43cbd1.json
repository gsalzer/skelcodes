{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n * See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n  {\r\n    require(has(_role, _addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _role.bearer[_addr];\r\n  }\r\n}\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * Supports unlimited numbers of roles and addresses.\r\n * See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n * for you to write your own implementation of this interface using Enums or similar.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address indexed operator, string role);\r\n  event RoleRemoved(address indexed operator, string role);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address _operator, string _role)\r\n    public\r\n    view\r\n  {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address _operator, string _role)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function addRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function removeRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string _role)\r\n  {\r\n    checkRole(msg.sender, _role);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param _roles the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] _roles) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < _roles.length; i++) {\r\n  //         if (hasRole(msg.sender, _roles[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\ncontract Crowdsale {\r\n using SafeMath for uint256;\r\n using SafeERC20 for ERC20;\r\n\r\n // The token being sold\r\n ERC20 public token;\r\n\r\n // Address where funds are collected\r\n address public wallet;\r\n\r\n // How many token units a buyer gets per wei.\r\n // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n // 1 wei will give you 1 unit, or 0.001 TOK.\r\n uint256 public rate;\r\n\r\n // Amount of wei raised\r\n uint256 public weiRaised;\r\n\r\n /**\r\n  * Event for token purchase logging\r\n  * @param purchaser who paid for the tokens\r\n  * @param beneficiary who got the tokens\r\n  * @param value weis paid for purchase\r\n  * @param amount amount of tokens purchased\r\n  */\r\n event TokenPurchase(\r\n   address indexed purchaser,\r\n   address indexed beneficiary,\r\n   uint256 value,\r\n   uint256 amount\r\n );\r\n\r\n /**\r\n  * @param _rate Number of token units a buyer gets per wei\r\n  * @param _wallet Address where collected funds will be forwarded to\r\n  * @param _token Address of the token being sold\r\n  */\r\n constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n   require(_rate > 0);\r\n   require(_wallet != address(0));\r\n   require(_token != address(0));\r\n\r\n   rate = _rate;\r\n   wallet = _wallet;\r\n   token = _token;\r\n }\r\n\r\n // -----------------------------------------\r\n // Crowdsale external interface\r\n // -----------------------------------------\r\n\r\n /**\r\n  * @dev fallback function ***DO NOT OVERRIDE***\r\n  */\r\n function () external payable {\r\n   buyTokens(msg.sender);\r\n }\r\n\r\n /**\r\n  * @dev low level token purchase ***DO NOT OVERRIDE***\r\n  * @param _beneficiary Address performing the token purchase\r\n  */\r\n function buyTokens(address _beneficiary) public payable {\r\n\r\n   uint256 weiAmount = msg.value;\r\n   _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n   // calculate token amount to be created\r\n   uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n   // update state\r\n   weiRaised = weiRaised.add(weiAmount);\r\n\r\n   _processPurchase(_beneficiary, tokens);\r\n   emit TokenPurchase(\r\n     msg.sender,\r\n     _beneficiary,\r\n     weiAmount,\r\n     tokens\r\n   );\r\n\r\n   _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n   _forwardFunds();\r\n   _postValidatePurchase(_beneficiary, weiAmount);\r\n }\r\n\r\n // -----------------------------------------\r\n // Internal interface (extensible)\r\n // -----------------------------------------\r\n\r\n /**\r\n  * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n  * Example from CappedCrowdsale.sol's _preValidatePurchase method:\r\n  *   super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  *   require(weiRaised.add(_weiAmount) <= cap);\r\n  * @param _beneficiary Address performing the token purchase\r\n  * @param _weiAmount Value in wei involved in the purchase\r\n  */\r\n function _preValidatePurchase(\r\n   address _beneficiary,\r\n   uint256 _weiAmount\r\n )\r\n   internal\r\n {\r\n   require(_beneficiary != address(0));\r\n   require(_weiAmount != 0);\r\n }\r\n\r\n /**\r\n  * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n  * @param _beneficiary Address performing the token purchase\r\n  * @param _weiAmount Value in wei involved in the purchase\r\n  */\r\n function _postValidatePurchase(\r\n   address _beneficiary,\r\n   uint256 _weiAmount\r\n )\r\n   internal\r\n {\r\n   // optional override\r\n }\r\n\r\n /**\r\n  * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n  * @param _beneficiary Address performing the token purchase\r\n  * @param _tokenAmount Number of tokens to be emitted\r\n  */\r\n function _deliverTokens(\r\n   address _beneficiary,\r\n   uint256 _tokenAmount\r\n )\r\n   internal\r\n {\r\n   token.safeTransfer(_beneficiary, _tokenAmount);\r\n }\r\n\r\n /**\r\n  * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n  * @param _beneficiary Address receiving the tokens\r\n  * @param _tokenAmount Number of tokens to be purchased\r\n  */\r\n function _processPurchase(\r\n   address _beneficiary,\r\n   uint256 _tokenAmount\r\n )\r\n   internal\r\n {\r\n   _deliverTokens(_beneficiary, _tokenAmount);\r\n }\r\n\r\n /**\r\n  * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n  * @param _beneficiary Address receiving the tokens\r\n  * @param _weiAmount Value in wei involved in the purchase\r\n  */\r\n function _updatePurchasingState(\r\n   address _beneficiary,\r\n   uint256 _weiAmount\r\n )\r\n   internal\r\n {\r\n   // optional override\r\n }\r\n\r\n /**\r\n  * @dev Override to extend the way in which ether is converted to tokens.\r\n  * @param _weiAmount Value in wei to be converted into tokens\r\n  * @return Number of tokens that can be purchased with the specified _weiAmount\r\n  */\r\n function _getTokenAmount(uint256 _weiAmount)\r\n   internal view returns (uint256)\r\n {\r\n   return _weiAmount.mul(rate);\r\n }\r\n\r\n /**\r\n  * @dev Determines how ETH is stored/forwarded on purchases.\r\n  */\r\n function _forwardFunds() internal {\r\n   wallet.transfer(msg.value);\r\n }\r\n}\r\n\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyWhileOpen\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\ncontract Whitelist is Ownable, RBAC {\r\n  string public constant ROLE_WHITELISTED = \"whitelist\";\r\n\r\n  /**\r\n   * @dev Throws if operator is not whitelisted.\r\n   * @param _operator address\r\n   */\r\n  modifier onlyIfWhitelisted(address _operator) {\r\n    checkRole(_operator, ROLE_WHITELISTED);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param _operator address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address _operator)\r\n    public\r\n    onlyOwner\r\n  {\r\n    addRole(_operator, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in whitelist\r\n   */\r\n  function whitelist(address _operator)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return hasRole(_operator, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param _operators addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] _operators)\r\n    public\r\n    onlyOwner\r\n  {\r\n    for (uint256 i = 0; i < _operators.length; i++) {\r\n      addAddressToWhitelist(_operators[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param _operator address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address _operator)\r\n    public\r\n    onlyOwner\r\n  {\r\n    removeRole(_operator, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param _operators addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] _operators)\r\n    public\r\n    onlyOwner\r\n  {\r\n    for (uint256 i = 0; i < _operators.length; i++) {\r\n      removeAddressFromWhitelist(_operators[i]);\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract WhitelistedCrowdsale is Whitelist, Crowdsale {\r\n  /**\r\n   * @dev Extend parent behavior requiring beneficiary to be in whitelist.\r\n   * @param _beneficiary Token beneficiary\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyIfWhitelisted(_beneficiary)\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\ncontract CbntCrowdsale is TimedCrowdsale, WhitelistedCrowdsale {\r\n using SafeMath for uint256;\r\n\r\n\r\n struct FutureTransaction{\r\n   address beneficiary;\r\n   uint256 num;\r\n   uint32  times;\r\n   uint256 lastTime;\r\n }\r\n FutureTransaction[] public futureTrans;\r\n uint256 public oweCbnt;\r\n\r\n uint256[] public rateSteps;\r\n uint256[] public rateStepsValue;\r\n uint32[] public regularTransTime;\r\n uint32 public transTimes;\r\n\r\n uint256 public minInvest;\r\n\r\n/**\r\n  * @param _openingTime Crowdsale opening time\r\n  * @param _closingTime Crowdsale closing time\r\n  * @param _rate Number of token units a buyer gets per wei\r\n  * @param _wallet Address where collected funds will be forwarded to\r\n  * @param _token Address of the token being sold\r\n  */\r\n constructor(uint256 _openingTime, uint256 _closingTime, uint256 _rate, address _wallet, ERC20 _token) TimedCrowdsale(_openingTime,_closingTime) Crowdsale(_rate,_wallet, _token) public {\r\n  // Crowdsale(uint256(1),_wallet, _token);\r\n   //TimedCrowdsale(_openingTime,_closingTime);\r\n }\r\n\r\n /** external functions **/\r\n function triggerTransaction(uint256 beginIdx, uint256 endIdx) public returns (bool){\r\n   uint32 regularTime = findRegularTime();\r\n   require(regularTime > 0 && endIdx < futureTrans.length);\r\n\r\n   bool bRemove = false;\r\n   uint256 i = 0;\r\n   for(i = beginIdx; i<=endIdx && i<futureTrans.length; ){\r\n     bRemove = false;\r\n     if(futureTrans[i].lastTime < regularTime){  // need to set the regularTime again when it comes late than the last regularTime\r\n        uint256 transNum = futureTrans[i].num;\r\n        address beneficiary = futureTrans[i].beneficiary;\r\n        //update data\r\n\r\n        futureTrans[i].lastTime = now;\r\n        futureTrans[i].times = futureTrans[i].times - 1;\r\n        require(futureTrans[i].times <= transTimes);\r\n\r\n        // remove item if it is the last time transaction\r\n        if(futureTrans[i].times ==0 ){\r\n           bRemove = true;\r\n           futureTrans[i].beneficiary = futureTrans[futureTrans.length -1].beneficiary;\r\n           futureTrans[i].num = futureTrans[futureTrans.length -1].num;\r\n           futureTrans[i].lastTime = futureTrans[futureTrans.length -1].lastTime;\r\n           futureTrans[i].times = futureTrans[futureTrans.length -1].times;\r\n           futureTrans.length = futureTrans.length.sub(1);\r\n        }\r\n           // transfer token\r\n        oweCbnt = oweCbnt.sub(transNum);\r\n        _deliverTokens(beneficiary, transNum);\r\n     }\r\n\r\n     if(!bRemove){\r\n       i++;\r\n     }\r\n   }\r\n\r\n   return true;\r\n\r\n }\r\n function transferBonus(address _beneficiary, uint256 _tokenAmount) public onlyOwner returns(bool){\r\n   _deliverTokens(_beneficiary, _tokenAmount);\r\n   return true;\r\n }\r\n\r\n // need to set this param before start business\r\n function setMinInvest(uint256 _minInvest) public onlyOwner returns (bool){\r\n   minInvest = _minInvest;\r\n   return true;\r\n }\r\n\r\n // need to set this param before start business\r\n function setTransTimes(uint32 _times) public onlyOwner returns (bool){\r\n   transTimes = _times;\r\n   return true;\r\n }\r\n\r\n function setRegularTransTime(uint32[] _times) public onlyOwner returns (bool){\r\n   for (uint256 i = 0; i + 1 < _times.length; i++) {\r\n       require(_times[i] < _times[i+1]);\r\n   }\r\n\r\n   regularTransTime = _times;\r\n   return true;\r\n }\r\n\r\n // need to set this param before start business\r\n function setRateSteps(uint256[] _steps, uint256[] _stepsValue) public onlyOwner returns (bool){\r\n   require(_steps.length == _stepsValue.length);\r\n   for (uint256 i = 0; i + 1 < _steps.length; i++) {\r\n       require(_steps[i] > _steps[i+1]);\r\n   }\r\n\r\n   rateSteps = _steps;\r\n   rateStepsValue = _stepsValue;\r\n   return true;\r\n }\r\n\r\n // need to check these params before start business\r\n function normalCheck() public view returns (bool){\r\n   return (transTimes > 0 && regularTransTime.length > 0 && minInvest >0 && rateSteps.length >0);\r\n }\r\n\r\n function getFutureTransLength() public view returns(uint256) {\r\n     return futureTrans.length;\r\n }\r\n function getFutureTransByIdx(uint256 _idx) public view returns(address,uint256, uint32, uint256) {\r\n     return (futureTrans[_idx].beneficiary, futureTrans[_idx].num, futureTrans[_idx].times, futureTrans[_idx].lastTime);\r\n }\r\n function getFutureTransIdxByAddress(address _beneficiary) public view returns(uint256[]) {\r\n     uint256 i = 0;\r\n     uint256 num = 0;\r\n     for(i=0; i<futureTrans.length; i++){\r\n       if(futureTrans[i].beneficiary == _beneficiary){\r\n           num++;\r\n       }\r\n     }\r\n     uint256[] memory transList = new uint256[](num);\r\n\r\n     uint256 idx = 0;\r\n     for(i=0; i<futureTrans.length; i++){\r\n       if(futureTrans[i].beneficiary == _beneficiary){\r\n         transList[idx] = i;\r\n         idx++;\r\n       }\r\n     }\r\n     return transList;\r\n }\r\n\r\n /** internal functions **/\r\n /**\r\n  * @dev Returns the rate of tokens per wei.\r\n  * Note that, as price _increases_ with invest number, the rate _increases_.\r\n  * @param _weiAmount The value in wei to be converted into tokens\r\n  * @return The number of tokens a buyer gets per wei\r\n  */\r\n function getCurrentRate(uint256 _weiAmount) public view returns (uint256) {\r\n   for (uint256 i = 0; i < rateSteps.length; i++) {\r\n       if (_weiAmount >= rateSteps[i]) {\r\n           return rateStepsValue[i];\r\n       }\r\n   }\r\n   return 0;\r\n }\r\n\r\n /**\r\n  * @dev Overrides parent method taking into account variable rate.\r\n  * @param _weiAmount The value in wei to be converted into tokens\r\n  * @return The number of tokens _weiAmount wei will send at present time\r\n  */\r\n function _getTokenAmount(uint256 _weiAmount)\r\n   internal view returns (uint256)\r\n {\r\n   uint256 currentRate = getCurrentRate(_weiAmount);\r\n   return currentRate.mul(_weiAmount).div(transTimes);\r\n }\r\n\r\n /**\r\n  * @dev Extend parent behavior requiring to be within contributing period\r\n  * @param _beneficiary Token purchaser\r\n  * @param _weiAmount Amount of wei contributed\r\n  */\r\n function _preValidatePurchase(\r\n   address _beneficiary,\r\n   uint256 _weiAmount\r\n )\r\n   internal\r\n {\r\n   require(msg.value >= minInvest);\r\n   super._preValidatePurchase(_beneficiary, _weiAmount);\r\n }\r\n\r\n /**\r\n  * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n  * @param _beneficiary Address receiving the tokens\r\n  * @param _tokenAmount Number of tokens to be purchased\r\n  */\r\n function _processPurchase(\r\n   address _beneficiary,\r\n   uint256 _tokenAmount\r\n )\r\n   internal\r\n {\r\n   // update the future transactions for future using.\r\n   FutureTransaction memory tran = FutureTransaction(_beneficiary, _tokenAmount, transTimes-1, now); // the trtanstimes always lagger than 0\r\n   futureTrans.push(tran);\r\n\r\n   //update owe cbnt\r\n   oweCbnt = oweCbnt.add(_tokenAmount.mul(tran.times));\r\n   super._processPurchase(_beneficiary, _tokenAmount);\r\n }\r\n\r\n function findRegularTime() internal view returns (uint32) {\r\n   if(now < regularTransTime[0]){\r\n     return 0;\r\n   }\r\n\r\n   uint256 i = 0;\r\n   while(i<regularTransTime.length && now >= regularTransTime[i]){\r\n     i++;\r\n   }\r\n\r\n   return regularTransTime[i -1];\r\n\r\n }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getFutureTransIdxByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rateSteps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_steps\",\"type\":\"uint256[]\"},{\"name\":\"_stepsValue\",\"type\":\"uint256[]\"}],\"name\":\"setRateSteps\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFutureTransLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_times\",\"type\":\"uint32\"}],\"name\":\"setTransTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_times\",\"type\":\"uint32[]\"}],\"name\":\"setRegularTransTime\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rateStepsValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oweCbnt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"getCurrentRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beginIdx\",\"type\":\"uint256\"},{\"name\":\"endIdx\",\"type\":\"uint256\"}],\"name\":\"triggerTransaction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minInvest\",\"type\":\"uint256\"}],\"name\":\"setMinInvest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"futureTrans\",\"outputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"times\",\"type\":\"uint32\"},{\"name\":\"lastTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"normalCheck\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"getFutureTransByIdx\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"transferBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"regularTransTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CbntCrowdsale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005bab2060000000000000000000000000000000000000000000000000000000006e7ba4800000000000000000000000000000000000000000000000000000000000000001000000000000000000000000ed1fc57ec62d542e5fe926fde640d42eeeb3b3ec0000000000000000000000001274a04257f6de10fc71559c85e881187e43b10f","Library":"","SwarmSource":"bzzr://4d0bb38b6bea67ad54e9d4d4062d0ee34443d78fb5b59e19a899aeab48a5d527"}]}