{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract AccessControl {\r\n     /// @dev Emited when contract is upgraded - See README.md for updgrade plan\r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public ceoAddress;\r\n\r\n    uint public totalTipForDeveloper = 0;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress, \"You're not a CEO!\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Wrong send eth! It's will tip for developer\r\n    function () public payable{\r\n        totalTipForDeveloper = totalTipForDeveloper + msg.value;\r\n    }\r\n\r\n    /// @dev Add tip for developer\r\n    /// @param valueTip The value of tip\r\n    function addTipForDeveloper(uint valueTip) internal {\r\n        totalTipForDeveloper += valueTip;\r\n    }\r\n\r\n    /// @dev Developer can withdraw tip.\r\n    function withdrawTipForDeveloper() external onlyCEO {\r\n        require(totalTipForDeveloper > 0, \"Need more tip to withdraw!\");\r\n        msg.sender.transfer(totalTipForDeveloper);\r\n        totalTipForDeveloper = 0;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0), \"Address to set CEO wrong!\");\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /*Pausable functionality adapted from OpenZeppelin */\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Paused!\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused, \"Not paused!\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCEO whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyCEO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract RPSCore is AccessControl {\r\n    uint constant ROCK = 1000;\r\n    uint constant PAPER = 2000;\r\n    uint constant SCISSOR = 3000;\r\n\r\n    uint constant GAME_RESULT_DRAW = 1;\r\n    uint constant GAME_RESULT_HOST_WIN = 2;\r\n    uint constant GAME_RESULT_GUEST_WIN = 3;\r\n\r\n    uint constant GAME_STATE_AVAILABLE_TO_JOIN = 1;\r\n    uint constant GAME_STATE_WAITING_HOST_REVEAL = 2;\r\n\r\n    uint constant DEVELOPER_TIP_PERCENT = 1;\r\n    uint constant DEVELOPER_TIP_MIN = 0.0005 ether;\r\n\r\n    uint constant VALUE_BET_MIN = 0.02 ether;\r\n    uint constant VALUE_BET_MAX = 2 ether;\r\n\r\n    uint constant TIME_GAME_EXPIRE = 1 hours;\r\n\r\n    struct Game {\r\n        uint id;\r\n        uint state;\r\n        uint timeExpire;\r\n        uint valueBet;\r\n        uint gestureGuest;\r\n        address addressHost;\r\n        address addressGuest;\r\n        bytes32 hashGestureHost;\r\n    }\r\n\r\n    event LogCloseGameSuccessed(uint _id, uint _valueReturn);\r\n    event LogCreateGameSuccessed(uint _id, uint _valuePlayerHostBid);\r\n    event LogJoinGameSuccessed(uint _id);\r\n    event LogRevealGameSuccessed(uint _id,\r\n                                    uint _result,\r\n                                    address indexed _addressPlayerWin,\r\n                                    address indexed _addressPlayerLose,\r\n                                    uint _valuePlayerWin,\r\n                                    uint _valuePlayerLose,\r\n                                    uint _gesturePlayerWin,\r\n                                    uint _gesturePlayerLose);\r\n \r\n    uint public totalCreatedGame;\r\n    uint public totalAvailableGames;\r\n    Game[] public arrAvailableGames;\r\n\r\n    mapping(uint => uint) idToIndexAvailableGames;\r\n\r\n\r\n    constructor() public {\r\n        ceoAddress = msg.sender;\r\n\r\n        totalCreatedGame = 0;\r\n        totalAvailableGames = 0;\r\n    }\r\n\r\n    function createGame(bytes32 _hashGestureHost)\r\n        external\r\n        payable\r\n        verifiedValueBetWithRule(msg.value)\r\n    {\r\n        Game memory game = Game({\r\n            id: totalCreatedGame + 1,\r\n            state: GAME_STATE_AVAILABLE_TO_JOIN,\r\n            timeExpire: 0,\r\n            valueBet: msg.value,\r\n            addressHost: msg.sender,\r\n            hashGestureHost: _hashGestureHost,\r\n            addressGuest: 0,\r\n            gestureGuest: 0\r\n        });\r\n\r\n        arrAvailableGames.push(game);\r\n        idToIndexAvailableGames[game.id] = arrAvailableGames.length - 1;\r\n\r\n        totalCreatedGame++;\r\n        totalAvailableGames++;\r\n\r\n        emit LogCreateGameSuccessed(game.id, game.valueBet);\r\n    }\r\n\r\n    function joinGame(uint _id, uint _gestureGuest)\r\n        external\r\n        payable\r\n        verifiedValueBetWithRule(msg.value)\r\n        verifiedGameAvailable(_id)\r\n        verifiedGameExist(_id)\r\n    {\r\n        Game storage game = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n\r\n        require(msg.sender != game.addressHost, \"Can't join game cretead by host\");\r\n        require(msg.value == game.valueBet, \"Value bet to battle not extractly with value bet of host\");\r\n       \r\n        game.addressGuest = msg.sender;\r\n        game.gestureGuest = _gestureGuest;\r\n        game.state = GAME_STATE_WAITING_HOST_REVEAL;\r\n        game.timeExpire = now + TIME_GAME_EXPIRE;\r\n\r\n        emit LogJoinGameSuccessed(_id);\r\n    }\r\n\r\n    function revealGameByHost(uint _id, uint _gestureHost, bytes32 _secretKey) external payable verifiedGameExist(_id) {\r\n        bytes32 proofHashGesture = getProofGesture(_gestureHost, _secretKey);\r\n        Game storage game = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n        Game memory gameCached = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n\r\n        require(gameCached.state == GAME_STATE_WAITING_HOST_REVEAL, \"Game not in state waiting reveal\");\r\n        require(now <= gameCached.timeExpire, \"Host time reveal ended\");\r\n        require(gameCached.addressHost == msg.sender, \"You're not host this game\");\r\n        require(gameCached.hashGestureHost == proofHashGesture, \"Can't verify gesture and secret key of host\");\r\n        require(verifyGesture(_gestureHost) && verifyGesture(gameCached.gestureGuest), \"Can't verify gesture of host or guest\");\r\n\r\n        uint result = GAME_RESULT_DRAW;\r\n\r\n        //Result: [Draw] => Return money to host and guest players (No fee)\r\n        if(_gestureHost == gameCached.gestureGuest) {\r\n            result = GAME_RESULT_DRAW;\r\n            sendPayment(gameCached.addressHost, gameCached.valueBet);\r\n            sendPayment(gameCached.addressGuest, gameCached.valueBet);\r\n            game.valueBet = 0;\r\n            destroyGame(_id);\r\n            emit LogRevealGameSuccessed(_id,\r\n                                        GAME_RESULT_DRAW,\r\n                                        gameCached.addressHost,\r\n                                        gameCached.addressGuest,\r\n                                        0,\r\n                                        0,\r\n                                        _gestureHost, \r\n                                        gameCached.gestureGuest);\r\n        }\r\n        else {\r\n            if(_gestureHost == ROCK) \r\n                result = gameCached.gestureGuest == SCISSOR ? GAME_RESULT_HOST_WIN : GAME_RESULT_GUEST_WIN;\r\n            else\r\n                if(_gestureHost == PAPER) \r\n                    result = (gameCached.gestureGuest == ROCK ? GAME_RESULT_HOST_WIN : GAME_RESULT_GUEST_WIN);\r\n                else\r\n                    if(_gestureHost == SCISSOR) \r\n                        result = (gameCached.gestureGuest == PAPER ? GAME_RESULT_HOST_WIN : GAME_RESULT_GUEST_WIN);\r\n\r\n            //Result: [Win] => Return money to winner (Winner will pay 1% fee)\r\n            uint valueTip = getValueTip(gameCached.valueBet);\r\n            addTipForDeveloper(valueTip);\r\n            \r\n            if(result == GAME_RESULT_HOST_WIN) {\r\n                sendPayment(gameCached.addressHost, gameCached.valueBet * 2 - valueTip);\r\n                game.valueBet = 0;\r\n                destroyGame(_id);    \r\n                emit LogRevealGameSuccessed(_id,\r\n                                            GAME_RESULT_HOST_WIN,\r\n                                            gameCached.addressHost,\r\n                                            gameCached.addressGuest,\r\n                                            gameCached.valueBet - valueTip,\r\n                                            gameCached.valueBet,\r\n                                            _gestureHost, \r\n                                            gameCached.gestureGuest);\r\n            }\r\n            else {\r\n                sendPayment(gameCached.addressGuest, gameCached.valueBet * 2 - valueTip);\r\n                game.valueBet = 0;\r\n                destroyGame(_id);\r\n                emit LogRevealGameSuccessed(_id,\r\n                                            GAME_RESULT_GUEST_WIN,\r\n                                            gameCached.addressGuest,\r\n                                            gameCached.addressHost,\r\n                                            gameCached.valueBet - valueTip,\r\n                                            gameCached.valueBet,\r\n                                            gameCached.gestureGuest, \r\n                                            _gestureHost);\r\n            }          \r\n        }\r\n    }\r\n\r\n    function revealGameByGuest(uint _id) external payable verifiedGameExist(_id) {\r\n        Game storage game = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n        Game memory gameCached = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n\r\n        require(gameCached.state == GAME_STATE_WAITING_HOST_REVEAL, \"Game not in state waiting reveal\");\r\n        require(now > gameCached.timeExpire, \"Host time reveal not ended\");\r\n        require(gameCached.addressGuest == msg.sender, \"You're not guest this game\");\r\n\r\n        uint valueTip = getValueTip(gameCached.valueBet);\r\n        addTipForDeveloper(valueTip);\r\n\r\n        sendPayment(gameCached.addressGuest, gameCached.valueBet * 2 - valueTip);\r\n        game.valueBet = 0;\r\n        destroyGame(_id);\r\n        emit LogRevealGameSuccessed(_id,\r\n                                    GAME_RESULT_GUEST_WIN,\r\n                                    gameCached.addressGuest,\r\n                                    gameCached.addressHost,\r\n                                    gameCached.valueBet - valueTip,\r\n                                    gameCached.valueBet,\r\n                                    gameCached.gestureGuest, \r\n                                    0);\r\n    }\r\n\r\n    function closeMyGame(uint _id) external payable verifiedHostOfGame(_id) verifiedGameAvailable(_id) {\r\n        Game storage game = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n\r\n        require(game.state == GAME_STATE_AVAILABLE_TO_JOIN, \"Battle already! Waiting your reveal! Refesh page\");\r\n\r\n        uint valueBetCached = game.valueBet;\r\n        sendPayment(game.addressHost, valueBetCached);\r\n        game.valueBet = 0;\r\n        destroyGame(_id);\r\n        emit LogCloseGameSuccessed(_id, valueBetCached);\r\n    }\r\n\r\n    function getAvailableGameWithID(uint _id) \r\n        public\r\n        view\r\n        verifiedGameExist(_id) \r\n        returns (uint id, uint state, uint valueBest, uint timeExpireRemaining, address addressHost, address addressGuest) \r\n    {\r\n        Game storage game = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n        timeExpireRemaining = game.timeExpire - now;\r\n        timeExpireRemaining = (timeExpireRemaining < 0 ? 0 : timeExpireRemaining);\r\n\r\n        return(game.id, game.state, game.valueBet, game.timeExpire, game.addressHost, game.addressGuest);\r\n    }\r\n\r\n    function destroyGame(uint _id) private {\r\n        removeGameInfoFromArray(idToIndexAvailableGames[_id]);\r\n        delete idToIndexAvailableGames[_id];\r\n        totalAvailableGames--;\r\n    }\r\n\r\n    function removeGameInfoFromArray(uint _index) private {\r\n        if(_index >= 0 && arrAvailableGames.length > 0) {\r\n            if(_index == arrAvailableGames.length - 1)\r\n            arrAvailableGames.length--;\r\n            else {\r\n                arrAvailableGames[_index] = arrAvailableGames[arrAvailableGames.length - 1];\r\n                idToIndexAvailableGames[arrAvailableGames[_index].id] = _index;\r\n                arrAvailableGames.length--;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getValueTip(uint _valueWin) private pure returns(uint) {\r\n        uint valueTip = _valueWin * DEVELOPER_TIP_PERCENT / 100;\r\n\r\n        if(valueTip < DEVELOPER_TIP_MIN)\r\n            valueTip = DEVELOPER_TIP_MIN;\r\n\r\n        return valueTip;\r\n    }\r\n\r\n    function sendPayment(address _receiver, uint _amount) private {\r\n        _receiver.transfer(_amount);\r\n    }\r\n\r\n    function getProofGesture(uint _gesture, bytes32 _secretKey) private pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_gesture, _secretKey));\r\n    }\r\n\r\n    function verifyGesture(uint _gesture) private pure returns (bool) {\r\n        return (_gesture == ROCK || _gesture == PAPER || _gesture == SCISSOR);\r\n    }\r\n\r\n    modifier verifiedGameAvailable(uint _id) {\r\n        require(arrAvailableGames[idToIndexAvailableGames[_id]].addressGuest == 0, \"Have guest already\");\r\n        _;\r\n    }\r\n\r\n    modifier verifiedGameExist(uint _id) {\r\n        require(idToIndexAvailableGames[_id] >= 0, \"Game ID not exist!\");\r\n        _;\r\n    }\r\n\r\n    modifier verifiedHostOfGame(uint _id) {\r\n        require(msg.sender == arrAvailableGames[idToIndexAvailableGames[_id]].addressHost, \"Verify host of game failed\");\r\n        _;\r\n    }\r\n\r\n    modifier verifiedValueBetWithRule(uint _valueBet) {\r\n        require(_valueBet >= VALUE_BET_MIN && _valueBet <= VALUE_BET_MAX, \"Your value bet out of rule\");\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTipForDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"closeMyGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAvailableGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hashGestureHost\",\"type\":\"bytes32\"}],\"name\":\"createGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"revealGameByGuest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCreatedGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTipForDeveloper\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_gestureHost\",\"type\":\"uint256\"},{\"name\":\"_secretKey\",\"type\":\"bytes32\"}],\"name\":\"revealGameByHost\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_gestureGuest\",\"type\":\"uint256\"}],\"name\":\"joinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrAvailableGames\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint256\"},{\"name\":\"timeExpire\",\"type\":\"uint256\"},{\"name\":\"valueBet\",\"type\":\"uint256\"},{\"name\":\"gestureGuest\",\"type\":\"uint256\"},{\"name\":\"addressHost\",\"type\":\"address\"},{\"name\":\"addressGuest\",\"type\":\"address\"},{\"name\":\"hashGestureHost\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getAvailableGameWithID\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint256\"},{\"name\":\"valueBest\",\"type\":\"uint256\"},{\"name\":\"timeExpireRemaining\",\"type\":\"uint256\"},{\"name\":\"addressHost\",\"type\":\"address\"},{\"name\":\"addressGuest\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_valueReturn\",\"type\":\"uint256\"}],\"name\":\"LogCloseGameSuccessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_valuePlayerHostBid\",\"type\":\"uint256\"}],\"name\":\"LogCreateGameSuccessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"LogJoinGameSuccessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_result\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_addressPlayerWin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_addressPlayerLose\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_valuePlayerWin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_valuePlayerLose\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gesturePlayerWin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gesturePlayerLose\",\"type\":\"uint256\"}],\"name\":\"LogRevealGameSuccessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"RPSCore","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://36e9c5ef9b04ff7211ff142984a6374ba316ba2df39d808d500a0851734ee6a7"}]}