{"status":"1","message":"OK","result":[{"SourceCode":"// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/WhiteList.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\ncontract WhiteList is Ownable{\r\n\r\n\r\n\tmapping(address => uint8) public whitelist;\r\n\tbool public publicsale_need_whitelist = true;\r\n\r\n\tevent ImportList(address indexed owner, address[] users, uint8 flag);\r\n\tevent UpdatePublicSaleWhitelistStatus(address indexed owner, bool flag);\r\n\r\n  \t/**\r\n\t* @dev Function to import user's address into whitelist, only user who in the whitelist can purchase token.\r\n\t*      Whitelistにユーザーアドレスを記録。sale期間に、Whitelistに記録したユーザーたちしかトークンを購入できない\r\n\t* @param _users The address list that can purchase token when sale period.\r\n\t* @param _flag The flag for record different lv user, 1: pre sale user, 2: public sale user. 3: premium sale user\r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction importList(address[] _users, uint8 _flag) onlyOwner public returns(bool){\r\n\r\n\t\trequire(_users.length > 0);\r\n\r\n        for(uint i = 0; i < _users.length; i++) {\r\n            whitelist[_users[i]] = _flag;\r\n        }\t\t\r\n\r\n        emit ImportList(msg.sender, _users, _flag);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n  \t/**\r\n\t* @dev Function check the current user can purchase token or not.\r\n\t*      ユーザーアドレスはWhitelistに記録かどうかチェック\r\n\t* @param _user The user address that can purchase token or not when public salse.\r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction checkList(address _user)public view returns(uint8){\r\n\t\treturn whitelist[_user];\r\n\t}\r\n\r\n  \t/**\r\n\t* @dev Function get whitelist able status in public sale \r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction getPublicSaleWhitelistStatus()public view returns(bool){\r\n\t\treturn publicsale_need_whitelist;\r\n\t}\t\r\n\r\n  \t/**\r\n\t* @dev Function update whitelist able status in public sale \r\n\t* @param _flag bool whitelist status\r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction updatePublicSaleWhitelistStatus(bool _flag) onlyOwner public returns(bool){\r\n\t\tpublicsale_need_whitelist = _flag;\r\n\r\n\t\temit UpdatePublicSaleWhitelistStatus(msg.sender, _flag);\r\n\r\n\t\treturn true;\r\n\t}\t\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/Deliver.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\ncontract Deliver is Ownable{\r\n\tusing SafeMath for uint256;\r\n\r\n\tmapping(address => uint256) public waiting_plate;\r\n\tmapping(bytes32 => uint256) public token_deliver_date_plate;\r\n\tmapping(bytes32 => uint256) public token_deliver_plate;\r\n\tmapping(bytes32 => bool) public already_deliver_token;\r\n\tmapping(address => uint256) public deliver_balance;\r\n\tmapping(bytes32 => address) public hash_mapping;\r\n\tmapping(bytes32 => bool) public deliver_suspending;\r\n\r\n\tevent UpdateWaitingPlate(address indexed updater, address indexed user, uint256 waiting_time);\r\n\tevent UpdateTokenDeliverPlate(address indexed updater, bytes32 indexed hash_id, uint256 token_amount);\r\n\tevent UpdateTokenDeliverCheck(address indexed updater, bytes32 indexed hash_id, bool flag);\r\n\tevent UpdateTokenDeliverBalance(address indexed updater, address indexed user, uint256 pending_token_amount);\r\n\tevent UpdateHashMapping(address indexed updater, bytes32 indexed hash_id, address indexed user);\r\n\tevent UpdateDeliverSuspending(address indexed updater, bytes32 indexed hash_id, bool deliver_suspending);\r\n\r\n\t/**\r\n\t* @dev called for get user waiting time\r\n\t* @param _user Address\r\n\t* @return A uint256 that if the operation was successful.\r\n\t*/\r\n\tfunction getWaitingPlate(address _user) public view returns(uint256){\r\n\t\treturn waiting_plate[_user];\r\n\t}\r\n\t\r\n\t/**\r\n\t* @dev called for get user deliver date\r\n\t* @param _hash_id transaction unique hash id\r\n\t* @return A uint256 that if the operation was successful.\r\n\t*/\r\n\tfunction getTokenDeliverDatePlate(bytes32 _hash_id) public view returns(uint256){\r\n\t\treturn token_deliver_date_plate[_hash_id];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get user waiting time\r\n\t* @param _hash_id transaction unique hash id\r\n\t* @return A uint256 that if the operation was successful.\r\n\t*/\r\n\tfunction getTokenDeliverPlate(bytes32 _hash_id) public view returns(uint256){\r\n\t\treturn token_deliver_plate[_hash_id];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get user total pending token amount\r\n\t* @param _user user address\r\n\t* @return A uint256 that if the operation was successful.\r\n\t*/\r\n\tfunction getPendingDeliverToken(address _user) public view returns(uint256){\r\n\t\treturn deliver_balance[_user];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get user address from hash_id\r\n\t* @param _hash_id transaction unique hash id\r\n\t* @return A address that if the operation was successful.\r\n\t*/\r\n\tfunction getHashMappingAddress(bytes32 _hash_id) public view returns(address){\r\n\t\treturn hash_mapping[_hash_id];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get user token deliver suspending status\r\n\t* @param _hash_id transaction unique hash id\r\n\t* @return A bool that if the operation was successful.\r\n\t*/\r\n\tfunction getDeliverSuspending(bytes32 _hash_id) public view returns(bool){\r\n\t\treturn deliver_suspending[_hash_id];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get user total pending token amount\r\n\t* @param _hash_id transaction unique hash id\r\n\t* @return A bool that if the operation was successful.\r\n\t*/\r\n\tfunction deliverCheck(bytes32 _hash_id) public view returns(bool){\r\n\t\treturn already_deliver_token[_hash_id];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for insert user waiting time\r\n\t* @param _users Address list\r\n\t* @param _waiting_times 時期申告時間リスト\r\n\t* @return A bool that if the operation was successful.\r\n\t*/\r\n\tfunction pushWaitingPlate(address[] _users, uint256[] _waiting_times)onlyOwner public returns(bool){\r\n\r\n\t\trequire(_users.length > 0 && _waiting_times.length > 0);\r\n\t\trequire(_users.length == _waiting_times.length);\r\n\r\n\t\taddress user;\r\n\t\tuint256 waiting_time;\r\n\r\n        for(uint i = 0; i < _users.length; i++) {\r\n        \tuser = _users[i];\r\n        \twaiting_time = _waiting_times[i];\r\n\r\n            waiting_plate[user] = waiting_time;\r\n\r\n            emit UpdateWaitingPlate(msg.sender, user, waiting_time);\r\n        }\t\t\r\n\r\n\t\treturn true;\r\n\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for insert user waiting time\r\n\t* @param _hash_id transaction unique hash id\r\n\t* @param _suspending ユーザーのトークン配布禁止フラグ\r\n\t* @return A bool that if the operation was successful.\r\n\t*/\r\n\tfunction updateDeliverSuspending(bytes32 _hash_id, bool _suspending)onlyOwner public returns(bool){\r\n\t\tdeliver_suspending[_hash_id] = _suspending;\r\n\r\n\t\temit UpdateDeliverSuspending(msg.sender, _hash_id, _suspending);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for insert user token info in the mapping\r\n\t* @param _hash_id transaction unique hash id\r\n\t* @param _total_token_amount the token amount that include bonus\r\n\t* @return A bool that if the operation was successful.\r\n\t*/\r\n\tfunction pushTokenDeliverPlate(address _beneficiary, bytes32 _hash_id, uint256 _total_token_amount, uint256 _deliver_date)onlyOwner public returns(bool){\r\n\r\n\t\trequire(_total_token_amount > 0);\r\n\r\n\t\ttoken_deliver_plate[_hash_id] = _total_token_amount;\r\n\t\talready_deliver_token[_hash_id] = false;\r\n\t\tdeliver_balance[_beneficiary] = deliver_balance[_beneficiary].add(_total_token_amount);\r\n\t\thash_mapping[_hash_id] = _beneficiary;\r\n\t\ttoken_deliver_date_plate[_hash_id] = _deliver_date;\r\n\r\n\t\temit UpdateTokenDeliverPlate(msg.sender, _hash_id, _total_token_amount);\r\n\t\temit UpdateTokenDeliverCheck(msg.sender, _hash_id, true);\r\n\t\temit UpdateTokenDeliverBalance(msg.sender, _beneficiary, deliver_balance[_beneficiary]);\r\n\t\temit UpdateHashMapping(msg.sender, _hash_id, _beneficiary);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for reset user token info in the mapping\r\n\t* @param _hash_id transaction unique hash id\r\n\t* @return A bool that if the operation was successful.\r\n\t*/\r\n\tfunction resetTokenDeliverPlate(address _beneficiary, bytes32 _hash_id, uint256 _token_amount)onlyOwner public returns(bool){\r\n\r\n\t\trequire(_token_amount > 0);\r\n\r\n\t\ttoken_deliver_plate[_hash_id] = 0;\r\n\t\talready_deliver_token[_hash_id] = true;\r\n\t\tdeliver_balance[_beneficiary] = deliver_balance[_beneficiary].sub(_token_amount);\r\n\r\n\t\temit UpdateTokenDeliverPlate(msg.sender, _hash_id, 0);\r\n\t\temit UpdateTokenDeliverCheck(msg.sender, _hash_id, false);\r\n\t\temit UpdateTokenDeliverBalance(msg.sender, _beneficiary, deliver_balance[_beneficiary]);\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\n// File: contracts/Bonus.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\ncontract Bonus is Ownable{\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public constant day = 24*60*60;\r\n\r\n\tuint256 public publicSale_first_stage_endTime;\r\n\r\n\tmapping(uint8 => uint256) public bonus_time_gate;\r\n\tmapping(uint8 => uint8) public bonus_rate;\r\n\r\n\tevent UpdateBonusPhase(address indexed updater, uint8 indexed phase_type, uint256 time_gate, uint8 bonus);\r\n\tevent UpdatePublicSaleFirstStageEndTime(address indexed updater, uint256 publicSale_first_stage_endTime);\r\n\r\n\tconstructor(\r\n\t\tuint256 _publicSale_first_stage_endTime,\r\n\t\tuint256 _bonus_time_gate_1, \r\n\t\tuint256 _bonus_time_gate_2,\r\n\t\tuint256 _bonus_time_gate_3, \r\n\t\tuint256 _bonus_time_gate_4,\r\n\t\tuint8 _bonus_rate_1, \r\n\t\tuint8 _bonus_rate_2,\r\n\t\tuint8 _bonus_rate_3,\r\n\t\tuint8 _bonus_rate_4) public\r\n\t{\r\n\t\tbonus_time_gate[0] = _bonus_time_gate_1*uint256(day);\r\n\t\tbonus_time_gate[1] = _bonus_time_gate_2*uint256(day);\r\n\t\tbonus_time_gate[2] = _bonus_time_gate_3*uint256(day);\r\n\t\tbonus_time_gate[3] = _bonus_time_gate_4*uint256(day);\r\n\r\n\t\tbonus_rate[0] = _bonus_rate_1;\r\n\t\tbonus_rate[1] = _bonus_rate_2;\r\n\t\tbonus_rate[2] = _bonus_rate_3;\r\n\t\tbonus_rate[3] = _bonus_rate_4;\r\n\t\r\n\t\tpublicSale_first_stage_endTime = _publicSale_first_stage_endTime;\r\n\r\n\t\temit UpdateBonusPhase(msg.sender, 1, _bonus_time_gate_1, _bonus_rate_1);\r\n\t\temit UpdateBonusPhase(msg.sender, 2, _bonus_time_gate_2, _bonus_rate_2);\r\n\t\temit UpdateBonusPhase(msg.sender, 3, _bonus_time_gate_3, _bonus_rate_3);\r\n\t\temit UpdateBonusPhase(msg.sender, 4, _bonus_time_gate_4, _bonus_rate_4);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get bonus rate\r\n\t* @param _phase_type uint8 bonus phase block\r\n\t* @return A uint8, bonus rate that if the operation was successful.\r\n\t*/\r\n\tfunction getBonusRate(uint8 _phase_type) public view returns(uint8){\r\n\t\treturn bonus_rate[_phase_type];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get bonus time block\r\n\t* @param _phase_type uint8 bonus phase block\r\n\t* @return A uint8, phase block time that if the operation was successful.\t\r\n\t*/\r\n\tfunction getBonusTimeGate(uint8 _phase_type) public view returns(uint256){\r\n\t\treturn bonus_time_gate[_phase_type];\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get the public sale first stage end time\r\n\t* @return A uint256, the public sale first stage end time that if the operation was successful.\t\r\n\t*/\r\n\tfunction getPublicSaleFirstStageEndTime() public view returns(uint256){\r\n\t\treturn publicSale_first_stage_endTime;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get total token amount that include the bonus\r\n\t* @param _waiting_time uint256 KYV waiting time\r\n\t* @param _tokenAmount uint256 basic token amount\r\n\t* @return A uint256, total token amount that if the operation was successful.\t\t\r\n\t*/\r\n\tfunction getTotalAmount(uint256 _waiting_time, uint256 _tokenAmount) public view returns(uint256){\r\n\t\tuint256 total_token_amount;\r\n\r\n\t\tif(_waiting_time < bonus_time_gate[0]){\r\n\t\t\t//user still can get bonus if user purchase token before publicSale first stage end time.\r\n\t\t\tif(now <= publicSale_first_stage_endTime){\r\n\t\t\t\ttotal_token_amount = _tokenAmount + (_tokenAmount * uint256(bonus_rate[0])) / 100;\r\n\t\t\t}else{\r\n\t\t\t\ttotal_token_amount = _tokenAmount;\r\n\t\t\t}\r\n\t\t}else if(_waiting_time < bonus_time_gate[1]){\r\n\t\t\ttotal_token_amount = _tokenAmount + (_tokenAmount * uint256(bonus_rate[0])) / 100;\r\n\t\t}else if(_waiting_time < bonus_time_gate[2]){\r\n\t\t\ttotal_token_amount = _tokenAmount + (_tokenAmount * uint256(bonus_rate[1])) / 100;\r\n\t\t}else if(_waiting_time < bonus_time_gate[3]){\r\n\t\t\ttotal_token_amount = _tokenAmount + (_tokenAmount * uint256(bonus_rate[2])) / 100;\r\n\t\t}else{\r\n\t\t\ttotal_token_amount = _tokenAmount + (_tokenAmount * uint256(bonus_rate[3])) / 100;\r\n\t\t}\r\n\r\n\t\treturn total_token_amount;\r\n\t}\r\n\t\r\n\t/**\r\n\t* @dev called for update the public sale first stage end time\r\n\t* @param _new_stage_endTime uint256 new public sale first stage end time\r\n\t* @return A uint256, the public sale first stage end time that if the operation was successful.\t\r\n\t*/\r\n\tfunction updatePublicSaleFirstStageEndTime(uint256 _new_stage_endTime)onlyOwner public returns(bool){\r\n\t\tpublicSale_first_stage_endTime = _new_stage_endTime;\r\n\r\n\t\temit UpdatePublicSaleFirstStageEndTime(msg.sender, _new_stage_endTime);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for update bonus phase time block and rate\r\n\t* @param _phase_type uint8 phase block\r\n\t* @param _new_days uint256 new phase block time\r\n\t* @param _new_bonus uint8 new rate\r\n\t* @return A bool that if the operation was successful.\r\n\t*/\r\n\tfunction updateBonusPhase(uint8 _phase_type, uint256 _new_days, uint8 _new_bonus)onlyOwner public returns(bool){\r\n\r\n\t\tuint256 _new_gate = _new_days * uint256(day);\r\n\r\n\t\t//gate phase only have 4 phase\r\n\t\trequire(0 < _phase_type && _phase_type <= 4);\r\n\r\n\t\t//gate phase 1\r\n\t\tif(_phase_type == 1){\r\n\r\n\t\t\t//new gate time needs to be early than the next gate time\r\n\t\t\trequire( _new_gate < bonus_time_gate[1] );\r\n\r\n\t\t\t//new gate rate needs to be less than the next gate's rate\r\n\t\t\trequire( _new_bonus < bonus_rate[1] );\r\n\r\n\t\t\tbonus_time_gate[0] = _new_gate;\r\n\t\t\tbonus_rate[0] = _new_bonus;\r\n\t\t}else if(_phase_type == 2){\r\n\r\n\t\t\t//new gate time needs to be early than the next gate time and need to be late than the perious gate time\r\n\t\t\trequire( bonus_time_gate[0] < _new_gate && _new_gate < bonus_time_gate[2] );\r\n\r\n\t\t\t//new gate rate needs to be less than the next gate's rate and need to be bigger than the perious gate rate\r\n\t\t\trequire( bonus_rate[0] < _new_bonus && _new_bonus < bonus_rate[2] );\r\n\r\n\t\t\tbonus_time_gate[1] = _new_gate;\r\n\t\t\tbonus_rate[1] = _new_bonus;\r\n\t\t}else if(_phase_type == 3){\r\n\r\n\t\t\trequire( bonus_time_gate[1] < _new_gate && _new_gate < bonus_time_gate[3] );\r\n\t\t\trequire( bonus_rate[1] < _new_bonus && _new_bonus < bonus_rate[3] );\r\n\r\n\t\t\tbonus_time_gate[2] = _new_gate;\r\n\t\t\tbonus_rate[2] = _new_bonus;\r\n\t\t}else{\r\n\r\n\t\t\trequire( bonus_time_gate[2] < _new_gate );\r\n\t\t\trequire( bonus_rate[2] < _new_bonus );\r\n\r\n\t\t\tbonus_time_gate[3] = _new_gate;\r\n\t\t\tbonus_rate[3] = _new_bonus;\r\n\t\t}\r\n\r\n\t\temit UpdateBonusPhase(msg.sender, _phase_type, _new_days, _new_bonus);\r\n\t}\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropiate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(\r\n    address indexed purchaser,\r\n    address indexed beneficiary,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per wei\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n  constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(\r\n      msg.sender,\r\n      _beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(_beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    token.transfer(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _deliverTokens(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount)\r\n    internal view returns (uint256)\r\n  {\r\n    return _weiAmount.mul(rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyWhileOpen\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: contracts/COTCoinPublicSaleCrowdsale.sol\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract COTCoinPublicSaleCrowdsale is TimedCrowdsale, Ownable, Pausable{\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public admin_wallet; //wallet to controll system\r\n\taddress public sale_owner_wallet; \r\n\taddress public eth_management_wallet; //wallet to reveive eth\r\n\taddress public refund_token_wallet; //wallet that contract will return token\r\n\taddress public cot_sale_wallet;\r\n\r\n\tuint256 public minimum_weiAmount;\r\n\r\n\tuint256 public public_opening_time;\r\n\tuint256 public public_closing_time;\r\n\r\n\tWhiteList public white_list;\r\n\tDeliver public deliver;\r\n\tBonus public bonus;\r\n\r\n\tuint256 public pending_balance;\r\n\r\n\tevent UpdateRate(address indexed updater, uint256 transaction_date, uint256 rate);\r\n\tevent ReFundToken(address indexed from, address indexed to, uint256 token_amount);\r\n\tevent PublicsalePurchase(address indexed beneficiary, \r\n\t\t\t\t\t\t\tuint256 transaction_date,\r\n\t\t\t\t\t\t\tuint256 waiting_time, \r\n\t\t\t\t\t\t\tuint256 deliver_date, \r\n\t\t\t\t\t\t\tuint256 value, \r\n\t\t\t\t\t\t\tuint256 origin_token_amount, \r\n\t\t\t\t\t\t\tuint256 total_token_amount,\r\n\t\t\t\t\t\t\tbytes32 hash_id,\r\n\t\t\t\t\t\t\tuint256 sale_balance,\r\n\t\t\t\t\t\t\tuint256 publicsale_balance,\r\n\t\t\t\t\t\t\tuint256 remain_balance);\r\n\tevent DeliverTokens(address indexed from, address indexed to, uint256 token_amount, uint256 deliver_time, bytes32 hash_id);\r\n\tevent UpdateMinimumAmount( address indexed updater, uint256 minimumWeiAmount);\r\n\tevent UpdateReFundAddress( address indexed updater, address indexed refund_address);\r\n\r\n\tconstructor(\r\n\t\tuint256 _openingTime, \r\n\t\tuint256 _closingTime,\r\n\t\tuint256 _minimum_weiAmount,\r\n\t\tuint256 _rate,\r\n\t\taddress _admin_wallet, \r\n\t\taddress _eth_management_wallet,\r\n\t\taddress _refund_token_wallet,\r\n\t\taddress _cot_sale_wallet,\r\n\t\tWhiteList _whiteList,\r\n\t\tERC20 _cot,\r\n\t\tDeliver _deliver,\r\n\t\tBonus _bonus) public\r\n\t    Crowdsale(_rate, _eth_management_wallet, _cot)\r\n\t    TimedCrowdsale(_openingTime, _closingTime)\r\n\t{\r\n\t\tminimum_weiAmount = _minimum_weiAmount;\r\n\r\n\t\tadmin_wallet = _admin_wallet;\r\n\t\teth_management_wallet = _eth_management_wallet;\r\n\t\trefund_token_wallet = _refund_token_wallet;\r\n\t\tcot_sale_wallet = _cot_sale_wallet;\r\n\r\n\t\tpublic_opening_time = _openingTime;\r\n\t\tpublic_closing_time = _closingTime;\r\n\r\n\t\twhite_list = _whiteList;\r\n\t\tdeliver = _deliver;\r\n\t\tbonus = _bonus;\r\n\r\n\t\temit UpdateRate( msg.sender, now,  _rate);\r\n\t\temit UpdateMinimumAmount(msg.sender, _minimum_weiAmount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev low level token purchase ***DO NOT OVERRIDE***\r\n\t* @param _beneficiary Address performing the token purchase\r\n\t*/\r\n\tfunction buyTokens(address _beneficiary) onlyWhileOpen whenNotPaused public payable {\r\n\r\n\t\tuint256 weiAmount = msg.value;\r\n\t\t_preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n\t\t// calculate token amount to be created\r\n\t\tuint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n\t\t// update state\r\n\t\tweiRaised = weiRaised.add(weiAmount);\r\n\r\n\t\t_processPurchase(_beneficiary, tokens);\r\n\t\temit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n\r\n\t\t_updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n\t\t_forwardFunds();\r\n\t\t_postValidatePurchase(_beneficiary, weiAmount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Validation of an incoming purchase. Use require statemens to revert state when conditions are not met. Use super to concatenate validations.\r\n\t* @param _beneficiary Address performing the token purchase\r\n\t* @param _weiAmount Value in wei involved in the purchase\r\n\t*/\r\n\tfunction _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\r\n\t\trequire(_beneficiary != address(0));\r\n\t\trequire(_weiAmount != 0);\r\n\r\n\t\t//minimum ether check\r\n\t\tuint256 publicSale_first_stage_endTime = bonus.getPublicSaleFirstStageEndTime();\r\n\r\n\t\t//need to check minimum ether\r\n\t\trequire(_weiAmount >= minimum_weiAmount);\r\n\t\t\r\n\t\t//owner can not purchase token\r\n\t\trequire(_beneficiary != admin_wallet);\r\n\t\trequire(_beneficiary != eth_management_wallet);\r\n\r\n\t\t//whitelist check\r\n\t\t//whitelist 2-public sale user\r\n\t\tuint8 inWhitelist = white_list.checkList(_beneficiary);\r\n\r\n\t\t//if need to check whitelist status\r\n\t\t//0:white listに入ってない, 1:プレセール, 2:パブリックセール, 3:プレミアムセール\r\n\t\tif( white_list.getPublicSaleWhitelistStatus() ){\r\n\t\t\trequire( inWhitelist != 0);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n\t* @param _beneficiary Address receiving the tokens\r\n\t* @param _tokenAmount Number of tokens to be purchased\r\n\t*/\r\n\tfunction _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n\r\n\t\t//check waiting time date which provided by KVC\r\n\t\tuint256 waiting_time = deliver.getWaitingPlate(_beneficiary);\r\n\r\n\t\trequire(waiting_time != 0);\r\n\r\n\t\t//calculate that when will deliver token to purchaser\r\n\t\tuint256 deliver_date = waiting_time + now;\r\n\r\n\t\t//calculate the token + bonus\r\n\t\tuint256 total_token_amount = bonus.getTotalAmount(waiting_time, _tokenAmount);\r\n\r\n\t\t//make the unique id\r\n\t\tbytes32 hash_id = keccak256(abi.encodePacked(_beneficiary,now));\r\n\r\n        //get total cot sale amount\r\n        uint256 cot_sale_wallet_balance = token.balanceOf(cot_sale_wallet);\r\n        uint256 publicsale_balance = token.balanceOf(address(this));\r\n\r\n\t\tuint256 total_cot_amount =  cot_sale_wallet_balance.add(publicsale_balance);\r\n\t\tuint256 expect_pending_balance = pending_balance.add(total_token_amount);\r\n        require(total_cot_amount > expect_pending_balance);\r\n        uint256 remain_cot_amount = total_cot_amount.sub(expect_pending_balance);\r\n\r\n\r\n\t\tpending_balance = pending_balance.add(total_token_amount);\r\n\r\n\t\trequire(deliver.pushTokenDeliverPlate(_beneficiary, hash_id, total_token_amount , deliver_date));\r\n\r\n\t\temit PublicsalePurchase(_beneficiary, now, waiting_time, deliver_date, msg.value, _tokenAmount, total_token_amount, hash_id, cot_sale_wallet_balance, publicsale_balance, remain_cot_amount);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get pending balance\r\n\t*/\r\n\tfunction getPendingBalance() public view returns(uint256){\r\n\t\treturn pending_balance; \r\n\t}\t\r\n\r\n\t/**\r\n\t* @dev called for update user waiting time\r\n\t* @param _users Address \r\n\t* @param _waiting_times 時期申告時間\r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction updateWaitingPlate(address[] _users, uint256[] _waiting_times)onlyOwner public returns(bool){\r\n\r\n\t\trequire(deliver.pushWaitingPlate(_users, _waiting_times));\r\n\r\n\t\treturn true;\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for update user deliver suspending status\r\n\t* @param _hash_id unique hash id\r\n\t* @param _suspending ユーザーのトークン配布禁止フラグ\r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction updateDeliverSuspending(bytes32 _hash_id, bool _suspending)onlyOwner public returns(bool){\r\n\r\n\t\trequire(deliver.updateDeliverSuspending(_hash_id, _suspending));\r\n\r\n\t\treturn true;\t\t\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for get status of pause.\r\n\t*/\r\n\tfunction ispause() public view returns(bool){\r\n\t\treturn paused;\r\n\t}\t\r\n\r\n\t/**\r\n\t* @dev Function update rate\r\n\t* @param _newRate rate\r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction updateRate(int256 _newRate)onlyOwner public returns(bool){\r\n\t\trequire(_newRate >= 1);\r\n\r\n\t\trate = uint256(_newRate);\r\n\r\n\t\temit UpdateRate( msg.sender, now, rate);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function get rate\r\n\t* @return A uint256 that indicates if the operation was successful.\r\n\t*/\r\n\tfunction getRate() public view returns(uint256){\r\n\t\treturn rate;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function return token back to the admin wallet\r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction reFundToken(uint256 _value)onlyOwner public returns (bool){\r\n\t\ttoken.transfer(refund_token_wallet, _value);\r\n\r\n\t\temit ReFundToken(msg.sender, refund_token_wallet, _value);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function to update refund address\r\n\t* @param _add new refund Address \r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction updateReFundAddress(address _add)onlyOwner public returns (bool){\r\n\t\trefund_token_wallet = _add;\r\n\r\n\t\temit UpdateReFundAddress(msg.sender, _add);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev called for deliver token\r\n\t* @param _beneficiary Address \r\n\t* @param _hash_id unique hash id\r\n\t* @return A bool that indicates if the operation was successful.\r\n\t*/\r\n\tfunction deliverTokens(address _beneficiary, bytes32 _hash_id)onlyOwner public returns (bool){\r\n\t\t\r\n\t\t// will reject if already delivered token \r\n\t\tbool already_delivered = deliver.deliverCheck(_hash_id);\r\n\t\trequire(already_delivered == false);\r\n\r\n\t\t//get the token deliver date \r\n\t\tuint256 deliver_token_date = deliver.getTokenDeliverDatePlate(_hash_id);\r\n\t\trequire(deliver_token_date <= now);\r\n\r\n\t\t//get the token amount that need to deliver \r\n\t\tuint256 deliver_token_amount = deliver.getTokenDeliverPlate(_hash_id);\r\n\t\trequire(deliver_token_amount > 0);\r\n\r\n\t\t//deliver user should match\r\n\t\taddress deliver_user = deliver.getHashMappingAddress(_hash_id);\r\n\t\trequire(deliver_user == _beneficiary);\r\n\r\n\t\t//get token deliver suspending status\r\n\t\tbool deliver_suspending = deliver.getDeliverSuspending(_hash_id);\r\n\t\trequire(!deliver_suspending);\r\n\r\n\t\t//get the total pending token amount for this user\r\n\t\tuint256 penging_total_deliver_token_amount = deliver.getPendingDeliverToken(_beneficiary);\r\n\t\trequire(penging_total_deliver_token_amount > 0);\r\n\r\n\t\t//the remain pending token amount should not less than 0\r\n\t\tuint256 remain_panding_total_deliver_token_amount = penging_total_deliver_token_amount - deliver_token_amount;\r\n\t\trequire(remain_panding_total_deliver_token_amount >= 0);\r\n\r\n\t\t//deliver token\r\n\t\ttoken.transfer(_beneficiary, deliver_token_amount);\r\n\r\n\t\t//reset data\r\n\t\trequire(deliver.resetTokenDeliverPlate(_beneficiary, _hash_id, deliver_token_amount));\r\n\r\n\t\tpending_balance = pending_balance.sub(deliver_token_amount);\r\n\r\n\t\temit DeliverTokens(msg.sender, _beneficiary, deliver_token_amount, now, _hash_id);\r\n\t}\r\n\r\n\t/**\r\n\t* @dev get admin wallet\r\n\t*/\r\n\tfunction getAdminAddress() public view returns(address) {\r\n\t\treturn admin_wallet;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev get eth management owner wallet\r\n\t*/\r\n\tfunction getEtherManagementAddress() public view returns(address) {\r\n\t\treturn eth_management_wallet;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev get token refund wallet\r\n\t*/\r\n\tfunction getReFundAddress() public view returns(address) {\r\n\t\treturn refund_token_wallet;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev get start date for public sale\r\n\t*/\r\n\tfunction getPublicsaleOpeningDate() public view returns(uint256) {\r\n\t\treturn public_opening_time;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev get end date for public sale\r\n\t*/\r\n\tfunction getPublicsaleClosingDate() public view returns(uint256) {\r\n\t\treturn public_closing_time;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function get minimum wei amount\r\n\t* @return A uint256 that indicates if the operation was successful.\r\n\t*/\r\n\tfunction getMinimumAmount() public view returns(uint256){\r\n\t\treturn minimum_weiAmount;\r\n\t}\r\n\r\n\t/**\r\n\t* @dev Function update minimum wei amount\r\n\t* @return A uint256 that indicates if the operation was successful.\r\n\t*/\r\n\tfunction updateMinimumAmount(int256 _new_minimum_weiAmount)onlyOwner public returns(bool){\r\n\r\n\t\trequire(_new_minimum_weiAmount >= 0);\r\n\r\n\t\tminimum_weiAmount = uint256(_new_minimum_weiAmount);\r\n\r\n\t\temit UpdateMinimumAmount( msg.sender, minimum_weiAmount);\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_hash_id\",\"type\":\"bytes32\"}],\"name\":\"deliverTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash_id\",\"type\":\"bytes32\"},{\"name\":\"_suspending\",\"type\":\"bool\"}],\"name\":\"updateDeliverSuspending\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_new_minimum_weiAmount\",\"type\":\"int256\"}],\"name\":\"updateMinimumAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getReFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEtherManagementAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPublicsaleOpeningDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cot_sale_wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth_management_wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"reFundToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refund_token_wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMinimumAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPendingBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"public_closing_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"public_opening_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale_owner_wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"int256\"}],\"name\":\"updateRate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ispause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin_wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"white_list\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_add\",\"type\":\"address\"}],\"name\":\"updateReFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pending_balance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPublicsaleClosingDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_users\",\"type\":\"address[]\"},{\"name\":\"_waiting_times\",\"type\":\"uint256[]\"}],\"name\":\"updateWaitingPlate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimum_weiAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deliver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_minimum_weiAmount\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_admin_wallet\",\"type\":\"address\"},{\"name\":\"_eth_management_wallet\",\"type\":\"address\"},{\"name\":\"_refund_token_wallet\",\"type\":\"address\"},{\"name\":\"_cot_sale_wallet\",\"type\":\"address\"},{\"name\":\"_whiteList\",\"type\":\"address\"},{\"name\":\"_cot\",\"type\":\"address\"},{\"name\":\"_deliver\",\"type\":\"address\"},{\"name\":\"_bonus\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transaction_date\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"}],\"name\":\"UpdateRate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token_amount\",\"type\":\"uint256\"}],\"name\":\"ReFundToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"transaction_date\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"waiting_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deliver_date\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"origin_token_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total_token_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hash_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"sale_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"publicsale_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"remain_balance\",\"type\":\"uint256\"}],\"name\":\"PublicsalePurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deliver_time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hash_id\",\"type\":\"bytes32\"}],\"name\":\"DeliverTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"minimumWeiAmount\",\"type\":\"uint256\"}],\"name\":\"UpdateMinimumAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"updater\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"refund_address\",\"type\":\"address\"}],\"name\":\"UpdateReFundAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"COTCoinPublicSaleCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005b5d0380000000000000000000000000000000000000000000000000000000005f4d8eff00000000000000000000000000000000000000000000000000470de4df82000000000000000000000000000000000000000000000000000000000000000030d4000000000000000000000000894d52703566a5bc2e47837a3eeb8eb43381ee29000000000000000000000000a3d779daff51a3c7a4ed7107c7b35d8f5b48767b0000000000000000000000005a5a58dbac64b70712c4dc2d28bffac71eb2bea700000000000000000000000025b94a458d19c97c7be62d1c2653669bccbb3e340000000000000000000000005c524f8b8d94999b42295ee0b6e088a4b43110b4000000000000000000000000ed64142f7d0a4d94ce0e7fe45d12f712fe360bd0000000000000000000000000bede284180c4b539430b0bfecaf1c4adff3ffdda000000000000000000000000ecea235bd2172bcffb7b280090cf06b2b14b193a","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://b699ba241e7907a1857065016ea4276b8e51c4396c03ffd1a25ee4fea0575dae"}]}