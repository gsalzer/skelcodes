{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\nlibrary SafeMath {\r\n\r\n  // We use `pure` bbecause it promises that the value for the function depends ONLY\r\n  // on the function arguments\r\n    function mul(uint256 a, uint256 b) internal pure  returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface RTCoinInterface {\r\n    \r\n\r\n    /** Functions - ERC20 */\r\n    function transfer(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function transferFrom(address _owner, address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function approve(address _spender, uint256 _amount) external returns (bool approved);\r\n\r\n    /** Getters - ERC20 */\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address _holder) external view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n    /** Getters - Custom */\r\n    function mint(address _recipient, uint256 _amount) external returns (bool);\r\n\r\n    function stakeContractAddress() external view returns (address);\r\n\r\n    function mergedMinerValidatorAddress() external view returns (address);\r\n    \r\n    /** Functions - Custom */\r\n    function freezeTransfers() external returns (bool);\r\n\r\n    function thawTransfers() external returns (bool);\r\n}\r\n\r\n\r\n/// @title This contract is used to handle vesting of the RTC token\r\n/// @author Postables, RTrade Technologies Ltd\r\n/// @dev We able V5 for safety features, see https://solidity.readthedocs.io/en/v0.4.24/security-considerations.html#take-warnings-seriously\r\ncontract Vesting {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // these will need to be changed prior to deployment\r\n    address constant public TOKENADDRESS = 0xecc043b92834c1ebDE65F2181B59597a6588D616;\r\n    RTCoinInterface constant public RTI = RTCoinInterface(TOKENADDRESS);\r\n    string constant public VERSION = \"production\";\r\n\r\n    address public admin;\r\n\r\n    // keeps track of the state of a vest\r\n    enum VestState {nil, vesting, vested}\r\n\r\n    struct Vest {\r\n        // total amount of coins vesting\r\n        uint256 totalVest;\r\n        // the times at which the tokens will unlock\r\n        uint256[] releaseDates;\r\n        // the amount of tokens to unlock at each interval\r\n        uint256[] releaseAmounts;\r\n        VestState state;\r\n        // keeps track of what tokens have been unlocked\r\n        mapping (uint256 => bool) claimed;\r\n    }\r\n\r\n    // Keeps track of token vests\r\n    mapping (address => Vest) public vests;\r\n\r\n    // make sure that they are using a valid vest index\r\n    modifier validIndex(uint256 _vestIndex) {\r\n        require(_vestIndex < vests[msg.sender].releaseDates.length, \"attempting to access invalid vest index must be less than length of array\");\r\n        _;\r\n    }\r\n\r\n    // make sure that the claim date has been passed\r\n    modifier pastClaimDate(uint256 _vestIndex) {\r\n        require(now >= vests[msg.sender].releaseDates[_vestIndex], \"attempting to claim vest before release date\");\r\n        _;\r\n    }\r\n\r\n    // make sure that the vest is not yet claimed\r\n    modifier unclaimedVest(uint256 _vestIndex) {\r\n        require(!vests[msg.sender].claimed[_vestIndex], \"vest must be unclaimed\");\r\n        _;\r\n    }\r\n\r\n    // make sure that the vest is active\r\n    modifier activeVester() {\r\n        require(vests[msg.sender].state == VestState.vesting, \"vest must be active\");\r\n        _;\r\n    }\r\n\r\n    // make sure that the user has no active vests going on\r\n    modifier nonActiveVester(address _vester) {\r\n        require(vests[_vester].state == VestState.nil, \"address must not have an active vest\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin, \"sender must be admin\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _admin) public {\r\n        // prevent deployments if not properly setup\r\n        require(TOKENADDRESS != address(0), \"token address not set\");\r\n        admin = _admin;\r\n    }\r\n\r\n    /** @notice Used to deposit a vest for someone\r\n        * Mythril will report an overflow here, however it is a false positive\r\n        * @dev Yes we are looping, however we have the ability to ensure that the block gas limit will never be reached\r\n        * @param _vester This is the person for whom vests are being enabled\r\n        * @param _totalAmountToVest This is the total amount of coins being vested\r\n        * @param _releaseDates These are the dates at which tokens will be unlocked\r\n        * @param _releaseAmounts these are the amounts of tokens to be unlocked at each date\r\n     */\r\n    function addVest(\r\n        address _vester,\r\n        uint256 _totalAmountToVest,\r\n        uint256[] _releaseDates, // unix time stamp format `time.Now().Unix()` in golang\r\n        uint256[] _releaseAmounts)\r\n        public\r\n        nonActiveVester(_vester)\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        require(_releaseDates.length > 0 && _releaseAmounts.length > 0 && _totalAmountToVest > 0, \"attempting to use non zero values\");\r\n        require(_releaseDates.length == _releaseAmounts.length, \"array lengths are not equal\");\r\n        uint256 total;\r\n        for (uint256 i = 0; i < _releaseAmounts.length; i++) {\r\n            total = total.add(_releaseAmounts[i]);\r\n            require(now < _releaseDates[i], \"release date must be in the future\");\r\n        }\r\n        require(total == _totalAmountToVest, \"invalid total amount to vest\");\r\n        Vest memory v = Vest({\r\n            totalVest: _totalAmountToVest,\r\n            releaseDates: _releaseDates,\r\n            releaseAmounts: _releaseAmounts,\r\n            state: VestState.vesting\r\n        });\r\n        vests[_vester] = v;\r\n        require(RTI.transferFrom(msg.sender, address(this), _totalAmountToVest), \"transfer from failed, most likely needs approval\");\r\n        return true;\r\n    }\r\n\r\n\r\n    /** @notice Used to withdraw unlocked vested tokens\r\n        * @dev Yes we are looping, but as we can control the total number of loops, etc.. we can ensure that the block gas limit will never be reached\r\n        * @notice IF YOU ARE WITHDRAWING THE LAST VEST (LAST INDEX) YOU MUST HAVE WITHDRAWN ALL OTHER VESTS FIRST OR THE TX WILL FAIL\r\n        * @param _vestIndex the particular vest to be withdrawn\r\n     */\r\n    function withdrawVestedTokens(\r\n        uint256 _vestIndex)\r\n        public\r\n        activeVester\r\n        validIndex(_vestIndex)\r\n        unclaimedVest(_vestIndex)\r\n        pastClaimDate(_vestIndex)\r\n        returns (bool)\r\n    {\r\n        // if this is the last vest, make sure all others have been claimed and then mark as vested\r\n        if (_vestIndex == vests[msg.sender].releaseAmounts.length.sub(1)) {\r\n            bool check;\r\n            for (uint256 i = 0; i < vests[msg.sender].releaseAmounts.length; i++) {\r\n                // if we detect that even one vest hasn't been claimed, set check to false and break out of loop\r\n                if (!vests[msg.sender].claimed[i]) {\r\n                    // this will preventsituations where the first vest may not be claimed but later ones have been\r\n                    // which would result in a \"split brain\" type scenario, in which the code thinks all vests have been claimed\r\n                    // but they actually haven't\r\n                    check = false;\r\n                    // break out of the loop\r\n                    break;\r\n                }\r\n                check = true;\r\n            }\r\n            // if they are attempting to withdraw the last vest, this must be true or else the tx will revert\r\n            require(check, \"not all vests have been withdrawn before attempting to withdraw final vest\");\r\n            // as this is the last vest, we must mark everything as having been vested, preventing further invocations\r\n            vests[msg.sender].state = VestState.vested;\r\n        }\r\n        // mark this particular vest as claimed\r\n        vests[msg.sender].claimed[_vestIndex] = true;\r\n        uint256 amount = vests[msg.sender].releaseAmounts[_vestIndex];\r\n        require(RTI.transfer(msg.sender, amount), \"failed to transfer\");\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"TOKENADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RTI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"vests\",\"outputs\":[{\"name\":\"totalVest\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vester\",\"type\":\"address\"},{\"name\":\"_totalAmountToVest\",\"type\":\"uint256\"},{\"name\":\"_releaseDates\",\"type\":\"uint256[]\"},{\"name\":\"_releaseAmounts\",\"type\":\"uint256[]\"}],\"name\":\"addVest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawVestedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Vesting","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000041fb0e5bd1dfe3b61e9a09ebd4105c2e35b0bcbd","Library":"","SwarmSource":"bzzr://5a82bf4ccdf569b0fa99a1a64f0f308dbac760b61acbef0767f8383e0490eb83"}]}