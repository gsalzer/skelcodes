{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n  * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n  * account.\r\n  */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n  * @return the address of the owner.\r\n  */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n  * @dev Throws if called by any account other than the owner.\r\n  */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * @return true if `msg.sender` is the owner of the contract.\r\n  */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n\r\n  /**\r\n  * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n  * @param newOwner The address to transfer ownership to.\r\n  */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  function withdrawAllEther() public onlyOwner { //to be executed on contract close\r\n    _owner.transfer(this.balance);\r\n  }\r\n\r\n  /**\r\n  * @dev Transfers control of the contract to a newOwner.\r\n  * @param newOwner The address to transfer ownership to.\r\n  */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\ncontract blackJack is Ownable {\r\n\r\n    mapping (uint => uint) cardsPower;\r\n\r\n    constructor() {\r\n    cardsPower[0] = 11; // aces\r\n    cardsPower[1] = 2;\r\n    cardsPower[2] = 3;\r\n    cardsPower[3] = 4;\r\n    cardsPower[4] = 5;\r\n    cardsPower[5] = 6;\r\n    cardsPower[6] = 7;\r\n    cardsPower[7] = 8;\r\n    cardsPower[8] = 9;\r\n    cardsPower[9] = 10;\r\n    cardsPower[10] = 10; // j\r\n    cardsPower[11] = 10; // q\r\n    cardsPower[12] = 10; // k\r\n    }\r\n\r\n\r\n    uint minBet = 0.01 ether;\r\n    uint maxBet = 0.1 ether;\r\n    uint requiredHouseBankroll = 3 ether; //use math of maxBet * 300\r\n    uint autoWithdrawBuffer = 1 ether; // only automatically withdraw if requiredHouseBankroll is exceeded by this amount\r\n\r\n\r\n    mapping (address => bool) public isActive;\r\n    mapping (address => bool) public isPlayerActive;\r\n    mapping (address => uint) public betAmount;\r\n    mapping (address => uint) public gamestatus; //1 = Player Turn, 2 = Player Blackjack!, 3 = Dealer Blackjack!, 4 = Push, 5 = Game Finished. Bets resolved.\r\n    mapping (address => uint) public payoutAmount;\r\n    mapping (address => uint) dealTime;\r\n    mapping (address => uint) blackJackHouseProhibited;\r\n    mapping (address => uint[]) playerCards;\r\n    mapping (address => uint[]) houseCards;\r\n\r\n\r\n    mapping (address => bool) playerExists; //check whether the player has played before, if so, he must have a playerHand\r\n\r\n    function card2PowerConverter(uint[] cards) internal view returns (uint) { //converts an array of cards to their actual power. 1 is 1 or 11 (Ace)\r\n        uint powerMax = 0;\r\n        uint aces = 0; //count number of aces\r\n        uint power;\r\n        for (uint i = 0; i < cards.length; i++) {\r\n             power = cardsPower[(cards[i] + 13) % 13];\r\n             powerMax += power;\r\n             if (power == 11) {\r\n                 aces += 1;\r\n             }\r\n        }\r\n        if (powerMax > 21) { //remove 10 for each ace until under 21, if possible.\r\n            for (uint i2=0; i2<aces; i2++) {\r\n                powerMax-=10;\r\n                if (powerMax <= 21) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        return uint(powerMax);\r\n    }\r\n\r\n\r\n    //PRNG / RANDOM NUMBER GENERATION. REPLACE THIS AS NEEDED WITH MORE EFFICIENT RNG\r\n\r\n    uint randNonce = 0;\r\n    function randgenNewHand() internal returns(uint,uint,uint) { //returns 3 numbers from 0-51.\r\n        //If new hand, generate 3 cards. If not, generate just 1.\r\n        randNonce++;\r\n        uint a = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 52;\r\n        randNonce++;\r\n        uint b = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 52;\r\n        randNonce++;\r\n        uint c = uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 52;\r\n        return (a,b,c);\r\n      }\r\n\r\n    function randgen() internal returns(uint) { //returns number from 0-51.\r\n        //If new hand, generate 3 cards. If not, generate just 1.\r\n        randNonce++;\r\n        return uint(keccak256(abi.encodePacked(now, msg.sender, randNonce))) % 52; //range: 0-51\r\n      }\r\n\r\n    modifier requireHandActive(bool truth) {\r\n        require(isActive[msg.sender] == truth);\r\n        _;\r\n    }\r\n\r\n    modifier requirePlayerActive(bool truth) {\r\n        require(isPlayerActive[msg.sender] == truth);\r\n        _;\r\n    }\r\n\r\n    function _play() public payable { //TEMP: Care, public.. ensure this is the public point of entry to play. Only allow 1 point of entry.\r\n        //check whether or not player has played before\r\n        if (playerExists[msg.sender]) {\r\n            require(isActive[msg.sender] == false);\r\n        }\r\n        else {\r\n            playerExists[msg.sender] = true;\r\n        }\r\n        require(msg.value >= minBet); //now check player has sent ether within betting requirements\r\n        require(msg.value <= maxBet); //TODO Do unit testing to ensure ETH is not deducted if previous conditional fails\r\n        //Now all checks have passed, the betting can proceed\r\n        uint a; //generate 3 cards, 2 for player, 1 for the house\r\n        uint b;\r\n        uint c;\r\n        (a,b,c) = randgenNewHand();\r\n        gamestatus[msg.sender] = 1;\r\n        payoutAmount[msg.sender] = 0;\r\n        isActive[msg.sender] = true;\r\n        isPlayerActive[msg.sender] = true;\r\n        betAmount[msg.sender] = msg.value;\r\n        dealTime[msg.sender] = now;\r\n        playerCards[msg.sender] = new uint[](0);\r\n        playerCards[msg.sender].push(a);\r\n        playerCards[msg.sender].push(b);\r\n        houseCards[msg.sender] = new uint[](0);\r\n        houseCards[msg.sender].push(c);\r\n        isBlackjack();\r\n        withdrawToOwnerCheck();\r\n        //TODO UPDATE playerHand correctly and also commence play utilizing game logic\r\n        //PLACEHOLDER FOR THE GAMBLING, DELEGATE TO OTHER FUNCTIONS SOME OF THE GAME LOGIC HERE\r\n        //END PLACEHOLDER, REMOVE THESE COMMENTS\r\n    }\r\n\r\n    function _Hit() public requireHandActive(true) requirePlayerActive(true) { //both the hand and player turn must be active in order to hit\r\n        uint a=randgen(); //generate a new card\r\n        playerCards[msg.sender].push(a);\r\n        checkGameState();\r\n    }\r\n\r\n    function _Stand() public requireHandActive(true) requirePlayerActive(true) { //both the hand and player turn must be active in order to stand\r\n        isPlayerActive[msg.sender] = false; //Player ends their turn, now dealer's turn\r\n        checkGameState();\r\n    }\r\n\r\n    function checkGameState() internal requireHandActive(true) { //checks game state, processing it as needed. Should be called after any card is dealt or action is made (eg: stand).\r\n        //IMPORTANT: Make sure this function is NOT called in the event of a blackjack. Blackjack should calculate things separately\r\n        if (isPlayerActive[msg.sender] == true) {\r\n            uint handPower = card2PowerConverter(playerCards[msg.sender]);\r\n            if (handPower > 21) { //player busted\r\n                processHandEnd(false);\r\n            }\r\n            else if (handPower == 21) { //autostand. Ensure same logic in stand is used\r\n                isPlayerActive[msg.sender] = false;\r\n                dealerHit();\r\n            }\r\n            else if (handPower <21) {\r\n                //do nothing, player is allowed another action\r\n            }\r\n        }\r\n        else if (isPlayerActive[msg.sender] == false) {\r\n            dealerHit();\r\n        }\r\n\r\n    }\r\n\r\n    function dealerHit() internal requireHandActive(true) requirePlayerActive(false)  { //dealer hits after player ends turn legally. Nounces can be incrimented with hits until turn finished.\r\n        uint[] storage houseCardstemp = houseCards[msg.sender];\r\n        uint[] storage playerCardstemp = playerCards[msg.sender];\r\n\r\n        uint tempCard;\r\n        while (card2PowerConverter(houseCardstemp) < 17) { //keep hitting on the same block for everything under 17. Same block is fine for dealer due to Nounce increase\r\n            //The house cannot cheat here since the player is forcing the NEXT BLOCK to be the source of randomness for all hits, and this contract cannot voluntarily skip blocks.\r\n            tempCard = randgen();\r\n            if (blackJackHouseProhibited[msg.sender] != 0) {\r\n                while (cardsPower[(tempCard + 13) % 13] == blackJackHouseProhibited[msg.sender]) { //don't deal the first card as prohibited card\r\n                    tempCard = randgen();\r\n                }\r\n                blackJackHouseProhibited[msg.sender] = 0;\r\n                }\r\n            houseCardstemp.push(tempCard);\r\n        }\r\n        //First, check if the dealer busted for an auto player win\r\n        if (card2PowerConverter(houseCardstemp) > 21 ) {\r\n            processHandEnd(true);\r\n        }\r\n        //If not, we do win logic here, since this is the natural place to do it (after dealer hitting). 3 Scenarios are possible... =>\r\n        if (card2PowerConverter(playerCardstemp) == card2PowerConverter(houseCardstemp)) {\r\n            //push, return bet\r\n            msg.sender.transfer(betAmount[msg.sender]);\r\n            payoutAmount[msg.sender]=betAmount[msg.sender];\r\n            gamestatus[msg.sender] = 4;\r\n            isActive[msg.sender] = false; //let's declare this manually only here, since processHandEnd is not called. Not needed for other scenarios.\r\n        }\r\n        else if (card2PowerConverter(playerCardstemp) > card2PowerConverter(houseCardstemp)) {\r\n            //player hand has more strength\r\n            processHandEnd(true);\r\n        }\r\n        else {\r\n            //only one possible scenario remains.. dealer hand has more strength\r\n            processHandEnd(false);\r\n        }\r\n    }\r\n\r\n    function processHandEnd(bool _win) internal { //hand is over and win is either true or false, now process it\r\n        if (_win == false) {\r\n            //do nothing, as player simply lost\r\n        }\r\n        else if (_win == true) {\r\n            uint winAmount = betAmount[msg.sender] * 2;\r\n            msg.sender.transfer(winAmount);\r\n            payoutAmount[msg.sender]=winAmount;\r\n        }\r\n        gamestatus[msg.sender] = 5;\r\n        isActive[msg.sender] = false;\r\n    }\r\n\r\n\r\n    //TODO: Log an event after hand, showing outcome\r\n\r\n    function isBlackjack() internal { //fill this function later to check both player and dealer for a blackjack after _play is called, then process\r\n        //4 possibilities: dealer blackjack, player blackjack (paying 3:2), both blackjack (push), no blackjack\r\n        //copy processHandEnd for remainder\r\n        blackJackHouseProhibited[msg.sender]=0; //set to 0 incase it already has a value\r\n        bool houseIsBlackjack = false;\r\n        bool playerIsBlackjack = false;\r\n        //First thing: For dealer check, ensure if dealer doesn't get blackjack they are prohibited from their first hit resulting in a blackjack\r\n        uint housePower = card2PowerConverter(houseCards[msg.sender]); //read the 1 and only house card, if it's 11 or 10, then deal temporary new card for bj check\r\n        if (housePower == 10 || housePower == 11) {\r\n            uint _card = randgen();\r\n            if (housePower == 10) {\r\n                if (cardsPower[_card] == 11) {\r\n                    //dealer has blackjack, process\r\n                    houseCards[msg.sender].push(_card); //push card as record, since game is now over\r\n                    houseIsBlackjack = true;\r\n                }\r\n                else {\r\n                    blackJackHouseProhibited[msg.sender]=uint(11); //ensure dealerHit doesn't draw this powerMax\r\n                }\r\n            }\r\n            else if (housePower == 11) {\r\n                if (cardsPower[_card] == 10) { //all 10s\r\n                    //dealer has blackjack, process\r\n                    houseCards[msg.sender].push(_card);  //push card as record, since game is now over\r\n                    houseIsBlackjack = true;\r\n                }\r\n                else{\r\n                    blackJackHouseProhibited[msg.sender]=uint(10); //ensure dealerHit doesn't draw this powerMax\r\n                }\r\n\r\n            }\r\n        }\r\n        //Second thing: Check if player has blackjack\r\n        uint playerPower = card2PowerConverter(playerCards[msg.sender]);\r\n        if (playerPower == 21) {\r\n            playerIsBlackjack = true;\r\n        }\r\n        //Third thing: Return all four possible outcomes: Win 1.5x, Push, Loss, or Nothing (no blackjack, continue game)\r\n        if (playerIsBlackjack == false && houseIsBlackjack == false) {\r\n            //do nothing. Call this first since it's the most likely outcome\r\n        }\r\n        else if (playerIsBlackjack == true && houseIsBlackjack == false) {\r\n            //Player has blackjack, dealer doesn't, reward 1.5x bet (plus bet return)\r\n            uint winAmount = betAmount[msg.sender] * 5/2;\r\n            msg.sender.transfer(winAmount);\r\n            payoutAmount[msg.sender] = betAmount[msg.sender] * 5/2;\r\n            gamestatus[msg.sender] = 2;\r\n            isActive[msg.sender] = false;\r\n        }\r\n        else if (playerIsBlackjack == true && houseIsBlackjack == true) {\r\n            //Both player and dealer have blackjack. Push - return bet only\r\n            uint winAmountPush = betAmount[msg.sender];\r\n            msg.sender.transfer(winAmountPush);\r\n            payoutAmount[msg.sender] = winAmountPush;\r\n            gamestatus[msg.sender] = 4;\r\n            isActive[msg.sender] = false;\r\n        }\r\n        else if (playerIsBlackjack == false && houseIsBlackjack == true) {\r\n            //Only dealer has blackjack, player loses\r\n            gamestatus[msg.sender] = 3;\r\n            isActive[msg.sender] = false;\r\n        }\r\n    }\r\n\r\n    function readCards() external view returns(uint[],uint[]) { //returns the cards in play, as an array of playercards, then houseCards\r\n        return (playerCards[msg.sender],houseCards[msg.sender]);\r\n    }\r\n\r\n    function readPower() external view returns(uint, uint) { //returns current card power of player and house\r\n        return (card2PowerConverter(playerCards[msg.sender]),card2PowerConverter(houseCards[msg.sender]));\r\n    }\r\n\r\n    function donateEther() public payable {\r\n        //do nothing\r\n    }\r\n\r\n    function withdrawToOwnerCheck() internal { //auto call this\r\n        //Contract profit withdrawal to the current contract owner is disabled unless contract balance exceeds requiredHouseBankroll\r\n        //If this condition is  met, requiredHouseBankroll must still always remain in the contract and cannot be withdrawn.\r\n        uint houseBalance = address(this).balance;\r\n        if (houseBalance > requiredHouseBankroll + autoWithdrawBuffer) { //see comments at top of contract\r\n            uint permittedWithdraw = houseBalance - requiredHouseBankroll; //leave the required bankroll behind, withdraw the rest\r\n            address _owner = owner();\r\n            _owner.transfer(permittedWithdraw);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAllEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"betAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isPlayerActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_Hit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"readCards\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payoutAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donateEther\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_Stand\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gamestatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_play\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"blackJack","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://870e8694aa1f9cb68ac67e017d98979f61b34c4d90e46195f72ed42279a52d81"}]}