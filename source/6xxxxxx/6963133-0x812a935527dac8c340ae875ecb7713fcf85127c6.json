{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n// Original gameplay and contract by Spielley\r\n// Spielley is not liable for any bugs or exploits the contract may contain\r\n// This game is purely intended for fun purposes\r\n\r\n// Gameplay:\r\n// Send in 0.1 eth to get a soldier in the field and 1 bullet\r\n// Wait till you reach the waiting time needed to shoot\r\n// Each time someone is killed divs are given to the survivors\r\n// 2 ways to shoot: \r\n// semi random, available first (after 200 blocks)\r\n// Chose target                 (after 800 blocks)\r\n\r\n// there is only a 1 time self kill prevention when semi is used\r\n// if you send in multiple soldiers friendly kills are possible\r\n// => use target instead\r\n\r\n// Social gameplay: Chat with people and Coordinate your shots \r\n// if you want to risk not getting shot by semi bullets first\r\n\r\n// you keep your bullets when you send in new soldiers\r\n\r\n// if your soldier dies your address is added to the back of the refund line\r\n// to get back your initial eth\r\n\r\n// payout structure per 0.1 eth:\r\n// 0.005 eth buy P3D\r\n// 0.005 eth goes to the refund line\r\n// 0.001 eth goes dev cut shared across SPASM(Spielleys profit share aloocation module)\r\n// 0.001 eth goes to referal\r\n// 0.088 eth is given to survivors upon kill\r\n\r\n// P3D divs: \r\n// 1% to SPASM\r\n// 99% to refund line\r\n\r\n// SPASM: get a part of the dev fee payouts and funds Spielley to go fulltime dev\r\n// https://etherscan.io/address/0xfaae60f2ce6491886c9f7c9356bd92f688ca66a1#writeContract\r\n// => buyshares function , send in eth to get shares\r\n\r\n// P3D MN payouts for UI devs\r\n// payout per 0.1 eth sent in the sendInSoldier function\r\n\r\n// **to prevent exploit spot 0 can be targeted by chosing nextFormation number**\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\r\n       \r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n// Snip3d contract\r\ncontract Snip3D is  Owned {\r\n    using SafeMath for uint;\r\n    uint public _totalSupply;\r\n\r\n    mapping(address => uint256)public  balances;// soldiers on field\r\n    mapping(address => uint256)public  bullets;// amount of bullets Owned\r\n    mapping(address => uint256)public  playerVault;// amount of bullets Owned\r\n    mapping(uint256 => address)public  formation;// the playing field\r\n    uint256 public nextFormation;// next spot in formation\r\n    mapping(address => uint256)public lastMove;//blocknumber lastMove\r\n    mapping(uint256 => address) public RefundWaitingLine;\r\n    uint256 public  NextInLine;//next person to be refunded\r\n    uint256 public  NextAtLineEnd;//next spot to add loser\r\n    uint256 public Refundpot;\r\n    uint256 public blocksBeforeSemiRandomShoot = 200;\r\n    uint256 public blocksBeforeTargetShoot = 800;\r\n    uint256 public NextInLineOld;\r\n    uint256 public lastToPayOld;\r\n    \r\n    // events\r\n    event death(address indexed player , uint256 indexed formation);\r\n    event semiShot(address indexed player);\r\n    event targetShot(address indexed player);\r\n    event newSoldiers(address indexed player , uint256 indexed amount, uint256 indexed formation);\r\n    //constructor\r\n    constructor()\r\n        public\r\n    {\r\n        NextInLineOld = old.NextInLine();\r\n        lastToPayOld = 2784;\r\n        \r\n    }\r\n    //mods\r\n    modifier isAlive()\r\n    {\r\n        require(balances[msg.sender] > 0);\r\n        _;\r\n    }\r\n    // divfunctions\r\n    // interface setup\r\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\nSPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\r\nSnip3dInterface public old = Snip3dInterface(0x6D534b48835701312ebc904d4b37e54D4f7D039f);\r\n// view functions\r\nfunction harvestabledivs()\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return (P3Dcontract_.myDividends(true))  ;\r\n    }\r\n    function nextonetogetpaid()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        \r\n        return (RefundWaitingLine[NextInLine]);\r\n    }\r\n    function playervanity(address theplayer)\r\n        public\r\n        view\r\n        returns( string )\r\n    {\r\n        return (Vanity[theplayer]);\r\n    }\r\n    function blocksTillSemiShoot(address theplayer)\r\n        public\r\n        view\r\n        returns( uint256 )\r\n    {\r\n        uint256 number;\r\n        if(block.number - lastMove[theplayer] < blocksBeforeSemiRandomShoot)\r\n        {number = blocksBeforeSemiRandomShoot -(block.number - lastMove[theplayer]);}\r\n        return (number);\r\n    }\r\n    function blocksTillTargetShoot(address theplayer)\r\n        public\r\n        view\r\n        returns( uint256 )\r\n    {\r\n        uint256 number;\r\n        if(block.number - lastMove[theplayer] < blocksBeforeTargetShoot)\r\n        {number = blocksBeforeTargetShoot -(block.number - lastMove[theplayer]);}\r\n        return (number);\r\n    }\r\nfunction amountofp3d() external view returns(uint256){\r\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\r\n}\r\n    //divsection\r\nuint256 public pointMultiplier = 10e18;\r\nstruct Account {\r\n  uint balance;\r\n  uint lastDividendPoints;\r\n}\r\nmapping(address=>Account) accounts;\r\nmapping(address => string) public Vanity;\r\nuint public ethtotalSupply;\r\nuint public totalDividendPoints;\r\nuint public unclaimedDividends;\r\n\r\nfunction dividendsOwing(address account) public view returns(uint256) {\r\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\r\n  return (balances[account] * newDividendPoints) / pointMultiplier;\r\n}\r\nmodifier updateAccount(address account) {\r\n  uint256 owing = dividendsOwing(account);\r\n  if(owing > 0) {\r\n    unclaimedDividends = unclaimedDividends.sub(owing);\r\n    \r\n    playerVault[account] = playerVault[account].add(owing);\r\n  }\r\n  accounts[account].lastDividendPoints = totalDividendPoints;\r\n  _;\r\n}\r\nfunction () external payable{}\r\nfunction fetchdivs(address toupdate) public updateAccount(toupdate){}\r\n// Gamefunctions\r\nfunction sendInSoldier(address masternode, uint256 amount) public updateAccount(msg.sender)  payable{\r\n    uint256 value = msg.value;\r\n    require(value >=  amount.mul(100 finney));// sending in sol costs 0.1 eth\r\n    address sender = msg.sender;\r\n    // add life\r\n    balances[sender]=  balances[sender].add(amount);\r\n    // update totalSupply\r\n    _totalSupply= _totalSupply.add(amount);\r\n    // add 2 bullet per soldier\r\n    bullets[sender] = bullets[sender].add(amount).add(amount);\r\n    // add to playing field\r\n    for(uint i=0; i< amount; i++)\r\n        {\r\n            uint256 spot = nextFormation.add(i);\r\n            formation[spot] = sender;\r\n        }\r\n    nextFormation += i;\r\n    // reset lastMove to prevent people from adding bullets and start shooting\r\n    lastMove[sender] = block.number;\r\n    // buy P3D\r\n    uint256 buyamount = amount.mul( 5 finney);\r\n    P3Dcontract_.buy.value(buyamount)(masternode);\r\n    // check excess of payed \r\n     if(value > amount.mul(100 finney)){Refundpot += value.sub(amount.mul(100 finney)) ;}\r\n    // progress refundline\r\n    Refundpot += amount.mul(5 finney);\r\n    // send SPASM cut\r\n    uint256 spasmamount = amount.mul(2 finney);\r\n    SPASM_.disburse.value(spasmamount)();\r\n    emit newSoldiers(sender, amount, nextFormation);\r\n\r\n}\r\nfunction sendInSoldierReferal(address masternode, address referal, uint256 amount) public updateAccount(msg.sender)  payable{\r\n    uint256 value = msg.value;\r\n    require(value >=  amount.mul(100 finney));// sending in sol costs 0.1 eth\r\n    address sender = msg.sender;\r\n   // add life\r\n    balances[sender]=  balances[sender].add(amount);\r\n    // update totalSupply\r\n    _totalSupply= _totalSupply.add(amount);\r\n    // add 2 bullet per soldier\r\n    bullets[sender] = bullets[sender].add(amount).add(amount);\r\n    // add to playing field\r\n    for(uint i=0; i< amount; i++)\r\n        {\r\n            uint256 spot = nextFormation.add(i);\r\n            formation[spot] = sender;\r\n        }\r\n    nextFormation += i;\r\n    // reset lastMove to prevent people from adding bullets and start shooting\r\n    lastMove[sender] = block.number;\r\n    // buy P3D\r\n    uint256 buyamount = amount.mul( 5 finney);\r\n    P3Dcontract_.buy.value(buyamount)(masternode);\r\n    // check excess of payed \r\n     if(value > amount.mul(100 finney)){Refundpot += value.sub(amount.mul(100 finney)) ;}\r\n    // progress refundline\r\n    Refundpot += amount.mul(5 finney);\r\n    // send SPASM cut\r\n    uint256 spasmamount = amount.mul(1 finney);\r\n    SPASM_.disburse.value(spasmamount)();\r\n    // send referal cut\r\n    playerVault[referal] = playerVault[referal].add(amount.mul(1 finney));\r\n    emit newSoldiers(sender, amount, nextFormation);\r\n\r\n}\r\nfunction shootSemiRandom() public isAlive() {\r\n    address sender = msg.sender;\r\n    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\r\n    require(bullets[sender] > 0);\r\n    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\r\n    \r\n    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\r\n    address killed = formation[shot];\r\n    // solo soldiers self kill prevention - shoots next in line instead\r\n    if(sender == killed)\r\n    {\r\n        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\r\n        killed = formation[shot];\r\n    }\r\n    // update divs loser\r\n    fetchdivs(killed);\r\n    // remove life\r\n    balances[killed]--;\r\n    // update totalSupply\r\n    _totalSupply--;\r\n    // remove bullet \r\n    bullets[sender]--;\r\n    // remove from playing field\r\n    uint256 lastEntry = nextFormation.sub(1);\r\n    formation[shot] = formation[lastEntry];\r\n    nextFormation--;\r\n    // reset lastMove to prevent people from adding bullets and start shooting\r\n    lastMove[sender] = block.number;\r\n    \r\n    \r\n    // add loser to refundline\r\n    fetchdivsRefund(killed);\r\n    balancesRefund[killed] += 0.1 ether;\r\n   \r\n    // disburse eth to survivors\r\n    uint256 amount = 88 finney;\r\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\r\n    unclaimedDividends = unclaimedDividends.add(amount);\r\n    emit semiShot(sender);\r\n    emit death(killed, shot);\r\n\r\n}\r\nfunction shootTarget(uint256 target) public isAlive() {\r\n    address sender = msg.sender;\r\n    require(target <= nextFormation && target > 0);\r\n    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\r\n    require(bullets[sender] > 0);\r\n    if(target == nextFormation){target = 0;}\r\n    address killed = formation[target];\r\n    \r\n    // update divs loser\r\n    fetchdivs(killed);\r\n    \r\n    // remove life\r\n    balances[killed]--;\r\n    // update totalSupply\r\n    _totalSupply--;\r\n    // remove bullet \r\n    bullets[sender]--;\r\n    // remove from playing field\r\n    uint256 lastEntry = nextFormation.sub(1);\r\n    formation[target] = formation[lastEntry];\r\n    nextFormation--;\r\n    // reset lastMove to prevent people from adding bullets and start shooting\r\n    lastMove[sender] = block.number;\r\n    \r\n    // add loser to refundline\r\n    fetchdivsRefund(killed);\r\n    balancesRefund[killed] += 0.1 ether;\r\n    // fetch contracts divs\r\n    \r\n    // disburse eth to survivors\r\n    uint256 amount = 88 finney;\r\n    \r\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\r\n    unclaimedDividends = unclaimedDividends.add(amount);\r\n    emit targetShot(sender);\r\n    emit death(killed, target);\r\n}\r\nfunction Payoutnextrefund ()public\r\n    {\r\n         \r\n        require(Refundpot > 0.00001 ether);\r\n        uint256 amount = Refundpot;\r\n    Refundpot = 0;\r\n    totalDividendPointsRefund = totalDividendPointsRefund.add(amount.mul(pointMultiplier).div(_totalSupplyRefund));\r\n    unclaimedDividendsRefund = unclaimedDividendsRefund.add(amount);\r\n    }\r\n\r\nfunction disburse() public  payable {\r\n    uint256 amount = msg.value;\r\n    uint256 base = amount.div(100);\r\n    uint256 amt2 = amount.sub(base);\r\n  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\r\n unclaimedDividends = unclaimedDividends.add(amt2);\r\n \r\n}\r\nfunction vaultToWallet(address toPay) public {\r\n        require(playerVault[toPay] > 0);\r\n        uint256 value = playerVault[toPay];\r\n        playerVault[toPay] = 0;\r\n        toPay.transfer(value);\r\n    }\r\nfunction changevanity(string van) public payable{\r\n    require(msg.value >= 1  finney);\r\n    Vanity[msg.sender] = van;\r\n    Refundpot += msg.value;\r\n}\r\nfunction P3DDivstocontract() public{\r\n    uint256 divs = harvestabledivs();\r\n    require(divs > 0);\r\n \r\nP3Dcontract_.withdraw();\r\n    //1% to owner\r\n    uint256 base = divs.div(100);\r\n    uint256 amt2 = divs.sub(base);\r\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\r\n   Refundpot = Refundpot.add(amt2);// add divs to refund line\r\n   \r\n}\r\n\r\n// bugtest selfdestruct function - deactivate on live\r\n function die () public onlyOwner {\r\n     selfdestruct(msg.sender);\r\n }\r\n// 2nd div setup for refunds\r\n\r\n// legacystarting refunds from old contract\r\n    function legacyStart(uint256 amountProgress) onlyOwner public{\r\n        uint256 nextUp = NextInLineOld;\r\n        for(uint i=0; i< amountProgress; i++)\r\n        {\r\n        address torefund = old.RefundWaitingLine(nextUp + i);\r\n        i++;\r\n        balancesRefund[torefund] = balancesRefund[torefund].add(0.1 ether);\r\n        }\r\n        NextInLineOld += i;\r\n        _totalSupplyRefund = _totalSupplyRefund.add(i.mul(0.1 ether));\r\n    }\r\n\r\nmapping(address => uint256) public balancesRefund;\r\nuint256 public _totalSupplyRefund;\r\nmapping(address=>Account) public accountsRefund;\r\nuint public ethtotalSupplyRefund;\r\nuint public totalDividendPointsRefund;\r\nuint public unclaimedDividendsRefund;\r\n\r\nfunction dividendsOwingRefund(address account) public view returns(uint256) {\r\n  uint256 newDividendPointsRefund = totalDividendPointsRefund.sub(accountsRefund[account].lastDividendPoints);\r\n  return (balancesRefund[account] * newDividendPointsRefund) / pointMultiplier;\r\n}\r\nmodifier updateAccountRefund(address account) {\r\n  uint256 owing = dividendsOwingRefund(account);\r\n  if(owing > balancesRefund[account]){balancesRefund[account] = owing;}\r\n  if(owing > 0 ) {\r\n    unclaimedDividendsRefund = unclaimedDividendsRefund.sub(owing);\r\n    \r\n    playerVault[account] = playerVault[account].add(owing);\r\n    balancesRefund[account] = balancesRefund[account].sub(owing);\r\n    _totalSupplyRefund = _totalSupplyRefund.sub(owing);\r\n  }\r\n  accountsRefund[account].lastDividendPoints = totalDividendPointsRefund;\r\n  _;\r\n}\r\n//function () external payable{}\r\nfunction fetchdivsRefund(address toUpdate) public updateAccountRefund(toUpdate){}\r\n\r\nfunction disburseRefund() public  payable {\r\n    uint256 amount = msg.value;\r\n    \r\n  totalDividendPointsRefund = totalDividendPointsRefund.add(amount.mul(pointMultiplier).div(_totalSupplyRefund));\r\n  //ethtotalSupply = ethtotalSupply.add(amount);\r\n unclaimedDividendsRefund = unclaimedDividendsRefund.add(amount);\r\n}\r\n\r\n    //fetch P3D divs\r\n    function DivsToRefundpot ()public\r\n    {\r\n        //allocate p3d dividends to contract \r\n            uint256 dividends = P3Dcontract_.myDividends(true);\r\n            require(dividends > 0);\r\n            uint256 base = dividends.div(100);\r\n            P3Dcontract_.withdraw();\r\n            SPASM_.disburse.value(base.mul(5))();// to dev fee sharing contract SPASM\r\n            Refundpot = Refundpot.add(base.mul(95));\r\n    }\r\n    \r\n}\r\ninterface HourglassInterface  {\r\n    function() payable external;\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function sell(uint256 _amountOfTokens) external;\r\n    function reinvest() external;\r\n    function withdraw() external;\r\n    function exit() external;\r\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n    function dividendsOf(address _playerAddress) external view returns(uint256);\r\n    function balanceOf(address _playerAddress) external view returns(uint256);\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n    function stakingRequirement() external view returns(uint256);\r\n}\r\n\r\ninterface Snip3dInterface {\r\n    function RefundWaitingLine(uint256 index) external view returns(address);\r\n    function NextInLine() external view returns(uint256);\r\n    function NextAtLineEnd() external view returns(uint256);\r\n}\r\ninterface SPASMInterface  {\r\n    function() payable external;\r\n    function disburse() external  payable;\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balancesRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"RefundWaitingLine\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"P3DDivstocontract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"theplayer\",\"type\":\"address\"}],\"name\":\"blocksTillSemiShoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividendPoints\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupplyRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksBeforeTargetShoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toupdate\",\"type\":\"address\"}],\"name\":\"fetchdivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"die\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextAtLineEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastMove\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unclaimedDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unclaimedDividendsRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextFormation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextInLineOld\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"van\",\"type\":\"string\"}],\"name\":\"changevanity\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pointMultiplier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bullets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"uint256\"}],\"name\":\"shootTarget\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"harvestabledivs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"DivsToRefundpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendsOwing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Vanity\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountofp3d\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accountsRefund\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"lastDividendPoints\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"masternode\",\"type\":\"address\"},{\"name\":\"referal\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendInSoldierReferal\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"formation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NextInLine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethtotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksBeforeSemiRandomShoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disburse\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"shootSemiRandom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"dividendsOwingRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"old\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"masternode\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sendInSoldier\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Refundpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividendPointsRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toUpdate\",\"type\":\"address\"}],\"name\":\"fetchdivsRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"theplayer\",\"type\":\"address\"}],\"name\":\"blocksTillTargetShoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Payoutnextrefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toPay\",\"type\":\"address\"}],\"name\":\"vaultToWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"theplayer\",\"type\":\"address\"}],\"name\":\"playervanity\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountProgress\",\"type\":\"uint256\"}],\"name\":\"legacyStart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastToPayOld\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethtotalSupplyRefund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextonetogetpaid\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disburseRefund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"formation\",\"type\":\"uint256\"}],\"name\":\"death\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"semiShot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"targetShot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"formation\",\"type\":\"uint256\"}],\"name\":\"newSoldiers\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Snip3D","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://219db3d5737cc01c8e154305b26e3ed9316231f404ecfb3cd626c3ad269333b0"}]}