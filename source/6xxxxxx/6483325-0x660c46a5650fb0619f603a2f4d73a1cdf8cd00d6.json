{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * \r\n * ██████╗ ███████╗████████╗███████╗██████╗ ███╗   ██╗ █████╗ ██╗     \r\n * ██╔══██╗██╔════╝╚══██╔══╝██╔════╝██╔══██╗████╗  ██║██╔══██╗██║     \r\n * ██████╔╝█████╗     ██║   █████╗  ██████╔╝██╔██╗ ██║███████║██║   \r\n * ██╔══██╗██╔══╝     ██║   ██╔══╝  ██╔══██╗██║╚██╗██║██╔══██║██║     \r\n * ██║  ██║███████╗   ██║   ███████╗██║  ██║██║ ╚████║██║  ██║███████╗\r\n * ╚═╝  ╚═╝╚══════╝   ╚═╝   ╚══════╝╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚══════╝\r\n * \r\n *  Contacts:\r\n * \r\n *   -- t.me/Reternal\r\n *   -- https://www.reternal.net\r\n * \r\n * - GAIN PER 24 HOURS:\r\n * \r\n *     -- Individual balance < 1 Ether: 3.55%\r\n *     -- Individual balance >= 1 Ether: 3.65%\r\n *     -- Individual balance >= 4 Ether: 3.75%\r\n *     -- Individual balance >= 12 Ether: 3.85%\r\n *     -- Individual balance >= 50 Ether: 4%\r\n * \r\n *     -- Contract balance < 200 Ether: 0%\r\n *     -- Contract balance >= 200 Ether: 0.30%\r\n *     -- Contract balance >= 500 Ether: 0.40%\r\n *     -- Contract balance >= 900 Ether: 0.50%\r\n *     -- Contract balance >= 1500 Ether: 0.65%\r\n *     -- Contract balance >= 2000 Ether: 0.80%\r\n * \r\n *  - Minimal contribution 0.01 eth\r\n *  - Contribution allocation schemes:\r\n *    -- 95% payments\r\n *    -- 5% Marketing + Operating Expenses\r\n * \r\n * - How to use:\r\n *  1. Send from your personal ETH wallet to the smart-contract address any amount more than or equal to 0.01 ETH\r\n *  2. Add your refferer's wallet to a HEX data in your transaction to \r\n *     get a bonus amount back to your wallet only for the FIRST deposit\r\n *     IMPORTANT: if you want to support Reternal project, you can leave your HEX data field empty, \r\n *                if you have no referrer and do not want to support Reternal, you can type 'noreferrer'\r\n *                if there is no referrer, you will not get any bonuses\r\n *  3. Use etherscan.io to verify your transaction \r\n *  4. Claim your dividents by sending 0 ether transaction (available anytime)\r\n *  5. You can reinvest anytime you want\r\n *\r\n * RECOMMENDED GAS LIMIT: 200000\r\n * RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n * \r\n * The smart-contract has a \"restart\" function, more info at www.reternal.net\r\n * \r\n * If you want to check your dividents, you can use etherscan.io site, following the \"Internal Txns\" tab of your wallet\r\n * WARNING: do not use exchanges' wallets - you will loose your funds. Only use your personal wallet for transactions \r\n * \r\n */\r\n\r\ncontract Reternal {\r\n    \r\n    // Investor's data storage\r\n    mapping (address => Investor) public investors;\r\n    address[] public addresses;\r\n    \r\n    struct Investor\r\n    {\r\n        uint id;\r\n        uint deposit;\r\n        uint depositCount;\r\n        uint block;\r\n        address referrer;\r\n    }\r\n    \r\n    uint constant public MINIMUM_INVEST = 10000000000000000 wei;\r\n    address defaultReferrer = 0x25EDFd665C2898c2898E499Abd8428BaC616a0ED;\r\n    \r\n    uint public round;\r\n    uint public totalDepositAmount;\r\n    bool public pause;\r\n    uint public restartBlock;\r\n    bool ref_flag;\r\n    \r\n    // Investors' dividents increase goals due to a bank growth\r\n    uint bank1 = 200e18; // 200 eth\r\n    uint bank2 = 500e18; // 500 eth\r\n    uint bank3 = 900e18; // 900 eth\r\n    uint bank4 = 1500e18; // 1500 eth\r\n    uint bank5 = 2000e18; // 2000 eth\r\n    // Investors' dividents increase due to individual deposit amount\r\n    uint dep1 = 1e18; // 1 ETH\r\n    uint dep2 = 4e18; // 4 ETH\r\n    uint dep3 = 12e18; // 12 ETH\r\n    uint dep4 = 5e19; // 50 ETH\r\n    \r\n    event NewInvestor(address indexed investor, uint deposit, address referrer);\r\n    event PayOffDividends(address indexed investor, uint value);\r\n    event refPayout(address indexed investor, uint value, address referrer);\r\n    event NewDeposit(address indexed investor, uint value);\r\n    event NextRoundStarted(uint round, uint block, address addr, uint value);\r\n    \r\n    constructor() public {\r\n        addresses.length = 1;\r\n        round = 1;\r\n        pause = false;\r\n    }\r\n\r\n    function restart() private {\r\n        address addr;\r\n\r\n        for (uint i = addresses.length - 1; i > 0; i--) {\r\n            addr = addresses[i];\r\n            addresses.length -= 1;\r\n            delete investors[addr];\r\n        }\r\n        \r\n        emit NextRoundStarted(round, block.number, msg.sender, msg.value);\r\n        pause = false;\r\n        round += 1;\r\n        totalDepositAmount = 0;\r\n        \r\n        createDeposit();\r\n    }\r\n\r\n    function getRaisedPercents(address addr) internal view  returns(uint){\r\n        // Individual deposit percentage sums up with 'Reternal total fund' percentage\r\n        uint percent = getIndividualPercent() + getBankPercent();\r\n        uint256 amount = investors[addr].deposit * percent / 100*(block.number-investors[addr].block)/6000;\r\n        return(amount / 100);\r\n    }\r\n    \r\n    function payDividends() private{\r\n        require(investors[msg.sender].id > 0, \"Investor not found.\");\r\n        // Investor's total raised amount\r\n        uint amount = getRaisedPercents(msg.sender);\r\n            \r\n        if (address(this).balance < amount) {\r\n            pause = true;\r\n            restartBlock = block.number + 6000;\r\n            return;\r\n        }\r\n        \r\n        // Service fee deduction \r\n        uint FeeToWithdraw = amount * 5 / 100;\r\n        uint payment = amount - FeeToWithdraw;\r\n        \r\n        address(0xD9bE11E7412584368546b1CaE64b6C384AE85ebB).transfer(FeeToWithdraw);\r\n        msg.sender.transfer(payment);\r\n        emit PayOffDividends(msg.sender, amount);\r\n        \r\n    }\r\n    \r\n    function createDeposit() private{\r\n        Investor storage user = investors[msg.sender];\r\n        \r\n        if (user.id == 0) {\r\n            \r\n            // Check for malicious smart-contract\r\n            msg.sender.transfer(0 wei);\r\n            user.id = addresses.push(msg.sender);\r\n\r\n            if (msg.data.length != 0) {\r\n                address referrer = bytesToAddress(msg.data);\r\n                \r\n                // Check for referrer's registration. Check for self referring\r\n                if (investors[referrer].id > 0 && referrer != msg.sender) {\r\n                    user.referrer = referrer;\r\n                    \r\n                    // Cashback only for the first deposit\r\n                    if (user.depositCount == 0) {\r\n                        uint cashback = msg.value / 100;\r\n                        if (msg.sender.send(cashback)) {\r\n                            emit refPayout(msg.sender, cashback, referrer);\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                // If data is empty:\r\n                user.referrer = defaultReferrer;\r\n            }\r\n            \r\n            emit NewInvestor(msg.sender, msg.value, referrer);\r\n            \r\n        } else {\r\n            // Dividents payment for an investor\r\n            payDividends();\r\n        }\r\n        \r\n        // 2% from a referral deposit transfer to a referrer \r\n        uint payReferrer = msg.value * 2 / 100; \r\n        \r\n        if (user.referrer == defaultReferrer) {\r\n            user.referrer.transfer(payReferrer);\r\n        } else {\r\n            investors[referrer].deposit += payReferrer;\r\n        }\r\n        \r\n        \r\n        user.depositCount++;\r\n        user.deposit += msg.value;\r\n        user.block = block.number;\r\n        totalDepositAmount += msg.value;\r\n        emit NewDeposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function() external payable {\r\n        if(pause) {\r\n            if (restartBlock <= block.number) { restart(); }\r\n            require(!pause, \"Eternal is restarting, wait for the block in restartBlock\");\r\n        } else {\r\n            if (msg.value == 0) {\r\n                payDividends();\r\n                return;\r\n            }\r\n            require(msg.value >= MINIMUM_INVEST, \"Too small amount, minimum 0.01 ether\");\r\n            createDeposit();\r\n        }\r\n    }\r\n    \r\n    function getBankPercent() public view returns(uint){\r\n        \r\n        uint contractBalance = address(this).balance;\r\n        \r\n        uint totalBank1 = bank1;\r\n        uint totalBank2 = bank2;\r\n        uint totalBank3 = bank3;\r\n        uint totalBank4 = bank4;\r\n        uint totalBank5 = bank5;\r\n        \r\n        if(contractBalance < totalBank1){\r\n            return(0);\r\n        }\r\n        if(contractBalance >= totalBank1 && contractBalance < totalBank2){\r\n            return(30);\r\n        }\r\n        if(contractBalance >= totalBank2 && contractBalance < totalBank3){\r\n            return(40);\r\n        }\r\n        if(contractBalance >= totalBank3 && contractBalance < totalBank4){\r\n            return(50);\r\n        }\r\n        if(contractBalance >= totalBank4 && contractBalance < totalBank5){\r\n            return(65);\r\n        }\r\n        if(contractBalance >= totalBank5){\r\n            return(80);\r\n        }\r\n    }\r\n\r\n    function getIndividualPercent() public view returns(uint){\r\n        \r\n        uint userBalance = investors[msg.sender].deposit;\r\n        \r\n        uint totalDeposit1 = dep1;\r\n        uint totalDeposit2 = dep2;\r\n        uint totalDeposit3 = dep3;\r\n        uint totalDeposit4 = dep4;\r\n        \r\n        if(userBalance < totalDeposit1){\r\n            return(355);\r\n        }\r\n        if(userBalance >= totalDeposit1 && userBalance < totalDeposit2){\r\n            return(365);\r\n        }\r\n        if(userBalance >= totalDeposit2 && userBalance < totalDeposit3){\r\n            return(375);\r\n        }\r\n        if(userBalance >= totalDeposit3 && userBalance < totalDeposit4){\r\n            return(385); \r\n        }\r\n        if(userBalance >= totalDeposit4){\r\n            return(400);\r\n        }\r\n    }\r\n    \r\n    function getInvestorCount() public view returns (uint) {\r\n        return addresses.length - 1;\r\n    }\r\n    \r\n    function bytesToAddress(bytes bys) private pure returns (address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_INVEST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getIndividualPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"depositCount\",\"type\":\"uint256\"},{\"name\":\"block\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"restartBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDepositAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBankPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"NewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PayOffDividends\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"refPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NextRoundStarted\",\"type\":\"event\"}]","ContractName":"Reternal","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://dc98771c806b03466b77ecd1ab07e3418f09073df1bf4268ece3e43b6af15314"}]}