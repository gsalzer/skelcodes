{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n//\"0x64C222d300d5f978D9867fA20C5C59b6B2c849aF\",\"9F86D081884C7D659A2FEAA0C55AD015A3BF4F1B2B0B822CD15D6C15B0F00A08\",\"1\",\"0\"\r\ncontract CertiMe {\r\n    // Defines a new type with two fields.\r\n    struct Certificate {\r\n        string certHash;\r\n        address issuer_addr;\r\n        address recepient_addr;\r\n        string version;\r\n        string content;\r\n    }\r\n\r\n    uint numCerts;\r\n    mapping (uint => Certificate) public certificates;\r\n    mapping (string => Certificate) certHashKey;\r\n\r\n    function newCertificate(address beneficiary, string certHash, string version, string content ) public returns (uint certID) {\r\n        certID = ++numCerts; // campaignID is return variable\r\n        // Creates new struct and saves in storage. We leave out the mapping type.\r\n        certificates[certID] = Certificate(certHash,msg.sender,beneficiary, version,content);\r\n        certHashKey[certHash]=certificates[certID];\r\n    }\r\n/*\r\n    function contribute(uint campaignID) public payable {\r\n        Campaign storage c = campaigns[campaignID];\r\n        // Creates a new temporary memory struct, initialised with the given values\r\n        // and copies it over to storage.\r\n        // Note that you can also use Funder(msg.sender, msg.value) to initialise.\r\n        c.funders[c.numFunders++] = CertIssuer({addr: msg.sender, amount: msg.value});\r\n        c.amount += msg.value;\r\n    }\r\n*/\r\n  /*  \r\n    function certHashExist(string value) constant returns (uint) {\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(stringsEqual(certificates[i].certHash,value)){\r\n                return i;\r\n              }\r\n        }\r\n        \r\n        return 0;\r\n    }*/\r\n    function getMatchCountAddress(uint addr_type,address value) public constant returns (uint){\r\n        uint counter = 0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if((addr_type==0&&certificates[i].issuer_addr==value)||(addr_type==1&&certificates[i].recepient_addr==value)){\r\n                counter++;\r\n              }\r\n        }        \r\n        return counter;\r\n    }\r\n    function getCertsByIssuer(address value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountAddress(0,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(certificates[i].issuer_addr==value){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }\r\n    function getCertsByRecepient(address value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountAddress(1,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(certificates[i].recepient_addr==value){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }   \r\n\r\n    function getMatchCountString(uint string_type,string value) public constant returns (uint){\r\n        uint counter = 0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(string_type==0){\r\n                if(stringsEqual(certificates[i].certHash,value)){\r\n                    counter++;\r\n                }\r\n              }\r\n              if(string_type==1){\r\n                if(stringsEqual(certificates[i].version,value)){\r\n                    counter++;\r\n                }\r\n              }\r\n              if(string_type==2){\r\n                if(stringsEqual(certificates[i].content,value)){\r\n                    counter++;\r\n                }\r\n              }\r\n        }        \r\n        return counter;\r\n    }\r\n    \r\n    function getCertsByProof(string value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountString(0,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(stringsEqual(certificates[i].certHash,value)){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }    \r\n    function getCertsByVersion(string value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountString(1,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(stringsEqual(certificates[i].version,value)){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }\r\n    function getCertsByContent(string value) public constant returns (uint[]) {\r\n        uint256[] memory matches=new uint[](getMatchCountString(2,value));\r\n        uint matchCount=0;\r\n        for (uint i=1; i<numCerts+1; i++) {\r\n              if(stringsEqual(certificates[i].content,value)){\r\n                matches[matchCount++]=i;\r\n              }\r\n        }\r\n        \r\n        return matches;\r\n    }\r\n    \r\n/*    function getCertIssuer(string key) constant returns (address,address,string,string) {\r\n         return (certHashKey[key].issuer_addr,certHashKey[key].recepient_addr,certHashKey[key].version,certHashKey[key].content);\r\n    }\r\n*/\r\n    \r\n\tfunction stringsEqual(string storage _a, string memory _b) internal constant returns (bool) {\r\n\t\tbytes storage a = bytes(_a);\r\n\t\tbytes memory b = bytes(_b);\r\n\t\tif (a.length != b.length)\r\n\t\t\treturn false;\r\n\t\t// @todo unroll this loop\r\n\t\tfor (uint i = 0; i < a.length; i ++)\r\n\t\t\tif (a[i] != b[i])\r\n\t\t\t\treturn false;\r\n\t\treturn true;\r\n\t}    \r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"getCertsByContent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"getCertsByProof\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"certHash\",\"type\":\"string\"},{\"name\":\"version\",\"type\":\"string\"},{\"name\":\"content\",\"type\":\"string\"}],\"name\":\"newCertificate\",\"outputs\":[{\"name\":\"certID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"certificates\",\"outputs\":[{\"name\":\"certHash\",\"type\":\"string\"},{\"name\":\"issuer_addr\",\"type\":\"address\"},{\"name\":\"recepient_addr\",\"type\":\"address\"},{\"name\":\"version\",\"type\":\"string\"},{\"name\":\"content\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"string_type\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"getMatchCountString\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"getCertsByIssuer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"string\"}],\"name\":\"getCertsByVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"getCertsByRecepient\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr_type\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"address\"}],\"name\":\"getMatchCountAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"CertiMe","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7091c8db39f66f3157a57e1803970f85c1b13c52a7513131681f8395806eea19"}]}