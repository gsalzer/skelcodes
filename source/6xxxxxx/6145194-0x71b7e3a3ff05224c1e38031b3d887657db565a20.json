{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n    function max64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal constant returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal constant returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * Safe unsigned safe math.\r\n *\r\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\n *\r\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\r\n *\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\n *\r\n */\r\nlibrary SafeMathLibExt {\r\n\r\n    function times(uint a, uint b) returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function divides(uint a, uint b) returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function minus(uint a, uint b) returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function plus(uint a, uint b) returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract Destructable is Ownable {\r\n\r\n    function burn() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract TokensContract {\r\n    function balanceOf(address who) public constant returns (uint256);\r\n    function transferFrom(address _from, address _to, uint _value) returns (bool success);\r\n    function approve(address _spender, uint _value) returns (bool success);\r\n}\r\n\r\ncontract Insurance is Destructable, SafeMath  {\r\n\r\n    uint startClaimDate;\r\n    uint endClaimDate;\r\n    uint rewardWeiCoefficient;\r\n    uint256 buyPrice;\r\n    address tokensContractAddress;\r\n    uint256 ichnDecimals;\r\n\r\n    mapping (address => uint256) buyersBalances;\r\n\r\n    struct ClientInsurance {\r\n        uint256 tokensCount;\r\n        bool isApplied;\r\n        bool exists;\r\n        bool isBlocked;\r\n    }\r\n\r\n\r\n    mapping(address => ClientInsurance) insurancesMap;\r\n\r\n\r\n    function Insurance() public {\r\n        /* I-CHAIN.NET (ICHN) ERC20 token */\r\n        tokensContractAddress = 0x3ab7b695573017eeBD6377c433F9Cf3eF5B4cd48;\r\n\r\n        /* UTC, 31 dec 2020 00:00 - 2 feb 2021 00:00 */\r\n        startClaimDate = 1609372800;\r\n        endClaimDate = 1612224000;\r\n\r\n\r\n        /* 0.1 ether */\r\n        rewardWeiCoefficient = 100000000000000000;\r\n\r\n        /* 0.05 ether */\r\n        buyPrice = 50000000000000000;\r\n\r\n        /* ICHN Token Decimals is 18 */\r\n        ichnDecimals = 1000000000000000000;\r\n    }\r\n\r\n    /**\r\n     * Don't expect to just send money by anyone except the owner\r\n     */\r\n    function () public payable {\r\n        throw;\r\n    }\r\n\r\n    /**\r\n     * Owner can add ETH to contract\r\n     */\r\n    function addEth() public payable onlyOwner {\r\n    }\r\n    \r\n    /**\r\n     * Owner can transfer ETH from contract to address\r\n     * Amount - 18 decimals\r\n     */\r\n    function transferEthTo(address to, uint256 amount) public payable onlyOwner {\r\n        require(address(this).balance > amount);\r\n        to.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * Basic entry point for buy insurance\r\n     */\r\n    function buy() public payable {\r\n        /* Can be called only once for address */\r\n        require(buyersBalances[msg.sender] == 0);\r\n\r\n        /* Checking price */\r\n        require(msg.value == buyPrice);\r\n\r\n        /* At least one token */\r\n        require(hasTokens(msg.sender));\r\n\r\n        /* Remember payment */\r\n        buyersBalances[msg.sender] = safeAdd(buyersBalances[msg.sender], msg.value);\r\n    }\r\n\r\n    function isClient(address clientAddress) public constant onlyOwner returns(bool) {\r\n        return insurancesMap[clientAddress].exists;\r\n    }\r\n\r\n    function addBuyer(address clientAddress, uint256 tokensCount) public onlyOwner {\r\n        require( (clientAddress != address(0)) && (tokensCount > 0) );\r\n\r\n        /* Checking payment */\r\n        require(buyersBalances[clientAddress] == buyPrice);\r\n\r\n        /* Can be called only once for address */\r\n        require(!insurancesMap[clientAddress].exists);\r\n\r\n        /* Checking the current number of tokens */\r\n        require(getTokensCount(clientAddress) >= tokensCount);\r\n\r\n        insurancesMap[clientAddress] = ClientInsurance(tokensCount, false, true, false);\r\n    }\r\n\r\n    function claim(address to, uint256 returnedTokensCount) public onlyOwner {\r\n        /* Can be called only on time range */\r\n        require(now > startClaimDate && now < endClaimDate);\r\n\r\n        /* Can be called once for address */\r\n        require( (to != address(0)) && (insurancesMap[to].exists) && (!insurancesMap[to].isApplied) && (!insurancesMap[to].isBlocked) );\r\n\r\n        /* Tokens returned */\r\n        require(returnedTokensCount >= insurancesMap[to].tokensCount);\r\n\r\n        /* Start transfer */\r\n        uint amount = getRewardWei(to);\r\n\r\n        require(address(this).balance > amount);\r\n        insurancesMap[to].isApplied = true;\r\n\r\n        to.transfer(amount);\r\n    }\r\n\r\n    function blockClient(address clientAddress) public onlyOwner {\r\n        insurancesMap[clientAddress].isBlocked = true;\r\n    }\r\n\r\n    function unblockClient(address clientAddress) public onlyOwner {\r\n        insurancesMap[clientAddress].isBlocked = false;\r\n    }\r\n\r\n    function isClientBlocked(address clientAddress) public constant onlyOwner returns(bool) {\r\n        return insurancesMap[clientAddress].isBlocked;\r\n    }\r\n\r\n    /**\r\n     * Sets buy price for insurance\r\n     */\r\n    function setBuyPrice(uint256 priceWei) public onlyOwner {\r\n        buyPrice = priceWei;\r\n    }\r\n\r\n    /**\r\n     * Sets tokens contract address from which check balance of tokens\r\n     */\r\n    function setTokensContractAddress(address contractAddress) public onlyOwner {\r\n        tokensContractAddress = contractAddress;\r\n    }\r\n\r\n    /**\r\n     * Returns address of tokens contract from which check balance of tokens\r\n     */\r\n    function getTokensContractAddress() public constant onlyOwner returns(address) {\r\n        return tokensContractAddress;\r\n    }\r\n\r\n    function getRewardWei(address clientAddress) private constant returns (uint256) {\r\n        uint tokensCount = insurancesMap[clientAddress].tokensCount;\r\n        return safeMul(tokensCount, rewardWeiCoefficient);\r\n    }\r\n\r\n    function hasTokens(address clientAddress) private constant returns (bool) {\r\n        return getTokensCount(clientAddress) > 0;\r\n    }\r\n\r\n    function getTokensCount(address clientAddress) private constant returns (uint256) {\r\n        TokensContract tokensContract = TokensContract(tokensContractAddress);\r\n\r\n        uint256 tcBalance = tokensContract.balanceOf(clientAddress);\r\n\r\n        return safeDiv(tcBalance, ichnDecimals);\r\n    }\r\n    \r\n    /**\r\n     * Transfer ERC20 tokens from contract to address\r\n     * tokensAmount - 18 decimals\r\n     */\r\n    function transferTokensTo(address to, uint256 tokensAmount) public onlyOwner {\r\n       TokensContract tokensContract = TokensContract(tokensContractAddress);\r\n       tokensContract.approve(address(this), tokensAmount);\r\n       tokensContract.transferFrom(address(this), to, tokensAmount);\r\n    }\r\n    \r\n    function getStartClaimDate() public constant onlyOwner returns(uint) {\r\n        return startClaimDate;\r\n    }\r\n    \r\n    function getEndClaimDate() public constant onlyOwner returns(uint) {\r\n        return endClaimDate;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"clientAddress\",\"type\":\"address\"}],\"name\":\"isClientBlocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"clientAddress\",\"type\":\"address\"}],\"name\":\"unblockClient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"clientAddress\",\"type\":\"address\"},{\"name\":\"tokensCount\",\"type\":\"uint256\"}],\"name\":\"addBuyer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokensAmount\",\"type\":\"uint256\"}],\"name\":\"transferTokensTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEndClaimDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"clientAddress\",\"type\":\"address\"}],\"name\":\"blockClient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"priceWei\",\"type\":\"uint256\"}],\"name\":\"setBuyPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"clientAddress\",\"type\":\"address\"}],\"name\":\"isClient\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartClaimDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"setTokensContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"returnedTokensCount\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferEthTo\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokensContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Insurance","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7caf697fd343c6fea601e74d9054f24e43e0ed62eeca912d7d01feb4917ea1ca"}]}