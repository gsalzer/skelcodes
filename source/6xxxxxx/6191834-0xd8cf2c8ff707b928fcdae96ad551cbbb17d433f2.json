{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath from zeppelin-solidity\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title PNS - Physical Form of CryptoCurrency Name System\r\n * @dev Physical form cryptocurrency name system smart contract is implemented \r\n * to manage and record physical form cryptocurrency manufacturers' \r\n * informations, such as the name of the manufacturer, the public key \r\n * of the key pair whose private key signed the certificate of the physical \r\n * form cryptocurrency, etc.\r\n * \r\n * @author Hui Xie - <hui.742369@gmail.com>\r\n */\r\ncontract PNS {\r\n\r\n    using SafeMath for uint256; \r\n\r\n    // Event of register\r\n    event Register(address indexed _from, string _mfr, bytes32 _mid);\r\n\r\n    // Event of transfer ownership\r\n    event Transfer(address indexed _from, string _mfr, bytes32 _mid, address _owner);\r\n\r\n    // Event of push a new batch\r\n    event Push(address indexed _from, string _mfr, bytes32 _mid, string _bn, bytes32 _bid, bytes _key);\r\n\r\n    // Event of set batch number\r\n    event SetBn(address indexed _from, string _mfr, bytes32 _mid, string _bn, bytes32 _bid, bytes _key);\r\n\r\n    // Event of set public key\r\n    event SetKey(address indexed _from, string _mfr, bytes32 _mid, string _bn, bytes32 _bid, bytes _key);\r\n\r\n    // Event of lock a batch\r\n    event Lock(address indexed _from, string _mfr, bytes32 _mid, string _bn, bytes32 _bid, bytes _key);\r\n\r\n    // Manufacturer informations\r\n    struct Manufacturer {\r\n        address owner; // owner address\r\n        string mfr; // manufacturer name\r\n        mapping (bytes32 => Batch) batchmapping; // mapping of batch: mapping (batch ID => batch structure)\r\n        mapping (uint256 => bytes32) bidmapping; // mapping of batch ID: mapping (storage index => batch ID), batch ID = keccak256(batch number)\r\n        uint256 bidcounter; // storage index counter of bidmapping\r\n    }\r\n\r\n    // Product batch informations\r\n    struct Batch {\r\n        string bn; // batch number\r\n        bytes key; // public key\r\n        bool lock; // is changeable or not\r\n    }\r\n\r\n    // Mapping of manufactures: mapping (manufacturer ID => manufacturer struct), Manufacturer ID = keccak256(uppercaseOf(manufacturer name))\r\n    mapping (bytes32 => Manufacturer) internal mfrmapping;\r\n\r\n    // Mapping of manufacturer ID: mapping (storage index => manufacturer ID)\r\n    mapping (uint256 => bytes32) internal midmapping;\r\n\r\n    // Storage index counter of midmapping\r\n    uint256 internal midcounter;\r\n    \r\n    /**\r\n     * @dev Register a manufacturer.\r\n     * \r\n     * @param _mfr Manufacturer name\r\n     * @return Manufacturer ID\r\n     */\r\n    function register(string _mfr) public returns (bytes32) {\r\n        require(lengthOf(_mfr) > 0);\r\n        require(msg.sender != address(0));\r\n\r\n        bytes32 mid = keccak256(bytes(uppercaseOf(_mfr)));\r\n        require(mfrmapping[mid].owner == address(0));\r\n\r\n        midcounter = midcounter.add(1);\r\n        midmapping[midcounter] = mid;\r\n\r\n        mfrmapping[mid].owner = msg.sender;\r\n        mfrmapping[mid].mfr = _mfr;\r\n        \r\n        emit Register(msg.sender, _mfr, mid);\r\n\r\n        return mid;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer ownership of a manufacturer.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _owner Address of new owner\r\n     * @return Batch ID\r\n     */\r\n    function transfer(bytes32 _mid, address _owner) public returns (bytes32) {\r\n        require(_mid != bytes32(0));\r\n        require(_owner != address(0));\r\n\r\n        require(mfrmapping[_mid].owner != address(0));\r\n        require(msg.sender == mfrmapping[_mid].owner);\r\n\r\n        mfrmapping[_mid].owner = _owner;\r\n\r\n        emit Transfer(msg.sender, mfrmapping[_mid].mfr, _mid, _owner);\r\n\r\n        return _mid;\r\n    }\r\n    \r\n    /**\r\n     * @dev Push(add) a batch.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _bn Batch number\r\n     * @param _key Public key\r\n     * @return Batch ID\r\n     */\r\n    function push(bytes32 _mid, string _bn, bytes _key) public returns (bytes32) {\r\n        require(_mid != bytes32(0));\r\n        require(lengthOf(_bn) > 0);\r\n        require(_key.length == 33 || _key.length == 65);\r\n\r\n        require(mfrmapping[_mid].owner != address(0));\r\n        require(msg.sender == mfrmapping[_mid].owner);\r\n\r\n        bytes32 bid = keccak256(bytes(_bn));\r\n        require(lengthOf(mfrmapping[_mid].batchmapping[bid].bn) == 0);\r\n        require(mfrmapping[_mid].batchmapping[bid].key.length == 0);\r\n        require(mfrmapping[_mid].batchmapping[bid].lock == false);\r\n\r\n        mfrmapping[_mid].bidcounter = mfrmapping[_mid].bidcounter.add(1);\r\n        mfrmapping[_mid].bidmapping[mfrmapping[_mid].bidcounter] = bid;\r\n        mfrmapping[_mid].batchmapping[bid].bn = _bn;\r\n        mfrmapping[_mid].batchmapping[bid].key = _key;\r\n        mfrmapping[_mid].batchmapping[bid].lock = false;\r\n\r\n        emit Push(msg.sender, mfrmapping[_mid].mfr, _mid, _bn, bid, _key);\r\n\r\n        return bid;\r\n    }\r\n\r\n    /**\r\n     * @dev Set(change) batch number of an unlocked batch.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _bid Batch ID\r\n     * @param _bn Batch number\r\n     * @return Batch ID\r\n     */\r\n    function setBn(bytes32 _mid, bytes32 _bid, string _bn) public returns (bytes32) {\r\n        require(_mid != bytes32(0));\r\n        require(_bid != bytes32(0));\r\n        require(lengthOf(_bn) > 0);\r\n\r\n        require(mfrmapping[_mid].owner != address(0));\r\n        require(msg.sender == mfrmapping[_mid].owner);\r\n\r\n        bytes32 bid = keccak256(bytes(_bn));\r\n        require(bid != _bid);\r\n        require(lengthOf(mfrmapping[_mid].batchmapping[_bid].bn) > 0);\r\n        require(mfrmapping[_mid].batchmapping[_bid].key.length > 0);\r\n        require(mfrmapping[_mid].batchmapping[_bid].lock == false);\r\n        require(lengthOf(mfrmapping[_mid].batchmapping[bid].bn) == 0);\r\n        require(mfrmapping[_mid].batchmapping[bid].key.length == 0);\r\n        require(mfrmapping[_mid].batchmapping[bid].lock == false);\r\n\r\n        uint256 counter = 0;\r\n        for (uint256 i = 1; i <= mfrmapping[_mid].bidcounter; i++) {\r\n            if (mfrmapping[_mid].bidmapping[i] == _bid) {\r\n                counter = i;\r\n                break;\r\n            }\r\n        }\r\n        require(counter > 0);\r\n\r\n        mfrmapping[_mid].bidmapping[counter] = bid;\r\n        mfrmapping[_mid].batchmapping[bid].bn = _bn;\r\n        mfrmapping[_mid].batchmapping[bid].key = mfrmapping[_mid].batchmapping[_bid].key;\r\n        mfrmapping[_mid].batchmapping[bid].lock = false;\r\n        delete mfrmapping[_mid].batchmapping[_bid];\r\n\r\n        emit SetBn(msg.sender, mfrmapping[_mid].mfr, _mid, _bn, bid, mfrmapping[_mid].batchmapping[bid].key);\r\n\r\n        return bid;\r\n    }\r\n\r\n    /**\r\n     * @dev Set(change) public key of an unlocked batch.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _bid Batch ID\r\n     * @param _key Public key\r\n     * @return Batch ID\r\n     */\r\n    function setKey(bytes32 _mid, bytes32 _bid, bytes _key) public returns (bytes32) {\r\n        require(_mid != bytes32(0));\r\n        require(_bid != bytes32(0));\r\n        require(_key.length == 33 || _key.length == 65);\r\n\r\n        require(mfrmapping[_mid].owner != address(0));\r\n        require(msg.sender == mfrmapping[_mid].owner);\r\n\r\n        require(lengthOf(mfrmapping[_mid].batchmapping[_bid].bn) > 0);\r\n        require(mfrmapping[_mid].batchmapping[_bid].key.length > 0);\r\n        require(mfrmapping[_mid].batchmapping[_bid].lock == false);\r\n\r\n        mfrmapping[_mid].batchmapping[_bid].key = _key;\r\n\r\n        emit SetKey(msg.sender, mfrmapping[_mid].mfr, _mid, mfrmapping[_mid].batchmapping[_bid].bn, _bid, _key);\r\n\r\n        return _bid;\r\n    }\r\n\r\n    /**\r\n     * @dev Lock batch. Batch number and public key is unchangeable after it is locked.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _bid Batch ID\r\n     * @return Batch ID\r\n     */\r\n    function lock(bytes32 _mid, bytes32 _bid) public returns (bytes32) {\r\n        require(_mid != bytes32(0));\r\n        require(_bid != bytes32(0));\r\n\r\n        require(mfrmapping[_mid].owner != address(0));\r\n        require(msg.sender == mfrmapping[_mid].owner);\r\n\r\n        require(lengthOf(mfrmapping[_mid].batchmapping[_bid].bn) > 0);\r\n        require(mfrmapping[_mid].batchmapping[_bid].key.length > 0);\r\n\r\n        mfrmapping[_mid].batchmapping[_bid].lock = true;\r\n\r\n        emit Lock(msg.sender, mfrmapping[_mid].mfr, _mid, mfrmapping[_mid].batchmapping[_bid].bn, _bid, mfrmapping[_mid].batchmapping[_bid].key);\r\n\r\n        return _bid;\r\n    }\r\n\r\n    /**\r\n     * @dev Check batch by its batch ID and public key.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _bid Batch ID\r\n     * @param _key Public key\r\n     * @return True or false\r\n     */\r\n    function check(bytes32 _mid, bytes32 _bid, bytes _key) public view returns (bool) {\r\n        if (mfrmapping[_mid].batchmapping[_bid].key.length != _key.length) {\r\n            return false;\r\n        }\r\n        for (uint256 i = 0; i < _key.length; i++) {\r\n            if (mfrmapping[_mid].batchmapping[_bid].key[i] != _key[i]) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Get total number of manufacturers.\r\n     * \r\n     * @return Total number of manufacturers\r\n     */\r\n    function totalMfr() public view returns (uint256) {\r\n        return midcounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Get manufacturer ID.\r\n     * \r\n     * @param _midcounter Storage index counter of midmapping\r\n     * @return Manufacturer ID\r\n     */\r\n    function midOf(uint256 _midcounter) public view returns (bytes32) {\r\n        return midmapping[_midcounter];\r\n    }\r\n\r\n    /**\r\n     * @dev Get manufacturer owner.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @return Manufacturer owner\r\n     */\r\n    function ownerOf(bytes32 _mid) public view returns (address) {\r\n        return mfrmapping[_mid].owner;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get manufacturer name.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @return Manufacturer name (Uppercase)\r\n     */\r\n    function mfrOf(bytes32 _mid) public view returns (string) {\r\n        return mfrmapping[_mid].mfr;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get total batch number of a manufacturer.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @return Total batch number\r\n     */\r\n    function totalBatchOf(bytes32 _mid) public view returns (uint256) {\r\n        return mfrmapping[_mid].bidcounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch ID.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _bidcounter Storage index counter of bidmapping\r\n     * @return Batch ID\r\n     */\r\n    function bidOf(bytes32 _mid, uint256 _bidcounter) public view returns (bytes32) {\r\n        return mfrmapping[_mid].bidmapping[_bidcounter];\r\n    }\r\n\r\n    /**\r\n     * @dev Get batch number.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _bid Batch ID\r\n     * @return Batch number\r\n     */\r\n    function bnOf(bytes32 _mid, bytes32 _bid) public view returns (string) {\r\n        return mfrmapping[_mid].batchmapping[_bid].bn;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get batch public key.\r\n     * \r\n     * @param _mid Manufacturer ID\r\n     * @param _bid Batch ID\r\n     * @return bytes Batch public key\r\n     */\r\n    function keyOf(bytes32 _mid, bytes32 _bid) public view returns (bytes) {\r\n        if (mfrmapping[_mid].batchmapping[_bid].lock == true) {\r\n            return mfrmapping[_mid].batchmapping[_bid].key;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Convert string to uppercase.\r\n     * \r\n     * @param _s String to convert\r\n     * @return Converted string\r\n     */\r\n    function uppercaseOf(string _s) internal pure returns (string) {\r\n        bytes memory b1 = bytes(_s);\r\n        uint256 l = b1.length;\r\n        bytes memory b2 = new bytes(l);\r\n        for (uint256 i = 0; i < l; i++) {\r\n            if (b1[i] >= 0x61 && b1[i] <= 0x7A) {\r\n                b2[i] = bytes1(uint8(b1[i]) - 32);\r\n            } else {\r\n                b2[i] = b1[i];\r\n            }\r\n        }\r\n        return string(b2);\r\n    }\r\n\r\n    /**\r\n     * @dev Get string length.\r\n     * \r\n     * @param _s String\r\n     * @return length\r\n     */\r\n    function lengthOf(string _s) internal pure returns (uint256) {\r\n        return bytes(_s).length;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_midcounter\",\"type\":\"uint256\"}],\"name\":\"midOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_bid\",\"type\":\"bytes32\"}],\"name\":\"bnOf\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"}],\"name\":\"mfrOf\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_bid\",\"type\":\"bytes32\"},{\"name\":\"_key\",\"type\":\"bytes\"}],\"name\":\"check\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_bidcounter\",\"type\":\"uint256\"}],\"name\":\"bidOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_bid\",\"type\":\"bytes32\"}],\"name\":\"lock\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_bid\",\"type\":\"bytes32\"}],\"name\":\"keyOf\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_bid\",\"type\":\"bytes32\"},{\"name\":\"_bn\",\"type\":\"string\"}],\"name\":\"setBn\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_bid\",\"type\":\"bytes32\"},{\"name\":\"_key\",\"type\":\"bytes\"}],\"name\":\"setKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"}],\"name\":\"totalBatchOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMfr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mfr\",\"type\":\"string\"}],\"name\":\"register\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mid\",\"type\":\"bytes32\"},{\"name\":\"_bn\",\"type\":\"string\"},{\"name\":\"_key\",\"type\":\"bytes\"}],\"name\":\"push\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_mfr\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_mid\",\"type\":\"bytes32\"}],\"name\":\"Register\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_mfr\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_mid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_mfr\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_mid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_bn\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_bid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_key\",\"type\":\"bytes\"}],\"name\":\"Push\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_mfr\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_mid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_bn\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_bid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_key\",\"type\":\"bytes\"}],\"name\":\"SetBn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_mfr\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_mid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_bn\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_bid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_key\",\"type\":\"bytes\"}],\"name\":\"SetKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_mfr\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_mid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_bn\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_bid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_key\",\"type\":\"bytes\"}],\"name\":\"Lock\",\"type\":\"event\"}]","ContractName":"PNS","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://17298903ddf2304daa22c40fc7bd5c5c5c25d6c116f82bc7c285c3e14625a977"}]}