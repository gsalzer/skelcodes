{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// ----------------------------------------------------------------------------\r\n// 'Kaasy' CROWDSALE token contract\r\n//\r\n// Deployed to : 0x06d5697043f8e611807b221e74f08a28bb4e6e13\r\n// Symbol      : KAAS\r\n// Name        : KAASY.AI Token\r\n// Total supply: 500000000\r\n// Decimals    : 18\r\n//\r\n// Enjoy.\r\n//\r\n// (c) by KAASY AI LTD. The MIT Licence.\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Safe maths\r\n// ----------------------------------------------------------------------------\r\ncontract SafeMath {\r\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Owned contract\r\n// ----------------------------------------------------------------------------\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n    \r\n    address public ownerAPI;\r\n    address public newOwnerAPI;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n    event OwnershipAPITransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        ownerAPI = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerAPI {\r\n        require(msg.sender == ownerAPI);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrOwnerAPI {\r\n        require(msg.sender == owner || msg.sender == ownerAPI);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function transferAPIOwnership(address _newOwnerAPI) public onlyOwner {\r\n        newOwnerAPI = _newOwnerAPI;\r\n    }\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n    function acceptOwnershipAPI() public {\r\n        require(msg.sender == newOwnerAPI);\r\n        emit OwnershipAPITransferred(ownerAPI, newOwnerAPI);\r\n        ownerAPI = newOwnerAPI;\r\n        newOwnerAPI = address(0);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Owned {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public isPaused = false;\r\n\r\n  function paused() public view returns (bool currentlyPaused) {\r\n      return isPaused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!isPaused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(isPaused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    isPaused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    isPaused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC20 Token, with the addition of symbol, name and decimals and assisted\r\n// token transfers\r\n// ----------------------------------------------------------------------------\r\ncontract KaasyToken is ERC20Interface, Pausable, SafeMath {\r\n    string public symbol = \"KAAS\";\r\n    string public  name  = \"KAASY.AI Token\";\r\n    uint8 public decimals = 18;\r\n    uint public _totalSupply;\r\n    uint public startDate;\r\n    uint public bonusEnd20;\r\n    uint public bonusEnd10;\r\n    uint public bonusEnd05;\r\n    uint public endDate;\r\n    uint public tradingDate;\r\n    uint public exchangeRate = 30000; // IN Euro cents = 300E\r\n    uint256 public maxSupply;\r\n    uint256 public soldSupply;\r\n    uint256 public maxSellable;\r\n    uint8 private teamWOVestingPercentage = 5;\r\n    \r\n    uint256 public minAmountETH;\r\n    uint256 public maxAmountETH;\r\n    \r\n    address public currentRunningAddress;\r\n\r\n    mapping(address => uint256) balances; //keeps ERC20 balances, in Symbol\r\n    mapping(address => uint256) ethDeposits; //keeps balances, in ETH\r\n    mapping(address => bool) kycAddressState; //keeps list of addresses which can send ETH without direct fail\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    mapping(address => uint256) burnedBalances; //keeps ERC20 balances, in Symbol\r\n\r\n    //event KYCStateUpdate(address indexed addr, bool state);\r\n    \r\n    event MintingFinished(uint indexed moment);\r\n    bool isMintingFinished = false;\r\n    \r\n    event OwnBlockchainLaunched(uint indexed moment);\r\n    event TokensBurned(address indexed exOwner, uint256 indexed amount, uint indexed moment);\r\n    bool isOwnBlockchainLaunched = false;\r\n    uint momentOwnBlockchainLaunched = 0;\r\n    \r\n    uint8 public versionIndex = 1;\r\n    \r\n    address addrUniversity;\r\n    address addrEarlySkills;\r\n    address addrHackathons;\r\n    address addrLegal;\r\n    address addrMarketing;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        maxSupply = 500000000 * (10 ** 18);\r\n        maxSellable = maxSupply * 60 / 100;\r\n        \r\n        currentRunningAddress = address(this);\r\n        \r\n        soldSupply = 0;\r\n        \r\n        startDate = 1535760000;  // September 1st\r\n        bonusEnd20 = 1536969600; // September 15th\r\n        bonusEnd10 = 1538179200; // September 29th\r\n        bonusEnd05 = 1539388800; // October 13th\r\n        endDate = 1542240000;    // November 15th\r\n        tradingDate = 1543536000;// November 30th\r\n        \r\n        minAmountETH = safeDiv(1 ether, 10);\r\n        maxAmountETH = safeMul(1 ether, 5000);\r\n        \r\n        uint256 teamAmount = maxSupply * 150 / 1000;\r\n        \r\n        balances[address(this)] = teamAmount * (100 - teamWOVestingPercentage) / 100; //team with vesting\r\n        emit Transfer(address(0), address(this), balances[address(this)]);\r\n        \r\n        balances[owner] = teamAmount * teamWOVestingPercentage / 100; //team without vesting\r\n        kycAddressState[owner] = true;\r\n        emit Transfer(address(0), owner, balances[owner]);\r\n        \r\n        addrUniversity = 0x7a0De4748E5E0925Bf80989A7951E15a418e4326;\r\n        balances[addrUniversity] =  maxSupply * 50 / 1000; //univ\r\n        kycAddressState[addrUniversity] = true;\r\n        emit Transfer(address(0), addrUniversity, balances[addrUniversity]);\r\n        \r\n        addrEarlySkills = 0xe1e0769b37c1C66889BdFE76eaDfE878f98aa4cd;\r\n        balances[addrEarlySkills] = maxSupply * 50 / 1000; //skills\r\n        kycAddressState[addrEarlySkills] = true;\r\n        emit Transfer(address(0), addrEarlySkills, balances[addrEarlySkills]);\r\n        \r\n        addrHackathons = 0xe9486863859b0facB9C62C46F7e3B70C476bc838;\r\n        balances[addrHackathons] =  maxSupply * 45 / 1000; //hackathons and bug bounties\r\n        kycAddressState[addrHackathons] = true;\r\n        emit Transfer(address(0), addrHackathons, balances[addrHackathons]);\r\n        \r\n        addrLegal = 0xDcdb9787ead2E0D3b12ED0cf8200Bc91F9Aaa045;\r\n        balances[addrLegal] =       maxSupply * 30 / 1000; //legal fees & backup\r\n        kycAddressState[addrLegal] = true;\r\n        emit Transfer(address(0), addrLegal, balances[addrLegal]);\r\n        \r\n        addrMarketing = 0x4f11859330D389F222476afd65096779Eb1aDf25;\r\n        balances[addrMarketing] =   maxSupply * 75 / 1000; //marketing\r\n        kycAddressState[addrMarketing] = true;\r\n        emit Transfer(address(0), addrMarketing, balances[addrMarketing]);\r\n        \r\n        _totalSupply = maxSupply * 40 / 100;\r\n        \r\n        \r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // token minter function\r\n    // ------------------------------------------------------------------------\r\n    function () public payable whenNotPaused {\r\n        if(now > endDate && isMintingFinished == false) {\r\n            finishMinting();\r\n            msg.sender.transfer(msg.value); //return this transfer, as it is too late.\r\n        } else {\r\n            require(now >= startDate && now <= endDate && isMintingFinished == false);\r\n            \r\n            require(msg.value >= minAmountETH && msg.value <= maxAmountETH);\r\n            require(msg.value + ethDeposits[msg.sender] <= maxAmountETH);\r\n            \r\n            require(kycAddressState[msg.sender] == true);\r\n            \r\n            uint tokens = getAmountToIssue(msg.value);\r\n            require(safeAdd(soldSupply, tokens) <= maxSellable);\r\n            \r\n            soldSupply = safeAdd(soldSupply, tokens);\r\n            _totalSupply = safeAdd(_totalSupply, tokens);\r\n            balances[msg.sender] = safeAdd(balances[msg.sender], tokens);\r\n            ethDeposits[msg.sender] = safeAdd(ethDeposits[msg.sender], msg.value);\r\n            emit Transfer(address(0), msg.sender, tokens);\r\n            \r\n            owner.transfer(msg.value * 15 / 100);   //transfer 15% of the ETH now, the other 85% at the end of the ICO process\r\n        }\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Burns tokens of `msg.sender` and sets them as redeemable on KAASY blokchain\r\n    // ------------------------------------------------------------------------\r\n    function BurnMyTokensAndSetAmountForNewBlockchain() public  {\r\n        require(isOwnBlockchainLaunched);\r\n        \r\n        uint senderBalance = balances[msg.sender];\r\n        burnedBalances[msg.sender] = safeAdd(burnedBalances[msg.sender], senderBalance);\r\n        balances[msg.sender] = 0;\r\n        emit TokensBurned(msg.sender, senderBalance, now);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Burns tokens of `exOwner` and sets them as redeemable on KAASY blokchain\r\n    // ------------------------------------------------------------------------\r\n    function BurnTokensAndSetAmountForNewBlockchain(address exOwner) onlyOwnerOrOwnerAPI public {\r\n        require(isOwnBlockchainLaunched);\r\n        \r\n        uint exBalance = balances[exOwner];\r\n        burnedBalances[exOwner] = safeAdd(burnedBalances[exOwner], exBalance);\r\n        balances[exOwner] = 0;\r\n        emit TokensBurned(exOwner, exBalance, now);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Enables the burning of tokens to move to the new KAASY blockchain\r\n    // ------------------------------------------------------------------------\r\n    function SetNewBlockchainEnabled() onlyOwner public {\r\n        require(isMintingFinished && isOwnBlockchainLaunched == false);\r\n        isOwnBlockchainLaunched = true;\r\n        momentOwnBlockchainLaunched = now;\r\n        emit OwnBlockchainLaunched(now);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Evaluates conditions for finishing the ICO and does that if conditions are met\r\n    // ------------------------------------------------------------------------\r\n    function finishMinting() public returns (bool finished) {\r\n        if(now > endDate && isMintingFinished == false) {\r\n            internalFinishMinting();\r\n            return true;\r\n        } else if (_totalSupply >= maxSupply) {\r\n            internalFinishMinting();\r\n            return true;\r\n        }\r\n        if(now > endDate && address(this).balance > 0) {\r\n            owner.transfer(address(this).balance);\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Actually executes the finish of the ICO, \r\n    //  no longer minting tokens, \r\n    //  releasing the 85% of ETH kept by contract and\r\n    //  enables trading 2 weeks after this moment\r\n    // ------------------------------------------------------------------------\r\n    function internalFinishMinting() internal {\r\n        tradingDate = now + 3600;// * 24 * 15; // 2 weeks after ICO end moment\r\n        isMintingFinished = true;\r\n        emit MintingFinished(now);\r\n        owner.transfer(address(this).balance); //transfer all ETH left (the 85% not sent instantly) to the owner address\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculates amount of KAAS to issue to `msg.sender` for `ethAmount`\r\n    // Can be called by any interested party, to evaluate the amount of KAAS obtained for `ethAmount` specified\r\n    // ------------------------------------------------------------------------\r\n    function getAmountToIssue(uint256 ethAmount) public view returns(uint256) {\r\n        //price is 10c/KAAS\r\n        uint256 euroAmount = exchangeEthToEur(ethAmount);\r\n        uint256 ret = euroAmount / 10; // 1kaas=0.1EUR, exchange rate is in cents, so *10/100 = /10\r\n        ret = ret * (uint256)(10) ** (uint256)(decimals);\r\n        if(now < bonusEnd20) {\r\n            ret = euroAmount * 12;          //first week, 20% bonus\r\n            \r\n        } else if(now < bonusEnd10) {\r\n            ret = euroAmount * 11;          //second week, 10% bonus\r\n            \r\n        } else if(now < bonusEnd05) {\r\n            ret = euroAmount * 105 / 10;    //third week, 5% bonus\r\n            \r\n        }\r\n        \r\n        if(euroAmount >= 50000) {\r\n            ret = ret * 13 / 10;\r\n            \r\n        } else if(euroAmount >= 10000) {\r\n            ret = ret * 12 / 10;\r\n        }\r\n        \r\n        return ret;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Calculates EUR amount for ethAmount\r\n    // ------------------------------------------------------------------------\r\n    function exchangeEthToEur(uint256 ethAmount) internal view returns(uint256 rate) {\r\n        return safeDiv(safeMul(ethAmount, exchangeRate), 1 ether);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Calculates KAAS amount for eurAmount\r\n    // ------------------------------------------------------------------------\r\n    function exchangeEurToEth(uint256 eurAmount) internal view returns(uint256 rate) {\r\n        return safeDiv(safeMul(safeDiv(safeMul(eurAmount, 1000000000000000000), exchangeRate), 1 ether), 1000000000000000000);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Calculates and transfers monthly vesting amount to founders, into the balance of `owner` address\r\n    // ------------------------------------------------------------------------\r\n    function transferVestingMonthlyAmount(address destination) public onlyOwner returns (bool) {\r\n        require(destination != address(0));\r\n        uint monthsSinceLaunch = (now - tradingDate) / 3600 / 24 / 30;\r\n        uint256 totalAmountInVesting = maxSupply * 15 / 100 * (100 - teamWOVestingPercentage) / 100; //15% of total, of which 5% instant and 95% with vesting\r\n        uint256 releaseableUpToToday = (monthsSinceLaunch + 1) * totalAmountInVesting / 24; // 15% of total, across 24 months\r\n        \r\n        //address(this) holds the vestable amount left\r\n        uint256 alreadyReleased = totalAmountInVesting - balances[address(this)];\r\n        uint256 releaseableNow = releaseableUpToToday - alreadyReleased;\r\n        require (releaseableNow > 0);\r\n        transferFrom(address(this), destination, releaseableNow);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Set KYC state for `depositer` to `isAllowed`, by admins\r\n    // ------------------------------------------------------------------------\r\n    function setAddressKYC(address depositer, bool isAllowed) public onlyOwnerOrOwnerAPI returns (bool) {\r\n        kycAddressState[depositer] = isAllowed;\r\n        //emit KYCStateUpdate(depositer, isAllowed);\r\n        return true;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Get an addresses KYC state\r\n    // ------------------------------------------------------------------------\r\n    function getAddressKYCState(address depositer) public view returns (bool) {\r\n        return kycAddressState[depositer];\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Token name, as seen by the network\r\n    // ------------------------------------------------------------------------\r\n    function name() public view returns (string) {\r\n        return name;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Token symbol, as seen by the network\r\n    // ------------------------------------------------------------------------\r\n    function symbol() public view returns (string) {\r\n        return symbol;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Token decimals\r\n    // ------------------------------------------------------------------------\r\n    function decimals() public view returns (uint8) {\r\n        return decimals;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Total supply\r\n    // ------------------------------------------------------------------------\r\n    function totalSupply() public constant returns (uint) {\r\n        return _totalSupply  - balances[address(0)]; //address(0) represents burned tokens\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Circulating supply\r\n    // ------------------------------------------------------------------------\r\n    function circulatingSupply() public constant returns (uint) {\r\n        return _totalSupply - balances[address(0)] - balances[address(this)]; //address(0) represents burned tokens\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the token balance for account `tokenOwner`\r\n    // ------------------------------------------------------------------------\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Get the total ETH deposited by `depositer`\r\n    // ------------------------------------------------------------------------\r\n    function depositsOf(address depositer) public constant returns (uint balance) {\r\n        return ethDeposits[depositer];\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Get the total KAAS burned by `exOwner`\r\n    // ------------------------------------------------------------------------\r\n    function burnedBalanceOf(address exOwner) public constant returns (uint balance) {\r\n        return burnedBalances[exOwner];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer the balance from token owner's account to `to` account\r\n    // - Owner's account must have sufficient balance to transfer\r\n    // - 0 value transfers are allowed\r\n    //  !! fund source is the address calling this function !!\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address to, uint tokens) public whenNotPaused returns (bool success) {\r\n        if(now > endDate && isMintingFinished == false) {\r\n            finishMinting();\r\n        }\r\n        require(now >= tradingDate || kycAddressState[to] == true); //allow internal transfers before tradingDate\r\n        balances[msg.sender] = safeSub(balances[msg.sender], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `destination` to transferFrom(...) `tokens`\r\n    // from the token owner's account\r\n    //\r\n    // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n    // recommends that there are no checks for the approval double-spend attack\r\n    // as this should be implemented in user interfaces\r\n    \r\n    // !!! When called, the amount of tokens DESTINATION can retrieve from MSG.SENDER is set to AMOUNT\r\n    // !!! This is used when another account C calls and pays gas for the transfer between A and B, like bank cheques\r\n    // !!! meaning: Allow DESTINATION to transfer a total AMOUNT from ME=callerOfThisFunction, from this point on, ignoring previous allows\r\n    \r\n    // ------------------------------------------------------------------------\r\n    function approve(address destination, uint amount) public returns (bool success) {\r\n        allowed[msg.sender][destination] = amount;\r\n        emit Approval(msg.sender, destination, amount);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Transfer `tokens` from the `from` account to the `to` account\r\n    //\r\n    // The calling account must already have sufficient tokens approve(...)-d\r\n    // for spending from the `from` account and\r\n    // - From account must have sufficient balance to transfer\r\n    // - Spender must have sufficient allowance to transfer\r\n    // - 0 value transfers are allowed\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) {\r\n        if(now > endDate && isMintingFinished == false) {\r\n            finishMinting();\r\n        }\r\n        require(now >= tradingDate || kycAddressState[to] == true); //allow internal transfers before tradingDate\r\n        allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens);\r\n        balances[from] = safeSub(balances[from], tokens);\r\n        balances[to] = safeAdd(balances[to], tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Returns the amount of tokens approved by the owner that can be\r\n    // transferred to the requester's account\r\n    // ------------------------------------------------------------------------\r\n    function allowance(address tokenOwner, address requester) public constant returns (uint remaining) {\r\n        return allowed[tokenOwner][requester];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Token owner can approve for `requester` to transferFrom(...) `tokens`\r\n    // from the token owner's account. The `requester` contract function\r\n    // `receiveApproval(...)` is then executed\r\n    // ------------------------------------------------------------------------\r\n    function approveAndCall(address requester, uint tokens, bytes data) public whenNotPaused returns (bool success) {\r\n        allowed[msg.sender][requester] = tokens;\r\n        emit Approval(msg.sender, requester, tokens);\r\n        ApproveAndCallFallBack(requester).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out `tokens` amount of accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAllERC20Token(address tokenAddress, uint tokens) public onlyOwnerOrOwnerAPI returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, tokens);\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out all accidentally sent ERC20 tokens\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress) public onlyOwnerOrOwnerAPI returns (bool success) {\r\n        return ERC20Interface(tokenAddress).transfer(owner, ERC20Interface(tokenAddress).balanceOf(this));\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Set the new ETH-EUR exchange rate, in cents\r\n    // ------------------------------------------------------------------------\r\n    function updateExchangeRate(uint newEthEurRate) public onlyOwnerOrOwnerAPI returns (bool success) {\r\n        exchangeRate = newEthEurRate;\r\n        return true;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Get the current ETH-EUR exchange rate, in cents\r\n    // ------------------------------------------------------------------------\r\n    function getExchangeRate() public view returns (uint256 rate) {\r\n        return exchangeRate;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Set the new EndDate\r\n    // ------------------------------------------------------------------------\r\n    function updateEndDate(uint256 newDate) public onlyOwnerOrOwnerAPI returns (bool success) {\r\n        require(!isMintingFinished);\r\n        require(!isOwnBlockchainLaunched);\r\n        \r\n        endDate = newDate;\r\n        \r\n        return true;\r\n    }\r\n    \r\n    // ------------------------------------------------------------------------\r\n    // Set the new Token name, Symbol, Contract address when updating\r\n    // ------------------------------------------------------------------------\r\n    function updateTokenNameSymbolAddress(string newTokenName, string newSymbol, address newContractAddress) public whenPaused onlyOwnerOrOwnerAPI returns (bool success) {\r\n        name = newTokenName;\r\n        symbol = newSymbol;\r\n        currentRunningAddress = newContractAddress;\r\n        \r\n        return true;\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnershipAPI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"SetNewBlockchainEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSellable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minAmountETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tradingDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwnerAPI\",\"type\":\"address\"}],\"name\":\"transferAPIOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusEnd10\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"currentlyPaused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"transferVestingMonthlyAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"finished\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRunningAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"BurnMyTokensAndSetAmountForNewBlockchain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"exOwner\",\"type\":\"address\"}],\"name\":\"burnedBalanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"circulatingSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusEnd20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newTokenName\",\"type\":\"string\"},{\"name\":\"newSymbol\",\"type\":\"string\"},{\"name\":\"newContractAddress\",\"type\":\"address\"}],\"name\":\"updateTokenNameSymbolAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newEthEurRate\",\"type\":\"uint256\"}],\"name\":\"updateExchangeRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusEnd05\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"getAmountToIssue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"requester\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAPI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAllERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"requester\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"exOwner\",\"type\":\"address\"}],\"name\":\"BurnTokensAndSetAmountForNewBlockchain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositer\",\"type\":\"address\"}],\"name\":\"depositsOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExchangeRate\",\"outputs\":[{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDate\",\"type\":\"uint256\"}],\"name\":\"updateEndDate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"depositer\",\"type\":\"address\"},{\"name\":\"isAllowed\",\"type\":\"bool\"}],\"name\":\"setAddressKYC\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositer\",\"type\":\"address\"}],\"name\":\"getAddressKYCState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwnerAPI\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxAmountETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"versionIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"moment\",\"type\":\"uint256\"}],\"name\":\"MintingFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"moment\",\"type\":\"uint256\"}],\"name\":\"OwnBlockchainLaunched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"exOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"moment\",\"type\":\"uint256\"}],\"name\":\"TokensBurned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipAPITransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"KaasyToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d0a2a38b629bdd97d8b779985645122d7963dd62be6555f15c666e8cbabe8317"}]}