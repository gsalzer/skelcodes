{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\n// File: contracts/ERC20Interface.sol\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() external view returns (uint supply);\r\n    function balanceOf(address _owner) external view returns (uint balance);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function approve(address _spender, uint _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n    function decimals() external view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n// File: contracts/SupplierInterface.sol\r\n\r\ninterface SupplierInterface {\r\n\r\n    function trade(\r\n        ERC20 srcToken,\r\n        uint srcAmount,\r\n        ERC20 destToken,\r\n        address destAddress,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        external\r\n        payable\r\n        returns(bool);\r\n\r\n    function getConversionRate(ERC20 src, ERC20 dest, uint srcQty, uint blockNumber) external view returns(uint);\r\n}\r\n\r\n// File: contracts/PermissionGroups.sol\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal quoters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal quotersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyQuoter() {\r\n        require(quoters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getQuoters () external view returns(address[]) {\r\n        return quotersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        emit TransferAdminPending(newAdmin);\r\n        emit AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        emit AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        emit OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                emit OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event QuoterAdded (address newQuoter, bool isAdd);\r\n\r\n    function addQuoter(address newQuoter) public onlyAdmin {\r\n        require(!quoters[newQuoter]); // prevent duplicates.\r\n        require(quotersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        emit QuoterAdded(newQuoter, true);\r\n        quoters[newQuoter] = true;\r\n        quotersGroup.push(newQuoter);\r\n    }\r\n\r\n    function removeQuoter (address alerter) public onlyAdmin {\r\n        require(quoters[alerter]);\r\n        quoters[alerter] = false;\r\n\r\n        for (uint i = 0; i < quotersGroup.length; ++i) {\r\n            if (quotersGroup[i] == alerter) {\r\n                quotersGroup[i] = quotersGroup[quotersGroup.length - 1];\r\n                quotersGroup.length--;\r\n                emit QuoterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/Withdrawable.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers\r\n * @dev This allows to recover any tokens or Ethers received in a contract.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        emit TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        emit EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n// File: contracts/Base.sol\r\n\r\n/**\r\n * The Base contract does this and that...\r\n */\r\ncontract Base {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n\tfunction setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n        \r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n// File: contracts/WhiteListInterface.sol\r\n\r\ncontract WhiteListInterface {\r\n    function getUserCapInWei(address user) external view returns (uint userCapWei);\r\n}\r\n\r\n// File: contracts/ExpectedRateInterface.sol\r\n\r\ninterface ExpectedRateInterface {\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) external view\r\n        returns (uint expectedRate, uint slippageRate);\r\n}\r\n\r\n// File: contracts/MartletInstantlyTrader.sol\r\n\r\ncontract MartletInstantlyTrader is Withdrawable, Base {\r\n\r\n    uint public negligibleRateDiff = 10; // basic rate steps will be in 0.01%\r\n    SupplierInterface[] public suppliers;\r\n    mapping(address=>bool) public isSupplier;\r\n    WhiteListInterface public whiteListContract;\r\n    ExpectedRateInterface public expectedRateContract;\r\n    mapping(address=>bool) validateCodeTokens;\r\n    uint                  public maxGasPrice = 50 * 1000 * 1000 * 1000; // 50 gwei\r\n    uint                  internal validBlkNum = 256; \r\n    bool                  public enabled = false; // network is enabled\r\n    mapping(bytes32=>uint) public info; // this is only a UI field for external app.\r\n    mapping(address=>mapping(bytes32=>bool)) public perSupplierListedPairs;\r\n    uint    internal  quoteKey = 0;\r\n\r\n    constructor (address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    event EtherReceival(address indexed sender, uint amount);\r\n\r\n    /* solhint-disable no-complex-fallback */\r\n    function() public payable {\r\n        require(isSupplier[msg.sender]);\r\n        emit EtherReceival(msg.sender, msg.value);\r\n    }\r\n    /* solhint-enable no-complex-fallback */\r\n\r\n    event LogCode(bytes32 bs);\r\n    event ExecuteTrade(address indexed sender, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount);\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param rate100 \"x\".\r\n    /// @param sn \"y\".\r\n    /// @param code \"z\"\r\n    /// @return amount of actual dest tokens\r\n    function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        uint rate100,\r\n        uint sn,\r\n        bytes32 code\r\n        \r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(enabled);\r\n        require(validateTradeInput(src, srcAmount, dest, destAddress, rate100, sn, code));\r\n\r\n        uint userSrcBalanceBefore;\r\n        uint userDestBalanceBefore;\r\n\r\n        userSrcBalanceBefore = getBalance(src, msg.sender);\r\n        if (src == ETH_TOKEN_ADDRESS)\r\n            userSrcBalanceBefore += msg.value;\r\n        userDestBalanceBefore = getBalance(dest, destAddress);\r\n\r\n        // emit LogEx(srcAmount, maxDestAmount, minConversionRate);\r\n        // uint actualDestAmount = 24;\r\n        uint actualDestAmount = doTrade(src,\r\n                                        srcAmount,\r\n                                        dest,\r\n                                        destAddress,\r\n                                        maxDestAmount,\r\n                                        minConversionRate,\r\n                                        rate100\r\n                                        );\r\n        require(actualDestAmount > 0);\r\n        require(checkBalance(src, dest, destAddress, userSrcBalanceBefore, userDestBalanceBefore, minConversionRate));\r\n        return actualDestAmount;\r\n}\r\n\r\nfunction checkBalance(ERC20 src, ERC20 dest, address destAddress,\r\n    uint userSrcBalanceBefore, \r\n    uint userDestBalanceBefore, \r\n    uint minConversionRate) internal view returns(bool)\r\n{\r\n    uint userSrcBalanceAfter = getBalance(src, msg.sender);\r\n    uint userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n    if(userSrcBalanceAfter > userSrcBalanceBefore){\r\n        return false;\r\n    }\r\n    if(userDestBalanceAfter < userDestBalanceBefore){\r\n        return false;\r\n    }\r\n\r\n    return (userDestBalanceAfter - userDestBalanceBefore) >=\r\n        calcDstQty((userSrcBalanceBefore - userSrcBalanceAfter), getDecimals(src), getDecimals(dest), minConversionRate);\r\n}\r\n\r\n    event AddSupplier(SupplierInterface supplier, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev add or deletes a supplier to/from the network.\r\n    /// @param supplier The supplier address.\r\n    /// @param add If true, the add supplier. Otherwise delete supplier.\r\n    function addSupplier(SupplierInterface supplier, bool add) public onlyAdmin {\r\n\r\n        if (add) {\r\n            require(!isSupplier[supplier]);\r\n            suppliers.push(supplier);\r\n            isSupplier[supplier] = true;\r\n            emit AddSupplier(supplier, true);\r\n        } else {\r\n            isSupplier[supplier] = false;\r\n            for (uint i = 0; i < suppliers.length; i++) {\r\n                if (suppliers[i] == supplier) {\r\n                    suppliers[i] = suppliers[suppliers.length - 1];\r\n                    suppliers.length--;\r\n                    emit AddSupplier(supplier, false);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    event ListSupplierPairs(address supplier, ERC20 src, ERC20 dest, bool add);\r\n\r\n    /// @notice can be called only by admin\r\n    /// @dev allow or prevent a specific supplier to trade a pair of tokens\r\n    /// @param supplier The supplier address.\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /// @param add If true then enable trade, otherwise delist pair.\r\n    function listPairForSupplier(address supplier, ERC20 src, ERC20 dest, bool add) public onlyAdmin {\r\n        (perSupplierListedPairs[supplier])[keccak256(src, dest)] = add;\r\n\r\n        if (src != ETH_TOKEN_ADDRESS) {\r\n            if (add) {\r\n                src.approve(supplier, 2**255); // approve infinity\r\n                // src.approve(supplier, src.balanceOf(msg.sender));\r\n            } else {\r\n                src.approve(supplier, 0);\r\n            }\r\n        }\r\n\r\n        setDecimals(src);\r\n        setDecimals(dest);\r\n\r\n        emit ListSupplierPairs(supplier, src, dest, add);\r\n    }\r\n\r\n    function setParams(\r\n        WhiteListInterface    _whiteList,\r\n        ExpectedRateInterface _expectedRate,\r\n        uint                  _maxGasPrice,\r\n        uint                  _negligibleRateDiff,\r\n        uint                  _validBlkNum\r\n    )\r\n        public\r\n        onlyAdmin\r\n    {\r\n        require(_whiteList != address(0));\r\n        require(_expectedRate != address(0));\r\n        require(_negligibleRateDiff <= 100 * 100); // at most 100%\r\n        require( _validBlkNum > 1 && _validBlkNum < 256);\r\n        \r\n        whiteListContract = _whiteList;\r\n        expectedRateContract = _expectedRate;\r\n        maxGasPrice = _maxGasPrice;\r\n        negligibleRateDiff = _negligibleRateDiff;\r\n        validBlkNum = _validBlkNum;\r\n    }\r\n\r\n    function setEnable(bool _enable) public onlyAdmin {\r\n        if (_enable) {\r\n            require(whiteListContract != address(0));\r\n            require(expectedRateContract != address(0));\r\n        }\r\n        enabled = _enable;\r\n    }\r\n\r\n    function setQuoteKey(uint _quoteKey) public onlyOperator{\r\n        require(_quoteKey > 0, \"quoteKey must greater than 0!\");\r\n        quoteKey = _quoteKey;\r\n    }\r\n\r\n    function getQuoteKey() public onlyOperator view returns(uint){\r\n        return quoteKey;\r\n    }\r\n\r\n    function setInfo(bytes32 field, uint value) public onlyOperator {\r\n        info[field] = value;\r\n    }\r\n\r\n    /// @dev returns number of suppliers\r\n    /// @return number of suppliers\r\n    function getNumSuppliers() public view returns(uint) {\r\n        return suppliers.length;\r\n    }\r\n\r\n    /// @notice should be called off chain with as much gas as needed\r\n    /// @dev get an array of all suppliers\r\n    /// @return An array of all suppliers\r\n    function getSuppliers() public view returns(SupplierInterface[]) {\r\n        return suppliers;\r\n    }\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev best conversion rate for a pair of tokens, if number of suppliers have small differences. randomize\r\n    /// @param src Src token\r\n    /// @param dest Destination token\r\n    /* solhint-disable code-complexity */\r\n    function findBestRate(ERC20 src, ERC20 dest, uint srcQty) public view returns(uint, uint) {\r\n        uint bestRate = 0;\r\n        uint bestSupplier = 0;\r\n        uint numRelevantSuppliers = 0;\r\n        uint numSuppliers = suppliers.length;\r\n        uint[] memory rates = new uint[](numSuppliers);\r\n        uint[] memory supplierCandidates = new uint[](numSuppliers);\r\n\r\n        for (uint i = 0; i < numSuppliers; i++) {\r\n            //list all suppliers that have this token.\r\n            if (!(perSupplierListedPairs[suppliers[i]])[keccak256(src, dest)]) continue;\r\n\r\n            rates[i] = suppliers[i].getConversionRate(src, dest, srcQty, block.number);\r\n\r\n            if (rates[i] > bestRate) {\r\n                //best rate is highest rate\r\n                bestRate = rates[i];\r\n            }\r\n        }\r\n\r\n        if (bestRate > 0) {\r\n            uint random = 0;\r\n            uint smallestRelevantRate = (bestRate * 10000) / (10000 + negligibleRateDiff);\r\n\r\n            for (i = 0; i < numSuppliers; i++) {\r\n                if (rates[i] >= smallestRelevantRate) {\r\n                    supplierCandidates[numRelevantSuppliers++] = i;\r\n                }\r\n            }\r\n\r\n            if (numRelevantSuppliers > 1) {\r\n                //when encountering small rate diff from bestRate. draw from relevant suppliers\r\n                random = uint(blockhash(block.number-1)) % numRelevantSuppliers;\r\n            }\r\n\r\n            bestSupplier = supplierCandidates[random];\r\n            bestRate = rates[bestSupplier];\r\n        }\r\n\r\n        return (bestSupplier, bestRate);\r\n    }\r\n    /* solhint-enable code-complexity */\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns (uint expectedRate, uint slippageRate)\r\n    {\r\n        require(expectedRateContract != address(0));\r\n        return expectedRateContract.getExpectedRate(src, dest, srcQty);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        return whiteListContract.getUserCapInWei(user);\r\n    }\r\n\r\n    // event LogEx(uint no, uint n1, uint n2);\r\n\r\n    function doTrade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        uint rate100\r\n    )\r\n        internal\r\n        returns(uint)\r\n    {\r\n        require(tx.gasprice <= maxGasPrice);\r\n\r\n        uint supplierInd;\r\n        uint rate;\r\n\r\n        (supplierInd, rate) = findBestRate(src, dest, srcAmount);\r\n        SupplierInterface theSupplier = suppliers[supplierInd];\r\n        require(rate > 0 && rate < MAX_RATE);\r\n        if (validateCodeTokens[src] || validateCodeTokens[dest]){\r\n            require(rate100 > 0 && rate100 >= minConversionRate && rate100 < MAX_RATE);\r\n            rate = rate100;\r\n        }\r\n        else{\r\n            require(rate >= minConversionRate);\r\n        }\r\n\r\n        uint actualSrcAmount = srcAmount;\r\n        uint actualDestAmount = calcDestAmount(src, dest, actualSrcAmount, rate100);\r\n        if (actualDestAmount > maxDestAmount) {\r\n            actualDestAmount = maxDestAmount;\r\n            actualSrcAmount = calcSrcAmount(src, dest, actualDestAmount, rate100);\r\n            require(actualSrcAmount <= srcAmount);\r\n        }\r\n\r\n        // do the trade\r\n        // verify trade size is smaller than user cap\r\n        uint ethAmount;\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            ethAmount = actualSrcAmount;\r\n        } else {\r\n            ethAmount = actualDestAmount;\r\n        }\r\n\r\n        require(ethAmount <= getUserCapInWei(msg.sender));\r\n        require(doSupplierTrade(src, actualSrcAmount, dest, destAddress, actualDestAmount, theSupplier, rate, true));\r\n\r\n        if ((actualSrcAmount < srcAmount) && (src == ETH_TOKEN_ADDRESS)) {\r\n            msg.sender.transfer(srcAmount - actualSrcAmount);\r\n        }\r\n\r\n\r\n        emit ExecuteTrade(msg.sender, src, dest, actualSrcAmount, actualDestAmount);\r\n        return actualDestAmount;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev do one trade with a supplier\r\n    /// @param src Src token\r\n    /// @param amount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param supplier Supplier to use\r\n    /// @param validate If true, additional validations are applicable\r\n    /// @return true if trade is successful\r\n    function doSupplierTrade(\r\n        ERC20 src,\r\n        uint amount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint expectedDestAmount,\r\n        SupplierInterface supplier,\r\n        uint conversionRate,\r\n        bool validate\r\n    )\r\n        internal\r\n        returns(bool)\r\n    {\r\n        uint callValue = 0;\r\n        \r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            callValue = amount;\r\n        } else {\r\n            // take src tokens to this contract\r\n            require(src.transferFrom(msg.sender, this, amount));\r\n        }\r\n\r\n        // supplier sends tokens/eth to network. network sends it to destination\r\n\r\n        require(supplier.trade.value(callValue)(src, amount, dest, this, conversionRate, validate));\r\n        emit SupplierTrade(callValue, src, amount, dest, this, conversionRate, validate);\r\n\r\n        if (dest == ETH_TOKEN_ADDRESS) {\r\n            destAddress.transfer(expectedDestAmount);\r\n        } else {\r\n            require(dest.transfer(destAddress, expectedDestAmount));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    event SupplierTrade(uint v, ERC20 src, uint amnt, ERC20 dest, address destAddress, uint conversionRate, bool validate);\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function setValidateCodeTokens(ERC20 token, bool add) public onlyAdmin{\r\n        if (add){\r\n            require(!validateCodeTokens[token]);\r\n            validateCodeTokens[token] = true;\r\n        }\r\n        else{\r\n            require(validateCodeTokens[token]);\r\n            delete validateCodeTokens[token];\r\n        }\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev checks that user sent ether/tokens to contract before trade\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @return true if input is valid\r\n    function validateTradeInput(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint rate, uint sn, bytes32 code) internal view returns(bool) {\r\n        if (validateCodeTokens[src] || validateCodeTokens[dest]){\r\n            if(sn > block.number || block.number - sn > validBlkNum)\r\n            {\r\n                return false;\r\n            }\r\n            if(keccak256(rate, sn, quoteKey) != code){\r\n                return false;\r\n            }\r\n        }\r\n        if ((srcAmount >= MAX_QTY) || (srcAmount == 0) || (destAddress == 0))\r\n            return false;\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            if (msg.value != srcAmount)\r\n                return false;\r\n        } else {\r\n            if ((msg.value != 0) || (src.allowance(msg.sender, this) < srcAmount))\r\n                return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"perSupplierListedPairs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumSuppliers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"alerter\",\"type\":\"address\"}],\"name\":\"removeQuoter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOperators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"setValidateCodeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_quoteKey\",\"type\":\"uint256\"}],\"name\":\"setQuoteKey\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxGasPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSuppliers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isSupplier\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"supplier\",\"type\":\"address\"},{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"listPairForSupplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"negligibleRateDiff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"expectedRateContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whiteListContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"field\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"setInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQuoters\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getUserCapInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"supplier\",\"type\":\"address\"},{\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"addSupplier\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enable\",\"type\":\"bool\"}],\"name\":\"setEnable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"transferAdminQuickly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"getExpectedRate\",\"outputs\":[{\"name\":\"expectedRate\",\"type\":\"uint256\"},{\"name\":\"slippageRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newQuoter\",\"type\":\"address\"}],\"name\":\"addQuoter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whiteList\",\"type\":\"address\"},{\"name\":\"_expectedRate\",\"type\":\"address\"},{\"name\":\"_maxGasPrice\",\"type\":\"uint256\"},{\"name\":\"_negligibleRateDiff\",\"type\":\"uint256\"},{\"name\":\"_validBlkNum\",\"type\":\"uint256\"}],\"name\":\"setParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"info\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"srcQty\",\"type\":\"uint256\"}],\"name\":\"findBestRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"srcAmount\",\"type\":\"uint256\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"destAddress\",\"type\":\"address\"},{\"name\":\"maxDestAmount\",\"type\":\"uint256\"},{\"name\":\"minConversionRate\",\"type\":\"uint256\"},{\"name\":\"rate100\",\"type\":\"uint256\"},{\"name\":\"sn\",\"type\":\"uint256\"},{\"name\":\"code\",\"type\":\"bytes32\"}],\"name\":\"trade\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"suppliers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQuoteKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"EtherReceival\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bs\",\"type\":\"bytes32\"}],\"name\":\"LogCode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"actualSrcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"actualDestAmount\",\"type\":\"uint256\"}],\"name\":\"ExecuteTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"AddSupplier\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"supplier\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"add\",\"type\":\"bool\"}],\"name\":\"ListSupplierPairs\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"v\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amnt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"destAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"conversionRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"validate\",\"type\":\"bool\"}],\"name\":\"SupplierTrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"TokenWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sendTo\",\"type\":\"address\"}],\"name\":\"EtherWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pendingAdmin\",\"type\":\"address\"}],\"name\":\"TransferAdminPending\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousAdmin\",\"type\":\"address\"}],\"name\":\"AdminClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newQuoter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdd\",\"type\":\"bool\"}],\"name\":\"QuoterAdded\",\"type\":\"event\"}]","ContractName":"MartletInstantlyTrader","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d794c4be4d49d863227a5f6d612fefa96486ee90","Library":"","SwarmSource":"bzzr://b8babca5b101c4781c8b11442d9a53659d25bdbc0aac2cad5c9f7fb2616df42e"}]}