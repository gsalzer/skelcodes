{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n     return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract tokenInterface {\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\r\n\tstring public symbols;\r\n\tfunction originBurn(uint256 _value) public returns(bool);\r\n}\r\ncontract TokedoDaicoInterface {\r\n    function sendTokens(address _buyer, uint256 _amount) public returns(bool);\r\n    address public owner;\r\n}\r\n\r\ncontract AtomaxKyc {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => bool) public isKycSigner;\r\n    mapping (bytes32 => uint256) public alreadyPayed;\r\n\r\n    event KycVerified(address indexed signer, address buyerAddress, bytes32 buyerId, uint maxAmount);\r\n\r\n    constructor() internal {\r\n        isKycSigner[0x9787295cdAb28b6640bc7e7db52b447B56b1b1f0] = true; //ATOMAX KYC 1 SIGNER\r\n        isKycSigner[0x3b3f379e49cD95937121567EE696dB6657861FB0] = true; //ATOMAX KYC 2 SIGNER\r\n    }\r\n\r\n    // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed\r\n    function releaseTokensTo(address buyer) internal returns(bool);\r\n    \r\n    function buyTokens(bytes32 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) {\r\n        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\r\n    }\r\n\r\n    function buyImplementation(address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount, uint8 _v, bytes32 _r, bytes32 _s) private returns (bool) {\r\n        // check the signature\r\n        bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount );\r\n        address signer = ecrecover(hash, _v, _r, _s);\r\n\t\t\r\n\t\trequire( isKycSigner[signer], \"isKycSigner[signer]\");\r\n        \r\n\t\tuint256 totalPayed = alreadyPayed[_buyerId].add(msg.value);\r\n\t\trequire(totalPayed <= _maxAmount);\r\n\t\talreadyPayed[_buyerId] = totalPayed;\r\n\t\t\r\n\t\temit KycVerified(signer, _buyerAddress, _buyerId, _maxAmount);\r\n\t\treturn releaseTokensTo(_buyerAddress);\r\n\r\n    }\r\n    \r\n    function hasher (address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount) public view returns ( bytes32 hash ) {\r\n        hash = keccak256(abi.encodePacked(\"Atomax authorization:\", this, _buyerAddress, _buyerId, _maxAmount));\r\n    }\r\n}\r\n\r\ncontract CoinCrowdReservedContract is AtomaxKyc {\r\n    using SafeMath for uint256;\r\n    \r\n    tokenInterface public xcc;\r\n    TokedoDaicoInterface public tokenSaleContract;\r\n    \r\n    mapping (address => uint256) public tkd_amount;\r\n    \r\n    constructor(address _xcc, address _tokenSaleAddress) public {\r\n        xcc = tokenInterface(_xcc);\r\n        tokenSaleContract = TokedoDaicoInterface(_tokenSaleAddress);\r\n    } \r\n\r\n    function releaseTokensTo(address _buyer) internal returns(bool) {\r\n        require ( msg.sender == tx.origin, \"msg.sender == tx.orgin\" );\r\n\t\t\r\n\t\tuint256 xcc_amount = xcc.balanceOf(msg.sender);\r\n\t\trequire( xcc_amount > 0, \"xcc_amount > 0\" );\r\n\t\t\r\n\t\txcc.originBurn(xcc_amount);\r\n\t\ttokenSaleContract.sendTokens(_buyer, xcc_amount);\r\n\t\t\r\n\t\tif ( msg.value > 0 ) msg.sender.transfer(msg.value);\r\n\t\t\r\n        return true;\r\n    }\r\n    \r\n    modifier onlyTokenSaleOwner() {\r\n        require(msg.sender == tokenSaleContract.owner() );\r\n        _;\r\n    }\r\n    \r\n    function withdrawTokens(address tknAddr, address to, uint256 value) public onlyTokenSaleOwner returns (bool) { //emergency function\r\n        return tokenInterface(tknAddr).transfer(to, value);\r\n    }\r\n    \r\n    function withdraw(address to, uint256 value) public onlyTokenSaleOwner { //emergency function\r\n        to.transfer(value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKycSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"alreadyPayed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyerAddress\",\"type\":\"address\"},{\"name\":\"_buyerId\",\"type\":\"bytes32\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"hasher\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenSaleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tknAddr\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tkd_amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerId\",\"type\":\"bytes32\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xcc\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_xcc\",\"type\":\"address\"},{\"name\":\"_tokenSaleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"KycVerified\",\"type\":\"event\"}]","ContractName":"CoinCrowdReservedContract","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004d829f8c92a6691c56300d020c9e0db984cfe2ba0000000000000000000000008b850e007736b24f7a81ad776d3e7e0a5c6df4d7","Library":"","SwarmSource":"bzzr://52a376f0b4feb7f7453edae5536660199d6c9e2fe696424185cb2f2c0207a3d2"}]}