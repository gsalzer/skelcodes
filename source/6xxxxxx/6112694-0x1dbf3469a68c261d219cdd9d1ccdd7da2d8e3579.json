{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// Zethr Token Bankroll interface\r\ncontract ZethrTokenBankroll{\r\n    // Game request token transfer to player \r\n    function gameRequestTokens(address target, uint tokens) public;\r\n}\r\n\r\n// Zether Main Bankroll interface\r\ncontract ZethrMainBankroll{\r\n    function gameGetTokenBankrollList() public view returns (address[7]);\r\n}\r\n\r\n// Zethr main contract interface\r\ncontract ZethrInterface{\r\n    function withdraw() public;\r\n}\r\n\r\n// Library for figuring out the \"tier\" (1-7) of a dividend rate\r\nlibrary ZethrTierLibrary{\r\n    uint constant internal magnitude = 2**64;\r\n    function getTier(uint divRate) internal pure returns (uint){\r\n        // Tier logic \r\n        // Returns the index of the UsedBankrollAddresses which should be used to call into to withdraw tokens \r\n        \r\n        // We can divide by magnitude\r\n        // Remainder is removed so we only get the actual number we want\r\n        uint actualDiv = divRate; \r\n        if (actualDiv >= 30){\r\n            return 6;\r\n        } else if (actualDiv >= 25){\r\n            return 5;\r\n        } else if (actualDiv >= 20){\r\n            return 4;\r\n        } else if (actualDiv >= 15){\r\n            return 3;\r\n        } else if (actualDiv >= 10){\r\n            return 2; \r\n        } else if (actualDiv >= 5){\r\n            return 1;\r\n        } else if (actualDiv >= 2){\r\n            return 0;\r\n        } else{\r\n            // Impossible\r\n            revert(); \r\n        }\r\n    }\r\n}\r\n \r\n// Contract that contains the functions to interact with the bankroll system\r\ncontract ZethrBankrollBridge{\r\n    // Must have an interface with the main Zethr token contract \r\n    ZethrInterface Zethr;\r\n   \r\n    // Store the bankroll addresses \r\n    // address[0] is main bankroll \r\n    // address[1] is tier1: 2-5% \r\n    // address[2] is tier2: 5-10, etc\r\n    address[7] UsedBankrollAddresses; \r\n\r\n    // Mapping for easy checking\r\n    mapping(address => bool) ValidBankrollAddress;\r\n    \r\n    // Set up the tokenbankroll stuff \r\n    function setupBankrollInterface(address ZethrMainBankrollAddress) internal {\r\n        // Get the bankroll addresses from the main bankroll\r\n        UsedBankrollAddresses = ZethrMainBankroll(ZethrMainBankrollAddress).gameGetTokenBankrollList();\r\n        for(uint i=0; i<7; i++){\r\n            ValidBankrollAddress[UsedBankrollAddresses[i]] = true;\r\n        }\r\n    }\r\n    \r\n    // Require a function to be called from a *token* bankroll \r\n    modifier fromBankroll(){\r\n        require(ValidBankrollAddress[msg.sender], \"msg.sender should be a valid bankroll\");\r\n        _;\r\n    }\r\n    \r\n    // Request a payment in tokens to a user FROM the appropriate tokenBankroll \r\n    // Figure out the right bankroll via divRate \r\n    function RequestBankrollPayment(address to, uint tokens, uint userDivRate) internal {\r\n        uint tier = ZethrTierLibrary.getTier(userDivRate);\r\n        address tokenBankrollAddress = UsedBankrollAddresses[tier];\r\n        ZethrTokenBankroll(tokenBankrollAddress).gameRequestTokens(to, tokens);\r\n    }\r\n}\r\n\r\n// Contract that contains functions to move divs to the main bankroll\r\ncontract ZethrShell is ZethrBankrollBridge{\r\n    \r\n    // Dump ETH balance to main bankroll \r\n    function WithdrawToBankroll() public {\r\n        address(UsedBankrollAddresses[0]).transfer(address(this).balance);\r\n    }\r\n    \r\n    // Dump divs and dump ETH into bankroll \r\n    function WithdrawAndTransferToBankroll() public {\r\n        Zethr.withdraw();\r\n        WithdrawToBankroll();\r\n    }\r\n}\r\n\r\n// Zethr game data setup\r\n// Includes all necessary to run with Zethr \r\ncontract Zethroll is ZethrShell {\r\n  using SafeMath for uint;\r\n\r\n  // Makes sure that player profit can't exceed a maximum amount,\r\n  //  that the bet size is valid, and the playerNumber is in range.\r\n  modifier betIsValid(uint _betSize, uint _playerNumber, uint divRate) {\r\n     require(  calculateProfit(_betSize, _playerNumber) < getMaxProfit(divRate)\r\n             && _betSize >= minBet\r\n             && _playerNumber >= minNumber\r\n             && _playerNumber <= maxNumber);\r\n    _;\r\n  }\r\n\r\n  // Requires game to be currently active\r\n  modifier gameIsActive {\r\n    require(gamePaused == false);\r\n    _;\r\n  }\r\n\r\n  // Requires msg.sender to be owner\r\n  modifier onlyOwner {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  // Constants\r\n  uint constant private MAX_INT = 2 ** 256 - 1;\r\n  uint constant public maxProfitDivisor = 1000000;\r\n  uint constant public maxNumber = 100;\r\n  uint constant public minNumber = 2;\r\n  uint constant public houseEdgeDivisor = 1000;\r\n\r\n  // Configurables\r\n  bool public gamePaused;\r\n\r\n  address public owner;\r\n\r\n  mapping (uint => uint) public contractBalance;\r\n  mapping (uint => uint) public maxProfit;\r\n  uint public houseEdge;\r\n  uint public maxProfitAsPercentOfHouse;\r\n  uint public minBet = 0;\r\n\r\n  // Trackers\r\n  uint public totalBets;\r\n  uint public totalZTHWagered;\r\n\r\n  // Events\r\n\r\n  // Logs bets + output to web3 for precise 'payout on win' field in UI\r\n  event LogBet(address sender, uint value, uint rollUnder);\r\n\r\n  // Outputs to web3 UI on bet result\r\n  // Status: 0=lose, 1=win, 2=win + failed send, 3=refund, 4=refund + failed send\r\n  event LogResult(address player, uint result, uint rollUnder, uint profit, uint tokensBetted, bool won);\r\n\r\n  // Logs owner transfers\r\n  event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred);\r\n\r\n  // Logs changes in maximum profit\r\n  event MaxProfitChanged(uint _oldMaxProfit, uint _newMaxProfit);\r\n\r\n  // Logs current contract balance\r\n  event CurrentContractBalance(uint _tokens);\r\n  \r\n  constructor (address ZethrMainBankrollAddress) public {\r\n    setupBankrollInterface(ZethrMainBankrollAddress);\r\n\r\n    // Owner is deployer\r\n    owner = msg.sender;\r\n\r\n    // Init 990 = 99% (1% houseEdge)\r\n    houseEdge = 990;\r\n\r\n    // The maximum profit from each bet is 10% of the contract balance.\r\n    ownerSetMaxProfitAsPercentOfHouse(10000);\r\n\r\n    // Init min bet (1 ZTH)\r\n    ownerSetMinBet(1e18);\r\n  }\r\n\r\n  // Returns a random number using a specified block number\r\n  // Always use a FUTURE block number.\r\n  function maxRandom(uint blockn, address entropy) public view returns (uint256 randomNumber) {\r\n    return uint256(keccak256(\r\n        abi.encodePacked(\r\n        blockhash(blockn),\r\n        entropy)\r\n      ));\r\n  }\r\n\r\n  // Random helper\r\n  function random(uint256 upper, uint256 blockn, address entropy) public view returns (uint256 randomNumber) {\r\n    return maxRandom(blockn, entropy) % upper;\r\n  }\r\n\r\n  // Calculate the maximum potential profit\r\n  function calculateProfit(uint _initBet, uint _roll)\r\n    private\r\n    view\r\n    returns (uint)\r\n  {\r\n    return ((((_initBet * (100 - (_roll.sub(1)))) / (_roll.sub(1)) + _initBet)) * houseEdge / houseEdgeDivisor) - _initBet;\r\n  }\r\n\r\n  // I present a struct which takes only 20k gas\r\n  struct playerRoll{\r\n    uint192 tokenValue; // Token value in uint \r\n    uint48 blockn;      // Block number 48 bits \r\n    uint8 rollUnder;    // Roll under 8 bits\r\n    uint8 divRate;      // Divrate, 8 bits \r\n  }\r\n\r\n  // Mapping because a player can do one roll at a time\r\n  mapping(address => playerRoll) public playerRolls;\r\n\r\n  // The actual roll function\r\n  function _playerRollDice(uint _rollUnder, TKN _tkn, uint userDivRate) private\r\n    gameIsActive\r\n    betIsValid(_tkn.value, _rollUnder, userDivRate)\r\n  {\r\n    require(_tkn.value < ((2 ** 192) - 1));   // Smaller than the storage of 1 uint192;\r\n    require(block.number < ((2 ** 48) - 1));  // Current block number smaller than storage of 1 uint48\r\n    require(userDivRate < (2 ** 8 - 1)); // This should never throw \r\n    // Note that msg.sender is the Token Contract Address\r\n    // and \"_from\" is the sender of the tokens\r\n\r\n    playerRoll memory roll = playerRolls[_tkn.sender];\r\n\r\n    // Cannot bet twice in one block \r\n    require(block.number != roll.blockn);\r\n\r\n    // If there exists a roll, finish it\r\n    if (roll.blockn != 0) {\r\n      _finishBet(_tkn.sender);\r\n    }\r\n\r\n    // Set struct block number, token value, and rollUnder values\r\n    roll.blockn = uint48(block.number);\r\n    roll.tokenValue = uint192(_tkn.value);\r\n    roll.rollUnder = uint8(_rollUnder);\r\n    roll.divRate = uint8(userDivRate);\r\n\r\n    // Store the roll struct - 20k gas.\r\n    playerRolls[_tkn.sender] = roll;\r\n\r\n    // Provides accurate numbers for web3 and allows for manual refunds\r\n    emit LogBet(_tkn.sender, _tkn.value, _rollUnder);\r\n                 \r\n    // Increment total number of bets\r\n    totalBets += 1;\r\n\r\n    // Total wagered\r\n    totalZTHWagered += _tkn.value;\r\n  }\r\n\r\n  // Finished the current bet of a player, if they have one\r\n  function finishBet() public\r\n    gameIsActive\r\n    returns (uint)\r\n  {\r\n    return _finishBet(msg.sender);\r\n  }\r\n\r\n  /*\r\n   * Pay winner, update contract balance\r\n   * to calculate new max bet, and send reward.\r\n   */\r\n  function _finishBet(address target) private returns (uint){\r\n    playerRoll memory roll = playerRolls[target];\r\n    require(roll.tokenValue > 0); // No re-entracy\r\n    require(roll.blockn != block.number);\r\n    // If the block is more than 255 blocks old, we can't get the result\r\n    // Also, if the result has already happened, fail as well\r\n    uint result;\r\n    if (block.number - roll.blockn > 255) {\r\n      result = 1000; // Cant win \r\n    } else {\r\n      // Grab the result - random based ONLY on a past block (future when submitted)\r\n      result = random(100, roll.blockn, target) + 1;\r\n    }\r\n\r\n    uint rollUnder = roll.rollUnder;\r\n\r\n    if (result < rollUnder) {\r\n      // Player has won!\r\n\r\n      // Safely map player profit\r\n      uint profit = calculateProfit(roll.tokenValue, rollUnder);\r\n      uint mProfit = getMaxProfit(roll.divRate);\r\n        if (profit > mProfit){\r\n            profit = mProfit;\r\n        }\r\n\r\n      // Safely reduce contract balance by player profit\r\n      subContractBalance(roll.divRate, profit);\r\n\r\n      emit LogResult(target, result, rollUnder, profit, roll.tokenValue, true);\r\n\r\n      // Update maximum profit\r\n      setMaxProfit(roll.divRate);\r\n\r\n      // Prevent re-entracy memes\r\n      playerRolls[target] = playerRoll(uint192(0), uint48(0), uint8(0), uint8(0));\r\n\r\n      // Transfer profit plus original bet\r\n      RequestBankrollPayment(target, profit + roll.tokenValue, roll.divRate);\r\n      return result;\r\n\r\n    } else {\r\n      /*\r\n      * Player has lost\r\n      * Update contract balance to calculate new max bet\r\n      */\r\n      emit LogResult(target, result, rollUnder, profit, roll.tokenValue, false);\r\n\r\n      /*\r\n      *  Safely adjust contractBalance\r\n      *  SetMaxProfit\r\n      */\r\n      addContractBalance(roll.divRate, roll.tokenValue);\r\n     \r\n      playerRolls[target] = playerRoll(uint192(0), uint48(0), uint8(0), uint8(0));\r\n      // No need to actually delete player roll here since player ALWAYS loses \r\n      // Saves gas on next buy \r\n\r\n      // Update maximum profit\r\n      setMaxProfit(roll.divRate);\r\n      \r\n      return result;\r\n    }\r\n  }\r\n\r\n  // TKN struct\r\n  struct TKN {address sender; uint value;}\r\n\r\n  // Token fallback to bet or deposit from bankroll\r\n  function execute(address _from, uint _value, uint userDivRate, bytes _data) public fromBankroll gameIsActive returns (bool) {\r\n      TKN memory _tkn;\r\n      _tkn.sender = _from;\r\n      _tkn.value = _value;\r\n      uint8 chosenNumber = uint8(_data[0]);\r\n      _playerRollDice(chosenNumber, _tkn, userDivRate);\r\n\r\n    return true;\r\n  }\r\n\r\n  // Sets max profit\r\n  function setMaxProfit(uint divRate) internal {\r\n    //emit CurrentContractBalance(contractBalance);\r\n    maxProfit[divRate] = (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor;\r\n  }\r\n \r\n  // Gets max profit \r\n  function getMaxProfit(uint divRate) public view returns (uint){\r\n      return (contractBalance[divRate] * maxProfitAsPercentOfHouse) / maxProfitDivisor;\r\n  }\r\n \r\n  // Subtracts from the contract balance tracking var \r\n  function subContractBalance(uint divRate, uint sub) internal {\r\n      contractBalance[divRate] = contractBalance[divRate].sub(sub);\r\n  }\r\n \r\n  // Adds to the contract balance tracking var \r\n  function addContractBalance(uint divRate, uint add) internal {\r\n      contractBalance[divRate] = contractBalance[divRate].add(add);\r\n  }\r\n\r\n  // Only owner adjust contract balance variable (only used for max profit calc)\r\n  function ownerUpdateContractBalance(uint newContractBalance, uint divRate) public\r\n  onlyOwner\r\n  {\r\n    contractBalance[divRate] = newContractBalance;\r\n  }\r\n  \r\n  // An EXTERNAL update of tokens should be handled here \r\n  // This is due to token allocation \r\n  // The game should handle internal updates itself (e.g. tokens are betted)\r\n  function bankrollExternalUpdateTokens(uint divRate, uint newBalance) public fromBankroll {\r\n      contractBalance[divRate] = newBalance;\r\n      setMaxProfit(divRate);\r\n  }\r\n\r\n  // Only owner address can set maxProfitAsPercentOfHouse\r\n  function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public\r\n  onlyOwner\r\n  {\r\n    // Restricts each bet to a maximum profit of 20% contractBalance\r\n    require(newMaxProfitAsPercent <= 200000);\r\n    maxProfitAsPercentOfHouse = newMaxProfitAsPercent;\r\n    setMaxProfit(2);\r\n    setMaxProfit(5);\r\n    setMaxProfit(10);\r\n    setMaxProfit(15);\r\n    setMaxProfit(20);\r\n    setMaxProfit(25);\r\n    setMaxProfit(33);\r\n  }\r\n\r\n  // Only owner address can set minBet\r\n  function ownerSetMinBet(uint newMinimumBet) public\r\n  onlyOwner\r\n  {\r\n    minBet = newMinimumBet;\r\n  }\r\n\r\n  // Only owner address can set emergency pause #1\r\n  function ownerPauseGame(bool newStatus) public\r\n  onlyOwner\r\n  {\r\n    gamePaused = newStatus;\r\n  }\r\n\r\n  // Only owner address can set owner address\r\n  function ownerChangeOwner(address newOwner) public \r\n  onlyOwner\r\n  {\r\n    owner = newOwner;\r\n  }\r\n\r\n  // Only owner address can selfdestruct - emergency\r\n  function ownerkill() public\r\n  onlyOwner\r\n  {\r\n\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalZTHWagered\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawAndTransferToBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitAsPercentOfHouse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"maxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxProfitDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxProfitAsPercent\",\"type\":\"uint256\"}],\"name\":\"ownerSetMaxProfitAsPercentOfHouse\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockn\",\"type\":\"uint256\"},{\"name\":\"entropy\",\"type\":\"address\"}],\"name\":\"maxRandom\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContractBalance\",\"type\":\"uint256\"},{\"name\":\"divRate\",\"type\":\"uint256\"}],\"name\":\"ownerUpdateContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumBet\",\"type\":\"uint256\"}],\"name\":\"ownerSetMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newStatus\",\"type\":\"bool\"}],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawToBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"userDivRate\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"divRate\",\"type\":\"uint256\"}],\"name\":\"getMaxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playerRolls\",\"outputs\":[{\"name\":\"tokenValue\",\"type\":\"uint192\"},{\"name\":\"blockn\",\"type\":\"uint48\"},{\"name\":\"rollUnder\",\"type\":\"uint8\"},{\"name\":\"divRate\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerkill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdge\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseEdgeDivisor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"divRate\",\"type\":\"uint256\"},{\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"bankrollExternalUpdateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"contractBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"upper\",\"type\":\"uint256\"},{\"name\":\"blockn\",\"type\":\"uint256\"},{\"name\":\"entropy\",\"type\":\"address\"}],\"name\":\"random\",\"outputs\":[{\"name\":\"randomNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ZethrMainBankrollAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"}],\"name\":\"LogBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rollUnder\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"profit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensBetted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"won\",\"type\":\"bool\"}],\"name\":\"LogResult\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"SentToAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"AmountTransferred\",\"type\":\"uint256\"}],\"name\":\"LogOwnerTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldMaxProfit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_newMaxProfit\",\"type\":\"uint256\"}],\"name\":\"MaxProfitChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"CurrentContractBalance\",\"type\":\"event\"}]","ContractName":"Zethroll","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006e379098588ee5b8b8e709dfd66dab1772a38038","Library":"","SwarmSource":"bzzr://64261383bec284160359de35ea50d36d79db5d372a869bfe9be2840572da89aa"}]}