{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract EthGods {\r\n\r\n    // imported contracts\r\n    \r\n    EthGodsName private eth_gods_name;\r\n    function set_eth_gods_name_contract_address(address eth_gods_name_contract_address) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        eth_gods_name = EthGodsName(eth_gods_name_contract_address);\r\n        return true;\r\n    }\r\n\r\n    EthGodsDice private eth_gods_dice;\r\n    function set_eth_gods_dice_contract_address(address eth_gods_dice_contract_address) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        eth_gods_dice = EthGodsDice(eth_gods_dice_contract_address);\r\n        return true;\r\n    }\r\n    \r\n    // end of imported contracts\r\n \r\n \r\n     // start of database\r\n    \r\n    //contract information & administration\r\n    bool private contract_created; // in case constructor logic change in the future\r\n    address private contract_address; //shown at the top of the home page\r\n    string private contact_email = \"ethgods@gmail.com\";\r\n    string private official_url = \"swarm-gateways.net/bzz:/ethgods.eth\";\r\n\r\n    address private  admin; // public when testing\r\n    address private controller1 = 0xcA5A9Db0EF9a0Bf5C38Fc86fdE6CB897d9d86adD; // controller can change admin at once; \r\n    address private controller2 = 0x8396D94046a099113E5fe5CBad7eC95e96c2B796; // controller can change admin at once; \r\n\r\n    address private v_god = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;\r\n    uint private block_hash_duration = 255; // can't get block hash, after 256 blocks, adjustable\r\n    \r\n\r\n    // god\r\n    struct god {\r\n        uint god_id;\r\n        uint level;\r\n        uint exp;\r\n        uint pet_type;// 12 animals or zodiacs\r\n        uint pet_level;   \r\n        uint listed; // 0 not a god, 1 - ... rank_score in god list\r\n        uint invite_price;\r\n        uint free_rounds; // to check if has used free dice in this round\r\n        uint paid_rounds; // to check if has paid for extra dice in this round\r\n        bool hosted_pray; // auto waitlist, when enlisted. others can invite, once hosted pray\r\n        uint bid_eth; // bid to host pray\r\n        \r\n        uint credit; // gained from the amulet invitation spending of invited fellows\r\n        uint count_amulets_generated;\r\n        uint first_amulet_generated;\r\n        uint count_amulets_at_hand;\r\n        uint count_amulets_selling;\r\n        uint amulets_start_id;\r\n        uint amulets_end_id;\r\n        \r\n        uint count_token_orders;\r\n        uint first_active_token_order;\r\n\r\n        uint last_ticket_number;\r\n        uint count_tickets;\r\n\r\n        uint inviter_id; // who invited this fellow to this world\r\n        uint count_gods_invited; // gods invited to this game by this god.\r\n        \r\n        \r\n    }\r\n    uint private count_gods = 0; // Used when generating id for a new player, \r\n    mapping(address => god) private gods; // everyone is a god\r\n    mapping(uint => address) private gods_address; // gods' address => god_id\r\n\r\n    uint [] private listed_gods; // id of listed gods\r\n    uint private max_listed_gods = 10000; // adjustable\r\n\r\n    uint private initial_invite_price = 0.02 ether; // grows with each invitation for this god\r\n    uint private invite_price_increase = 0.02 ether; // grows by this amount with each invitation\r\n    uint private max_invite_price = 1000 ether; // adjustable\r\n    uint private max_extra_eth = 0.001 ether; // adjustable\r\n\r\n    uint private list_level = 10; // start from level 10\r\n    uint private max_gas_price = 100000000000; // 100 gwei for invite and pray, adjustable\r\n    \r\n    // amulet\r\n    struct amulet {\r\n        uint god_id;\r\n        address owner;\r\n        uint level;\r\n        uint bound_start_block;// can't sell, if just got\r\n        uint start_selling_block; // can't bind & use in pk, if selling\r\n        uint price; // set to 0, when withdraw from selling or bought\r\n    }\r\n    uint private count_amulets = 0; \r\n    mapping(uint => amulet) private amulets; // public when testing\r\n    uint private bound_duration = 9000; // once bought, wait a while before sell it again, adjustable\r\n    uint private order_duration = 20000; // valid for about 3 days, then not to show to public in selling amulets/token orders, but still show in my_selling amulets/token orders. adjustable\r\n\r\n    // pray\r\n    address private pray_host_god; // public when testing\r\n    bool private pray_reward_top100; // if hosted by new god, reward top 100 gods egst\r\n    uint private pray_start_block; // public when testing\r\n    bool private rewarded_pray_winners = false;\r\n\r\n    uint private count_hosted_gods; // gods hosted pray (event started). If less than bidding gods, there are new gods waiting to host pray, \r\n    mapping (uint => address) private bidding_gods; // every listed god and bid to host pray\r\n    uint private initializer_reward = 60; // reward the god who burned gas to send pray rewards to community, adjustable\r\n    uint private double_egst_fee = 0.006 ether; // adjustable\r\n    \r\n    mapping(uint => uint) private max_winners;  // max winners for each prize  \r\n    uint private round_duration = 6666; // 6000, 600 in CBT, 60 in dev, adjustable\r\n\r\n    // ticket\r\n    struct ticket {\r\n        address owner;\r\n        uint block_number;\r\n        bytes32 block_hash;\r\n        uint new_ticket_number;\r\n        uint dice_result;\r\n    }\r\n    uint private count_tickets;\r\n    mapping (uint => ticket) private tickets;\r\n    uint private used_tickets;\r\n\r\n    uint private max_show_tickets = 20; //  public when testing\r\n\r\n    mapping(uint => uint) private pk_positions; // public when testing\r\n    mapping(uint => uint) private count_listed_winners; // count for 5 prizes, public in testing\r\n    mapping (uint => mapping(uint => address)) private listed_winners; // winners for 5 prizes\r\n\r\n    bool private reEntrancyMutex = false; // for sendnig eth to msg.sender\r\n    \r\n    uint private pray_egses = 0; // lottery treasury\r\n    uint private pray_egst = 0;  // lottery treasury\r\n    uint private reward_pool_egses = 0; // 10% of pray_egses, for top 3 winners\r\n    uint private reward_pool_egst = 0; // 10% of pray_egst, for EGST floor winners\r\n\r\n    mapping(address => uint) egses_balances;\r\n        \r\n\r\n    // eth_gods_token (EGST)\r\n    string public name = \"EthGodsToken\";\r\n    string public symbol = \"EGST\";\r\n    uint8 public constant decimals = 18; //same as ethereum\r\n    uint private _totalSupply;\r\n    mapping(address => uint) balances; // bought or gained from pray or revenue share\r\n    mapping(address => mapping(address => uint)) allowed;\r\n  \r\n\r\n    struct token_order {\r\n        uint id;\r\n        uint start_selling_block;\r\n        address seller;\r\n        uint unit_price;\r\n        uint egst_amount;\r\n    }\r\n    uint private count_token_orders = 0;\r\n    mapping (uint => token_order) token_orders;\r\n    uint private first_active_token_order = 0;\r\n\r\n    uint private min_unit_price = 20; // 1 egst min value is 0.0002 ether, adjustable\r\n    uint private max_unit_price = 200; // 1 egst max value is 0.002 ether, adjustable\r\n    uint private max_egst_amount = 1000000 ether; // for create_token_order, adjustable\r\n    uint private min_egst_amount = 0.00001 ether; // for create_token_order, adjustable\r\n \r\n \r\n    //logs\r\n    uint private count_rounds = 0;\r\n    \r\n    struct winner_log { // win a prize and if pk\r\n        address previous_winner;\r\n        uint prize;\r\n        bool pk_result;\r\n        uint ticket_number;\r\n    }\r\n    mapping (uint => uint) private count_rounds_winner_logs;\r\n    mapping(uint => mapping(uint => winner_log)) private winner_logs;\r\n    \r\n    struct change_log {\r\n        uint block_number;\r\n        uint asset_type; // 1 egst, 2 eth_surplus\r\n        \r\n        // egses change reasons:  \r\n            // 1 pray_reward, 2 god_reward for being invited, 3 inviter_reward,\r\n            // 4 admin_deposit to reward_pool, 5 withdraw egses\r\n            // 6 sell amulet, 7 sell egst, 8 withdraw bid\r\n        \r\n        // egst_change reasons: \r\n            // 1 pray_reward, 2 top_gods_reward, \r\n            // 3 create_token_order, 4 withdraw token_order, 5 buy token,  \r\n            // 6 upgrade pet, 7 upgrade amulet, 8 admin_reward\r\n        \r\n        uint reason; // > 10 is buy token unit_price\r\n        uint change_amount;\r\n        uint after_amount;\r\n        address _from;\r\n        address _to;\r\n    }\r\n    mapping (uint => uint) private count_rounds_change_logs;\r\n    mapping(uint => mapping(uint => change_log)) private change_logs;\r\n\r\n    // end of database\r\n  \r\n    \r\n    // start of constructor\r\n    constructor () public {\r\n        require (contract_created == false);\r\n        contract_created = true;\r\n        contract_address = address(this);\r\n        admin = msg.sender;\r\n\r\n        create_god(admin, 0);\r\n        create_god(v_god, 0);\r\n        gods[v_god].level = 10;\r\n        enlist_god(v_god);\r\n        \r\n        max_winners[1] = 1; // 1\r\n        max_winners[2] = 2; // 2\r\n        max_winners[3] = 6; // 6\r\n\r\n        _totalSupply = 6000000 ether;\r\n        pray_egst = 2000 ether;\r\n        balances[admin] = sub(_totalSupply, pray_egst);\r\n  \r\n        initialize_pray();\r\n    }\r\n    \r\n    // destruct for testing contracts. can't destruct since round 3\r\n    function finalize() public {\r\n        require(msg.sender == admin && count_rounds <= 3);\r\n        selfdestruct(admin); \r\n    }\r\n    \r\n\r\n    function () public payable {\r\n        revert ();\r\n    }   \r\n    // end of constructor\r\n     \r\n         \r\n    //start of contract information & administration\r\n    \r\n    function get_controller () public view returns (address, address){\r\n        require (msg.sender == admin || msg.sender == controller1  || msg.sender == controller2);\r\n        return (controller1, controller2);\r\n    }\r\n    \r\n    function set_controller (uint controller_index, address new_controller_address) public returns (bool){\r\n        if (controller_index == 1){\r\n            require(msg.sender == controller2);\r\n            controller1 = new_controller_address;\r\n        } else {\r\n            require(msg.sender == controller1);\r\n            controller2 = new_controller_address;            \r\n        }\r\n        return true;\r\n    }\r\n     \r\n    function set_admin (address new_admin_address) public returns (bool) {\r\n        require (msg.sender == controller1 || msg.sender == controller2);\r\n        // admin don't have game attributes, such as level'\r\n        // no need to transfer egses and egst to new_admin_address\r\n        delete gods[admin];\r\n        delete gods_address[0];\r\n        admin = new_admin_address;\r\n        gods_address[0] = admin;\r\n        gods[admin].god_id = 0;\r\n        return true;\r\n    }  \r\n    \r\n    // update system parameters\r\n    function set_parameters (uint parameter_type, uint new_parameter) public returns (bool){\r\n        require (msg.sender == admin);\r\n        if (parameter_type == 1) {\r\n            // max_pray_duration = new_parameter;\r\n        } else if (parameter_type == 2) {\r\n            // min_pray_duration = new_parameter;\r\n            round_duration = new_parameter;\r\n        } else if (parameter_type == 3) {\r\n            block_hash_duration = new_parameter;\r\n        } else if (parameter_type == 4) {\r\n            double_egst_fee = new_parameter;\r\n        } else if (parameter_type == 5) {\r\n            order_duration = new_parameter;\r\n        } else if (parameter_type == 6) {\r\n            bound_duration = new_parameter;\r\n        } else if (parameter_type == 7) {\r\n            initializer_reward = new_parameter;\r\n        } else if (parameter_type == 8) {\r\n            max_extra_eth = new_parameter;\r\n        } else if (parameter_type == 9) {\r\n            min_unit_price = new_parameter;\r\n        } else if (parameter_type == 10) {\r\n            max_unit_price = new_parameter;\r\n        } else if (parameter_type == 11) {\r\n            max_listed_gods = new_parameter;\r\n        } else if (parameter_type == 12) {\r\n            max_gas_price = new_parameter;\r\n        } else if (parameter_type == 13) {\r\n            max_invite_price = new_parameter;\r\n        } else if (parameter_type == 14) {\r\n            min_egst_amount = new_parameter;\r\n        } else if (parameter_type == 15) {\r\n            max_egst_amount = new_parameter;\r\n        } else if (parameter_type == 16) {\r\n            max_show_tickets = new_parameter;\r\n        } \r\n        return true;\r\n    }  \r\n        \r\n    function set_strings (uint string_type, string new_string) public returns (bool){\r\n        require (msg.sender == admin);\r\n        \r\n        if (string_type == 1){\r\n            official_url = new_string;\r\n        } else if (string_type == 2){\r\n            name = new_string; // egst name\r\n        } else if (string_type == 3){\r\n            symbol = new_string; // egst symbol\r\n        } else if (string_type == 4){\r\n            contact_email = new_string; // egst symbol\r\n        } else if (string_type == 5){\r\n            reEntrancyMutex = false; // repair contract, if blocked somehow in longlong future\r\n        }\r\n        return true;\r\n    } \r\n    \r\n    // reset lottery event, if it's blocked \r\n    function admin_reset_pray() public returns (bool){\r\n        require (msg.sender == admin);\r\n        \r\n        if (pray_start_block > block.number){\r\n            pray_start_block = block.number;\r\n        }  else if (check_event_completed() == true) {\r\n            if (rewarded_pray_winners == false){\r\n                reward_pray_winners();\r\n            } else {\r\n                initialize_pray();\r\n            }\r\n        }\r\n    }\r\n    \r\n    //end of contract information & administration\r\n    \r\n\r\n    function query_contract () public view returns(address, address, address, uint, uint, bool, bool){\r\n        (uint highest_bid, address highest_bidder) = compare_bid_eth(); \r\n        return (admin,\r\n                pray_host_god,\r\n                highest_bidder,\r\n                highest_bid,\r\n                block_hash_duration,\r\n                pray_reward_top100,\r\n                rewarded_pray_winners\r\n               );\r\n    }\r\n    \r\n    function query_contract2 () public view returns (string, string, address, bool){\r\n        return (official_url, contact_email, v_god, reEntrancyMutex);\r\n    }    \r\n                    \r\n    function query_uints () public view returns (uint[32] uints){\r\n        uints[0] = max_invite_price;\r\n        uints[1] = list_level;\r\n        uints[2] = _totalSupply;\r\n        uints[3] = round_duration;\r\n        uints[4] = initializer_reward;\r\n        uints[5] = min_unit_price;\r\n        uints[6] = max_unit_price;\r\n        uints[7] = max_listed_gods;\r\n        uints[8] = max_gas_price;\r\n        uints[9] = min_egst_amount;\r\n        uints[10] = max_egst_amount;\r\n        uints[11] = max_extra_eth;\r\n        uints[12] = pray_start_block;\r\n        uints[13] = pray_egses;\r\n        uints[14] = pray_egst;\r\n        uints[15] = count_rounds;\r\n        uints[16] = count_gods;\r\n        uints[17] = listed_gods.length;\r\n        uints[18] = order_duration;\r\n        uints[19] = bound_duration;\r\n        uints[20] = initial_invite_price;\r\n        uints[21] = invite_price_increase;\r\n        uints[22] = max_invite_price;\r\n        uints[23] = count_amulets;\r\n        uints[24] = count_hosted_gods;\r\n        uints[25] = used_tickets;\r\n        uints[26] = double_egst_fee;\r\n        uints[27] = count_tickets;\r\n        uints[28] = reward_pool_egses;\r\n        uints[29] = reward_pool_egst;\r\n        uints[30] = block.number;\r\n        uints[31] = contract_address.balance;\r\n\r\n        return uints;\r\n    }\r\n    \r\n  \r\n    //end of contract information & administration\r\n\r\n    \r\n    // god related functions: create_god, upgrade_pet, add_exp, invite, enlist\r\n    \r\n    function create_god (address god_address, uint inviter_id) private returns(uint god_id){ // created by the contract // public when testing\r\n        // check if the god is already created\r\n        if (gods[god_address].credit == 0) { // create admin as god[0]\r\n\r\n            god_id = count_gods; // 1st god's id is admin 0\r\n            count_gods = add(count_gods, 1) ;\r\n            gods_address[god_id] = god_address;\r\n            gods[god_address].god_id = god_id;\r\n            gods[god_address].credit = 0.001 ether; // give 0.001 ether credit, so we know this address has a god\r\n                       \r\n            if (god_id > 0 && inviter_id > 0 && inviter_id < count_gods){ // not admin\r\n                set_inviter(inviter_id);\r\n            }\r\n            \r\n            return god_id;\r\n        }\r\n    }\r\n    \r\n    function set_inviter (uint inviter_id) private returns (bool){\r\n        if (inviter_id > 0 && gods_address[inviter_id] != address(0)\r\n        && gods[msg.sender].inviter_id == 0\r\n        && gods[gods_address[inviter_id]].inviter_id != gods[msg.sender].god_id){\r\n            gods[msg.sender].inviter_id = inviter_id;\r\n            address inviter_address = gods_address[inviter_id];\r\n            gods[inviter_address].count_gods_invited = add(gods[inviter_address].count_gods_invited, 1);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function add_exp (address god_address, uint exp_up) private returns(uint new_level, uint new_exp) { // public when testing\r\n        if (god_address == admin){\r\n            return (0,0);\r\n        }\r\n        if (gods[god_address].god_id == 0){\r\n            create_god(god_address, 0);\r\n        }\r\n        new_exp = add(gods[god_address].exp, exp_up);\r\n        uint current_god_level = gods[god_address].level;\r\n        uint level_up_exp;\r\n        new_level = current_god_level;\r\n\r\n        for (uint i=0;i<10;i++){ // if still have extra exp, level up next time\r\n            if (current_god_level < 99){\r\n                level_up_exp = mul(10, add(new_level, 1));\r\n            } else {\r\n                level_up_exp = 1000;\r\n            }\r\n            if (new_exp >= level_up_exp){\r\n                new_exp = sub(new_exp, level_up_exp);\r\n                new_level = add(new_level, 1);\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n\r\n        gods[god_address].exp = new_exp;\r\n\r\n        if(new_level > current_god_level) {\r\n            gods[god_address].level = new_level;\r\n            if (gods[god_address].listed > 0) {\r\n                if (listed_gods.length > 1) {\r\n                    sort_gods(gods[god_address].god_id);\r\n                }\r\n            } else if (new_level >= list_level && listed_gods.length < max_listed_gods) {\r\n                enlist_god(god_address);\r\n            }\r\n        }\r\n        \r\n        return (new_level, new_exp);\r\n    }\r\n\r\n   \r\n    function enlist_god (address god_address) private returns (uint) { // public when testing\r\n        require(gods[god_address].level >= list_level && god_address != admin);\r\n                \r\n        // if the god is not listed yet, enlist and add level requirement for the next enlist\r\n        if (gods[god_address].listed == 0) {\r\n            uint god_id = gods[god_address].god_id;\r\n            if (god_id == 0){\r\n                god_id = create_god(god_address, 0); // get a god_id and set inviter as v god\r\n            }\r\n            gods[god_address].listed = listed_gods.push(god_id); // start from 1, 0 is not listed\r\n            gods[god_address].invite_price = initial_invite_price;\r\n\r\n            list_level = add(list_level, 1);\r\n            bidding_gods[listed_gods.length] = god_address;\r\n            \r\n        }\r\n        return list_level;\r\n    }\r\n    \r\n    function sort_gods_admin(uint god_id) public returns (bool){\r\n        require (msg.sender == admin);\r\n        sort_gods(god_id);\r\n        return true;\r\n    }\r\n\r\n\r\n    // when a listed god level up and is not top 1 of the list, compare power with higher god, if higher than the higher god, swap position\r\n    function sort_gods (uint god_id) private returns (uint){ \r\n        require (god_id > 0);\r\n        uint list_length = listed_gods.length;\r\n        if (list_length > 1) {\r\n            address god_address = gods_address[god_id];\r\n            uint this_god_listed = gods[god_address].listed;\r\n            if (this_god_listed < list_length) {\r\n                uint higher_god_listed = add(this_god_listed, 1);\r\n                uint higher_god_id = listed_gods[sub(higher_god_listed, 1)];\r\n                address higher_god = gods_address[higher_god_id];\r\n                if(gods[god_address].level > gods[higher_god].level\r\n                || (gods[god_address].level == gods[higher_god].level\r\n                    && gods[god_address].exp > gods[higher_god].exp)){\r\n                        listed_gods[sub(this_god_listed, 1)] = higher_god_id;\r\n                        listed_gods[sub(higher_god_listed, 1)] = god_id;\r\n                        gods[higher_god].listed = this_god_listed;\r\n                        gods[god_address].listed = higher_god_listed;\r\n                }\r\n            }\r\n        }\r\n        return gods[god_address].listed;\r\n    }\r\n\r\n\r\n    function invite (uint god_id) public payable returns (uint new_invite_price)  {\r\n        address god_address = gods_address[god_id];\r\n        require(god_id > 0 \r\n                && god_id <= count_gods\r\n                && gods[god_address].hosted_pray == true\r\n                && tx.gasprice <= max_gas_price\r\n                );\r\n\r\n        uint invite_price = gods[god_address].invite_price;\r\n\r\n        require(msg.value >= invite_price); \r\n\r\n        if (add(invite_price, invite_price_increase) <= max_invite_price) {\r\n            gods[god_address].invite_price = add(invite_price, invite_price_increase);\r\n        }\r\n        \r\n        uint exp_up = div(invite_price, (10 ** 15)); // 1000 exp for each eth\r\n        add_exp(god_address, exp_up);\r\n        add_exp(msg.sender, exp_up);\r\n       \r\n        //generate a new amulet of this god for the inviter\r\n        count_amulets = add(count_amulets, 1);\r\n        amulets[count_amulets].god_id = god_id;\r\n        amulets[count_amulets].owner = msg.sender;\r\n\r\n        gods[god_address].count_amulets_generated = add(gods[god_address].count_amulets_generated, 1);\r\n        if (gods[god_address].count_amulets_generated == 1){\r\n            gods[god_address].first_amulet_generated = count_amulets;\r\n        }\r\n        gods[msg.sender].count_amulets_at_hand = add(gods[msg.sender].count_amulets_at_hand, 1);\r\n        update_amulets_count(msg.sender, count_amulets, true);\r\n\r\n        // invite_price to egses: 60% to pray_egses, 20% to god, 20 to promoter/admin\r\n        pray_egses = add(pray_egses, div(mul(60, invite_price), 100)); \r\n        egses_from_contract(god_address, div(mul(20, invite_price), 100), 2); //2 reward god for being invited\r\n\r\n        reward_inviter(msg.sender, invite_price);\r\n        emit invited_god (msg.sender, god_id);\r\n\r\n        return gods[god_address].invite_price;\r\n    }\r\n    event invited_god (address msg_sender, uint god_id);\r\n    \r\n\r\n    function reward_inviter (address inviter_address, uint invite_price) private returns (bool){\r\n        // the player spending eth also get credit and share\r\n        uint previous_share = 0;\r\n        uint inviter_share = 0;\r\n        uint share_diff;\r\n        address rewarding_inviter = inviter_address;\r\n        \r\n        for (uint i = 0; i < 9; i++){ // max trace 9 layers of inviter\r\n            if (rewarding_inviter != address(0) && rewarding_inviter != admin){ // admin doesn't get reward or credit\r\n                share_diff = 0;\r\n                gods[rewarding_inviter].credit = add(gods[rewarding_inviter].credit, invite_price);\r\n                inviter_share = get_vip_level(rewarding_inviter);\r\n\r\n                if (inviter_share > previous_share) {\r\n                    share_diff = sub(inviter_share, previous_share);\r\n                    if (share_diff > 18) {\r\n                        share_diff = 18;\r\n                    }\r\n                    previous_share = inviter_share;\r\n                }\r\n                \r\n                if (share_diff > 0) {\r\n                    egses_from_contract(rewarding_inviter, div(mul(share_diff, invite_price), 100), 3); // 3 inviter_reward\r\n                }\r\n                \r\n                rewarding_inviter = gods_address[gods[rewarding_inviter].inviter_id]; // get the address of inviter's inviter'\r\n            } else{\r\n                break;\r\n            }\r\n        }\r\n        // invite_price to egses: sub(20%, previous_share) to admin\r\n        share_diff = sub(20, inviter_share); \r\n        egses_from_contract(admin, div(mul(share_diff, invite_price), 100), 2); // remaining goes to admin, 2 god_reward for being invited\r\n        \r\n        return true;\r\n    }\r\n    \r\n\r\n    function upgrade_pet () public returns(bool){\r\n        //use egst to level up pet;\r\n        uint egst_cost = mul(add(gods[msg.sender].pet_level, 1), 10 ether);\r\n        egst_to_contract(msg.sender, egst_cost, 6);// 6 upgrade_pet\r\n        gods[msg.sender].pet_level = add(gods[msg.sender].pet_level, 1);\r\n        add_exp(msg.sender, div(egst_cost, 1 ether));\r\n        pray_egst = add(pray_egst, egst_cost);\r\n\r\n        emit upgradeAmulet(msg.sender, 0, gods[msg.sender].pet_level);\r\n        \r\n        return true;\r\n    }\r\n    event upgradeAmulet (address owner, uint amulet_id, uint new_level);\r\n\r\n    function set_pet_type (uint new_type) public returns (bool){\r\n        if (gods[msg.sender].pet_type != new_type) {\r\n            gods[msg.sender].pet_type = new_type;\r\n            return true;\r\n        }\r\n    }\r\n  \r\n      \r\n    function get_vip_level (address god_address) public view returns (uint vip_level){\r\n        uint inviter_credit = gods[god_address].credit;\r\n        \r\n        if (inviter_credit > 500 ether){\r\n            vip_level = 18;\r\n        } else if (inviter_credit > 200 ether){\r\n            vip_level = 15;\r\n        } else if (inviter_credit > 100 ether){\r\n            vip_level = 12;\r\n        } else if (inviter_credit > 50 ether){\r\n            vip_level = 10;\r\n        } else if (inviter_credit > 20 ether){\r\n            vip_level = 8;\r\n        } else if (inviter_credit > 10 ether){\r\n            vip_level = 6;\r\n        } else if (inviter_credit > 5 ether){\r\n            vip_level = 5;\r\n        } else if (inviter_credit > 2 ether){\r\n            vip_level = 4;\r\n        } else if (inviter_credit > 1 ether){\r\n            vip_level = 3;\r\n        } else if (inviter_credit > 0.5 ether){\r\n            vip_level = 2;\r\n        } else {\r\n            vip_level = 1;\r\n        }\r\n        return vip_level;\r\n    }\r\n\r\n\r\n    // view god's information\r\n    \r\n    function get_god_id (address god_address) public view returns (uint god_id){\r\n        return gods[god_address].god_id;\r\n    }\r\n    \r\n    \r\n    function get_god_address(uint god_id) public view returns (address){\r\n        return gods_address[god_id];\r\n    }\r\n\r\n\r\n    function get_god (uint god_id) public view returns(uint, string, uint, uint, uint, uint, bool) {\r\n        address god_address = gods_address[god_id];\r\n        string memory god_name;\r\n\r\n        god_name = eth_gods_name.get_god_name(god_address);\r\n        if (bytes(god_name).length == 0){\r\n            god_name = \"Unknown\";\r\n        }\r\n\r\n        return (gods[god_address].god_id,\r\n                god_name,\r\n                gods[god_address].level,\r\n                gods[god_address].exp,\r\n                gods[god_address].invite_price,\r\n                gods[god_address].listed,\r\n                gods[god_address].hosted_pray\r\n                );\r\n    }\r\n\r\n    function get_god_info (address god_address) public view returns (uint, uint, uint, uint, uint, uint, uint){\r\n        return (gods[god_address].last_ticket_number,\r\n                gods[god_address].free_rounds,\r\n                gods[god_address].paid_rounds,\r\n                gods[god_address].pet_type,\r\n                gods[god_address].pet_level,\r\n                gods[god_address].bid_eth,\r\n                gods[god_address].count_tickets\r\n                );\r\n    }    \r\n    \r\n    \r\n    function get_my_info () public view returns(uint, uint, uint, uint, uint, uint, uint) { //private information\r\n\r\n        return (gods[msg.sender].god_id,\r\n                egses_balances[msg.sender], //egses\r\n                balances[msg.sender], //egst\r\n                get_vip_level(msg.sender),\r\n                gods[msg.sender].credit, // inviter_credit\r\n                gods[msg.sender].inviter_id,\r\n                gods[msg.sender].count_gods_invited\r\n                );\r\n    }   \r\n\r\n\r\n    function get_my_invited () public view returns (uint[]){\r\n        uint count_elements = 0;\r\n        uint count_gods_invited = gods[msg.sender].count_gods_invited;\r\n\r\n        uint my_id = gods[msg.sender].god_id;\r\n        uint [] memory invited_players = new uint[](count_gods_invited);\r\n        if (count_gods_invited > 0) {\r\n            for (uint i = 1; i <= count_gods; i++){\r\n                if (gods[gods_address[i]].inviter_id == my_id) {\r\n                    invited_players[count_elements] = i;\r\n                    count_elements ++;\r\n                    \r\n                    if (count_elements >= count_gods_invited){\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return invited_players;\r\n    }\r\n\r\n\r\n    function get_listed_gods (uint page_number) public view returns (uint[]){\r\n        \r\n        uint count_listed_gods = listed_gods.length;\r\n        require(count_listed_gods <= mul(page_number, 20));\r\n        \r\n        uint[] memory tempArray = new uint[] (20);\r\n\r\n        if (page_number < 1) {\r\n            page_number = 1;\r\n        } \r\n\r\n        for (uint i = 0; i < 20; i++){\r\n            if(count_listed_gods > add(i, mul(20, sub(page_number, 1)))) {\r\n                tempArray[i] = listed_gods[sub(sub(sub(count_listed_gods, i), 1), mul(20, sub(page_number, 1)))];\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        return tempArray;\r\n    }\r\n\r\n\r\n    // amulets\r\n   \r\n    function upgrade_amulet (uint amulet_id) public returns(uint){\r\n        require(amulets[amulet_id].owner == msg.sender);\r\n        uint egst_cost = mul(add(amulets[amulet_id].level, 1), 10 ether);\r\n        egst_to_contract(msg.sender, egst_cost, 7);// reason 7, upgrade_amulet\r\n        pray_egst = add(pray_egst, egst_cost);\r\n        \r\n        amulets[amulet_id].level = add(amulets[amulet_id].level, 1);\r\n        add_exp(msg.sender, div(egst_cost, 1 ether));\r\n        emit upgradeAmulet(msg.sender, amulet_id, amulets[amulet_id].level);\r\n        \r\n        return amulets[amulet_id].level;\r\n    }\r\n    \r\n    \r\n    function create_amulet_order (uint amulet_id, uint price) public returns (uint) {\r\n        require(msg.sender == amulets[amulet_id].owner\r\n                && amulet_id >= 1 && amulet_id <= count_amulets\r\n                && amulets[amulet_id].start_selling_block == 0\r\n                && add(amulets[amulet_id].bound_start_block, bound_duration) < block.number\r\n                && price > 0);\r\n\r\n        amulets[amulet_id].start_selling_block = block.number;\r\n        amulets[amulet_id].price = price;\r\n        gods[msg.sender].count_amulets_at_hand = sub(gods[msg.sender].count_amulets_at_hand, 1);\r\n        gods[msg.sender].count_amulets_selling = add(gods[msg.sender].count_amulets_selling, 1);\r\n        \r\n        return gods[msg.sender].count_amulets_selling;\r\n\r\n    }\r\n\r\n    function buy_amulet (uint amulet_id) public payable returns (bool) {\r\n        uint price = amulets[amulet_id].price;\r\n        require(msg.value >= price && msg.value < add(price, max_extra_eth)\r\n        && amulets[amulet_id].start_selling_block > 0\r\n        && amulets[amulet_id].owner != msg.sender\r\n        && price > 0);\r\n        \r\n        address seller = amulets[amulet_id].owner;\r\n        amulets[amulet_id].owner = msg.sender;\r\n        amulets[amulet_id].bound_start_block = block.number;\r\n        amulets[amulet_id].start_selling_block = 0;\r\n\r\n        gods[msg.sender].count_amulets_at_hand = add(gods[msg.sender].count_amulets_at_hand, 1);\r\n        update_amulets_count(msg.sender, amulet_id, true);\r\n        gods[seller].count_amulets_selling = sub(gods[seller].count_amulets_selling, 1);\r\n        update_amulets_count(seller, amulet_id, false);\r\n\r\n        egses_from_contract(seller, price, 6); // 6 sell amulet\r\n\r\n        return true;\r\n    }\r\n\r\n    function withdraw_amulet_order (uint amulet_id) public returns (uint){\r\n        // an amulet can only have one order_id, so withdraw amulet_id instead of withdraw order_id, since only amulet_id is shown in amulets_at_hand\r\n        require(msg.sender == amulets[amulet_id].owner\r\n                && amulet_id >= 1 && amulet_id <= count_amulets\r\n                && amulets[amulet_id].start_selling_block > 0);\r\n                \r\n        amulets[amulet_id].start_selling_block = 0;\r\n        gods[msg.sender].count_amulets_at_hand = add(gods[msg.sender].count_amulets_at_hand, 1);\r\n        gods[msg.sender].count_amulets_selling = sub(gods[msg.sender].count_amulets_selling, 1);\r\n\r\n        return gods[msg.sender].count_amulets_selling;\r\n    }\r\n    \r\n    function update_amulets_count (address god_address, uint amulet_id, bool obtained) private returns (uint){\r\n        if (obtained == true){\r\n            if (amulet_id < gods[god_address].amulets_start_id) {\r\n                gods[god_address].amulets_start_id = amulet_id;\r\n            }\r\n        } else {\r\n            if (amulet_id == gods[god_address].amulets_start_id){\r\n                for (uint i = amulet_id; i <= count_amulets; i++){\r\n                    if (amulets[i].owner == god_address && i > amulet_id){\r\n                        gods[god_address].amulets_start_id = i;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return gods[god_address].amulets_start_id;\r\n    }\r\n    \r\n\r\n    function get_amulets_generated (uint god_id) public view returns (uint[]) {\r\n        address god_address = gods_address[god_id];\r\n        uint count_amulets_generated = gods[god_address].count_amulets_generated;\r\n        \r\n        uint [] memory temp_list = new uint[](count_amulets_generated);\r\n        if (count_amulets_generated > 0) {\r\n            uint count_elements = 0;\r\n            for (uint i = gods[god_address].first_amulet_generated; i <= count_amulets; i++){\r\n                if (amulets[i].god_id == god_id){\r\n                    temp_list [count_elements] = i;\r\n                    count_elements++;\r\n                    \r\n                    if (count_elements >= count_amulets_generated){\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return temp_list;\r\n    }\r\n\r\n    \r\n    function get_amulets_at_hand (address god_address) public view returns (uint[]) {\r\n        uint count_amulets_at_hand = gods[god_address].count_amulets_at_hand;\r\n        uint [] memory temp_list = new uint[] (count_amulets_at_hand);\r\n        if (count_amulets_at_hand > 0) {\r\n            uint count_elements = 0;\r\n            for (uint i = gods[god_address].amulets_start_id; i <= count_amulets; i++){\r\n                if (amulets[i].owner == god_address && amulets[i].start_selling_block == 0){\r\n                    temp_list[count_elements] = i;\r\n                    count_elements++;\r\n                    \r\n                    if (count_elements >= count_amulets_at_hand){\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return temp_list;\r\n    }\r\n    \r\n    \r\n    function get_my_amulets_selling () public view returns (uint[]){\r\n\r\n        uint count_amulets_selling = gods[msg.sender].count_amulets_selling;\r\n        uint [] memory temp_list = new uint[] (count_amulets_selling);\r\n        if (count_amulets_selling > 0) {\r\n            uint count_elements = 0;\r\n            for (uint i = gods[msg.sender].amulets_start_id; i <= count_amulets; i++){\r\n                if (amulets[i].owner == msg.sender \r\n                && amulets[i].start_selling_block > 0){\r\n                    temp_list[count_elements] = i;\r\n                    count_elements++;\r\n                    \r\n                    if (count_elements >= count_amulets_selling){\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return temp_list;\r\n    }\r\n\r\n    // to calculate how many pages\r\n    function get_amulet_orders_overview () public view returns(uint){\r\n        uint count_amulets_selling = 0;\r\n        for (uint i = 1; i <= count_amulets; i++){\r\n            if (add(amulets[i].start_selling_block, order_duration) > block.number && amulets[i].owner != msg.sender){\r\n                count_amulets_selling = add(count_amulets_selling, 1);\r\n            }\r\n        }        \r\n        \r\n        return count_amulets_selling; // to show page numbers when getting amulet_orders\r\n    }\r\n\r\n    function get_amulet_orders (uint page_number) public view returns (uint[]){\r\n        uint[] memory temp_list = new uint[] (20);\r\n        uint count_amulets_selling = 0;\r\n        uint count_list_elements = 0;\r\n\r\n        if ((page_number < 1)\r\n            || count_amulets  <= 20) {\r\n            page_number = 1; // chose a page out of range\r\n        }\r\n        uint start_amulets_count = mul(sub(page_number, 1), 20);\r\n\r\n        for (uint i = 1; i <= count_amulets; i++){\r\n            if (add(amulets[i].start_selling_block, order_duration) > block.number && amulets[i].owner != msg.sender){\r\n                \r\n                if (count_amulets_selling <= start_amulets_count) {\r\n                    count_amulets_selling ++;\r\n                }\r\n                if (count_amulets_selling > start_amulets_count){\r\n                    \r\n                    temp_list[count_list_elements] = i;\r\n                    count_list_elements ++;\r\n                    \r\n                    if (count_list_elements >= 20){\r\n                        break;\r\n                    }\r\n                }\r\n                \r\n            }\r\n        }\r\n        \r\n        return temp_list;\r\n    }\r\n    \r\n    \r\n    function get_amulet (uint amulet_id) public view returns(address, string, uint, uint, uint, uint, uint){\r\n        uint god_id = amulets[amulet_id].god_id;\r\n        // address god_address = gods_address[god_id];\r\n        string memory god_name = eth_gods_name.get_god_name(gods_address[god_id]);\r\n        uint god_level = gods[gods_address[god_id]].level;\r\n        uint amulet_level = amulets[amulet_id].level;\r\n        uint start_selling_block = amulets[amulet_id].start_selling_block;\r\n        uint price = amulets[amulet_id].price;\r\n\r\n        return(amulets[amulet_id].owner,\r\n                god_name,\r\n                god_id,\r\n                god_level,\r\n                amulet_level,\r\n                start_selling_block,\r\n                price\r\n              );\r\n    }\r\n\r\n    function get_amulet2 (uint amulet_id) public view returns(uint){\r\n        return amulets[amulet_id].bound_start_block;\r\n    }\r\n\r\n    // end of amulet\r\n    \r\n    // start of pray\r\n    function admin_deposit (uint egst_amount) public payable returns (bool) {\r\n        require (msg.sender == admin);\r\n        if (msg.value > 0){\r\n            pray_egses = add(pray_egses, msg.value);\r\n            egses_from_contract(admin, msg.value, 4); // 4 admin_deposit to reward_pool\r\n        }\r\n        if (egst_amount > 0){\r\n            pray_egst = add(pray_egst, egst_amount);\r\n            egst_to_contract(admin, egst_amount, 4); // 4 admin_deposit to reward_pool            \r\n        }\r\n        return true;\r\n    }\r\n        \r\n    function initialize_pray () private returns (bool){\r\n        if (pray_start_block > 0) { // double safeguard\r\n            require (check_event_completed() == true\r\n            && rewarded_pray_winners == true);\r\n        }\r\n        \r\n        count_rounds = add(count_rounds, 1);\r\n        count_rounds_winner_logs[count_rounds] = 0;\r\n        pray_start_block = block.number;\r\n        rewarded_pray_winners = false;\r\n\r\n        for (uint i = 1; i <= 3; i++){\r\n            pk_positions[i] = max_winners[i]; // pk start from the last slot\r\n\t\t\tcount_listed_winners[i] = 0;\r\n        }\r\n        if (listed_gods.length > count_hosted_gods) {\r\n            // a new god's turn\r\n            count_hosted_gods = add(count_hosted_gods, 1);\r\n            pray_host_god = bidding_gods[count_hosted_gods];\r\n            gods[pray_host_god].hosted_pray = true;\r\n            pray_reward_top100 = true;\r\n        } else {\r\n            //choose highest bidder\r\n            (uint highest_bid, address highest_bidder) = compare_bid_eth();\r\n\r\n            gods[highest_bidder].bid_eth = 0;\r\n            pray_host_god = highest_bidder;\r\n            pray_egses = add(pray_egses, highest_bid);\r\n            pray_reward_top100 = false;\r\n\r\n        }\r\n        \r\n        // set_up reward pool\r\n        reward_pool_egses = div(pray_egses, 10);\r\n        // pray_egses = sub(pray_egses, reward_pool_egses);\r\n\r\n        reward_pool_egst = div(pray_egst, 10);\r\n        pray_egst = sub(pray_egst, reward_pool_egst); // reduce sum for less calculation, burn, if not used\r\n                \r\n        return true;\r\n\r\n    }\r\n\r\n\r\n    function bid_host () public payable returns (bool) {\r\n        require (msg.value > 0 && gods[msg.sender].listed > 0);\r\n        gods[msg.sender].bid_eth = add (gods[msg.sender].bid_eth, msg.value);\r\n\r\n        return true;\r\n    }\r\n    \r\n\r\n    function withdraw_bid () public returns (bool) {\r\n        uint bid_eth = gods[msg.sender].bid_eth;\r\n        require(bid_eth > 0);\r\n        gods[msg.sender].bid_eth = 0;\r\n        egses_from_contract(msg.sender, bid_eth, 8); // 8  withdraw bid\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function create_ticket(address owner_address) private returns (uint) {\r\n        count_tickets = add(count_tickets, 1);\r\n        tickets[count_tickets].block_number = add(block.number, 1);\r\n        tickets[count_tickets].owner = owner_address;\r\n        gods[owner_address].last_ticket_number = count_tickets;\r\n        gods[owner_address].count_tickets = add(gods[owner_address].count_tickets, 1);\r\n        \r\n        return count_tickets;\r\n    }\r\n    \r\n    \r\n    function pray (uint inviter_id) public payable returns (bool){\r\n        require (tx.gasprice <= max_gas_price);\r\n  \r\n        if (gods[msg.sender].credit == 0) {\r\n            create_god(msg.sender, inviter_id);\r\n        }\r\n        \r\n        if (gods[msg.sender].free_rounds >= count_rounds){\r\n            require (msg.value == double_egst_fee);\r\n            \r\n            if (gods[msg.sender].paid_rounds != count_rounds){\r\n                gods[msg.sender].paid_rounds = count_rounds;\r\n            }\r\n            add_exp(msg.sender, 6);\r\n            pray_egses = add(pray_egses, double_egst_fee);\r\n        } else {\r\n            require (msg.value == 0);\r\n            gods[msg.sender].free_rounds = count_rounds; // 1 free dice in each round\r\n        }\r\n        \r\n        create_ticket(msg.sender);\r\n        \r\n        if (used_tickets < count_tickets) {\r\n\r\n            ticket storage using_ticket = tickets[add(used_tickets, 1)];\r\n            uint block_number = using_ticket.block_number;\r\n\r\n            if (block_number < block.number) {// can only get previous block hash\r\n                used_tickets = add(used_tickets, 1);\r\n                address waiting_prayer = using_ticket.owner;\r\n                \r\n                if (add(block_number, block_hash_duration) <= block.number) {// this ticket should have a valid block_number to generate block hash\r\n                    using_ticket.new_ticket_number = create_ticket(waiting_prayer); //void this ticket and create a new ticket\r\n                } else {// throw dice\r\n                    bytes32 block_hash = keccak256(abi.encodePacked(blockhash(block_number)));\r\n                    using_ticket.block_hash = block_hash;\r\n    \r\n                    uint dice_result = eth_gods_dice.throw_dice (block_hash)[0];\r\n                    using_ticket.dice_result = dice_result;\r\n\r\n                    if (dice_result >= 1 && dice_result <= 3){\r\n                        set_winner(dice_result, used_tickets);\r\n                    } else {\r\n                        add_exp(waiting_prayer, 6); // add 6 exp and no pk for lucky stars\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n        \r\n   \r\n        add_exp(pray_host_god, 1);\r\n\r\n        if (check_event_completed() == true && rewarded_pray_winners == false) {\r\n            reward_pray_winners();\r\n        }\r\n\r\n        return true;\r\n    }\r\n    \r\n\r\n    function set_winner (uint prize, uint ticket_number) private returns (uint){\r\n\r\n        count_rounds_winner_logs[count_rounds] = add(count_rounds_winner_logs[count_rounds], 1);\r\n        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].ticket_number = ticket_number;\r\n        winner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].prize = prize;\r\n        address waiting_prayer =  tickets[ticket_number].owner;\r\n        bytes32 block_hash = tickets[ticket_number].block_hash;\r\n\r\n        if (count_listed_winners[prize] >= max_winners[prize]){ // winner_list maxed, so the new prayer challenge previous winners\r\n           \tuint pk_position = pk_positions[prize];\r\n        \taddress previous_winner = listed_winners[prize][pk_position];  \r\n\r\n            bool pk_result = pk(waiting_prayer, previous_winner, block_hash);\r\n\r\n\t\t\twinner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].pk_result = pk_result;\r\n\t\t\twinner_logs[count_rounds][count_rounds_winner_logs[count_rounds]].previous_winner = previous_winner;\r\n            \r\n            if (pk_result == true) {\r\n                listed_winners[prize][pk_position] = waiting_prayer; // attacker defeat defender\r\n            }\r\n            if (prize > 1) { // no need to change pk_pos for champion\r\n                if (pk_positions[prize] > 1){\r\n                    pk_positions[prize] = sub(pk_positions[prize], 1);\r\n                } else {\r\n                    pk_positions[prize] = max_winners[prize];\r\n                }               \r\n            }\r\n        } else {\r\n            count_listed_winners[prize] = add(count_listed_winners[prize], 1);\r\n            listed_winners[prize][count_listed_winners[prize]] = waiting_prayer;\r\n        }\r\n     \r\n        return count_listed_winners[prize];\r\n    }\r\n\r\n    function reward_pray_winners () private returns (bool){\r\n        require (check_event_completed() == true && rewarded_pray_winners == false);\r\n\r\n        egst_from_contract(pray_host_god, mul(div(reward_pool_egst, 100), 50), 1); // 1 pray_reward for hosting event\r\n\r\n        uint this_reward_egses = 0; // this reward for a specific winner\r\n        uint this_reward_egst = 0;  // this reward for a specific winner\r\n        \r\n        for (uint i = 1; i<=3; i++){\r\n            if (i == 1) {\r\n                this_reward_egses = mul(div(reward_pool_egses, 100), 60);\r\n            } else if (i == 2){\r\n                this_reward_egses = mul(div(reward_pool_egses, 100), 20);\r\n            } else if (i == 3){\r\n                this_reward_egst = mul(div(reward_pool_egst, 100), 8);\r\n            } \r\n            \r\n            for (uint reward_i = 1; reward_i <= count_listed_winners[i]; reward_i++){\r\n                address rewarding_winner = listed_winners[i][reward_i];\r\n\r\n                if (this_reward_egses > 0 ) {\r\n                    egses_from_contract(rewarding_winner, this_reward_egses, 1); // 1 pray_reward\r\n                    pray_egses = sub(pray_egses, this_reward_egses);\r\n                } else if (this_reward_egst > 0) {\r\n                    if (gods[rewarding_winner].paid_rounds < count_rounds){\r\n                        egst_from_contract(rewarding_winner, this_reward_egst, 1); // 1 pray_reward\r\n                    } else { \r\n                        egst_from_contract(rewarding_winner, mul(this_reward_egst, 2), 1); // 1 pray_reward\r\n                        _totalSupply = add(_totalSupply, this_reward_egst);\r\n\r\n                        if (gods[rewarding_winner].paid_rounds > count_rounds){// just in case of any error\r\n                            gods[rewarding_winner].paid_rounds = count_rounds;\r\n                        } \r\n                    }\r\n                }  \r\n\r\n            }\r\n\r\n        }\r\n\r\n        // burn egst, 2% fixed amount, plus wasted EGST floor prizes\r\n        uint burn_egst = div(reward_pool_egst, 50);\r\n        if (count_listed_winners[3] < max_winners[3]) {\r\n            burn_egst = add(burn_egst,  mul(this_reward_egst, sub(max_winners[3], count_listed_winners[3]))); \r\n        }\r\n        _totalSupply = sub(_totalSupply, burn_egst);\r\n                    \r\n        if(pray_reward_top100 == true) {\r\n            reward_top_gods();\r\n        }\r\n            \r\n        // a small gift of exp & egst to the god who burned gas to send rewards to the community\r\n        egst_from_contract(msg.sender, mul(initializer_reward, 1 ether), 1); // 1 pray_reward\r\n        _totalSupply = add(_totalSupply, mul(initializer_reward, 1 ether));  \r\n        add_exp(msg.sender, initializer_reward);\r\n\r\n        rewarded_pray_winners = true;\r\n        initialize_pray();\r\n        return true;\r\n    }\r\n\r\n\r\n    // more listed gods, more reward to the top gods, highest reward 600 egst\r\n    function reward_top_gods () private returns (bool){ // public when testing\r\n        \r\n        uint count_listed_gods = listed_gods.length;\r\n        uint last_god_index;\r\n        \r\n        if (count_listed_gods > 100) {\r\n            last_god_index = sub(count_listed_gods, 100);\r\n        } else {\r\n            last_god_index = 0;\r\n        }\r\n        \r\n        uint reward_egst = 0;\r\n        uint base_reward = 6 ether;\r\n        if (count_rounds == 6){\r\n            base_reward = mul(base_reward, 6);\r\n        }\r\n        for (uint i = last_god_index; i < count_listed_gods; i++) {\r\n            reward_egst = mul(base_reward, sub(add(i, 1), last_god_index));\r\n            egst_from_contract(gods_address[listed_gods[i]], reward_egst, 2);// 2 top_gods_reward\r\n            _totalSupply = add(_totalSupply, reward_egst);   \r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n\r\n    function compare_bid_eth () private view returns (uint, address) {\r\n        uint highest_bid = 0;\r\n        address highest_bidder = v_god; // if no one bid, v god host this event\r\n\r\n        for (uint j = 1; j <= listed_gods.length; j++){\r\n            if (gods[bidding_gods[j]].bid_eth > highest_bid){\r\n                highest_bid = gods[bidding_gods[j]].bid_eth;\r\n                highest_bidder = bidding_gods[j];\r\n            }\r\n        }\r\n        return (highest_bid, highest_bidder);\r\n    }\r\n\r\n\r\n    function check_event_completed () public view returns (bool){\r\n        if (add(pray_start_block, round_duration) < block.number){\r\n            return true;   \r\n        } else {\r\n            return false;   \r\n        }\r\n    }\r\n\r\n\r\n    function pk (address attacker, address defender, bytes32 block_hash) public view returns (bool pk_result){// make it public, view only, other contract may use it\r\n\r\n        (uint attacker_sum_god_levels, uint attacker_sum_amulet_levels) = get_sum_levels_pk(attacker);\r\n        (uint defender_sum_god_levels, uint defender_sum_amulet_levels) = get_sum_levels_pk(defender);\r\n    \r\n        pk_result = eth_gods_dice.pk(block_hash, attacker_sum_god_levels, attacker_sum_amulet_levels, defender_sum_god_levels, defender_sum_amulet_levels);\r\n        \r\n        return pk_result;\r\n    }\r\n    \r\n    \r\n    function get_sum_levels_pk (address god_address) public view returns (uint sum_gods_level, uint sum_amulets_level){\r\n             \r\n        sum_gods_level =  gods[god_address].level;\r\n        sum_amulets_level = gods[god_address].pet_level; // add pet level to the sum\r\n\t\tuint amulet_god_id;\r\n        uint amulet_god_level;\r\n        for (uint i = 1; i <= count_amulets; i++){\r\n            if (amulets[i].owner == god_address && amulets[i].start_selling_block == 0){\r\n                amulet_god_id = amulets[i].god_id;\r\n                amulet_god_level = gods[gods_address[amulet_god_id]].level;\r\n                sum_gods_level = add(sum_gods_level, amulet_god_level);\r\n                sum_amulets_level = add(sum_amulets_level, amulets[i].level);\r\n            }\r\n        }\r\n                \r\n        return (sum_gods_level, sum_amulets_level);\r\n    }\r\n        \r\n    //admin need this function\r\n    function get_listed_winners (uint prize) public view returns (address[]){\r\n        address [] memory temp_list = new address[] (count_listed_winners[prize]);\r\n        if (count_listed_winners[prize] > 0) {\r\n            for (uint i = 0; i < count_listed_winners[prize]; i++){\r\n                temp_list[i] = listed_winners[prize][add(i,1)];\r\n            }\r\n        }\r\n        return temp_list;\r\n    }\r\n    \r\n    function get_ticket (uint ticket_number) public view returns (uint, bytes32, address, uint, uint){\r\n        return (tickets[ticket_number].block_number,\r\n            tickets[ticket_number].block_hash,\r\n            tickets[ticket_number].owner,\r\n            tickets[ticket_number].new_ticket_number,\r\n            tickets[ticket_number].dice_result);\r\n    }\r\n    \r\n    function get_my_tickets() public view returns (uint[]) {\r\n        uint count_my_tickets = gods[msg.sender].count_tickets;\r\n        if (count_my_tickets > max_show_tickets) {\r\n            count_my_tickets = max_show_tickets;\r\n        }\r\n        uint [] memory temp_list = new uint[] (count_my_tickets);\r\n        if (count_my_tickets > 0) {\r\n            uint count_elements = 0;\r\n            for (uint i = gods[msg.sender].last_ticket_number; i > 0; i--){\r\n                if (tickets[i].owner == msg.sender){\r\n                    temp_list[count_elements] = i;\r\n                    count_elements++;\r\n                    \r\n                    if (count_elements >= count_my_tickets){\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return temp_list;       \r\n    }\r\n\r\n \r\n    // end of pray\r\n\r\n    // start of egses\r\n\r\n    function egses_from_contract (address to, uint tokens, uint reason) private returns (bool) { // public when testing\r\n        if (reason == 1) {\r\n            require (pray_egses > tokens); // >, pool never be zero\r\n            pray_egses = sub(pray_egses, tokens);\r\n        }\r\n\r\n        egses_balances[to] = add(egses_balances[to], tokens);\r\n\r\n        create_change_log(1, reason, tokens, egses_balances[to], contract_address, to);\r\n        return true;\r\n    } \r\n    \r\n    function egses_withdraw () public returns (uint tokens){\r\n        tokens = egses_balances[msg.sender];\r\n        require (tokens > 0 && contract_address.balance >= tokens && reEntrancyMutex == false);\r\n\r\n        reEntrancyMutex = true; // if met problem, it will use up gas from msg.sender and roll back to false\r\n        egses_balances[msg.sender] = 0;\r\n        msg.sender.transfer(tokens);\r\n        reEntrancyMutex = false;\r\n        \r\n        emit withdraw_egses(msg.sender, tokens);\r\n        create_change_log(1, 5, tokens, 0, contract_address, msg.sender); // 5 withdraw egses\r\n\r\n        return tokens;\r\n    }\r\n    event withdraw_egses (address receiver, uint tokens);\r\n\r\n   // end of egses\r\n   \r\n\r\n    // start of erc20 for egst\r\n    function totalSupply () public view returns (uint){\r\n        return _totalSupply;\r\n    }\r\n\r\n\r\n    function balanceOf (address tokenOwner) public view returns (uint){\r\n        return balances[tokenOwner]; // will return 0 if doesn't exist\r\n    }\r\n\r\n    function allowance (address tokenOwner, address spender) public view returns (uint) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    function transfer (address to, uint tokens) public returns (bool success){\r\n        require (balances[msg.sender] >= tokens);\r\n        balances[msg.sender] = sub(balances[msg.sender], tokens);\r\n        balances[to] = add(balances[to], tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        create_change_log(2, 9, tokens, balances[to], msg.sender, to);\r\n        \r\n        return true;    \r\n    }\r\n    event Transfer (address indexed from, address indexed to, uint tokens);\r\n\r\n\r\n    function approve (address spender, uint tokens) public returns (bool success) {\r\n\r\n        require (balances[msg.sender] >= tokens);\r\n        allowed[msg.sender][spender] = tokens;\r\n        \r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n    event Approval (address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n\r\n    function transferFrom (address from, address to, uint tokens) public returns (bool success) {\r\n        require (balances[from] >= tokens);\r\n        allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokens);\r\n        balances[from] = sub(balances[from], tokens);\r\n        balances[to] = add(balances[to], tokens);\r\n        \r\n        emit Transfer(from, to, tokens);\r\n        create_change_log(2, 10, tokens, balances[to], from, to);\r\n        return true;    \r\n    }\r\n\r\n    // end of erc20 for egst\r\n    \r\n    \r\n    // egst\r\n  \r\n    function egst_from_contract (address to, uint tokens, uint reason) private returns (bool) { // public when testing\r\n        balances[to] = add(balances[to], tokens);\r\n\r\n        create_change_log(2, reason, tokens, balances[to], contract_address, to); \r\n        return true;\r\n    }\r\n\r\n    function egst_to_contract (address from, uint tokens, uint reason) private returns (bool) { // public when testing\r\n        require (balances[from] >= tokens);\r\n        balances[from] = sub(balances[from], tokens);\r\n        \r\n\r\n        emit spend_egst(from, tokens, reason);\r\n        create_change_log(2, reason, tokens, balances[from], from, contract_address);\r\n        return true;\r\n    }\r\n    event spend_egst (address from, uint tokens, uint reason);\r\n\r\n\r\n    function create_token_order (uint unit_price, uint egst_amount) public returns (uint) {      \r\n        require(unit_price >= min_unit_price && unit_price <= max_unit_price \r\n        && balances[msg.sender] >= egst_amount\r\n        && egst_amount <= max_egst_amount\r\n        && egst_amount >= min_egst_amount);\r\n\r\n        count_token_orders = add(count_token_orders, 1);\r\n\r\n        egst_to_contract(msg.sender, egst_amount, 3); // 3 create_token_order\r\n        \r\n        token_orders[count_token_orders].start_selling_block = block.number;    \r\n        token_orders[count_token_orders].seller = msg.sender;\r\n        token_orders[count_token_orders].unit_price = unit_price;\r\n        token_orders[count_token_orders].egst_amount = egst_amount;\r\n        gods[msg.sender].count_token_orders = add(gods[msg.sender].count_token_orders, 1);\r\n        \r\n        update_first_active_token_order(msg.sender);\r\n\r\n        return gods[msg.sender].count_token_orders;\r\n    }\r\n\r\n\r\n    function withdraw_token_order (uint order_id) public returns (bool) { \r\n        require (msg.sender == token_orders[order_id].seller\r\n                && token_orders[order_id].egst_amount > 0);\r\n\r\n        uint egst_amount = token_orders[order_id].egst_amount;\r\n        token_orders[order_id].start_selling_block = 0;\r\n        token_orders[order_id].egst_amount = 0;\r\n        egst_from_contract(msg.sender, egst_amount, 4); // 4  withdraw token_order\r\n        gods[msg.sender].count_token_orders = sub(gods[msg.sender].count_token_orders, 1);\r\n        \r\n        update_first_active_token_order(msg.sender);\r\n        emit WithdrawTokenOrder(msg.sender, order_id);\r\n\r\n        return true;\r\n    }\r\n    event WithdrawTokenOrder (address seller, uint order_id);\r\n\r\n    function buy_token (uint order_id, uint egst_amount) public payable returns (uint) { \r\n\r\n        require(order_id >= first_active_token_order \r\n                && order_id <= count_token_orders\r\n                && egst_amount <= token_orders[order_id].egst_amount\r\n                && token_orders[order_id].egst_amount > 0\r\n                && token_orders[order_id].seller != msg.sender);\r\n        \r\n        // unit_price 100 means 1 egst = 0.001 ether\r\n        uint eth_cost = div(mul(token_orders[order_id].unit_price, egst_amount), 100000);\r\n        require(msg.value >= eth_cost && msg.value < add(eth_cost, max_extra_eth) );\r\n\r\n        token_orders[order_id].egst_amount = sub(token_orders[order_id].egst_amount, egst_amount);\r\n        egst_from_contract(msg.sender, egst_amount, token_orders[order_id].unit_price); // uint price (> 10) will be recorded as reason in change log and translated by front end as buy token & unit_price\r\n\r\n        address seller = token_orders[order_id].seller;\r\n        egses_from_contract(seller, eth_cost, 7); // 7 sell egst\r\n        \r\n        \r\n        if (token_orders[order_id].egst_amount <= 0){\r\n            token_orders[order_id].start_selling_block = 0;\r\n            gods[seller].count_token_orders = sub(gods[seller].count_token_orders, 1);\r\n            update_first_active_token_order(seller);\r\n        }\r\n        \r\n        emit BuyToken(msg.sender, order_id, egst_amount);\r\n\r\n        return token_orders[order_id].egst_amount;\r\n    }\r\n    event BuyToken (address buyer, uint order_id, uint egst_amount);\r\n\r\n  \r\n    function update_first_active_token_order (address god_address) private returns (uint, uint){ // public when testing\r\n        if (count_token_orders > 0 \r\n        && first_active_token_order == 0){\r\n            first_active_token_order = 1;\r\n        } else {\r\n            for (uint i = first_active_token_order; i <= count_token_orders; i++) {\r\n                if (add(token_orders[i].start_selling_block, order_duration) > block.number){\r\n                    // find the first active order and compare with the currect index\r\n                    if (i > first_active_token_order){\r\n                        first_active_token_order = i;\r\n                    }\r\n                    break;\r\n                }\r\n            }    \r\n        }\r\n            \r\n        if (gods[god_address].count_token_orders > 0\r\n        && gods[god_address].first_active_token_order == 0){\r\n            gods[god_address].first_active_token_order = 1; // may not be 1, but it will correct next time\r\n        } else {\r\n            for (uint j = gods[god_address].first_active_token_order; j < count_token_orders; j++){\r\n                if (token_orders[j].seller == god_address \r\n                && token_orders[j].start_selling_block > 0){ // don't check duration, show it to selling, even if expired\r\n                    // find the first active order and compare with the currect index\r\n                    if(j > gods[god_address].first_active_token_order){\r\n                        gods[god_address].first_active_token_order = j;\r\n                    }\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        \r\n        return (first_active_token_order, gods[msg.sender].first_active_token_order);\r\n    }\r\n\r\n\r\n    function get_token_order (uint order_id) public view returns(uint, address, uint, uint){\r\n        require(order_id >= 1 && order_id <= count_token_orders);\r\n\r\n        return(token_orders[order_id].start_selling_block,\r\n               token_orders[order_id].seller,\r\n               token_orders[order_id].unit_price,\r\n               token_orders[order_id].egst_amount);\r\n    }\r\n\r\n    // return total orders and lowest price to browser, browser query each active order and show at most three orders of lowest price\r\n    function get_token_orders () public view returns(uint, uint, uint, uint, uint) {\r\n        uint lowest_price = max_unit_price;\r\n        for (uint i = first_active_token_order; i <= count_token_orders; i++){\r\n            if (token_orders[i].unit_price < lowest_price \r\n            && token_orders[i].egst_amount > 0\r\n            && add(token_orders[i].start_selling_block, order_duration) > block.number){\r\n                lowest_price = token_orders[i].unit_price;\r\n            }\r\n        }\r\n        return (count_token_orders, first_active_token_order, order_duration, max_unit_price, lowest_price);\r\n    }\r\n    \r\n\r\n    function get_my_token_orders () public view returns(uint []) {\r\n        uint my_count_token_orders = gods[msg.sender].count_token_orders;\r\n        uint [] memory temp_list = new uint[] (my_count_token_orders);\r\n        if (my_count_token_orders > 0) {\r\n            uint count_list_elements = 0;\r\n            for (uint i = gods[msg.sender].first_active_token_order; i <= count_token_orders; i++){\r\n                if (token_orders[i].seller == msg.sender\r\n                && token_orders[i].start_selling_block > 0){\r\n                    temp_list[count_list_elements] = i;\r\n                    count_list_elements++;\r\n                    \r\n                    if (count_list_elements >= my_count_token_orders){\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return temp_list;\r\n    }\r\n\r\n\r\n    // end of egst\r\n    \r\n   \r\n    // logs\r\n    function get_winner_log (uint pray_round, uint log_id) public view returns (uint, bytes32, address, address, uint, bool, uint){\r\n        require(log_id >= 1 && log_id <= count_rounds_winner_logs[pray_round]);\r\n        winner_log storage this_winner_log = winner_logs[pray_round][log_id];\r\n        \r\n        uint ticket_number = this_winner_log.ticket_number;\r\n        \r\n        return (tickets[ticket_number].block_number,\r\n                tickets[ticket_number].block_hash,\r\n                tickets[ticket_number].owner,\r\n                this_winner_log.previous_winner,\r\n                this_winner_log.prize,\r\n                this_winner_log.pk_result,\r\n                this_winner_log.ticket_number);\r\n    }    \r\n\r\n    function get_count_rounds_winner_logs (uint pray_round) public view returns (uint){\r\n        return count_rounds_winner_logs[pray_round];\r\n    }\r\n\r\n\r\n    // egses change reasons:  \r\n        // 1 pray_reward, 2 god_reward for being invited, 3 inviter_reward,\r\n        // 4 admin_deposit to reward_pool, 5 withdraw egses\r\n        // 6 sell amulet, 7 sell egst, 8 withdraw bid\r\n    \r\n    // egst_change reasons: \r\n        // 1 pray_reward, 2 top_gods_reward, \r\n        // 3 create_token_order, 4 withdraw token_order, 5 buy token (> 10),  \r\n        // 6 upgrade pet, 7 upgrade amulet, 8 admin_reward, \r\n        // 9 transfer, 10 transferFrom(owner & receiver)\r\n\r\n        \r\n    function create_change_log (uint asset_type, uint reason, uint change_amount, uint after_amount, address _from, address _to) private returns (uint) {\r\n        count_rounds_change_logs[count_rounds] = add(count_rounds_change_logs[count_rounds], 1);\r\n        uint log_id = count_rounds_change_logs[count_rounds];\r\n \r\n        change_logs[count_rounds][log_id].block_number = block.number;\r\n        change_logs[count_rounds][log_id].asset_type = asset_type;\r\n        change_logs[count_rounds][log_id].reason = reason;\r\n        change_logs[count_rounds][log_id].change_amount = change_amount;\r\n        change_logs[count_rounds][log_id].after_amount = after_amount; \r\n        change_logs[count_rounds][log_id]._from = _from;\r\n        change_logs[count_rounds][log_id]._to = _to;\r\n        \r\n        return log_id;\r\n    }\r\n          \r\n    function get_change_log (uint pray_round, uint log_id) public view returns (uint, uint, uint, uint, uint, address, address){ // public\r\n        change_log storage this_log = change_logs[pray_round][log_id];\r\n        return (this_log.block_number,\r\n                this_log.asset_type,\r\n                this_log.reason, // reason > 10 is buy_token unit_price\r\n                this_log.change_amount,\r\n                this_log.after_amount, // god's after amount. transfer or transferFrom doesn't record log\r\n                this_log._from,\r\n                this_log._to);\r\n        \r\n    }\r\n    \r\n    function get_count_rounds_change_logs (uint pray_round) public view returns(uint){\r\n        return count_rounds_change_logs[pray_round];\r\n    }\r\n    \r\n    // end of logs\r\n\r\n\r\n    // common functions\r\n\r\n     function add (uint a, uint b) internal pure returns (uint c) {\r\n         c = a + b;\r\n         require(c >= a);\r\n     }\r\n     function sub (uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n         c = a - b;\r\n     }\r\n     function mul (uint a, uint b) internal pure returns (uint c) {\r\n         c = a * b;\r\n         require(a == 0 || c / a == b);\r\n     }\r\n     function div (uint a, uint b) internal pure returns (uint c) {\r\n         require(b > 0);\r\n         c = a / b;\r\n     }\r\n\r\n}\r\n\r\n\r\ncontract EthGodsName {\r\n\r\n    // EthGods\r\n    EthGods private eth_gods;\r\n    address private ethgods_contract_address;   \r\n    function set_eth_gods_contract_address (address eth_gods_contract_address) public returns (bool){\r\n        require (msg.sender == admin);\r\n        \r\n        ethgods_contract_address = eth_gods_contract_address;\r\n        eth_gods = EthGods(ethgods_contract_address); \r\n        return true;\r\n    }\r\n  \r\n    address private admin; // manually update to ethgods' admin\r\n    function update_admin () public returns (bool){\r\n        (address new_admin,,,,,,) = eth_gods.query_contract();\r\n        require (msg.sender == new_admin);\r\n        admin = new_admin;\r\n        return true;\r\n    }\r\n\r\n    //contract information & administration\r\n    bool private contract_created; // in case constructor logic change in the future\r\n    address private contract_address; //shown at the top of the home page   \r\n    \r\n    string private invalid_chars = \"\\\\\\\"\";\r\n    bytes private invalid_bytes = bytes(invalid_chars);\r\n    function set_invalid_chars (string new_invalid_chars) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        invalid_chars = new_invalid_chars;\r\n        invalid_bytes = bytes(invalid_chars);\r\n        return true;\r\n    }\r\n    \r\n    uint private valid_length = 16;    \r\n    function set_valid_length (uint new_valid_length) public returns (bool) {\r\n        require(msg.sender == admin);\r\n        valid_length = new_valid_length;\r\n        return true;\r\n    }\r\n    \r\n    struct god_name {\r\n        string god_name;\r\n        uint block_number;\r\n        uint block_duration;\r\n    }\r\n    mapping (address => god_name) private gods_name;\r\n\r\n    // start of constructor and destructor\r\n    \r\n    constructor () public {    \r\n        require (contract_created == false);\r\n        contract_created = true;\r\n        contract_address = address(this);\r\n        admin = msg.sender;     \r\n        address v_god = 0xfB6916095ca1df60bB79Ce92cE3Ea74c37c5d359;\r\n        gods_name[v_god].god_name = \"V\";\r\n    }\r\n\r\n    function () public payable {\r\n        revert();  // if received eth for no reason, reject\r\n    }\r\n\r\n    function finalize() public {\r\n        require (msg.sender == admin);\r\n        selfdestruct(msg.sender); \r\n    }\r\n    \r\n    // end of constructor and destructor\r\n    \r\n    \r\n    function set_god_name (string new_name) public returns (bool){\r\n        address god_address = msg.sender;\r\n        require (add(gods_name[god_address].block_number, gods_name[god_address].block_duration) < block.number );\r\n\r\n        bytes memory bs = bytes(new_name);\r\n        require (bs.length <= valid_length);\r\n        \r\n        for (uint i = 0; i < bs.length; i++){\r\n            for (uint j = 0; j < invalid_bytes.length; j++) {\r\n                if (bs[i] == invalid_bytes[j]){\r\n                    return false;\r\n                } \r\n            }\r\n        }\r\n\r\n        gods_name[god_address].god_name = new_name;\r\n        emit set_name(god_address, new_name);\r\n        return true;\r\n    }\r\n    event set_name (address indexed god_address, string new_name);\r\n\r\n\r\n    function get_god_name (address god_address) public view returns (string) {\r\n        return gods_name[god_address].god_name;\r\n    }\r\n\r\n    function block_god_name (address god_address, uint block_duration) public {\r\n        require (msg.sender == admin);\r\n        gods_name[god_address].god_name = \"Unkown\";\r\n        gods_name[god_address].block_number = block.number;\r\n        gods_name[god_address].block_duration = block_duration;\r\n    }\r\n    \r\n    function add (uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n}\r\n\r\n\r\ncontract EthGodsDice {\r\n    \r\n    //contract information & administration\r\n    bool private contract_created; // in case constructor logic change in the future\r\n    address private contract_address; //shown at the top of the home page\r\n    address private admin;\r\n    \r\n    // start of constructor and destructor\r\n    constructor () public {\r\n        require (contract_created == false);\r\n        contract_created = true;\r\n        contract_address = address(this);\r\n        admin = msg.sender;\r\n\r\n    }\r\n\r\n    function finalize () public {\r\n        require (msg.sender == admin);\r\n        selfdestruct(msg.sender); \r\n    }\r\n    \r\n    function () public payable {\r\n        revert();  // if received eth for no reason, reject\r\n    }\r\n    \r\n    // end of constructor and destructor\r\n\r\n\r\n    function throw_dice (bytes32 block_hash) public pure returns (uint[]) {// 0 for prize, 1-6 for 6 numbers should be pure\r\n        uint[] memory dice_numbers = new uint[](7);\r\n        uint hash_number;\r\n        uint[] memory count_dice_numbers = new uint[](7);\r\n        uint i; // for loop\r\n  \r\n        for (i = 1; i <= 6; i++) {\r\n            hash_number = uint(block_hash[i]);\r\n            if (hash_number >= 214) { // 214\r\n                dice_numbers[i] = 6;\r\n            } else if (hash_number >= 172) { // 172\r\n                dice_numbers[i] = 5;\r\n            } else if (hash_number >= 129) { // 129\r\n                dice_numbers[i] = 4;\r\n            } else if (hash_number >= 86) { // 86\r\n                dice_numbers[i] = 3;\r\n            } else if (hash_number >= 43) { // 43\r\n                dice_numbers[i] = 2;\r\n            } else {\r\n                dice_numbers[i] = 1;\r\n            }\r\n            count_dice_numbers[dice_numbers[i]] ++;\r\n        }\r\n\r\n        bool won_super_prize = false;\r\n        uint count_super_eth = 0;\r\n        for (i = 1; i <= 6; i++) {\r\n            if (count_dice_numbers[i] >= 5) {\r\n                dice_numbers[0] = 1; //champion_eth\r\n                won_super_prize = true;\r\n                break;\r\n            }else if (count_dice_numbers[i] >= 3) {\r\n                dice_numbers[0] = 3; // super_egst\r\n                won_super_prize = true;\r\n                break;\r\n            }else if (count_dice_numbers[i] == 1) {\r\n                count_super_eth ++;\r\n                if (count_super_eth == 6) {\r\n                    dice_numbers[0] = 2; // super_eth\r\n                    won_super_prize = true;\r\n                }\r\n            } \r\n        }\r\n\r\n        if (won_super_prize == false) {\r\n            dice_numbers[0] = 4;\r\n        }\r\n        \r\n        return dice_numbers;\r\n    }\r\n    \r\n    function pk (bytes32 block_hash, uint attacker_sum_god_levels, uint attacker_sum_amulet_levels, uint defender_sum_god_levels, uint defender_sum_amulet_levels) public pure returns (bool){\r\n     \r\n        uint god_win_chance;\r\n        attacker_sum_god_levels = add(attacker_sum_god_levels, 10);\r\n        if (attacker_sum_god_levels < defender_sum_god_levels){\r\n            god_win_chance = 0;\r\n        } else {\r\n            god_win_chance = sub(attacker_sum_god_levels, defender_sum_god_levels);\r\n            if (god_win_chance > 20) {\r\n                god_win_chance = 100;\r\n            } else { // equal level, 50% chance to win\r\n                god_win_chance = mul(god_win_chance, 5);\r\n            }\r\n        }        \r\n        \r\n        \r\n        uint amulet_win_chance;\r\n        attacker_sum_amulet_levels = add(attacker_sum_amulet_levels, 10);\r\n        if (attacker_sum_amulet_levels < defender_sum_amulet_levels){\r\n            amulet_win_chance = 0;\r\n        } else {\r\n            amulet_win_chance = sub(attacker_sum_amulet_levels, defender_sum_amulet_levels);\r\n            if (amulet_win_chance > 20) {\r\n                amulet_win_chance = 100;\r\n            } else { // equal level, 50% chance to win\r\n                amulet_win_chance = mul(amulet_win_chance, 5);\r\n            }\r\n        }\r\n\r\n        \r\n        uint attacker_win_chance = div(add(god_win_chance, amulet_win_chance), 2);\r\n        if (attacker_win_chance >= div(mul(uint(block_hash[3]),2),5)){\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n        \r\n    }\r\n    \r\n    \r\n    // common functions\r\n\r\n     function add (uint a, uint b) internal pure returns (uint c) {\r\n         c = a + b;\r\n         require(c >= a);\r\n     }\r\n     function sub (uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n         c = a - b;\r\n     }\r\n     function mul (uint a, uint b) internal pure returns (uint c) {\r\n         c = a * b;\r\n         require(a == 0 || c / a == b);\r\n     }\r\n     function div (uint a, uint b) internal pure returns (uint c) {\r\n         require(b > 0);\r\n         c = a / b;\r\n     }\r\n        \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"page_number\",\"type\":\"uint256\"}],\"name\":\"get_amulet_orders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"parameter_type\",\"type\":\"uint256\"},{\"name\":\"new_parameter\",\"type\":\"uint256\"}],\"name\":\"set_parameters\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amulet_id\",\"type\":\"uint256\"}],\"name\":\"buy_amulet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"page_number\",\"type\":\"uint256\"}],\"name\":\"get_listed_gods\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"god_id\",\"type\":\"uint256\"}],\"name\":\"get_god_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_my_invited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"god_id\",\"type\":\"uint256\"}],\"name\":\"get_amulets_generated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"controller_index\",\"type\":\"uint256\"},{\"name\":\"new_controller_address\",\"type\":\"address\"}],\"name\":\"set_controller\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"god_id\",\"type\":\"uint256\"}],\"name\":\"get_god\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_my_info\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"query_contract2\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ticket_number\",\"type\":\"uint256\"}],\"name\":\"get_ticket\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amulet_id\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"create_amulet_order\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amulet_id\",\"type\":\"uint256\"}],\"name\":\"get_amulet2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"order_id\",\"type\":\"uint256\"},{\"name\":\"egst_amount\",\"type\":\"uint256\"}],\"name\":\"buy_token\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amulet_id\",\"type\":\"uint256\"}],\"name\":\"upgrade_amulet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bid_host\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"attacker\",\"type\":\"address\"},{\"name\":\"defender\",\"type\":\"address\"},{\"name\":\"block_hash\",\"type\":\"bytes32\"}],\"name\":\"pk\",\"outputs\":[{\"name\":\"pk_result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pray_round\",\"type\":\"uint256\"}],\"name\":\"get_count_rounds_winner_logs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prize\",\"type\":\"uint256\"}],\"name\":\"get_listed_winners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade_pet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"string_type\",\"type\":\"uint256\"},{\"name\":\"new_string\",\"type\":\"string\"}],\"name\":\"set_strings\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_type\",\"type\":\"uint256\"}],\"name\":\"set_pet_type\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pray_round\",\"type\":\"uint256\"},{\"name\":\"log_id\",\"type\":\"uint256\"}],\"name\":\"get_winner_log\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amulet_id\",\"type\":\"uint256\"}],\"name\":\"get_amulet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"egst_amount\",\"type\":\"uint256\"}],\"name\":\"admin_deposit\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"egses_withdraw\",\"outputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"god_address\",\"type\":\"address\"}],\"name\":\"get_god_info\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"order_id\",\"type\":\"uint256\"}],\"name\":\"withdraw_token_order\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_token_orders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pray_round\",\"type\":\"uint256\"},{\"name\":\"log_id\",\"type\":\"uint256\"}],\"name\":\"get_change_log\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pray_round\",\"type\":\"uint256\"}],\"name\":\"get_count_rounds_change_logs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_my_tickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amulet_id\",\"type\":\"uint256\"}],\"name\":\"withdraw_amulet_order\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"god_id\",\"type\":\"uint256\"}],\"name\":\"invite\",\"outputs\":[{\"name\":\"new_invite_price\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"god_address\",\"type\":\"address\"}],\"name\":\"get_sum_levels_pk\",\"outputs\":[{\"name\":\"sum_gods_level\",\"type\":\"uint256\"},{\"name\":\"sum_amulets_level\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"query_uints\",\"outputs\":[{\"name\":\"uints\",\"type\":\"uint256[32]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"order_id\",\"type\":\"uint256\"}],\"name\":\"get_token_order\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"unit_price\",\"type\":\"uint256\"},{\"name\":\"egst_amount\",\"type\":\"uint256\"}],\"name\":\"create_token_order\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"god_id\",\"type\":\"uint256\"}],\"name\":\"sort_gods_admin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"check_event_completed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"god_address\",\"type\":\"address\"}],\"name\":\"get_vip_level\",\"outputs\":[{\"name\":\"vip_level\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_my_amulets_selling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eth_gods_name_contract_address\",\"type\":\"address\"}],\"name\":\"set_eth_gods_name_contract_address\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inviter_id\",\"type\":\"uint256\"}],\"name\":\"pray\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_my_token_orders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"god_address\",\"type\":\"address\"}],\"name\":\"get_god_id\",\"outputs\":[{\"name\":\"god_id\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"get_amulet_orders_overview\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"god_address\",\"type\":\"address\"}],\"name\":\"get_amulets_at_hand\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw_bid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"admin_reset_pray\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_admin_address\",\"type\":\"address\"}],\"name\":\"set_admin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"eth_gods_dice_contract_address\",\"type\":\"address\"}],\"name\":\"set_eth_gods_dice_contract_address\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"query_contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"msg_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"god_id\",\"type\":\"uint256\"}],\"name\":\"invited_god\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amulet_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"new_level\",\"type\":\"uint256\"}],\"name\":\"upgradeAmulet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"withdraw_egses\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reason\",\"type\":\"uint256\"}],\"name\":\"spend_egst\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"order_id\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokenOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"order_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"egst_amount\",\"type\":\"uint256\"}],\"name\":\"BuyToken\",\"type\":\"event\"}]","ContractName":"EthGods","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://fef8416678954743b3737f6c7973fc9953476f0aa639eb60278496eb66545c4c"}]}