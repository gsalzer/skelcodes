{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract Z_ERC20Basic {\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract Z_ERC20 is Z_ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n \r\n\r\n/**\r\n * @title Basic token implementation\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract Z_BasicToken is Z_ERC20Basic {\r\n   \r\n  mapping(address => uint256) balances;\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] -= _value;\r\n    balances[_to] += _value;\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token, implementing  transfer by agents \r\n *\r\n * @dev Implementation of the basic standard token with allowances.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract Z_StandardToken is Z_ERC20, Z_BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n \r\n  /**\r\n   * @dev Transfer tokens from one address to another by agents within allowance limit \r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   * @return true\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] -= _value;\r\n    balances[_to] += _value;\r\n    allowed[_from][msg.sender] -= _value;\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to  by admin , without any allowance limit\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   * @return true\r\n   */\r\n  function transferFromByAdmin(address _from, address _to, uint256 _value) internal returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    //require(_value <= 100000);\r\n\r\n    balances[_from] -= _value;\r\n    balances[_to] += _value;\r\n\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   * @return true\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified *additional* amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The additional amount of tokens to be spent.\r\n   * @return true\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender] + (_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the allownance quota by the specified amount of tokens\r\n   *\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to be decreased\r\n   * @return true\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue - (_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and multiple admin addresses, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Z_Ownable {\r\n  address public owner;\r\n  mapping (address => bool) internal admin_accounts;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    // set msg.sender as owner\r\n    owner = msg.sender;\r\n    // set msg.sender as first administrator\r\n    admin_accounts[msg.sender]= true;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev check if msg.sender is owner\r\n   * @return true  if msg.sender is owner\r\n   */\r\n  function  isOwner() internal view returns (bool) {\r\n    return (msg.sender == owner );\r\n    \r\n  }\r\n  \r\n  /**\r\n   * @dev Throws if called by any account other than admins.\r\n   */\r\n  modifier onlyAdmin() {\r\n    require (admin_accounts[msg.sender]==true);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev check if msg.sender is admin\r\n   * @return true  if msg.sender is admin\r\n   */\r\n  function  isAdmin() internal view returns (bool) {\r\n    return  (admin_accounts[msg.sender]==true);\r\n    \r\n  }\r\n \r\n}\r\n\r\n\r\n/** @title main contract for NOW token. we should deploy this contract. needs about 5,500,000 gas */\r\n\r\ncontract NOWToken is Z_StandardToken, Z_Ownable {\r\n    string  public  constant name = \"NOW\";\r\n    string  public  constant symbol = \"NOW\";\r\n    uint8   public  constant decimals = 18; // token traded in integer amounts, no period\r\n\r\n    // total token supply: 3 billion NOW\r\n    uint256 internal constant _totalTokenAmount = 3 * (10 ** 9) * (10 ** 18);\r\n\r\n    uint256 internal constant WEI_PER_ETHER= 1000000000000000000; // 10^18 wei = 1 ether\r\n    uint256 internal constant NUM_OF_SALE_STAGES= 5; // support upto five sale stages\r\n\r\n    // enum type definition for sale status (0 ~ 13)\r\n    enum Sale_Status {\r\n      Initialized_STATUS, // 0\r\n      Stage0_Sale_Started_STATUS, // 1, stage0\r\n      Stage0_Sale_Stopped_STATUS, // 2, stage0\r\n      Stage1_Sale_Started_STATUS, // 3, stage1\r\n      Stage1_Sale_Stopped_STATUS, // 4, stage1\r\n      Stage2_Sale_Started_STATUS, // 5, stage2\r\n      Stage2_Sale_Stopped_STATUS, // 6, stage2\r\n      Stage3_Sale_Started_STATUS, // 7, stage3\r\n      Stage3_Sale_Stopped_STATUS, // 8, stage3\r\n      Stage4_Sale_Started_STATUS, // 9,  stage4\r\n      Stage4_Sale_Stopped_STATUS, // 10, stage4\r\n      Public_Allowed_To_Trade_STATUS, // 11\r\n      Stage0_Allowed_To_Trade_STATUS, // 12\r\n      Closed_STATUS  // 13\r\n    }\r\n\r\n    // sale status variable: 0 ~ 13 (enum Sale_Status )\r\n    Sale_Status  public  sale_status= Sale_Status.Initialized_STATUS;\r\n\r\n    // sale stage index : 0 ~ 4 ( 0:1~2,  1:3~4, 2:5~6, 3:7~8, 4:9~10) \r\n    uint256   public  sale_stage_index= 0; // 0 ~ 4 for stage0 ~ 4\r\n\r\n    // initiazlied time\r\n    uint256  public  when_initialized= 0;\r\n\r\n    // timestamp when public trade begins except stage0\r\n    uint256  public  when_public_allowed_to_trade_started= 0;\r\n\r\n    // timestamp when *all* tokens trade begins including stage0\r\n    uint256  public  when_stage0_allowed_to_trade_started= 0;\r\n\r\n    // array of sale starting time's timestamp\r\n    uint256 [NUM_OF_SALE_STAGES] public  when_stageN_sale_started;\r\n\r\n    // array of sale stopping time's timestamp\r\n    uint256 [NUM_OF_SALE_STAGES] public  when_stageN_sale_stopped;\r\n\r\n    // sum of all sold tokens\r\n    uint256 public sold_tokens_total= 0;\r\n\r\n    // sum of ethers received during all token sale stages\r\n    uint256 public raised_ethers_total= 0;\r\n\r\n    // array of sold tokens per sale stage\r\n    uint256[NUM_OF_SALE_STAGES] public sold_tokens_per_stage;\r\n\r\n    // array of received ethers per sale stage\r\n    uint256[NUM_OF_SALE_STAGES] public raised_ethers_per_stage;\r\n\r\n    // target ether amount to gather in each sale stage, when fullfilled, the sale stage automatically forced to stop\r\n    uint256[NUM_OF_SALE_STAGES] public target_ethers_per_stage= [\r\n       1000 * WEI_PER_ETHER, // stage0 for staff\r\n       9882 * WEI_PER_ETHER, // stage1 for black sale\r\n      11454 * WEI_PER_ETHER, // stage2 for private sale\r\n      11200 * WEI_PER_ETHER, // stage3 for public sale\r\n      11667 * WEI_PER_ETHER  // stage4 for crowd sale\r\n    ];\r\n\r\n    // array of token sale price for each stage (wei per now)\r\n    uint256[NUM_OF_SALE_STAGES] internal  sale_price_per_stage_wei_per_now = [\r\n      uint256(1000000000000000000/ uint256(100000)),// stage0 for staff\r\n      uint256(1000000000000000000/ uint256(38000)), // stage1 for black sale\r\n      uint256(1000000000000000000/ uint256(23000)), // stage2 for private sale\r\n      uint256(1000000000000000000/ uint256(17000)), // stage3 for public sale\r\n      uint256(1000000000000000000/ uint256(10000))  // stage4 for crowd sale\r\n    ];\r\n\r\n    // struct definition for token sale history\r\n    struct history_token_sale_obj {\r\n      address _buyer;\r\n      uint256 _ether_value; // in wei\r\n      uint256 _token_value; // in now token\r\n      uint256 _when; \r\n    }\r\n\r\n    // struct definition for token transfer history\r\n    struct history_token_transfer_obj {\r\n      address _from;\r\n      address _to;\r\n      uint256 _token_value; // in now token\r\n      uint256 _when; \r\n    }\r\n\r\n    // struct definition for token burning history\r\n    struct history_token_burning_obj {\r\n      address _from;\r\n      uint256 _token_value_burned; // in now token\r\n      uint256 _when; \r\n    }\r\n\r\n    // token sale history for stage 0 ~ 4\r\n    history_token_sale_obj[]  internal history_token_sale_stage0;\r\n    history_token_sale_obj[]  internal history_token_sale_stage1;\r\n    history_token_sale_obj[]  internal history_token_sale_stage2;\r\n    history_token_sale_obj[]  internal history_token_sale_stage3;\r\n    history_token_sale_obj[]  internal history_token_sale_stage4;\r\n\r\n    // token transfer history\r\n    history_token_transfer_obj[] internal history_token_transfer;\r\n\r\n    // token burning history\r\n    history_token_burning_obj[]  internal history_token_burning;\r\n\r\n    // token sale amount for each account per stage 0 ~ 4\r\n    mapping (address => uint256) internal sale_amount_stage0_account;\r\n    mapping (address => uint256) internal sale_amount_stage1_account;\r\n    mapping (address => uint256) internal sale_amount_stage2_account;\r\n    mapping (address => uint256) internal sale_amount_stage3_account;\r\n    mapping (address => uint256) internal sale_amount_stage4_account;\r\n\r\n    \r\n    // array for list of  holders and their receiving amounts\r\n    mapping (address => uint256) internal holders_received_accumul;\r\n\r\n    // array for list of holders accounts (including even inactive holders) \r\n    address[] public holders;\r\n\r\n    // array for list of sale holders accounts for each sale stage\r\n    address[] public holders_stage0_sale;\r\n    address[] public holders_stage1_sale;\r\n    address[] public holders_stage2_sale;\r\n    address[] public holders_stage3_sale;\r\n    address[] public holders_stage4_sale;\r\n    \r\n    // array for list of trading holders which are not sale holders\r\n    address[] public holders_trading;\r\n\r\n    // array for list of burning holders accounts\r\n    address[] public holders_burned;\r\n\r\n    // array for list of frozen holders accounts\r\n    address[] public holders_frozen;\r\n\r\n    // burned tokens for each holders account\r\n    mapping (address => uint256) public burned_amount;\r\n\r\n    // sum of all burned tokens\r\n    uint256 public totalBurned= 0;\r\n\r\n    // total ether value withdrawed from this contract by contract owner\r\n    uint256 public totalEtherWithdrawed= 0;\r\n\r\n    // addess to timestamp mapping  to  mark the account freezing time ( 0 means later unfreezed )\r\n    mapping (address => uint256) internal account_frozen_time;\r\n\r\n    // unused\r\n    mapping (address => mapping (string => uint256)) internal traded_monthly;\r\n\r\n    // cryptocurrency exchange office  ether address, for monitorig purpose\r\n    address[] public cryptocurrency_exchange_company_accounts;\r\n\r\n    \r\n    /////////////////////////////////////////////////////////////////////////\r\n \r\n    event AddNewAdministrator(address indexed _admin, uint256 indexed _when);\r\n    event RemoveAdministrator(address indexed _admin, uint256 indexed _when);\r\n  \r\n    /**\r\n     *  @dev   add new admin accounts \r\n     *        (run by admin, public function) \r\n     *  @param _newAdmin   new admin address\r\n     */\r\n    function z_admin_add_admin(address _newAdmin) public onlyOwner {\r\n      require(_newAdmin != address(0));\r\n      admin_accounts[_newAdmin]=true;\r\n    \r\n      emit AddNewAdministrator(_newAdmin, block.timestamp);\r\n    }\r\n  \r\n    /**\r\n     *  @dev   remove old admin accounts\r\n     *        (run by admin, public function) \r\n     *  @param _oldAdmin   old admin address\r\n     */\r\n    function z_admin_remove_admin(address _oldAdmin) public onlyOwner {\r\n      require(_oldAdmin != address(0));\r\n      require(admin_accounts[_oldAdmin]==true);\r\n      admin_accounts[_oldAdmin]=false;\r\n    \r\n      emit RemoveAdministrator(_oldAdmin, block.timestamp);\r\n    }\r\n\r\n\r\n  \r\n    event AddNewExchangeAccount(address indexed _exchange_account, uint256 indexed _when);\r\n\r\n    /**\r\n     *  @dev   add new exchange office accounts\r\n     *        (run by admin, public function) \r\n     *  @param _exchange_account   new exchange address\r\n     */\r\n    function z_admin_add_exchange(address _exchange_account) public onlyAdmin {\r\n      require(_exchange_account != address(0));\r\n      cryptocurrency_exchange_company_accounts.push(_exchange_account);\r\n    \r\n      emit AddNewExchangeAccount(_exchange_account, block.timestamp);\r\n    }\r\n \r\n\r\n \r\n    event SaleTokenPriceSet(uint256 _stage_index, uint256 _wei_per_now_value, uint256 indexed _when);\r\n\r\n    /**\r\n     * @dev  set new token sale price for current sale stage\r\n     *       (run buy admin, public function)\r\n     * return  _how_many_wei_per_now   new token sale price (wei per now)\r\n     */\r\n    function z_admin_set_sale_price(uint256 _how_many_wei_per_now) public\r\n        onlyAdmin \r\n    {\r\n        if(_how_many_wei_per_now == 0) revert();\r\n        if(sale_stage_index >= 5) revert();\r\n        sale_price_per_stage_wei_per_now[sale_stage_index] = _how_many_wei_per_now;\r\n        emit SaleTokenPriceSet(sale_stage_index, _how_many_wei_per_now, block.timestamp);\r\n    }\r\n\r\n    /**\r\n     * @dev  return current or last token sale price\r\n     *       (public view function)\r\n     * return  _sale_price   get current token sale price (wei per now)\r\n     * return  _current_sale_stage_index   get current sale stage index ( 0 ~ 4)\r\n     */\r\n    function CurrentSalePrice() public view returns (uint256 _sale_price, uint256 _current_sale_stage_index)  {\r\n        if(sale_stage_index >= 5) revert();\r\n        _current_sale_stage_index= sale_stage_index;\r\n        _sale_price= sale_price_per_stage_wei_per_now[sale_stage_index];\r\n    }\r\n\r\n\r\n\r\n\r\n    event InitializedStage(uint256 indexed _when);\r\n    event StartStage0TokenSale(uint256 indexed _when);\r\n    event StartStage1TokenSale(uint256 indexed _when);\r\n    event StartStage2TokenSale(uint256 indexed _when);\r\n    event StartStage3TokenSale(uint256 indexed _when);\r\n    event StartStage4TokenSale(uint256 indexed _when);\r\n\r\n    /**\r\n     * @dev  start _new_sale_stage_index sale stage\r\n     *    (run by admin )\r\n     */\r\n    function start_StageN_Sale(uint256 _new_sale_stage_index) internal\r\n    {\r\n        if(sale_status==Sale_Status.Initialized_STATUS || sale_stage_index+1<= _new_sale_stage_index)\r\n           sale_stage_index= _new_sale_stage_index;\r\n        else\r\n           revert();\r\n        sale_status= Sale_Status(1 + sale_stage_index * 2); // 0=>1, 1=>3, 2=>5, 3=>7, 4=>9\r\n        when_stageN_sale_started[sale_stage_index]= block.timestamp;\r\n        if(sale_stage_index==0) emit StartStage0TokenSale(block.timestamp); \r\n        if(sale_stage_index==1) emit StartStage1TokenSale(block.timestamp); \r\n        if(sale_stage_index==2) emit StartStage2TokenSale(block.timestamp); \r\n        if(sale_stage_index==3) emit StartStage3TokenSale(block.timestamp); \r\n        if(sale_stage_index==4) emit StartStage4TokenSale(block.timestamp); \r\n    }\r\n\r\n\r\n\r\n    event StopStage0TokenSale(uint256 indexed _when);\r\n    event StopStage1TokenSale(uint256 indexed _when);\r\n    event StopStage2TokenSale(uint256 indexed _when);\r\n    event StopStage3TokenSale(uint256 indexed _when);\r\n    event StopStage4TokenSale(uint256 indexed _when);\r\n\r\n    /**\r\n     * @dev  stop this [_old_sale_stage_index] sale stage\r\n     *     (run by admin )\r\n     */\r\n    function stop_StageN_Sale(uint256 _old_sale_stage_index) internal \r\n    {\r\n        if(sale_stage_index != _old_sale_stage_index)\r\n           revert();\r\n        sale_status= Sale_Status(2 + sale_stage_index * 2); // 0=>2, 1=>4, 2=>6, 3=>8, 4=>10\r\n        when_stageN_sale_stopped[sale_stage_index]= block.timestamp;\r\n        if(sale_stage_index==0) emit StopStage0TokenSale(block.timestamp); \r\n        if(sale_stage_index==1) emit StopStage1TokenSale(block.timestamp); \r\n        if(sale_stage_index==2) emit StopStage2TokenSale(block.timestamp); \r\n        if(sale_stage_index==3) emit StopStage3TokenSale(block.timestamp); \r\n        if(sale_stage_index==4) emit StopStage4TokenSale(block.timestamp); \r\n    }\r\n\r\n\r\n\r\n    event StartTradePublicSaleTokens(uint256 indexed _when);\r\n\r\n    /**\r\n     *  @dev  allow stage1~4 token trading \r\n     *      (run by admin )\r\n     */\r\n    function start_Public_Trade() internal\r\n        onlyAdmin\r\n    {\r\n        // if current sale stage had not been stopped, first stop current active sale stage \r\n        Sale_Status new_sale_status= Sale_Status(2 + sale_stage_index * 2);\r\n        if(new_sale_status > sale_status)\r\n          stop_StageN_Sale(sale_stage_index);\r\n\r\n        sale_status= Sale_Status.Public_Allowed_To_Trade_STATUS;\r\n        when_public_allowed_to_trade_started= block.timestamp;\r\n        emit StartTradePublicSaleTokens(block.timestamp); \r\n    }\r\n\r\n    event StartTradeStage0SaleTokens(uint256 indexed _when);\r\n\r\n    /**\r\n     *  @dev  allow stage0 token trading\r\n     *        (run by admin )\r\n     */\r\n    function start_Stage0_Trade() internal\r\n        onlyAdmin\r\n    {\r\n        if(sale_status!= Sale_Status.Public_Allowed_To_Trade_STATUS) revert();\r\n        \r\n        // allowed 1 year later after stage1 tokens trading is enabled\r\n\r\n        uint32 stage0_locked_year= 1;\r\n \r\n        bool is_debug= false; // change to false if this contract source  is release version \r\n        if(is_debug==false && block.timestamp <  stage0_locked_year*365*24*60*60\r\n            + when_public_allowed_to_trade_started  )  \r\n\t      revert();\r\n        if(is_debug==true  && block.timestamp <  stage0_locked_year*10*60\r\n            + when_public_allowed_to_trade_started  )  \r\n\t      revert();\r\n\t      \r\n        sale_status= Sale_Status.Stage0_Allowed_To_Trade_STATUS;\r\n        when_stage0_allowed_to_trade_started= block.timestamp;\r\n        emit StartTradeStage0SaleTokens(block.timestamp); \r\n    }\r\n\r\n\r\n\r\n\r\n    event CreateTokenContract(uint256 indexed _when);\r\n\r\n    /**\r\n     *  @dev  token contract constructor(), initialized tokens supply and sale status variables\r\n     *         (run by owner when contract deploy)\r\n     */\r\n    constructor() public\r\n    {\r\n        totalSupply = _totalTokenAmount;\r\n        balances[msg.sender] = _totalTokenAmount;\r\n\r\n        sale_status= Sale_Status.Initialized_STATUS;\r\n        sale_stage_index= 0;\r\n\r\n        when_initialized= block.timestamp;\r\n\r\n        holders.push(msg.sender); \r\n        holders_received_accumul[msg.sender] += _totalTokenAmount;\r\n\r\n        emit Transfer(address(0x0), msg.sender, _totalTokenAmount);\r\n        emit InitializedStage(block.timestamp);\r\n        emit CreateTokenContract(block.timestamp); \r\n    }\r\n\r\n\r\n\r\n\r\n    /**\r\n     * @dev check if specified token transfer request is valid \r\n     *           ( internal modifier function).\r\n     *           revert  if transfer should be NOT allowed, otherwise do nothing\r\n     * @param _from   source account from whom tokens should be transferred\r\n     * @param _to   destination account to whom tokens should be transferred\r\n     * @param _value   number of tokens to be transferred\r\n     */\r\n    modifier validTransaction( address _from, address _to, uint256 _value)\r\n    {\r\n        require(_to != address(0x0));\r\n        require(_to != _from);\r\n        require(_value > 0);\r\n        if(isAdmin()==false)  {\r\n\t    // if _from is frozen account, disallow this request\r\n\t    if(account_frozen_time[_from] > 0) revert();\r\n\t    if(_value == 0 ) revert();\r\n\r\n            // if token trading is not enabled yet, disallow this request\r\n            if(sale_status < Sale_Status.Public_Allowed_To_Trade_STATUS) revert();\r\n\r\n            // if stage0 token trading is not enabled yet, disallow this request\r\n            if( sale_amount_stage0_account[_from] > 0 ) {\r\n                if(sale_status < Sale_Status.Stage0_Allowed_To_Trade_STATUS)  \r\n                    revert();\r\n            }  else {\r\n            }\r\n  \t }\r\n        _;\r\n    }\r\n\r\n\r\n    event TransferToken(address indexed _from_whom,address indexed _to_whom,\r\n         uint _token_value, uint256 indexed _when);\r\n    event TransferTokenFrom(address indexed _from_whom,address indexed _to_whom, address _agent,\r\n\t uint _token_value, uint256 indexed _when);\r\n    event TransferTokenFromByAdmin(address indexed _from_whom,address indexed _to_whom, address _admin, \r\n \t uint _token_value, uint256 indexed _when);\r\n\r\n    /**\r\n     * @dev transfer specified amount of tokens from my account to _to account \r\n     *     (run by self, public function)\r\n     * @param _to   destination account to whom tokens should be transferred\r\n     * @param _value   number of tokens to be transferred\r\n     * @return _success   report if transfer was successful, on failure revert()\r\n     */\r\n    function transfer(address _to, uint _value) public \r\n        validTransaction(msg.sender, _to,  _value)\r\n    returns (bool _success) \r\n    {\r\n        _success= super.transfer(_to, _value);\r\n        if(_success==false) revert();\r\n\r\n  \temit TransferToken(msg.sender,_to,_value,block.timestamp);\r\n\r\n\t// check if new trading holder\r\n        if(holders_received_accumul[_to]==0x0) {\r\n\t   // new holder comes\r\n           holders.push(_to); \r\n           holders_trading.push(_to);\r\n\t   emit NewHolderTrading(_to, block.timestamp);\r\n        }\r\n        holders_received_accumul[_to] += _value;\r\n\r\n\t// leave a transfer history entry\r\n        history_token_transfer.push( history_token_transfer_obj( {\r\n\t       _from: msg.sender,\r\n\t       _to: _to,\r\n\t       _token_value: _value,\r\n\t       _when: block.timestamp\r\n        } ) );\r\n    }\r\n\r\n    /**\r\n     * @dev transfer specified amount of tokens from _from account to _to account\r\n     *     (run by agent, public function)\r\n     * @param _from   client account who approved transaction performed by this sender as agent\r\n     * @param _to   destination account to whom tokens should be transferred\r\n     * @param _value   number of tokens to be transferred\r\n     * @return _success   report if transfer was successful, on failure revert()\r\n     */\r\n    function transferFrom(address _from, address _to, uint _value) public \r\n        validTransaction(_from, _to, _value)\r\n    returns (bool _success) \r\n    {\r\n        if(isAdmin()==true) {\r\n            // admins can transfer tokens of **ANY** accounts\r\n            emit TransferTokenFromByAdmin(_from,_to,msg.sender,_value,block.timestamp);\r\n            _success= super.transferFromByAdmin(_from,_to, _value);\r\n        }\r\n        else {\r\n            // approved agents can transfer tokens of their clients (clients shoukd 'approve()' agents first)\r\n            emit TransferTokenFrom(_from,_to,msg.sender,_value,block.timestamp);\r\n            _success= super.transferFrom(_from, _to, _value);\r\n        }\r\n\r\n        if(_success==false) revert();\r\n        \r\n\t// check if new trading holder\r\n        if(holders_received_accumul[_to]==0x0) {\r\n\t   // new holder comes\r\n           holders.push(_to); \r\n           holders_trading.push(_to); \r\n\t   emit NewHolderTrading(_to, block.timestamp);\r\n        }\r\n        holders_received_accumul[_to] += _value;\r\n\r\n\t// leave a transfer history entry\r\n        history_token_transfer.push( history_token_transfer_obj( {\r\n\t       _from: _from,\r\n\t       _to: _to,\r\n\t       _token_value: _value,\r\n\t       _when: block.timestamp\r\n        } ) );\r\n\r\n    }\r\n\r\n\r\n\r\n\r\n    \r\n    event IssueTokenSale(address indexed _buyer, uint _ether_value, uint _token_value,\r\n           uint _exchange_rate_now_per_wei, uint256 indexed _when);\r\n\r\n    /**\r\n     * @dev  fallback function for incoming ether, receive ethers and give tokens back\r\n     */\r\n    function () public payable {\r\n        buy();\r\n    }\r\n\r\n    event NewHolderTrading(address indexed _new_comer, uint256 indexed _when);\r\n    event NewHolderSale(address indexed _new_comer, uint256 indexed _when);\r\n    \r\n    /**\r\n     *  @dev   buy now tokens by sending some ethers  to this contract address\r\n     *       (payable public function )\r\n     */\r\n    function buy() public payable {\r\n        if(sale_status < Sale_Status.Stage0_Sale_Started_STATUS) \r\n           revert();\r\n        \r\n        if(sale_status > Sale_Status.Stage4_Sale_Stopped_STATUS) \r\n           revert();\r\n        \r\n        if((uint256(sale_status)%2)!=1)  revert(); // not in started sale status\r\n        if(isAdmin()==true)  revert(); // admins are not allowed to buy tokens\r\n\t  \r\n        uint256 tokens;\r\n        \r\n        uint256 wei_per_now= sale_price_per_stage_wei_per_now[sale_stage_index];\r\n\r\n        // if sent ether value is less than exch_rate, revert\r\n        if (msg.value <  wei_per_now) revert();\r\n\r\n        // calculate num of bought tokens based on sent ether value (in wei)\r\n\ttokens = uint256( msg.value /  wei_per_now );\r\n      \r\n        if (tokens + sold_tokens_total > totalSupply) revert();\r\n\r\n        // update token sale statistics  per stage\r\n\tif(sale_stage_index==0) sale_amount_stage0_account[msg.sender] += tokens; else\t\r\n\tif(sale_stage_index==1) sale_amount_stage1_account[msg.sender] += tokens; else\t\r\n\tif(sale_stage_index==2) sale_amount_stage2_account[msg.sender] += tokens; else\t\r\n\tif(sale_stage_index==3) sale_amount_stage3_account[msg.sender] += tokens; else\t\r\n\tif(sale_stage_index==4) sale_amount_stage4_account[msg.sender] += tokens;\t\r\n\tsold_tokens_per_stage[sale_stage_index] += tokens;\r\n        sold_tokens_total += tokens;\r\n\r\n        // update ether statistics\r\n\traised_ethers_per_stage[sale_stage_index] +=  msg.value;\r\n        raised_ethers_total +=  msg.value;\r\n\r\n        super.transferFromByAdmin(owner, msg.sender, tokens);\r\n\r\n\t// check if this holder is new\r\n        if(holders_received_accumul[msg.sender]==0x0) {\r\n\t   // new holder comes\r\n           holders.push(msg.sender); \r\n\t   if(sale_stage_index==0) holders_stage0_sale.push(msg.sender); else \r\n\t   if(sale_stage_index==1) holders_stage1_sale.push(msg.sender); else \r\n\t   if(sale_stage_index==2) holders_stage2_sale.push(msg.sender); else \r\n\t   if(sale_stage_index==3) holders_stage3_sale.push(msg.sender); else \r\n\t   if(sale_stage_index==4) holders_stage4_sale.push(msg.sender); \r\n\t   emit NewHolderSale(msg.sender, block.timestamp);\r\n        }\r\n        holders_received_accumul[msg.sender] += tokens;\r\n    \r\n        // leave a token sale history entry\r\n        history_token_sale_obj memory history = history_token_sale_obj( {\r\n\t       _buyer: msg.sender,\r\n\t       _ether_value: msg.value,\r\n\t       _token_value: tokens,\r\n\t       _when: block.timestamp\r\n        } );\r\n        if(sale_stage_index==0) history_token_sale_stage0.push( history ); else\r\n        if(sale_stage_index==1) history_token_sale_stage1.push( history ); else\r\n        if(sale_stage_index==2) history_token_sale_stage2.push( history ); else\r\n        if(sale_stage_index==3) history_token_sale_stage3.push( history ); else\r\n        if(sale_stage_index==4) history_token_sale_stage4.push( history );\r\n\r\n        emit IssueTokenSale(msg.sender, msg.value, tokens, wei_per_now, block.timestamp);\r\n        \r\n        // if target ether is reached, stop this sale stage \r\n\tif( target_ethers_per_stage[sale_stage_index] <= raised_ethers_per_stage[sale_stage_index])\r\n    \t    stop_StageN_Sale(sale_stage_index);\r\n    }\r\n\r\n\r\n    event FreezeAccount(address indexed _account_to_freeze, uint256 indexed _when);\r\n    event UnfreezeAccount(address indexed _account_to_unfreeze, uint256 indexed _when);\r\n    \r\n    /**\r\n     * @dev freeze a holder account, prohibit further token transfer \r\n     *     (run by ADMIN, public function)\r\n     * @param _account_to_freeze   account to freeze\r\n     */\r\n    function z_admin_freeze(address _account_to_freeze) public onlyAdmin   {\r\n        account_frozen_time[_account_to_freeze]= block.timestamp;\r\n        holders_frozen.push(_account_to_freeze);\r\n        emit FreezeAccount(_account_to_freeze,block.timestamp); \r\n    }\r\n\r\n    /**\r\n     * @dev unfreeze a holder account \r\n     *     (run by ADMIN, public function)\r\n     * @param _account_to_unfreeze   account to unfreeze (previously frozen)\r\n     */\r\n    function z_admin_unfreeze(address _account_to_unfreeze) public onlyAdmin   {\r\n        account_frozen_time[_account_to_unfreeze]= 0; // reset time to zero\r\n        emit UnfreezeAccount(_account_to_unfreeze,block.timestamp); \r\n    }\r\n\r\n\r\n\r\n\r\n    event CloseTokenContract(uint256 indexed _when);\r\n\r\n    /**\r\n     * @dev close this contract after burning all tokens \r\n     *     (run by ADMIN, public function )\r\n     */\r\n    function closeContract() onlyAdmin internal {\r\n\tif(sale_status < Sale_Status.Stage0_Allowed_To_Trade_STATUS)  revert();\r\n\tif(totalSupply > 0)  revert();\r\n    \taddress ScAddress = this;\r\n        emit CloseTokenContract(block.timestamp); \r\n        emit WithdrawEther(owner,ScAddress.balance,block.timestamp); \r\n\tselfdestruct(owner);\r\n    } \r\n\r\n\r\n\r\n    /**\r\n     * @dev retrieve contract's ether balance info \r\n     *     (public view function)\r\n     * @return _current_ether_balane   current contract ethereum balance ( in wei unit)\r\n     * @return _ethers_withdrawn   withdrawen ethers in wei\r\n     * @return _ethers_raised_total   total ethers gathered from token sale\r\n     */\r\n    function ContractEtherBalance() public view\r\n    returns (\r\n      uint256 _current_ether_balance,\r\n      uint256 _ethers_withdrawn,\r\n      uint256 _ethers_raised_total \r\n     ) {\r\n\t_current_ether_balance= address(this).balance;\r\n\t_ethers_withdrawn= totalEtherWithdrawed;\r\n\t_ethers_raised_total= raised_ethers_total;\r\n    } \r\n\r\n    event WithdrawEther(address indexed _addr, uint256 _value, uint256 indexed _when);\r\n\r\n    /**\r\n     * @dev transfer this contract ether balance to owner's account \r\n     *    ( public function )\r\n     * @param _withdraw_wei_value   amount to widthdraw ( in wei unit)\r\n     */\r\n    function z_admin_withdraw_ether(uint256 _withdraw_wei_value) onlyAdmin public {\r\n    \taddress ScAddress = this;\r\n    \tif(_withdraw_wei_value > ScAddress.balance) revert();\r\n    \t//if(owner.call.value(_withdraw_wei_value).gas(5000)()==false) revert();\r\n    \tif(owner.send(_withdraw_wei_value)==false) revert();\r\n        totalEtherWithdrawed += _withdraw_wei_value;\r\n        emit WithdrawEther(owner,_withdraw_wei_value,block.timestamp); \r\n    } \r\n\r\n\r\n\r\n\r\n    /**\r\n     * @dev return  list of active holders accounts and their balances \r\n     *     ( public view function )\r\n     * @param _max_num_of_items_to_display   Max Number of latest accounts items to display ( 0 means 1 )\r\n     * @return  _num_of_active_holders   number of latest holders accounts\r\n     * @return  _active_holders   array of active( balance > 0) holders\r\n     * @return  _token_balances   array of token balances \r\n     */\r\n    function list_active_holders_and_balances(uint _max_num_of_items_to_display) public view \r\n      returns (uint _num_of_active_holders,address[] _active_holders,uint[] _token_balances){\r\n      uint len = holders.length;\r\n      _num_of_active_holders = 0;\r\n      if(_max_num_of_items_to_display==0) _max_num_of_items_to_display=1;\r\n      for (uint i = len-1 ; i >= 0 ; i--) {\r\n         if( balances[ holders[i] ] != 0x0) _num_of_active_holders++;\r\n         if(_max_num_of_items_to_display == _num_of_active_holders) break;\r\n      }\r\n      _active_holders = new address[](_num_of_active_holders);\r\n      _token_balances = new uint[](_num_of_active_holders);\r\n      uint num=0;\r\n      for (uint j = len-1 ; j >= 0 && _num_of_active_holders > num ; j--) {\r\n         address addr = holders[j];\r\n         if( balances[ addr ] == 0x0) continue; // assure balance > 0\r\n         _active_holders[num] = addr;\r\n         _token_balances[num] = balances[addr];\r\n         num++;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @dev return  list of recent stage0 token sale history\r\n     *      ( public view function )\r\n     * @param _max_num_of_items_to_display   Max Number of latest history items to display ( 0 means 1 )\r\n     * @return  _num   number of latest token sale history items\r\n     * @return  _sale_holders   array of holders\r\n     * @return  _ethers   array of ethers paid\r\n     * @return  _tokens   array of tokens bought\r\n     * @return  _whens   array of sale times\r\n     */\r\n    function list_history_of_stage0_sale(uint _max_num_of_items_to_display) public view \r\n      returns (uint _num,address[] _sale_holders,uint[] _ethers,uint[] _tokens,uint[] _whens){\r\n      uint len = history_token_sale_stage0.length;\r\n      uint n= len; \r\n      if(_max_num_of_items_to_display == 0) _max_num_of_items_to_display= 1;\r\n      if(_max_num_of_items_to_display <  n) n= _max_num_of_items_to_display;\r\n      _sale_holders = new address[](n);\r\n      _ethers = new uint[](n);\r\n      _tokens = new uint[](n);\r\n      _whens = new uint[](n);\r\n      _num=0;\r\n      for (uint j = len-1 ; j >= 0 && n > _num ; j--) {\r\n         history_token_sale_obj storage obj= history_token_sale_stage0[j];\r\n         _sale_holders[_num]= obj._buyer;\r\n         _ethers[_num]=  obj._ether_value;\r\n         _tokens[_num]=  obj._token_value;\r\n         _whens[_num]=   obj._when;\r\n         _num++;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev return  list of recent stage1 token sale history \r\n     *     ( public view function )\r\n     * @param _max_num_of_items_to_display   Max Number of latest history items to display ( 0 means 1 )\r\n     * @return  _num   number of latest token sale history items\r\n     * @return  _sale_holders   array of holders\r\n     * @return  _ethers   array of ethers paid\r\n     * @return  _tokens   array of tokens bought\r\n     * @return  _whens   array of sale times\r\n     */\r\n    function list_history_of_stage1_sale(uint _max_num_of_items_to_display) public view \r\n      returns (uint _num,address[] _sale_holders,uint[] _ethers,uint[] _tokens,uint[] _whens){\r\n      uint len = history_token_sale_stage1.length;\r\n      uint n= len; \r\n      if(_max_num_of_items_to_display == 0) _max_num_of_items_to_display= 1;\r\n      if(_max_num_of_items_to_display <  n) n= _max_num_of_items_to_display;\r\n      _sale_holders = new address[](n);\r\n      _ethers = new uint[](n);\r\n      _tokens = new uint[](n);\r\n      _whens = new uint[](n);\r\n      _num=0;\r\n      for (uint j = len-1 ; j >= 0 && n > _num ; j--) {\r\n         history_token_sale_obj storage obj= history_token_sale_stage1[j];\r\n         _sale_holders[_num]= obj._buyer;\r\n         _ethers[_num]=  obj._ether_value;\r\n         _tokens[_num]=  obj._token_value;\r\n         _whens[_num]=   obj._when;\r\n         _num++;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev return  list of recent stage2 token sale history \r\n     *     ( public view function )\r\n     * @param _max_num_of_items_to_display   Max Number of latest history items to display ( 0 means 1 )\r\n     * @return  _num   number of latest token sale history items\r\n     * @return  _sale_holders   array of holders\r\n     * @return  _ethers   array of ethers paid\r\n     * @return  _tokens   array of tokens bought\r\n     * @return  _whens   array of sale times\r\n     */\r\n    function list_history_of_stage2_sale(uint _max_num_of_items_to_display) public view \r\n      returns (uint _num,address[] _sale_holders,uint[] _ethers,uint[] _tokens,uint[] _whens){\r\n      uint len = history_token_sale_stage2.length;\r\n      uint n= len; \r\n      if(_max_num_of_items_to_display == 0) _max_num_of_items_to_display= 1;\r\n      if(_max_num_of_items_to_display <  n) n= _max_num_of_items_to_display;\r\n      _sale_holders = new address[](n);\r\n      _ethers = new uint[](n);\r\n      _tokens = new uint[](n);\r\n      _whens = new uint[](n);\r\n      _num=0;\r\n      for (uint j = len-1 ; j >= 0 && n > _num ; j--) {\r\n         history_token_sale_obj storage obj= history_token_sale_stage2[j];\r\n         _sale_holders[_num]= obj._buyer;\r\n         _ethers[_num]=  obj._ether_value;\r\n         _tokens[_num]=  obj._token_value;\r\n         _whens[_num]=   obj._when;\r\n         _num++;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev return  list of recent stage3 token sale history \r\n     *     ( public view function )\r\n     * @param _max_num_of_items_to_display   Max Number of latest history items to display ( 0 means 1 )\r\n     * @return  _num   number of latest token sale history items\r\n     * @return  _sale_holders   array of holders\r\n     * @return  _ethers   array of ethers paid\r\n     * @return  _tokens   array of tokens bought\r\n     * @return  _whens   array of sale times\r\n     */\r\n    function list_history_of_stage3_sale(uint _max_num_of_items_to_display) public view \r\n      returns (uint _num,address[] _sale_holders,uint[] _ethers,uint[] _tokens,uint[] _whens){\r\n      uint len = history_token_sale_stage3.length;\r\n      uint n= len; \r\n      if(_max_num_of_items_to_display == 0) _max_num_of_items_to_display= 1;\r\n      if(_max_num_of_items_to_display <  n) n= _max_num_of_items_to_display;\r\n      _sale_holders = new address[](n);\r\n      _ethers = new uint[](n);\r\n      _tokens = new uint[](n);\r\n      _whens = new uint[](n);\r\n      _num=0;\r\n      for (uint j = len-1 ; j >= 0 && n > _num ; j--) {\r\n         history_token_sale_obj storage obj= history_token_sale_stage3[j];\r\n         _sale_holders[_num]= obj._buyer;\r\n         _ethers[_num]=  obj._ether_value;\r\n         _tokens[_num]=  obj._token_value;\r\n         _whens[_num]=   obj._when;\r\n         _num++;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev return  list of recent stage4 token sale history\r\n     *      ( public view function )\r\n     * @param _max_num_of_items_to_display   Max Number of latest history items to display ( 0 means 1 )\r\n     * @return  _num   number of latest token sale history items\r\n     * @return  _sale_holders   array of holders\r\n     * @return  _ethers   array of ethers paid\r\n     * @return  _tokens   array of tokens bought\r\n     * @return  _whens   array of sale times\r\n     */\r\n    function list_history_of_stage4_sale(uint _max_num_of_items_to_display) public view \r\n      returns (uint _num,address[] _sale_holders,uint[] _ethers,uint[] _tokens,uint[] _whens){\r\n      uint len = history_token_sale_stage4.length;\r\n      uint n= len; \r\n      if(_max_num_of_items_to_display == 0) _max_num_of_items_to_display= 1;\r\n      if(_max_num_of_items_to_display <  n) n= _max_num_of_items_to_display;\r\n      _sale_holders = new address[](n);\r\n      _ethers = new uint[](n);\r\n      _tokens = new uint[](n);\r\n      _whens = new uint[](n);\r\n      _num=0;\r\n      for (uint j = len-1 ; j >= 0 && n > _num ; j--) {\r\n         history_token_sale_obj storage obj= history_token_sale_stage4[j];\r\n         _sale_holders[_num]= obj._buyer;\r\n         _ethers[_num]=  obj._ether_value;\r\n         _tokens[_num]=  obj._token_value;\r\n         _whens[_num]=   obj._when;\r\n         _num++;\r\n      }\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev return  list of latest #N transfer history\r\n     *      ( public view function )\r\n     * @param _max_num_of_items_to_display   Max Number of latest history items to display ( 0 means 1 )\r\n     * @return  _num   number of latest transfer history items\r\n     * @return  _senders   array of senders\r\n     * @return  _receivers   array of receivers\r\n     * @return  _tokens   array of tokens transferred\r\n     * @return  _whens   array of transfer times\r\n     */\r\n    function list_history_of_token_transfer(uint _max_num_of_items_to_display) public view \r\n      returns (uint _num,address[] _senders,address[] _receivers,uint[] _tokens,uint[] _whens){\r\n      uint len = history_token_transfer.length;\r\n      uint n= len;\r\n      if(_max_num_of_items_to_display == 0) _max_num_of_items_to_display= 1;\r\n      if(_max_num_of_items_to_display <  n) n= _max_num_of_items_to_display;\r\n      _senders = new address[](n);\r\n      _receivers = new address[](n);\r\n      _tokens = new uint[](n);\r\n      _whens = new uint[](n);\r\n      _num=0;\r\n      for (uint j = len-1 ; j >= 0 && n > _num ; j--) {\r\n         history_token_transfer_obj storage obj= history_token_transfer[j];\r\n         _senders[_num]= obj._from;\r\n         _receivers[_num]= obj._to;\r\n         _tokens[_num]=  obj._token_value;\r\n         _whens[_num]=   obj._when;\r\n         _num++;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @dev return  list of latest address-filtered #N transfer history \r\n     *     ( public view function )\r\n     * @param _addr   address as filter for transfer history (default 0x0)\r\n     * @return  _num   number of latest transfer history items\r\n     * @return  _senders   array of senders\r\n     * @return  _receivers   array of receivers\r\n     * @return  _tokens   array of tokens transferred\r\n     * @return  _whens   array of transfer times\r\n     */\r\n    function list_history_of_token_transfer_filtered_by_addr(address _addr) public view \r\n      returns (uint _num,address[] _senders,address[] _receivers,uint[] _tokens,uint[] _whens){\r\n      uint len = history_token_transfer.length;\r\n      uint _max_num_of_items_to_display= 0;\r\n      history_token_transfer_obj storage obj= history_token_transfer[0];\r\n      uint j;\r\n      for (j = len-1 ; j >= 0 ; j--) {\r\n         obj= history_token_transfer[j];\r\n         if(obj._from== _addr || obj._to== _addr) _max_num_of_items_to_display++;\r\n      }\r\n      if(_max_num_of_items_to_display == 0) _max_num_of_items_to_display= 1;\r\n      _senders = new address[](_max_num_of_items_to_display);\r\n      _receivers = new address[](_max_num_of_items_to_display);\r\n      _tokens = new uint[](_max_num_of_items_to_display);\r\n      _whens = new uint[](_max_num_of_items_to_display);\r\n      _num=0;\r\n      for (j = len-1 ; j >= 0 && _max_num_of_items_to_display > _num ; j--) {\r\n         obj= history_token_transfer[j];\r\n         if(obj._from!= _addr && obj._to!= _addr) continue;\r\n         _senders[_num]= obj._from;\r\n         _receivers[_num]= obj._to;\r\n         _tokens[_num]=  obj._token_value;\r\n         _whens[_num]=   obj._when;\r\n         _num++;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @dev return frozen accounts and their balances \r\n     *     ( public view function )\r\n     * @param _max_num_of_items_to_display   Max Number of items to display ( 0 means 1 )\r\n     * @return  _num   number of currently frozen accounts\r\n     * @return  _frozen_holders   array of frozen accounts\r\n     * @return  _whens   array of frozen times\r\n     */\r\n    function list_frozen_accounts(uint _max_num_of_items_to_display) public view\r\n      returns (uint _num,address[] _frozen_holders,uint[] _whens){\r\n      uint len = holders_frozen.length;\r\n      uint num_of_frozen_holders = 0;\r\n      if(_max_num_of_items_to_display==0) _max_num_of_items_to_display=1;\r\n      for (uint i = len-1 ; i >= 0 ; i--) {\r\n         // assure currently in frozen state\r\n         if( account_frozen_time[ holders_frozen[i] ] > 0x0) num_of_frozen_holders++;\r\n         if(_max_num_of_items_to_display == num_of_frozen_holders) break;\r\n      }\r\n      _frozen_holders = new address[](num_of_frozen_holders);\r\n      _whens = new uint[](num_of_frozen_holders);\r\n      _num=0;\r\n      for (uint j = len-1 ; j >= 0 && num_of_frozen_holders > _num ; j--) {\r\n         address addr= holders_frozen[j];\r\n         uint256 when= account_frozen_time[ addr ];\r\n         if( when == 0x0) continue; // assure if frozen true\r\n         _frozen_holders[_num]= addr;\r\n         _whens[_num]= when;\r\n         _num++;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * @dev Token sale sumilation for current sale stage \r\n     *     ( public view function )\r\n     * @param _ether_or_wei_value  input ethereum value (in wei or ether unit)\r\n     * @return _num_of_tokens  number of tokens that can be bought with the input value\r\n     * @return _exch_rate  current sale stage exchange rate (wei per now)\r\n     * @return _current_sale_stage_index  current sale stage index\r\n     */\r\n    function simulate_token_sale(uint _ether_or_wei_value) public view \r\n\treturns (uint256 _num_of_tokens, uint256 _exch_rate, uint256 _current_sale_stage_index) {\r\n\tif(sale_stage_index >=5 ) return (0,0,0);\r\n\t_exch_rate= sale_price_per_stage_wei_per_now[sale_stage_index];\r\n        _current_sale_stage_index= sale_stage_index;\r\n        // determine whether the input value is in ether unit or in wei unit\r\n\tif(_ether_or_wei_value>=1000000) \r\n\t   _num_of_tokens= uint256( _ether_or_wei_value /  _exch_rate ); // guess it is in wei\r\n        else\r\n\t   _num_of_tokens= uint256( _ether_or_wei_value * WEI_PER_ETHER / _exch_rate ); // guess it is in ether\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Admin menu: Token Sale Status management\r\n     *      (run by admin, public function)\r\n     * @param _next_status  next status index (1 ~ 13). refer to enum Sale_Status \r\n     */\r\n    function z_admin_next_status(Sale_Status _next_status) onlyAdmin public {\r\n      if(_next_status== Sale_Status.Stage0_Sale_Started_STATUS) { start_StageN_Sale(0); return;} // 1\r\n      if(_next_status== Sale_Status.Stage0_Sale_Stopped_STATUS) { stop_StageN_Sale(0); return;} // 2\r\n      if(_next_status== Sale_Status.Stage1_Sale_Started_STATUS) { start_StageN_Sale(1); return;} // 3\r\n      if(_next_status== Sale_Status.Stage1_Sale_Stopped_STATUS) { stop_StageN_Sale(1); return;} // 4\r\n      if(_next_status== Sale_Status.Stage2_Sale_Started_STATUS) { start_StageN_Sale(2); return;} // 5\r\n      if(_next_status== Sale_Status.Stage2_Sale_Stopped_STATUS) { stop_StageN_Sale(2); return;} // 6\r\n      if(_next_status== Sale_Status.Stage3_Sale_Started_STATUS) { start_StageN_Sale(3); return;} // 7\r\n      if(_next_status== Sale_Status.Stage3_Sale_Stopped_STATUS) { stop_StageN_Sale(3); return;} // 8\r\n      if(_next_status== Sale_Status.Stage4_Sale_Started_STATUS) { start_StageN_Sale(4); return;} // 9\r\n      if(_next_status== Sale_Status.Stage4_Sale_Stopped_STATUS) { stop_StageN_Sale(4); return;} // 10\r\n      if(_next_status== Sale_Status.Public_Allowed_To_Trade_STATUS) { start_Public_Trade(); return;} //11\r\n      if(_next_status== Sale_Status.Stage0_Allowed_To_Trade_STATUS) { start_Stage0_Trade(); return;} //12\r\n      if(_next_status== Sale_Status.Closed_STATUS) { closeContract(); return;} //13\r\n      revert();\r\n    } \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_max_num_of_items_to_display\",\"type\":\"uint256\"}],\"name\":\"list_frozen_accounts\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_frozen_holders\",\"type\":\"address[]\"},{\"name\":\"_whens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"when_initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders_frozen\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders_stage0_sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ether_or_wei_value\",\"type\":\"uint256\"}],\"name\":\"simulate_token_sale\",\"outputs\":[{\"name\":\"_num_of_tokens\",\"type\":\"uint256\"},{\"name\":\"_exch_rate\",\"type\":\"uint256\"},{\"name\":\"_current_sale_stage_index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"z_admin_add_admin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raised_ethers_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"burned_amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_max_num_of_items_to_display\",\"type\":\"uint256\"}],\"name\":\"list_history_of_token_transfer\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_senders\",\"type\":\"address[]\"},{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_whens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherWithdrawed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale_status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_max_num_of_items_to_display\",\"type\":\"uint256\"}],\"name\":\"list_history_of_stage3_sale\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_sale_holders\",\"type\":\"address[]\"},{\"name\":\"_ethers\",\"type\":\"uint256[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_whens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"when_public_allowed_to_trade_started\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account_to_unfreeze\",\"type\":\"address\"}],\"name\":\"z_admin_unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_max_num_of_items_to_display\",\"type\":\"uint256\"}],\"name\":\"list_history_of_stage4_sale\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_sale_holders\",\"type\":\"address[]\"},{\"name\":\"_ethers\",\"type\":\"uint256[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_whens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account_to_freeze\",\"type\":\"address\"}],\"name\":\"z_admin_freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_how_many_wei_per_now\",\"type\":\"uint256\"}],\"name\":\"z_admin_set_sale_price\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ContractEtherBalance\",\"outputs\":[{\"name\":\"_current_ether_balance\",\"type\":\"uint256\"},{\"name\":\"_ethers_withdrawn\",\"type\":\"uint256\"},{\"name\":\"_ethers_raised_total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_next_status\",\"type\":\"uint8\"}],\"name\":\"z_admin_next_status\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"when_stageN_sale_started\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders_burned\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders_stage1_sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CurrentSalePrice\",\"outputs\":[{\"name\":\"_sale_price\",\"type\":\"uint256\"},{\"name\":\"_current_sale_stage_index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"z_admin_remove_admin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders_stage2_sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_max_num_of_items_to_display\",\"type\":\"uint256\"}],\"name\":\"list_active_holders_and_balances\",\"outputs\":[{\"name\":\"_num_of_active_holders\",\"type\":\"uint256\"},{\"name\":\"_active_holders\",\"type\":\"address[]\"},{\"name\":\"_token_balances\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_max_num_of_items_to_display\",\"type\":\"uint256\"}],\"name\":\"list_history_of_stage2_sale\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_sale_holders\",\"type\":\"address[]\"},{\"name\":\"_ethers\",\"type\":\"uint256[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_whens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cryptocurrency_exchange_company_accounts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchange_account\",\"type\":\"address\"}],\"name\":\"z_admin_add_exchange\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"when_stage0_allowed_to_trade_started\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"_success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"raised_ethers_per_stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders_stage3_sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sold_tokens_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders_stage4_sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdraw_wei_value\",\"type\":\"uint256\"}],\"name\":\"z_admin_withdraw_ether\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale_stage_index\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sold_tokens_per_stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"holders_trading\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBurned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"list_history_of_token_transfer_filtered_by_addr\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_senders\",\"type\":\"address[]\"},{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_whens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"target_ethers_per_stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_max_num_of_items_to_display\",\"type\":\"uint256\"}],\"name\":\"list_history_of_stage0_sale\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_sale_holders\",\"type\":\"address[]\"},{\"name\":\"_ethers\",\"type\":\"uint256[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_whens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"when_stageN_sale_stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_max_num_of_items_to_display\",\"type\":\"uint256\"}],\"name\":\"list_history_of_stage1_sale\",\"outputs\":[{\"name\":\"_num\",\"type\":\"uint256\"},{\"name\":\"_sale_holders\",\"type\":\"address[]\"},{\"name\":\"_ethers\",\"type\":\"uint256[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_whens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_admin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"AddNewAdministrator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_admin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"RemoveAdministrator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_exchange_account\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"AddNewExchangeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_stage_index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_wei_per_now_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"SaleTokenPriceSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"InitializedStage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StartStage0TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StartStage1TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StartStage2TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StartStage3TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StartStage4TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StopStage0TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StopStage1TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StopStage2TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StopStage3TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StopStage4TokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StartTradePublicSaleTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"StartTradeStage0SaleTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"CreateTokenContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from_whom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to_whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"TransferToken\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from_whom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to_whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_agent\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"TransferTokenFrom\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from_whom\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to_whom\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_admin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_token_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"TransferTokenFromByAdmin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ether_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_exchange_rate_now_per_wei\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"IssueTokenSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_new_comer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"NewHolderTrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_new_comer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"NewHolderSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account_to_freeze\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"FreezeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account_to_unfreeze\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"UnfreezeAccount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"CloseTokenContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_when\",\"type\":\"uint256\"}],\"name\":\"WithdrawEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"NOWToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://52f9b7dde061c78985b2073b5388248080393ad2225474899fe6bdbc7883dc7e"}]}