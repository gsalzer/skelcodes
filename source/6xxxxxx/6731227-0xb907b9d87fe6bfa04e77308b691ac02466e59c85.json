{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n * @title Hodler\r\n * @dev Handles hodler reward, TokenController should create and own it.\r\n */\r\n\r\n/**\r\n * @title ERC20\r\n * @dev ERC20 interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() {\r\n    owner = msg.sender;\r\n  }\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { require(msg.sender == controller); _; }\r\n    address public controller;\r\n    function Controlled() public { controller = msg.sender;}\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n/**\r\n * @title MiniMe interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20MiniMe is ERC20, Controlled {\r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool);\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOfAt(address _owner, uint _blockNumber) public view returns (uint);\r\n    function totalSupplyAt(uint _blockNumber) public view returns(uint);\r\n    function createCloneToken(string _cloneTokenName, uint8 _cloneDecimalUnits, string _cloneTokenSymbol, uint _snapshotBlock, bool _transfersEnabled) public returns(address);\r\n    function generateTokens(address _owner, uint _amount) public returns (bool);\r\n    function destroyTokens(address _owner, uint _amount)  public returns (bool);\r\n    function enableTransfers(bool _transfersEnabled) public;\r\n    function isContract(address _addr) internal view returns(bool);\r\n    function claimTokens(address _token) public;\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n    event NewCloneToken(address indexed _cloneToken, uint _snapshotBlock);\r\n}\r\n/// @dev The token controller contract must implement these functions\r\ncontract TokenController {\r\n    ERC20MiniMe public ethealToken;\r\n    address public SALE; // address where sale tokens are located\r\n    /// @notice needed for hodler handling\r\n    function addHodlerStake(address _beneficiary, uint _stake) public;\r\n    function setHodlerStake(address _beneficiary, uint256 _stake) public;\r\n    function setHodlerTime(uint256 _time) public;\r\n    /// @notice Called when `_owner` sends ether to the MiniMe Token contract\r\n    /// @param _owner The address that sent the ether to create tokens\r\n    /// @return True if the ether is accepted, false if it throws\r\n    function proxyPayment(address _owner) public payable returns(bool);\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param _from The origin of the transfer\r\n    /// @param _to The destination of the transfer\r\n    /// @param _amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param _owner The address that calls `approve()`\r\n    /// @param _spender The spender in the `approve()` call\r\n    /// @param _amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\r\n}\r\n/**\r\n * @title Hodler\r\n * @dev Handles hodler reward, TokenController should create and own it.\r\n */\r\ncontract EthealHodler is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    // HODLER reward tracker\r\n    // stake amount per address\r\n    struct HODL {\r\n        uint256 stake;\r\n        // moving ANY funds invalidates hodling of the address\r\n        bool invalid;\r\n        bool claimed3M;\r\n        bool claimed6M;\r\n        bool claimed9M;\r\n    }\r\n\r\n    mapping (address => HODL) public hodlerStakes;\r\n\r\n    // total current staking value and hodler addresses\r\n    uint256 public hodlerTotalValue;\r\n    uint256 public hodlerTotalCount;\r\n\r\n    // store dates and total stake values for 3 - 6 - 9 months after normal sale\r\n    uint256 public hodlerTotalValue3M;\r\n    uint256 public hodlerTotalValue6M;\r\n    uint256 public hodlerTotalValue9M;\r\n    uint256 public hodlerTimeStart;\r\n    uint256 public hodlerTime3M;\r\n    uint256 public hodlerTime6M;\r\n    uint256 public hodlerTime9M;\r\n\r\n    // reward HEAL token amount\r\n    uint256 public TOKEN_HODL_3M;\r\n    uint256 public TOKEN_HODL_6M;\r\n    uint256 public TOKEN_HODL_9M;\r\n\r\n    // total amount of tokens claimed so far\r\n    uint256 public claimedTokens;\r\n\r\n    \r\n    event LogHodlSetStake(address indexed _setter, address indexed _beneficiary, uint256 _value);\r\n    event LogHodlClaimed(address indexed _setter, address indexed _beneficiary, uint256 _value);\r\n    event LogHodlStartSet(address indexed _setter, uint256 _time);\r\n\r\n\r\n    /// @dev Only before hodl is started\r\n    modifier beforeHodlStart() {\r\n        if (hodlerTimeStart == 0 || now <= hodlerTimeStart)\r\n            _;\r\n    }\r\n\r\n    /// @dev Contructor, it should be created by a TokenController\r\n    function EthealHodler(uint256 _stake3m, uint256 _stake6m, uint256 _stake9m) {\r\n        TOKEN_HODL_3M = _stake3m;\r\n        TOKEN_HODL_6M = _stake6m;\r\n        TOKEN_HODL_9M = _stake9m;\r\n    }\r\n\r\n    /// @notice Adding hodler stake to an account\r\n    /// @dev Only owner contract can call it and before hodling period starts\r\n    /// @param _beneficiary Recepient address of hodler stake\r\n    /// @param _stake Amount of additional hodler stake\r\n    function addHodlerStake(address _beneficiary, uint256 _stake) public onlyOwner beforeHodlStart {\r\n        // real change and valid _beneficiary is needed\r\n        if (_stake == 0 || _beneficiary == address(0))\r\n            return;\r\n        \r\n        // add stake and maintain count\r\n        if (hodlerStakes[_beneficiary].stake == 0)\r\n            hodlerTotalCount = hodlerTotalCount.add(1);\r\n\r\n        hodlerStakes[_beneficiary].stake = hodlerStakes[_beneficiary].stake.add(_stake);\r\n\r\n        hodlerTotalValue = hodlerTotalValue.add(_stake);\r\n\r\n        LogHodlSetStake(msg.sender, _beneficiary, hodlerStakes[_beneficiary].stake);\r\n    }\r\n\r\n    /// @notice Add hodler stake for multiple addresses\r\n    function addManyHodlerStake(address[] _addr, uint256[] _stake) public onlyOwner beforeHodlStart {\r\n        require(_addr.length == _stake.length);\r\n\r\n        for (uint256 i = 0; i < _addr.length; i++) {\r\n            addHodlerStake(_addr[i], _stake[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Setting hodler stake of an account\r\n    /// @dev Only owner contract can call it and before hodling period starts\r\n    /// @param _beneficiary Recepient address of hodler stake\r\n    /// @param _stake Amount to set the hodler stake\r\n    function setHodlerStake(address _beneficiary, uint256 _stake) public onlyOwner beforeHodlStart {\r\n        // real change and valid _beneficiary is needed\r\n        if (hodlerStakes[_beneficiary].stake == _stake || _beneficiary == address(0))\r\n            return;\r\n        \r\n        // add stake and maintain count\r\n        if (hodlerStakes[_beneficiary].stake == 0 && _stake > 0) {\r\n            hodlerTotalCount = hodlerTotalCount.add(1);\r\n        } else if (hodlerStakes[_beneficiary].stake > 0 && _stake == 0) {\r\n            hodlerTotalCount = hodlerTotalCount.sub(1);\r\n        }\r\n\r\n        uint256 _diff = _stake > hodlerStakes[_beneficiary].stake ? _stake.sub(hodlerStakes[_beneficiary].stake) : hodlerStakes[_beneficiary].stake.sub(_stake);\r\n        if (_stake > hodlerStakes[_beneficiary].stake) {\r\n            hodlerTotalValue = hodlerTotalValue.add(_diff);\r\n        } else {\r\n            hodlerTotalValue = hodlerTotalValue.sub(_diff);\r\n        }\r\n        hodlerStakes[_beneficiary].stake = _stake;\r\n\r\n        LogHodlSetStake(msg.sender, _beneficiary, _stake);\r\n    }\r\n\r\n    /// @notice Set hodler stake for multiple addresses\r\n    function setManyHodlerStake(address[] _addr, uint256[] _stake) public onlyOwner beforeHodlStart {\r\n        require(_addr.length == _stake.length);\r\n\r\n        for (uint256 i = 0; i < _addr.length; i++) {\r\n            setHodlerStake(_addr[i], _stake[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice Setting hodler start period.\r\n    /// @param _time The time when hodler reward starts counting\r\n    function setHodlerTime(uint256 _time) public onlyOwner beforeHodlStart {\r\n        // since we had to redeploy the contract\r\n        // require(_time >= now);\r\n\r\n        hodlerTimeStart = _time;\r\n        hodlerTime3M = _time.add(90 days);\r\n        hodlerTime6M = _time.add(180 days);\r\n        hodlerTime9M = _time.add(270 days);\r\n\r\n        LogHodlStartSet(msg.sender, _time);\r\n    }\r\n\r\n    /// @notice Invalidates hodler account \r\n    /// @dev Gets called by EthealController#onTransfer before every transaction\r\n    function invalidate(address _account) public onlyOwner {\r\n        if (hodlerStakes[_account].stake > 0 && !hodlerStakes[_account].invalid) {\r\n            // claim before invalidating if there is something to claim\r\n            claimHodlRewardFor(_account);\r\n\r\n            // invalidate stake\r\n            hodlerStakes[_account].invalid = true;\r\n            hodlerTotalValue = hodlerTotalValue.sub(hodlerStakes[_account].stake);\r\n            hodlerTotalCount = hodlerTotalCount.sub(1);\r\n        } else {\r\n            // update hodl total values \"automatically\" - whenever someone sends funds\r\n            updateAndGetHodlTotalValue();\r\n        }\r\n    }\r\n\r\n    /// @notice Claiming HODL reward for msg.sender\r\n    function claimHodlReward() public {\r\n        claimHodlRewardFor(msg.sender);\r\n    }\r\n\r\n    /// @notice Claiming HODL reward for an address\r\n    function claimHodlRewardFor(address _beneficiary) public {\r\n        // only when the address has a valid stake\r\n        require(hodlerStakes[_beneficiary].stake > 0 && !hodlerStakes[_beneficiary].invalid);\r\n\r\n        uint256 _stake = 0;\r\n        \r\n        // update hodl total values\r\n        updateAndGetHodlTotalValue();\r\n\r\n        // claim hodl if not claimed\r\n        if (!hodlerStakes[_beneficiary].claimed3M && now >= hodlerTime3M) {\r\n            _stake = _stake.add(hodlerStakes[_beneficiary].stake.mul(TOKEN_HODL_3M).div(hodlerTotalValue3M));\r\n            hodlerStakes[_beneficiary].claimed3M = true;\r\n        }\r\n        if (!hodlerStakes[_beneficiary].claimed6M && now >= hodlerTime6M) {\r\n            _stake = _stake.add(hodlerStakes[_beneficiary].stake.mul(TOKEN_HODL_6M).div(hodlerTotalValue6M));\r\n            hodlerStakes[_beneficiary].claimed6M = true;\r\n        }\r\n        if (!hodlerStakes[_beneficiary].claimed9M && now >= hodlerTime9M) {\r\n            _stake = _stake.add(hodlerStakes[_beneficiary].stake.mul(TOKEN_HODL_9M).div(hodlerTotalValue9M));\r\n            hodlerStakes[_beneficiary].claimed9M = true;\r\n        }\r\n\r\n        if (_stake > 0) {\r\n            // increasing claimed tokens\r\n            claimedTokens = claimedTokens.add(_stake);\r\n\r\n            // transferring tokens\r\n            require(TokenController(owner).ethealToken().transfer(_beneficiary, _stake));\r\n\r\n            // log\r\n            LogHodlClaimed(msg.sender, _beneficiary, _stake);\r\n        }\r\n    }\r\n\r\n    /// @notice claimHodlRewardFor() for multiple addresses\r\n    /// @dev Anyone can call this function and distribute hodl rewards\r\n    /// @param _beneficiaries Array of addresses for which we want to claim hodl rewards\r\n    function claimHodlRewardsFor(address[] _beneficiaries) external {\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++)\r\n            claimHodlRewardFor(_beneficiaries[i]);\r\n    }\r\n\r\n    /// @notice Setting 3 - 6 - 9 months total staking hodl value if time is come\r\n    function updateAndGetHodlTotalValue() public returns (uint) {\r\n        if (hodlerTime3M > 0 && now >= hodlerTime3M && hodlerTotalValue3M == 0) {\r\n            hodlerTotalValue3M = hodlerTotalValue;\r\n        }\r\n\r\n        if (hodlerTime6M > 0 && now >= hodlerTime6M && hodlerTotalValue6M == 0) {\r\n            hodlerTotalValue6M = hodlerTotalValue;\r\n        }\r\n\r\n        if (hodlerTime9M > 0 && now >= hodlerTime9M && hodlerTotalValue9M == 0) {\r\n            hodlerTotalValue9M = hodlerTotalValue;\r\n\r\n            // since we can transfer more tokens to this contract, make it possible to retain more than the predefined limit\r\n            TOKEN_HODL_9M = TokenController(owner).ethealToken().balanceOf(this).sub(TOKEN_HODL_3M).sub(TOKEN_HODL_6M).add(claimedTokens);\r\n        }\r\n\r\n        return hodlerTotalValue;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_stake\",\"type\":\"uint256\"}],\"name\":\"setHodlerStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_HODL_6M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"claimedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTotalValue6M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTotalCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_HODL_9M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"invalidate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTime6M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTime3M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimHodlReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address[]\"},{\"name\":\"_stake\",\"type\":\"uint256[]\"}],\"name\":\"addManyHodlerStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"claimHodlRewardsFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address[]\"},{\"name\":\"_stake\",\"type\":\"uint256[]\"}],\"name\":\"setManyHodlerStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTotalValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_stake\",\"type\":\"uint256\"}],\"name\":\"addHodlerStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setHodlerTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTime9M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTimeStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTotalValue3M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimHodlRewardFor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerTotalValue9M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"hodlerStakes\",\"outputs\":[{\"name\":\"stake\",\"type\":\"uint256\"},{\"name\":\"invalid\",\"type\":\"bool\"},{\"name\":\"claimed3M\",\"type\":\"bool\"},{\"name\":\"claimed6M\",\"type\":\"bool\"},{\"name\":\"claimed9M\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updateAndGetHodlTotalValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_HODL_3M\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_stake3m\",\"type\":\"uint256\"},{\"name\":\"_stake6m\",\"type\":\"uint256\"},{\"name\":\"_stake9m\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogHodlSetStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_setter\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogHodlClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_setter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"LogHodlStartSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthealHodler","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000d3c21bcecceda100000000000000000000000000000000000000000000000001a784379d99db4200000000000000000000000000000000000000000000000005ca4ec2a79a7f67000000","Library":"","SwarmSource":"bzzr://8e0e453ba1af71e377353df5b320a68f5eb4464912309a463b470b3618b12615"}]}