{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/interfaces/Token.sol\r\n\r\ncontract Token {\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n}\r\n\r\n// File: contracts/interfaces/TokenConverter.sol\r\n\r\ncontract TokenConverter {\r\n    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n    function getReturn(Token _fromToken, Token _toToken, uint256 _fromAmount) external view returns (uint256 amount);\r\n    function convert(Token _fromToken, Token _toToken, uint256 _fromAmount, uint256 _minReturn) external payable returns (uint256 amount);\r\n}\r\n\r\n// File: contracts/interfaces/AvailableProvider.sol\r\n\r\ninterface AvailableProvider {\r\n   function isAvailable(Token _from, Token _to, uint256 _amount) external view returns (bool);\r\n}\r\n\r\n// File: contracts/utils/Ownable.sol\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event SetOwner(address _owner);\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"msg.sender is not the owner\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit SetOwner(msg.sender);\r\n    }\r\n\r\n    /**\r\n        @dev Transfers the ownership of the contract.\r\n\r\n        @param _to Address of the new owner\r\n    */\r\n    function transferTo(address _to) public onlyOwner returns (bool) {\r\n        require(_to != address(0), \"Can't transfer to address 0x0\");\r\n        emit SetOwner(_to);\r\n        owner = _to;\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/TokenConverterRouter.sol\r\n\r\ncontract TokenConverterRouter is TokenConverter, Ownable {\r\n    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n\r\n    TokenConverter[] public converters;\r\n    \r\n    mapping(address => uint256) private converterToIndex;    \r\n    mapping (address => AvailableProvider) public availability;\r\n\r\n    uint256 extraLimit;\r\n    \r\n    event AddedConverter(address _converter);\r\n    event Converted(address _converter, address _from, address _to, uint256 _amount, uint256 _return);\r\n    event SetAvailableProvider(address _converter, address _provider);\r\n    event SetExtraLimit(uint256 _extraLimit);\r\n    event RemovedConverter(address _converter);\r\n\r\n    event ConverterEvaluated(address _converter, address _from, address _to, uint256 _srcQty, uint256 _destQty);\r\n    event ConverterNotAvailable(address _converter, address _provider, address _from, address _to, uint256 _srcQty);\r\n    event ConverterError(address _converter, address _from, address _to, uint256 _srcQty);\r\n    event ConverterAvailableError(address _converter, address _provider, address _from, address _to, uint256 _srcQty);\r\n\r\n    event WithdrawTokens(address _token, address _to, uint256 _amount);\r\n    event WithdrawEth(address _to, uint256 _amount);\r\n\r\n    /*\r\n     *  @notice External function isWorker.\r\n     *  @dev Takes _worker, checks if the worker is valid. \r\n     *  @param _worker Worker address.\r\n     *  @return bool True if worker is valid, false otherwise.\r\n     */\r\n    function _issetConverter(address _converter) internal view returns (bool) {\r\n        return converterToIndex[_converter] != 0;\r\n    }\r\n    \r\n    /*\r\n    *  @notice External function allConverters.\r\n    *  @dev Return all convertes.\r\n    *  @return array with all address the converters.\r\n    */\r\n    function getConverters() external view returns (address[] memory result) {\r\n        result = new address[](converters.length - 1);\r\n        for (uint256 i = 1; i < converters.length; i++) {\r\n            result[i - 1] = converters[i];\r\n        }\r\n    }\r\n    \r\n    /*\r\n     *  @notice External function addConverter.\r\n     *  @dev Takes _converter.\r\n     *       Add converter.\r\n     *  @param _converter Converter address.\r\n     *  @return bool True if converter is added, false otherwise.\r\n     */\r\n    function addConverter(TokenConverter _converter) external onlyOwner returns (bool) {\r\n        require(!_issetConverter(_converter), \"The converter it already exist\");\r\n        uint256 index = converters.push(_converter) - 1;\r\n        converterToIndex[_converter] = index;\r\n        emit AddedConverter(_converter);\r\n        return true;\r\n    }\r\n    \r\n    /*\r\n     *  @notice External function removeConverter.\r\n     *  @dev Takes _converter and removes the converter.\r\n     *  @param _worker Converter address.\r\n     *  @return bool true if existed, false otherwise.\r\n     */\r\n    function removeConverter(address _converter) external onlyOwner returns (bool) {\r\n        require(_issetConverter(_converter), \"The converter is not exist.\");\r\n        uint256 index = converterToIndex[_converter];\r\n        TokenConverter lastConverter = converters[converters.length - 1];\r\n        converterToIndex[lastConverter] = index;\r\n        converters[index] = lastConverter;\r\n        converters.length--;\r\n        delete converterToIndex[_converter];\r\n        emit RemovedConverter(_converter);\r\n        return true;\r\n    }\r\n    \r\n    function setAvailableProvider(\r\n        TokenConverter _converter,\r\n        AvailableProvider _provider\r\n    ) external onlyOwner {\r\n        emit SetAvailableProvider(_converter, _provider);\r\n        availability[_converter] = _provider;        \r\n    }\r\n    \r\n    function setExtraLimit(uint256 _extraLimit) external onlyOwner {\r\n        emit SetExtraLimit(_extraLimit);\r\n        extraLimit = _extraLimit;\r\n    }\r\n\r\n    function convert(Token _from, Token _to, uint256 _amount, uint256 _minReturn) external payable returns (uint256) {\r\n        TokenConverter converter = _getBestConverter(_from, _to, _amount);\r\n        require(converter != address(0), \"No converter candidates\");\r\n\r\n        if (_from == ETH_ADDRESS) {\r\n            require(msg.value == _amount, \"ETH not enought\");\r\n        } else {\r\n            require(msg.value == 0, \"ETH not required\");\r\n            require(_from.transferFrom(msg.sender, this, _amount), \"Error pulling Token amount\");\r\n            require(_from.approve(converter, _amount), \"Error approving token transfer\");\r\n        }\r\n\r\n        uint256 result = converter.convert.value(msg.value)(_from, _to, _amount, _minReturn);\r\n        require(result >= _minReturn, \"Funds received below min return\");\r\n\r\n        emit Converted({\r\n            _converter: converter,\r\n            _from: _from,\r\n            _to: _to,\r\n            _amount: _amount,\r\n            _return: result\r\n        });\r\n\r\n        if (_from != ETH_ADDRESS) {\r\n            require(_from.approve(converter, 0), \"Error removing approve\");\r\n        }\r\n\r\n        if (_to == ETH_ADDRESS) {\r\n            msg.sender.transfer(result);\r\n        } else {\r\n            require(_to.transfer(msg.sender, result), \"Error sending tokens\");\r\n        }\r\n\r\n        if (_isSimulation()) {\r\n            // this is a simulation, we need a pessimistic simulation we add\r\n            // the extraLimit. reasons: this algorithm is not deterministic\r\n            // different gas depending on the best route (Kyber, Bancor, etc)\r\n            _addExtraGasLimit();\r\n        }\r\n    }\r\n\r\n    function getReturn(Token _from, Token _to, uint256 _amount) external view returns (uint256) {\r\n        return _getBestConverterView(_from, _to, _amount).getReturn(_from, _to, _amount);\r\n    }\r\n\r\n    function _isSimulation() internal view returns (bool) {\r\n        return gasleft() > block.gaslimit;\r\n    }\r\n    \r\n    function _addExtraGasLimit() internal view {\r\n        uint256 startGas = gasleft();\r\n        while (startGas - gasleft() < extraLimit) {          \r\n            assembly {\r\n                let x := mload(0x0)\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getBestConverterView(Token _from, Token _to, uint256 _amount) internal view returns (TokenConverter best) {\r\n        uint256 length = converters.length;\r\n        bytes32 bestReturn;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            TokenConverter converter = converters[i];\r\n            if (_isAvailableView(converter, _from, _to, _amount)) {\r\n                (uint256 success, bytes32 newReturn) = _safeStaticCall(\r\n                    converter,\r\n                    abi.encodeWithSelector(\r\n                        converter.getReturn.selector,\r\n                        _from,\r\n                        _to,\r\n                        _amount\r\n                    )\r\n                );\r\n\r\n                if (success == 1 && newReturn > bestReturn) {\r\n                    bestReturn = newReturn;\r\n                    best = converter;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getBestConverter(Token _from, Token _to, uint256 _amount) internal returns (TokenConverter best) {\r\n        uint256 length = converters.length;\r\n        bytes32 bestReturn;\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            TokenConverter converter = converters[i];\r\n            if (_isAvailable(converter, _from, _to, _amount)) {\r\n                (uint256 success, bytes32 newReturn) = _safeCall(\r\n                    converter,\r\n                    abi.encodeWithSelector(\r\n                        converter.getReturn.selector,\r\n                        _from,\r\n                        _to,\r\n                        _amount\r\n                    )\r\n                );\r\n\r\n                if (success == 1) {\r\n                    emit ConverterEvaluated(converter, _from, _to, _amount, uint256(newReturn));\r\n                    if (newReturn > bestReturn) {\r\n                        bestReturn = newReturn;\r\n                        best = converter;\r\n                    }\r\n                } else {\r\n                    emit ConverterError(converter, _from, _to, _amount);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function _isAvailable(address converter, Token _from, Token _to, uint256 _amount) internal returns (bool) {\r\n        AvailableProvider provider = availability[converter];\r\n        if (provider == address(0)) return true;\r\n        (uint256 success,bytes32 available) = _safeCall(\r\n            provider, abi.encodeWithSelector(\r\n                provider.isAvailable.selector,\r\n                _from,\r\n                _to,\r\n                _amount\r\n            )\r\n        );\r\n\r\n        if (success != 1) {\r\n            emit ConverterAvailableError(converter, provider, _from, _to, _amount);\r\n            return false;\r\n        }\r\n\r\n        if (available != bytes32(1)) {\r\n            emit ConverterNotAvailable(converter, provider, _from, _to, _amount);\r\n            return false;\r\n        }\r\n        \r\n        return true;\r\n    }\r\n\r\n    function _isAvailableView(address converter, Token _from, Token _to, uint256 _amount) internal view returns (bool) {\r\n        AvailableProvider provider = availability[converter];\r\n        if (provider == address(0)) return true;\r\n        (uint256 success,bytes32 available) = _safeStaticCall(\r\n            provider, abi.encodeWithSelector(\r\n                provider.isAvailable.selector,\r\n                _from,\r\n                _to,\r\n                _amount\r\n            )\r\n        );\r\n        return success == 1 && available == bytes32(1);\r\n    }\r\n\r\n    function withdrawEther(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        emit WithdrawEth(_to, _amount);\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    function withdrawTokens(\r\n        Token _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner returns (bool) {\r\n        emit WithdrawTokens(_token, _to, _amount);\r\n        return _token.transfer(_to, _amount);\r\n    }\r\n\r\n    function _safeStaticCall(\r\n        address _contract,\r\n        bytes _data\r\n    ) internal view returns (uint256 success, bytes32 result) {\r\n        assembly {\r\n            let x := mload(0x40)\r\n            success := staticcall(\r\n                            gas,                  // Send almost all gas\r\n                            _contract,            // To addr\r\n                            add(0x20, _data),     // Input is data past the first 32 bytes\r\n                            mload(_data),         // Input size is the lenght of data\r\n                            x,                    // Store the ouput on x\r\n                            0x20                  // Output is a single bytes32, has 32 bytes\r\n                        )\r\n\r\n            result := mload(x)\r\n        }\r\n    }\r\n\r\n    function _safeCall(\r\n        address _contract,\r\n        bytes _data\r\n    ) internal returns (uint256 success, bytes32 result) {\r\n        assembly {\r\n            let x := mload(0x40)\r\n            success := call(\r\n                            gas,                  // Send almost all gas\r\n                            _contract,            // To addr\r\n                            0,                    // Send ETH\r\n                            add(0x20, _data),     // Input is data past the first 32 bytes\r\n                            mload(_data),         // Input size is the lenght of data\r\n                            x,                    // Store the ouput on x\r\n                            0x20                  // Output is a single bytes32, has 32 bytes\r\n                        )\r\n\r\n            result := mload(x)\r\n        }\r\n    }\r\n\r\n    function() external payable {}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_extraLimit\",\"type\":\"uint256\"}],\"name\":\"setExtraLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"getReturn\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConverters\",\"outputs\":[{\"name\":\"result\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"converters\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"addConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_minReturn\",\"type\":\"uint256\"}],\"name\":\"convert\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"removeConverter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"availability\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_converter\",\"type\":\"address\"},{\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"setAvailableProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"AddedConverter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_return\",\"type\":\"uint256\"}],\"name\":\"Converted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"SetAvailableProvider\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_extraLimit\",\"type\":\"uint256\"}],\"name\":\"SetExtraLimit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"}],\"name\":\"RemovedConverter\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_srcQty\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_destQty\",\"type\":\"uint256\"}],\"name\":\"ConverterEvaluated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_srcQty\",\"type\":\"uint256\"}],\"name\":\"ConverterNotAvailable\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_srcQty\",\"type\":\"uint256\"}],\"name\":\"ConverterError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_converter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_provider\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_srcQty\",\"type\":\"uint256\"}],\"name\":\"ConverterAvailableError\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"SetOwner\",\"type\":\"event\"}]","ContractName":"TokenConverterRouter","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://44901fa156ed1d0c60062215c7ac97a7e1d48f2b27f85f3ef4d0cae7ab130234"}]}