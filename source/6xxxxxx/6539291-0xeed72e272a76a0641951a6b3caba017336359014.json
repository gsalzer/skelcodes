{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.0;\r\ncontract Verifier {\r\n  // Returns the address that signed a given string message\r\n  function verifyString(string message, uint8 v, bytes32 r, bytes32 s) \r\n  public pure returns (address signer) {\r\n    // The message header; we will fill in the length next\r\n      string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\r\n      uint256 lengthOffset;\r\n      uint256 length;\r\n      assembly {\r\n      // The first word of a string is its length\r\n        length := mload(message)\r\n      // The beginning of the base-10 message length in the prefix\r\n        lengthOffset := add(header, 57)\r\n    }\r\n    // Maximum length we support\r\n    require(length <= 999999);\r\n    // The length of the message's length in base-10\r\n    uint256 lengthLength = 0;\r\n    // The divisor to get the next left-most message length digit\r\n    uint256 divisor = 100000;\r\n    // Move one digit of the message length to the right at a time\r\n    while (divisor != 0) {\r\n      // The place value at the divisor\r\n      uint256 digit = length / divisor;\r\n      if (digit == 0) {\r\n        // Skip leading zeros\r\n        if (lengthLength == 0) {\r\n          divisor /= 10;\r\n          continue;\r\n        }\r\n      }\r\n      // Found a non-zero digit or non-leading zero digit\r\n      lengthLength++;\r\n      // Remove this digit from the message length's current value\r\n      length -= digit * divisor;\r\n      // Shift our base-10 divisor over\r\n      divisor /= 10;\r\n      \r\n      // Convert the digit to its ASCII representation (man ascii)\r\n      digit += 0x30;\r\n      // Move to the next character and write the digit\r\n      lengthOffset++;\r\n      assembly {\r\n        mstore8(lengthOffset, digit)\r\n      }\r\n    }\r\n    // The null string requires exactly 1 zero (unskip 1 leading 0)\r\n    if (lengthLength == 0) {\r\n      lengthLength = 1 + 0x19 + 1;\r\n    } else {\r\n      lengthLength += 1 + 0x19;\r\n    }\r\n    // Truncate the tailing zeros from the header\r\n    assembly {\r\n      mstore(header, lengthLength)\r\n    }\r\n    // Perform the elliptic curve recover operation\r\n    bytes32 check = keccak256(header, message);\r\n    return ecrecover(check, v, r, s);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"message\",\"type\":\"string\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"verifyString\",\"outputs\":[{\"name\":\"signer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"Verifier","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d49b5a8ec5aaeae52e0a6dee42176eaa614a2e1532468ea3376566ff2fcc88c3"}]}