{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary utils{\r\n    function inArray(uint[] _arr,uint _val) internal pure returns(bool){\r\n        for(uint _i=0;_i< _arr.length;_i++){\r\n            if(_arr[_i]==_val){\r\n                return true;\r\n                break;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function inArray(address[] _arr,address _val) internal pure returns(bool){\r\n        for(uint _i=0;_i< _arr.length;_i++){\r\n            if(_arr[_i]==_val){\r\n                return true;\r\n                break;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n      /**\r\n       * @dev Throws if called by any account other than the owner.\r\n       */\r\n      modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n      }\r\n  \r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract GuessEthEvents{\r\n    event drawLog(uint,uint,uint);\r\n\r\n    event guessEvt(\r\n        address indexed playerAddr,\r\n        uint[] numbers, uint amount\r\n        );\r\n    event winnersEvt(\r\n        uint blockNumber,\r\n        address indexed playerAddr,\r\n        uint amount,\r\n        uint winAmount\r\n        );\r\n    event withdrawEvt(\r\n        address indexed to,\r\n        uint256 value\r\n        );\r\n    event drawEvt(\r\n        uint indexed blocknumberr,\r\n        uint number\r\n        );\r\n    \r\n    event sponseEvt(\r\n        address indexed addr,\r\n        uint amount\r\n        );\r\n\r\n    event pauseGameEvt(\r\n        bool pause\r\n        );\r\n    event setOddsEvt(\r\n        uint odds\r\n        );\r\n  \r\n}\r\n\r\ncontract GuessEth is Ownable,GuessEthEvents{\r\n    using SafeMath for uint;\r\n\r\n    /* Player Bets */\r\n\r\n    struct bnumber{\r\n        address addr;\r\n        uint number;\r\n        uint value;\r\n        int8 result;\r\n        uint prize;\r\n    }\r\n    mapping(uint => bnumber[]) public bets;\r\n    mapping(uint => address) public betNumber;\r\n    \r\n    /* player address => blockNumber[]*/\r\n    mapping(address => uint[]) private playerBetBNumber;\r\n    \r\n    /* Awards Records */\r\n    struct winner{\r\n        bool result;\r\n        uint prize;\r\n    }\r\n    \r\n    mapping(uint => winner[]) private winners;\r\n    mapping(uint => uint) private winResult;\r\n    \r\n    address private wallet1;\r\n    address private wallet2;\r\n    \r\n    uint private predictBlockInterval=3;\r\n    uint public odds=30;\r\n    uint public blockInterval=500;\r\n    uint public curOpenBNumber=0;\r\n    uint public numberRange=100;\r\n\r\n    bool public gamePaused=false;\r\n    \r\n\r\n    /* Sponsors */\r\n    mapping(address => uint) Sponsors;\r\n    uint public balanceOfSPS=0;\r\n    address[] public SponsorAddresses;\r\n    \r\n    uint reservefund=30 ether;\r\n   \r\n  \r\n    /**\r\n    * @dev prevents contracts from interacting with fomo3d\r\n    */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n    \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    \r\n    constructor(address _wallet1,address _wallet2) public{\r\n        wallet1=_wallet1;\r\n        wallet2=_wallet2;\r\n        \r\n        curOpenBNumber=blockInterval*(block.number.div(blockInterval));\r\n    }\r\n    \r\n    function pauseGame(bool _status) public onlyOwner returns(bool){\r\n            gamePaused=_status;\r\n            emit pauseGameEvt(_status);\r\n    }\r\n    \r\n    function setOdds(uint _odds) isHuman() public onlyOwner returns(bool){\r\n            odds = _odds;\r\n            emit setOddsEvt(_odds);\r\n    }\r\n    function setReservefund(uint _reservefund) isHuman() public onlyOwner returns(bool){\r\n            reservefund = _reservefund * 1 ether;\r\n    }\r\n    \r\n    function getTargetBNumber() view isHuman() public returns(uint){\r\n        uint n;\r\n        n=blockInterval*(predictBlockInterval + block.number/blockInterval);\r\n        return n;\r\n    }\r\n    \r\n    function guess(uint[] _numbers) payable isHuman() public returns(uint){\r\n        require(msg.value  >= _numbers.length * 0.05 ether);\r\n\r\n        uint n=blockInterval*(predictBlockInterval + block.number/blockInterval);\r\n        \r\n        for(uint _i=0;_i < _numbers.length;_i++){\r\n            bnumber memory b;\r\n            \r\n            b.addr=msg.sender;\r\n            b.number=_numbers[_i];\r\n            b.value=msg.value/_numbers.length;\r\n            b.result=-1;\r\n            \r\n            bets[n].push(b);\r\n        }\r\n        \r\n        \r\n        if(utils.inArray(playerBetBNumber[msg.sender],n)==false){\r\n            playerBetBNumber[msg.sender].push(n);\r\n        }\r\n        \r\n        emit guessEvt(msg.sender,_numbers, msg.value);\r\n        \r\n        return _numbers.length;\r\n    }\r\n    \r\n\r\n    function getPlayerGuessNumbers() view public returns (uint[],uint[],uint256[],int8[],uint[]){\r\n        uint _c=0;\r\n        uint _i=0;\r\n        uint _j=0;\r\n        uint _bnumber;\r\n        uint limitRows=100;\r\n        \r\n        while(_i < playerBetBNumber[msg.sender].length){\r\n            _bnumber=playerBetBNumber[msg.sender][_i];\r\n            for(_j=0 ; _j < bets[_bnumber].length && _c < limitRows ; _j++){\r\n                if(msg.sender==bets[_bnumber][_j].addr){\r\n                    _c++;\r\n                }\r\n            }\r\n            _i++;\r\n        }\r\n\r\n        uint[] memory _blockNumbers=new uint[](_c);\r\n        uint[] memory _numbers=new uint[](_c);\r\n        uint[] memory _values=new uint[](_c);\r\n        int8[] memory _result=new int8[](_c);\r\n        uint[] memory _prize=new uint[](_c);\r\n        \r\n        if(_c<=0){\r\n            return(_blockNumbers,_numbers,_values,_result,_prize);\r\n        }\r\n\r\n        //uint[] memory _b=new uint[](bettings[_blocknumber].length);\r\n\r\n        uint _count=0;\r\n        for(_i=0 ; _i < playerBetBNumber[msg.sender].length ; _i++){\r\n            _bnumber=playerBetBNumber[msg.sender][_i];\r\n            \r\n            for(_j=0 ; _j < bets[_bnumber].length && _count < limitRows ; _j++){\r\n                if(bets[_bnumber][_j].addr == msg.sender){\r\n                    _blockNumbers[_count] = _bnumber;\r\n                    _numbers[_count] =  bets[_bnumber][_j].number;\r\n                    _values[_count] =  bets[_bnumber][_j].value;\r\n                    _result[_count] =  bets[_bnumber][_j].result;\r\n                    _prize[_count] =  bets[_bnumber][_j].prize;\r\n                    \r\n                    _count++;\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        return(_blockNumbers,_numbers,_values,_result,_prize);\r\n    }\r\n    \r\n\r\n    function draw(uint _blockNumber,uint _blockTimestamp) public onlyOwner returns (uint){\r\n        require(block.number >= curOpenBNumber + blockInterval);\r\n\r\n        /*Set open Result*/\r\n        curOpenBNumber=_blockNumber;\r\n        uint result=_blockTimestamp % numberRange;\r\n        winResult[_blockNumber]=result;\r\n\r\n        for(uint _i=0;_i < bets[_blockNumber].length;_i++){\r\n            //result+=1;\r\n            \r\n            \r\n            if(bets[_blockNumber][_i].number==result){\r\n                bets[_blockNumber][_i].result = 1;\r\n                bets[_blockNumber][_i].prize = bets[_blockNumber][_i].value * odds;\r\n                \r\n                emit winnersEvt(_blockNumber,bets[_blockNumber][_i].addr,bets[_blockNumber][_i].value,bets[_blockNumber][_i].prize);\r\n\r\n                withdraw(bets[_blockNumber][_i].addr,bets[_blockNumber][_i].prize);\r\n\r\n            }else{\r\n                bets[_blockNumber][_i].result = 0;\r\n                bets[_blockNumber][_i].prize = 0;\r\n            }\r\n        }\r\n        \r\n        emit drawEvt(_blockNumber,curOpenBNumber);\r\n        \r\n        return result;\r\n    }\r\n    \r\n    function getWinners(uint _blockNumber) view public returns(address[],uint[]){\r\n        uint _count=winners[_blockNumber].length;\r\n        \r\n        address[] memory _addresses = new address[](_count);\r\n        uint[] memory _prize = new uint[](_count);\r\n        \r\n        uint _i=0;\r\n        for(_i=0;_i<_count;_i++){\r\n            //_addresses[_i] = winners[_blockNumber][_i].addr;\r\n            _prize[_i] = winners[_blockNumber][_i].prize;\r\n        }\r\n\r\n        return (_addresses,_prize);\r\n    }\r\n\r\n    function getWinResults(uint _blockNumber) view public returns(uint){\r\n        return winResult[_blockNumber];\r\n    }\r\n    \r\n    function withdraw(address _to,uint amount) public onlyOwner returns(bool){\r\n        require(address(this).balance.sub(amount) > 0);\r\n        _to.transfer(amount);\r\n        \r\n        emit withdrawEvt(_to,amount);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function invest() isHuman payable public returns(uint){\r\n        require(msg.value >= 1 ether,\"Minima amoun:1 ether\");\r\n        \r\n        Sponsors[msg.sender] = Sponsors[msg.sender].add(msg.value);\r\n        balanceOfSPS = balanceOfSPS.add(msg.value);\r\n        \r\n        if(!utils.inArray(SponsorAddresses,msg.sender)){\r\n            SponsorAddresses.push(msg.sender);\r\n            emit sponseEvt(msg.sender,msg.value);\r\n        }\r\n\r\n        return Sponsors[msg.sender];\r\n    }\r\n    \r\n    function distribute() public onlyOwner{\r\n        if(address(this).balance < reservefund){\r\n            return;\r\n        }\r\n        \r\n        uint availableProfits=address(this).balance.sub(reservefund);\r\n        uint prft1=availableProfits.mul(3 ether).div(10 ether);\r\n        uint prft2=availableProfits.sub(prft1);\r\n        \r\n        uint _val=0;\r\n        uint _i=0;\r\n        \r\n        for(_i=0;_i<SponsorAddresses.length;_i++){\r\n            _val = (prft1 * Sponsors[SponsorAddresses[_i]]) / (balanceOfSPS);\r\n            SponsorAddresses[_i].transfer(_val);\r\n        }\r\n        \r\n        uint w1p=prft2.mul(3 ether).div(10 ether);\r\n        \r\n        wallet1.transfer(w1p);\r\n        wallet2.transfer(prft2.sub(w1p));\r\n    }\r\n    \r\n    function sharesOfSPS() view public returns(uint,uint){\r\n        return (Sponsors[msg.sender],balanceOfSPS);\r\n    }\r\n    \r\n    function getAllSponsors() view public returns(address[],uint[],uint){\r\n        uint _i=0;\r\n        uint _c=0;\r\n        for(_i=0;_i<SponsorAddresses.length;_i++){\r\n            _c+=1;\r\n        }\r\n        \r\n        address[] memory addrs=new address[](_c);\r\n        uint[] memory amounts=new uint[](_c);\r\n\r\n        for(_i=0;_i<SponsorAddresses.length;_i++){\r\n            addrs[_i]=SponsorAddresses[_i];\r\n            amounts[_i]=Sponsors[SponsorAddresses[_i]];\r\n        }\r\n        \r\n        return(addrs,amounts,balanceOfSPS);\r\n    }\r\n\r\n    function() payable isHuman() public {\r\n    }\r\n    \r\n  \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"curOpenBNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"betNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"odds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberRange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"pauseGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"SponsorAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTargetBNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numbers\",\"type\":\"uint256[]\"}],\"name\":\"guess\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"number\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"int8\"},{\"name\":\"prize\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getWinners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerGuessNumbers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"int8[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllSponsors\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sharesOfSPS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_odds\",\"type\":\"uint256\"}],\"name\":\"setOdds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gamePaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blockInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reservefund\",\"type\":\"uint256\"}],\"name\":\"setReservefund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getWinResults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"_blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"draw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceOfSPS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet1\",\"type\":\"address\"},{\"name\":\"_wallet2\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"drawLog\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"numbers\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"guessEvt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winAmount\",\"type\":\"uint256\"}],\"name\":\"winnersEvt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawEvt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blocknumberr\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"drawEvt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sponseEvt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"pause\",\"type\":\"bool\"}],\"name\":\"pauseGameEvt\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"odds\",\"type\":\"uint256\"}],\"name\":\"setOddsEvt\",\"type\":\"event\"}]","ContractName":"GuessEth","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a89d0ad62e13d90797db138c50b198a140da67e100000000000000000000000096837c46ed5c9121771ca6a4c63347bf665fb891","Library":"","SwarmSource":"bzzr://da95acff9549aa42c735ac860c1b20419b9cc82312e16dc41c5e328547f39240"}]}