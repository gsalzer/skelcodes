{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n// * Samurai Quest - Levelling game that pay ether. Version 1.\r\n// \r\n// * Developer     - Studio California\r\n//                   \"You can check out any time you like, but you can never leave\"\r\n//\r\n// * Uses Linked List to store player level\r\n//\r\n// * Refer to https://samurai-quest.hostedwiki.co/ for detailed description.\r\n\r\ncontract SamuraiQuest {\r\n\r\n    using SafeMath for uint256;\r\n    using LinkedListLib for LinkedListLib.LinkedList;\r\n\r\n    // ***Event Section\r\n    event NewSamuraiIncoming(uint256 id, bytes32 name);\r\n    event TheLastSamuraiBorn(uint256 id, bytes32 name, uint256 winning);\r\n    event Retreat(uint256 id, bytes32 name, uint256 balance);\r\n\r\n    address public owner;\r\n\r\n    uint256 public currentSamuraiId;\r\n    uint256 public totalProcessingFee;\r\n    uint256 public theLastSamuraiPot;\r\n    uint256 public theLastSamuraiEndTime;\r\n\r\n    // ***Constant Section\r\n    uint256 private constant MAX_LEVEL = 8;\r\n    uint256 private constant JOINING_FEE = 0.03 ether;\r\n    uint256 private constant PROCESSING_FEE = 0.001 ether;\r\n    uint256 private constant REFERRAL_FEE = 0.002 ether;\r\n    uint256 private constant THE_LAST_SAMURAI_FEE = 0.002 ether;\r\n    uint256 private constant THE_LAST_SAMURAI_COOLDOWN = 1 days;\r\n\r\n    struct Samurai {\r\n        uint256 level;\r\n        uint256 supporterWallet;\r\n        uint256 referralWallet;\r\n        uint256 theLastSamuraiWallet;\r\n        bytes32 name;\r\n        address addr;\r\n        bool isRetreat;\r\n        bool autoLevelUp;\r\n    }\r\n\r\n    mapping (address => uint256) public addressToId;\r\n    mapping (uint256 => Samurai) public idToSamurai;\r\n    mapping (uint256 => uint256) public idToSamuraiHeadId;\r\n    mapping (uint256 => uint256) public idToAffiliateId;\r\n    mapping (uint256 => uint256) public supporterCount;\r\n    mapping (uint256 => uint256) public referralCount;\r\n    \r\n    mapping (uint256 => LinkedListLib.LinkedList) private levelChain; // level up chain\r\n    uint256[9] public levelUpFee; // level up fees\r\n\r\n    // Constructor. Deliberately does not take any parameters.\r\n    constructor() public {\r\n        // Set the contract owner\r\n        owner = msg.sender;\r\n\r\n        totalProcessingFee = 0;\r\n        theLastSamuraiPot = 0;\r\n        currentSamuraiId = 1;\r\n        \r\n        // Level up fee\r\n        levelUpFee[1] = 0.02 ether; // 0 > 1\r\n        levelUpFee[2] = 0.04 ether; // 1 > 2\r\n        levelUpFee[3] = 0.08 ether; // 2 > 3\r\n        levelUpFee[4] = 0.16 ether; // 3 > 4\r\n        levelUpFee[5] = 0.32 ether; // 4 > 5\r\n        levelUpFee[6] = 0.64 ether; // 5 > 6\r\n        levelUpFee[7] = 1.28 ether; // 6 > 7\r\n        levelUpFee[8] = 2.56 ether; // 7 > 8\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"OnlyOwner method called by non owner\");\r\n        _;\r\n    }\r\n\r\n    // Fund withdrawal to cover costs of operation\r\n    function withdrawProcessingFee() public onlyOwner {\r\n        require(totalProcessingFee <= address(this).balance, \"not enough fund\");\r\n    \r\n        uint256 amount = totalProcessingFee;\r\n\r\n        totalProcessingFee = 0;\r\n\r\n        owner.transfer(amount);\r\n    }\r\n\r\n    // Fallback function deliberately left empty.\r\n    function () public payable { }\r\n\r\n    /// *** join Logic\r\n\r\n    // Set the samurai info and level to 0, then level up it\r\n    // _name        - Name of the samurai\r\n    // _affiliateId - Affiliate Id, affiliate will get 0.002ETH of each action\r\n    //                performed by it's referral\r\n    // _autoLevelUp - Let player control the level up type\r\n    function join(bytes32 _name, uint256 _affiliateId, bool _autoLevelUp) public payable {\r\n        require(msg.value == JOINING_FEE, \"you have no enough courage\");\r\n        require(addressToId[msg.sender] == 0, \"you're already in\");\r\n        require(_affiliateId >= 0 && _affiliateId < currentSamuraiId, \"invalid affiliate\");\r\n\r\n        Samurai storage samurai = idToSamurai[currentSamuraiId];\r\n        \r\n        samurai.level = 0;\r\n        samurai.addr = msg.sender;\r\n        samurai.referralWallet = 0;\r\n        samurai.theLastSamuraiWallet = 0;\r\n        samurai.name = _name;\r\n        samurai.isRetreat = false;\r\n        samurai.autoLevelUp = _autoLevelUp;\r\n        samurai.supporterWallet = JOINING_FEE;\r\n\r\n        addressToId[msg.sender] = currentSamuraiId;\r\n\r\n        if (_affiliateId > 0) {\r\n            idToAffiliateId[currentSamuraiId] = _affiliateId;\r\n            referralCount[_affiliateId] = referralCount[_affiliateId].add(1);\r\n        }\r\n\r\n        levelUp(currentSamuraiId);\r\n\r\n        emit NewSamuraiIncoming(currentSamuraiId, samurai.name);\r\n\r\n        // Increase the count for next samurai\r\n        currentSamuraiId = currentSamuraiId.add(1);\r\n        theLastSamuraiEndTime = now.add(THE_LAST_SAMURAI_COOLDOWN);\r\n    }\r\n\r\n    /// *** levelUp Logic\r\n\r\n    // Level up the samurai, push it to the next level chain\r\n    // Help checking the last samurai pot\r\n    // Distribute the fund to corresponding accounts\r\n    // Help levelling up the head of samurai \r\n    // _samuraiId - Id of the samurai to be levelled up\r\n    function levelUp(uint256 _samuraiId) public {\r\n        bool exist;\r\n        uint256 samuraiHeadId;\r\n        Samurai storage samurai = idToSamurai[_samuraiId];\r\n        \r\n        require(canLevelUp(_samuraiId), \"cannot level up\");\r\n\r\n        uint256 balance = samurai.supporterWallet.add(samurai.referralWallet).add(samurai.theLastSamuraiWallet);\r\n\r\n        require(\r\n            balance >= levelUpFee[samurai.level.add(1)].add(PROCESSING_FEE).add(THE_LAST_SAMURAI_FEE).add(REFERRAL_FEE),\r\n            \"not enough fund to level up\"\r\n        );\r\n\r\n        // level up\r\n        samurai.level = samurai.level.add(1);\r\n\r\n        // help checking the last samurai pot\r\n        distributeTheLastSamuraiPot();\r\n\r\n        // push the samurai Id to the corresponding level chain\r\n        push(levelChain[samurai.level], _samuraiId);\r\n        supporterCount[_samuraiId] = 0;\r\n\r\n        // Check if head exist, and get it's Id\r\n        (exist, samuraiHeadId) = levelChain[samurai.level].getAdjacent(0, true);\r\n        \r\n        // Distribute 0.001 ETH to poor developer\r\n        samurai.supporterWallet = samurai.supporterWallet.sub(PROCESSING_FEE);\r\n        totalProcessingFee = totalProcessingFee.add(PROCESSING_FEE);\r\n\r\n        // Distribute 0.002 ETH to the last samurai pot\r\n        samurai.supporterWallet = samurai.supporterWallet.sub(THE_LAST_SAMURAI_FEE);\r\n        theLastSamuraiPot = theLastSamuraiPot.add(THE_LAST_SAMURAI_FEE);\r\n        \r\n        // Distribute 0.002 ETH to affiliate/the last samurai pot\r\n        uint256 affiliateId = idToAffiliateId[_samuraiId];\r\n\r\n        samurai.supporterWallet = samurai.supporterWallet.sub(REFERRAL_FEE);\r\n        if (affiliateId == 0) {\r\n            theLastSamuraiPot = theLastSamuraiPot.add(REFERRAL_FEE);\r\n        } else {\r\n            Samurai storage affiliate = idToSamurai[affiliateId];\r\n            affiliate.referralWallet = affiliate.referralWallet.add(REFERRAL_FEE);\r\n        }\r\n\r\n        // check if samuraiHead exist and it should not be Samurai itself\r\n        if (exist && samuraiHeadId != _samuraiId) {\r\n            Samurai storage samuraiHead = idToSamurai[samuraiHeadId];\r\n\r\n            // Distribute the level up fee to samuraiHead\r\n            samurai.supporterWallet = samurai.supporterWallet.sub(levelUpFee[samurai.level]);\r\n            samuraiHead.supporterWallet = samuraiHead.supporterWallet.add(levelUpFee[samurai.level]);\r\n\r\n            // Map the samuraiId to samuraiHead struct\r\n            idToSamuraiHeadId[_samuraiId] = samuraiHeadId;\r\n\r\n            // Add up the supporter count of samuraiHead\r\n            supporterCount[samuraiHeadId] = supporterCount[samuraiHeadId].add(1);\r\n\r\n            // nested loop to level up samuraiHead\r\n            if(canLevelUp(samuraiHeadId)) {\r\n                // pop the samurai headoff the leve chain\r\n                pop(levelChain[samuraiHead.level]);\r\n                \r\n                if(samuraiHead.autoLevelUp) {\r\n                    levelUp(samuraiHeadId);\r\n                } else {\r\n                    return;\r\n                }\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// *** retreat Logic\r\n    \r\n    // Retreat the samurai, pop it off the level chain\r\n    // Help checking the last samurai pot\r\n    // Distribute the fund to corresponding accounts\r\n    // _samuraiId - Id of the samurai to be retreat\r\n    function retreat(uint256 _samuraiId) public {\r\n        Samurai storage samurai = idToSamurai[_samuraiId];\r\n\r\n        require(!samurai.isRetreat, \"you've already quit!\");\r\n        require(samurai.addr == msg.sender, \"you must be a yokai spy!\");\r\n\r\n        uint256 balance = samurai.supporterWallet.add(samurai.referralWallet).add(samurai.theLastSamuraiWallet);\r\n\r\n        require(balance >= 0.005 ether, \"fee is required, even when retreating\");\r\n\r\n        // Clear the balance, prevent re-entrancy\r\n        samurai.supporterWallet = 0;\r\n        samurai.theLastSamuraiWallet = 0;\r\n        samurai.referralWallet = 0;\r\n\r\n        // pop the player off the level chain and mark the retreat flag\r\n        remove(levelChain[samurai.level], _samuraiId);\r\n        samurai.isRetreat = true;\r\n        \r\n        // Transfer the processing fee to poor developer\r\n        balance = balance.sub(PROCESSING_FEE);\r\n        totalProcessingFee = totalProcessingFee.add(PROCESSING_FEE);\r\n\r\n        balance = balance.sub(THE_LAST_SAMURAI_FEE);\r\n        theLastSamuraiPot = theLastSamuraiPot.add(THE_LAST_SAMURAI_FEE);\r\n\r\n        balance = balance.sub(REFERRAL_FEE);\r\n\r\n        uint256 affiliateId = idToAffiliateId[_samuraiId];\r\n\r\n        // No affiliate, distribute the referral fee to the last samurai pot\r\n        if (affiliateId == 0) {\r\n            theLastSamuraiPot = theLastSamuraiPot.add(REFERRAL_FEE);\r\n        } else {\r\n            Samurai storage affiliate = idToSamurai[affiliateId];\r\n            affiliate.referralWallet = affiliate.referralWallet.add(REFERRAL_FEE);\r\n        }\r\n\r\n        // transfer balance to account holder\r\n        samurai.addr.transfer(balance);\r\n\r\n        // help checking the last samurai pot\r\n        distributeTheLastSamuraiPot();\r\n\r\n        emit Retreat(_samuraiId, samurai.name, balance);\r\n    }\r\n\r\n    /// *** withdraw Logic\r\n    \r\n    // Withdraw the left over fund in wallet after retreat\r\n    // _samuraiId - Id of the samurai\r\n    function withdraw(uint256 _samuraiId) public {\r\n        Samurai storage samurai = idToSamurai[_samuraiId];\r\n\r\n        require(samurai.addr == msg.sender, \"you must be a yokai spy!\");\r\n\r\n        uint256 balance = samurai.supporterWallet.add(samurai.referralWallet).add(samurai.theLastSamuraiWallet);\r\n\r\n        require(balance <= address(this).balance, \"not enough fund\");\r\n\r\n        // Prevent re-entrancy\r\n        samurai.supporterWallet = 0;\r\n        samurai.theLastSamuraiWallet = 0;\r\n        samurai.referralWallet = 0;\r\n\r\n        // transfer balance to account holder\r\n        samurai.addr.transfer(balance);\r\n    }\r\n\r\n    /// *** distributeTheLastSamuraiPot Logic\r\n    \r\n    // Distribute the last samurai pot to winner when no joining after 24 hours\r\n    // Distribute the fund to corresponding accounts\r\n    // _samuraiId - Id of the samurai to be retreat\r\n    function distributeTheLastSamuraiPot() public {\r\n        require(theLastSamuraiPot <= address(this).balance, \"not enough fund\");\r\n\r\n        // When the remaining time is over\r\n        if (theLastSamuraiEndTime <= now) {\r\n            uint256 samuraiId = currentSamuraiId.sub(1);\r\n            Samurai storage samurai = idToSamurai[samuraiId];\r\n\r\n            uint256 total = theLastSamuraiPot;\r\n            \r\n            // again, prevent re-entrancy\r\n            theLastSamuraiPot = 0;\r\n            samurai.theLastSamuraiWallet = samurai.theLastSamuraiWallet.add(total);\r\n\r\n            emit TheLastSamuraiBorn(samuraiId, samurai.name, total);\r\n        }\r\n    }\r\n\r\n    /// *** toggleAutoLevelUp Logic\r\n    \r\n    // Toggle auto level up, for those who don't intend to play longer,\r\n    // can set the auto level up to false\r\n    // _samuraiId - Id of the samurai\r\n    function toggleAutoLevelUp(uint256 _samuraiId) public {\r\n        Samurai storage samurai = idToSamurai[_samuraiId];\r\n\r\n        require(!samurai.isRetreat, \"you've already quit!\");\r\n        require(msg.sender == samurai.addr, \"you must be a yokai spy\");\r\n\r\n        samurai.autoLevelUp = !samurai.autoLevelUp;\r\n    }\r\n\r\n    //*** For UI\r\n\r\n    // Returns - Id\r\n    function getSamuraiId() public view returns(uint256) {\r\n        return addressToId[msg.sender];\r\n    }\r\n\r\n    // Returns - 0: id, 1: level, 2: name, 3: isRetreat, 4: autoLevelUp, 5: isHead\r\n    function getSamuraiInfo(uint256 _samuraiId) public view\r\n        returns(uint256, uint256, bytes32, bool, bool, bool)\r\n    {\r\n        Samurai memory samurai = idToSamurai[_samuraiId];\r\n        bool isHead = isHeadOfSamurai(_samuraiId);\r\n        \r\n        return (_samuraiId, samurai.level, samurai.name, samurai.isRetreat, samurai.autoLevelUp, isHead);\r\n    }\r\n\r\n    // Returns - 0: supperterWallet, 1: theLastSamuraiWallet, 2: referralWallet\r\n    function getSamuraiWallet(uint256 _samuraiId) public view\r\n        returns(uint256, uint256, uint256)\r\n    {\r\n        Samurai memory samurai = idToSamurai[_samuraiId];\r\n\r\n        return (samurai.supporterWallet, samurai.theLastSamuraiWallet, samurai.referralWallet);\r\n    }\r\n    \r\n    // Returns - 0: affiliateId, 1: affiliateName\r\n    function getAffiliateInfo(uint256 _samuraiId) public view returns(uint256, bytes32) {\r\n        uint256 affiliateId = idToAffiliateId[_samuraiId];\r\n        Samurai memory affiliate = idToSamurai[affiliateId];\r\n\r\n        return (affiliateId, affiliate.name);\r\n    }\r\n\r\n    // Returns - 0: samuraiHeadId, 1: samuraiHeadName\r\n    function contributeTo(uint256 _samuraiId) public view returns(uint256, bytes32) {\r\n        uint256 samuraiHeadId = idToSamuraiHeadId[_samuraiId];\r\n        Samurai memory samuraiHead = idToSamurai[samuraiHeadId];\r\n\r\n        return (samuraiHeadId, samuraiHead.name);\r\n    }\r\n\r\n    // Returns - 0: theLastSamuraiEndTime, 1: theLastSamuraiPot, 2: lastSamuraiId, 3: lastSamuraiName\r\n    function getTheLastSamuraiInfo() public view returns(uint256, uint256, uint256, bytes32) {\r\n        uint256 lastSamuraiId = currentSamuraiId.sub(1);\r\n\r\n        return (theLastSamuraiEndTime, theLastSamuraiPot, lastSamuraiId, idToSamurai[lastSamuraiId].name);\r\n    }\r\n    \r\n    // Returns - canLevelUp\r\n    function canLevelUp(uint256 _id) public view returns(bool) {\r\n        Samurai memory samurai = idToSamurai[_id];\r\n        \r\n        return !samurai.isRetreat && (samurai.level == 0 || (supporterCount[_id] == 2 ** samurai.level && samurai.level <= MAX_LEVEL));\r\n    }\r\n\r\n    // Returns - canRetreat\r\n    function canRetreat(uint256 _id) public view returns(bool) {\r\n        Samurai memory samurai = idToSamurai[_id];\r\n        uint256 balance = samurai.supporterWallet.add(samurai.referralWallet).add(samurai.theLastSamuraiWallet);\r\n\r\n        return !samurai.isRetreat && (balance >= 0.005 ether);\r\n    }\r\n\r\n    // Returns - canWithdraw\r\n    function canWithdraw(uint256 _id) public view returns(bool) {\r\n        Samurai memory samurai = idToSamurai[_id];\r\n        uint256 balance = samurai.supporterWallet.add(samurai.referralWallet).add(samurai.theLastSamuraiWallet);\r\n\r\n        return samurai.isRetreat && (balance > 0);\r\n    }\r\n\r\n    // Returns - isHeadOfSamurai\r\n    function isHeadOfSamurai(uint256 _id) public view returns(bool) {\r\n        Samurai memory samurai = idToSamurai[_id];\r\n        bool exist;\r\n        uint256 samuraiHeadId;\r\n\r\n        (exist, samuraiHeadId) = levelChain[samurai.level].getAdjacent(0, true);\r\n\r\n        return (exist && samuraiHeadId == _id);\r\n    }\r\n    \r\n    // For linked list manipulation\r\n    function push(LinkedListLib.LinkedList storage _levelChain, uint256 _samuraiId) private {\r\n        _levelChain.push(_samuraiId, false);\r\n    }\r\n    \r\n    function pop(LinkedListLib.LinkedList storage _levelChain) private {\r\n        _levelChain.pop(true);\r\n    }\r\n    \r\n    function remove(LinkedListLib.LinkedList storage _levelChain, uint256 _samuraiId) private {\r\n        _levelChain.remove(_samuraiId);\r\n    }\r\n}\r\n\r\n/**\r\n * @title LinkedListLib\r\n * @author Darryl Morris (o0ragman0o) and Modular.network\r\n * \r\n * This utility library was forked from https://github.com/o0ragman0o/LibCLL\r\n * into the Modular-Network ethereum-libraries repo at https://github.com/Modular-Network/ethereum-libraries\r\n * It has been updated to add additional functionality and be more compatible with solidity 0.4.18\r\n * coding patterns.\r\n *\r\n * version 1.0.0\r\n * Copyright (c) 2017 Modular Inc.\r\n * The MIT License (MIT)\r\n * https://github.com/Modular-Network/ethereum-libraries/blob/master/LICENSE\r\n * \r\n * The LinkedListLib provides functionality for implementing data indexing using\r\n * a circlular linked list.\r\n *\r\n * Modular provides smart contract services and security reviews for contract\r\n * deployments in addition to working on open source projects in the Ethereum\r\n * community. Our purpose is to test, document, and deploy reusable code onto the\r\n * blockchain and improve both security and usability. We also educate non-profits,\r\n * schools, and other community members about the application of blockchain\r\n * technology. For further information: modular.network.\r\n *\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\r\n * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\r\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\r\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\r\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n*/\r\n\r\nlibrary LinkedListLib {\r\n\r\n\r\n    uint256 private constant NULL = 0;\r\n    uint256 private constant HEAD = 0;\r\n    bool private constant PREV = false;\r\n    bool private constant NEXT = true;\r\n    \r\n    struct LinkedList {\r\n        mapping (uint256 => mapping (bool => uint256)) list;\r\n    }\r\n\r\n  /// @dev returns true if the list exists\r\n  /// @param self stored linked list from contract\r\n    function listExists(LinkedList storage self)\r\n        internal\r\n        view returns (bool)\r\n    {\r\n        // if the head nodes previous or next pointers both point to itself, then there are no items in the list\r\n        if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /// @dev returns true if the node exists\r\n    /// @param self stored linked list from contract\r\n    /// @param _node a node to search for\r\n    function nodeExists(LinkedList storage self, uint256 _node) \r\n        internal\r\n        view returns (bool)\r\n    {\r\n        if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) {\r\n            if (self.list[HEAD][NEXT] == _node) {\r\n                return true;\r\n            } else {\r\n                return false;\r\n            }\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n  \r\n    /// @dev Returns the number of elements in the list\r\n    /// @param self stored linked list from contract\r\n    function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) {\r\n        bool exists;\r\n        uint256 i;\r\n        (exists, i) = getAdjacent(self, HEAD, NEXT);\r\n        while (i != HEAD) {\r\n            (exists, i) = getAdjacent(self, i, NEXT);\r\n            numElements++;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /// @dev Returns the links of a node as a tuple\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to get\r\n    function getNode(LinkedList storage self, uint256 _node)\r\n        internal view returns (bool, uint256, uint256)\r\n    {\r\n        if (!nodeExists(self, _node)) {\r\n            return (false, 0, 0);\r\n        } else {\r\n            return (true, self.list[_node][PREV], self.list[_node][NEXT]);\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the link of a node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node id of the node to step from\r\n    /// @param _direction direction to step in\r\n    function getAdjacent(LinkedList storage self, uint256 _node, bool _direction)\r\n        internal view returns (bool, uint256)\r\n    {\r\n        if (!nodeExists(self, _node)) {\r\n            return (false, 0);\r\n        } else {\r\n            return (true, self.list[_node][_direction]);\r\n        }\r\n    }\r\n  \r\n    /// @dev Can be used before `insert` to build an ordered list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node an existing node to search from, e.g. HEAD.\r\n    /// @param _value value to seek\r\n    /// @param _direction direction to seek in\r\n    //  @return next first node beyond '_node' in direction `_direction`\r\n    function getSortedSpot(LinkedList storage self, uint256 _node, uint256 _value, bool _direction)\r\n        internal view returns (uint256)\r\n    {\r\n        if (sizeOf(self) == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require((_node == 0) || nodeExists(self, _node));\r\n\r\n        bool exists;\r\n        uint256 next;\r\n\r\n        (exists, next) = getAdjacent(self, _node, _direction);\r\n\r\n        while ((next != 0) && (_value != next) && ((_value < next) != _direction)) {\r\n            next = self.list[next][_direction];\r\n        }\r\n\r\n        return next;\r\n    }\r\n\r\n    /// @dev Creates a bidirectional link between two nodes on direction `_direction`\r\n    /// @param self stored linked list from contract\r\n    /// @param _node first node for linking\r\n    /// @param _link  node to link to in the _direction\r\n    function createLink(LinkedList storage self, uint256 _node, uint256 _link, bool _direction)\r\n        internal\r\n    {\r\n        self.list[_link][!_direction] = _node;\r\n        self.list[_node][_direction] = _link;\r\n    }\r\n\r\n    /// @dev Insert node `_new` beside existing node `_node` in direction `_direction`.\r\n    /// @param self stored linked list from contract\r\n    /// @param _node existing node\r\n    /// @param _new  new node to insert\r\n    /// @param _direction direction to insert node in\r\n    function insert(LinkedList storage self, uint256 _node, uint256 _new, bool _direction) internal returns (bool) {\r\n        if (!nodeExists(self, _new) && nodeExists(self, _node)) {\r\n            uint256 c = self.list[_node][_direction];\r\n            createLink(self, _node, _new, _direction);\r\n            createLink(self, _new, c, _direction);\r\n\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    /// @dev removes an entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node node to remove from the list\r\n    function remove(LinkedList storage self, uint256 _node) internal returns (uint256) {\r\n        if ((_node == NULL) || (!nodeExists(self, _node))) {\r\n            return 0;\r\n        }\r\n\r\n        createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT);\r\n        delete self.list[_node][PREV];\r\n        delete self.list[_node][NEXT];\r\n\r\n        return _node;\r\n    }\r\n\r\n    /// @dev pushes an entry to the head of the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _node new entry to push to the head\r\n    /// @param _direction push to the head (NEXT) or tail (PREV)\r\n    function push(LinkedList storage self, uint256 _node, bool _direction)    \r\n        internal returns (bool)\r\n    {\r\n        return insert(self, HEAD, _node, _direction);\r\n    }\r\n    \r\n    /// @dev pops the first entry from the linked list\r\n    /// @param self stored linked list from contract\r\n    /// @param _direction pop from the head (NEXT) or the tail (PREV)\r\n    function pop(LinkedList storage self, bool _direction) \r\n        internal returns (uint256)\r\n    {\r\n        bool exists;\r\n        uint256 adj;\r\n\r\n        (exists, adj) = getAdjacent(self, HEAD, _direction);\r\n\r\n        return remove(self, adj);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        \r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"currentSamuraiId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"isHeadOfSamurai\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theLastSamuraiEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_samuraiId\",\"type\":\"uint256\"}],\"name\":\"levelUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTheLastSamuraiInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_samuraiId\",\"type\":\"uint256\"}],\"name\":\"getSamuraiWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToSamurai\",\"outputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"supporterWallet\",\"type\":\"uint256\"},{\"name\":\"referralWallet\",\"type\":\"uint256\"},{\"name\":\"theLastSamuraiWallet\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"isRetreat\",\"type\":\"bool\"},{\"name\":\"autoLevelUp\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_samuraiId\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_samuraiId\",\"type\":\"uint256\"}],\"name\":\"retreat\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"canLevelUp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToSamuraiHeadId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_samuraiId\",\"type\":\"uint256\"}],\"name\":\"getAffiliateInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"levelUpFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_samuraiId\",\"type\":\"uint256\"}],\"name\":\"getSamuraiInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"canRetreat\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_samuraiId\",\"type\":\"uint256\"}],\"name\":\"contributeTo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"supporterCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"referralCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawProcessingFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affiliateId\",\"type\":\"uint256\"},{\"name\":\"_autoLevelUp\",\"type\":\"bool\"}],\"name\":\"join\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalProcessingFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"theLastSamuraiPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributeTheLastSamuraiPot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_samuraiId\",\"type\":\"uint256\"}],\"name\":\"toggleAutoLevelUp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"idToAffiliateId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSamuraiId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"canWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"}],\"name\":\"NewSamuraiIncoming\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"winning\",\"type\":\"uint256\"}],\"name\":\"TheLastSamuraiBorn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Retreat\",\"type\":\"event\"}]","ContractName":"SamuraiQuest","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ac5c3287f4c41b0f3a849812c5067a576538038e77a7e62dac11bfca11db6e4e"}]}