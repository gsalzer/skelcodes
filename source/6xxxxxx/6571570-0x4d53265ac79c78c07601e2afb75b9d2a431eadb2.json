{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract BossWage {\r\n  uint256 public stakingRequirement;\r\n  function buy(address _referredBy) public payable returns(uint256) {}\r\n  function balanceOf(address _customerAddress) view public returns(uint256) {}\r\n  function exit() public {}\r\n  function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {}\r\n  function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) { }\r\n  function myDividends(bool _includeReferralBonus) public view returns(uint256) {}\r\n  function withdraw() public {}\r\n  function getDividends(address _customerAddress, bool _includeReferralBonus) public view returns(uint256) {}\r\n}\r\n\r\ncontract Trends {\r\n  using SafeMath for uint256;\r\n  \r\n  uint256 constant internal initialTokenPrice = 0.0000001 ether;\r\n  uint256 constant internal tokenPriceIncremental = 0.00000001 ether;\r\n  uint256 constant internal magnitude = 2**64;\r\n  uint8 constant internal dividendFee = 20;\r\n  uint8 constant internal bonusFee = 100;\r\n  BossWage constant public bosswage = BossWage(0xbE67a76368dECa7420cEE6adcc9A86a887AE1716);\r\n  \r\n  struct Trend {\r\n    string topic;\r\n    uint256 supply;\r\n    uint256 profitPerShare;\r\n    uint256 created;\r\n    mapping(address => uint256) balances;\r\n    mapping(address => int256) payouts;\r\n  }\r\n  \r\n  mapping(bytes32 => Trend) public trends;\r\n  mapping(address => uint256) public referrals;\r\n  \r\n  event Purchase(\r\n    bytes32 indexed trendId,\r\n    address indexed owner,\r\n    uint256 incomingEthereum,\r\n    uint256 tokensMinted,\r\n    address indexed referredBy\r\n  );\r\n\r\n  event Sell(\r\n    bytes32 indexed trendId,\r\n    address indexed owner,\r\n    uint256 tokensBurned,\r\n    uint256 ethereumEarned\r\n  );\r\n\r\n  event Reinvestment(\r\n    bytes32 indexed trendId,\r\n    address indexed owner,\r\n    uint256 ethereumReinvested,\r\n    uint256 tokensMinted,\r\n    address indexed referredBy\r\n  );\r\n  \r\n  event ReinvestReferrals(\r\n    bytes32 indexed trendId,\r\n    address indexed owner,\r\n    uint256 ethereumReinvested,\r\n    uint256 tokensMinted,\r\n    address indexed referredBy\r\n  );\r\n\r\n  event Withdraw(\r\n    bytes32 indexed trendId,\r\n    address indexed owner,\r\n    uint256 ethereumWithdrawn\r\n  );\r\n  \r\n  event WithdrawReferrals(\r\n    address indexed owner,\r\n    uint256 ethereumWithdrawn\r\n  );\r\n  \r\n  event Created(\r\n    bytes32 indexed trendId,\r\n    address indexed owner\r\n  );\r\n  \r\n  // only people with tokens\r\n  modifier onlyBagholders(bytes32 _trendId) {\r\n    require(balanceOf(_trendId, msg.sender) > 0);\r\n    _;\r\n  }\r\n\r\n  // only people with profits\r\n  modifier onlyStronghands(bytes32 _trendId) {\r\n    require(dividendsOf(_trendId, msg.sender) > 0);\r\n    _;\r\n  }\r\n  \r\n  // only existing trends\r\n  modifier onlyTrends(bytes32 _trendId) {\r\n    require(trends[_trendId].created != 0);\r\n    _;\r\n  }\r\n  \r\n  function() payable public {\r\n    // only bosswage can send funds\r\n    require(msg.sender == address(bosswage));\r\n  }\r\n  \r\n  function createTrend(string _topic, address _referredBy) external payable returns (uint256) {\r\n    // get trend id\r\n    bytes32 trendId = keccak256(abi.encodePacked(_topic));\r\n    \r\n    // trend must not have already been created\r\n    require(trends[trendId].created == 0);\r\n    \r\n    // create trend\r\n    trends[trendId] = Trend(_topic, 0, 0, now);\r\n    \r\n    emit Created(trendId, msg.sender);\r\n    \r\n    if (msg.value > 0) {\r\n      return purchase(trendId, msg.sender, msg.value, _referredBy);\r\n    }\r\n  }\r\n  \r\n  function buy(bytes32 _trendId, address _referredBy) onlyTrends(_trendId) external payable returns (uint256) {\r\n    return purchase(_trendId, msg.sender, msg.value, _referredBy);\r\n  }\r\n  \r\n  function reinvest(bytes32 _trendId, address _referredBy) onlyTrends(_trendId) onlyStronghands(_trendId) public {\r\n    Trend storage trend = trends[_trendId];\r\n        \r\n    // pay out the dividends virtually\r\n    address owner = msg.sender;\r\n\r\n    // fetch dividends\r\n    uint256 dividends = dividendsOf(_trendId, owner);\r\n\r\n    trend.payouts[owner] += (int256) (dividends * magnitude);\r\n\r\n    // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n    uint256 tokens = purchase(_trendId, owner, dividends, _referredBy);\r\n\r\n    // fire event\r\n    emit Reinvestment(_trendId, owner, dividends, tokens, _referredBy);\r\n  }\r\n  \r\n  function purchase(bytes32 _trendId, address _owner, uint256 _incomingEthereum, address _referredBy) internal returns (uint256) {\r\n    Trend storage trend = trends[_trendId];\r\n\r\n    uint256 undividedDividends = _incomingEthereum.div(dividendFee);\r\n    uint256 taxedEthereum = _incomingEthereum.sub(undividedDividends);\r\n    \r\n    uint256 bonus = _incomingEthereum.div(bonusFee);\r\n    uint256 dividends = undividedDividends.sub(bonus.mul(2));\r\n    uint256 amountOfTokens = ethereumToTokens(taxedEthereum, trend.supply);\r\n    uint256 fee = dividends * magnitude;\r\n    \r\n    disperse(bonus, _owner);\r\n\r\n    require(amountOfTokens > 0 && (amountOfTokens.add(trend.supply) > trend.supply));\r\n\r\n    // is the user referred by a masternode?\r\n    if(\r\n      // is this a referred purchase?\r\n      _referredBy != 0x0000000000000000000000000000000000000000 &&\r\n      \r\n      // no cheating!\r\n      _referredBy != _owner\r\n    ) {\r\n      // wealth redistribution\r\n      referrals[_referredBy] = referrals[_referredBy].add(bonus);\r\n    } else {\r\n      // no ref purchase\r\n      // add the referral bonus back to the global dividends cake\r\n      dividends = dividends.add(bonus);\r\n      fee = dividends * magnitude;\r\n    }\r\n\r\n    // we can't give people infinite ethereum\r\n    if(trend.supply > 0){\r\n      // add tokens to the pool\r\n      trend.supply = trend.supply.add(amountOfTokens);\r\n\r\n      // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n      trend.profitPerShare += (dividends * magnitude / (trend.supply));\r\n\r\n      // calculate the amount of tokens the customer receives over his purchase\r\n      fee = fee - (fee-(amountOfTokens * (dividends * magnitude / (trend.supply))));\r\n    } else {\r\n      // add tokens to the pool\r\n      trend.supply = amountOfTokens;\r\n    }\r\n    \r\n    // update circulating supply & the ledger address for the customer\r\n    trend.balances[_owner] = trend.balances[_owner].add(amountOfTokens);\r\n\r\n    int256 updatedPayouts = (int256) ((trend.profitPerShare * amountOfTokens) - fee);\r\n    trend.payouts[_owner] += updatedPayouts;\r\n    \r\n    emit Purchase(_trendId, _owner, _incomingEthereum, amountOfTokens, _referredBy);\r\n\r\n    return amountOfTokens;\r\n  }\r\n  \r\n  function sell(bytes32 _trendId, uint256 _amountOfTokens) onlyTrends(_trendId) onlyBagholders(_trendId) public {\r\n    Trend storage trend = trends[_trendId];\r\n    \r\n    // setup data\r\n    address owner = msg.sender;\r\n    \r\n    // russian hackers BTFO\r\n    require(_amountOfTokens <= trend.balances[owner]);\r\n    uint256 tokens = _amountOfTokens;\r\n    uint256 ethereum = tokensToEthereum(tokens, trend.supply);\r\n\r\n    // tax ethereum\r\n    uint256 undividedDividends = ethereum.div(dividendFee);\r\n    uint256 taxedEthereum = ethereum.sub(undividedDividends);\r\n\r\n    // divide dividends\r\n    uint256 bonus = ethereum.div(bonusFee);\r\n    uint256 dividends = undividedDividends.sub(bonus);\r\n\r\n    disperse(bonus, msg.sender);\r\n\r\n    // burn the sold tokens\r\n    trend.supply = trend.supply.sub(tokens);\r\n    trend.balances[owner] = trend.balances[owner].sub(tokens);\r\n\r\n    // update dividends tracker\r\n    int256 updatedPayouts = (int256) (trend.profitPerShare * tokens + (taxedEthereum * magnitude));\r\n    trend.payouts[owner] -= updatedPayouts;\r\n\r\n    // dividing by zero is a bad idea\r\n    if (trend.supply > 0) {\r\n      // update the amount of dividends per token\r\n      trend.profitPerShare = trend.profitPerShare.add((dividends * magnitude) / trend.supply);\r\n    }\r\n\r\n    // fire event\r\n    emit Sell(_trendId, owner, tokens, taxedEthereum);\r\n  }\r\n    \r\n  function exit(bytes32 _trendId) onlyTrends(_trendId) external {\r\n    Trend storage trend = trends[_trendId];\r\n    // get token count for caller & sell them all\r\n    uint256 tokens = trend.balances[msg.sender];\r\n    if(tokens > 0) sell(_trendId, tokens);\r\n\r\n    withdraw(_trendId);\r\n  }\r\n\r\n  function withdraw(bytes32 _trendId) onlyTrends(_trendId) onlyStronghands(_trendId) public {\r\n    Trend storage trend = trends[_trendId];\r\n    \r\n    // setup data\r\n    address owner = msg.sender;\r\n    uint256 dividends = dividendsOf(_trendId, owner);\r\n\r\n    // update dividend tracker\r\n    trend.payouts[owner] += (int256) (dividends * magnitude);\r\n    \r\n    // lambo delivery service\r\n    owner.transfer(dividends);\r\n\r\n    // fire event\r\n    emit Withdraw(_trendId, owner, dividends);\r\n  }\r\n  \r\n  function withdrawReferrals() external {\r\n    address owner = msg.sender;\r\n    uint256 dividends = referrals[owner];\r\n    require(dividends > 0);\r\n    referrals[owner] = 0;\r\n    owner.transfer(dividends);\r\n    emit WithdrawReferrals(owner, dividends);\r\n  }\r\n  \r\n  function reinvestReferrals(bytes32 _trendId, address _referredBy) onlyTrends(_trendId) external {\r\n    address owner = msg.sender;\r\n    uint256 dividends = referrals[owner];\r\n    require(dividends > 0);\r\n    referrals[owner] = 0;\r\n    \r\n    uint256 tokens = purchase(_trendId, owner, dividends, _referredBy);\r\n    \r\n    emit ReinvestReferrals(_trendId, owner, dividends, tokens, _referredBy);\r\n  }\r\n  \r\n  function disperse(uint256 _bonus, address _owner) internal {\r\n    uint256 divs = bosswage.getDividends(address(this), true);\r\n    if (divs > 0) {\r\n      bosswage.withdraw();\r\n    }\r\n    uint256 totalBuy = _bonus.add(divs);\r\n    bosswage.buy.value(totalBuy)(_owner);\r\n  }\r\n    \r\n  function ethereumToTokens(uint256 _ethereum, uint256 _supply)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        uint256 tokenPriceInitial = initialTokenPrice * 1e18;\r\n        uint256 tokensReceived =\r\n         (\r\n            (\r\n                // underflow attempts BTFO\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (tokenPriceInitial**2)\r\n                            +\r\n                            (2*(tokenPriceIncremental * 1e18)*(_ethereum * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental)**2)*(_supply**2))\r\n                            +\r\n                            (2*(tokenPriceIncremental)*tokenPriceInitial*_supply)\r\n                        )\r\n                    ), tokenPriceInitial\r\n                )\r\n            )/(tokenPriceIncremental)\r\n        )-(_supply)\r\n        ;\r\n\r\n        return tokensReceived;\r\n  }\r\n\r\n  function tokensToEthereum(uint256 _tokens, uint256 _supply)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 tokens = (_tokens + 1e18);\r\n        uint256 tokenSupply = (_supply + 1e18);\r\n        uint256 etherReceived =\r\n        (\r\n          SafeMath.sub(\r\n            (\r\n                (\r\n                    (\r\n                      initialTokenPrice +(tokenPriceIncremental * (tokenSupply/1e18))\r\n                    )-tokenPriceIncremental\r\n                )*(tokens - 1e18)\r\n            ),(tokenPriceIncremental*((tokens**2-tokens)/1e18))/2\r\n          )\r\n        /1e18);\r\n        return etherReceived;\r\n  }\r\n\r\n  function sqrt(uint x) internal pure returns (uint y) {\r\n    uint z = (x + 1) / 2;\r\n    y = x;\r\n    while (z < y) {\r\n      y = z;\r\n      z = (x / z + z) / 2;\r\n    }\r\n  }\r\n  \r\n  function sellPrice(bytes32 _trendId) public view returns(uint256) {\r\n    Trend memory trend = trends[_trendId];\r\n    // our calculation relies on the token supply, so we need supply. Doh.\r\n    if(trend.supply == 0){\r\n      return initialTokenPrice - tokenPriceIncremental;\r\n    } else {\r\n      uint256 ethereum = tokensToEthereum(1e18, trend.supply);\r\n      uint256 dividends = ethereum.div(dividendFee);\r\n      uint256 taxedEthereum = ethereum.sub(dividends);\r\n      return taxedEthereum;\r\n    }\r\n  }\r\n\r\n  function buyPrice(bytes32 _trendId) public view returns(uint256) {\r\n    Trend memory trend = trends[_trendId];\r\n    // our calculation relies on the token supply, so we need supply. Doh.\r\n    if(trend.supply == 0){\r\n      return initialTokenPrice + tokenPriceIncremental;\r\n    } else {\r\n      uint256 ethereum = tokensToEthereum(1e18, trend.supply);\r\n      uint256 dividends = ethereum.div(dividendFee);\r\n      uint256 taxedEthereum = ethereum.sub(dividends);\r\n      return taxedEthereum;\r\n    }\r\n  }\r\n\r\n  function calculateTokensReceived(bytes32 _trendId, uint256 _ethereumToSpend) public view returns(uint256) {\r\n    Trend memory trend = trends[_trendId];\r\n    uint256 dividends = _ethereumToSpend.div(dividendFee);\r\n    uint256 taxedEthereum = _ethereumToSpend.sub(dividends);\r\n    uint256 amountOfTokens = ethereumToTokens(taxedEthereum, trend.supply);\r\n    return amountOfTokens;\r\n  }\r\n\r\n  function calculateEthereumReceived(bytes32 _trendId, uint256 _tokensToSell) public view returns (uint256) {\r\n    Trend memory trend = trends[_trendId];\r\n    require(_tokensToSell <= trend.supply);\r\n    uint256 ethereum = tokensToEthereum(_tokensToSell, trend.supply);\r\n    uint256 dividends = ethereum.div(dividendFee);\r\n    uint256 taxedEthereum = ethereum.sub(dividends);\r\n    return taxedEthereum;\r\n  }\r\n\r\n  function balanceOf(bytes32 _trendId, address _owner) public view returns (uint256) {\r\n    return trends[_trendId].balances[_owner];\r\n  }\r\n  \r\n  function payoutsOf(bytes32 _trendId, address _owner) public  view returns (int256) {\r\n    return trends[_trendId].payouts[_owner];\r\n  }\r\n  \r\n  function dividendsOf(bytes32 _trendId, address _owner) public view returns(uint256) {\r\n    return (uint256) ((int256)(trends[_trendId].profitPerShare * trends[_trendId].balances[_owner]) - trends[_trendId].payouts[_owner]) / magnitude;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"}],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"payoutsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"reinvestReferrals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateEthereumReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"}],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bosswage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"trends\",\"outputs\":[{\"name\":\"topic\",\"type\":\"string\"},{\"name\":\"supply\",\"type\":\"uint256\"},{\"name\":\"profitPerShare\",\"type\":\"uint256\"},{\"name\":\"created\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawReferrals\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_topic\",\"type\":\"string\"},{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"createTrend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_trendId\",\"type\":\"bytes32\"},{\"name\":\"_ethereumToSpend\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trendId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"incomingEthereum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"Purchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trendId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethereumEarned\",\"type\":\"uint256\"}],\"name\":\"Sell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trendId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"Reinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trendId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumReinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"referredBy\",\"type\":\"address\"}],\"name\":\"ReinvestReferrals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trendId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethereumWithdrawn\",\"type\":\"uint256\"}],\"name\":\"WithdrawReferrals\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"trendId\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"Created\",\"type\":\"event\"}]","ContractName":"Trends","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a14bc83a1d1f5240504da21b89d6945a77573f61af9334a8d19e0ca56ecc1159"}]}