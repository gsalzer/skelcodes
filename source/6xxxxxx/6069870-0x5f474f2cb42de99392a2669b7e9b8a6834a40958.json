{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n/**\r\n * @author FadyAro\r\n *\r\n * 22.07.2018\r\n *\r\n *\r\n */\r\ncontract Ownable {\r\n\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, 'Contract Paused!');\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused, 'Contract Active!');\r\n        _;\r\n    }\r\n\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract EtherDrop is Pausable {\r\n\r\n    uint constant PRICE_WEI = 2e18;\r\n\r\n    /*\r\n     * blacklist flag\r\n     */\r\n    uint constant FLAG_BLACKLIST = 1;\r\n\r\n    /*\r\n     * subscription queue size: should be power of 10\r\n     */\r\n    uint constant QMAX = 10;\r\n\r\n    /*\r\n     * randomness order construction conform to QMAX\r\n     * e.g. random [0 to 999] is of order 3 => rand = 100*x + 10*y + z\r\n     */\r\n    uint constant DMAX = 1;\r\n\r\n    /*\r\n     * this event is when we have a new subscription\r\n     * note that it may be fired sequentially just before => NewWinner\r\n     */\r\n    event NewDropIn(address addr, uint round, uint place, uint value);\r\n\r\n    /*\r\n     * this event is when we have a new winner\r\n     * it is as well a new round start => (round + 1)\r\n     */\r\n    event NewWinner(address addr, uint round, uint place, uint value, uint price);\r\n\r\n    struct history {\r\n\r\n        /*\r\n         * user black listed comment\r\n         */\r\n        uint blacklist;\r\n\r\n        /*\r\n         * user rounds subscriptions number\r\n         */\r\n        uint size;\r\n\r\n        /*\r\n         * array of subscribed rounds indexes\r\n         */\r\n        uint[] rounds;\r\n\r\n        /*\r\n         * array of rounds subscription's inqueue indexes\r\n         */\r\n        uint[] places;\r\n\r\n        /*\r\n         * array of rounds's ether value subscription >= PRICE\r\n         */\r\n        uint[] values;\r\n\r\n        /*\r\n         * array of 0's initially, update to REWARD PRICE in win situations\r\n         */\r\n        uint[] prices;\r\n    }\r\n\r\n    /*\r\n     * active subscription queue\r\n     */\r\n    address[] private _queue;\r\n\r\n    /*\r\n     * winners history\r\n     */\r\n    address[] private _winners;\r\n\r\n    /*\r\n     * winner comment 32 left\r\n     */\r\n    bytes32[] private _wincomma;\r\n\r\n    /*\r\n     * winner comment 32 right\r\n     */\r\n    bytes32[] private _wincommb;\r\n\r\n    /*\r\n     * winners positions\r\n     */\r\n    uint[] private _positions;\r\n\r\n    /*\r\n     * on which block we got a winner\r\n     */\r\n    uint[] private _blocks;\r\n\r\n    /*\r\n     * active round index\r\n     */\r\n    uint public _round;\r\n\r\n    /*\r\n     * active round queue pointer\r\n     */\r\n    uint public _counter;\r\n\r\n    /*\r\n     * allowed collectibles\r\n     */\r\n    uint private _collectibles = 0;\r\n\r\n    /*\r\n     * users history mapping\r\n     */\r\n    mapping(address => history) private _history;\r\n\r\n    /**\r\n     * get current round details\r\n     */\r\n    function currentRound() public view returns (uint round, uint counter, uint round_users, uint price) {\r\n        return (_round, _counter, QMAX, PRICE_WEI);\r\n    }\r\n\r\n    /**\r\n     * get round stats by index\r\n     */\r\n    function roundStats(uint index) public view returns (uint round, address winner, uint position, uint block_no) {\r\n        return (index, _winners[index], _positions[index], _blocks[index]);\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @dev get the total number of user subscriptions\r\n     *\r\n     * @param user the specific user\r\n     *\r\n     * @return user rounds size\r\n     */\r\n    function userRounds(address user) public view returns (uint) {\r\n        return _history[user].size;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @dev get user subscription round number details\r\n     *\r\n     * @param user the specific user\r\n     *\r\n     * @param index the round number\r\n     *\r\n     * @return round no, user placing, user drop, user reward\r\n     */\r\n    function userRound(address user, uint index) public view returns (uint round, uint place, uint value, uint price) {\r\n        history memory h = _history[user];\r\n        return (h.rounds[index], h.places[index], h.values[index], h.prices[index]);\r\n    }\r\n\r\n    /**\r\n     * round user subscription\r\n     */\r\n    function() public payable whenNotPaused {\r\n        /*\r\n         * check subscription price\r\n         */\r\n        require(msg.value >= PRICE_WEI, 'Insufficient Ether');\r\n\r\n        /*\r\n         * start round ahead: on QUEUE_MAX + 1\r\n         * draw result\r\n         */\r\n        if (_counter == QMAX) {\r\n\r\n            uint r = DMAX;\r\n\r\n            uint winpos = 0;\r\n\r\n            _blocks.push(block.number);\r\n\r\n            bytes32 _a = blockhash(block.number - 1);\r\n\r\n            for (uint i = 31; i >= 1; i--) {\r\n                if (uint8(_a[i]) >= 48 && uint8(_a[i]) <= 57) {\r\n                    winpos = 10 * winpos + (uint8(_a[i]) - 48);\r\n                    if (--r == 0) break;\r\n                }\r\n            }\r\n\r\n            _positions.push(winpos);\r\n\r\n            /*\r\n             * post out winner rewards\r\n             */\r\n            uint _reward = (QMAX * PRICE_WEI * 90) / 100;\r\n            address _winner = _queue[winpos];\r\n\r\n            _winners.push(_winner);\r\n            _winner.transfer(_reward);\r\n\r\n            /*\r\n             * update round history\r\n             */\r\n            history storage h = _history[_winner];\r\n            h.prices[h.size - 1] = _reward;\r\n\r\n            /*\r\n             * default winner blank comments\r\n             */\r\n            _wincomma.push(0x0);\r\n            _wincommb.push(0x0);\r\n\r\n            /*\r\n             * log the win event: winpos is the proof, history trackable\r\n             */\r\n            emit NewWinner(_winner, _round, winpos, h.values[h.size - 1], _reward);\r\n\r\n            /*\r\n             * update collectibles\r\n             */\r\n            _collectibles += address(this).balance - _reward;\r\n\r\n            /*\r\n             * reset counter\r\n             */\r\n            _counter = 0;\r\n\r\n            /*\r\n             * increment round\r\n             */\r\n            _round++;\r\n        }\r\n\r\n        h = _history[msg.sender];\r\n\r\n        /*\r\n         * user is not allowed to subscribe twice\r\n         */\r\n        require(h.size == 0 || h.rounds[h.size - 1] != _round, 'Already In Round');\r\n\r\n        /*\r\n         * create user subscription: N.B. places[_round] is the result proof\r\n         */\r\n        h.size++;\r\n        h.rounds.push(_round);\r\n        h.places.push(_counter);\r\n        h.values.push(msg.value);\r\n        h.prices.push(0);\r\n\r\n        /*\r\n         * initial round is a push, others are 'on set' index\r\n         */\r\n        if (_round == 0) {\r\n            _queue.push(msg.sender);\r\n        } else {\r\n            _queue[_counter] = msg.sender;\r\n        }\r\n\r\n        /*\r\n         * log subscription\r\n         */\r\n        emit NewDropIn(msg.sender, _round, _counter, msg.value);\r\n\r\n        /*\r\n         * increment counter\r\n         */\r\n        _counter++;\r\n    }\r\n\r\n    /**\r\n     *\r\n     * @dev let the user comment 64 letters for a winning round\r\n     *\r\n     * @param round the winning round\r\n     *\r\n     * @param a the first 32 letters comment\r\n     *\r\n     * @param b the second 32 letters comment\r\n     *\r\n     * @return user comment\r\n     */\r\n    function comment(uint round, bytes32 a, bytes32 b) whenNotPaused public {\r\n\r\n        address winner = _winners[round];\r\n\r\n        require(winner == msg.sender, 'not a winner');\r\n        require(_history[winner].blacklist != FLAG_BLACKLIST, 'blacklisted');\r\n\r\n        _wincomma[round] = a;\r\n        _wincommb[round] = b;\r\n    }\r\n\r\n\r\n    /**\r\n     *\r\n     * @dev blacklist a user for its comments behavior\r\n     *\r\n     * @param user address\r\n     *\r\n     */\r\n    function blackList(address user) public onlyOwner {\r\n        history storage h = _history[user];\r\n        if (h.size > 0) {\r\n            h.blacklist = FLAG_BLACKLIST;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *\r\n    * @dev get the user win round comment\r\n    *\r\n    * @param round the winning round number\r\n    *\r\n    * @return user comment\r\n    */\r\n    function userComment(uint round) whenNotPaused public view returns (address winner, bytes32 comma, bytes32 commb) {\r\n        if (_history[_winners[round]].blacklist != FLAG_BLACKLIST) {\r\n            return (_winners[round], _wincomma[round], _wincommb[round]);\r\n        } else {\r\n            return (0x0, 0x0, 0x0);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * etherdrop team R&D support collectibles\r\n     */\r\n    function collect() public onlyOwner {\r\n        owner.transfer(_collectibles);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"roundStats\",\"outputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"position\",\"type\":\"uint256\"},{\"name\":\"block_no\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"userRounds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"blackList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"a\",\"type\":\"bytes32\"},{\"name\":\"b\",\"type\":\"bytes32\"}],\"name\":\"comment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint256\"}],\"name\":\"userComment\",\"outputs\":[{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"comma\",\"type\":\"bytes32\"},{\"name\":\"commb\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_counter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"counter\",\"type\":\"uint256\"},{\"name\":\"round_users\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"userRound\",\"outputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"place\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"place\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewDropIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"place\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"NewWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EtherDrop","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8f12a1ee8675cc77dafbdd3e69a586288145318f1d41205dcaff4375def6894b"}]}