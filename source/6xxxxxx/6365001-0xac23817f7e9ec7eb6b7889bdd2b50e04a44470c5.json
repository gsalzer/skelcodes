{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @notice LinkedList is a library for a circular double linked list.\r\n */\r\nlibrary LinkedList {\r\n\r\n    /*\r\n    * @notice A permanent NULL node (0x0) in the circular double linked list.\r\n    * NULL.next is the head, and NULL.previous is the tail.\r\n    */\r\n    address public constant NULL = 0x0;\r\n\r\n    /**\r\n    * @notice A node points to the node before it, and the node after it. If\r\n    * node.previous = NULL, then the node is the head of the list. If\r\n    * node.next = NULL, then the node is the tail of the list.\r\n    */\r\n    struct Node {\r\n        bool inList;\r\n        address previous;\r\n        address next;\r\n    }\r\n\r\n    /**\r\n    * @notice LinkedList uses a mapping from address to nodes. Each address\r\n    * uniquely identifies a node, and in this way they are used like pointers.\r\n    */\r\n    struct List {\r\n        mapping (address => Node) list;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node before an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert before the target.\r\n    */\r\n    function insertBefore(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"already in list\");\r\n        require(isInList(self, target) || target == NULL, \"not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address prev = self.list[target].previous;\r\n\r\n        self.list[newNode].next = target;\r\n        self.list[newNode].previous = prev;\r\n        self.list[target].previous = newNode;\r\n        self.list[prev].next = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node after an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert after the target.\r\n    */\r\n    function insertAfter(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"already in list\");\r\n        require(isInList(self, target) || target == NULL, \"not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address n = self.list[target].next;\r\n\r\n        self.list[newNode].previous = target;\r\n        self.list[newNode].next = n;\r\n        self.list[target].next = newNode;\r\n        self.list[n].previous = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Remove a node from the list, and fix the previous and next\r\n    * pointers that are pointing to the removed node. Removing anode that is not\r\n    * in the list will do nothing.\r\n    *\r\n    * @param self The list being using.\r\n    * @param node The node in the list to be removed.\r\n    */\r\n    function remove(List storage self, address node) internal {\r\n        require(isInList(self, node), \"not in list\");\r\n        if (node == NULL) {\r\n            return;\r\n        }\r\n        address p = self.list[node].previous;\r\n        address n = self.list[node].next;\r\n\r\n        self.list[p].next = n;\r\n        self.list[n].previous = p;\r\n\r\n        // Deleting the node should set this value to false, but we set it here for\r\n        // explicitness.\r\n        self.list[node].inList = false;\r\n        delete self.list[node];\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the beginning of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the beginning of the list.\r\n    */\r\n    function prepend(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertBefore(self, begin(self), node);\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the end of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the end of the list.\r\n    */\r\n    function append(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertAfter(self, end(self), node);\r\n    }\r\n\r\n    function swap(List storage self, address left, address right) internal {\r\n        // isInList(left) and isInList(right) are checked in remove\r\n\r\n        address previousRight = self.list[right].previous;\r\n        remove(self, right);\r\n        insertAfter(self, left, right);\r\n        remove(self, left);\r\n        insertAfter(self, previousRight, left);\r\n    }\r\n\r\n    function isInList(List storage self, address node) internal view returns (bool) {\r\n        return self.list[node].inList;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the beginning of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the beginning of the double\r\n    * linked list.\r\n    */\r\n    function begin(List storage self) internal view returns (address) {\r\n        return self.list[NULL].next;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the end of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the end of the double linked\r\n    * list.\r\n    */\r\n    function end(List storage self) internal view returns (address) {\r\n        return self.list[NULL].previous;\r\n    }\r\n\r\n    function next(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"not in list\");\r\n        return self.list[node].next;\r\n    }\r\n\r\n    function previous(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"not in list\");\r\n        return self.list[node].previous;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\ncontract RepublicToken is PausableToken, BurnableToken {\r\n\r\n    string public constant name = \"Republic Token\";\r\n    string public constant symbol = \"REN\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**uint256(decimals);\r\n\r\n    /// @notice The RepublicToken Constructor.\r\n    constructor() public {\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n    }\r\n\r\n    function transferTokens(address beneficiary, uint256 amount) public onlyOwner returns (bool) {\r\n        /* solium-disable error-reason */\r\n        require(amount > 0);\r\n\r\n        balances[owner] = balances[owner].sub(amount);\r\n        balances[beneficiary] = balances[beneficiary].add(amount);\r\n        emit Transfer(owner, beneficiary, amount);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/// @notice This contract stores data and funds for the DarknodeRegistry\r\n/// contract. The data / fund logic and storage have been separated to improve\r\n/// upgradability.\r\ncontract DarknodeRegistryStore is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice Darknodes are stored in the darknode struct. The owner is the\r\n    /// address that registered the darknode, the bond is the amount of REN that\r\n    /// was transferred during registration, and the public key is the\r\n    /// encryption key that should be used when sending sensitive information to\r\n    /// the darknode.\r\n    struct Darknode {\r\n        // The owner of a Darknode is the address that called the register\r\n        // function. The owner is the only address that is allowed to\r\n        // deregister the Darknode, unless the Darknode is slashed for\r\n        // malicious behavior.\r\n        address owner;\r\n\r\n        // The bond is the amount of REN submitted as a bond by the Darknode.\r\n        // This amount is reduced when the Darknode is slashed for malicious\r\n        // behavior.\r\n        uint256 bond;\r\n\r\n        // The block number at which the Darknode is considered registered.\r\n        uint256 registeredAt;\r\n\r\n        // The block number at which the Darknode is considered deregistered.\r\n        uint256 deregisteredAt;\r\n\r\n        // The public key used by this Darknode for encrypting sensitive data\r\n        // off chain. It is assumed that the Darknode has access to the\r\n        // respective private key, and that there is an agreement on the format\r\n        // of the public key.\r\n        bytes publicKey;\r\n    }\r\n\r\n    /// Registry data.\r\n    mapping(address => Darknode) private darknodeRegistry;\r\n    LinkedList.List private darknodes;\r\n\r\n    // RepublicToken.\r\n    RepublicToken public ren;\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _ren The address of the RepublicToken contract.\r\n    constructor(\r\n        string _VERSION,\r\n        RepublicToken _ren\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        ren = _ren;\r\n    }\r\n\r\n    /// @notice Instantiates a darknode and appends it to the darknodes\r\n    /// linked-list.\r\n    ///\r\n    /// @param _darknodeID The darknode's ID.\r\n    /// @param _darknodeOwner The darknode's owner's address\r\n    /// @param _bond The darknode's bond value\r\n    /// @param _publicKey The darknode's public key\r\n    /// @param _registeredAt The time stamp when the darknode is registered.\r\n    /// @param _deregisteredAt The time stamp when the darknode is deregistered.\r\n    function appendDarknode(\r\n        address _darknodeID,\r\n        address _darknodeOwner,\r\n        uint256 _bond,\r\n        bytes _publicKey,\r\n        uint256 _registeredAt,\r\n        uint256 _deregisteredAt\r\n    ) external onlyOwner {\r\n        Darknode memory darknode = Darknode({\r\n            owner: _darknodeOwner,\r\n            bond: _bond,\r\n            publicKey: _publicKey,\r\n            registeredAt: _registeredAt,\r\n            deregisteredAt: _deregisteredAt\r\n        });\r\n        darknodeRegistry[_darknodeID] = darknode;\r\n        LinkedList.append(darknodes, _darknodeID);\r\n    }\r\n\r\n    /// @notice Returns the address of the first darknode in the store\r\n    function begin() external view onlyOwner returns(address) {\r\n        return LinkedList.begin(darknodes);\r\n    }\r\n\r\n    /// @notice Returns the address of the next darknode in the store after the\r\n    /// given address.\r\n    function next(address darknodeID) external view onlyOwner returns(address) {\r\n        return LinkedList.next(darknodes, darknodeID);\r\n    }\r\n\r\n    /// @notice Removes a darknode from the store and transfers its bond to the\r\n    /// owner of this contract.\r\n    function removeDarknode(address darknodeID) external onlyOwner {\r\n        uint256 bond = darknodeRegistry[darknodeID].bond;\r\n        delete darknodeRegistry[darknodeID];\r\n        LinkedList.remove(darknodes, darknodeID);\r\n        require(ren.transfer(owner, bond), \"bond transfer failed\");\r\n    }\r\n\r\n    /// @notice Updates the bond of the darknode. If the bond is being\r\n    /// decreased, the difference is sent to the owner of this contract.\r\n    function updateDarknodeBond(address darknodeID, uint256 bond) external onlyOwner {\r\n        uint256 previousBond = darknodeRegistry[darknodeID].bond;\r\n        darknodeRegistry[darknodeID].bond = bond;\r\n        if (previousBond > bond) {\r\n            require(ren.transfer(owner, previousBond - bond), \"cannot transfer bond\");\r\n        }\r\n    }\r\n\r\n    /// @notice Updates the deregistration timestamp of a darknode.\r\n    function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external onlyOwner {\r\n        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;\r\n    }\r\n\r\n    /// @notice Returns the owner of a given darknode.\r\n    function darknodeOwner(address darknodeID) external view onlyOwner returns (address) {\r\n        return darknodeRegistry[darknodeID].owner;\r\n    }\r\n\r\n    /// @notice Returns the bond of a given darknode.\r\n    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].bond;\r\n    }\r\n\r\n    /// @notice Returns the registration time of a given darknode.\r\n    function darknodeRegisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].registeredAt;\r\n    }\r\n\r\n    /// @notice Returns the deregistration time of a given darknode.\r\n    function darknodeDeregisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].deregisteredAt;\r\n    }\r\n\r\n    /// @notice Returns the encryption public key of a given darknode.\r\n    function darknodePublicKey(address darknodeID) external view onlyOwner returns (bytes) {\r\n        return darknodeRegistry[darknodeID].publicKey;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"}],\"name\":\"darknodeDeregisteredAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"begin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"},{\"name\":\"deregisteredAt\",\"type\":\"uint256\"}],\"name\":\"updateDarknodeDeregisteredAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"}],\"name\":\"removeDarknode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ren\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"}],\"name\":\"darknodeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_darknodeID\",\"type\":\"address\"},{\"name\":\"_darknodeOwner\",\"type\":\"address\"},{\"name\":\"_bond\",\"type\":\"uint256\"},{\"name\":\"_publicKey\",\"type\":\"bytes\"},{\"name\":\"_registeredAt\",\"type\":\"uint256\"},{\"name\":\"_deregisteredAt\",\"type\":\"uint256\"}],\"name\":\"appendDarknode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"}],\"name\":\"next\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"}],\"name\":\"darknodeBond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"}],\"name\":\"darknodeRegisteredAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"}],\"name\":\"darknodePublicKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"darknodeID\",\"type\":\"address\"},{\"name\":\"bond\",\"type\":\"uint256\"}],\"name\":\"updateDarknodeBond\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_VERSION\",\"type\":\"string\"},{\"name\":\"_ren\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DarknodeRegistryStore","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000021c482f153d0317fe85c60be1f7fa079019fcebd000000000000000000000000000000000000000000000000000000000000000d6d61696e6e65742d312e302e3000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://a7180f8ec55bc0773c44cb67f80bf1b0e176ad54429ac29116da64960707c6e0"}]}