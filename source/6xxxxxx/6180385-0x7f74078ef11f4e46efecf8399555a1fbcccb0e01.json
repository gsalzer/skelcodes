{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.21;\r\n\r\n/**\r\n *   @title SafeMath\r\n *   @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *   @title ERC20\r\n *   @dev Standart ERC20 token interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address _owner) public constant returns(uint256);\r\n    function transfer(address _to, uint256 _value) public returns(bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\r\n    function approve(address _spender, uint256 _value) public returns(bool);\r\n    function allowance(address _owner, address _spender) public constant returns(uint256);\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/**\r\n *   @dev CRET token contract\r\n */\r\ncontract CretToken is ERC20 {\r\n    using SafeMath for uint256;\r\n    string public name = \"CRET TOKEN\";\r\n    string public symbol = \"CRET\";\r\n    uint256 public decimals = 18;\r\n    uint256 public totalSupply = 0;\r\n    uint256 public riskTokens;\r\n    uint256 public bountyTokens;\r\n    uint256 public advisersTokens;\r\n    uint256 public reserveTokens;\r\n    uint256 public constant reserveTokensLimit = 5000000 * 1e18; //5mlnM  for reserve fund\r\n    uint256 public lastBountyStatus;\r\n    address public teamOneYearFrozen;\r\n    address public teamHalfYearFrozen;\r\n    uint256 public timeStamp;\r\n\r\n\r\n\r\n    // Ico contract address\r\n    address public owner;\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    // Disables token transfers\r\n    bool public tokensAreFrozen = true;\r\n\r\n    // Allows execution by the owner only\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    \r\n    \r\n    constructor (address _owner, address _team, address _team2) public {\r\n        owner = _owner;\r\n        timeStamp = now;\r\n        teamOneYearFrozen = _team;\r\n        teamHalfYearFrozen = _team2;\r\n\r\n    }\r\n    \r\n    \r\n\r\n   /**\r\n    *   @dev Mint tokens\r\n    *   @param _investor     address the tokens will be issued to\r\n    *   @param _value        number of tokens\r\n    */\r\n    function mintTokens(address _investor, uint256 _value) external onlyOwner {\r\n        require(_value > 0);\r\n        balances[_investor] = balances[_investor].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        emit Transfer(0x0, _investor, _value);\r\n    }\r\n    \r\n    \r\n    function mintRiskTokens(address _investor, uint256 _value) external onlyOwner {\r\n        balances[_investor] = balances[_investor].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        riskTokens = riskTokens.add(_value);\r\n        emit Transfer(0x0, _investor, _value);\r\n    }\r\n    \r\n    \r\n    function mintReserveTokens(address _investor, uint256 _value) external onlyOwner {\r\n        require(reserveTokens.add(_value) <= reserveTokensLimit);\r\n        balances[_investor] = balances[_investor].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        reserveTokens = reserveTokens.add(_value);\r\n        emit Transfer(0x0, _investor, _value);\r\n    }\r\n    \r\n    \r\n    function mintAdvisersTokens(address _investor, uint256 _value) external onlyOwner {\r\n        balances[_investor] = balances[_investor].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        advisersTokens = advisersTokens.add(_value);\r\n        emit Transfer(0x0, _investor, _value);\r\n    }\r\n    \r\n\r\n    function mintBountyTokens(address[] _dests, uint256 _value) external onlyOwner {\r\n        lastBountyStatus = 0;\r\n        for (uint256 i = 0;i < _dests.length; i++) {\r\n        address tmp = _dests[i];\r\n        balances[tmp] = balances[tmp].add(_value);\r\n        totalSupply = totalSupply.add(_value);\r\n        bountyTokens = bountyTokens.add(_value);\r\n        lastBountyStatus++;\r\n        emit Transfer(0x0, tmp, _value);\r\n        }\r\n    }\r\n    \r\n\r\n\r\n   /**\r\n    *   @dev Enables token transfers\r\n    */\r\n    function defrostTokens() external onlyOwner {\r\n      tokensAreFrozen = false;\r\n    }\r\n\r\n   /**\r\n    *   @dev Disables token transfers\r\n    */\r\n    function frostTokens() external onlyOwner {\r\n      tokensAreFrozen = true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Burn Tokens\r\n    *   @param _investor     token holder address which the tokens will be burnt\r\n    *   @param _value        number of tokens to burn\r\n    */\r\n    function burnTokens(address _investor, uint256 _value) external onlyOwner {\r\n        require(balances[_investor] > 0);\r\n        balances[_investor] = balances[_investor].sub(_value);\r\n        totalSupply = totalSupply.sub(_value);\r\n        emit Burn(_investor, _value);\r\n    }\r\n\r\n   /**\r\n    *   @dev Get balance of investor\r\n    *   @param _owner        investor's address\r\n    *   @return              balance of investor\r\n    */\r\n    function balanceOf(address _owner) public constant returns(uint256) {\r\n      return balances[_owner];\r\n    }\r\n\r\n   /**\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transfer(address _to, uint256 _amount) public returns(bool) {\r\n        require(!tokensAreFrozen);\r\n        if(now < (timeStamp + 425 days)){               //365 days + 60 days ICO\r\n            require(msg.sender != teamOneYearFrozen);\r\n        } \r\n        if(now < (timeStamp + 240 days)){        \t// 180 days + 60 days ICO\r\n            require(msg.sender != teamHalfYearFrozen);\r\n        }\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {\r\n        require(!tokensAreFrozen);\r\n        require(_amount <= allowed[_from][msg.sender]);\r\n        require(_amount <= balances[_from]);\r\n        if(now < (timeStamp + 425 days)){               //365 days + 60 days ICO \r\n            require(msg.sender != teamOneYearFrozen);\r\n            require(_from != teamOneYearFrozen);\r\n        }\r\n        if(now < (timeStamp + 240 days)){        \t// 180 days + 60 days ICO\r\n            require(msg.sender != teamHalfYearFrozen);\r\n            require(_from != teamHalfYearFrozen);\r\n        }\r\n\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Allows another account/contract to spend some tokens on its behalf\r\n    * approve has to be called twice in 2 separate transactions - once to\r\n    *   change the allowance to 0 and secondly to change it to the new allowance value\r\n    *   @param _spender      approved address\r\n    *   @param _amount       allowance amount\r\n    *\r\n    *   @return true if the approval was successful\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns(bool) {\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    *   @param _owner        the address which owns the funds\r\n    *   @param _spender      the address which will spend the funds\r\n    *\r\n    *   @return              the amount of tokens still avaible for the spender\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns(uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\ncontract CretICO {\r\n    using SafeMath for uint256;\r\n    \r\n    address public TeamFund; //tokens will be frozen for 1 year\r\n    address public TeamFund2; //tokens will be frozen for a half year\r\n    address public Companion1;\r\n    address public Companion2;\r\n    address public Manager; // Manager controls contract\r\n    address internal addressCompanion1;\r\n    address internal addressCompanion2;\r\n    CretToken public CRET;\r\n    \r\n    /**\r\n    *   @dev Contract constructor function\r\n    */\r\n    constructor (\r\n        address _TeamFund,\r\n        address _TeamFund2,\r\n        address _Companion1,\r\n        address _Companion2,\r\n        address _Manager\r\n    )\r\n        public {\r\n        TeamFund = _TeamFund;\r\n        TeamFund2 = _TeamFund2;\r\n        Manager = _Manager;\r\n        Companion1 = _Companion1;\r\n        Companion2 = _Companion2;\r\n        statusICO = StatusICO.Created;\r\n        CRET = new CretToken(this, _TeamFund, _TeamFund2);\r\n    }\r\n    \r\n \r\n    \r\n\r\n    // Token price parameters\r\n    uint256 public Rate_Eth = 700; // Rate USD per ETH\r\n    uint256 public Tokens_Per_Dollar = 10; // CRET token per dollar\r\n    uint256 public Token_Price = Tokens_Per_Dollar.mul(Rate_Eth); // CRET token per ETH\r\n    uint256 constant teamPart = 75; //7.5% * 2 = 15% of sold tokens for team \r\n    uint256 constant advisersPart = 30; // 3% of sold tokens for advisers\r\n    uint256 constant riskPart = 10; // 1% of sold tokens for risk fund\r\n    uint256 constant airdropPart = 10; // 1% of sold tokens for airdrop program\r\n    uint256 constant SOFT_CAP = 30000000 * 1e18; // tokens without bonus 3 000 000$ in ICO\r\n    uint256 constant HARD_CAP = 450000000 * 1e18; // tokens without bonus 45 000 000$ in ICO\r\n    uint256 internal constant maxDeposit = 5000000 * 1e18;\r\n    uint256 internal constant bonusRange1 = 30000000 * 1e18;\r\n    uint256 internal constant bonusRange2 = 100000000 * 1e18;\r\n    uint256 internal constant bonusRange3 = 200000000 * 1e18;\r\n    uint256 internal constant bonusRange4 = 300000000 * 1e18;\r\n    uint256 public soldTotal;  // total sold without bonus\r\n    bool public canIBuy = false;\r\n    bool public canIWithdraw = false;\r\n\r\n\r\n    \r\n    \r\n\r\n    // Possible ICO statuses\r\n    enum StatusICO {\r\n        Created,\r\n        PreIco,\r\n        PreIcoFinished,\r\n        Ico,\r\n        IcoFinished\r\n    }\r\n    \r\n    \r\n    StatusICO statusICO;\r\n\r\n    // Mapping\r\n\r\n    mapping(address => uint256) public icoInvestments; // Mapping for remembering investors eth in ICO\r\n    mapping(address => bool) public returnStatus; // Users can return their funds one time\r\n    mapping(address => uint256) public tokensIco; // Mapping for remembering tokens of investors who paid at ICO in ether\r\n    mapping(address => uint256) public tokensIcoInOtherCrypto; // Mapping for remembering tokens of investors who paid at ICO in other crypto\r\n    mapping(address => uint256) public pureBalance; // Mapping for remembering pure tokens of investors who paid at ICO\r\n    mapping(address => bool) public kyc;  // investor identification status\r\n\r\n    // Events Log\r\n    event LogStartPreIco();\r\n    event LogFinishPreICO();\r\n    event LogStartIco();\r\n    event LogFinishICO();\r\n    event LogBuyForInvestor(address investor, uint256 value);\r\n    event LogReturnEth(address investor, uint256 eth);\r\n    event LogReturnOtherCrypto(address investor);\r\n\r\n    // Modifiers\r\n    // Allows execution by the contract manager only\r\n    modifier managerOnly {\r\n        require(msg.sender == Manager);\r\n        _;\r\n    }\r\n    \r\n    // Allows execution by the companions only\r\n    modifier companionsOnly {\r\n        require(msg.sender == Companion1 || msg.sender == Companion2);\r\n        _;\r\n    }\r\n\r\n\r\n    // passing KYC for investor\r\n    function passKYC(address _investor) external managerOnly {\r\n        kyc[_investor] = true;\r\n    }\r\n\r\n    // Giving a reward from risk managment token\r\n    function giveRiskToken(address _investor, uint256 _value) external managerOnly {\r\n        require(_value > 0);\r\n        uint256 rt = CRET.riskTokens();\r\n        uint256 decvalue = _value.mul(1 ether);\r\n        require(rt.add(decvalue) <= soldTotal.div(1000).mul(riskPart));\r\n        CRET.mintRiskTokens(_investor, decvalue);\r\n    }\r\n    \r\n    function giveAdvisers(address _investor, uint256 _value) external managerOnly {\r\n        require(_value > 0);\r\n        uint256 at = CRET.advisersTokens();\r\n        uint256 decvalue = _value.mul(1 ether);\r\n        require(at.add(decvalue) <= soldTotal.div(1000).mul(advisersPart)); // 3% for advisers\r\n        CRET.mintAdvisersTokens(_investor, decvalue);\r\n    }\r\n    \r\n    function giveReserveFund(address _investor, uint256 _value) external managerOnly {\r\n        require(_value > 0);\r\n        uint256 decvalue = _value.mul(1 ether);\r\n        CRET.mintReserveTokens(_investor, decvalue);\r\n    }\r\n    \r\n    function giveBounty(address[] dests, uint256 _value) external managerOnly {\r\n        require(_value > 0);\r\n        uint256 bt = CRET.bountyTokens();\r\n        uint256 decvalue = _value.mul(1 ether);\r\n        uint256 wantToMint = dests.length.mul(decvalue);\r\n        require(bt.add(wantToMint) <= soldTotal.div(1000).mul(airdropPart)); \r\n        CRET.mintBountyTokens(dests, decvalue);\r\n\r\n    }\r\n    \r\n   \r\n    function pureBalance(address _owner) public constant returns(uint256) {\r\n      return pureBalance[_owner];\r\n    }\r\n    \r\n    \r\n    function currentStage() public view returns (string) {\r\n        if(statusICO == StatusICO.Created){return \"Created\";}\r\n        else if(statusICO == StatusICO.PreIco){return  \"PreIco\";}\r\n        else if(statusICO == StatusICO.PreIcoFinished){return \"PreIcoFinished\";}\r\n        else if(statusICO == StatusICO.Ico){return \"Ico\";}\r\n        else if(statusICO == StatusICO.IcoFinished){return \"IcoFinished\";}\r\n    }\r\n\r\n   /**\r\n    *   @dev Set rate of ETH and update token price\r\n    *   @param _RateEth       current ETH rate\r\n    */\r\n    function setRate(uint256 _RateEth) external managerOnly {\r\n        Rate_Eth = _RateEth;\r\n        Token_Price = Tokens_Per_Dollar.mul(Rate_Eth);\r\n    }\r\n\r\n   /**\r\n    *   \r\n    *   Start PreICO \r\n    */\r\n    function startPreIco() external managerOnly {\r\n        require(statusICO == StatusICO.Created); \r\n        statusICO = StatusICO.PreIco;\r\n        emit LogStartPreIco();\r\n    }\r\n    \r\n    /**\r\n    *   @dev Finish PreIco\r\n    *   Set Ico status to PreIcoFinished\r\n    */\r\n    function finishPreIco() external managerOnly {\r\n        require(statusICO == StatusICO.PreIco);\r\n        statusICO = StatusICO.PreIcoFinished;\r\n        emit LogFinishPreICO();\r\n    }\r\n\r\n \r\n \r\n\r\n   /**\r\n    *   @dev Start ICO\r\n    *   Set ICO status\r\n    */\r\n    \r\n    function setIco() external managerOnly {\r\n        require(statusICO == StatusICO.PreIcoFinished);\r\n        statusICO = StatusICO.Ico;\r\n        canIBuy = true;\r\n        emit LogStartIco();\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Finish ICO and emit tokens for bounty advisors and team\r\n    */\r\n    function finishIco() external managerOnly {\r\n        require(statusICO == StatusICO.Ico);\r\n        \r\n        uint256 teamTokens = soldTotal.div(1000).mul(teamPart);\r\n        CRET.mintTokens(TeamFund, teamTokens);\r\n        CRET.mintTokens(TeamFund2, teamTokens);\r\n        statusICO = StatusICO.IcoFinished;\r\n        canIBuy = false;\r\n        if(soldTotal < SOFT_CAP){canIWithdraw = true;}\r\n        emit LogFinishICO();\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Unfreeze tokens(enable token transfer)\r\n    */\r\n    function enableTokensTransfer() external managerOnly {\r\n        CRET.defrostTokens();\r\n    }\r\n\r\n    /**\r\n    *   @dev Freeze tokens(disable token transfers)\r\n    */\r\n    function disableTokensTransfer() external managerOnly {\r\n        require(statusICO != StatusICO.IcoFinished);\r\n        CRET.frostTokens();\r\n    }\r\n\r\n   /**\r\n    *   @dev Fallback function calls function to create tokens\r\n    *        when investor sends ETH to address of ICO contract\r\n    */\r\n    function() external payable {\r\n        require(canIBuy);\r\n        require(kyc[msg.sender]);\r\n        require(msg.value > 0);\r\n        require(msg.value.mul(Token_Price) <= maxDeposit);\r\n        require(pureBalance[msg.sender].add(msg.value.mul(Token_Price)) <= maxDeposit);\r\n        createTokens(msg.sender, msg.value.mul(Token_Price), msg.value);\r\n    }\r\n    \r\n   \r\n    \r\n    function buyToken() external payable {\r\n        require(canIBuy);\r\n        require(kyc[msg.sender]);\r\n        require(msg.value > 0);\r\n        require(msg.value.mul(Token_Price) <= maxDeposit);\r\n        require(pureBalance[msg.sender].add(msg.value.mul(Token_Price)) <= maxDeposit);\r\n        createTokens(msg.sender, msg.value.mul(Token_Price), msg.value);\r\n    }\r\n    \r\n    \r\n    function buyPreIco() external payable {\r\n        require(msg.value.mul(Token_Price) <= maxDeposit);\r\n        require(kyc[msg.sender]);\r\n        require(statusICO == StatusICO.PreIco);\r\n        require(pureBalance[msg.sender].add(msg.value.mul(Token_Price)) <= maxDeposit);\r\n        createTokens(msg.sender, msg.value.mul(Token_Price), msg.value);\r\n    }\r\n\r\n\r\n\r\n    function buyForInvestor(address _investor, uint256 _value) external managerOnly {\r\n        uint256 decvalue = _value.mul(1 ether);\r\n        require(_value > 0);\r\n        require(kyc[_investor]);\r\n        require(pureBalance[_investor].add(decvalue) <= maxDeposit);\r\n        require(decvalue <= maxDeposit);\r\n        require(statusICO != StatusICO.IcoFinished);\r\n        require(statusICO != StatusICO.PreIcoFinished);\r\n        require(statusICO != StatusICO.Created);\r\n        require(soldTotal.add(decvalue) <= HARD_CAP);\r\n        uint256 bonus = getBonus(decvalue);\r\n        uint256 total = decvalue.add(bonus);\r\n        tokensIcoInOtherCrypto[_investor] = tokensIcoInOtherCrypto[_investor].add(total);\r\n        soldTotal = soldTotal.add(decvalue);\r\n        pureBalance[_investor] = pureBalance[_investor].add(decvalue);\r\n        \r\n        CRET.mintTokens(_investor, total);\r\n        emit LogBuyForInvestor(_investor, _value);\r\n    }\r\n    \r\n\r\n\r\n    function createTokens(address _investor, uint256 _value, uint256 _ethValue) internal {\r\n        require(_value > 0);\r\n        require(soldTotal.add(_value) <= HARD_CAP);\r\n        uint256 bonus = getBonus(_value);\r\n        uint256 total = _value.add(bonus);\r\n        tokensIco[_investor] = tokensIco[_investor].add(total);\r\n        icoInvestments[_investor] = icoInvestments[_investor].add(_ethValue);\r\n        soldTotal = soldTotal.add(_value);\r\n        pureBalance[_investor] = pureBalance[_investor].add(_value);\r\n      \r\n        CRET.mintTokens(_investor, total);\r\n    }\r\n\r\n\r\n\r\n   /**\r\n    *   @dev Calculates bonus \r\n    *   @param _value        amount of tokens\r\n    *   @return              bonus value\r\n    */\r\n    function getBonus(uint256 _value) public view returns(uint256) {\r\n        uint256 bonus = 0;\r\n        if (soldTotal <= bonusRange1) {\r\n            if(soldTotal.add(_value) <= bonusRange1){\r\n                bonus = _value.mul(500).div(1000);\r\n            } else {\r\n                uint256 part1 = (soldTotal.add(_value)).sub(bonusRange1);\r\n                uint256 part2 = _value.sub(part1);\r\n                uint256 bonusPart1 = part1.mul(300).div(1000);\r\n                uint256 bonusPart2 = part2.mul(500).div(1000);\r\n                bonus = bonusPart1.add(bonusPart2);\r\n            }\r\n                                \r\n        } else if (soldTotal > bonusRange1 && soldTotal <= bonusRange2) {\r\n            if(soldTotal.add(_value) <= bonusRange2){\r\n                bonus = _value.mul(300).div(1000);\r\n            } else {\r\n                part1 = (soldTotal.add(_value)).sub(bonusRange2);\r\n                part2 = _value.sub(part1);\r\n                bonusPart1 = part1.mul(200).div(1000);\r\n                bonusPart2 = part2.mul(300).div(1000);\r\n                bonus = bonusPart1.add(bonusPart2);\r\n            }\r\n        } else if (soldTotal > bonusRange2 && soldTotal <= bonusRange3) {\r\n            if(soldTotal.add(_value) <= bonusRange3){\r\n                bonus = _value.mul(200).div(1000);\r\n            } else {\r\n                part1 = (soldTotal.add(_value)).sub(bonusRange3);\r\n                part2 = _value.sub(part1);\r\n                bonusPart1 = part1.mul(100).div(1000);\r\n                bonusPart2 = part2.mul(200).div(1000);\r\n                bonus = bonusPart1.add(bonusPart2);\r\n            }\r\n        } else if (soldTotal > bonusRange3 && soldTotal <= bonusRange4) {\r\n            if(soldTotal.add(_value) <= bonusRange4){\r\n                bonus = _value.mul(100).div(1000);\r\n            } else {\r\n                part1 = (soldTotal.add(_value)).sub(bonusRange4);\r\n                part2 = _value.sub(part1);\r\n                bonusPart1 = 0;\r\n                bonusPart2 = part2.mul(100).div(1000);\r\n                bonus = bonusPart1.add(bonusPart2);\r\n            }\r\n        } \r\n        return bonus;\r\n    }\r\n    \r\n    \r\n    \r\n\r\n   /**\r\n    *   @dev Allows investors to return their investments\r\n    */\r\n    function returnEther() public {\r\n        require(canIWithdraw);\r\n        require(!returnStatus[msg.sender]);\r\n        require(icoInvestments[msg.sender] > 0);\r\n        uint256 eth = 0;\r\n        uint256 tokens = 0;\r\n        eth = icoInvestments[msg.sender];\r\n        tokens = tokensIco[msg.sender];\r\n        icoInvestments[msg.sender] = 0;\r\n        tokensIco[msg.sender] = 0;\r\n        pureBalance[msg.sender] = 0;\r\n        returnStatus[msg.sender] = true;\r\n\r\n        CRET.burnTokens(msg.sender, tokens);\r\n        msg.sender.transfer(eth);\r\n        emit LogReturnEth(msg.sender, eth);\r\n    }\r\n\r\n   /**\r\n    *   @dev Burn tokens who paid in other cryptocurrencies\r\n    */\r\n    function returnOtherCrypto(address _investor)external managerOnly {\r\n        require(canIWithdraw);\r\n        require(tokensIcoInOtherCrypto[_investor] > 0);\r\n        uint256 tokens = 0;\r\n        tokens = tokensIcoInOtherCrypto[_investor];\r\n        tokensIcoInOtherCrypto[_investor] = 0;\r\n        pureBalance[_investor] = 0;\r\n\r\n        CRET.burnTokens(_investor, tokens);\r\n        emit LogReturnOtherCrypto(_investor);\r\n    }\r\n    \r\n    \r\n    /**\r\n    *   @dev Allows Companions to add consensus address\r\n    */\r\n    function consensusAddress(address _investor) external companionsOnly {\r\n        if(msg.sender == Companion1) {\r\n            addressCompanion1 = _investor;\r\n        } else {\r\n            addressCompanion2 = _investor;\r\n        }\r\n    }\r\n    \r\n    \r\n    \r\n   \r\n\r\n   /**\r\n    *   @dev Allows Companions withdraw investments\r\n    */\r\n    function takeInvestments() external companionsOnly {\r\n        require(addressCompanion1 != 0x0 && addressCompanion2 != 0x0);\r\n        require(addressCompanion1 == addressCompanion2);\r\n        require(soldTotal >= SOFT_CAP);\r\n        addressCompanion1.transfer(address(this).balance);\r\n        CRET.defrostTokens();\r\n        }\r\n        \r\n    }\r\n\r\n\r\n// gexabyte.com","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeStamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advisersTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintRiskTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamHalfYearFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintReserveTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dests\",\"type\":\"address[]\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintBountyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"frostTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintAdvisersTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"defrostTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBountyStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"riskTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveTokensLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensAreFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamOneYearFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"address\"},{\"name\":\"_team2\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"CretToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b58b3e52a3550e0bdcfe00b1918a760bb7c0f33c0000000000000000000000005d738f9ed814b799fe8bc3114caee45b1e8f84d20000000000000000000000008918bc88f7363e3d58ecdba23de19e13e9cb3274","Library":"","SwarmSource":"bzzr://48e5f76fb47edaeb01be825e723cefcf27b6318c1824ea4cca74621c7307b514"}]}