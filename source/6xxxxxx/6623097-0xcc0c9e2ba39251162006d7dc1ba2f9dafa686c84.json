{"status":"1","message":"OK","result":[{"SourceCode":"contract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\ncontract ERC20Interface {\r\n\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    function allowance(address owner, address spender)public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value)public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n\r\n}\r\ncontract StandardToken is ERC20Interface {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply_;\r\n\r\n    // the following variables need to be here for scoping to properly freeze normal transfers after migration has started\r\n    // migrationStart flag\r\n    bool public migrationStart;\r\n    // var for storing the the TimeLock contract deployment address (for vesting GTX allocations)\r\n    TimeLock timeLockContract;\r\n\r\n    /**\r\n     * @dev Modifier for allowing only TimeLock transactions to occur after the migration period has started\r\n    */\r\n    modifier migrateStarted {\r\n        if(migrationStart == true){\r\n            require(msg.sender == address(timeLockContract));\r\n        }\r\n        _;\r\n    }\r\n\r\n    constructor(string _name, string _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public migrateStarted returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n        )\r\n        public\r\n        migrateStarted\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = (\r\n        allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\ncontract GTXERC20Migrate is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // Address map used to store the per account claimable GTX Network Tokens\r\n    // as per the user's GTX ERC20 on the Ethereum Network\r\n\r\n    mapping (address => uint256) public migratableGTX;\r\n\r\n    GTXToken public ERC20;\r\n\r\n    constructor(GTXToken _ERC20) public {\r\n        ERC20 = _ERC20;\r\n    }\r\n\r\n    // Note: _totalMigratableGTX is a running total of GTX, migratable in this contract,\r\n    // but does not represent the actual amount of GTX migrated to the Gallactic network\r\n    event GTXRecordUpdate(\r\n        address indexed _recordAddress,\r\n        uint256 _totalMigratableGTX\r\n    );\r\n\r\n    /**\r\n    * @dev Used to calculate and store the amount of GTX ERC20 token balances to be migrated to the Gallactic network\r\n    * i.e., 1 GTX = 10**18 base units\r\n    * @param _balanceToMigrate - the requested balance to reserve for migration (in most cases this should be the account's total balance)\r\n    * primarily included as a parameter for simple validation on the Gallactic side of the migration\r\n    */\r\n    function initiateGTXMigration(uint256 _balanceToMigrate) public {\r\n        uint256 migratable = ERC20.migrateTransfer(msg.sender,_balanceToMigrate);\r\n        migratableGTX[msg.sender] = migratableGTX[msg.sender].add(migratable);\r\n        emit GTXRecordUpdate(msg.sender, migratableGTX[msg.sender]);\r\n    }\r\n\r\n}\r\ncontract TimeLock {\r\n    //GTXERC20 var definition\r\n    GTXToken public ERC20;\r\n    // custom data structure to hold locked funds and time\r\n    struct accountData {\r\n        uint256 balance;\r\n        uint256 releaseTime;\r\n    }\r\n\r\n    event Lock(address indexed _tokenLockAccount, uint256 _lockBalance, uint256 _releaseTime);\r\n    event UnLock(address indexed _tokenUnLockAccount, uint256 _unLockBalance, uint256 _unLockTime);\r\n\r\n    // only one locked account per address\r\n    mapping (address => accountData) public accounts;\r\n\r\n    /**\r\n    * @dev Constructor in which we pass the ERC20 Contract address for reference and method calls\r\n    */\r\n\r\n    constructor(GTXToken _ERC20) public {\r\n        ERC20 = _ERC20;\r\n    }\r\n\r\n    function timeLockTokens(uint256 _lockTimeS) public {\r\n\r\n        uint256 lockAmount = ERC20.allowance(msg.sender, this); // get this time lock contract's approved amount of tokens\r\n        require(lockAmount != 0); // check that this time lock contract has been approved to lock an amount of tokens on the msg.sender's behalf\r\n        if (accounts[msg.sender].balance > 0) { // if locked balance already exists, add new amount to the old balance and retain the same release time\r\n            accounts[msg.sender].balance = SafeMath.add(accounts[msg.sender].balance, lockAmount);\r\n        } else { // else populate the balance and set the release time for the newly locked balance\r\n            accounts[msg.sender].balance = lockAmount;\r\n            accounts[msg.sender].releaseTime = SafeMath.add(block.timestamp , _lockTimeS);\r\n        }\r\n\r\n        emit Lock(msg.sender, lockAmount, accounts[msg.sender].releaseTime);\r\n        ERC20.transferFrom(msg.sender, this, lockAmount);\r\n\r\n    }\r\n\r\n    function tokenRelease() public {\r\n        // check if user has funds due for pay out because lock time is over\r\n        require (accounts[msg.sender].balance != 0 && accounts[msg.sender].releaseTime <= block.timestamp);\r\n        uint256 transferUnlockedBalance = accounts[msg.sender].balance;\r\n        accounts[msg.sender].balance = 0;\r\n        accounts[msg.sender].releaseTime = 0;\r\n        emit UnLock(msg.sender, transferUnlockedBalance, block.timestamp);\r\n        ERC20.transfer(msg.sender, transferUnlockedBalance);\r\n    }\r\n\r\n    // some helper functions for demo purposes (not required)\r\n    function getLockedFunds(address _account) view public returns (uint _lockedBalance) {\r\n        return accounts[_account].balance;\r\n    }\r\n\r\n    function getReleaseTime(address _account) view public returns (uint _releaseTime) {\r\n        return accounts[_account].releaseTime;\r\n    }\r\n\r\n}\r\ncontract GTXToken is StandardToken, Ownable{\r\n    using SafeMath for uint256;\r\n    event SetMigrationAddress(address GTXERC20MigrateAddress);\r\n    event SetAuctionAddress(address GTXAuctionContractAddress);\r\n    event SetTimeLockAddress(address _timeLockAddress);\r\n    event Migrated(address indexed account, uint256 amount);\r\n    event MigrationStarted();\r\n\r\n\r\n    //global variables\r\n    GTXRecord public gtxRecord;\r\n    GTXPresale public gtxPresale;\r\n    uint256 public totalAllocation;\r\n\r\n    // var for storing the the GTXRC20Migrate contract deployment address (for migration to the GALLACTIC network)\r\n    TimeLock timeLockContract;\r\n    GTXERC20Migrate gtxMigrationContract;\r\n    GTXAuction gtxAuctionContract;\r\n\r\n    /**\r\n     * @dev Modifier for only GTX migration contract address\r\n    */\r\n    modifier onlyMigrate {\r\n        require(msg.sender == address(gtxMigrationContract));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier for only gallactic Auction contract address\r\n    */\r\n    modifier onlyAuction {\r\n        require(msg.sender == address(gtxAuctionContract));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor to pass the GTX ERC20 arguments\r\n     * @param _totalSupply the total token supply (Initial Proposal is 1,000,000,000)\r\n     * @param _gtxRecord the GTXRecord contract address to use for records keeping\r\n     * @param _gtxPresale the GTXPresale contract address to use for records keeping\r\n     * @param _name ERC20 Token Name (Gallactic Token)\r\n     * @param _symbol ERC20 Token Symbol (GTX)\r\n     * @param _decimals ERC20 Token Decimal precision value (18)\r\n    */\r\n    constructor(uint256 _totalSupply, GTXRecord _gtxRecord, GTXPresale _gtxPresale, string _name, string _symbol, uint8 _decimals)\r\n    StandardToken(_name,_symbol,_decimals) public {\r\n        require(_gtxRecord != address(0), \"Must provide a Record address\");\r\n        require(_gtxPresale != address(0), \"Must provide a PreSale address\");\r\n        require(_gtxPresale.getStage() > 0, \"Presale must have already set its allocation\");\r\n        require(_gtxRecord.maxRecords().add(_gtxPresale.totalPresaleTokens()) <= _totalSupply, \"Records & PreSale allocation exceeds the proposed total supply\");\r\n\r\n        totalSupply_ = _totalSupply; // unallocated until passAuctionAllocation is called\r\n        gtxRecord = _gtxRecord;\r\n        gtxPresale = _gtxPresale;\r\n    }\r\n\r\n    /**\r\n    * @dev Fallback reverts any ETH payment\r\n    */\r\n    function () public payable {\r\n        revert ();\r\n    }\r\n\r\n    /**\r\n    * @dev Safety function for reclaiming ERC20 tokens\r\n    * @param _token address of the ERC20 contract\r\n    */\r\n    function recoverLost(ERC20Interface _token) public onlyOwner {\r\n        _token.transfer(owner(), _token.balanceOf(this));\r\n    }\r\n\r\n    /**\r\n    * @dev Function to set the migration contract address\r\n    * @return True if the operation was successful.\r\n    */\r\n    function setMigrationAddress(GTXERC20Migrate _gtxMigrateContract) public onlyOwner returns (bool) {\r\n        require(_gtxMigrateContract != address(0), \"Must provide a Migration address\");\r\n        // check that this GTX ERC20 deployment is the migration contract's attached ERC20 token\r\n        require(_gtxMigrateContract.ERC20() == address(this), \"Migration contract does not have this token assigned\");\r\n\r\n        gtxMigrationContract = _gtxMigrateContract;\r\n        emit SetMigrationAddress(_gtxMigrateContract);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to set the Auction contract address\r\n    * @return True if the operation was successful.\r\n    */\r\n    function setAuctionAddress(GTXAuction _gtxAuctionContract) public onlyOwner returns (bool) {\r\n        require(_gtxAuctionContract != address(0), \"Must provide an Auction address\");\r\n        // check that this GTX ERC20 deployment is the Auction contract's attached ERC20 token\r\n        require(_gtxAuctionContract.ERC20() == address(this), \"Auction contract does not have this token assigned\");\r\n\r\n        gtxAuctionContract = _gtxAuctionContract;\r\n        emit SetAuctionAddress(_gtxAuctionContract);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to set the TimeLock contract address\r\n    * @return True if the operation was successful.\r\n    */\r\n    function setTimeLockAddress(TimeLock _timeLockContract) public onlyOwner returns (bool) {\r\n        require(_timeLockContract != address(0), \"Must provide a TimeLock address\");\r\n        // check that this GTX ERC20 deployment is the TimeLock contract's attached ERC20 token\r\n        require(_timeLockContract.ERC20() == address(this), \"TimeLock contract does not have this token assigned\");\r\n\r\n        timeLockContract = _timeLockContract;\r\n        emit SetTimeLockAddress(_timeLockContract);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Function to start the migration period\r\n    * @return True if the operation was successful.\r\n    */\r\n    function startMigration() onlyOwner public returns (bool) {\r\n        require(migrationStart == false, \"startMigration has already been run\");\r\n        // check that the GTX migration contract address is set\r\n        require(gtxMigrationContract != address(0), \"Migration contract address must be set\");\r\n        // check that the GTX Auction contract address is set\r\n        require(gtxAuctionContract != address(0), \"Auction contract address must be set\");\r\n        // check that the TimeLock contract address is set\r\n        require(timeLockContract != address(0), \"TimeLock contract address must be set\");\r\n\r\n        migrationStart = true;\r\n        emit MigrationStarted();\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to pass the Auction Allocation to the Auction Contract Address\r\n     * @dev modifier onlyAuction Permissioned only to the Gallactic Auction Contract Owner\r\n     * @param _auctionAllocation The GTX Auction Allocation Amount (Initial Proposal 400,000,000 tokens)\r\n    */\r\n\r\n    function passAuctionAllocation(uint256 _auctionAllocation) public onlyAuction {\r\n        //check GTX Record creation has stopped.\r\n        require(gtxRecord.lockRecords() == true, \"GTXRecord contract lock state should be true\");\r\n\r\n        uint256 gtxRecordTotal = gtxRecord.totalClaimableGTX();\r\n        uint256 gtxPresaleTotal = gtxPresale.totalPresaleTokens();\r\n\r\n        totalAllocation = _auctionAllocation.add(gtxRecordTotal).add(gtxPresaleTotal);\r\n        require(totalAllocation <= totalSupply_, \"totalAllocation must be less than totalSupply\");\r\n        balances[gtxAuctionContract] = totalAllocation;\r\n        emit Transfer(address(0), gtxAuctionContract, totalAllocation);\r\n        uint256 remainingTokens = totalSupply_.sub(totalAllocation);\r\n        balances[owner()] = remainingTokens;\r\n        emit Transfer(address(0), owner(), totalAllocation);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to modify the GTX ERC-20 balance in compliance with migration to GTX network tokens on the GALLACTIC Network\r\n     *      - called by the GTX-ERC20-MIGRATE GTXERC20Migrate.sol Migration Contract to record the amount of tokens to be migrated\r\n     * @dev modifier onlyMigrate - Permissioned only to the deployed GTXERC20Migrate.sol Migration Contract\r\n     * @param _account The Ethereum account which holds some GTX ERC20 balance to be migrated to Gallactic\r\n     * @param _amount The amount of GTX ERC20 to be migrated\r\n    */\r\n    function migrateTransfer(address _account, uint256 _amount) onlyMigrate public returns (uint256) {\r\n        require(migrationStart == true);\r\n        uint256 userBalance = balanceOf(_account);\r\n        require(userBalance >= _amount);\r\n\r\n        emit Migrated(_account, _amount);\r\n        balances[_account] = balances[_account].sub(_amount);\r\n        return _amount;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to get the GTX Record contract address\r\n    */\r\n    function getGTXRecord() public view returns (address) {\r\n        return address(gtxRecord);\r\n    }\r\n\r\n    /**\r\n     * @dev Function to get the total auction allocation\r\n    */\r\n    function getAuctionAllocation() public view returns (uint256){\r\n        require(totalAllocation != 0, \"Auction allocation has not been set yet\");\r\n        return totalAllocation;\r\n    }\r\n}\r\ncontract GTXRecord is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // conversionRate is the multiplier to calculate the number of GTX claimable per FIN Point converted\r\n    // e.g., 100 = 1:1 conversion ratio\r\n    uint256 public conversionRate;\r\n\r\n    // a flag for locking record changes, lockRecords is only settable by the owner\r\n    bool public lockRecords;\r\n\r\n    // Maximum amount of recorded GTX able to be stored on this contract\r\n    uint256 public maxRecords;\r\n\r\n    // Total number of claimable GTX converted from FIN Points\r\n    uint256 public totalClaimableGTX;\r\n\r\n    // an address map used to store the per account claimable GTX\r\n    // as a result of converted FIN Points\r\n    mapping (address => uint256) public claimableGTX;\r\n\r\n    event GTXRecordCreate(\r\n        address indexed _recordAddress,\r\n        uint256 _finPointAmount,\r\n        uint256 _gtxAmount\r\n    );\r\n\r\n    event GTXRecordUpdate(\r\n        address indexed _recordAddress,\r\n        uint256 _finPointAmount,\r\n        uint256 _gtxAmount\r\n    );\r\n\r\n    event GTXRecordMove(\r\n        address indexed _oldAddress,\r\n        address indexed _newAddress,\r\n        uint256 _gtxAmount\r\n    );\r\n\r\n    event LockRecords();\r\n\r\n    /**\r\n     * Throws if conversionRate is not set or if the lockRecords flag has been set to true\r\n    */\r\n    modifier canRecord() {\r\n        require(conversionRate > 0);\r\n        require(!lockRecords);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev GTXRecord constructor\r\n     * @param _maxRecords is the maximum numer of GTX records this contract can store (used for sanity checks on GTX ERC20 totalsupply)\r\n    */\r\n    constructor (uint256 _maxRecords) public {\r\n        maxRecords = _maxRecords;\r\n    }\r\n\r\n    /**\r\n     * @dev sets the GTX Conversion rate\r\n     * @param _conversionRate is the rate applied during FIN Point to GTX conversion\r\n    */\r\n    function setConversionRate(uint256 _conversionRate) external onlyOwner{\r\n        require(_conversionRate <= 1000); // maximum 10x conversion rate\r\n        require(_conversionRate > 0); // minimum .01x conversion rate\r\n        conversionRate = _conversionRate;\r\n    }\r\n\r\n   /**\r\n    * @dev Function to lock record changes on this contracts\r\n    * @return True if the operation was successful.\r\n    */\r\n    function lock() public onlyOwner returns (bool) {\r\n        lockRecords = true;\r\n        emit LockRecords();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Used to calculate and store the amount of claimable GTX for those exsisting FIN point holders\r\n    * who opt to convert FIN points for GTX\r\n    * @param _recordAddress - the registered address where GTX can be claimed from\r\n    * @param _finPointAmount - the amount of FINs to be converted for GTX, this param should always be entered as base units\r\n    * i.e., 1 FIN = 10**18 base units\r\n    * @param _applyConversionRate - flag to apply conversion rate or not, any Finterra Technologies company GTX conversion allocations\r\n    * are strictly covnerted at one to one and do not recive the conversion bonus applied to FIN point user balances\r\n    */\r\n    function recordCreate(address _recordAddress, uint256 _finPointAmount, bool _applyConversionRate) public onlyOwner canRecord {\r\n        require(_finPointAmount >= 100000, \"cannot be less than 100000 FIN (in WEI)\"); // minimum allowed FIN 0.000000000001 (in base units) to avoid large rounding errors\r\n        uint256 afterConversionGTX;\r\n        if(_applyConversionRate == true) {\r\n            afterConversionGTX = _finPointAmount.mul(conversionRate).div(100);\r\n        } else {\r\n            afterConversionGTX = _finPointAmount;\r\n        }\r\n        claimableGTX[_recordAddress] = claimableGTX[_recordAddress].add(afterConversionGTX);\r\n        totalClaimableGTX = totalClaimableGTX.add(afterConversionGTX);\r\n        require(totalClaimableGTX <= maxRecords, \"total token record (contverted GTX) cannot exceed GTXRecord token limit\");\r\n        emit GTXRecordCreate(_recordAddress, _finPointAmount, claimableGTX[_recordAddress]);\r\n    }\r\n\r\n    /**\r\n    * @dev Used to calculate and update the amount of claimable GTX for those exsisting FIN point holders\r\n    * who opt to convert FIN points for GTX\r\n    * @param _recordAddress - the registered address where GTX can be claimed from\r\n    * @param _finPointAmount - the amount of FINs to be converted for GTX, this param should always be entered as base units\r\n    * i.e., 1 FIN = 10**18 base units\r\n    * @param _applyConversionRate - flag to apply conversion rate or do one for one conversion, any Finterra Technologies company FIN point allocations\r\n    * are strictly converted at one to one and do not recive the cnversion bonus applied to FIN point user balances\r\n    */\r\n    function recordUpdate(address _recordAddress, uint256 _finPointAmount, bool _applyConversionRate) public onlyOwner canRecord {\r\n        require(_finPointAmount >= 100000, \"cannot be less than 100000 FIN (in WEI)\"); // minimum allowed FIN 0.000000000001 (in base units) to avoid large rounding errors\r\n        uint256 afterConversionGTX;\r\n        totalClaimableGTX = totalClaimableGTX.sub(claimableGTX[_recordAddress]);\r\n        if(_applyConversionRate == true) {\r\n            afterConversionGTX  = _finPointAmount.mul(conversionRate).div(100);\r\n        } else {\r\n            afterConversionGTX  = _finPointAmount;\r\n        }\r\n        claimableGTX[_recordAddress] = afterConversionGTX;\r\n        totalClaimableGTX = totalClaimableGTX.add(claimableGTX[_recordAddress]);\r\n        require(totalClaimableGTX <= maxRecords, \"total token record (contverted GTX) cannot exceed GTXRecord token limit\");\r\n        emit GTXRecordUpdate(_recordAddress, _finPointAmount, claimableGTX[_recordAddress]);\r\n    }\r\n\r\n    /**\r\n    * @dev Used to move GTX records from one address to another, primarily in case a user has lost access to their originally registered account\r\n    * @param _oldAddress - the original registered address\r\n    * @param _newAddress - the new registerd address\r\n    */\r\n    function recordMove(address _oldAddress, address _newAddress) public onlyOwner canRecord {\r\n        require(claimableGTX[_oldAddress] != 0, \"cannot move a zero record\");\r\n        require(claimableGTX[_newAddress] == 0, \"destination must not already have a claimable record\");\r\n\r\n        claimableGTX[_newAddress] = claimableGTX[_oldAddress];\r\n        claimableGTX[_oldAddress] = 0;\r\n\r\n        emit GTXRecordMove(_oldAddress, _newAddress, claimableGTX[_newAddress]);\r\n    }\r\n\r\n}\r\ncontract GTXPresale is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    // a flag for locking record changes, lockRecords is only settable by the owner\r\n    bool public lockRecords;\r\n\r\n    // Total GTX allocated for presale\r\n    uint256 public totalPresaleTokens;\r\n\r\n    // Total Claimable GTX which is the Amount of GTX sold during presale\r\n    uint256 public totalClaimableGTX;\r\n\r\n    // an address map used to store the per account claimable GTX and their bonus\r\n    mapping (address => uint256) public presaleGTX;\r\n    mapping (address => uint256) public bonusGTX;\r\n    mapping (address => uint256) public claimableGTX;\r\n\r\n    // Bonus Arrays for presale amount based Bonus calculation\r\n    uint256[11] public bonusPercent; // 11 possible bonus percentages (with values 0 - 100 each)\r\n    uint256[11] public bonusThreshold; // 11 thresholds values to calculate bonus based on the presale tokens (in cents).\r\n\r\n    // Enums for Stages\r\n    Stages public stage;\r\n\r\n    /*\r\n     *  Enums\r\n     */\r\n    enum Stages {\r\n        PresaleDeployed,\r\n        Presale,\r\n        ClaimingStarted\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier atStage(Stages _stage) {\r\n        require(stage == _stage, \"function not allowed at current stage\");\r\n        _;\r\n    }\r\n\r\n    event Setup(\r\n        uint256 _maxPresaleTokens,\r\n        uint256[] _bonusThreshold,\r\n        uint256[] _bonusPercent\r\n    );\r\n\r\n    event GTXRecordCreate(\r\n        address indexed _recordAddress,\r\n        uint256 _gtxTokens\r\n    );\r\n\r\n    event GTXRecordUpdate(\r\n        address indexed _recordAddress,\r\n        uint256 _gtxTokens\r\n    );\r\n\r\n    event GTXRecordMove(\r\n        address indexed _oldAddress,\r\n        address indexed _newAddress,\r\n        uint256 _gtxTokens\r\n    );\r\n\r\n    event LockRecords();\r\n\r\n    constructor() public{\r\n        stage = Stages.PresaleDeployed;\r\n    }\r\n\r\n   /**\r\n    * @dev Function to lock record changes on this contract\r\n    * @return True if the operation was successful.\r\n    */\r\n    function lock() public onlyOwner returns (bool) {\r\n        lockRecords = true;\r\n        stage = Stages.ClaimingStarted;\r\n        emit LockRecords();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev setup function sets up the bonus percent and bonus thresholds for MD module tokens\r\n     * @param _maxPresaleTokens is the maximum tokens allocated for presale\r\n     * @param _bonusThreshold is an array of thresholds of GTX Tokens in dollars to calculate bonus%\r\n     * @param _bonusPercent is an array of bonus% from 0-100\r\n    */\r\n    function setup(uint256 _maxPresaleTokens, uint256[] _bonusThreshold, uint256[] _bonusPercent) external onlyOwner atStage(Stages.PresaleDeployed) {\r\n        require(_bonusPercent.length == _bonusThreshold.length, \"Length of bonus percent array and bonus threshold should be equal\");\r\n        totalPresaleTokens =_maxPresaleTokens;\r\n        for(uint256 i=0; i< _bonusThreshold.length; i++) {\r\n            bonusThreshold[i] = _bonusThreshold[i];\r\n            bonusPercent[i] = _bonusPercent[i];\r\n        }\r\n        stage = Stages.Presale; //Once the inital parameters are set the Presale Record Creation can be started\r\n        emit Setup(_maxPresaleTokens,_bonusThreshold,_bonusPercent);\r\n    }\r\n\r\n    /**\r\n    * @dev Used to store the amount of Presale GTX tokens for those who purchased Tokens during the presale\r\n    * @param _recordAddress - the registered address where GTX can be claimed from\r\n    * @param _gtxTokens - the amount of presale GTX tokens, this param should always be entered as Boson (base units)\r\n    * i.e., 1 GTX = 10**18 Boson\r\n    */\r\n    function recordCreate(address _recordAddress, uint256 _gtxTokens) public onlyOwner atStage(Stages.Presale) {\r\n        // minimum allowed GTX 0.000000000001 (in Boson) to avoid large rounding errors\r\n        require(_gtxTokens >= 100000, \"Minimum allowed GTX tokens is 100000 Bosons\");\r\n        totalClaimableGTX = totalClaimableGTX.sub(claimableGTX[_recordAddress]);\r\n        presaleGTX[_recordAddress] = presaleGTX[_recordAddress].add(_gtxTokens);\r\n        bonusGTX[_recordAddress] = calculateBonus(_recordAddress);\r\n        claimableGTX[_recordAddress] = presaleGTX[_recordAddress].add(bonusGTX[_recordAddress]);\r\n\r\n        totalClaimableGTX = totalClaimableGTX.add(claimableGTX[_recordAddress]);\r\n        require(totalClaimableGTX <= totalPresaleTokens, \"total token record (presale GTX + bonus GTX) cannot exceed presale token limit\");\r\n        emit GTXRecordCreate(_recordAddress, claimableGTX[_recordAddress]);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Used to calculate and update the amount of claimable GTX for those who purchased Tokens during the presale\r\n    * @param _recordAddress - the registered address where GTX can be claimed from\r\n    * @param _gtxTokens - the amount of presale GTX tokens, this param should always be entered as Boson (base units)\r\n    * i.e., 1 GTX = 10**18 Boson\r\n    */\r\n    function recordUpdate(address _recordAddress, uint256 _gtxTokens) public onlyOwner atStage(Stages.Presale){\r\n        // minimum allowed GTX 0.000000000001 (in Boson) to avoid large rounding errors\r\n        require(_gtxTokens >= 100000, \"Minimum allowed GTX tokens is 100000 Bosons\");\r\n        totalClaimableGTX = totalClaimableGTX.sub(claimableGTX[_recordAddress]);\r\n        presaleGTX[_recordAddress] = _gtxTokens;\r\n        bonusGTX[_recordAddress] = calculateBonus(_recordAddress);\r\n        claimableGTX[_recordAddress] = presaleGTX[_recordAddress].add(bonusGTX[_recordAddress]);\r\n        \r\n        totalClaimableGTX = totalClaimableGTX.add(claimableGTX[_recordAddress]);\r\n        require(totalClaimableGTX <= totalPresaleTokens, \"total token record (presale GTX + bonus GTX) cannot exceed presale token limit\");\r\n        emit GTXRecordUpdate(_recordAddress, claimableGTX[_recordAddress]);\r\n    }\r\n\r\n    /**\r\n    * @dev Used to move GTX records from one address to another, primarily in case a user has lost access to their originally registered account\r\n    * @param _oldAddress - the original registered address\r\n    * @param _newAddress - the new registerd address\r\n    */\r\n    function recordMove(address _oldAddress, address _newAddress) public onlyOwner atStage(Stages.Presale){\r\n        require(claimableGTX[_oldAddress] != 0, \"cannot move a zero record\");\r\n        require(claimableGTX[_newAddress] == 0, \"destination must not already have a claimable record\");\r\n\r\n        //Moving the Presale GTX\r\n        presaleGTX[_newAddress] = presaleGTX[_oldAddress];\r\n        presaleGTX[_oldAddress] = 0;\r\n\r\n        //Moving the Bonus GTX\r\n        bonusGTX[_newAddress] = bonusGTX[_oldAddress];\r\n        bonusGTX[_oldAddress] = 0;\r\n\r\n        //Moving the claimable GTX\r\n        claimableGTX[_newAddress] = claimableGTX[_oldAddress];\r\n        claimableGTX[_oldAddress] = 0;\r\n\r\n        emit GTXRecordMove(_oldAddress, _newAddress, claimableGTX[_newAddress]);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev calculates the bonus percentage based on the total number of GTX tokens\r\n     * @param _receiver is the registered address for which bonus is calculated\r\n     * @return returns the calculated bonus tokens\r\n    */\r\n    function calculateBonus(address _receiver) public view returns(uint256 bonus) {\r\n        uint256 gtxTokens = presaleGTX[_receiver];\r\n        for(uint256 i=0; i < bonusThreshold.length; i++) {\r\n            if(gtxTokens >= bonusThreshold[i]) {\r\n                bonus = (bonusPercent[i].mul(gtxTokens)).div(100);\r\n            }\r\n        }\r\n        return bonus;\r\n    }\r\n\r\n    /**\r\n    * @dev Used to retrieve the total GTX tokens for GTX claiming after the GTX ICO\r\n    * @return uint256 - Presale stage\r\n    */\r\n    function getStage() public view returns (uint256) {\r\n        return uint(stage);\r\n    }\r\n\r\n}\r\ncontract GTXAuction is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Setup(uint256 etherPrice, uint256 hardCap, uint256 ceiling, uint256 floor, uint256[] bonusThreshold, uint256[] bonusPercent);\r\n    event BidSubmission(address indexed sender, uint256 amount);\r\n    event ClaimedTokens(address indexed recipient, uint256 sentAmount);\r\n    event Collected(address collector, address multiSigAddress, uint256 amount);\r\n    event SetMultiSigAddress(address owner, address multiSigAddress);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    // GTX Contract objects required to allocate GTX Tokens and FIN converted GTX Tokens\r\n    GTXToken public ERC20;\r\n    GTXRecord public gtxRecord;\r\n    GTXPresale public gtxPresale;\r\n\r\n    // Auction specific uint256 Bid variables\r\n    uint256 public maxTokens; // the maximum number of tokens for distribution during the auction\r\n    uint256 public remainingCap; // Remaining amount in wei to reach the hardcap target\r\n    uint256 public totalReceived; // Keep track of total ETH in Wei received during the bidding phase\r\n    uint256 public maxTotalClaim; // a running total of the maximum possible tokens that can be claimed by bidder (including bonuses)\r\n    uint256 public totalAuctionTokens; // Total tokens for the accumulated bid amount and the bonus\r\n    uint256 public fundsClaimed;  // Keep track of cumulative ETH funds for which the tokens have been claimed\r\n\r\n    // Auction specific uint256 Time variables\r\n    uint256 public startBlock; // the number of the block when the auction bidding period was started\r\n    uint256 public biddingPeriod; // the number of blocks for the bidding period of the auction\r\n    uint256 public endBlock; // the last possible block of the bidding period\r\n    uint256 public waitingPeriod; // the number of days of the cooldown/audit period after the bidding phase has ended\r\n\r\n    // Auction specific uint256 Price variables\r\n    uint256 public etherPrice; // 2 decimal precision, e.g., $1.00 = 100\r\n    uint256 public ceiling; // entered as a paremeter in USD cents; calculated as the equivalent \"ceiling\" value in ETH - given the etherPrice\r\n    uint256 public floor; // entered as a paremeter in USD cents; calculated as the equivalent \"floor\" value in ETH - given the etherPrice\r\n    uint256 public hardCap; // entered as a paremeter in USD cents; calculated as the equivalent \"hardCap\" value in ETH - given the etherPrice\r\n    uint256 public priceConstant; // price calculation factor to generate the price curve per block\r\n    uint256 public finalPrice; // the final Bid Price achieved\r\n    uint256 constant public WEI_FACTOR = 10**18; // wei conversion factor\r\n    \r\n    //generic variables\r\n    uint256 public participants; \r\n    address public multiSigAddress; // a multisignature contract address to keep the auction funds\r\n\r\n    // Auction maps to calculate Bids and Bonuses\r\n    mapping (address => uint256) public bids; // total bids in wei per account\r\n    mapping (address => uint256) public bidTokens; // tokens calculated for the submitted bids\r\n    mapping (address => uint256) public totalTokens; // total tokens is the accumulated tokens of bidTokens, presaleTokens, gtxrecordTokens and bonusTokens\r\n    mapping (address => bool) public claimedStatus; // claimedStatus is the claimed status of the user\r\n\r\n    // Map of whitelisted address for participation in the Auction\r\n    mapping (address => bool) public whitelist;\r\n\r\n    // Auction arrays for bid amount based Bonus calculation\r\n    uint256[11] public bonusPercent; // 11 possible bonus percentages (with values 0 - 100 each)\r\n    uint256[11] public bonusThresholdWei; // 11 thresholds values to calculate bonus based on the bid amount in wei.\r\n\r\n    // Enums for Stages\r\n    Stages public stage;\r\n\r\n    /*\r\n     *  Enums\r\n     */\r\n    enum Stages {\r\n        AuctionDeployed,\r\n        AuctionSetUp,\r\n        AuctionStarted,\r\n        AuctionEnded,\r\n        ClaimingStarted,\r\n        ClaimingEnded\r\n    }\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier atStage(Stages _stage) {\r\n        require(stage == _stage, \"not the expected stage\");\r\n        _;\r\n    }\r\n\r\n    modifier timedTransitions() {\r\n        if (stage == Stages.AuctionStarted && block.number >= endBlock) {\r\n            finalizeAuction();\r\n            msg.sender.transfer(msg.value);\r\n            return;\r\n        }\r\n        if (stage == Stages.AuctionEnded && block.number >= endBlock.add(waitingPeriod)) {\r\n            stage = Stages.ClaimingStarted;\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhitelisted(address _participant) {\r\n        require(whitelist[_participant] == true, \"account is not white listed\");\r\n        _;\r\n    }\r\n\r\n    /// GTXAuction Contract Constructor\r\n    /// @dev Constructor sets the basic auction information\r\n    /// @param _gtxToken the GTX ERC20 token contract address\r\n    /// @param _gtxRecord the GTX Record contract address\r\n    /// @param _gtxPresale the GTX presale contract address\r\n    /// @param _biddingPeriod the number of blocks the bidding period of the auction will run - Initial decision of 524160 (~91 Days)\r\n    /// @param _waitingPeriod the waiting period post Auction End before claiming - Initial decision of 172800 (-30 days)\r\n\r\n\r\n    constructor (\r\n        GTXToken _gtxToken,\r\n        GTXRecord _gtxRecord,\r\n        GTXPresale _gtxPresale,\r\n        uint256 _biddingPeriod,\r\n        uint256 _waitingPeriod\r\n    )\r\n       public\r\n    {\r\n        require(_gtxToken != address(0), \"Must provide a Token address\");\r\n        require(_gtxRecord != address(0), \"Must provide a Record address\");\r\n        require(_gtxPresale != address(0), \"Must provide a PreSale address\");\r\n        require(_biddingPeriod > 0, \"The bidding period must be a minimum 1 block\");\r\n        require(_waitingPeriod > 0, \"The waiting period must be a minimum 1 block\");\r\n\r\n        ERC20 = _gtxToken;\r\n        gtxRecord = _gtxRecord;\r\n        gtxPresale = _gtxPresale;\r\n        waitingPeriod = _waitingPeriod;\r\n        biddingPeriod = _biddingPeriod;\r\n\r\n        uint256 gtxSwapTokens = gtxRecord.maxRecords();\r\n        uint256 gtxPresaleTokens = gtxPresale.totalPresaleTokens();\r\n        maxTotalClaim = maxTotalClaim.add(gtxSwapTokens).add(gtxPresaleTokens);\r\n\r\n        // Set the contract stage to Auction Deployed\r\n        stage = Stages.AuctionDeployed;\r\n    }\r\n\r\n    // fallback to revert ETH sent to this contract\r\n    function () public payable {\r\n        bid(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Safety function for reclaiming ERC20 tokens\r\n    * @param _token address of the ERC20 contract\r\n    */\r\n    function recoverTokens(ERC20Interface _token) external onlyOwner {\r\n        if(address(_token) == address(ERC20)) {\r\n            require(uint(stage) >= 3, \"auction bidding must be ended to recover\");\r\n            if(currentStage() == 3 || currentStage() == 4) {\r\n                _token.transfer(owner(), _token.balanceOf(address(this)).sub(maxTotalClaim));\r\n            } else {\r\n                _token.transfer(owner(), _token.balanceOf(address(this)));\r\n            }\r\n        } else {\r\n            _token.transfer(owner(), _token.balanceOf(address(this)));\r\n        }\r\n    }\r\n\r\n    ///  @dev Function to whitelist participants during the crowdsale\r\n    ///  @param _bidder_addresses Array of addresses to whitelist\r\n    function addToWhitelist(address[] _bidder_addresses) external onlyOwner {\r\n        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\r\n            if(_bidder_addresses[i] != address(0) && whitelist[_bidder_addresses[i]] == false){\r\n                whitelist[_bidder_addresses[i]] = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    ///  @dev Function to remove the whitelististed participants\r\n    ///  @param _bidder_addresses is an array of accounts to remove form the whitelist\r\n    function removeFromWhitelist(address[] _bidder_addresses) external onlyOwner {\r\n        for (uint32 i = 0; i < _bidder_addresses.length; i++) {\r\n            if(_bidder_addresses[i] != address(0) && whitelist[_bidder_addresses[i]] == true){\r\n                whitelist[_bidder_addresses[i]] = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Setup function sets eth pricing information and the floor and ceiling of the Dutch auction bid pricing\r\n    /// @param _maxTokens the maximum public allocation of tokens - Initial decision for 400 Million GTX Tokens to be allocated for ICO\r\n    /// @param _etherPrice for calculating Gallactic Auction price curve - Should be set 1 week before the auction starts, denominated in USD cents\r\n    /// @param _hardCap Gallactic Auction maximum accepted total contribution - Initial decision to be $100,000,000.00 or 10000000000 (USD cents)\r\n    /// @param _ceiling Gallactic Auction Price curve ceiling price - Initial decision to be 500 (USD cents)\r\n    /// @param _floor Gallactic Auction Price curve floor price - Initial decision to be 30 (USD cents)\r\n    /// @param _bonusThreshold is an array of thresholds for the bid amount to set the bonus% (thresholds entered in USD cents, converted to ETH equivalent based on ETH price)\r\n    /// @param _bonusPercent is an array of bonus% based on the threshold of bid\r\n\r\n    function setup(\r\n        uint256 _maxTokens,\r\n        uint256 _etherPrice,\r\n        uint256 _hardCap,\r\n        uint256 _ceiling,\r\n        uint256 _floor,\r\n        uint256[] _bonusThreshold,\r\n        uint256[] _bonusPercent\r\n    )\r\n        external\r\n        onlyOwner\r\n        atStage(Stages.AuctionDeployed)\r\n        returns (bool)\r\n    {\r\n        require(_maxTokens > 0,\"Max Tokens should be > 0\");\r\n        require(_etherPrice > 0,\"Ether price should be > 0\");\r\n        require(_hardCap > 0,\"Hard Cap should be > 0\");\r\n        require(_floor < _ceiling,\"Floor must be strictly less than the ceiling\");\r\n        require(_bonusPercent.length == 11 && _bonusThreshold.length == 11, \"Length of bonus percent array and bonus threshold should be 11\");\r\n\r\n        maxTokens = _maxTokens;\r\n        etherPrice = _etherPrice;\r\n\r\n        // Allocate Crowdsale token amounts (Permissible only to this GTXAuction Contract)\r\n        // Address needs to be set in GTXToken before Auction Setup)\r\n        ERC20.passAuctionAllocation(maxTokens);\r\n\r\n        // Validate allocation amount\r\n        require(ERC20.balanceOf(address(this)) == ERC20.getAuctionAllocation(), \"Incorrect balance assigned by auction allocation\");\r\n\r\n        // ceiling, floor, hardcap and bonusThreshholds in Wei and priceConstant setting\r\n        ceiling = _ceiling.mul(WEI_FACTOR).div(_etherPrice); // result in WEI\r\n        floor = _floor.mul(WEI_FACTOR).div(_etherPrice); // result in WEI\r\n        hardCap = _hardCap.mul(WEI_FACTOR).div(_etherPrice); // result in WEI\r\n        for (uint32 i = 0; i<_bonusPercent.length; i++) {\r\n            bonusPercent[i] = _bonusPercent[i];\r\n            bonusThresholdWei[i] = _bonusThreshold[i].mul(WEI_FACTOR).div(_etherPrice);\r\n        }\r\n        remainingCap = hardCap.sub(remainingCap);\r\n        // used for the bidding price curve\r\n        priceConstant = (biddingPeriod**3).div((biddingPeriod.add(1).mul(ceiling).div(floor)).sub(biddingPeriod.add(1)));\r\n\r\n        // Initializing Auction Setup Stage\r\n        stage = Stages.AuctionSetUp;\r\n        emit Setup(_etherPrice,_hardCap,_ceiling,_floor,_bonusThreshold,_bonusPercent);\r\n    }\r\n\r\n    /// @dev Changes auction price curve variables before auction is started.\r\n    /// @param _etherPrice New Ether Price in Cents.\r\n    /// @param _hardCap New hardcap amount in Cents.\r\n    /// @param _ceiling New auction ceiling price in Cents.\r\n    /// @param _floor New auction floor price in Cents.\r\n    /// @param _bonusThreshold is an array of thresholds for the bid amount to set the bonus%\r\n    /// @param _bonusPercent is an array of bonus% based on the threshold of bid\r\n\r\n    function changeSettings(\r\n        uint256 _etherPrice,\r\n        uint256 _hardCap,\r\n        uint256 _ceiling,\r\n        uint256 _floor,\r\n        uint256[] _bonusThreshold,\r\n        uint256[] _bonusPercent\r\n    )\r\n        external\r\n        onlyOwner\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        require(_etherPrice > 0,\"Ether price should be > 0\");\r\n        require(_hardCap > 0,\"Hard Cap should be > 0\");\r\n        require(_floor < _ceiling,\"floor must be strictly less than the ceiling\");\r\n        require(_bonusPercent.length == _bonusThreshold.length, \"Length of bonus percent array and bonus threshold should be equal\");\r\n        etherPrice = _etherPrice;\r\n        ceiling = _ceiling.mul(WEI_FACTOR).div(_etherPrice); // recalculate ceiling, result in WEI\r\n        floor = _floor.mul(WEI_FACTOR).div(_etherPrice); // recalculate floor, result in WEI\r\n        hardCap = _hardCap.mul(WEI_FACTOR).div(_etherPrice); // recalculate hardCap, result in WEI\r\n        for (uint i = 0 ; i<_bonusPercent.length; i++) {\r\n            bonusPercent[i] = _bonusPercent[i];\r\n            bonusThresholdWei[i] = _bonusThreshold[i].mul(WEI_FACTOR).div(_etherPrice);\r\n        }\r\n        remainingCap = hardCap.sub(remainingCap);\r\n        // recalculate price constant\r\n        priceConstant = (biddingPeriod**3).div((biddingPeriod.add(1).mul(ceiling).div(floor)).sub(biddingPeriod.add(1)));\r\n        emit Setup(_etherPrice,_hardCap,_ceiling,_floor,_bonusThreshold,_bonusPercent);\r\n    }\r\n\r\n    /// @dev Starts auction and sets startBlock and endBlock.\r\n    function startAuction()\r\n        public\r\n        onlyOwner\r\n        atStage(Stages.AuctionSetUp)\r\n    {\r\n        // set the stage to Auction Started and bonus stage to First Stage\r\n        stage = Stages.AuctionStarted;\r\n        startBlock = block.number;\r\n        endBlock = startBlock.add(biddingPeriod);\r\n    }\r\n\r\n    /// @dev Implements a moratorium on claiming so that company can eventually recover all remaining tokens (in case of lost accounts who can/will never claim) - any remaining claims must contact the company directly\r\n    function endClaim()\r\n        public\r\n        onlyOwner\r\n        atStage(Stages.ClaimingStarted)\r\n    {\r\n        require(block.number >= endBlock.add(biddingPeriod), \"Owner can end claim only after 3 months\");   //Owner can force end the claim only after 3 months. This is to protect the owner from ending the claim before users could claim\r\n        // set the stage to Claiming Ended\r\n        stage = Stages.ClaimingEnded;\r\n    }\r\n\r\n    /// @dev setup multisignature address to keep the funds safe\r\n    /// @param _multiSigAddress is the multisignature contract address\r\n    /// @return true if the address was set successfully  \r\n    function setMultiSigAddress(address _multiSigAddress) external onlyOwner returns(bool){\r\n        require(_multiSigAddress != address(0), \"not a valid multisignature address\");\r\n        multiSigAddress = _multiSigAddress;\r\n        emit SetMultiSigAddress(msg.sender,multiSigAddress);\r\n        return true;\r\n    }\r\n\r\n    // Owner can collect ETH any number of times\r\n    function collect() external onlyOwner returns (bool) {\r\n        require(multiSigAddress != address(0), \"multisignature address is not set\");\r\n        multiSigAddress.transfer(address(this).balance);\r\n        emit Collected(msg.sender, multiSigAddress, address(this).balance);\r\n        return true;\r\n    }\r\n\r\n    /// @dev Allows to send a bid to the auction.\r\n    /// @param _receiver Bid will be assigned to this address if set.\r\n    function bid(address _receiver)\r\n        public\r\n        payable\r\n        timedTransitions\r\n        atStage(Stages.AuctionStarted)\r\n    {\r\n        require(msg.value > 0, \"bid must be larger than 0\");\r\n        require(block.number <= endBlock ,\"Auction has ended\");\r\n        if (_receiver == 0x0) {\r\n            _receiver = msg.sender;\r\n        }\r\n        assert(bids[_receiver].add(msg.value) >= msg.value);\r\n\r\n        uint256 maxWei = hardCap.sub(totalReceived); // remaining accetable funds without the current bid value\r\n        require(msg.value <= maxWei, \"Hardcap limit will be exceeded\");\r\n        participants = participants.add(1);\r\n        bids[_receiver] = bids[_receiver].add(msg.value);\r\n\r\n        uint256 maxAcctClaim = bids[_receiver].mul(WEI_FACTOR).div(calcTokenPrice(endBlock)); // max claimable tokens given bids total amount\r\n        maxAcctClaim = maxAcctClaim.add(bonusPercent[10].mul(maxAcctClaim).div(100)); // max claimable tokens (including bonus)\r\n        maxTotalClaim = maxTotalClaim.add(maxAcctClaim); // running total of max claim liability\r\n\r\n        totalReceived = totalReceived.add(msg.value);\r\n\r\n        remainingCap = hardCap.sub(totalReceived);\r\n        if(remainingCap == 0){\r\n            finalizeAuction(); // When maxWei is equal to the hardcap the auction will end and finalizeAuction is triggered.\r\n        }\r\n        assert(totalReceived >= msg.value);\r\n        emit BidSubmission(_receiver, msg.value);\r\n    }\r\n\r\n    /// @dev Claims tokens for bidder after auction.\r\n    function claimTokens()\r\n        public\r\n        timedTransitions\r\n        onlyWhitelisted(msg.sender)\r\n        atStage(Stages.ClaimingStarted)\r\n    {\r\n        require(!claimedStatus[msg.sender], \"User already claimed\");\r\n        // validate that GTXRecord contract has been locked - set to true\r\n        require(gtxRecord.lockRecords(), \"gtx records record updating must be locked\");\r\n        // validate that GTXPresale contract has been locked - set to true\r\n        require(gtxPresale.lockRecords(), \"presale record updating must be locked\");\r\n\r\n        // Update the total amount of ETH funds for which tokens have been claimed\r\n        fundsClaimed = fundsClaimed.add(bids[msg.sender]);\r\n\r\n        //total tokens accumulated for an user\r\n        uint256 accumulatedTokens = calculateTokens(msg.sender);\r\n\r\n        // Set receiver bid to 0 before assigning tokens\r\n        bids[msg.sender] = 0;\r\n        totalTokens[msg.sender] = 0;\r\n\r\n        claimedStatus[msg.sender] = true;\r\n        require(ERC20.transfer(msg.sender, accumulatedTokens), \"transfer failed\");\r\n\r\n        emit ClaimedTokens(msg.sender, accumulatedTokens);\r\n        assert(bids[msg.sender] == 0);\r\n    }\r\n\r\n    /// @dev calculateTokens calculates the sum of GTXRecord Tokens, Presale Tokens, BidTokens and Bonus Tokens\r\n    /// @param _receiver is the address of the receiver to calculate the tokens.\r\n    function calculateTokens(address _receiver) private returns(uint256){\r\n        // Check for GTX Record Tokens\r\n        uint256 gtxRecordTokens = gtxRecord.claimableGTX(_receiver);\r\n\r\n        // Check for Presale Record Tokens\r\n        uint256 gtxPresaleTokens = gtxPresale.claimableGTX(_receiver);\r\n\r\n        //Calculate the total bid tokens\r\n        bidTokens[_receiver] = bids[_receiver].mul(WEI_FACTOR).div(finalPrice);\r\n\r\n        //Calculate the total bonus tokens for the bids\r\n        uint256 bonusTokens = calculateBonus(_receiver);\r\n\r\n        uint256 auctionTokens = bidTokens[_receiver].add(bonusTokens);\r\n\r\n        totalAuctionTokens = totalAuctionTokens.add(auctionTokens);\r\n\r\n        //Sum all the tokens accumulated\r\n        totalTokens[msg.sender] = gtxRecordTokens.add(gtxPresaleTokens).add(auctionTokens);\r\n        return totalTokens[msg.sender];\r\n    }\r\n\r\n    /// @dev Finalize the Auction and set the final token price\r\n    /// no more bids allowed\r\n    function finalizeAuction()\r\n        private\r\n    {\r\n        // remainingFunds should be 0 at this point\r\n        require(remainingCap == 0 || block.number >= endBlock, \"cap or block condition not met\");\r\n\r\n        stage = Stages.AuctionEnded;\r\n        if (block.number < endBlock){\r\n            finalPrice = calcTokenPrice(block.number);\r\n            endBlock = block.number;\r\n        } else {\r\n            finalPrice = calcTokenPrice(endBlock);\r\n        }\r\n    }\r\n\r\n    /// @dev calculates the bonus for the total bids\r\n    /// @param _receiver is the address of the bidder to calculate the bonus\r\n    /// @return returns the calculated bonus tokens\r\n    function calculateBonus(address _receiver) private view returns(uint256 bonusTokens){\r\n        for (uint256 i=0; i < bonusThresholdWei.length; i++) {\r\n            if(bids[_receiver] >= bonusThresholdWei[i]){\r\n                bonusTokens = bonusPercent[i].mul(bidTokens[_receiver]).div(100); // bonusAmount is calculated in wei\r\n            }\r\n        }\r\n        return bonusTokens;\r\n    }\r\n\r\n    // public getters\r\n    /// @dev Calculates the token price (WEI per GTX) at the given block number\r\n    /// @param _bidBlock is the block number\r\n    /// @return Returns the token price - Wei per GTX\r\n    function calcTokenPrice(uint256 _bidBlock) public view returns(uint256){\r\n\r\n        require(_bidBlock >= startBlock && _bidBlock <= endBlock, \"pricing only given in the range of startBlock and endBlock\");\r\n\r\n        uint256 currentBlock = _bidBlock.sub(startBlock);\r\n        uint256 decay = (currentBlock ** 3).div(priceConstant);\r\n        return ceiling.mul(currentBlock.add(1)).div(currentBlock.add(decay).add(1));\r\n    }\r\n\r\n    /// @dev Returns correct stage, even if a function with a timedTransitions modifier has not been called yet\r\n    /// @return Returns current auction stage.\r\n    function currentStage()\r\n        public\r\n        view\r\n        returns (uint)\r\n    {\r\n        return uint(stage);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_multiSigAddress\",\"type\":\"address\"}],\"name\":\"setMultiSigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiSigAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WEI_FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waitingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"floor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"priceConstant\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidder_addresses\",\"type\":\"address[]\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAuctionTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_maxTokens\",\"type\":\"uint256\"},{\"name\":\"_etherPrice\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"name\":\"_ceiling\",\"type\":\"uint256\"},{\"name\":\"_floor\",\"type\":\"uint256\"},{\"name\":\"_bonusThreshold\",\"type\":\"uint256[]\"},{\"name\":\"_bonusPercent\",\"type\":\"uint256[]\"}],\"name\":\"setup\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundsClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"biddingPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gtxRecord\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceiling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusThresholdWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bidder_addresses\",\"type\":\"address[]\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTotalClaim\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endClaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bidTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_bidBlock\",\"type\":\"uint256\"}],\"name\":\"calcTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gtxPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"collect\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherPrice\",\"type\":\"uint256\"},{\"name\":\"_hardCap\",\"type\":\"uint256\"},{\"name\":\"_ceiling\",\"type\":\"uint256\"},{\"name\":\"_floor\",\"type\":\"uint256\"},{\"name\":\"_bonusThreshold\",\"type\":\"uint256[]\"},{\"name\":\"_bonusPercent\",\"type\":\"uint256[]\"}],\"name\":\"changeSettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"claimedStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_gtxToken\",\"type\":\"address\"},{\"name\":\"_gtxRecord\",\"type\":\"address\"},{\"name\":\"_gtxPresale\",\"type\":\"address\"},{\"name\":\"_biddingPeriod\",\"type\":\"uint256\"},{\"name\":\"_waitingPeriod\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"etherPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ceiling\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"floor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusThreshold\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"bonusPercent\",\"type\":\"uint256[]\"}],\"name\":\"Setup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"BidSubmission\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"sentAmount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"collector\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"multiSigAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Collected\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"multiSigAddress\",\"type\":\"address\"}],\"name\":\"SetMultiSigAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"GTXAuction","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000058e0419ab0bcc7844069fab2cef414f1a56769e700000000000000000000000032b74fa63490790f6f66bc154793fcd18fc22f4a00000000000000000000000037cd9c5a1666f206754fc72ec5b8e5f020008474000000000000000000000000000000000000000000000000000000000007f968000000000000000000000000000000000000000000000000000000000002a300","Library":"","SwarmSource":"bzzr://295c1567bcf385978d2d722babbbc5f662124a47c7281a1ff8f778aebd9f2279"}]}