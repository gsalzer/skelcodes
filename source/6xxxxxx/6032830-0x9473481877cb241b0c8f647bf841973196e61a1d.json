{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract Prop {\r\n    function noFeeTransfer(address _to, uint256 _value) public returns (bool);\r\n    function mintTokens(address _atAddress, uint256 _amount) public;\r\n\r\n}\r\n\r\ncontract BST {\r\n    function balanceOf(address _owner) public constant returns (uint256 _balance);\r\n}\r\n\r\ncontract FirstBuyers is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    /* Modifiers */\r\n    modifier onlyFirstBuyer() {\r\n        require(firstBuyers[msg.sender].tokensReceived > 0);\r\n        _;\r\n    }\r\n\r\n    /* Struct */\r\n    struct FirstBuyer {\r\n        uint256 lastTransactionIndex;\r\n        uint256 tokensReceived;\r\n        uint256 weightedContribution;\r\n    }\r\n\r\n    /* Mappings */\r\n    mapping(address => FirstBuyer) firstBuyers;\r\n    mapping(uint256 => uint256) transactions;\r\n    mapping(uint256 => address) firstBuyerIndex;\r\n\r\n    /* Private variables */\r\n    uint256 numOfTransaction;\r\n    uint256 numOfFirstBuyers = 0;\r\n    uint256 totalWeightedContribution;\r\n    Prop property;\r\n    BST bst;\r\n\r\n    event FirstBuyerWhitdraw(address indexed _firstBuyer, uint256 _amount);\r\n    event NewTransactionOfTokens(uint256 _amount, uint256 _index);\r\n\r\n    /**\r\n    * @dev constructor function, creates new FirstBuyers\r\n    * @param _property Address of property\r\n    * @param _owner Owner of this ICO\r\n    **/\r\n    constructor(address _property,  address _owner) public {\r\n        property = Prop(_property);\r\n        owner = _owner;\r\n        bst = BST(0x509A38b7a1cC0dcd83Aa9d06214663D9eC7c7F4a);\r\n    }\r\n\r\n    /**\r\n    * @dev add first buyers\r\n    * @param _addresses Array of first buyer addresses\r\n    * @param _amount Array of first buyer tokens\r\n    **/\r\n    function addFirstBuyers(address[] _addresses, uint256[] _amount) public onlyOwner {\r\n        require(_addresses.length == _amount.length);\r\n        for(uint256 i = 0; i < _addresses.length; i++) {\r\n            uint256 weightedContribution = (bst.balanceOf(_addresses[i]).mul(_amount[i])).div(10**18);\r\n\r\n            FirstBuyer storage buyer = firstBuyers[_addresses[i]];\r\n            uint256 before = buyer.tokensReceived;\r\n            buyer.tokensReceived = buyer.tokensReceived.add(_amount[i]);\r\n            buyer.weightedContribution = buyer.weightedContribution.add(weightedContribution);\r\n\r\n            property.mintTokens(_addresses[i], _amount[i]);\r\n            firstBuyers[_addresses[i]] = buyer;\r\n\r\n            totalWeightedContribution = totalWeightedContribution.add(weightedContribution);\r\n            if(before == 0) {\r\n                firstBuyerIndex[numOfFirstBuyers] = _addresses[i];\r\n                numOfFirstBuyers++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev allows First buyers to collect fee from transactions\r\n    **/\r\n    function withdrawTokens() public onlyFirstBuyer {\r\n        FirstBuyer storage buyer = firstBuyers[msg.sender];\r\n        require(numOfTransaction >= buyer.lastTransactionIndex);\r\n        uint256 iterateOver = numOfTransaction.sub(buyer.lastTransactionIndex);\r\n        if (iterateOver > 30) {\r\n            iterateOver = 30;\r\n        }\r\n        uint256 iterate = buyer.lastTransactionIndex.add(iterateOver);\r\n        uint256 amount = 0;\r\n        for (uint256 i = buyer.lastTransactionIndex; i < iterate; i++) {\r\n            uint256 ratio = ((buyer.weightedContribution.mul(10**14)).div(totalWeightedContribution));\r\n            amount = amount.add((transactions[buyer.lastTransactionIndex].mul(ratio)).div(10**14));\r\n            buyer.lastTransactionIndex = buyer.lastTransactionIndex.add(1);\r\n        }\r\n        assert(property.noFeeTransfer(msg.sender, amount));\r\n        emit FirstBuyerWhitdraw(msg.sender, amount);\r\n    }\r\n\r\n    /**\r\n    * @dev save every transaction that BSPT sends\r\n    * @param _amount Amount of tokens taken as fee\r\n    **/\r\n    function incomingTransaction(uint256 _amount) public {\r\n        require(msg.sender == address(property));\r\n        transactions[numOfTransaction] = _amount;\r\n        numOfTransaction += 1;\r\n        emit NewTransactionOfTokens(_amount, numOfTransaction);\r\n    }\r\n\r\n    /**\r\n    * @dev get transaction index of last transaction that First buyer claimed\r\n    * @param _firstBuyer First buyer address\r\n    * @return Return transaction index\r\n    **/\r\n    function getFirstBuyer(address _firstBuyer) constant public returns (uint256, uint256, uint256) {\r\n        return (firstBuyers[_firstBuyer].lastTransactionIndex,firstBuyers[_firstBuyer].tokensReceived,firstBuyers[_firstBuyer].weightedContribution);\r\n    }\r\n\r\n    /**\r\n    * @dev get number of first buyers\r\n    * @return Number of first buyers\r\n    **/\r\n    function getNumberOfFirstBuyer() constant public returns(uint256) {\r\n        return numOfFirstBuyers;\r\n    }\r\n\r\n    /**\r\n    * @dev get address of first buyer by index\r\n    * @param _index Index of first buyer\r\n    * @return Address of first buyer\r\n    **/\r\n    function getFirstBuyerAddress(uint256 _index) constant public returns(address) {\r\n        return firstBuyerIndex[_index];\r\n    }\r\n\r\n    /**\r\n    * @dev get total number of transactions\r\n    * @return Total number of transactions that came in\r\n    **/\r\n    function getNumberOfTransactions() constant public returns(uint256) {\r\n        return numOfTransaction;\r\n    }\r\n\r\n    /**\r\n    * @dev get total weighted contribution\r\n    * @return Total sum of all weighted contribution\r\n    **/\r\n    function getTotalWeightedContribution() constant public returns(uint256) {\r\n        return totalWeightedContribution;\r\n    }\r\n\r\n    /**\r\n    * @dev fallback function to prevent any ether to be sent to this contract\r\n    **/\r\n    function () public payable {\r\n        revert();\r\n    }\r\n}\r\n\r\n\r\n/*****************************/\r\n/*   STANDARD ERC20 TOKEN    */\r\n/*****************************/\r\n\r\ncontract ERC20Token {\r\n\r\n    /** Functions needed to be implemented by ERC20 standard **/\r\n    function totalSupply() public constant returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) public constant returns (uint256 _balance);\r\n    function transfer(address _to, uint256 _amount) public returns (bool _success);\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool _success);\r\n    function approve(address _spender, uint256 _amount) public returns (bool _success);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 _remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _amount);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n}\r\n\r\ncontract Data {\r\n    function canMakeNoFeeTransfer(address _from, address _to) constant public returns(bool);\r\n    function getNetworkFee() public constant returns (uint256);\r\n    function getBlocksquareFee() public constant returns (uint256);\r\n    function getCPFee() public constant returns (uint256);\r\n    function getFirstBuyersFee() public constant returns (uint256);\r\n    function hasPrestige(address _owner) public constant returns(bool);\r\n}\r\n\r\n/*****************/\r\n/*   PROPERTY    */\r\n/*****************/\r\n\r\ncontract PropToken is ERC20Token, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Prop {\r\n        string primaryPropertyType;\r\n        string secondaryPropertyType;\r\n        uint64 cadastralMunicipality;\r\n        uint64 parcelNumber;\r\n        uint64 id;\r\n    }\r\n\r\n\r\n    /* Info about property */\r\n    string mapURL = \"https://www.google.com/maps/place/Tehnolo%C5%A1ki+park+Ljubljana+d.o.o./@46.0491873,14.458252,17z/data=!3m1!4b1!4m5!3m4!1s0x477ad2b1cdee0541:0x8e60f36e738253f0!8m2!3d46.0491873!4d14.4604407\";\r\n    string public name = \"PropToken BETA 000000000001\"; // Name of property\r\n    string public symbol = \"BSPT-BETA-000000000001\"; // Symbol for property\r\n    uint8 public decimals = 18; // Decimals\r\n    uint8 public numOfProperties;\r\n\r\n    bool public tokenFrozen; // Can property be transfered\r\n\r\n    /* Fee-recievers */\r\n    FirstBuyers public firstBuyers; //FirstBuyers\r\n    address public networkReserveFund; // Address of Reserve funds\r\n    address public blocksquare; // Address of Blocksquare\r\n    address public certifiedPartner; // Address of partner who is selling property\r\n\r\n    /* Private variables */\r\n    uint256 supply; //Current supply, at end total supply\r\n    uint256 MAXSUPPLY = 100000 * 10 ** 18; // Total supply\r\n    uint256 feePercent;\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowances;\r\n\r\n    Data data;\r\n\r\n    Prop[] properties;\r\n\r\n    /* Events */\r\n    event TokenFrozen(bool _frozen, string _reason);\r\n    event Mint(address indexed _to, uint256 _value);\r\n\r\n    /**\r\n    * @dev constructor\r\n    **/\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        tokenFrozen = true;\r\n        feePercent = 2;\r\n        networkReserveFund = address(0x7E8f1b7655fc05e48462082E5A12e53DBc33464a);\r\n        blocksquare = address(0x84F4CE7a40238062edFe3CD552cacA656d862f27);\r\n        certifiedPartner = address(0x3706E1CdB3254a1601098baE8D1A8312Cf92f282);\r\n        firstBuyers = new FirstBuyers(this, owner);\r\n    }\r\n\r\n    /**\r\n    * @dev add new property under this BSPT\r\n    * @param _primaryPropertyType Primary type of property\r\n    * @param _secondaryPropertyType Secondary type of property\r\n    * @param _cadastralMunicipality Cadastral municipality\r\n    * @param _parcelNumber Parcel number\r\n    * @param _id Id of property\r\n    **/\r\n    function addProperty(string _primaryPropertyType, string _secondaryPropertyType, uint64 _cadastralMunicipality, uint64 _parcelNumber, uint64 _id) public onlyOwner {\r\n        properties.push(Prop(_primaryPropertyType, _secondaryPropertyType, _cadastralMunicipality, _parcelNumber, _id));\r\n        numOfProperties++;\r\n    }\r\n\r\n    /**\r\n    * @dev set data factory\r\n    * @param _data Address of data factory\r\n    **/\r\n    function setDataFactory(address _data) public onlyOwner {\r\n        data = Data(_data);\r\n    }\r\n\r\n    /**\r\n    * @dev send tokens without fee\r\n    * @param _from Address of sender.\r\n    * @param _to Address of recipient.\r\n    * @param _amount Amount to send.\r\n    * @return Whether the transfer was successful or not.\r\n    **/\r\n    function noFee(address _from, address _to, uint256 _amount) private returns (bool) {\r\n        require(!tokenFrozen);\r\n        require(balances[_from] >= _amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev allows first buyers contract to transfer BSPT without fee\r\n    * @param _to Where to send BSPT\r\n    * @param _amount Amount of BSPT to send\r\n    * @return True if transfer was successful, false instead\r\n    **/\r\n    function noFeeTransfer(address _to, uint256 _amount) public returns (bool) {\r\n        require(msg.sender == address(firstBuyers));\r\n        return noFee(msg.sender, _to, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev calculate and distribute fee for fee-recievers\r\n    * @param _fee Fee amount\r\n    **/\r\n    function distributeFee(uint256 _fee) private {\r\n        balances[networkReserveFund] = balances[networkReserveFund].add((_fee.mul(data.getNetworkFee())).div(100));\r\n        balances[blocksquare] = balances[blocksquare].add((_fee.mul(data.getBlocksquareFee())).div(100));\r\n        balances[certifiedPartner] = balances[certifiedPartner].add((_fee.mul(data.getCPFee())).div(100));\r\n        balances[address(firstBuyers)] = balances[address(firstBuyers)].add((_fee.mul(data.getFirstBuyersFee())).div(100));\r\n        firstBuyers.incomingTransaction((_fee.mul(data.getFirstBuyersFee())).div(100));\r\n    }\r\n\r\n    /**\r\n    * @dev send tokens\r\n    * @param _from Address of sender.\r\n    * @param _to Address of recipient.\r\n    * @param _amount Amount to send.\r\n    **/\r\n    function _transfer(address _from, address _to, uint256 _amount) private {\r\n        require(_to != 0x0);\r\n        require(_to != address(this));\r\n        require(balances[_from] >= _amount);\r\n        uint256 fee = (_amount.mul(feePercent)).div(100);\r\n        distributeFee(fee);\r\n        balances[_to] = balances[_to].add(_amount.sub(fee));\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        emit Transfer(_from, _to, _amount.sub(fee));\r\n    }\r\n\r\n    /**\r\n    * @dev send tokens from your address.\r\n    * @param _to Address of recipient.\r\n    * @param _amount Amount to send.\r\n    * @return Whether the transfer was successful or not.\r\n    **/\r\n    function transfer(address _to, uint256 _amount) public returns (bool) {\r\n        require(!tokenFrozen);\r\n        if (data.canMakeNoFeeTransfer(msg.sender, _to) || data.hasPrestige(msg.sender)) {\r\n            noFee(msg.sender, _to, _amount);\r\n        }\r\n        else {\r\n            _transfer(msg.sender, _to, _amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev set allowance for someone to spend tokens from your address\r\n    * @param _spender Address of spender.\r\n    * @param _amount Max amount allowed to spend.\r\n    * @return Whether the approve was successful or not.\r\n    **/\r\n    function approve(address _spender, uint256 _amount) public returns (bool) {\r\n        allowances[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev send tokens\r\n    * @param _from Address of sender.\r\n    * @param _to Address of recipient.\r\n    * @param _amount Amount of token to send.\r\n    * @return Whether the transfer was successful or not.\r\n    **/\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns (bool) {\r\n        require(_amount <= allowances[_from][msg.sender]);\r\n        require(!tokenFrozen);\r\n        _transfer(_from, _to, _amount);\r\n        allowances[_from][msg.sender] = allowances[_from][msg.sender].sub(_amount);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev mint tokens, can only be done by first buyers contract\r\n    * @param _atAddress Adds tokens to address\r\n    * @param _amount Amount of tokens to add\r\n    **/\r\n    function mintTokens(address _atAddress, uint256 _amount) public {\r\n        require(msg.sender == address(firstBuyers));\r\n        require(balances[_atAddress].add(_amount) > balances[_atAddress]);\r\n        require((supply.add(_amount)) <= MAXSUPPLY);\r\n        supply = supply.add(_amount);\r\n        balances[_atAddress] = balances[_atAddress].add(_amount);\r\n        emit Mint(_atAddress, _amount);\r\n        emit Transfer(0x0, _atAddress, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev changes status of frozen\r\n    * @param _reason Reason for freezing or unfreezing token\r\n    **/\r\n    function changeFreezeTransaction(string _reason) public onlyOwner {\r\n        tokenFrozen = !tokenFrozen;\r\n        emit TokenFrozen(tokenFrozen, _reason);\r\n    }\r\n\r\n    /**\r\n    * @dev change fee percent\r\n    * @param _fee New fee percent\r\n    **/\r\n    function changeFee(uint256 _fee) public onlyOwner {\r\n        feePercent = _fee;\r\n    }\r\n\r\n    /**\r\n    * @dev get allowance\r\n    * @param _owner Owner address\r\n    * @param _spender Spender address\r\n    * @return Return amount allowed to spend from '_owner' by '_spender'\r\n    **/\r\n    function allowance(address _owner, address _spender) public constant returns (uint256) {\r\n        return allowances[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev total amount of token\r\n    * @return Total amount of token\r\n    **/\r\n    function totalSupply() public constant returns (uint256) {\r\n        return supply;\r\n    }\r\n\r\n    /**\r\n    * @dev check balance of address\r\n    * @param _owner Address\r\n    * @return Amount of token in possession\r\n    **/\r\n    function balanceOf(address _owner) public constant returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev get information about property\r\n    * @param _index Index of property\r\n    * @return Primary type, secondary type, cadastral municipality, parcel number and id of property\r\n    **/\r\n    function getPropertyInfo(uint8 _index) public constant returns (string, string, uint64, uint64, uint64) {\r\n        return (properties[_index].primaryPropertyType, properties[_index].secondaryPropertyType, properties[_index].cadastralMunicipality, properties[_index].parcelNumber, properties[_index].id);\r\n    }\r\n\r\n    /**\r\n    * @dev get google maps url of property location\r\n    **/\r\n    function getMap() public constant returns (string) {\r\n        return mapURL;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_data\",\"type\":\"address\"}],\"name\":\"setDataFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfProperties\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"changeFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"changeFreezeTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksquare\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"noFeeTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint8\"}],\"name\":\"getPropertyInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMap\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"networkReserveFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstBuyers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"certifiedPartner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_atAddress\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_primaryPropertyType\",\"type\":\"string\"},{\"name\":\"_secondaryPropertyType\",\"type\":\"string\"},{\"name\":\"_cadastralMunicipality\",\"type\":\"uint64\"},{\"name\":\"_parcelNumber\",\"type\":\"uint64\"},{\"name\":\"_id\",\"type\":\"uint64\"}],\"name\":\"addProperty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_frozen\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"TokenFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"PropToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3d02821c897eb07ce6376d82f95dfdc5f91cfe22a9cbadf998ed55269b2cba64"}]}