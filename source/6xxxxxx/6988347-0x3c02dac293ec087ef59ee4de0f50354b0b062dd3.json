{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n* \r\n* T R U T H   S T A K I N G\r\n*\r\n* www.truthstaking.com\r\n*\r\n* Stake Ether on claims made by the media. If your peers agree with you, you win.\r\n* This smart contract allows users to do 2 things:\r\n* 1) Submit statements that are TRUE or FALSE.\r\n* 2) Stake on submitted statements.\r\n* After the staking period for the statement ends, the TRUE and FALSE pots of ether are counted. \r\n* The larger pot wins, and the smaller pot is distributed amongst the winners, proportional to the size of their stakes.\r\n* The \"market maker\" (the address that submitted the statement) receives an extra reward proportional to her first stake.\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    /**\r\n    * @dev Returns the largest of two numbers.\r\n    */\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the smallest of two numbers.\r\n    */\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the average of two numbers. Since these are integers,\r\n    * averages of an even and odd number cannot be represented, and will be\r\n    * rounded down.\r\n    */\r\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // (a + b) / 2 can overflow, so we distribute\r\n        return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n    }\r\n}\r\n\r\ncontract TruthStaking {\r\n\r\n\tusing SafeMath for uint;\r\n\r\n\t////////////////////// STRUCTS //////////////////////\r\n\r\n\tstruct Statement {\r\n\t\tuint id;\r\n\t\tstring statement;\r\n\t\tuint stakeDuration;\r\n\t\tuint stakeBeginningTime;\r\n\t\tuint stakeEndTime;\r\n\t\taddress marketMaker;\r\n\t\tuint numStakes;\r\n\t\tuint ethStaked;\r\n\t\tbool stakeEnded;\r\n\t\tstring source;\r\n\t\tuint verdict;\r\n\t\tmapping(uint => Stake) stakes; // TODO: Make private?\r\n\t}\r\n\r\n\tstruct Stake {\r\n\t\taddress addr; // Staker's address\r\n\t\tuint amount; // Value staked\r\n\t\tuint position; // Staker's position (1 true or 0 false)\r\n\t}\r\n\r\n\tstruct Pot {\r\n\t\tuint T;\r\n\t\tuint F;\r\n\t}\r\n\r\n\t////////////////////// MAPPINGS AND ARRAYS //////////////////////\r\n\r\n\tmapping(uint => Statement) public statements;\r\n\tmapping(uint => Pot) private pots;\r\n\tmapping(address => uint) public beneficiaryShares;\r\n\r\n\taddress[] public beneficiaryAddresses;\r\n\r\n\t////////////////////// STATE VARIABLES //////////////////////\r\n\r\n\t// Information Trackers\r\n\tuint public absNumStatements;\r\n\tuint public absNumStakes;\r\n\tuint public absEthStaked;\r\n\r\n\t// Logistics\r\n\tuint pctTimeRemainingThreshold;\r\n\r\n\tuint minTimeAddPct;\r\n\tuint maxTimeAddPct;\r\n\r\n\tuint minPotPctThreshold;\r\n\tuint maxPotPctThreshold;\r\n\r\n\taddress private owner;\r\n\tuint public serviceFeeTenThousandths; // int range [0, 10000] to accomodate precision of ten-thosaundths. eg. 1.25% is represented as 125\r\n\r\n\t////////////////////// EVENTS //////////////////////\r\n\r\n    // Events that will be emitted on changes.\r\n    event NewStake(uint statementID, uint amount);\r\n    event StakeEnded(uint statementID, uint TruePotFinal, uint FalsePotFinal, uint winningPosition, uint numStakes);\r\n    event CurrentPot(uint statementID, uint totalPot);\r\n   \tevent NewStatement(uint statementID, string statement, uint stakeEndTime, string source);\r\n\r\n\t// Constructor executes once when contract is created\r\n\tconstructor () public {\r\n\t\towner = msg.sender;\r\n\t\tpctTimeRemainingThreshold = 20;\r\n\r\n\t\tminTimeAddPct = 0;\r\n\t\tmaxTimeAddPct = 40;\r\n\r\n\t\tminPotPctThreshold = 20;\r\n\t\tmaxPotPctThreshold = 180;\r\n\t}\r\n\r\n\t////////////////////// MODIFIERS //////////////////////\r\n    modifier onlyOwner {\r\n        require(\r\n            msg.sender == owner,\r\n            \"Only owner can call this function.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n\t////////////////////// FUNCTIONS //////////////////////\r\n\r\n\tfunction newStatement(string _statement, uint _position, uint _stakeDuration, string _source) public payable returns(uint statementID) {\r\n\t\t/**\r\n\t\t* creates a new statement with an initial stake\r\n\t\t*/\r\n\r\n\t\trequire(bytes(_statement).length > 0, \"requires bytes(statement) > 0. Possibly empty string given.\");\r\n\t\trequire(msg.value > 0, \"Insufficient stake value.\");\r\n\t\trequire(_position == 0 || _position == 1, \"Invalid position to stake on.\"); \r\n\t\trequire(_stakeDuration > 60 && _stakeDuration < 315360000, \"Stake duration must be at least 60 seconds and less than 10 years.\");\r\n\r\n\t\tuint stakeEndTime = now.add(_stakeDuration);\r\n\r\n\t\tstatementID = absNumStatements++; //sets statementID and THEN increases absNumStatements by 1\r\n\t\tstatements[statementID] = Statement(statementID, _statement, _stakeDuration, now, stakeEndTime, msg.sender, 0, 0, false, _source, 3);\r\n\r\n\t\temit NewStatement(statementID, _statement, stakeEndTime, _source);\r\n\r\n\t\tstake(statementID, _position);\r\n\r\n\t}\r\n\r\n\r\n\tfunction stake(uint _statementID, uint _position) public payable { \r\n\t\t/**\r\n\t\t* Stakes an amount of ethereum on a statement\r\n\t\t*/\r\n\r\n\t    // Revert the call if the staking period is over or if insufficient value transacted\r\n\t\trequire(msg.value > 0, \"Insufficient stake value.\");\r\n\t\trequire(_position == 0 || _position == 1, \"Invalid position to stake on.\"); \r\n\t\trequire(_statementID < absNumStatements && _statementID >= 0, \"Invalid Statement ID.\");\r\n\r\n\t\tStatement storage s = statements[_statementID];\r\n\t\trequire(now <= s.stakeEndTime, \"Stake already ended for this statement.\");\r\n\r\n\t\t// Map Stake with statement AND THEN add one to numStakes\r\n\t\ts.stakes[s.numStakes++] = Stake({addr:msg.sender, amount:msg.value, position:_position});\r\n\r\n\t\t// If it is near the end of the stake and someone stakes a large amount, time is added.\r\n\t\tuint pctTimeRemaining = 100 * s.stakeEndTime.sub(now) / s.stakeDuration;\r\n\r\n\t\tif (pctTimeRemaining <= pctTimeRemainingThreshold) {\r\n\r\n\t\t    uint percentOfCurrentPot = 100 * msg.value / s.ethStaked;\r\n\t\t    \r\n\t\t    if (percentOfCurrentPot > minPotPctThreshold) {\r\n\t\t        \r\n    \t\t\t// extraTime = stakeDuration * size of stake * time added per stake size ratio. More generally, extraTime = stakeDuration * x * slope\r\n    \t\t\tuint extraTimeRaw = s.stakeDuration * (percentOfCurrentPot.sub(minPotPctThreshold)) * (maxTimeAddPct.sub(minTimeAddPct)) / (maxPotPctThreshold.sub(minPotPctThreshold)) / 100;\r\n    \r\n    \t\t\t// Cap the amount of extra time added.\r\n    \t\t\tuint extraTime = Math.min(extraTimeRaw, s.stakeDuration * maxTimeAddPct / 100);\r\n    \r\n    \t\t\t// Add time to the stake\r\n    \t\t\ts.stakeEndTime += extraTime;\r\n\r\n\t\t    }\r\n\t\t}\r\n\r\n\t\t// Update Statement value\r\n\t\ts.ethStaked += msg.value;\r\n\t\temit NewStake(_statementID, msg.value);\r\n\r\n\t\t// Add to global trackers\r\n\t\tabsNumStakes++;\r\n\t\tabsEthStaked += msg.value;\r\n\r\n\t\t// Add the stake to total pot\r\n\t\taddToPot(msg.value, _position, _statementID);\r\n\r\n\t}\r\n\r\n\tfunction addToPot(uint _amount, uint _position, uint _statementID) private {\r\n\t\t/**\r\n\t\t* Private function keeps track of pots\r\n\t\t*/\r\n\r\n\t\tPot storage p = pots[_statementID];\r\n\r\n\t\tif (_position == 1) {\r\n\t\t\tp.T += _amount;\r\n\t\t}\r\n\t\telse {\r\n\t\t\tp.F += _amount;\r\n\t\t}\r\n\r\n\t\temit CurrentPot(_statementID, p.T.add(p.F));\r\n\r\n\t}\r\n\r\n\tfunction endStake(uint _statementID) public {\r\n\t\t/**\r\n\t\t* End the stake. Only callable after stake end time.\r\n\t\t*/\r\n\r\n\t\tStatement storage s = statements[_statementID];\r\n\r\n\t\t// 1. Conditions\r\n\t\t// Require that sufficient time has passed and endStake has not already been called\r\n\t\trequire(_statementID < absNumStatements, \"Invalid statementID\");\r\n\t\trequire(now >= s.stakeEndTime, \"There is still staking time remaining.\");\r\n\t\trequire(!s.stakeEnded, \"endStake has already been called.\");\r\n\r\n\t\t// 2. Effects\r\n\t\ts.stakeEnded = true; \r\n\r\n\t\t// 3. Interactions\r\n\t\t// distribute pot between winners, proportional to their stake\r\n\t\tdistribute(_statementID);\r\n\t}\r\n\r\n\tfunction distribute(uint _statementID) private {\r\n\t\t/**\r\n\t\t* This function distributes all rewards to the winners for this statement\r\n\t\t*/\r\n\r\n\t\tuint profit;\r\n\t\tuint reward; \r\n\t\tuint winningPot;\r\n\t\tuint losingPot;\r\n\t\tuint winningPosition;\r\n\r\n\t\tStatement storage s = statements[_statementID];\r\n\t\tPot storage p = pots[_statementID];\r\n\r\n\t\tif (p.T >= p.F) {\r\n\t\t\twinningPot = p.T;\r\n\t\t\tlosingPot = p.F;\r\n\t\t\twinningPosition = 1;\r\n\t\t\ts.verdict = 1;\r\n\t\t}\r\n\t\telse {\r\n\t\t\twinningPot = p.F;\r\n\t\t\tlosingPot = p.T;\r\n\t\t\twinningPosition = 0;\r\n\t\t\ts.verdict = 0;\r\n\t\t}\r\n\r\n\t\t// Emit the total pot value and winning position at end of stake\r\n\t\temit StakeEnded(_statementID,  p.T, p.F, winningPosition, s.numStakes);\r\n\r\n\t\t// Platform Service Fee\r\n\t\tuint fee = losingPot.mul(serviceFeeTenThousandths) / 10000;\r\n\t\tuint potRemaining = losingPot.sub(fee);\r\n\r\n\t\t// Beneficiaries \r\n\t\tfor (uint i = 0; i < beneficiaryAddresses.length; i++) {\r\n\t\t\taddress beneficiary = beneficiaryAddresses[i];\r\n\t\t\tbeneficiary.transfer(losingPot.mul(beneficiaryShares[beneficiary]) / 10000);\r\n\t\t\tpotRemaining -= losingPot.mul(beneficiaryShares[beneficiary]) / 10000;\r\n\t\t}\r\n\r\n\t\t// Reward marketMaker for submitting the statement\r\n\t\tuint marketMakerReward = potRemaining.mul(s.stakes[0].amount) / winningPot.add(potRemaining);\r\n\r\n\t\ts.stakes[0].addr.transfer(marketMakerReward);\r\n\r\n\t\tpotRemaining -= marketMakerReward;\r\n\r\n\t\t// Stakers Rewards\r\n\t\tfor (uint j = 0; j < s.numStakes; j++) {\r\n\r\n\t\t\t// If the staker's position matched the majority, they receive their original stake + proportion of loser's stakes\r\n\t\t\tif (s.stakes[j].position == winningPosition) {\r\n\r\n\t\t\t\t// Calculate profit for correct staker\r\n\t\t\t\tprofit = potRemaining.mul(s.stakes[j].amount) / winningPot;\r\n\r\n\t\t\t\t// Their reward is original stake + profit\r\n\t\t\t\treward = profit.add(s.stakes[j].amount);\r\n\r\n\t\t\t\t// Send the winner their reward\r\n\t\t\t\ts.stakes[j].addr.transfer(reward);\r\n\r\n\t\t\t}\r\n\r\n\t\t}\r\n\r\n\t\towner.transfer(fee);\r\n\r\n\t}\r\n\r\n\tfunction setServiceFeeTenThousandths(uint _newServiceFeeTenThousandths) public onlyOwner {\r\n\t/**\r\n\t* _newServiceFeeTenThousandths should be desired fee percentage * 100.\r\n\t* e.g. if service fee of 1.75% is desired, _newServiceFeeTenThousandths = 175\r\n\t*/\t\r\n\t\trequire(_newServiceFeeTenThousandths >= 0, 'Service Fee cannot be less than 0%.');\r\n\t\trequire(_newServiceFeeTenThousandths <= 10000, 'Service Fee cannot be greater than 100%.');\r\n\t\tserviceFeeTenThousandths = _newServiceFeeTenThousandths;\r\n\t}\r\n\r\n\tfunction addBeneficiary(address _beneficiaryAddress, uint _beneficiaryShareTenThousandths) public onlyOwner {\r\n\t\t/**\r\n\t\t* _potProportionTenThousandths should be desired percentage * 100.\r\n\t\t* e.g. if a pot cut of 0.35% is desired, _potProportionTenThousandths = 35\r\n\t\t*/\r\n\t\trequire(_beneficiaryShareTenThousandths >= 0, 'Beneficiary cut cannot be less than 0%.');\r\n\t\trequire(_beneficiaryShareTenThousandths <= 10000, 'Beneficiary cut cannot be greater than 100%.');\r\n\t\tbeneficiaryAddresses.push(_beneficiaryAddress);\r\n\t\tbeneficiaryShares[_beneficiaryAddress] = _beneficiaryShareTenThousandths;\r\n\t}\r\n\r\n\tfunction removeBeneficiary(uint _index, address _beneficiaryAddress) public onlyOwner {\r\n\t\t/**\r\n\t\t* Remove a beneficiary\r\n\t\t*/\r\n\t\trequire(beneficiaryAddresses.length > 0, 'There are no beneficiaries to remove.');\r\n\t\trequire(_beneficiaryAddress == beneficiaryAddresses[_index], \"The beneficiary address must match beneficiaryAddresses[index].\");\r\n\r\n\t\tbeneficiaryShares[_beneficiaryAddress] = 0; // set beneficiary shares to 0\r\n\t\tdelete beneficiaryAddresses[_index]; // remove the beneficiary\r\n\t\tbeneficiaryAddresses[_index] = beneficiaryAddresses[beneficiaryAddresses.length - 1]; // replace the empty spot with most recently added\r\n\t\tdelete beneficiaryAddresses[beneficiaryAddresses.length - 1]; // delete the redundant copy\r\n\t}\r\n\r\n\tfunction setAddTimeParameters(uint _newPctTimeRemainingThreshold, \r\n\t\t\t\t\t\t\t\t  uint _newMinTimeAddPct, \r\n\t\t\t\t\t\t\t\t  uint _newMaxTimeAddPct, \r\n\t\t\t\t\t\t\t\t  uint _newMinPotPctThreshold, \r\n\t\t\t\t\t\t\t\t  uint _newMaxPotPctThreshold )\r\n\t\t\t\t\t\t\t\t  public onlyOwner {\r\n\t\t/**\r\n\t\t* The time addition function is a linear function defined by 2 points (i.e. 4 coordinates)\r\n\t\t* extraTime = stakeDuration * x * slope\r\n\t\t* The pctTimeRemainingThreshold sets the time limit where the function becomes active. \r\n\t\t*/\r\n\t\tpctTimeRemainingThreshold = _newPctTimeRemainingThreshold;\r\n\t\tminTimeAddPct = _newMinTimeAddPct;\r\n\t\tmaxTimeAddPct = _newMaxTimeAddPct;\r\n\t\tminPotPctThreshold = _newMinPotPctThreshold;\r\n\t\tmaxPotPctThreshold = _newMaxPotPctThreshold;\r\n\t}\r\n\r\n\tfunction transferOwnership(address _newOwner) public onlyOwner {\r\n\t\towner = _newOwner;\r\n\t}\r\n\r\n\tfunction SELF_DESTRUCT(bytes _confirm) public onlyOwner {\r\n\t\t\t\r\n\t\tif (keccak256(_confirm) == keccak256('Yes, I really want to destroy this contract forever.')) {\r\n\t\t\tselfdestruct(owner);\r\n\t\t}\r\n\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newServiceFeeTenThousandths\",\"type\":\"uint256\"}],\"name\":\"setServiceFeeTenThousandths\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"absNumStatements\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"beneficiaryAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_statementID\",\"type\":\"uint256\"}],\"name\":\"endStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_confirm\",\"type\":\"bytes\"}],\"name\":\"SELF_DESTRUCT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"absEthStaked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceFeeTenThousandths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_statementID\",\"type\":\"uint256\"},{\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"stake\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaryAddress\",\"type\":\"address\"},{\"name\":\"_beneficiaryShareTenThousandths\",\"type\":\"uint256\"}],\"name\":\"addBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"statements\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"statement\",\"type\":\"string\"},{\"name\":\"stakeDuration\",\"type\":\"uint256\"},{\"name\":\"stakeBeginningTime\",\"type\":\"uint256\"},{\"name\":\"stakeEndTime\",\"type\":\"uint256\"},{\"name\":\"marketMaker\",\"type\":\"address\"},{\"name\":\"numStakes\",\"type\":\"uint256\"},{\"name\":\"ethStaked\",\"type\":\"uint256\"},{\"name\":\"stakeEnded\",\"type\":\"bool\"},{\"name\":\"source\",\"type\":\"string\"},{\"name\":\"verdict\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"},{\"name\":\"_beneficiaryAddress\",\"type\":\"address\"}],\"name\":\"removeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaryShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPctTimeRemainingThreshold\",\"type\":\"uint256\"},{\"name\":\"_newMinTimeAddPct\",\"type\":\"uint256\"},{\"name\":\"_newMaxTimeAddPct\",\"type\":\"uint256\"},{\"name\":\"_newMinPotPctThreshold\",\"type\":\"uint256\"},{\"name\":\"_newMaxPotPctThreshold\",\"type\":\"uint256\"}],\"name\":\"setAddTimeParameters\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_statement\",\"type\":\"string\"},{\"name\":\"_position\",\"type\":\"uint256\"},{\"name\":\"_stakeDuration\",\"type\":\"uint256\"},{\"name\":\"_source\",\"type\":\"string\"}],\"name\":\"newStatement\",\"outputs\":[{\"name\":\"statementID\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"absNumStakes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"statementID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NewStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"statementID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"TruePotFinal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"FalsePotFinal\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winningPosition\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numStakes\",\"type\":\"uint256\"}],\"name\":\"StakeEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"statementID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPot\",\"type\":\"uint256\"}],\"name\":\"CurrentPot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"statementID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"statement\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"stakeEndTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"source\",\"type\":\"string\"}],\"name\":\"NewStatement\",\"type\":\"event\"}]","ContractName":"TruthStaking","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","EVMVersion":"Default","Library":"","LicenseType":"MIT","Proxy":"0","Implementation":"","SwarmSource":"bzzr://c22446373d9f8c9e1c65e9d9f6618a095593ce528e0f556ee84e9338c1cbc594"}]}