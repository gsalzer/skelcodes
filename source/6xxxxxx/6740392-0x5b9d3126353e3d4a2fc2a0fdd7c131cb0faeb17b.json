{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n * Math operations with safety checks that throw on overflows.\r\n */\r\nlibrary SafeMath {\r\n\r\n    function mul (uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n    \r\n    function sub (uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add (uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20TokenInterface {\r\n\r\n    function totalSupply () external constant returns (uint);\r\n    function balanceOf (address tokenOwner) external constant returns (uint balance);\r\n    function transfer (address to, uint tokens) external returns (bool success);\r\n    function transferFrom (address from, address to, uint tokens) external returns (bool success);\r\n\r\n}\r\n\r\n/**\r\n * @title Team Vesting\r\n * You can check how many tokens you can withdraw from this smart contract by calling\r\n * `releasableAmount` function. If you want to withdraw these tokens, create a transaction\r\n * to a `release` function, specifying your account address as an argument.\r\n */\r\ncontract PermanentTeamVesting {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    event Released(address beneficiary, uint256 amount);\r\n\r\n    struct Beneficiary {\r\n        uint256 start;\r\n        uint256 duration;\r\n        uint256 cliff;\r\n        uint256 totalAmount;\r\n        uint256 releasedAmount;\r\n    }\r\n\r\n    mapping (address => Beneficiary) public beneficiary;\r\n    ERC20TokenInterface public token;\r\n\r\n    modifier isVestedAccount (address account) { require(beneficiary[account].start != 0); _; }\r\n    modifier isNotVestedAccount (address account) { require(beneficiary[account].start == 0); _; }\r\n\r\n    /**\r\n    * Token vesting.\r\n    */\r\n    constructor (ERC20TokenInterface tokenAddress) public {\r\n        require(tokenAddress != address(0));\r\n        token = tokenAddress;\r\n    }\r\n\r\n    /**\r\n    * Calculates the releaseable amount of tokens at the current time.\r\n    * @param account Vested account\r\n    * @return Amount in decimals\r\n    */\r\n    function releasableAmount (address account) public view returns (uint256) {\r\n        return vestedAmount(account).sub(beneficiary[account].releasedAmount);\r\n    }\r\n\r\n    /**\r\n    * @notice Transfers available vested tokens to the beneficiary.\r\n    * @param account Beneficiary account.\r\n    */\r\n    function release (address account) public isVestedAccount(account) {\r\n        uint256 unreleased = releasableAmount(account);\r\n        require(unreleased > 0);\r\n        beneficiary[account].releasedAmount = beneficiary[account].releasedAmount.add(unreleased);\r\n        token.transfer(account, unreleased);\r\n        emit Released(account, unreleased);\r\n        if (beneficiary[account].releasedAmount == beneficiary[account].totalAmount) { // When done, clean beneficiary info\r\n            delete beneficiary[account];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Allows to vest tokens for beneficiary.\r\n     */\r\n    function addBeneficiary (\r\n        address account,\r\n        uint256 start,\r\n        uint256 duration,\r\n        uint256 cliff,\r\n        uint256 amount\r\n    ) public isNotVestedAccount(account) {\r\n        require(amount != 0 && account != 0x0 && cliff < duration && beneficiary[account].start == 0);\r\n        require(token.transferFrom(msg.sender, address(this), amount));\r\n        beneficiary[account] = Beneficiary({\r\n            start: start,\r\n            duration: duration,\r\n            cliff: start.add(cliff),\r\n            totalAmount: amount,\r\n            releasedAmount: 0\r\n        });\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates the amount that has already vested.\r\n    * @param account Vested account\r\n    * @return Amount in decimals\r\n    */\r\n    function vestedAmount (address account) private view returns (uint256) {\r\n        if (block.timestamp < beneficiary[account].cliff) {\r\n            return 0;\r\n        } else if (block.timestamp >= beneficiary[account].start.add(beneficiary[account].duration)) {\r\n            return beneficiary[account].totalAmount;\r\n        } else {\r\n            return beneficiary[account].totalAmount.mul(\r\n                block.timestamp.sub(beneficiary[account].start)\r\n            ).div(beneficiary[account].duration);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"releasableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"cliff\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"cliff\",\"type\":\"uint256\"},{\"name\":\"totalAmount\",\"type\":\"uint256\"},{\"name\":\"releasedAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"}]","ContractName":"PermanentTeamVesting","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000082f4ded9cec9b5750fbff5c2185aee35afc16587","Library":"","SwarmSource":"bzzr://99984f29b12d2d2803a3465155f03e0ec1b3210397d0e51e22a4651658f7ffa8"}]}