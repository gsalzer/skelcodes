{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\n\r\n//\r\n// SVLightBallotBox\r\n// Single use contract to manage a ballot\r\n// Author: Max Kaye <max@secure.vote>\r\n// (c) SecureVote 2018\r\n//\r\n// Architecture:\r\n// * Ballot authority declares public key with which to encrypt ballots (optional - stored in ballot spec)\r\n// * Users submit encrypted or plaintext ballots as blobs (dependent on above)\r\n// * These ballots are tracked by the ETH address of the sender\r\n// * Following the conclusion of the ballot, the secret key is provided\r\n//   by the ballot authority, and all users may transparently and\r\n//   independently validate the results\r\n//\r\n// Notes:\r\n// * Since ballots are encrypted the only validation we can do is length, but UI takes care of most of the rest\r\n//\r\n\r\n\r\ncontract SVLightBallotBox {\r\n    //// ** Storage Variables\r\n\r\n    // Std owner pattern\r\n    address public owner;\r\n\r\n    // test mode - operations like changing start/end times\r\n    bool public testMode = false;\r\n\r\n    // struct for ballot\r\n    struct Ballot {\r\n        bytes32 ballotData;\r\n        address sender;\r\n        // we use a uint32 here because addresses are 20 bytes and this might help\r\n        // solidity pack the block number well. gives us a little room to expand too if needed.\r\n        uint32 blockN;\r\n    }\r\n\r\n    // Maps to store ballots, along with corresponding log of voters.\r\n    // Should only be modified through `addBallotAndVoter` internal function\r\n    mapping (uint256 => Ballot) public ballotMap;\r\n    mapping (uint256 => bytes32) public associatedPubkeys;\r\n    uint256 public nVotesCast = 0;\r\n\r\n    // Use a map for voters to look up their ballot\r\n    mapping (address => uint256) public voterToBallotID;\r\n\r\n    // NOTE - We don't actually want to include the PublicKey because _it's included in the ballotSpec_.\r\n    // It's better to ensure ppl actually have the ballot spec by not including it in the contract.\r\n    // Plus we're already storing the hash of the ballotSpec anyway...\r\n\r\n    // Private key to be set after ballot conclusion - curve25519\r\n    bytes32 public ballotEncryptionSeckey;\r\n    bool seckeyRevealed = false;\r\n\r\n    // Timestamps for start and end of ballot (UTC)\r\n    uint64 public startTime;\r\n    uint64 public endTime;\r\n    uint64 public creationBlock;\r\n    uint64 public startingBlockAround;\r\n\r\n    // specHash by which to validate the ballots integrity\r\n    bytes32 public specHash;\r\n    bool public useEncryption;\r\n\r\n    // deprecation flag - doesn't actually do anything besides signal that this contract is deprecated;\r\n    bool public deprecated = false;\r\n\r\n    //// ** Events\r\n    event CreatedBallot(address _creator, uint64[2] _openPeriod, bool _useEncryption, bytes32 _specHash);\r\n    event SuccessfulPkVote(address voter, bytes32 ballot, bytes32 pubkey);\r\n    event SuccessfulVote(address voter, bytes32 ballot);\r\n    event SeckeyRevealed(bytes32 secretKey);\r\n    event TestingEnabled();\r\n    event Error(string error);\r\n    event DeprecatedContract();\r\n    event SetOwner(address _owner);\r\n\r\n\r\n    //// ** Modifiers\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier ballotOpen {\r\n        require(uint64(block.timestamp) >= startTime && uint64(block.timestamp) < endTime);\r\n        _;\r\n    }\r\n\r\n    modifier onlyTesting {\r\n        require(testMode);\r\n        _;\r\n    }\r\n\r\n    modifier isTrue(bool _b) {\r\n        require(_b == true);\r\n        _;\r\n    }\r\n\r\n    modifier isFalse(bool _b) {\r\n        require(_b == false);\r\n        _;\r\n    }\r\n\r\n    //// ** Functions\r\n\r\n    uint16 constant F_USE_ENC = 0;\r\n    uint16 constant F_TESTING = 1;\r\n    // Constructor function - init core params on deploy\r\n    // timestampts are uint64s to give us plenty of room for millennia\r\n    // flags are [_useEncryption, enableTesting]\r\n    function SVLightBallotBox(bytes32 _specHash, uint64[2] openPeriod, bool[2] flags) public {\r\n        owner = msg.sender;\r\n\r\n        // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\r\n        // (which someone might be able to do if they could set the timestamp in the past)\r\n        startTime = max(openPeriod[0], uint64(block.timestamp));\r\n        endTime = openPeriod[1];\r\n        useEncryption = flags[F_USE_ENC];\r\n        specHash = _specHash;\r\n        creationBlock = uint64(block.number);\r\n        // add a rough prediction of what block is the starting block\r\n        startingBlockAround = uint64((startTime - block.timestamp) / 15 + block.number);\r\n\r\n        if (flags[F_TESTING]) {\r\n            testMode = true;\r\n            TestingEnabled();\r\n        }\r\n\r\n        CreatedBallot(msg.sender, [startTime, endTime], useEncryption, specHash);\r\n    }\r\n\r\n    // Ballot submission\r\n    function submitBallotWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) isTrue(useEncryption) ballotOpen public {\r\n        addBallotAndVoterWithPk(encryptedBallot, senderPubkey);\r\n        SuccessfulPkVote(msg.sender, encryptedBallot, senderPubkey);\r\n    }\r\n\r\n    function submitBallotNoPk(bytes32 ballot) isFalse(useEncryption) ballotOpen public {\r\n        addBallotAndVoterNoPk(ballot);\r\n        SuccessfulVote(msg.sender, ballot);\r\n    }\r\n\r\n    // Internal function to ensure atomicity of voter log\r\n    function addBallotAndVoterWithPk(bytes32 encryptedBallot, bytes32 senderPubkey) internal {\r\n        uint256 ballotNumber = addBallotAndVoterNoPk(encryptedBallot);\r\n        associatedPubkeys[ballotNumber] = senderPubkey;\r\n    }\r\n\r\n    function addBallotAndVoterNoPk(bytes32 encryptedBallot) internal returns (uint256) {\r\n        uint256 ballotNumber = nVotesCast;\r\n        ballotMap[ballotNumber] = Ballot(encryptedBallot, msg.sender, uint32(block.number));\r\n        voterToBallotID[msg.sender] = ballotNumber;\r\n        nVotesCast += 1;\r\n        return ballotNumber;\r\n    }\r\n\r\n    // Allow the owner to reveal the secret key after ballot conclusion\r\n    function revealSeckey(bytes32 _secKey) onlyOwner public {\r\n        require(block.timestamp > endTime);\r\n\r\n        ballotEncryptionSeckey = _secKey;\r\n        seckeyRevealed = true; // this flag allows the contract to be locked\r\n        SeckeyRevealed(_secKey);\r\n    }\r\n\r\n    function getEncSeckey() public constant returns (bytes32) {\r\n        return ballotEncryptionSeckey;\r\n    }\r\n\r\n    // Test functions\r\n    function setEndTime(uint64 newEndTime) onlyTesting onlyOwner public {\r\n        endTime = newEndTime;\r\n    }\r\n\r\n    function setDeprecated() onlyOwner public {\r\n        deprecated = true;\r\n        DeprecatedContract();\r\n    }\r\n\r\n    function setOwner(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n        SetOwner(newOwner);\r\n    }\r\n\r\n    // utils\r\n    function max(uint64 a, uint64 b) pure internal returns(uint64) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}\r\n\r\n\r\n//\r\n// The Index by which democracies and ballots are tracked (and optionally deployed).\r\n// Author: Max Kaye <max@secure.vote>\r\n// (c) SecureVote 2018\r\n//\r\n\r\ncontract SVLightIndexShim {\r\n\r\n    address public owner;\r\n\r\n    struct Ballot {\r\n        bytes32 specHash;\r\n        bytes32 extraData;\r\n        address votingContract;\r\n        uint64 startTs;\r\n    }\r\n\r\n    struct Democ {\r\n        string name;\r\n        address admin;\r\n        Ballot[] ballots;\r\n    }\r\n\r\n    mapping (bytes32 => Democ) public democs;\r\n    bytes32[] public democList;\r\n\r\n    bool public paymentEnabled = false;\r\n\r\n    SVLightIndexShim prevIndex;\r\n\r\n    //* EVENTS /\r\n\r\n    event PaymentMade(uint128[2] valAndRemainder);\r\n    event DemocInit(string name, bytes32 democHash, address admin);\r\n    event BallotInit(bytes32 specHash, uint64[2] openPeriod, bool[2] flags);\r\n    event BallotAdded(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract);\r\n    event SetFees(uint128[2] _newFees);\r\n    event PaymentEnabled(bool _feeEnabled);\r\n\r\n    //* MODIFIERS /\r\n\r\n    modifier onlyBy(address _account) {\r\n        require(msg.sender == _account);\r\n        _;\r\n    }\r\n\r\n    //* FUNCTIONS /\r\n\r\n\r\n    // constructor\r\n    constructor(SVLightIndexShim _prevIndex) public {\r\n        owner = msg.sender;\r\n        prevIndex = _prevIndex;\r\n\r\n        bytes32 democHash;\r\n        bytes32 specHash;\r\n        bytes32 extraData;\r\n        address votingContract;\r\n        uint64 startTime;\r\n\r\n        for (uint i = 0; i < prevIndex.nDemocs(); i++) {\r\n            democHash = prevIndex.democList(i);\r\n            democList.push(democHash);\r\n            // only democracies are SWM\r\n            democs[democHash].admin = msg.sender;\r\n\r\n            for (uint j = 0; j < prevIndex.nBallots(democHash); j++) {\r\n                (specHash, extraData, votingContract, startTime) = prevIndex.getNthBallot(democHash, j);\r\n                democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTime));\r\n            }\r\n        }\r\n    }\r\n\r\n    //* GLOBAL INFO */\r\n\r\n    function nDemocs() public constant returns (uint256) {\r\n        return democList.length;\r\n    }\r\n\r\n    //* PAYMENT AND OWNER FUNCTIONS */\r\n\r\n    function setOwner(address _owner) onlyBy(owner) public {\r\n        owner = _owner;\r\n    }\r\n\r\n    function setDemocAdminEmergency(bytes32 democHash, address newAdmin) onlyBy(owner) public {\r\n        democs[democHash].admin = newAdmin;\r\n    }\r\n\r\n    //* DEMOCRACY FUNCTIONS - INDIVIDUAL */\r\n\r\n    function getDemocInfo(bytes32 democHash) public constant returns (string name, address admin, uint256 nBallots) {\r\n        // only democs are SWM Gov democs\r\n        return (\"SWM Governance\", democs[democHash].admin, democs[democHash].ballots.length);\r\n    }\r\n\r\n    function setAdmin(bytes32 democHash, address newAdmin) onlyBy(democs[democHash].admin) public {\r\n        democs[democHash].admin = newAdmin;\r\n    }\r\n\r\n    function nBallots(bytes32 democHash) public constant returns (uint256) {\r\n        return democs[democHash].ballots.length;\r\n    }\r\n\r\n    function getNthBallot(bytes32 democHash, uint256 n) public constant returns (bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTime) {\r\n        return (democs[democHash].ballots[n].specHash, democs[democHash].ballots[n].extraData, democs[democHash].ballots[n].votingContract, democs[democHash].ballots[n].startTs);\r\n    }\r\n\r\n    //* ADD BALLOT TO RECORD */\r\n\r\n    function _commitBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, address votingContract, uint64 startTs) internal {\r\n        democs[democHash].ballots.push(Ballot(specHash, extraData, votingContract, startTs));\r\n        BallotAdded(democHash, specHash, extraData, votingContract);\r\n    }\r\n\r\n    function addBallot(bytes32 democHash, bytes32 extraData, address votingContract)\r\n                      onlyBy(democs[democHash].admin)\r\n                      public\r\n                      {\r\n        SVLightBallotBox bb = SVLightBallotBox(votingContract);\r\n        bytes32 specHash = bb.specHash();\r\n        uint64 startTs = bb.startTime();\r\n        _commitBallot(democHash, specHash, extraData, votingContract, startTs);\r\n    }\r\n\r\n    function deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData,\r\n                          uint64[2] openPeriod, bool[2] flags)\r\n                          onlyBy(democs[democHash].admin)\r\n                          public payable {\r\n        // the start time is max(startTime, block.timestamp) to avoid a DoS whereby a malicious electioneer could disenfranchise\r\n        // token holders who have recently acquired tokens.\r\n        uint64 startTs = max(openPeriod[0], uint64(block.timestamp));\r\n        SVLightBallotBox votingContract = new SVLightBallotBox(specHash, [startTs, openPeriod[1]], flags);\r\n        votingContract.setOwner(msg.sender);\r\n        _commitBallot(democHash, specHash, extraData, address(votingContract), startTs);\r\n        BallotInit(specHash, [startTs, openPeriod[1]], flags);\r\n    }\r\n\r\n    // utils\r\n    function max(uint64 a, uint64 b) pure internal returns(uint64) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"}],\"name\":\"getDemocInfo\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"nBallots\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nDemocs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"specHash\",\"type\":\"bytes32\"},{\"name\":\"extraData\",\"type\":\"bytes32\"},{\"name\":\"openPeriod\",\"type\":\"uint64[2]\"},{\"name\":\"flags\",\"type\":\"bool[2]\"}],\"name\":\"deployBallot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getNthBallot\",\"outputs\":[{\"name\":\"specHash\",\"type\":\"bytes32\"},{\"name\":\"extraData\",\"type\":\"bytes32\"},{\"name\":\"votingContract\",\"type\":\"address\"},{\"name\":\"startTime\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"democs\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"extraData\",\"type\":\"bytes32\"},{\"name\":\"votingContract\",\"type\":\"address\"}],\"name\":\"addBallot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"}],\"name\":\"nBallots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"democList\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"democHash\",\"type\":\"bytes32\"},{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"setDemocAdminEmergency\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_prevIndex\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"valAndRemainder\",\"type\":\"uint128[2]\"}],\"name\":\"PaymentMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"democHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"admin\",\"type\":\"address\"}],\"name\":\"DemocInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"specHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"openPeriod\",\"type\":\"uint64[2]\"},{\"indexed\":false,\"name\":\"flags\",\"type\":\"bool[2]\"}],\"name\":\"BallotInit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"democHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"specHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"extraData\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"votingContract\",\"type\":\"address\"}],\"name\":\"BallotAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newFees\",\"type\":\"uint128[2]\"}],\"name\":\"SetFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_feeEnabled\",\"type\":\"bool\"}],\"name\":\"PaymentEnabled\",\"type\":\"event\"}]","ContractName":"SVLightIndexShim","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000a8a8509a17a5872d01e489fc85b152eb2a0c092e","Library":"","SwarmSource":"bzzr://f704f0dadc2decd4737904b5515591865a93af511acefc6b84e32ee311090733"}]}