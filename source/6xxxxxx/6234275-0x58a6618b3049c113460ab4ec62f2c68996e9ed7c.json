{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/BytesUtils.sol\r\n\r\nlibrary BytesUtils {\r\n    /*\r\n    * @dev Returns the keccak-256 hash of a byte range.\r\n    * @param self The byte string to hash.\r\n    * @param offset The position to start hashing at.\r\n    * @param len The number of bytes to hash.\r\n    * @return The hash of the byte range.\r\n    */\r\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\r\n        require(offset + len <= self.length);\r\n        assembly {\r\n            ret := sha3(add(add(self, 32), offset), len)\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal.\r\n    * @param self The first bytes to compare.\r\n    * @param other The second bytes to compare.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\r\n        return compare(self, 0, self.length, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal. Comparison is done per-rune,\r\n    *      on unicode codepoints.\r\n    * @param self The first bytes to compare.\r\n    * @param offset The offset of self.\r\n    * @param len    The length of self.\r\n    * @param other The second bytes to compare.\r\n    * @param otheroffset The offset of the other string.\r\n    * @param otherlen    The length of the other string.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\r\n        uint shortest = len;\r\n        if (otherlen < len)\r\n        shortest = otherlen;\r\n\r\n        uint selfptr;\r\n        uint otherptr;\r\n\r\n        assembly {\r\n            selfptr := add(self, add(offset, 32))\r\n            otherptr := add(other, add(otheroffset, 32))\r\n        }\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint mask;\r\n                if (shortest > 32) {\r\n                    mask = uint256(- 1); // aka 0xffffff....\r\n                } else {\r\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n\r\n        return int(len) - int(otherlen);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @param len The number of bytes to compare\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\r\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal with offsets.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\r\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\r\n    }\r\n\r\n    /*\r\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\r\n    *      they are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\r\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\r\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 8-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 8 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\r\n        require(idx + 1 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 1), idx)), 0xFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 16-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 16 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\r\n        require(idx + 2 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\r\n        require(idx + 4 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\r\n        require(idx + 32 <= self.length);\r\n        assembly {\r\n            ret := mload(add(add(self, 32), idx))\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\r\n        require(idx + 20 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the n byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes.\r\n    * @param len The number of bytes.\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes20 ret) {\r\n        require(idx + len <= self.length);\r\n        assembly {\r\n            let mask := not(sub(exp(256, sub(32, len)), 1))\r\n            ret := and(mload(add(add(self, 32), idx)),  mask)\r\n        }\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Copies a substring into a new byte string.\r\n    * @param self The byte string to copy from.\r\n    * @param offset The offset to start copying at.\r\n    * @param len The number of bytes to copy.\r\n    */\r\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes) {\r\n        require(offset + len <= self.length);\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint dest;\r\n        uint src;\r\n\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n\r\n    // Maps characters from 0x30 to 0x7A to their base32 values.\r\n    // 0xFF represents invalid characters in that range.\r\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\r\n\r\n    /**\r\n     * @dev Decodes unpadded base32 data of up to one word in length.\r\n     * @param self The data to decode.\r\n     * @param off Offset into the string to start at.\r\n     * @param len Number of characters to decode.\r\n     * @return The decoded data, left aligned.\r\n     */\r\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\r\n        require(len <= 52);\r\n\r\n        uint ret = 0;\r\n        for(uint i = 0; i < len; i++) {\r\n            byte char = self[off + i];\r\n            require(char >= 0x30 && char <= 0x7A);\r\n            uint8 decoded = uint8(base32HexTable[uint(char) - 0x30]);\r\n            require(decoded <= 0x20);\r\n            if(i == len - 1) {\r\n                break;\r\n            }\r\n            ret = (ret << 5) | decoded;\r\n        }\r\n\r\n        uint bitlen = len * 5;\r\n        if(len % 8 == 0) {\r\n            // Multiple of 8 characters, no padding\r\n            ret = (ret << 5) | decoded;\r\n        } else if(len % 8 == 2) {\r\n            // Two extra characters - 1 byte\r\n            ret = (ret << 3) | (decoded >> 2);\r\n            bitlen -= 2;\r\n        } else if(len % 8 == 4) {\r\n            // Four extra characters - 2 bytes\r\n            ret = (ret << 1) | (decoded >> 4);\r\n            bitlen -= 4;\r\n        } else if(len % 8 == 5) {\r\n            // Five extra characters - 3 bytes\r\n            ret = (ret << 4) | (decoded >> 1);\r\n            bitlen -= 1;\r\n        } else if(len % 8 == 7) {\r\n            // Seven extra characters - 4 bytes\r\n            ret = (ret << 2) | (decoded >> 3);\r\n            bitlen -= 3;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        return bytes32(ret << (256 - bitlen));\r\n    }\r\n}\r\n\r\n// File: contracts/DNSSEC.sol\r\n\r\ninterface DNSSEC {\r\n\r\n    event AlgorithmUpdated(uint8 id, address addr);\r\n    event DigestUpdated(uint8 id, address addr);\r\n    event NSEC3DigestUpdated(uint8 id, address addr);\r\n    event RRSetUpdated(bytes name, bytes rrset);\r\n\r\n    function submitRRSets(bytes memory data, bytes memory proof) public returns (bytes);\r\n    function submitRRSet(bytes memory input, bytes memory sig, bytes memory proof) public returns(bytes memory rrs);\r\n    function deleteRRSet(uint16 deleteType, bytes deleteName, bytes memory nsec, bytes memory sig, bytes memory proof) public;\r\n    function rrdata(uint16 dnstype, bytes memory name) public view returns (uint32, uint64, bytes20);\r\n\r\n}\r\n\r\n// File: contracts/Owned.sol\r\n\r\n/**\r\n* @dev Contract mixin for 'owned' contracts.\r\n*/\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier owner_only() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address newOwner) public owner_only {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: @ensdomains/buffer/contracts/Buffer.sol\r\n\r\n/**\r\n* @dev A library for working with mutable byte buffers in Solidity.\r\n*\r\n* Byte buffers are mutable and expandable, and provide a variety of primitives\r\n* for writing to them. At any time you can fetch a bytes object containing the\r\n* current contents of the buffer. The bytes object should not be stored between\r\n* operations, as it may change due to resizing of the buffer.\r\n*/\r\nlibrary Buffer {\r\n    /**\r\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n    *      a capacity. The capacity may be longer than the current value, in\r\n    *      which case it can be extended without the need to allocate more memory.\r\n    */\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a buffer with an initial capacity.\r\n    * @param buf The buffer to initialize.\r\n    * @param capacity The number of bytes of space to allocate the buffer.\r\n    * @return The buffer, for chaining.\r\n    */\r\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\r\n        if (capacity % 32 != 0) {\r\n            capacity += 32 - (capacity % 32);\r\n        }\r\n        // Allocate space for the buffer data\r\n        buf.capacity = capacity;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a new buffer from an existing bytes object.\r\n    *      Changes to the buffer may mutate the original value.\r\n    * @param b The bytes object to initialize the buffer with.\r\n    * @return A new buffer.\r\n    */\r\n    function fromBytes(bytes b) internal pure returns(buffer memory) {\r\n        buffer memory buf;\r\n        buf.buf = b;\r\n        buf.capacity = b.length;\r\n        return buf;\r\n    }\r\n\r\n    function resize(buffer memory buf, uint capacity) private pure {\r\n        bytes memory oldbuf = buf.buf;\r\n        init(buf, capacity);\r\n        append(buf, oldbuf);\r\n    }\r\n\r\n    function max(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets buffer length to 0.\r\n    * @param buf The buffer to truncate.\r\n    * @return The original buffer, for chaining..\r\n    */\r\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n        assembly {\r\n            let bufptr := mload(buf)\r\n            mstore(bufptr, 0)\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The start offset to write to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes data, uint len) internal pure returns(buffer memory) {\r\n        require(len <= data.length);\r\n\r\n        if (off + len + buf.buf.length > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len + off) * 2);\r\n        }\r\n\r\n        uint dest;\r\n        uint src;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Start address = buffer address + offset + sizeof(buffer length)\r\n            dest := add(add(bufptr, 32), off)\r\n            // Update buffer length if we're extending it\r\n            if gt(add(len, off), buflen) {\r\n                mstore(bufptr, add(len, off))\r\n            }\r\n            src := add(data, 32)\r\n        }\r\n\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes data, uint len) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, len);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, data.length);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write the byte at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\r\n        if (off > buf.capacity) {\r\n            resize(buf, buf.capacity * 2);\r\n        }\r\n\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + sizeof(buffer length) + off\r\n            let dest := add(add(bufptr, off), 32)\r\n            mstore8(dest, data)\r\n            // Update buffer length if we extended it\r\n            if eq(off, buflen) {\r\n                mstore(bufptr, add(buflen, 1))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\r\n        return writeUint8(buf, buf.buf.length, data);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n    *      exceed the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (left-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        // Right-align data\r\n        data = data >> (8 * (32 - len));\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + sizeof(buffer length) + off + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, off, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chhaining.\r\n    */\r\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, 32);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (right-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len + off) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + off + sizeof(buffer length) + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n}\r\n\r\n// File: contracts/RRUtils.sol\r\n\r\n/**\r\n* @dev RRUtils is a library that provides utilities for parsing DNS resource records.\r\n*/\r\nlibrary RRUtils {\r\n    using BytesUtils for *;\r\n    using Buffer for *;\r\n\r\n    /**\r\n    * @dev Returns the number of bytes in the DNS name at 'offset' in 'self'.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return The length of the DNS name at 'offset', in bytes.\r\n    */\r\n    function nameLength(bytes memory self, uint offset) internal pure returns(uint) {\r\n        uint idx = offset;\r\n        while (true) {\r\n            assert(idx < self.length);\r\n            uint labelLen = self.readUint8(idx);\r\n            idx += labelLen + 1;\r\n            if (labelLen == 0) {\r\n                break;\r\n            }\r\n        }\r\n        return idx - offset;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns a DNS format name at the specified offset of self.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return The name.\r\n    */\r\n    function readName(bytes memory self, uint offset) internal pure returns(bytes memory ret) {\r\n        uint len = nameLength(self, offset);\r\n        return self.substring(offset, len);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the number of labels in the DNS name at 'offset' in 'self'.\r\n    * @param self The byte array to read a name from.\r\n    * @param offset The offset to start reading at.\r\n    * @return The number of labels in the DNS name at 'offset', in bytes.\r\n    */\r\n    function labelCount(bytes memory self, uint offset) internal pure returns(uint) {\r\n        uint count = 0;\r\n        while (true) {\r\n            assert(offset < self.length);\r\n            uint labelLen = self.readUint8(offset);\r\n            offset += labelLen + 1;\r\n            if (labelLen == 0) {\r\n                break;\r\n            }\r\n            count += 1;\r\n        }\r\n        return count;\r\n    }\r\n\r\n    /**\r\n    * @dev An iterator over resource records.\r\n    */\r\n    struct RRIterator {\r\n        bytes data;\r\n        uint offset;\r\n        uint16 dnstype;\r\n        uint16 class;\r\n        uint32 ttl;\r\n        uint rdataOffset;\r\n        uint nextOffset;\r\n    }\r\n\r\n    /**\r\n    * @dev Begins iterating over resource records.\r\n    * @param self The byte string to read from.\r\n    * @param offset The offset to start reading at.\r\n    * @return An iterator object.\r\n    */\r\n    function iterateRRs(bytes memory self, uint offset) internal pure returns (RRIterator memory ret) {\r\n        ret.data = self;\r\n        ret.nextOffset = offset;\r\n        next(ret);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns true iff there are more RRs to iterate.\r\n    * @param iter The iterator to check.\r\n    * @return True iff the iterator has finished.\r\n    */\r\n    function done(RRIterator memory iter) internal pure returns(bool) {\r\n        return iter.offset >= iter.data.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Moves the iterator to the next resource record.\r\n    * @param iter The iterator to advance.\r\n    */\r\n    function next(RRIterator memory iter) internal pure {\r\n        iter.offset = iter.nextOffset;\r\n        if (iter.offset >= iter.data.length) {\r\n            return;\r\n        }\r\n\r\n        // Skip the name\r\n        uint off = iter.offset + nameLength(iter.data, iter.offset);\r\n\r\n        // Read type, class, and ttl\r\n        iter.dnstype = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.class = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.ttl = iter.data.readUint32(off);\r\n        off += 4;\r\n\r\n        // Read the rdata\r\n        uint rdataLength = iter.data.readUint16(off);\r\n        off += 2;\r\n        iter.rdataOffset = off;\r\n        iter.nextOffset = off + rdataLength;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the name of the current record.\r\n    * @param iter The iterator.\r\n    * @return A new bytes object containing the owner name from the RR.\r\n    */\r\n    function name(RRIterator memory iter) internal pure returns(bytes memory) {\r\n        return iter.data.substring(iter.offset, nameLength(iter.data, iter.offset));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the rdata portion of the current record.\r\n    * @param iter The iterator.\r\n    * @return A new bytes object containing the RR's RDATA.\r\n    */\r\n    function rdata(RRIterator memory iter) internal pure returns(bytes memory) {\r\n        return iter.data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks if a given RR type exists in a type bitmap.\r\n    * @param self The byte string to read the type bitmap from.\r\n    * @param offset The offset to start reading at.\r\n    * @param rrtype The RR type to check for.\r\n    * @return True if the type is found in the bitmap, false otherwise.\r\n    */\r\n    function checkTypeBitmap(bytes memory self, uint offset, uint16 rrtype) internal pure returns (bool) {\r\n        uint8 typeWindow = uint8(rrtype >> 8);\r\n        uint8 windowByte = uint8((rrtype & 0xff) / 8);\r\n        uint8 windowBitmask = uint8(uint8(1) << (uint8(7) - uint8(rrtype & 0x7)));\r\n        for (uint off = offset; off < self.length;) {\r\n            uint8 window = self.readUint8(off);\r\n            uint8 len = self.readUint8(off + 1);\r\n            if (typeWindow < window) {\r\n                // We've gone past our window; it's not here.\r\n                return false;\r\n            } else if (typeWindow == window) {\r\n                // Check this type bitmap\r\n                if (len * 8 <= windowByte) {\r\n                    // Our type is past the end of the bitmap\r\n                    return false;\r\n                }\r\n                return (self.readUint8(off + windowByte + 2) & windowBitmask) != 0;\r\n            } else {\r\n                // Skip this type bitmap\r\n                off += len + 2;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function compareNames(bytes memory self, bytes memory other) internal pure returns (int) {\r\n        if (self.equals(other)) {\r\n            return 0;\r\n        }\r\n\r\n        uint off;\r\n        uint otheroff;\r\n        uint prevoff;\r\n        uint otherprevoff;\r\n        uint counts = labelCount(self, 0);\r\n        uint othercounts = labelCount(other, 0);\r\n\r\n        // Keep removing labels from the front of the name until both names are equal length\r\n        while (counts > othercounts) {\r\n            prevoff = off;\r\n            off = progress(self, off);\r\n            counts--;\r\n        }\r\n\r\n        while (othercounts > counts) {\r\n            otherprevoff = otheroff;\r\n            otheroff = progress(other, otheroff);\r\n            othercounts--;\r\n        }\r\n\r\n        // Compare the last nonequal labels to each other\r\n        while (counts > 0 && !self.equals(off, other, otheroff)) {\r\n            prevoff = off;\r\n            off = progress(self, off);\r\n            otherprevoff = otheroff;\r\n            otheroff = progress(other, otheroff);\r\n            counts -= 1;\r\n        }\r\n\r\n        if (off == 0) {\r\n            return -1;\r\n        }\r\n        if(otheroff == 0) {\r\n            return 1;\r\n        }\r\n\r\n        return self.compare(prevoff + 1, self.readUint8(prevoff), other, otherprevoff + 1, other.readUint8(otherprevoff));\r\n    }\r\n\r\n    function progress(bytes memory body, uint off) internal pure returns(uint) {\r\n        return off + 1 + body.readUint8(off);\r\n    }\r\n}\r\n\r\n// File: contracts/algorithms/Algorithm.sol\r\n\r\n/**\r\n* @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\r\n*/\r\ninterface Algorithm {\r\n    /**\r\n    * @dev Verifies a signature.\r\n    * @param key The public key to verify with.\r\n    * @param data The signed data to verify.\r\n    * @param signature The signature to verify.\r\n    * @return True iff the signature is valid.\r\n    */\r\n    function verify(bytes key, bytes data, bytes signature) external view returns (bool);\r\n}\r\n\r\n// File: contracts/digests/Digest.sol\r\n\r\n/**\r\n* @dev An interface for contracts implementing a DNSSEC digest.\r\n*/\r\ninterface Digest {\r\n    /**\r\n    * @dev Verifies a cryptographic hash.\r\n    * @param data The data to hash.\r\n    * @param hash The hash to compare to.\r\n    * @return True iff the hashed data matches the provided hash value.\r\n    */\r\n    function verify(bytes data, bytes hash) external pure returns (bool);\r\n}\r\n\r\n// File: contracts/nsec3digests/NSEC3Digest.sol\r\n\r\n/**\r\n * @dev Interface for contracts that implement NSEC3 digest algorithms.\r\n */\r\ninterface NSEC3Digest {\r\n    /**\r\n     * @dev Performs an NSEC3 iterated hash.\r\n     * @param salt The salt value to use on each iteration.\r\n     * @param data The data to hash.\r\n     * @param iterations The number of iterations to perform.\r\n     * @return The result of the iterated hash operation.\r\n     */\r\n     function hash(bytes salt, bytes data, uint iterations) external pure returns (bytes32);\r\n}\r\n\r\n// File: contracts/DNSSECImpl.sol\r\n\r\n/*\r\n * @dev An oracle contract that verifies and stores DNSSEC-validated DNS records.\r\n *\r\n * TODO: Support for NSEC3 records\r\n * TODO: Use 'serial number math' for inception/expiration\r\n */\r\ncontract DNSSECImpl is DNSSEC, Owned {\r\n    using Buffer for Buffer.buffer;\r\n    using BytesUtils for bytes;\r\n    using RRUtils for *;\r\n\r\n    uint16 constant DNSCLASS_IN = 1;\r\n\r\n    uint16 constant DNSTYPE_DS = 43;\r\n    uint16 constant DNSTYPE_RRSIG = 46;\r\n    uint16 constant DNSTYPE_NSEC = 47;\r\n    uint16 constant DNSTYPE_DNSKEY = 48;\r\n    uint16 constant DNSTYPE_NSEC3 = 50;\r\n\r\n    uint constant DS_KEY_TAG = 0;\r\n    uint constant DS_ALGORITHM = 2;\r\n    uint constant DS_DIGEST_TYPE = 3;\r\n    uint constant DS_DIGEST = 4;\r\n\r\n    uint constant RRSIG_TYPE = 0;\r\n    uint constant RRSIG_ALGORITHM = 2;\r\n    uint constant RRSIG_LABELS = 3;\r\n    uint constant RRSIG_TTL = 4;\r\n    uint constant RRSIG_EXPIRATION = 8;\r\n    uint constant RRSIG_INCEPTION = 12;\r\n    uint constant RRSIG_KEY_TAG = 16;\r\n    uint constant RRSIG_SIGNER_NAME = 18;\r\n\r\n    uint constant DNSKEY_FLAGS = 0;\r\n    uint constant DNSKEY_PROTOCOL = 2;\r\n    uint constant DNSKEY_ALGORITHM = 3;\r\n    uint constant DNSKEY_PUBKEY = 4;\r\n\r\n    uint constant DNSKEY_FLAG_ZONEKEY = 0x100;\r\n\r\n    uint constant NSEC3_HASH_ALGORITHM = 0;\r\n    uint constant NSEC3_FLAGS = 1;\r\n    uint constant NSEC3_ITERATIONS = 2;\r\n    uint constant NSEC3_SALT_LENGTH = 4;\r\n    uint constant NSEC3_SALT = 5;\r\n\r\n    uint8 constant ALGORITHM_RSASHA256 = 8;\r\n\r\n    uint8 constant DIGEST_ALGORITHM_SHA256 = 2;\r\n\r\n    struct RRSet {\r\n        uint32 inception;\r\n        uint64 inserted;\r\n        bytes20 hash;\r\n    }\r\n\r\n    // (name, type) => RRSet\r\n    mapping (bytes32 => mapping(uint16 => RRSet)) rrsets;\r\n\r\n    bytes public anchors;\r\n\r\n    mapping (uint8 => Algorithm) public algorithms;\r\n    mapping (uint8 => Digest) public digests;\r\n    mapping (uint8 => NSEC3Digest) public nsec3Digests;\r\n\r\n    /**\r\n     * @dev Constructor.\r\n     * @param _anchors The binary format RR entries for the root DS records.\r\n     */\r\n    constructor(bytes _anchors) public {\r\n        // Insert the 'trust anchors' - the key hashes that start the chain\r\n        // of trust for all other records.\r\n        anchors = _anchors;\r\n        rrsets[keccak256(hex\"00\")][DNSTYPE_DS] = RRSet({\r\n            inception: uint32(0),\r\n            inserted: uint64(now),\r\n            hash: bytes20(keccak256(anchors))\r\n        });\r\n        emit RRSetUpdated(hex\"00\", anchors);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the contract address for a signature verification algorithm.\r\n     *      Callable only by the owner.\r\n     * @param id The algorithm ID\r\n     * @param algo The address of the algorithm contract.\r\n     */\r\n    function setAlgorithm(uint8 id, Algorithm algo) public owner_only {\r\n        algorithms[id] = algo;\r\n        emit AlgorithmUpdated(id, algo);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the contract address for a digest verification algorithm.\r\n     *      Callable only by the owner.\r\n     * @param id The digest ID\r\n     * @param digest The address of the digest contract.\r\n     */\r\n    function setDigest(uint8 id, Digest digest) public owner_only {\r\n        digests[id] = digest;\r\n        emit DigestUpdated(id, digest);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets the contract address for an NSEC3 digest algorithm.\r\n     *      Callable only by the owner.\r\n     * @param id The digest ID\r\n     * @param digest The address of the digest contract.\r\n     */\r\n    function setNSEC3Digest(uint8 id, NSEC3Digest digest) public owner_only {\r\n        nsec3Digests[id] = digest;\r\n        emit NSEC3DigestUpdated(id, digest);\r\n    }\r\n\r\n    /**\r\n     * @dev Submits multiple RRSets\r\n     * @param data The data to submit, as a series of chunks. Each chunk is\r\n     *        in the format <uint16 length><bytes input><uint16 length><bytes sig>\r\n     * @param proof The DNSKEY or DS to validate the first signature against.\r\n     * @return The last RRSET submitted.\r\n     */\r\n    function submitRRSets(bytes memory data, bytes memory proof) public returns (bytes) {\r\n        uint offset = 0;\r\n        while(offset < data.length) {\r\n            bytes memory input = data.substring(offset + 2, data.readUint16(offset));\r\n            offset += input.length + 2;\r\n            bytes memory sig = data.substring(offset + 2, data.readUint16(offset));\r\n            offset += sig.length + 2;\r\n            proof = submitRRSet(input, sig, proof);\r\n        }\r\n        return proof;\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a signed set of RRs to the oracle.\r\n     *\r\n     * RRSETs are only accepted if they are signed with a key that is already\r\n     * trusted, or if they are self-signed, and the signing key is identified by\r\n     * a DS record that is already trusted.\r\n     *\r\n     * @param input The signed RR set. This is in the format described in section\r\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\r\n     *        data, followed by a series of canonicalised RR records that the signature\r\n     *        applies to.\r\n     * @param sig The signature data from the RRSIG record.\r\n     * @param proof The DNSKEY or DS to validate the signature against. Must Already\r\n     *        have been submitted and proved previously.\r\n     */\r\n    function submitRRSet(bytes memory input, bytes memory sig, bytes memory proof)\r\n        public returns(bytes memory rrs)\r\n    {\r\n        bytes memory name;\r\n        (name, rrs) = validateSignedSet(input, sig, proof);\r\n\r\n        uint32 inception = input.readUint32(RRSIG_INCEPTION);\r\n        uint16 typecovered = input.readUint16(RRSIG_TYPE);\r\n\r\n        RRSet storage set = rrsets[keccak256(name)][typecovered];\r\n        if (set.inserted > 0) {\r\n            // To replace an existing rrset, the signature must be at least as new\r\n            require(inception >= set.inception);\r\n        }\r\n        if (set.hash == keccak256(rrs)) {\r\n            // Already inserted!\r\n            return;\r\n        }\r\n\r\n        rrsets[keccak256(name)][typecovered] = RRSet({\r\n            inception: inception,\r\n            inserted: uint64(now),\r\n            hash: bytes20(keccak256(rrs))\r\n        });\r\n        emit RRSetUpdated(name, rrs);\r\n    }\r\n\r\n    /**\r\n     * @dev Deletes an RR from the oracle.\r\n     *\r\n     * @param deleteType The DNS record type to delete.\r\n     * @param deleteName which you want to delete\r\n     * @param nsec The signed NSEC RRset. This is in the format described in section\r\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\r\n     *        data, followed by a series of canonicalised RR records that the signature\r\n     *        applies to.\r\n     */\r\n    function deleteRRSet(uint16 deleteType, bytes deleteName, bytes memory nsec, bytes memory sig, bytes memory proof) public {\r\n        bytes memory nsecName;\r\n        bytes memory rrs;\r\n        (nsecName, rrs) = validateSignedSet(nsec, sig, proof);\r\n\r\n        // Don't let someone use an old proof to delete a new name\r\n        require(rrsets[keccak256(deleteName)][deleteType].inception <= nsec.readUint32(RRSIG_INCEPTION));\r\n\r\n        for (RRUtils.RRIterator memory iter = rrs.iterateRRs(0); !iter.done(); iter.next()) {\r\n            // We're dealing with three names here:\r\n            //   - deleteName is the name the user wants us to delete\r\n            //   - nsecName is the owner name of the NSEC record\r\n            //   - nextName is the next name specified in the NSEC record\r\n            //\r\n            // And three cases:\r\n            //   - deleteName equals nsecName, in which case we can delete the\r\n            //     record if it's not in the type bitmap.\r\n            //   - nextName comes after nsecName, in which case we can delete\r\n            //     the record if deleteName comes between nextName and nsecName.\r\n            //   - nextName comes before nsecName, in which case nextName is the\r\n            //     zone apez, and deleteName must come after nsecName.\r\n\r\n            if(iter.dnstype == DNSTYPE_NSEC) {\r\n                checkNsecName(iter, nsecName, deleteName, deleteType);\r\n            } else if(iter.dnstype == DNSTYPE_NSEC3) {\r\n                checkNsec3Name(iter, nsecName, deleteName, deleteType);\r\n            } else {\r\n                revert(\"Unrecognised record type\");\r\n            }\r\n\r\n            delete rrsets[keccak256(deleteName)][deleteType];\r\n            return;\r\n        }\r\n        // This should never reach.\r\n        revert();\r\n    }\r\n\r\n    function checkNsecName(RRUtils.RRIterator memory iter, bytes memory nsecName, bytes memory deleteName, uint16 deleteType) private pure {\r\n        uint rdataOffset = iter.rdataOffset;\r\n        uint nextNameLength = iter.data.nameLength(rdataOffset);\r\n        uint rDataLength = iter.nextOffset - iter.rdataOffset;\r\n\r\n        // We assume that there is always typed bitmap after the next domain name\r\n        require(rDataLength > nextNameLength);\r\n\r\n        int compareResult = deleteName.compareNames(nsecName);\r\n        if(compareResult == 0) {\r\n            // Name to delete is on the same label as the NSEC record\r\n            require(!iter.data.checkTypeBitmap(rdataOffset + nextNameLength, deleteType));\r\n        } else {\r\n            // First check if the NSEC next name comes after the NSEC name.\r\n            bytes memory nextName = iter.data.substring(rdataOffset,nextNameLength);\r\n            // deleteName must come after nsecName\r\n            require(compareResult > 0);\r\n            if(nsecName.compareNames(nextName) < 0) {\r\n                // deleteName must also come before nextName\r\n                require(deleteName.compareNames(nextName) < 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkNsec3Name(RRUtils.RRIterator memory iter, bytes memory nsecName, bytes memory deleteName, uint16 deleteType) private view {\r\n        uint16 iterations = iter.data.readUint16(iter.rdataOffset + NSEC3_ITERATIONS);\r\n        uint8 saltLength = iter.data.readUint8(iter.rdataOffset + NSEC3_SALT_LENGTH);\r\n        bytes memory salt = iter.data.substring(iter.rdataOffset + NSEC3_SALT, saltLength);\r\n        bytes32 deleteNameHash = nsec3Digests[iter.data.readUint8(iter.rdataOffset)].hash(salt, deleteName, iterations);\r\n\r\n        uint8 nextLength = iter.data.readUint8(iter.rdataOffset + NSEC3_SALT + saltLength);\r\n        require(nextLength <= 32);\r\n        bytes32 nextNameHash = iter.data.readBytesN(iter.rdataOffset + NSEC3_SALT + saltLength + 1, nextLength);\r\n\r\n        bytes32 nsecNameHash = nsecName.base32HexDecodeWord(1, uint(nsecName.readUint8(0)));\r\n\r\n        if(deleteNameHash == nsecNameHash) {\r\n            // Name to delete is on the same label as the NSEC record\r\n            require(!iter.data.checkTypeBitmap(iter.rdataOffset + NSEC3_SALT + saltLength + 1 + nextLength, deleteType));\r\n        } else {\r\n            // deleteName must come after nsecName\r\n            require(deleteNameHash > nsecNameHash);\r\n            // Check if the NSEC next name comes after the NSEC name.\r\n            if(nextNameHash > nsecNameHash) {\r\n                // deleteName must come also come before nextName\r\n                require(deleteNameHash < nextNameHash);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Returns data about the RRs (if any) known to this oracle with the provided type and name.\r\n     * @param dnstype The DNS record type to query.\r\n     * @param name The name to query, in DNS label-sequence format.\r\n     * @return inception The unix timestamp at which the signature for this RRSET was created.\r\n     * @return inserted The unix timestamp at which this RRSET was inserted into the oracle.\r\n     * @return hash The hash of the RRset that was inserted.\r\n     */\r\n    function rrdata(uint16 dnstype, bytes memory name) public view returns (uint32, uint64, bytes20) {\r\n        RRSet storage result = rrsets[keccak256(name)][dnstype];\r\n        return (result.inception, result.inserted, result.hash);\r\n    }\r\n\r\n    /**\r\n     * @dev Submits a signed set of RRs to the oracle.\r\n     *\r\n     * RRSETs are only accepted if they are signed with a key that is already\r\n     * trusted, or if they are self-signed, and the signing key is identified by\r\n     * a DS record that is already trusted.\r\n     *\r\n     * @param input The signed RR set. This is in the format described in section\r\n     *        5.3.2 of RFC4035: The RRDATA section from the RRSIG without the signature\r\n     *        data, followed by a series of canonicalised RR records that the signature\r\n     *        applies to.\r\n     * @param sig The signature data from the RRSIG record.\r\n     * @param proof The DNSKEY or DS to validate the signature against. Must Already\r\n     *        have been submitted and proved previously.\r\n     */\r\n    function validateSignedSet(bytes memory input, bytes memory sig, bytes memory proof) internal view returns(bytes memory name, bytes memory rrs) {\r\n        require(validProof(input.readName(RRSIG_SIGNER_NAME), proof));\r\n\r\n        uint32 inception = input.readUint32(RRSIG_INCEPTION);\r\n        uint32 expiration = input.readUint32(RRSIG_EXPIRATION);\r\n        uint16 typecovered = input.readUint16(RRSIG_TYPE);\r\n        uint8 labels = input.readUint8(RRSIG_LABELS);\r\n\r\n        // Extract the RR data\r\n        uint rrdataOffset = input.nameLength(RRSIG_SIGNER_NAME) + 18;\r\n        rrs = input.substring(rrdataOffset, input.length - rrdataOffset);\r\n\r\n        // Do some basic checks on the RRs and extract the name\r\n        name = validateRRs(rrs, typecovered);\r\n        require(name.labelCount(0) == labels);\r\n\r\n        // TODO: Check inception and expiration using mod2^32 math\r\n\r\n        // o  The validator's notion of the current time MUST be less than or\r\n        //    equal to the time listed in the RRSIG RR's Expiration field.\r\n        require(expiration > now);\r\n\r\n        // o  The validator's notion of the current time MUST be greater than or\r\n        //    equal to the time listed in the RRSIG RR's Inception field.\r\n        require(inception < now);\r\n\r\n        // Validate the signature\r\n        verifySignature(name, input, sig, proof);\r\n\r\n        return (name, rrs);\r\n    }\r\n\r\n    function validProof(bytes name, bytes memory proof) internal view returns(bool) {\r\n        uint16 dnstype = proof.readUint16(proof.nameLength(0));\r\n        return rrsets[keccak256(name)][dnstype].hash == bytes20(keccak256(proof));\r\n    }\r\n\r\n    /**\r\n     * @dev Validates a set of RRs.\r\n     * @param data The RR data.\r\n     * @param typecovered The type covered by the RRSIG record.\r\n     */\r\n    function validateRRs(bytes memory data, uint16 typecovered) internal pure returns (bytes memory name) {\r\n        // Iterate over all the RRs\r\n        for (RRUtils.RRIterator memory iter = data.iterateRRs(0); !iter.done(); iter.next()) {\r\n            // We only support class IN (Internet)\r\n            require(iter.class == DNSCLASS_IN);\r\n\r\n            if(name.length == 0) {\r\n                name = iter.name();\r\n            } else {\r\n                // Name must be the same on all RRs\r\n                require(name.length == data.nameLength(iter.offset));\r\n                require(name.equals(0, data, iter.offset, name.length));\r\n            }\r\n\r\n            // o  The RRSIG RR's Type Covered field MUST equal the RRset's type.\r\n            require(iter.dnstype == typecovered);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Performs signature verification.\r\n     *\r\n     * Throws or reverts if unable to verify the record.\r\n     *\r\n     * @param name The name of the RRSIG record, in DNS label-sequence format.\r\n     * @param data The original data to verify.\r\n     * @param sig The signature data.\r\n     */\r\n    function verifySignature(bytes name, bytes memory data, bytes memory sig, bytes memory proof) internal view {\r\n        uint signerNameLength = data.nameLength(RRSIG_SIGNER_NAME);\r\n\r\n        // o  The RRSIG RR's Signer's Name field MUST be the name of the zone\r\n        //    that contains the RRset.\r\n        require(signerNameLength <= name.length);\r\n        require(data.equals(RRSIG_SIGNER_NAME, name, name.length - signerNameLength, signerNameLength));\r\n\r\n        // Set the return offset to point at the first RR\r\n        uint offset = 18 + signerNameLength;\r\n\r\n        // Check the proof\r\n        uint16 dnstype = proof.readUint16(proof.nameLength(0));\r\n        if (dnstype == DNSTYPE_DS) {\r\n            require(verifyWithDS(data, sig, offset, proof));\r\n        } else if (dnstype == DNSTYPE_DNSKEY) {\r\n            require(verifyWithKnownKey(data, sig, proof));\r\n        } else {\r\n            revert(\"Unsupported proof record type\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a signed RRSET against an already known public key.\r\n     * @param data The original data to verify.\r\n     * @param sig The signature data.\r\n     * @return True if the RRSET could be verified, false otherwise.\r\n     */\r\n    function verifyWithKnownKey(bytes memory data, bytes memory sig, bytes memory proof) internal view returns(bool) {\r\n        uint signerNameLength = data.nameLength(RRSIG_SIGNER_NAME);\r\n\r\n        // Extract algorithm and keytag\r\n        uint8 algorithm = data.readUint8(RRSIG_ALGORITHM);\r\n        uint16 keytag = data.readUint16(RRSIG_KEY_TAG);\r\n\r\n        for (RRUtils.RRIterator memory iter = proof.iterateRRs(0); !iter.done(); iter.next()) {\r\n            // Check the DNSKEY's owner name matches the signer name on the RRSIG\r\n            require(proof.nameLength(0) == signerNameLength);\r\n            require(proof.equals(0, data, RRSIG_SIGNER_NAME, signerNameLength));\r\n            if (verifySignatureWithKey(iter.rdata(), algorithm, keytag, data, sig)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a signed RRSET against an already known public key.\r\n     * @param data The original data to verify.\r\n     * @param sig The signature data.\r\n     * @param offset The offset from the start of the data to the first RR.\r\n     * @return True if the RRSET could be verified, false otherwise.\r\n     */\r\n    function verifyWithDS(bytes memory data, bytes memory sig, uint offset, bytes memory proof) internal view returns(bool) {\r\n        // Extract algorithm and keytag\r\n        uint8 algorithm = data.readUint8(RRSIG_ALGORITHM);\r\n        uint16 keytag = data.readUint16(RRSIG_KEY_TAG);\r\n\r\n        // Perhaps it's self-signed and verified by a DS record?\r\n        for (RRUtils.RRIterator memory iter = data.iterateRRs(offset); !iter.done(); iter.next()) {\r\n            if (iter.dnstype != DNSTYPE_DNSKEY) {\r\n                return false;\r\n            }\r\n\r\n            bytes memory keyrdata = iter.rdata();\r\n            if (verifySignatureWithKey(keyrdata, algorithm, keytag, data, sig)) {\r\n                // It's self-signed - look for a DS record to verify it.\r\n                return verifyKeyWithDS(iter.name(), keyrdata, keytag, algorithm, proof);\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify some data using a provided key and a signature.\r\n     * @param keyrdata The RDATA section of the key to use.\r\n     * @param algorithm The algorithm ID of the key and signature.\r\n     * @param keytag The keytag from the signature.\r\n     * @param data The data to verify.\r\n     * @param sig The signature to use.\r\n     * @return True iff the key verifies the signature.\r\n     */\r\n    function verifySignatureWithKey(bytes memory keyrdata, uint8 algorithm, uint16 keytag, bytes data, bytes sig) internal view returns (bool) {\r\n        if (algorithms[algorithm] == address(0)) {\r\n            return false;\r\n        }\r\n        // TODO: Check key isn't expired, unless updating key itself\r\n\r\n        // o The RRSIG RR's Signer's Name, Algorithm, and Key Tag fields MUST\r\n        //   match the owner name, algorithm, and key tag for some DNSKEY RR in\r\n        //   the zone's apex DNSKEY RRset.\r\n        if (keyrdata.readUint8(DNSKEY_PROTOCOL) != 3) {\r\n            return false;\r\n        }\r\n        if (keyrdata.readUint8(DNSKEY_ALGORITHM) != algorithm) {\r\n            return false;\r\n        }\r\n        uint16 computedkeytag = computeKeytag(keyrdata);\r\n        if (computedkeytag != keytag) {\r\n            return false;\r\n        }\r\n\r\n        // o The matching DNSKEY RR MUST be present in the zone's apex DNSKEY\r\n        //   RRset, and MUST have the Zone Flag bit (DNSKEY RDATA Flag bit 7)\r\n        //   set.\r\n        if (keyrdata.readUint16(DNSKEY_FLAGS) & DNSKEY_FLAG_ZONEKEY == 0) {\r\n            return false;\r\n        }\r\n\r\n        return algorithms[algorithm].verify(keyrdata, data, sig);\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a key using DS records.\r\n     * @param keyname The DNS name of the key, in DNS label-sequence format.\r\n     * @param keyrdata The RDATA section of the key.\r\n     * @param keytag The keytag of the key.\r\n     * @param algorithm The algorithm ID of the key.\r\n     * @return True if a DS record verifies this key.\r\n     */\r\n    function verifyKeyWithDS(bytes memory keyname, bytes memory keyrdata, uint16 keytag, uint8 algorithm, bytes memory data)\r\n        internal view returns (bool)\r\n    {\r\n        for (RRUtils.RRIterator memory iter = data.iterateRRs(0); !iter.done(); iter.next()) {\r\n            if (data.readUint16(iter.rdataOffset + DS_KEY_TAG) != keytag) {\r\n                continue;\r\n            }\r\n            if (data.readUint8(iter.rdataOffset + DS_ALGORITHM) != algorithm) {\r\n                continue;\r\n            }\r\n\r\n            uint8 digesttype = data.readUint8(iter.rdataOffset + DS_DIGEST_TYPE);\r\n            Buffer.buffer memory buf;\r\n            buf.init(keyname.length + keyrdata.length);\r\n            buf.append(keyname);\r\n            buf.append(keyrdata);\r\n            if (verifyDSHash(digesttype, buf.buf, data.substring(iter.rdataOffset, iter.nextOffset - iter.rdataOffset))) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Attempts to verify a DS record's hash value against some data.\r\n     * @param digesttype The digest ID from the DS record.\r\n     * @param data The data to digest.\r\n     * @param digest The digest data to check against.\r\n     * @return True iff the digest matches.\r\n     */\r\n    function verifyDSHash(uint8 digesttype, bytes data, bytes digest) internal view returns (bool) {\r\n        if (digests[digesttype] == address(0)) {\r\n            return false;\r\n        }\r\n        return digests[digesttype].verify(data, digest.substring(4, digest.length - 4));\r\n    }\r\n\r\n    /**\r\n     * @dev Computes the keytag for a chunk of data.\r\n     * @param data The data to compute a keytag for.\r\n     * @return The computed key tag.\r\n     */\r\n    function computeKeytag(bytes memory data) internal pure returns (uint16) {\r\n        uint ac;\r\n        for (uint i = 0; i < data.length; i += 2) {\r\n            ac += data.readUint16(i);\r\n        }\r\n        ac += (ac >> 16) & 0xFFFF;\r\n        return uint16(ac & 0xFFFF);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"algo\",\"type\":\"address\"}],\"name\":\"setAlgorithm\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dnstype\",\"type\":\"uint16\"},{\"name\":\"name\",\"type\":\"bytes\"}],\"name\":\"rrdata\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"bytes20\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"digest\",\"type\":\"address\"}],\"name\":\"setDigest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"input\",\"type\":\"bytes\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"submitRRSet\",\"outputs\":[{\"name\":\"rrs\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"digests\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"submitRRSets\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"id\",\"type\":\"uint8\"},{\"name\":\"digest\",\"type\":\"address\"}],\"name\":\"setNSEC3Digest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"anchors\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"nsec3Digests\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"algorithms\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"deleteType\",\"type\":\"uint16\"},{\"name\":\"deleteName\",\"type\":\"bytes\"},{\"name\":\"nsec\",\"type\":\"bytes\"},{\"name\":\"sig\",\"type\":\"bytes\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"deleteRRSet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_anchors\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"AlgorithmUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"DigestUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"NSEC3DigestUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"rrset\",\"type\":\"bytes\"}],\"name\":\"RRSetUpdated\",\"type\":\"event\"}]","ContractName":"DNSSECImpl","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000005e00002b000100000e1000244a5c080249aac11d7b6f6446702e54a1607371607a1a41855200fd2ce1cdde32f24e8fb500002b000100000e1000244f660802e06d44b80b8f1d39a95c0b0d7c65d08458e880409bbc683457104237c7f8ec8d0000","Library":"","SwarmSource":"bzzr://ba7e576d602ff4cdd0aaa74544348974d997e15b730a0479c9167d2a08a3abf3"}]}