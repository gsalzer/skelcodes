{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n//@Author Kirin\r\ncontract Infinitestars {\r\n    \r\n    using Player for Player.Map;\r\n    using CommUtils for string;\r\n    using InfinitestarsData for InfinitestarsData.Data;\r\n    using Ball for Ball.Data[];\r\n    uint256 public constant WITHDRAWAL_AUTO_BUY_COUNT = 1;\r\n    uint256 public constant BALL_PRICE = 0.5 ether;\r\n    uint256 public constant REGESTER_FEE = 0.02 ether;\r\n    uint256 public constant REGISTER_FREE_COUNT = 100;\r\n    InfinitestarsData.Data private data;\r\n    uint256 private regesterCount =0;\r\n    bool private gameEnabled = false;\r\n\r\n\r\n    function enableGame() public{\r\n        require(Player.isAdmin(msg.sender),\"it`s not admin\");\r\n        gameEnabled = true;\r\n    }\r\n    \r\n    modifier enabling(){\r\n        require(gameEnabled,\"game not start\");\r\n        _;\r\n    }\r\n\r\n    function buyBall(uint256 count) enabling public payable  {\r\n        (address picker,uint256 ammount) =data.buyBall(count,msg.sender);\r\n        broadcastBuy(msg.sender,count,ammount,picker);\r\n    }\r\n    \r\n    function broadcastBuy(address adr,uint256 count,uint256 starsPickValue,address picker) private {\r\n        bytes32 b = data.players.getName(adr);\r\n        emit OnBuyed (adr,b,count,starsPickValue,picker);\r\n    }\r\n    \r\n    function buyBallWithReferrer(uint256 count,string referrer) enabling public payable  {\r\n       (address picker,uint256 ammount) =data.buyBallWithReferrer(count,msg.sender,referrer);\r\n        broadcastBuy(msg.sender,count,ammount,picker);\r\n    }    \r\n\r\n    function getInit()  public view returns(\r\n        bytes32, //0 your name\r\n        bytes32, //1  refername\r\n        uint256,  //2 currentIdx\r\n        uint256,    //3 shourt Prize\r\n        uint256,     //4 the player gains\r\n        uint256,     //5 refferSumReward\r\n        bool ,      //6 played\r\n        uint256 ,    //7 blance\r\n        uint256     //8  Your live ball\r\n    \r\n    ){\r\n       // (uint256 count,uint256 firstAt,uint256 lastAt, uint256 payOutCount,uint256 nextPayOutAt) = data.getOutInfoOfSender();\r\n        return (\r\n            data.players.getName(),\r\n            data.players.getReferrerName(msg.sender),\r\n            data.currentIdx,\r\n            data.shortPrize,\r\n            data.players.getAmmount(msg.sender),\r\n            data.referralbonusMap[msg.sender],\r\n            data.playedMap[msg.sender],\r\n            address(this).balance,\r\n            data.balls.countByOwner(msg.sender)\r\n        );\r\n    }\r\n    \r\n    \r\n    function getOutInfo(uint256 startIdx,uint256 pageSize) public view returns(\r\n            uint256 scanCount,\r\n            uint256 selfCount,\r\n            uint256 firstAt,\r\n            uint256 lastAt,\r\n            uint256 payOutCount,\r\n            uint256 nextPayOutAt\r\n        ){\r\n        return data.getOutInfo(startIdx,pageSize);\r\n    }\r\n    \r\n\r\n    function getPayedInfo(uint256 startIdx,uint256 pageSize) public view returns(\r\n            uint256 scanCount,\r\n            uint256 selfCount,\r\n            uint256 firstAt,\r\n            uint256 lastAt,\r\n            uint256 payOutCount,\r\n            uint256 payedCount\r\n        ){\r\n        return data.getPayedInfo(startIdx,pageSize);\r\n    }    \r\n    \r\n    \r\n    function getOutInfoOfSender()  public view returns(\r\n            uint256 , //your out ball\r\n            uint256 , //firstAt\r\n            uint256 ,  //lastAt      \r\n            uint256,   //  payOutCount,\r\n            uint256 ,   //   nextPayOutAt    \r\n            uint256     // payedCount\r\n        ){\r\n        return data.getOutInfoOfSender();\r\n    }      \r\n\r\n    \r\n    function outBall() enabling public {\r\n        data.toPayedBall();\r\n        data.toOutBall();\r\n    }\r\n    \r\n    function listLiveBall() public view returns(\r\n        uint256[] , //index;\r\n        address[] , //owner;\r\n        uint256[] , //outCount;\r\n        uint[]  //createAt;\r\n        ){\r\n        return listBall(data.balls);\r\n    }\r\n    \r\n    function listBall(Ball.Data[] list) private pure returns(\r\n        uint256[] indexs, //index;\r\n        address[] owners, //owner;\r\n        uint256[] outCounts, //outCount;\r\n        uint[] createAts //createAt;\r\n        ){\r\n        indexs = new uint256[](list.length);    \r\n        owners = new address[](list.length);    \r\n        outCounts = new uint256[](list.length);    \r\n        createAts = new uint[](list.length);    \r\n        for(uint256 i=0;i<list.length;i++){\r\n            indexs[i]=list[i].index;\r\n            owners[i]=list[i].owner;\r\n            outCounts[i]=list[i].outCount;\r\n            createAts[i]=list[i].createAt;\r\n        }\r\n    }\r\n  \r\n    \r\n    function registerName(string  name) enabling public payable {\r\n        require(msg.value >= REGESTER_FEE,\"fee not enough\");\r\n        require(data.playedMap[msg.sender] ,\"it`s not play\");\r\n        regesterCount++;\r\n        data.registerName(name);\r\n        if(REGISTER_FREE_COUNT>=regesterCount){\r\n            data.players.deposit(msg.sender,REGESTER_FEE);\r\n        }\r\n    }    \r\n    \r\n    function isEmptyName(string _n) public view returns(bool){\r\n        return data.players.isEmptyName(_n.nameFilter());\r\n    }    \r\n    \r\n    \r\n    function withdrawalBuy(uint256 ammount) enabling public payable{\r\n        \r\n        address self = msg.sender;\r\n        uint256 fee = CommUtils.mulRate(ammount,1);\r\n        uint256 gains = data.players.getAmmount(msg.sender);\r\n        uint256 autoPayA = WITHDRAWAL_AUTO_BUY_COUNT*BALL_PRICE;\r\n        ammount-= fee;\r\n        require(ammount<=gains ,\"getAmmount is too low \");\r\n        //require(data.balls.countByOwner(self)>0 ,\"must has live ball \");\r\n        require(gains >= autoPayA,\"gains >= autoPayA\");\r\n        require(ammount>= autoPayA,\"ammount>= ammount\");\r\n        data.players.transferAuthor(fee);\r\n        ammount -= autoPayA;\r\n        data.buyBall(WITHDRAWAL_AUTO_BUY_COUNT,self);\r\n        uint256 contractBlc = address(this).balance;\r\n        bool b =false;\r\n        if(contractBlc >= ammount){\r\n            data.players.minus(self,ammount);\r\n            self.transfer(ammount);\r\n            b= true;\r\n        }else if(ammount>=BALL_PRICE){\r\n            uint256 mod = ammount % BALL_PRICE;\r\n            uint256 count = (ammount - mod) / BALL_PRICE;\r\n            data.buyBall(count,self);\r\n            data.players.deposit(msg.sender,mod);\r\n            b= true;\r\n        }        \r\n        emit OnWithdrawaled (self,ammount,b); \r\n    }\r\n    \r\n\r\n    event OnBuyed(\r\n        address buyer,\r\n        bytes32 buyerName,\r\n        uint256 count,\r\n        uint256 starsPickValue,\r\n        address picker\r\n    );\r\n    \r\n    event OnWithdrawaled(\r\n        address who,\r\n        uint256 ammount,\r\n        bool ok\r\n    );\r\n    \r\n    \r\n\r\n}\r\n\r\nlibrary Ball {\r\n    \r\n    using CommUtils for CommUtils.QueueIdx;\r\n    \r\n    struct Data{\r\n        uint64  index;\r\n        uint64  createAt;\r\n        address owner;\r\n        uint128  outCount;\r\n    }\r\n    \r\n    struct Queue{\r\n        CommUtils.QueueIdx queueIdx;\r\n        mapping(uint256 => Data) map;\r\n    }\r\n    \r\n    function lifo(Data[] storage ds,Data ind) internal  returns(Data  ans){\r\n        ans = ds[0];\r\n        for(uint256 i=0;i<ds.length-1;i++){\r\n            Data storage nd = ds[i+1];\r\n            ds[i] = nd;\r\n        }\r\n        ds[ds.length-1] = ind;\r\n    }\r\n    \r\n    function getByIndex(Data[] storage ds,uint256 idx) internal view returns(Data storage ) {\r\n        for(uint256 i=0;i<ds.length;i++){\r\n            Data storage d = ds[i];\r\n            if(idx ==d.index){\r\n                return d;\r\n            }\r\n        }       \r\n        revert(\"not find getByIndex Ball\");\r\n    }\r\n    \r\n    function isBrandNew(Data storage d) internal view returns(bool){\r\n        return d.owner == address(0);\r\n    }\r\n    \r\n    function replace(Data storage tar,Data  sor) internal {\r\n        tar.index = sor.index;\r\n        tar.owner = sor.owner;\r\n        tar.outCount = sor.outCount;\r\n        tar.createAt = sor.createAt;\r\n    }\r\n    \r\n    function removeByIndex(Data[] storage array,uint256 index) internal {\r\n        if (index >= array.length) return;\r\n\r\n        for (uint256 i = index; i<array.length-1; i++){\r\n            array[i] = array[i+1];\r\n        }\r\n        delete array[array.length-1];\r\n        array.length--;\r\n    }\r\n    \r\n    \r\n    function removeByOwner(Data[] storage ds,address owner,uint256 count) internal{\r\n        for(uint256 i=0;i<ds.length;i++){\r\n            if( ds[i].owner == owner ) {\r\n                removeByIndex(ds,i);\r\n                i--;\r\n                count--;\r\n            }\r\n            if(count ==0) return;\r\n        }\r\n        revert(\"removeByOwner count not = 0\");\r\n    }\r\n    \r\n    function countByOwner(Data[] storage ds,address owner) internal view returns(uint256 ans){\r\n        for(uint256 i=0;i<ds.length;i++){\r\n            if( ds[i].owner == owner ) {\r\n                ans++;\r\n            }\r\n        }        \r\n    }\r\n    \r\n    \r\n\r\n    function getEnd(Queue storage q)  internal view returns(uint256 ){\r\n            return q.queueIdx.getEnd();\r\n    }        \r\n    \r\n    function getWishEnd(Queue storage q,uint256 wishSize)  internal view returns(uint256 ){\r\n        return q.queueIdx.getWishEnd(wishSize);\r\n    }    \r\n    \r\n    function getRealIdx(Queue storage q,uint256 index) internal view  returns(uint256 ){\r\n        return q.queueIdx.getRealIdx(index);\r\n    }\r\n    \r\n    function get(Queue storage q,uint256 index) internal view returns(Data ){\r\n        return q.map[getRealIdx(q,index)];\r\n    }\r\n    \r\n    function offer(Queue storage q,Data b) internal {\r\n        uint256 lastIdx= q.queueIdx.offer();\r\n        q.map[getRealIdx(q,lastIdx)] = Data({\r\n            index :b.index,\r\n            owner : b.owner,\r\n            outCount : b.outCount,\r\n            createAt : b.createAt\r\n        });\r\n    }\r\n    \r\n    function removeAtStart(Queue storage q,uint256 count)  internal{\r\n        (uint256 start,uint256 end) = q.queueIdx.removeAtStart(count);\r\n        for(uint256 i=start;i<end;i++){\r\n            delete q.map[i];\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\nlibrary CommUtils{\r\n\r\n \r\n    struct QueueIdx{\r\n        uint256 startIdx;\r\n        uint256 size ;\r\n    }\r\n\r\n    \r\n\r\n    function random(uint256 max,uint256 mixed) public view returns(uint256){\r\n        uint256 lastBlockNumber = block.number - 1;\r\n        uint256 hashVal = uint256(blockhash(lastBlockNumber));\r\n        hashVal += 19*uint256(block.coinbase);\r\n        hashVal += 17*mixed;\r\n        hashVal += 13*uint256(block.difficulty);\r\n        hashVal += 11*uint256(block.gaslimit );\r\n        hashVal += 7*uint256(now );\r\n        hashVal += 3*uint256(tx.origin);\r\n        return uint256(hashVal % max);\r\n    } \r\n\r\n    function mulRate(uint256 tar,uint256 rate) public pure returns (uint256){\r\n        return tar *rate / 100;\r\n    }  \r\n    \r\n    \r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }    \r\n    \r\n\r\n    \r\n    function getEnd(QueueIdx storage q)  internal view returns(uint256 ){\r\n            return q.startIdx + q.size;\r\n    }        \r\n    \r\n    function getWishEnd(QueueIdx storage q,uint256 wishSize)  internal view returns(uint256 ){\r\n        if(q.size > wishSize){\r\n            return q.startIdx + wishSize;\r\n        }else{\r\n            return q.startIdx + q.size;\r\n        }\r\n    }    \r\n    \r\n    function getRealIdx(QueueIdx storage q,uint256 index) internal view  returns(uint256 ){\r\n        uint256 realIdx = q.startIdx + index;\r\n        require(getEnd(q)>realIdx,\"getEnd()>q.startIdx+idx\");\r\n        return realIdx;\r\n    }\r\n    \r\n    function offer(QueueIdx storage q) internal returns (uint256 lastIdx) {\r\n        lastIdx= q.size ++;\r\n    }\r\n    \r\n    function removeAtStart(QueueIdx storage q,uint256 count)  internal returns(uint256 start ,  uint256 end) {\r\n        require(q.size >= count ,\"getSize(q) >= count\");\r\n        start = q.startIdx;\r\n        end = getWishEnd(q,count);\r\n\r\n        q.startIdx += count;\r\n        q.size -= count;\r\n        if(q.size == 0){\r\n            q.startIdx = 0;\r\n        }\r\n        \r\n    }    \r\n    \r\n    \r\n}\r\n\r\n\r\n\r\nlibrary InfinitestarsData {\r\n    \r\n\r\n    using Ball for Ball.Data[];\r\n    using Ball for Ball.Queue;\r\n    using Ball for Ball.Data;\r\n    using Player for Player.Map;\r\n    using CommUtils for string;\r\n    using CommUtils for CommUtils.QueueIdx;\r\n    \r\n    \r\n    uint256 public constant  LIVE_BALL_COUNT = 3;\r\n    uint256 public constant BALL_PRICE = 0.5 ether;\r\n    uint256 public constant FEE = BALL_PRICE /100;\r\n    uint256 public constant OUT_LIMT = 2;\r\n    uint256 public constant SHORT_PRIZE_PLUS = BALL_PRICE * 3 / 100;\r\n    uint256 public constant LEVEL_1_REWARD = BALL_PRICE * 10 /100;\r\n    uint256 public constant LEVEL_2_REWARD = BALL_PRICE * 3 /100;\r\n    uint256 public constant LEVEL_3_REWARD = BALL_PRICE * 2 /100;\r\n    uint256 public constant MAINTTAIN_FEE =  BALL_PRICE * 1 /100;\r\n    uint256 public constant OUT_TIME = 60*60*24*2;\r\n    uint256 public constant PAY_TIME = 60*60*24*1;\r\n    uint256 public constant AIRDROP_RATE_1000 = 5;\r\n    // uint256 public constant OUT_TIME = 8*60;\r\n    // uint256 public constant PAY_TIME = 4*60;\r\n    \r\n    uint256 public constant QUEUE_BATCH_SIZE = 20;\r\n    //uint256 public constant OUT_TIME = 60;\r\n    uint256 public constant PAY_PROFIT = 0.085 ether;\r\n    //uint256 public constant PAY_AMMOUNT = (BALL_PRICE* 40/100) - FEE;\r\n\r\n    \r\n    struct Data{\r\n        Ball.Data[] balls ;\r\n        Ball.Queue outingBalls ;\r\n        Ball.Queue payedQueue ;\r\n        Player.Map players;\r\n        uint256 shortPrize;\r\n        uint256 currentIdx;\r\n        mapping(address => bool) playedMap;\r\n        mapping(address => uint256) playBallCountMap;\r\n        mapping(address=> uint256 ) referralbonusMap;  \r\n        \r\n        bytes32  ranHash;\r\n        uint256  blockCalled;\r\n        \r\n        \r\n        \r\n        CommUtils.QueueIdx adQueueIdx;\r\n        mapping(uint256=>uint256) adCountMap;\r\n        mapping(uint256=>address) adOwnerMap;\r\n        \r\n    }\r\n    \r\n\r\n    function getOutInfo(Data storage d,uint256 startIdx,uint256 pageSize) internal view returns(\r\n            uint256 scanCount,\r\n            uint256 selfCount,\r\n            uint256 firstAt,\r\n            uint256 lastAt,\r\n            uint256 payOutCount,\r\n            uint256 nextPayOutAt\r\n        ){\r\n        uint256 end = d.outingBalls.getWishEnd(startIdx+pageSize);\r\n            \r\n        for(uint256 i=startIdx;i<end;i++){\r\n            Ball.Data storage ob = d.outingBalls.map[i];  \r\n            if(ob.owner == msg.sender){\r\n                if(firstAt==0  ||  ob.createAt<firstAt){\r\n                    firstAt = ob.createAt;\r\n                }\r\n                if(lastAt == 0 || ob.createAt > lastAt){\r\n                    lastAt = ob.createAt;\r\n                }\r\n                if( (now - ob.createAt) > PAY_TIME ){\r\n                    payOutCount ++;\r\n                }else{\r\n                  if(nextPayOutAt==0) nextPayOutAt = ob.createAt;\r\n                }\r\n                selfCount++;\r\n            }\r\n            scanCount++;\r\n        }  \r\n        \r\n        firstAt = now - firstAt;\r\n        lastAt = now - lastAt;\r\n        nextPayOutAt = now - nextPayOutAt;\r\n    }\r\n    \r\n    function getPayedInfo(Data storage d,uint256 startIdx,uint256 pageSize) internal view returns(\r\n            uint256 scanCount,\r\n            uint256 selfCount,\r\n            uint256 firstAt,\r\n            uint256 lastAt,\r\n            uint256 payOutCount,\r\n            uint256 payedCount\r\n        ){\r\n            \r\n        uint256 end = d.payedQueue.getWishEnd(startIdx+pageSize);\r\n        for(uint256 i=startIdx;i<end;i++){\r\n            Ball.Data storage ob = d.payedQueue.map[i];  \r\n            if(ob.owner == msg.sender){\r\n                if(firstAt==0  ||  ob.createAt<firstAt){\r\n                    firstAt = ob.createAt;\r\n                }\r\n                if(lastAt == 0 || ob.createAt > lastAt){\r\n                    lastAt = ob.createAt;\r\n                }\r\n                payOutCount ++;\r\n                payedCount++;\r\n                selfCount++;\r\n            }\r\n            scanCount++;\r\n        }         \r\n         \r\n        firstAt = now - firstAt;\r\n        lastAt = now - lastAt;\r\n    }    \r\n\r\n    function getOutInfoOfSender(Data storage d) internal view returns(\r\n            uint256 count,\r\n            uint256 firstAt,\r\n            uint256 lastAt,\r\n            uint256 payOutCount,\r\n            uint256 nextPayOutAt,\r\n            uint256 payedCount\r\n        ){\r\n        // (uint256 stI , uint256 endI ) = d.outingBalls.getRange();    \r\n        for(uint256 i=d.outingBalls.queueIdx.startIdx;i<d.outingBalls.getEnd();i++){\r\n            Ball.Data storage ob = d.outingBalls.map[i];  \r\n            if(ob.owner == msg.sender){\r\n                if(firstAt==0  ||  ob.createAt<firstAt){\r\n                    firstAt = ob.createAt;\r\n                }\r\n                if(lastAt == 0 || ob.createAt > lastAt){\r\n                    lastAt = ob.createAt;\r\n                }\r\n                if( (now - ob.createAt) > PAY_TIME ){\r\n                    payOutCount ++;\r\n                }else{\r\n                   if(nextPayOutAt==0) nextPayOutAt = ob.createAt;\r\n                }\r\n                count++;\r\n            }\r\n        }\r\n         for( i=d.payedQueue.queueIdx.startIdx;i<d.payedQueue.getEnd();i++){\r\n            ob = d.payedQueue.map[i];  \r\n            if(ob.owner == msg.sender){\r\n                if(firstAt==0  ||  ob.createAt<firstAt){\r\n                    firstAt = ob.createAt;\r\n                }\r\n                if(lastAt == 0 || ob.createAt > lastAt){\r\n                    lastAt = ob.createAt;\r\n                }\r\n                payOutCount ++;\r\n                payedCount++;\r\n                count++;\r\n            }\r\n        }         \r\n         \r\n        firstAt = now - firstAt;\r\n        lastAt = now - lastAt;\r\n        nextPayOutAt = now - nextPayOutAt;\r\n    }\r\n\r\n    function buyBallWithReferrer(Data storage d,uint256 count,address owner,string referrer) internal returns (address,uint256) {\r\n        require(!d.playedMap[msg.sender] ,\"it`s not play game player can apply referrer\");\r\n        d.players.applyReferrer(referrer);\r\n        return buyBall(d,count,owner);\r\n    }\r\n    \r\n    function buyBall(Data storage d,uint256 count,address owner) internal returns (address,uint256) {\r\n        d.players.withdrawalFee(count *BALL_PRICE);\r\n        for(uint256 i=0;i<count;i++){\r\n            claimBall(d,owner);            \r\n        }\r\n        d.playedMap[owner] = true;\r\n        d.playBallCountMap[owner] += count;\r\n        d.players.transferAuthorAll();\r\n        toPayedBall(d);\r\n        toOutBall(d);\r\n        return setupAirdrop(d,owner,count);\r\n    }\r\n    \r\n\r\n    \r\n    function setupAirdrop(Data storage d,address owner,uint256 count) private returns(address winner,uint256 ammount)  {\r\n        if(d.blockCalled < block.number && d.adQueueIdx.size > 10){\r\n            winner = drawWinner(d);\r\n            if(winner != address(0)){\r\n                ammount = d.shortPrize;\r\n                d.players.deposit(msg.sender,d.shortPrize);\r\n                d.shortPrize = 0;\r\n            }\r\n            d.blockCalled = block.number + 3 + CommUtils.random(6,1);\r\n        }\r\n        d.ranHash =  blockhash(block.number);\r\n        offerAirdrop(d,owner,count);\r\n        \r\n    }\r\n    \r\n    function offerAirdrop(Data storage d,address owner , uint256 count) internal {\r\n        uint256 lastIdx= d.adQueueIdx.offer();\r\n        d.adOwnerMap[lastIdx] = owner;\r\n        d.adCountMap[lastIdx] = count;\r\n    }    \r\n    \r\n    function drawWinner(Data storage d) private returns(address owner) {\r\n        uint256 end = d.adQueueIdx.getWishEnd(QUEUE_BATCH_SIZE);\r\n        uint256 rmCount = 0;\r\n        uint256 ranV = random(d,1000);\r\n        for(uint256 i=d.adQueueIdx.startIdx;i<end;i++){\r\n            rmCount++;\r\n           uint256 threshold = d.adCountMap[i] * AIRDROP_RATE_1000 ;\r\n           if(threshold>ranV){\r\n               owner = d.adOwnerMap[i];\r\n               break;\r\n           }\r\n        }\r\n        (uint256 start,uint256 endB) = d.adQueueIdx.removeAtStart(rmCount);\r\n        for(uint256 j=start;j<endB;j++){\r\n            delete d.adCountMap[j];\r\n            delete d.adOwnerMap[j];\r\n        }\r\n    }\r\n    \r\n  \r\n    \r\n    function random(Data storage d,uint256 limit) internal view returns(uint256) {\r\n        bytes32 hash2 = blockhash(d.blockCalled);\r\n        bytes32 hash = keccak256(abi.encodePacked(d.ranHash, hash2));\r\n        uint256 ranV = uint256(hash) + CommUtils.random(now,5);\r\n        return ranV % limit;\r\n    }    \r\n    \r\n    function claimBall(Data storage d,address _owner) private{\r\n        Ball.Data memory b = Ball.Data({\r\n            index : uint64( d.currentIdx++),\r\n            owner : _owner,\r\n            outCount : 0,\r\n            createAt :uint64( now)\r\n        });\r\n        require(d.balls.length <= LIVE_BALL_COUNT ,\"live ball is over 3\");\r\n        if(d.balls.length <LIVE_BALL_COUNT){\r\n            d.balls[d.balls.length++] = b;\r\n        }else{\r\n            Ball.Data memory outb= lifo(d,b);\r\n            revive(d,outb);\r\n        }\r\n        distributeReward(d,_owner);\r\n        \r\n    }\r\n    \r\n    function distributeReward(Data storage d,address _owner) private {\r\n        d.players.depositAuthor(FEE);\r\n        d.players.depositAuthor(MAINTTAIN_FEE);\r\n        d.shortPrize += SHORT_PRIZE_PLUS;\r\n        address l1 = d.players.getReferrer(_owner);\r\n        if(l1 == address(0)){\r\n            d.players.depositAuthor(LEVEL_1_REWARD + LEVEL_2_REWARD + LEVEL_3_REWARD);\r\n            return ;\r\n        }\r\n        depositReferrer(d,l1,LEVEL_1_REWARD);\r\n        address l2 = d.players.getReferrer(l1);\r\n        if(l2 == address(0)){\r\n            d.players.depositAuthor( LEVEL_2_REWARD + LEVEL_3_REWARD);\r\n             return ;\r\n        }\r\n        depositReferrer(d,l2,LEVEL_2_REWARD);\r\n        address l3 = d.players.getReferrer(l2);\r\n        if(l3 == address(0)){\r\n            d.players.depositAuthor(  LEVEL_3_REWARD);\r\n            return;\r\n        }\r\n        depositReferrer(d,l3,LEVEL_3_REWARD);\r\n    }\r\n    \r\n    function depositReferrer(Data storage d,address a,uint256 v) private {\r\n        d.players.deposit(a,v);\r\n        d.referralbonusMap[a]+= v;\r\n    }\r\n    \r\n    function lifo(Data storage d,Ball.Data  inb) private returns(Ball.Data ans){\r\n        ans = d.balls.lifo(inb);\r\n        d.players.depositAuthor(FEE);\r\n        //d.players.deposit(ans.owner,PAY_AMMOUNT);\r\n    }\r\n    \r\n    \r\n    function revive(Data storage d,Ball.Data b) private{\r\n        require(b.outCount<=OUT_LIMT,\"outCount>OUT_LIMT\");\r\n         if(b.outCount==OUT_LIMT){\r\n            d.players.deposit(b.owner,PAY_PROFIT);\r\n            b.createAt = uint64(now);\r\n            //Ball.Data storage outP= d.outingBalls[d.outingBalls.length ++];\r\n            d.outingBalls.offer(b);\r\n            //outP.replace(b);\r\n        }else{\r\n            b.outCount ++;\r\n            b.index = uint64( d.currentIdx++);\r\n            Ball.Data memory newOut  = lifo(d,b);\r\n            revive(d,newOut);\r\n        }\r\n    }\r\n    \r\n    function registerName(Data storage d,string  name) internal  {\r\n        require(d.playedMap[msg.sender] ,\"it`s  play game player can registerName\");\r\n        require(msg.value >= 0.02 ether);\r\n        require(d.players.getName()==\"\");\r\n        d.players.registerName(name.nameFilter());\r\n    }    \r\n    \r\n    \r\n    function toOutBall(Data storage d) internal{\r\n        \r\n        uint256 end  = d.payedQueue.getWishEnd(QUEUE_BATCH_SIZE);\r\n        uint256 rmCount = 0;\r\n        for(uint256 i=d.payedQueue.queueIdx.startIdx;i<end;i++){\r\n            Ball.Data storage b = d.payedQueue.map[i];\r\n\r\n            if(now - b.createAt> OUT_TIME ){\r\n                address owner = b.owner;\r\n                d.playBallCountMap[owner]--;\r\n                rmCount++;\r\n                removePlayerBallEmpty(d,owner);\r\n            }\r\n        }\r\n        d.payedQueue.removeAtStart( rmCount);\r\n    }\r\n    \r\n    function toPayedBall(Data storage d) internal{\r\n        uint256 end = d.outingBalls.getWishEnd(QUEUE_BATCH_SIZE);\r\n        uint256 rmCount = 0;\r\n        for(uint256 i=d.outingBalls.queueIdx.startIdx;i<end;i++){\r\n            Ball.Data storage b = d.outingBalls.map[i];\r\n            if(now - b.createAt >= PAY_TIME ){\r\n                d.players.deposit(b.owner,BALL_PRICE);\r\n                rmCount++;\r\n                d.payedQueue.offer(b);\r\n            }\r\n        }   \r\n        d.outingBalls.removeAtStart(rmCount);\r\n    }\r\n    \r\n    function removePlayerBallEmpty(Data storage d,address addr) private{\r\n        uint256 allBallCount = d.playBallCountMap[addr] ;\r\n        if(allBallCount <= 0){\r\n            d.players.remove(addr);\r\n            delete d.playedMap[addr];\r\n        }\r\n    }\r\n    \r\n}\r\n\r\n\r\nlibrary Player{\r\n\r\n    using CommUtils for string;\r\n\r\n    address public constant AUTHOR =  0x001C9b3392f473f8f13e9Eaf0619c405AF22FC26a7;\r\n    address public constant DIRECTOR = 0x43beFdf21996f323E3cE6552452F11Efb7Dc1e7D;\r\n    address public constant DEV_BACKUP = 0x00e37c73dbe66e92149092a85be6c32e23251ed0af;\r\n    uint256 public constant AUTHOR_RATE = 8;\r\n    \r\n    struct Map{\r\n        mapping(address=>uint256) map;\r\n        mapping(address=>address) referrerMap;\r\n        mapping(address=>bytes32) addrNameMap;\r\n        mapping(bytes32=>address) nameAddrMap;\r\n    }\r\n    \r\n    function remove(Map storage ps,address adr) internal{\r\n        transferAuthor(ps,ps.map[adr]);\r\n        delete ps.map[adr];\r\n        bytes32 b = ps.addrNameMap[adr];\r\n        delete ps.nameAddrMap[b];\r\n        delete ps.addrNameMap[adr];\r\n    }\r\n    \r\n    function deposit(Map storage  ps,address adr,uint256 v) internal returns(uint256) {\r\n       ps.map[adr]+=v;\r\n        return v;\r\n    }\r\n\r\n    function isAdmin(address addr) internal pure returns (bool){\r\n        if(addr == AUTHOR) return true;\r\n        if(addr == DIRECTOR) return true;\r\n        if(addr == DEV_BACKUP) return true;\r\n        return false;\r\n    }\r\n\r\n    function depositAuthor(Map storage  ps,uint256 v) internal returns(uint256) {\r\n        uint256 devFee = CommUtils.mulRate(v,AUTHOR_RATE);\r\n        uint256 dFee =  v- devFee;\r\n        deposit(ps,AUTHOR,devFee);\r\n        deposit(ps,DIRECTOR,dFee);\r\n        return v;\r\n    }\r\n    \r\n    function transferAuthorAll(Map storage  ps) internal{\r\n        transferSafe(ps,AUTHOR, withdrawalAll(ps,AUTHOR));\r\n        transferSafe(ps,DIRECTOR, withdrawalAll(ps,DIRECTOR));\r\n    }\r\n    \r\n    function transferSafe(Map storage  ps,address addr,uint256 v) internal {\r\n        \r\n        if(address(this).balance>=v){\r\n            addr.transfer(v);\r\n        }else{\r\n            uint256 less = v - address(this).balance;\r\n            addr.transfer( address(this).balance);\r\n            deposit(ps,addr,less);\r\n        }\r\n    }\r\n    \r\n    //depositAuthor\r\n    function transferAuthor(Map storage  ps,uint256 v) internal returns(uint256) {\r\n        uint256 devFee = CommUtils.mulRate(v,AUTHOR_RATE);\r\n        uint256 dFee =  v- devFee;\r\n        transferSafe(ps,AUTHOR,devFee);\r\n        transferSafe(ps,DIRECTOR,dFee);\r\n        return v;\r\n    }\r\n\r\n    function minus(Map storage  ps,address adr,uint256 num) internal  {\r\n        uint256 sum = ps.map[adr];\r\n        if(sum==num){\r\n             withdrawalAll(ps,adr);\r\n        }else{\r\n            require(sum > num);\r\n            ps.map[adr] = sum-num;\r\n        }\r\n    }\r\n    \r\n    function minusAndTransfer(Map storage  ps,address adr,uint256 num) internal  {\r\n        minus(ps,adr,num);\r\n        transferSafe(ps,adr,num);\r\n    }    \r\n    \r\n    function withdrawalAll(Map storage  ps,address adr) public returns(uint256) {\r\n        uint256 sum = ps.map[adr];\r\n        delete ps.map[adr];\r\n        return sum;\r\n    }\r\n    \r\n    function getAmmount(Map storage ps,address adr) public view returns(uint256) {\r\n        return ps.map[adr];\r\n    }\r\n    \r\n    function registerName(Map storage ps,bytes32 _name)internal  {\r\n        require(ps.nameAddrMap[_name] == address(0) );\r\n        ps.nameAddrMap[_name] = msg.sender;\r\n        ps.addrNameMap[msg.sender] = _name;\r\n        depositAuthor(ps,msg.value);\r\n    }\r\n    \r\n    function isEmptyName(Map storage ps,bytes32 _name) public view returns(bool) {\r\n        return ps.nameAddrMap[_name] == address(0);\r\n    }\r\n    \r\n    function getByName(Map storage ps,bytes32 _name)public view returns(address) {\r\n        return ps.nameAddrMap[_name] ;\r\n    }\r\n    \r\n    function getName(Map storage ps) public view returns(bytes32){\r\n        return ps.addrNameMap[msg.sender];\r\n    }\r\n    \r\n    function getName(Map storage ps,address adr) public view returns(bytes32){\r\n        return ps.addrNameMap[adr];\r\n    }    \r\n    \r\n    function getNameByAddr(Map storage ps,address adr) public view returns(bytes32){\r\n        return ps.addrNameMap[adr];\r\n    }    \r\n    \r\n    function getReferrer(Map storage ps,address adr)public view returns(address){\r\n        address refA = ps.referrerMap[adr];\r\n        bytes32 b= ps.addrNameMap[refA];\r\n        return b.length == 0 ? getReferrer(ps,refA) : refA;\r\n    }\r\n    \r\n    function getReferrerName(Map storage ps,address adr)public view returns(bytes32){\r\n        return getNameByAddr(ps,getReferrer(ps,adr));\r\n    }\r\n    \r\n    function setReferrer(Map storage ps,address self,address referrer)internal {\r\n         ps.referrerMap[self] = referrer;\r\n    }\r\n    \r\n    function applyReferrer(Map storage ps,string referrer)internal {\r\n        bytes32 rbs = referrer.nameFilter();\r\n        address referrerAdr = getByName(ps,rbs);\r\n        require(referrerAdr != address(0),\"referrerAdr is null\");\r\n        require(referrerAdr != msg.sender ,\"referrerAdr is self \");\r\n        setReferrer(ps,msg.sender,referrerAdr);\r\n    }    \r\n    \r\n    function withdrawalFee(Map storage ps,uint256 fee) public returns (uint256){\r\n        if(msg.value > 0){\r\n            require(msg.value == fee,\"msg.value != fee\");\r\n            return fee;\r\n        }\r\n        require(getAmmount(ps,msg.sender)>=fee ,\"players.getAmmount(msg.sender)<fee\");\r\n        minus(ps,msg.sender,fee);\r\n        return fee;\r\n    }   \r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"registerName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_n\",\"type\":\"string\"}],\"name\":\"isEmptyName\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"string\"}],\"name\":\"buyBallWithReferrer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REGISTER_FREE_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"outBall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInit\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"buyBall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOutInfoOfSender\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIdx\",\"type\":\"uint256\"},{\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getOutInfo\",\"outputs\":[{\"name\":\"scanCount\",\"type\":\"uint256\"},{\"name\":\"selfCount\",\"type\":\"uint256\"},{\"name\":\"firstAt\",\"type\":\"uint256\"},{\"name\":\"lastAt\",\"type\":\"uint256\"},{\"name\":\"payOutCount\",\"type\":\"uint256\"},{\"name\":\"nextPayOutAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_AUTO_BUY_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REGESTER_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIdx\",\"type\":\"uint256\"},{\"name\":\"pageSize\",\"type\":\"uint256\"}],\"name\":\"getPayedInfo\",\"outputs\":[{\"name\":\"scanCount\",\"type\":\"uint256\"},{\"name\":\"selfCount\",\"type\":\"uint256\"},{\"name\":\"firstAt\",\"type\":\"uint256\"},{\"name\":\"lastAt\",\"type\":\"uint256\"},{\"name\":\"payOutCount\",\"type\":\"uint256\"},{\"name\":\"payedCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BALL_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listLiveBall\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ammount\",\"type\":\"uint256\"}],\"name\":\"withdrawalBuy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"starsPickValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"picker\",\"type\":\"address\"}],\"name\":\"OnBuyed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ammount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ok\",\"type\":\"bool\"}],\"name\":\"OnWithdrawaled\",\"type\":\"event\"}]","ContractName":"Infinitestars","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"CommUtils:ca661dfb357f84d628ea75680b5fd183d6df2490;Player:c4c1ff7698ce9701c3c171c7340f32e5a296e89f","SwarmSource":"bzzr://8691a826bb7cf496d23bc7a05bd4e189c0c0449db1720a3f74a7b71a8c27d56e"}]}