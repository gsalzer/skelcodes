{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Created on 2018-06-05 16:37\r\n * @summary: Our NFT Minting Contract which inherits ERC721 capability from LSNFT\r\n * @author: Fazri Zubair & Farhan Khwaja\r\n */\r\npragma solidity ^0.4.23;\r\n\r\npragma solidity ^0.4.23;\r\n\r\n/* NFT Metadata Schema \r\n{\r\n    \"title\": \"Asset Metadata\",\r\n    \"type\": \"object\",\r\n    \"properties\": {\r\n        \"name\": {\r\n            \"type\": \"string\",\r\n            \"description\": \"Identifies the asset to which this NFT represents\",\r\n        },\r\n        \"description\": {\r\n            \"type\": \"string\",\r\n            \"description\": \"Describes the asset to which this NFT represents\",\r\n        },\r\n        \"image\": {\r\n            \"type\": \"string\",\r\n            \"description\": \"A URI pointing to a resource with mime type image/* representing the asset to which this NFT represents. Consider making any images at a width between 320 and 1080 pixels and aspect ratio between 1.91:1 and 4:5 inclusive.\",\r\n        }\r\n    }\r\n}\r\n*/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n    /**\r\n    * Returns whether the target address is a contract\r\n    * @dev This function will return false if invoked during the constructor of a contract,\r\n    *  as the code is not actually created until after the constructor finishes.\r\n    * @param addr address to check\r\n    * @return whether the target address is a contract\r\n    */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint256 _tokenId)\r\n        public view returns (address _operator);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        public view returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 _tokenId);\r\n\r\n    function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n    function name() public view returns (string _name);\r\n    function symbol() public view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is ERC721Basic {\r\n    using SafeMath for uint256;\r\n    using AddressUtils for address;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 public constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) internal tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) internal ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n    /**\r\n    * @dev Guarantees msg.sender is owner of the given token\r\n    * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n    */\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        require (ownerOf(_tokenId) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n    * @param _tokenId uint256 ID of the token to validate\r\n    */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        require (isApprovedOrOwner(msg.sender, _tokenId));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address\r\n    * @param _owner address to query the balance of\r\n    * @return uint256 representing the amount owned by the passed address\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require (_owner != address(0));\r\n        return ownedTokensCount[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the owner of the specified token ID\r\n    * @param _tokenId uint256 ID of the token to query the owner of\r\n    * @return owner address currently marked as the owner of the given token ID\r\n    */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        require (owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns whether the specified token exists\r\n    * @param _tokenId uint256 ID of the token to query the existence of\r\n    * @return whether the token exists\r\n    */\r\n    function exists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Approves another address to transfer the given token ID\r\n    * @dev The zero address indicates there is no approved address.\r\n    * @dev There can only be one approved address per token at a given time.\r\n    * @dev Can only be called by the token owner or an approved operator.\r\n    * @param _to address to be approved for the given token ID\r\n    * @param _tokenId uint256 ID of the token to be approved\r\n    */\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        address owner = ownerOf(_tokenId);\r\n        require (_to != owner);\r\n        require (msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        tokenApprovals[_tokenId] = _to;\r\n        emit Approval(owner, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the approved address for a token ID, or zero if no address set\r\n    * @param _tokenId uint256 ID of the token to query the approval of\r\n    * @return address currently approved for the given token ID\r\n    */\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev Sets or unsets the approval of a given operator\r\n    * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n    * @param _to operator address to set the approval\r\n    * @param _approved representing the status of the approval to be set\r\n    */\r\n    function setApprovalForAll(address _to, bool _approved) public {\r\n        require (_to != msg.sender);\r\n        operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    /**\r\n    * @dev Tells whether an operator is approved by a given owner\r\n    * @param _owner owner address which you want to query the approval of\r\n    * @param _operator operator address which you want to query the approval of\r\n    * @return bool whether the given operator is approved by the given owner\r\n    */\r\n    function isApprovedForAll(\r\n        address _owner,\r\n        address _operator\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the ownership of a given token ID to another address\r\n    * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        require (_from != address(0));\r\n        require (_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n    *  which is called upon a safe transfer, and return the magic value\r\n    *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n    *  the transfer is reverted.\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        // solium-disable-next-line arg-overflow\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n    *  which is called upon a safe transfer, and return the magic value\r\n    *  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\r\n    *  the transfer is reverted.\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes data to send along with a safe transfer check\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        transferFrom(_from, _to, _tokenId);\r\n        // solium-disable-next-line arg-overflow\r\n        require (checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns whether the given spender can transfer a given token ID\r\n    * @param _spender address of the spender to query\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @return bool whether the msg.sender is approved for the given token ID,\r\n    *  is an operator of the owner, or is the owner of the token\r\n    */\r\n    function isApprovedOrOwner(\r\n        address _spender,\r\n        uint256 _tokenId\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        address owner = ownerOf(_tokenId);\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (\r\n        _spender == owner ||\r\n        getApproved(_tokenId) == _spender ||\r\n        isApprovedForAll(owner, _spender)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to mint a new token\r\n    * @dev Reverts if the given token ID already exists\r\n    * @param _to The address that will own the minted token\r\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n    */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require (_to != address(0));\r\n        addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * @dev Reverts if the token does not exist\r\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n    */\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        clearApproval(_owner, _tokenId);\r\n        removeTokenFrom(_owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to clear current approval of a given token ID\r\n    * @dev Reverts if the given address is not indeed the owner of the token\r\n    * @param _owner owner of the token\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require (ownerOf(_tokenId) == _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to add a token ID to the list of a given address\r\n    * @param _to address representing the new owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require (tokenOwner[_tokenId] == address(0));\r\n        tokenOwner[_tokenId] = _to;\r\n        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to remove a token ID from the list of a given address\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n    */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        require (ownerOf(_tokenId) == _from);\r\n        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n        tokenOwner[_tokenId] = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to invoke `onERC721Received` on a target address\r\n    * @dev The call is not executed if the target address is not a contract\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _to target address that will receive the tokens\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes optional data to send along with the call\r\n    * @return whether the call correctly returned the expected magic value\r\n    */\r\n    function checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (!_to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n            msg.sender, _from, _tokenId, _data);\r\n        return (retval == ERC721_RECEIVED);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n    /**\r\n    * @dev Magic value to be returned upon successful reception of an NFT\r\n    *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n    *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    */\r\n    bytes4 public constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    /**\r\n    * @notice Handle the receipt of an NFT\r\n    * @dev The ERC721 smart contract calls this function on the recipient\r\n    *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n    *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    *  than the magic value MUST result in the transaction being reverted.\r\n    *  Note: the contract address is always the message sender.\r\n    * @param _from The sending address\r\n    * @param _tokenId The NFT identifier which is being transfered\r\n    * @param _data Additional data with no specified format\r\n    * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    */\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        returns(bytes4);\r\n}\r\n\r\ncontract ERC721Holder is ERC721Receiver {\r\n    function onERC721Received(\r\n        address,\r\n        address,\r\n        uint256,\r\n        bytes\r\n    ) \r\n        public\r\n        returns(bytes4)\r\n        {\r\n            return ERC721_RECEIVED;\r\n        }\r\n}\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Token is ERC721, ERC721BasicToken {\r\n\r\n    // Token name\r\n    string internal name_;\r\n\r\n    // Token symbol\r\n    string internal symbol_;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) internal ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] internal allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n    // Base Server Address for Token MetaData URI\r\n    string internal tokenURIBase;\r\n\r\n    /**\r\n    * @dev Returns an URI for a given token ID\r\n    * @dev Throws if the token ID does not exist. May return an empty string.\r\n    * @notice The user/developper needs to add the tokenID, in the end of URL, to \r\n    * use the URI and get all details. Ex. www.<apiURL>.com/token/<tokenID>\r\n    * @param _tokenId uint256 ID of the token to query\r\n    */\r\n    function tokenURI(uint256 _tokenId) public view returns (string) {\r\n        require (exists(_tokenId));\r\n        return tokenURIBase;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n    * @param _owner address owning the tokens list to be accessed\r\n    * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n    * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n    */\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require (_index < balanceOf(_owner));\r\n        return ownedTokens[_owner][_index];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the total amount of tokens stored by the contract\r\n    * @return uint256 representing the total amount of tokens\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of all the tokens in this contract\r\n    * @dev Reverts if the index is greater or equal to the total number of tokens\r\n    * @param _index uint256 representing the index to be accessed of the tokens list\r\n    * @return uint256 token ID at the given index of the tokens list\r\n    */\r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        require (_index < totalSupply());\r\n        return allTokens[_index];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Internal function to set the token URI for a given token\r\n    * @dev Reverts if the token ID does not exist\r\n    * @param _uri string URI to assign\r\n    */\r\n    function _setTokenURIBase(string _uri) internal {\r\n        tokenURIBase = _uri;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to add a token ID to the list of a given address\r\n    * @param _to address representing the new owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        super.addTokenTo(_to, _tokenId);\r\n        uint256 length = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n        ownedTokensIndex[_tokenId] = length;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to remove a token ID from the list of a given address\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n    */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        super.removeTokenFrom(_from, _tokenId);\r\n\r\n        // To prevent a gap in the array, we store the last token in the index of the token to delete, and\r\n        // then delete the last slot.\r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        // This also deletes the contents at the last position of the array\r\n        ownedTokens[_from].length--;\r\n\r\n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token name\r\n    * @return string representing the token name\r\n    */\r\n    function name() public view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token symbol\r\n    */\r\n    function symbol() public view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to mint a new token\r\n    * @dev Reverts if the given token ID already exists\r\n    * @param _to address the beneficiary that will own the minted token\r\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n    */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        super._mint(_to, _tokenId);\r\n\r\n        allTokensIndex[_tokenId] = allTokens.length;\r\n        allTokens.push(_tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * @dev Reverts if the token does not exist\r\n    * @param _owner owner of the token to burn\r\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n    */\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        super._burn(_owner, _tokenId);\r\n\r\n        // Reorg all tokens array\r\n        uint256 tokenIndex = allTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = allTokens.length.sub(1);\r\n        uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n        allTokens[tokenIndex] = lastToken;\r\n        allTokens[lastTokenIndex] = 0;\r\n\r\n        allTokens.length--;\r\n        allTokensIndex[_tokenId] = 0;\r\n        allTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 = 0x01ffc9a7;\r\n    /*\r\n    bytes4(keccak256('supportsInterface(bytes4)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721Enumerable = 0x780e9d63;\r\n    /*\r\n    bytes4(keccak256('totalSupply()')) ^\r\n    bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n    bytes4(keccak256('tokenByIndex(uint256)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721Metadata = 0x5b5e139f;\r\n    /*\r\n    bytes4(keccak256('name()')) ^\r\n    bytes4(keccak256('symbol()')) ^\r\n    bytes4(keccak256('tokenURI(uint256)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 = 0x80ac58cd;\r\n    /*\r\n    bytes4(keccak256('balanceOf(address)')) ^\r\n    bytes4(keccak256('ownerOf(uint256)')) ^\r\n    bytes4(keccak256('approve(address,uint256)')) ^\r\n    bytes4(keccak256('getApproved(uint256)')) ^\r\n    bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n    bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'));\r\n    */\r\n\r\n    bytes4 public constant InterfaceSignature_ERC721Optional =- 0x4f558e79;\r\n    /*\r\n    bytes4(keccak256('exists(uint256)'));\r\n    */\r\n\r\n    /**\r\n    * @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n    * @dev Returns true for any standardized interfaces implemented by this contract.\r\n    * @param _interfaceID bytes4 the interface to check for\r\n    * @return true for any standardized interfaces implemented by this contract.\r\n    */\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        return ((_interfaceID == InterfaceSignature_ERC165)\r\n        || (_interfaceID == InterfaceSignature_ERC721)\r\n        || (_interfaceID == InterfaceSignature_ERC721Enumerable)\r\n        || (_interfaceID == InterfaceSignature_ERC721Metadata));\r\n    }\r\n\r\n    function implementsERC721() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n}\r\n/* Lucid Sight, Inc. ERC-721 Collectibles. \r\n * @title LSNFT - Lucid Sight, Inc. Non-Fungible Token\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n */\r\ncontract LSNFT is ERC721Token {\r\n  \r\n  /*** EVENTS ***/\r\n\r\n  /// @dev The Created event is fired whenever a new collectible comes into existence.\r\n  event Created(address owner, uint256 tokenId);\r\n  \r\n  /*** DATATYPES ***/\r\n  \r\n  struct NFT {\r\n    // The sequence of potential attributes a Collectible has and can provide in creation events. Used in Creation logic to spwan new Cryptos\r\n    uint256 attributes;\r\n\r\n    // Current Game Card identifier\r\n    uint256 currentGameCardId;\r\n\r\n    // MLB Game Identifier (if asset generated as a game reward)\r\n    uint256 mlbGameId;\r\n\r\n    // player orverride identifier\r\n    uint256 playerOverrideId;\r\n\r\n    // official MLB Player ID\r\n    uint256 mlbPlayerId;\r\n\r\n    // earnedBy : In some instances we may want to retroactively write which MLB player triggered\r\n    // the event that created a Legendary Trophy. This optional field should be able to be written\r\n    // to after generation if we determine an event was newsworthy enough\r\n    uint256 earnedBy;\r\n    \r\n    // asset metadata\r\n    uint256 assetDetails;\r\n    \r\n    // Attach/Detach Flag\r\n    uint256 isAttached;\r\n  }\r\n\r\n  NFT[] allNFTs;\r\n\r\n  function isLSNFT() public view returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /// For creating NFT\r\n  function _createNFT (\r\n    uint256[5] _nftData,\r\n    address _owner,\r\n    uint256 _isAttached)\r\n    internal\r\n    returns(uint256) {\r\n\r\n    NFT memory _lsnftObj = NFT({\r\n        attributes : _nftData[1],\r\n        currentGameCardId : 0,\r\n        mlbGameId : _nftData[2],\r\n        playerOverrideId : _nftData[3],\r\n        assetDetails: _nftData[0],\r\n        isAttached: _isAttached,\r\n        mlbPlayerId: _nftData[4],\r\n        earnedBy: 0\r\n    });\r\n\r\n    uint256 newLSNFTId = allNFTs.push(_lsnftObj) - 1;\r\n\r\n    _mint(_owner, newLSNFTId);\r\n    \r\n    // Created event\r\n    emit Created(_owner, newLSNFTId);\r\n\r\n    return newLSNFTId;\r\n  }\r\n\r\n  /// @dev Gets attributes of NFT  \r\n  function _getAttributesOfToken(uint256 _tokenId) internal returns(NFT) {\r\n    NFT storage lsnftObj = allNFTs[_tokenId];  \r\n    return lsnftObj;\r\n  }\r\n\r\n  function _approveForSale(address _owner, address _to, uint256 _tokenId) internal {\r\n    address owner = ownerOf(_tokenId);\r\n    require (_to != owner);\r\n    require (_owner == owner || isApprovedForAll(owner, _owner));\r\n\r\n    if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n        tokenApprovals[_tokenId] = _to;\r\n        emit Approval(_owner, _to, _tokenId);\r\n    }\r\n  }\r\n}\r\n\r\n/** Controls state and access rights for contract functions\r\n * @title Operational Control\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n * Inspired and adapted from contract created by OpenZeppelin \r\n * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\r\n */\r\ncontract OperationalControl {\r\n    /// Facilitates access & control for the game.\r\n    /// Roles:\r\n    ///  -The Managers (Primary/Secondary): Has universal control of all elements (No ability to withdraw)\r\n    ///  -The Banker: The Bank can withdraw funds and adjust fees / prices.\r\n    ///  -otherManagers: Contracts that need access to functions for gameplay\r\n\r\n    /// @dev Emited when contract is upgraded\r\n    event ContractUpgrade(address newContract);\r\n\r\n    /// @dev The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public managerPrimary;\r\n    address public managerSecondary;\r\n    address public bankManager;\r\n\r\n    // Contracts that require access for gameplay\r\n    mapping(address => uint8) public otherManagers;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    // @dev Keeps track whether the contract erroredOut. When that is true, most actions are blocked & refund can be claimed\r\n    bool public error = false;\r\n\r\n    /**\r\n     * @dev Operation modifiers for limiting access only to Managers\r\n     */\r\n    modifier onlyManager() {\r\n        require (msg.sender == managerPrimary || msg.sender == managerSecondary);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Operation modifiers for limiting access to only Banker\r\n     */\r\n    modifier onlyBanker() {\r\n        require (msg.sender == bankManager);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Operation modifiers for any Operators\r\n     */\r\n    modifier anyOperator() {\r\n        require (\r\n            msg.sender == managerPrimary ||\r\n            msg.sender == managerSecondary ||\r\n            msg.sender == bankManager ||\r\n            otherManagers[msg.sender] == 1\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev        Operation modifier for any Other Manager\r\n     */\r\n    modifier onlyOtherManagers() {\r\n        require (otherManagers[msg.sender] == 1);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new address to act as the Primary Manager.\r\n     * @param _newGM    New primary manager address\r\n     */\r\n    function setPrimaryManager(address _newGM) external onlyManager {\r\n        require (_newGM != address(0));\r\n\r\n        managerPrimary = _newGM;\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new address to act as the Secondary Manager.\r\n     * @param _newGM    New Secondary Manager Address\r\n     */\r\n    function setSecondaryManager(address _newGM) external onlyManager {\r\n        require (_newGM != address(0));\r\n\r\n        managerSecondary = _newGM;\r\n    }\r\n\r\n    /**\r\n     * @dev Assigns a new address to act as the Banker.\r\n     * @param _newBK    New Banker Address\r\n     */\r\n    function setBanker(address _newBK) external onlyManager {\r\n        require (_newBK != address(0));\r\n\r\n        bankManager = _newBK;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Other Manager. (State = 1 is active, 0 is disabled)\r\n    function setOtherManager(address _newOp, uint8 _state) external onlyManager {\r\n        require (_newOp != address(0));\r\n\r\n        otherManagers[_newOp] = _state;\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require (!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require (paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract has Error\r\n    modifier whenError {\r\n        require (error);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Called by any Operator role to pause the contract.\r\n     * Used only if a bug or exploit is discovered (Here to limit losses / damage)\r\n     */\r\n    function pause() external onlyManager whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Unpauses the smart contract. Can only be called by the Game Master\r\n     */\r\n    function unpause() public onlyManager whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n\r\n    /**\r\n     * @dev Errors out the contract thus mkaing the contract non-functionable\r\n     */\r\n    function hasError() public onlyManager whenPaused {\r\n        error = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Removes the Error Hold from the contract and resumes it for working\r\n     */\r\n    function noError() public onlyManager whenPaused {\r\n        error = false;\r\n    }\r\n}\r\n\r\n/** Base contract for MLBNFT Collectibles. Holds all commons, events and base variables.\r\n * @title Lucid Sight MLB NFT 2018\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n */\r\ncontract CollectibleBase is LSNFT {\r\n\r\n    /*** EVENTS ***/\r\n\r\n    /// @dev Event emitted when an attribute of the player is updated\r\n    event AssetUpdated(uint256 tokenId);\r\n\r\n    /*** STORAGE ***/\r\n\r\n    /// @dev A mapping of Team Id to Team Sequence Number to Collectible\r\n    mapping (uint256 => mapping (uint32 => uint256) ) public nftTeamIdToSequenceIdToCollectible;\r\n\r\n    /// @dev A mapping from Team IDs to the Sequqence Number .\r\n    mapping (uint256 => uint32) public nftTeamIndexToCollectibleCount;\r\n\r\n    /// @dev Array to hold details on attachment for each LS NFT Collectible\r\n    mapping(uint256 => uint256[]) public nftCollectibleAttachments;\r\n\r\n    /// @dev Mapping to control the asset generation per season.\r\n    mapping(uint256 => uint256) public generationSeasonController;\r\n\r\n    /// @dev Mapping for generation Season Dict.\r\n    mapping(uint256 => uint256) public generationSeasonDict;\r\n\r\n    /// @dev internal function to update player override id\r\n    function _updatePlayerOverrideId(uint256 _tokenId, uint256 _newPlayerOverrideId) internal {\r\n\r\n        // Get Token Obj\r\n        NFT storage lsnftObj = allNFTs[_tokenId];\r\n        lsnftObj.playerOverrideId = _newPlayerOverrideId;\r\n\r\n        // Update Token Data with new updated attributes\r\n        allNFTs[_tokenId] = lsnftObj;\r\n\r\n        emit AssetUpdated(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev An internal method that helps in generation of new NFT Collectibles\r\n     * @param _teamId           teamId of the asset/token/collectible\r\n     * @param _attributes       attributes of asset/token/collectible\r\n     * @param _owner            owner of asset/token/collectible\r\n     * @param _isAttached       State of the asset (attached or dettached)\r\n     * @param _nftData          Array of data required for creation\r\n     */\r\n    function _createNFTCollectible(\r\n        uint8 _teamId,\r\n        uint256 _attributes,\r\n        address _owner,\r\n        uint256 _isAttached,\r\n        uint256[5] _nftData\r\n    )\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 generationSeason = (_attributes % 1000000).div(1000);\r\n        require (generationSeasonController[generationSeason] == 1);\r\n\r\n        uint32 _sequenceId = getSequenceId(_teamId);\r\n\r\n        uint256 newNFTCryptoId = _createNFT(_nftData, _owner, _isAttached);\r\n        \r\n        nftTeamIdToSequenceIdToCollectible[_teamId][_sequenceId] = newNFTCryptoId;\r\n        nftTeamIndexToCollectibleCount[_teamId] = _sequenceId;\r\n\r\n        return newNFTCryptoId;\r\n    }\r\n    \r\n    function getSequenceId(uint256 _teamId) internal returns (uint32) {\r\n        return (nftTeamIndexToCollectibleCount[_teamId] + 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function, Helps in updating the Creation Stop Time\r\n     * @param _season    Season UINT Code\r\n     * @param _value    0 - Not allowed, 1 - Allowed\r\n     */\r\n    function _updateGenerationSeasonFlag(uint256 _season, uint8 _value) internal {\r\n        generationSeasonController[_season] = _value;\r\n    }\r\n\r\n    /** @param _owner The owner whose ships tokens we are interested in.\r\n      * @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n      *  expensive (it walks the entire Collectibles owners array looking for NFT belonging to owner)\r\n    */      \r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalItems = balanceOf(_owner);\r\n            uint256 resultIndex = 0;\r\n\r\n            // We count on the fact that all Collectible have IDs starting at 0 and increasing\r\n            // sequentially up to the total count.\r\n            uint256 _assetId;\r\n\r\n            for (_assetId = 0; _assetId < totalItems; _assetId++) {\r\n                result[resultIndex] = tokenOfOwnerByIndex(_owner,_assetId);\r\n                resultIndex++;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /// @dev internal function to update MLB player id\r\n    function _updateMLBPlayerId(uint256 _tokenId, uint256 _newMLBPlayerId) internal {\r\n\r\n        // Get Token Obj\r\n        NFT storage lsnftObj = allNFTs[_tokenId];\r\n        \r\n        lsnftObj.mlbPlayerId = _newMLBPlayerId;\r\n\r\n        // Update Token Data with new updated attributes\r\n        allNFTs[_tokenId] = lsnftObj;\r\n\r\n        emit AssetUpdated(_tokenId);\r\n    }\r\n\r\n    /// @dev internal function to update asset earnedBy value for an asset/token\r\n    function _updateEarnedBy(uint256 _tokenId, uint256 _earnedBy) internal {\r\n\r\n        // Get Token Obj\r\n        NFT storage lsnftObj = allNFTs[_tokenId];\r\n        \r\n        lsnftObj.earnedBy = _earnedBy;\r\n\r\n        // Update Token Data with new updated attributes\r\n        allNFTs[_tokenId] = lsnftObj;\r\n\r\n        emit AssetUpdated(_tokenId);\r\n    }\r\n}\r\n\r\n/* Handles creating new Collectibles for promo and seed.\r\n * @title CollectibleMinting Minting\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n * Inspired and adapted from KittyCore.sol created by Axiom Zen\r\n * Ref: ETH Contract - 0x06012c8cf97BEaD5deAe237070F9587f8E7A266d\r\n */\r\ncontract CollectibleMinting is CollectibleBase, OperationalControl {\r\n\r\n    uint256 public rewardsRedeemed = 0;\r\n\r\n    /// @dev Counts the number of promo collectibles that can be made per-team\r\n    uint256[31]  public promoCreatedCount;\r\n    \r\n    /// @dev Counts the number of seed collectibles that can be made in total\r\n    uint256 public seedCreatedCount;\r\n\r\n    /// @dev Bool to toggle batch support\r\n    bool public isBatchSupported = true;\r\n    \r\n    /// @dev A mapping of contracts that can trigger functions\r\n    mapping (address => bool) public contractsApprovedList;\r\n    \r\n    /**\r\n     * @dev        Helps to toggle batch supported flag\r\n     * @param      _flag  The flag\r\n     */\r\n    function updateBatchSupport(bool _flag) public onlyManager {\r\n        isBatchSupported = _flag;\r\n    }\r\n\r\n    modifier canCreate() { \r\n        require (contractsApprovedList[msg.sender] || \r\n            msg.sender == managerPrimary ||\r\n            msg.sender == managerSecondary); \r\n        _; \r\n    }\r\n    \r\n    /**\r\n     * @dev Add an address to the Approved List\r\n     * @param _newAddress   The new address to be approved for interaction with the contract\r\n     */\r\n    function addToApproveList(address _newAddress) public onlyManager {\r\n        \r\n        require (!contractsApprovedList[_newAddress]);\r\n        contractsApprovedList[_newAddress] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove an address from Approved List\r\n     * @param _newAddress   The new address to be approved for interaction with the contract\r\n     */\r\n    function removeFromApproveList(address _newAddress) public onlyManager {\r\n        require (contractsApprovedList[_newAddress]);\r\n        delete contractsApprovedList[_newAddress];\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev Generates promo collectibles. Only callable by Game Master, with isAttached as 0.\r\n     * @notice The generation of an asset if limited via the generationSeasonController\r\n     * @param _teamId           teamId of the asset/token/collectible\r\n     * @param _posId            position of the asset/token/collectible\r\n     * @param _attributes       attributes of asset/token/collectible\r\n     * @param _owner            owner of asset/token/collectible\r\n     * @param _gameId          mlb game Identifier\r\n     * @param _playerOverrideId player override identifier\r\n     * @param _mlbPlayerId      official mlb player identifier\r\n     */\r\n    function createPromoCollectible(\r\n        uint8 _teamId,\r\n        uint8 _posId,\r\n        uint256 _attributes,\r\n        address _owner,\r\n        uint256 _gameId,\r\n        uint256 _playerOverrideId,\r\n        uint256 _mlbPlayerId)\r\n        external\r\n        canCreate\r\n        whenNotPaused\r\n        returns (uint256)\r\n        {\r\n\r\n        address nftOwner = _owner;\r\n        if (nftOwner == address(0)) {\r\n             nftOwner = managerPrimary;\r\n        }\r\n\r\n        if(allNFTs.length > 0) {\r\n            promoCreatedCount[_teamId]++;\r\n        }\r\n        \r\n        uint32 _sequenceId = getSequenceId(_teamId);\r\n        \r\n        uint256 assetDetails = uint256(uint64(now));\r\n        assetDetails |= uint256(_sequenceId)<<64;\r\n        assetDetails |= uint256(_teamId)<<96;\r\n        assetDetails |= uint256(_posId)<<104;\r\n\r\n        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];\r\n        \r\n        return _createNFTCollectible(_teamId, _attributes, nftOwner, 0, _nftData);\r\n    }\r\n\r\n    /**\r\n     * @dev Generaes a new single seed Collectible, with isAttached as 0.\r\n     * @notice Helps in creating seed collectible.The generation of an asset if limited via the generationSeasonController\r\n     * @param _teamId           teamId of the asset/token/collectible\r\n     * @param _posId            position of the asset/token/collectible\r\n     * @param _attributes       attributes of asset/token/collectible\r\n     * @param _owner            owner of asset/token/collectible\r\n     * @param _gameId          mlb game Identifier\r\n     * @param _playerOverrideId player override identifier\r\n     * @param _mlbPlayerId      official mlb player identifier\r\n     */\r\n    function createSeedCollectible(\r\n        uint8 _teamId,\r\n        uint8 _posId,\r\n        uint256 _attributes,\r\n        address _owner,\r\n        uint256 _gameId,\r\n        uint256 _playerOverrideId,\r\n        uint256 _mlbPlayerId)\r\n        external\r\n        canCreate\r\n        whenNotPaused\r\n        returns (uint256) {\r\n\r\n        address nftOwner = _owner;\r\n        \r\n        if (nftOwner == address(0)) {\r\n             nftOwner = managerPrimary;\r\n        }\r\n        \r\n        seedCreatedCount++;\r\n        uint32 _sequenceId = getSequenceId(_teamId);\r\n        \r\n        uint256 assetDetails = uint256(uint64(now));\r\n        assetDetails |= uint256(_sequenceId)<<64;\r\n        assetDetails |= uint256(_teamId)<<96;\r\n        assetDetails |= uint256(_posId)<<104;\r\n\r\n        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];\r\n        \r\n        return _createNFTCollectible(_teamId, _attributes, nftOwner, 0, _nftData);\r\n    }\r\n\r\n    /**\r\n     * @dev Generate new Reward Collectible and transfer it to the owner, with isAttached as 0.\r\n     * @notice Helps in redeeming the Rewards using our Oracle. Creates & transfers the asset to the redeemer (_owner)\r\n     * The generation of an asset if limited via the generationSeasonController\r\n     * @param _teamId           teamId of the asset/token/collectible\r\n     * @param _posId            position of the asset/token/collectible\r\n     * @param _attributes       attributes of asset/token/collectible\r\n     * @param _owner            owner (redeemer) of asset/token/collectible\r\n     * @param _gameId           mlb game Identifier\r\n     * @param _playerOverrideId player override identifier\r\n     * @param _mlbPlayerId      official mlb player identifier\r\n     */\r\n    function createRewardCollectible (\r\n        uint8 _teamId,\r\n        uint8 _posId,\r\n        uint256 _attributes,\r\n        address _owner,\r\n        uint256 _gameId,\r\n        uint256 _playerOverrideId,\r\n        uint256 _mlbPlayerId)\r\n        external\r\n        canCreate\r\n        whenNotPaused\r\n        returns (uint256) {\r\n\r\n        address nftOwner = _owner;\r\n        \r\n        if (nftOwner == address(0)) {\r\n             nftOwner = managerPrimary;\r\n        }\r\n        \r\n        rewardsRedeemed++;\r\n        uint32 _sequenceId = getSequenceId(_teamId);\r\n        \r\n        uint256 assetDetails = uint256(uint64(now));\r\n        assetDetails |= uint256(_sequenceId)<<64;\r\n        assetDetails |= uint256(_teamId)<<96;\r\n        assetDetails |= uint256(_posId)<<104;\r\n\r\n        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];\r\n        \r\n        return _createNFTCollectible(_teamId, _attributes, nftOwner, 0, _nftData);\r\n    }\r\n\r\n    /**\r\n     * @dev Generate new ETH Card Collectible, with isAttached as 2.\r\n     * @notice Helps to generate Collectibles/Tokens/Asset and transfer to ETH Cards,\r\n     * which can be redeemed using our web-app.The generation of an asset if limited via the generationSeasonController\r\n     * @param _teamId           teamId of the asset/token/collectible\r\n     * @param _posId            position of the asset/token/collectible\r\n     * @param _attributes       attributes of asset/token/collectible\r\n     * @param _owner            owner of asset/token/collectible\r\n     * @param _gameId           mlb game Identifier\r\n     * @param _playerOverrideId player override identifier\r\n     * @param _mlbPlayerId      official mlb player identifier\r\n     */\r\n    function createETHCardCollectible (\r\n        uint8 _teamId,\r\n        uint8 _posId,\r\n        uint256 _attributes,\r\n        address _owner,\r\n        uint256 _gameId,\r\n        uint256 _playerOverrideId,\r\n        uint256 _mlbPlayerId)\r\n        external\r\n        canCreate\r\n        whenNotPaused\r\n        returns (uint256) {\r\n\r\n        address nftOwner = _owner;\r\n        \r\n        if (nftOwner == address(0)) {\r\n             nftOwner = managerPrimary;\r\n        }\r\n        \r\n        rewardsRedeemed++;\r\n        uint32 _sequenceId = getSequenceId(_teamId);\r\n        \r\n        uint256 assetDetails = uint256(uint64(now));\r\n        assetDetails |= uint256(_sequenceId)<<64;\r\n        assetDetails |= uint256(_teamId)<<96;\r\n        assetDetails |= uint256(_posId)<<104;\r\n\r\n        uint256[5] memory _nftData = [assetDetails, _attributes, _gameId, _playerOverrideId, _mlbPlayerId];\r\n        \r\n        return _createNFTCollectible(_teamId, _attributes, nftOwner, 2, _nftData);\r\n    }\r\n}\r\n\r\n/* @title Interface for MLBNFT Contract\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n */\r\ncontract SaleManager {\r\n    function createSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration, address _owner) external;\r\n}\r\n\r\n/**\r\n * MLBNFT manages all aspects of the Lucid Sight, Inc. CryptoBaseball.\r\n * @title MLBNFT\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n */\r\ncontract MLBNFT is CollectibleMinting {\r\n    \r\n    /// @dev Set in case the MLBNFT contract requires an upgrade\r\n    address public newContractAddress;\r\n\r\n    string public constant MLB_Legal = \"Major League Baseball trademarks and copyrights are used with permission of the applicable MLB entity.  All rights reserved.\";\r\n\r\n    // Time LS Oracle has to respond to detach requests\r\n    uint32 public detachmentTime = 0;\r\n\r\n    // Indicates if attached system is Active (Transfers will be blocked if attached and active)\r\n    bool public attachedSystemActive;\r\n\r\n    // Sale Manager Contract\r\n    SaleManager public saleManagerAddress;\r\n\r\n    /**\r\n     * @dev MLBNFT constructor.\r\n     */\r\n    constructor() public {\r\n        // Starts paused.\r\n        paused = true;\r\n        managerPrimary = msg.sender;\r\n        managerSecondary = msg.sender;\r\n        bankManager = msg.sender;\r\n        name_ = \"LucidSight-MLB-NFT\";\r\n        symbol_ = \"MLBCB\";\r\n    }\r\n\r\n    /**\r\n     * @dev        Sets the address for the NFT Contract\r\n     * @param      _saleManagerAddress  The nft address\r\n     */\r\n    function setSaleManagerAddress(address _saleManagerAddress) public onlyManager {\r\n        require (_saleManagerAddress != address(0));\r\n        saleManagerAddress = SaleManager(_saleManagerAddress);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n    * @param _tokenId uint256 ID of the token to validate\r\n    */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        uint256 isAttached = checkIsAttached(_tokenId);\r\n        if(isAttached == 2) {\r\n            //One-Time Auth for Physical Card Transfers\r\n            require (msg.sender == managerPrimary ||\r\n                msg.sender == managerSecondary ||\r\n                msg.sender == bankManager ||\r\n                otherManagers[msg.sender] == 1\r\n            );\r\n            updateIsAttached(_tokenId, 0);\r\n        } else if(attachedSystemActive == true && isAttached >= 1) {\r\n            require (msg.sender == managerPrimary ||\r\n                msg.sender == managerSecondary ||\r\n                msg.sender == bankManager ||\r\n                otherManagers[msg.sender] == 1\r\n            );\r\n        }\r\n        else {\r\n            require (isApprovedOrOwner(msg.sender, _tokenId));\r\n        }\r\n    _;\r\n    }\r\n\r\n    /**\r\n     * @dev Used to mark the smart contract as upgraded, in case of a issue\r\n     * @param _v2Address    The new contract address\r\n     */\r\n    function setNewAddress(address _v2Address) external onlyManager {\r\n        require (_v2Address != address(0));\r\n        newContractAddress = _v2Address;\r\n        emit ContractUpgrade(_v2Address);\r\n    }\r\n\r\n    /**\r\n     * @dev Returns all the relevant information about a specific Collectible.\r\n     * @notice Get details about your collectible\r\n     * @param _tokenId              The token identifier\r\n     * @return isAttached           Is Object attached\r\n     * @return teamId               team identifier of the asset/token/collectible\r\n     * @return positionId           position identifier of the asset/token/collectible\r\n     * @return creationTime         creation timestamp\r\n     * @return attributes           attribute of the asset/token/collectible\r\n     * @return currentGameCardId    current game card of the asset/token/collectible\r\n     * @return mlbGameID            mlb game identifier in which the asset/token/collectible was generated\r\n     * @return playerOverrideId     player override identifier of the asset/token/collectible\r\n     * @return playerStatus         status of the player (Rookie/Veteran/Historical)\r\n     * @return playerHandedness     handedness of the asset\r\n     * @return mlbPlayerId          official MLB Player Identifier\r\n     */\r\n    function getCollectibleDetails(uint256 _tokenId)\r\n        external\r\n        view\r\n        returns (\r\n        uint256 isAttached,\r\n        uint32 sequenceId,\r\n        uint8 teamId,\r\n        uint8 positionId,\r\n        uint64 creationTime,\r\n        uint256 attributes,\r\n        uint256 playerOverrideId,\r\n        uint256 mlbGameId,\r\n        uint256 currentGameCardId,\r\n        uint256 mlbPlayerId,\r\n        uint256 earnedBy,\r\n        uint256 generationSeason\r\n        ) {\r\n        NFT memory obj  = _getAttributesOfToken(_tokenId);\r\n        \r\n        attributes = obj.attributes;\r\n        currentGameCardId = obj.currentGameCardId;\r\n        mlbGameId = obj.mlbGameId;\r\n        playerOverrideId = obj.playerOverrideId;\r\n        mlbPlayerId = obj.mlbPlayerId;\r\n\r\n        creationTime = uint64(obj.assetDetails);\r\n        sequenceId = uint32(obj.assetDetails>>64);\r\n        teamId = uint8(obj.assetDetails>>96);\r\n        positionId = uint8(obj.assetDetails>>104);\r\n        isAttached = obj.isAttached;\r\n        earnedBy = obj.earnedBy;\r\n\r\n        generationSeason = generationSeasonDict[(obj.attributes % 1000000) / 1000];\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev This is public rather than external so we can call super.unpause\r\n     * without using an expensive CALL.\r\n     */\r\n    function unpause() public onlyManager {\r\n        /// Actually unpause the contract.\r\n        super.unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to get the teamID of a collectible.To avoid using getCollectibleDetails\r\n     * @notice Returns the teamID associated with the asset/collectible/token\r\n     * @param _tokenId  The token identifier\r\n     */\r\n    function getTeamId(uint256 _tokenId) external view returns (uint256) {\r\n        NFT memory obj  = _getAttributesOfToken(_tokenId);\r\n\r\n        uint256 teamId = uint256(uint8(obj.assetDetails>>96));\r\n        return uint256(teamId);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to get the position of a collectible.To avoid using getCollectibleDetails\r\n     * @notice Returns the position of the asset/collectible/token\r\n     * @param _tokenId  The token identifier\r\n     */\r\n    function getPositionId(uint256 _tokenId) external view returns (uint256) {\r\n        NFT memory obj  = _getAttributesOfToken(_tokenId);\r\n\r\n        uint256 positionId = uint256(uint8(obj.assetDetails>>104));\r\n\r\n        return positionId;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to get the game card. To avoid using getCollectibleDetails\r\n     * @notice Returns the gameCard associated with the asset/collectible/token\r\n     * @param _tokenId  The token identifier\r\n     */\r\n    function getGameCardId(uint256 _tokenId) public view returns (uint256) {\r\n        NFT memory obj  = _getAttributesOfToken(_tokenId);\r\n        return obj.currentGameCardId;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns isAttached property value for an asset/collectible/token\r\n     * @param _tokenId  The token identifier\r\n     */\r\n    function checkIsAttached(uint256 _tokenId) public view returns (uint256) {\r\n        NFT memory obj  = _getAttributesOfToken(_tokenId);\r\n        return obj.isAttached;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to get the attirbute of the collectible.To avoid using getCollectibleDetails\r\n     * @notice Returns the ability of an asset/collectible/token from attributes.\r\n     * @param _tokenId  The token identifier\r\n     * @return ability  ability of the asset\r\n     */\r\n    function getAbilitiesForCollectibleId(uint256 _tokenId) external view returns (uint256 ability) {\r\n        NFT memory obj  = _getAttributesOfToken(_tokenId);\r\n        uint256 _attributes = uint256(obj.attributes);\r\n        ability = (_attributes % 1000);\r\n    }\r\n\r\n    /**\r\n     * @dev Only allows trasnctions to go throught if the msg.sender is in the apporved list\r\n     * @notice Updates the gameCardID properrty of the asset\r\n     * @param _gameCardNumber  The game card number\r\n     * @param _playerId        The player identifier\r\n     */\r\n    function updateCurrentGameCardId(uint256 _gameCardNumber, uint256 _playerId) public whenNotPaused {\r\n        require (contractsApprovedList[msg.sender]);\r\n\r\n        NFT memory obj  = _getAttributesOfToken(_playerId);\r\n        \r\n        obj.currentGameCardId = _gameCardNumber;\r\n        \r\n        if ( _gameCardNumber == 0 ) {\r\n            obj.isAttached = 0;\r\n        } else {\r\n            obj.isAttached = 1;\r\n        }\r\n\r\n        allNFTs[_playerId] = obj;\r\n    }\r\n\r\n    /**\r\n     * @dev Only Manager can add an attachment (special events) to the collectible\r\n     * @notice Adds an attachment to collectible.\r\n     * @param _tokenId  The token identifier\r\n     * @param _attachment  The attachment\r\n     */\r\n    function addAttachmentToCollectible ( \r\n        uint256 _tokenId,\r\n        uint256 _attachment)\r\n        external\r\n        onlyManager\r\n        whenNotPaused {\r\n        require (exists(_tokenId));\r\n\r\n        nftCollectibleAttachments[_tokenId].push(_attachment);\r\n        emit AssetUpdated(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev It will remove the attachment form the collectible. We will need to re-add all attachment(s) if removed.\r\n     * @notice Removes all attachments from collectible.\r\n     * @param _tokenId  The token identifier\r\n     */\r\n    function removeAllAttachmentsFromCollectible(uint256 _tokenId)\r\n        external\r\n        onlyManager\r\n        whenNotPaused {\r\n\r\n        require (exists(_tokenId));\r\n        \r\n        delete nftCollectibleAttachments[_tokenId];\r\n        emit AssetUpdated(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers the ownership of NFT from one address to another address\r\n     * @dev responsible for gifting assets to other user.\r\n     * @param _to       to address\r\n     * @param _tokenId  The token identifier\r\n     */\r\n    function giftAsset(address _to, uint256 _tokenId) public whenNotPaused {        \r\n        safeTransferFrom(msg.sender, _to, _tokenId);\r\n    }\r\n    \r\n    /**\r\n     * @dev responsible for setting the tokenURI.\r\n     * @notice The user/developper needs to add the tokenID, in the end of URL, to \r\n     * use the URI and get all details. Ex. www.<apiURL>.com/token/<tokenID>\r\n     * @param _tokenURI  The token uri\r\n     */\r\n    function setTokenURIBase (string _tokenURI) public anyOperator {\r\n        _setTokenURIBase(_tokenURI);\r\n    }\r\n\r\n    /**\r\n     * @dev Allowed to be called by onlyGameManager to update a certain collectible playerOverrideID\r\n     * @notice Sets the player override identifier.\r\n     * @param _tokenId      The token identifier\r\n     * @param _newOverrideId     The new player override identifier\r\n     */\r\n    function setPlayerOverrideId(uint256 _tokenId, uint256 _newOverrideId) public onlyManager whenNotPaused {\r\n        require (exists(_tokenId));\r\n\r\n        _updatePlayerOverrideId(_tokenId, _newOverrideId);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates the Generation Season Controller.\r\n     * @dev Allowed to be called by onlyGameManager to update the generation season.\r\n     * this helps to control the generation of collectible.\r\n     * @param _season    Season UINT representation\r\n     * @param _value    0-Not allowed, 1-open, >=2 Locked Forever\r\n     */\r\n    function updateGenerationStopTime(uint256 _season, uint8 _value ) public  onlyManager whenNotPaused {\r\n        require (generationSeasonController[_season] == 1 && _value != 0);\r\n        _updateGenerationSeasonFlag(_season, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev set Generation Season Controller, can only be called by Managers._season can be [0,1,2,3..] and \r\n     * _value can be [0,1,N].\r\n     * @notice _value of 1: means generation of collectible is allowed. anything, apart from 1, wont allow generating assets for that season.\r\n     * @param _season    Season UINT representation\r\n     */\r\n    function setGenerationSeasonController(uint256 _season) public onlyManager whenNotPaused {\r\n        require (generationSeasonController[_season] == 0);\r\n        _updateGenerationSeasonFlag(_season, 1);\r\n    }\r\n\r\n    /**\r\n     * @dev Adding value to DICT helps in showing the season value in getCollectibleDetails\r\n     * @notice Updates the Generation Season Dict.\r\n     * @param _season    Season UINT representation\r\n     * @param _value    0-Not allowed,1-allowed\r\n     */\r\n    function updateGenerationDict(uint256 _season, uint64 _value) public onlyManager whenNotPaused {\r\n        require (generationSeasonDict[_season] <= 1);\r\n        generationSeasonDict[_season] = _value;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to avoid calling getCollectibleDetails\r\n     * @notice Gets the MLB player Id from the player attributes\r\n     * @param _tokenId  The token identifier\r\n     * @return playerId  MLB Player Identifier\r\n     */\r\n    function getPlayerId(uint256 _tokenId) external view returns (uint256 playerId) {\r\n        NFT memory obj  = _getAttributesOfToken(_tokenId);\r\n        playerId = ((obj.attributes.div(100000000000000000)) % 1000);\r\n    }\r\n    \r\n    /**\r\n     * @dev Helper function to avoid calling getCollectibleDetails\r\n     * @notice Gets the attachments for an asset\r\n     * @param _tokenId  The token identifier\r\n     * @return attachments\r\n     */\r\n    function getAssetAttachment(uint256 _tokenId) external view returns (uint256[]) {\r\n        uint256[] _attachments = nftCollectibleAttachments[_tokenId];\r\n        uint256[] attachments;\r\n        for(uint i=0;i<_attachments.length;i++){\r\n            attachments.push(_attachments[i]);\r\n        }\r\n        \r\n        return attachments;\r\n    }\r\n\r\n    /**\r\n     * @dev Can only be trigerred by Managers. Updates the earnedBy property of the NFT\r\n     * @notice Helps in updating the earned _by property of an asset/token.\r\n     * @param  _tokenId        asser/token identifier\r\n     * @param  _earnedBy       New asset/token DNA\r\n     */\r\n    function updateEarnedBy(uint256 _tokenId, uint256 _earnedBy) public onlyManager whenNotPaused {\r\n        require (exists(_tokenId));\r\n\r\n        _updateEarnedBy(_tokenId, _earnedBy);\r\n    }\r\n\r\n    /**\r\n     * @dev A batch function to facilitate batching of asset creation. canCreate modifier\r\n     * helps in controlling who can call the function\r\n     * @notice Batch Function to Create Assets\r\n     * @param      _teamId            The team identifier\r\n     * @param      _attributes        The attributes\r\n     * @param      _playerOverrideId  The player override identifier\r\n     * @param      _mlbPlayerId       The mlb player identifier\r\n     * @param      _to                To Address\r\n     */\r\n    function batchCreateAsset(\r\n        uint8[] _teamId,\r\n        uint256[] _attributes,\r\n        uint256[] _playerOverrideId,\r\n        uint256[] _mlbPlayerId,\r\n        address[] _to)\r\n        external\r\n        canCreate\r\n        whenNotPaused {\r\n            require (isBatchSupported);\r\n\r\n            require (_teamId.length > 0 && _attributes.length > 0 && \r\n                _playerOverrideId.length > 0 && _mlbPlayerId.length > 0 && \r\n                _to.length > 0);\r\n\r\n            uint256 assetDetails;\r\n            uint256[5] memory _nftData;\r\n            \r\n            for(uint ii = 0; ii < _attributes.length; ii++){\r\n                require (_to[ii] != address(0) && _teamId[ii] != 0 && _attributes.length != 0 && \r\n                    _mlbPlayerId[ii] != 0);\r\n                \r\n                assetDetails = uint256(uint64(now));\r\n                assetDetails |= uint256(getSequenceId(_teamId[ii]))<<64;\r\n                assetDetails |= uint256(_teamId[ii])<<96;\r\n                assetDetails |= uint256((_attributes[ii]/1000000000000000000000000000000000000000)-800)<<104;\r\n        \r\n                _nftData = [assetDetails, _attributes[ii], 0, _playerOverrideId[ii], _mlbPlayerId[ii]];\r\n                \r\n                _createNFTCollectible(_teamId[ii], _attributes[ii], _to[ii], 0, _nftData);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * @dev A batch function to facilitate batching of asset creation for ETH Cards. canCreate modifier\r\n     * helps in controlling who can call the function\r\n     * @notice        Batch Function to Create Assets\r\n     * @param      _teamId            The team identifier\r\n     * @param      _attributes        The attributes\r\n     * @param      _playerOverrideId  The player override identifier\r\n     * @param      _mlbPlayerId       The mlb player identifier\r\n     * @param      _to                { parameter_description }\r\n     */\r\n    function batchCreateETHCardAsset(\r\n        uint8[] _teamId,\r\n        uint256[] _attributes,\r\n        uint256[] _playerOverrideId,\r\n        uint256[] _mlbPlayerId,\r\n        address[] _to)\r\n        external\r\n        canCreate\r\n        whenNotPaused {\r\n            require (isBatchSupported);\r\n\r\n            require (_teamId.length > 0 && _attributes.length > 0\r\n                        && _playerOverrideId.length > 0 &&\r\n                        _mlbPlayerId.length > 0 && _to.length > 0);\r\n\r\n            uint256 assetDetails;\r\n            uint256[5] memory _nftData;\r\n\r\n            for(uint ii = 0; ii < _attributes.length; ii++){\r\n\r\n                require (_to[ii] != address(0) && _teamId[ii] != 0 && _attributes.length != 0 && \r\n                    _mlbPlayerId[ii] != 0);\r\n        \r\n                assetDetails = uint256(uint64(now));\r\n                assetDetails |= uint256(getSequenceId(_teamId[ii]))<<64;\r\n                assetDetails |= uint256(_teamId[ii])<<96;\r\n                assetDetails |= uint256((_attributes[ii]/1000000000000000000000000000000000000000)-800)<<104;\r\n        \r\n                _nftData = [assetDetails, _attributes[ii], 0, _playerOverrideId[ii], _mlbPlayerId[ii]];\r\n                \r\n                _createNFTCollectible(_teamId[ii], _attributes[ii], _to[ii], 2, _nftData);\r\n            }\r\n        }\r\n\r\n    /**\r\n     * @dev        Overriden TransferFrom, with the modifier canTransfer which uses our attachment system\r\n     * @notice     Helps in trasnferring assets\r\n     * @param      _from     the address sending from\r\n     * @param      _to       the address sending to\r\n     * @param      _tokenId  The token identifier\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        // Asset should not be in play\r\n        require (checkIsAttached(_tokenId) == 0);\r\n        \r\n        require (_from != address(0));\r\n\r\n        require (_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev     Facilitates batch trasnfer of collectible with multiple TO Address, depending if batch is supported on contract.\r\n     * @notice  Batch Trasnfer with multpple TO addresses\r\n     * @param      _tokenIds  The token identifiers\r\n     * @param      _fromB     the address sending from\r\n     * @param      _toB       the address sending to\r\n     */\r\n    function multiBatchTransferFrom(\r\n        uint256[] _tokenIds, \r\n        address[] _fromB, \r\n        address[] _toB) \r\n        public\r\n    {\r\n        require (isBatchSupported);\r\n\r\n        require (_tokenIds.length > 0 && _fromB.length > 0 && _toB.length > 0);\r\n\r\n        uint256 _id;\r\n        address _to;\r\n        address _from;\r\n        \r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n\r\n            require (_tokenIds[i] != 0 && _fromB[i] != 0 && _toB[i] != 0);\r\n\r\n            _id = _tokenIds[i];\r\n            _to = _toB[i];\r\n            _from = _fromB[i];\r\n\r\n            transferFrom(_from, _to, _id);\r\n        }\r\n        \r\n    }\r\n    \r\n    /**\r\n     * @dev     Facilitates batch trasnfer of collectible, depending if batch is supported on contract\r\n     * @notice        Batch TransferFrom with the same to & from address\r\n     * @param      _tokenIds  The asset identifiers\r\n     * @param      _from      the address sending from\r\n     * @param      _to        the address sending to\r\n     */\r\n    function batchTransferFrom(uint256[] _tokenIds, address _from, address _to) \r\n        public\r\n    {\r\n        require (isBatchSupported);\r\n\r\n        require (_tokenIds.length > 0 && _from != address(0) && _to != address(0));\r\n\r\n        uint256 _id;\r\n        \r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n            \r\n            require (_tokenIds[i] != 0);\r\n\r\n            _id = _tokenIds[i];\r\n\r\n            transferFrom(_from, _to, _id);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev     Facilitates batch trasnfer of collectible, depending if batch is supported on contract.\r\n     * Checks for collectible 0,address 0 and then performs the transfer\r\n     * @notice        Batch SafeTransferFrom with multiple From and to Addresses\r\n     * @param      _tokenIds  The asset identifiers\r\n     * @param      _fromB     the address sending from\r\n     * @param      _toB       the address sending to\r\n     */\r\n    function multiBatchSafeTransferFrom(\r\n        uint256[] _tokenIds, \r\n        address[] _fromB, \r\n        address[] _toB\r\n        )\r\n        public\r\n    {\r\n        require (isBatchSupported);\r\n\r\n        require (_tokenIds.length > 0 && _fromB.length > 0 && _toB.length > 0);\r\n\r\n        uint256 _id;\r\n        address _to;\r\n        address _from;\r\n        \r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n\r\n            require (_tokenIds[i] != 0 && _fromB[i] != 0 && _toB[i] != 0);\r\n\r\n            _id = _tokenIds[i];\r\n            _to  = _toB[i];\r\n            _from  = _fromB[i];\r\n\r\n            safeTransferFrom(_from, _to, _id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev     Facilitates batch trasnfer of collectible, depending if batch is supported on contract.\r\n     * Checks for collectible 0,address 0 and then performs the transfer\r\n     * @notice        Batch SafeTransferFrom from a single address to another address\r\n     * @param      _tokenIds  The asset identifiers\r\n     * @param      _from     the address sending from\r\n     * @param      _to       the address sending to\r\n     */\r\n    function batchSafeTransferFrom(\r\n        uint256[] _tokenIds, \r\n        address _from, \r\n        address _to\r\n        )\r\n        public\r\n    {   \r\n        require (isBatchSupported);\r\n\r\n        require (_tokenIds.length > 0 && _from != address(0) && _to != address(0));\r\n\r\n        uint256 _id;\r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n            require (_tokenIds[i] != 0);\r\n            _id = _tokenIds[i];\r\n            safeTransferFrom(_from, _to, _id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice     Batch Function to approve the spender\r\n     * @dev        Helps to approve a batch of collectibles \r\n     * @param      _tokenIds  The asset identifiers\r\n     * @param      _spender   The spender\r\n     */\r\n    function batchApprove(\r\n        uint256[] _tokenIds, \r\n        address _spender\r\n        )\r\n        public\r\n    {   \r\n        require (isBatchSupported);\r\n\r\n        require (_tokenIds.length > 0 && _spender != address(0));\r\n        \r\n        uint256 _id;\r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n\r\n            require (_tokenIds[i] != 0);\r\n            \r\n            _id = _tokenIds[i];\r\n            approve(_spender, _id);\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * @dev        Batch Function to mark spender for approved for all. Does a check\r\n     * for address(0) and throws if true\r\n     * @notice     Facilitates batch approveAll\r\n     * @param      _spenders  The spenders\r\n     * @param      _approved  The approved\r\n     */\r\n    function batchSetApprovalForAll(\r\n        address[] _spenders,\r\n        bool _approved\r\n        )\r\n        public\r\n    {   \r\n        require (isBatchSupported);\r\n\r\n        require (_spenders.length > 0);\r\n\r\n        address _spender;\r\n        for (uint256 i = 0; i < _spenders.length; ++i) {        \r\n\r\n            require (address(_spenders[i]) != address(0));\r\n                \r\n            _spender = _spenders[i];\r\n            setApprovalForAll(_spender, _approved);\r\n        }\r\n    }  \r\n    \r\n    /**\r\n     * @dev        Function to request Detachment from our Contract\r\n     * @notice     a wallet can request to detach it collectible, so, that it can be used in other third-party contracts.\r\n     * @param      _tokenId  The token identifier\r\n     */\r\n    function requestDetachment(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n    {\r\n        //Request can only be made by owner or approved address\r\n        require (isApprovedOrOwner(msg.sender, _tokenId));\r\n\r\n        uint256 isAttached = checkIsAttached(_tokenId);\r\n\r\n        //If collectible is on a gamecard prevent detachment\r\n        require(getGameCardId(_tokenId) == 0);\r\n\r\n        require (isAttached >= 1);\r\n\r\n        if(attachedSystemActive == true) {\r\n            //Checks to see if request was made and if time elapsed\r\n            if(isAttached > 1 && block.timestamp - isAttached > detachmentTime) {\r\n                isAttached = 0;\r\n            } else if(isAttached > 1) {\r\n                //Forces Tx Fail if time is already set for attachment and not less than detachmentTime\r\n                require (isAttached == 1);\r\n            } else {\r\n                //Is attached, set detachment time and make request to detach\r\n                // emit AssetUpdated(_tokenId);\r\n                isAttached = block.timestamp;\r\n            }\r\n        } else {\r\n            isAttached = 0;\r\n        }\r\n\r\n        updateIsAttached(_tokenId, isAttached);\r\n    }\r\n\r\n    /**\r\n     * @dev        Function to attach the asset, thus, restricting transfer\r\n     * @notice     Attaches the collectible to our contract\r\n     * @param      _tokenId  The token identifier\r\n     */\r\n    function attachAsset(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        uint256 isAttached = checkIsAttached(_tokenId);\r\n\r\n        require (isAttached == 0);\r\n        isAttached = 1;\r\n\r\n        updateIsAttached(_tokenId, isAttached);\r\n\r\n        emit AssetUpdated(_tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev        Batch attach function\r\n     * @param      _tokenIds  The identifiers\r\n     */\r\n    function batchAttachAssets(uint256[] _tokenIds) public {\r\n        require (isBatchSupported);\r\n\r\n        for(uint i = 0; i < _tokenIds.length; i++) {\r\n            attachAsset(_tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Batch detach function\r\n     * @param      _tokenIds  The identifiers\r\n     */\r\n    function batchDetachAssets(uint256[] _tokenIds) public {\r\n        require (isBatchSupported);\r\n\r\n        for(uint i = 0; i < _tokenIds.length; i++) {\r\n            requestDetachment(_tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Function to facilitate detachment when contract is paused\r\n     * @param      _tokenId  The identifiers\r\n     */\r\n    function requestDetachmentOnPause (uint256 _tokenId) public whenPaused {\r\n        //Request can only be made by owner or approved address\r\n        require (isApprovedOrOwner(msg.sender, _tokenId));\r\n\r\n        updateIsAttached(_tokenId, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev        Toggle the Attachment Switch\r\n     * @param      _state  The state\r\n     */\r\n    function toggleAttachedEnforcement (bool _state) public onlyManager {\r\n        attachedSystemActive = _state;\r\n    }\r\n\r\n    /**\r\n     * @dev        Set Attachment Time Period (this restricts user from continuously trigger detachment)\r\n     * @param      _time  The time\r\n     */\r\n    function setDetachmentTime (uint256 _time) public onlyManager {\r\n        //Detactment Time can not be set greater than 2 weeks.\r\n        require (_time <= 1209600);\r\n        detachmentTime = uint32(_time);\r\n    }\r\n\r\n    /**\r\n     * @dev        Detach Asset From System\r\n     * @param      _tokenId  The token iddentifier\r\n     */\r\n    function setNFTDetached(uint256 _tokenId) public anyOperator {\r\n        require (checkIsAttached(_tokenId) > 0);\r\n\r\n        updateIsAttached(_tokenId, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev        Batch function to detach multiple assets\r\n     * @param      _tokenIds  The token identifiers\r\n     */\r\n    function setBatchDetachCollectibles(uint256[] _tokenIds) public anyOperator {\r\n        uint256 _id;\r\n        for(uint i = 0; i < _tokenIds.length; i++) {\r\n            _id = _tokenIds[i];\r\n            setNFTDetached(_id);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Function to update attach value\r\n     * @param      _tokenId     The asset id\r\n     * @param      _isAttached  Indicates if attached\r\n     */\r\n    function updateIsAttached(uint256 _tokenId, uint256 _isAttached) internal {\r\n        NFT memory obj  = _getAttributesOfToken(_tokenId);\r\n        \r\n        obj.isAttached = _isAttached;\r\n    \r\n        allNFTs[_tokenId] = obj;\r\n        emit AssetUpdated(_tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev   Facilitates Creating Sale using the Sale Contract. Forces owner check & collectibleId check\r\n    * @notice Helps a wallet to create a sale using our Sale Contract\r\n    * @param      _tokenId        The token identifier\r\n    * @param      _startingPrice  The starting price\r\n    * @param      _endingPrice    The ending price\r\n    * @param      _duration       The duration\r\n    */\r\n    function initiateCreateSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration) external {\r\n        require (_tokenId != 0);\r\n        \r\n        // If MLBNFT is already on any sale, this will throw\r\n        // because it will be owned by the sale contract.\r\n        address owner = ownerOf(_tokenId);\r\n        require (owner == msg.sender);\r\n\r\n        // Sale contract checks input sizes\r\n        require (_startingPrice == _startingPrice);\r\n        require (_endingPrice == _endingPrice);\r\n        require (_duration == _duration);\r\n\r\n        require (checkIsAttached(_tokenId) == 0);\r\n        \r\n        // One time approval for the tokenID\r\n        _approveForSale(msg.sender, address(saleManagerAddress), _tokenId);\r\n\r\n        saleManagerAddress.createSale(_tokenId, _startingPrice, _endingPrice, _duration, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev        Facilitates batch auction of collectibles, and enforeces strict checking on the collectibleId,starting/ending price, duration.\r\n     * @notice     Batch function to put 10 or less collectibles on sale\r\n     * @param      _tokenIds        The token identifier\r\n     * @param      _startingPrices  The starting price\r\n     * @param      _endingPrices    The ending price\r\n     * @param      _durations       The duration\r\n     */\r\n    function batchCreateAssetSale(uint256[] _tokenIds, uint256[] _startingPrices, uint256[] _endingPrices, uint256[] _durations) external whenNotPaused {\r\n\r\n        require (_tokenIds.length > 0 && _startingPrices.length > 0 && _endingPrices.length > 0 && _durations.length > 0);\r\n        \r\n        // Sale contract checks input sizes\r\n        for(uint ii = 0; ii < _tokenIds.length; ii++){\r\n\r\n            // Do not process for tokenId 0\r\n            require (_tokenIds[ii] != 0);\r\n            \r\n            require (_startingPrices[ii] == _startingPrices[ii]);\r\n            require (_endingPrices[ii] == _endingPrices[ii]);\r\n            require (_durations[ii] == _durations[ii]);\r\n\r\n            // If MLBNFT is already on any sale, this will throw\r\n            // because it will be owned by the sale contract.\r\n            address _owner = ownerOf(_tokenIds[ii]);\r\n            address _msgSender = msg.sender;\r\n            require (_owner == _msgSender);\r\n\r\n            // Check whether the collectible is inPlay. If inPlay cant put it on Sale\r\n            require (checkIsAttached(_tokenIds[ii]) == 0);\r\n            \r\n            // approve token to for Sale creation\r\n            _approveForSale(msg.sender, address(saleManagerAddress), _tokenIds[ii]);\r\n            \r\n            saleManagerAddress.createSale(_tokenIds[ii], _startingPrices[ii], _endingPrices[ii], _durations[ii], msg.sender);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_fromB\",\"type\":\"address[]\"},{\"name\":\"_toB\",\"type\":\"address[]\"}],\"name\":\"multiBatchSafeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8[]\"},{\"name\":\"_attributes\",\"type\":\"uint256[]\"},{\"name\":\"_playerOverrideId\",\"type\":\"uint256[]\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256[]\"},{\"name\":\"_to\",\"type\":\"address[]\"}],\"name\":\"batchCreateAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"requestDetachment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8\"},{\"name\":\"_posId\",\"type\":\"uint8\"},{\"name\":\"_attributes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_playerOverrideId\",\"type\":\"uint256\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256\"}],\"name\":\"createETHCardCollectible\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spenders\",\"type\":\"address[]\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"batchSetApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"detachmentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"promoCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_fromB\",\"type\":\"address[]\"},{\"name\":\"_toB\",\"type\":\"address[]\"}],\"name\":\"multiBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"generationSeasonDict\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"otherManagers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"giftAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleManagerAddress\",\"type\":\"address\"}],\"name\":\"setSaleManagerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"updateBatchSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"batchApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8\"},{\"name\":\"_posId\",\"type\":\"uint8\"},{\"name\":\"_attributes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_playerOverrideId\",\"type\":\"uint256\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256\"}],\"name\":\"createRewardCollectible\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MLB_Legal\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftTeamIndexToCollectibleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"contractsApprovedList\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8\"},{\"name\":\"_posId\",\"type\":\"uint8\"},{\"name\":\"_attributes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_playerOverrideId\",\"type\":\"uint256\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256\"}],\"name\":\"createSeedCollectible\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"checkIsAttached\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"removeFromApproveList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setDetachmentTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceSignature_ERC721Optional\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameCardNumber\",\"type\":\"uint256\"},{\"name\":\"_playerId\",\"type\":\"uint256\"}],\"name\":\"updateCurrentGameCardId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"attachedSystemActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getGameCardId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8[]\"},{\"name\":\"_attributes\",\"type\":\"uint256[]\"},{\"name\":\"_playerOverrideId\",\"type\":\"uint256[]\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256[]\"},{\"name\":\"_to\",\"type\":\"address[]\"}],\"name\":\"batchCreateETHCardAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLSNFT\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchDetachAssets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCollectibleDetails\",\"outputs\":[{\"name\":\"isAttached\",\"type\":\"uint256\"},{\"name\":\"sequenceId\",\"type\":\"uint32\"},{\"name\":\"teamId\",\"type\":\"uint8\"},{\"name\":\"positionId\",\"type\":\"uint8\"},{\"name\":\"creationTime\",\"type\":\"uint64\"},{\"name\":\"attributes\",\"type\":\"uint256\"},{\"name\":\"playerOverrideId\",\"type\":\"uint256\"},{\"name\":\"mlbGameId\",\"type\":\"uint256\"},{\"name\":\"currentGameCardId\",\"type\":\"uint256\"},{\"name\":\"mlbPlayerId\",\"type\":\"uint256\"},{\"name\":\"earnedBy\",\"type\":\"uint256\"},{\"name\":\"generationSeason\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsRedeemed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getTeamId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_earnedBy\",\"type\":\"uint256\"}],\"name\":\"updateEarnedBy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_startingPrices\",\"type\":\"uint256[]\"},{\"name\":\"_endingPrices\",\"type\":\"uint256[]\"},{\"name\":\"_durations\",\"type\":\"uint256[]\"}],\"name\":\"batchCreateAssetSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setSecondaryManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAbilitiesForCollectibleId\",\"outputs\":[{\"name\":\"ability\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPositionId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"removeAllAttachmentsFromCollectible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchAttachAssets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"noError\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint64\"}],\"name\":\"updateGenerationDict\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"batchSafeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_attachment\",\"type\":\"uint256\"}],\"name\":\"addAttachmentToCollectible\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftCollectibleAttachments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBatchSupported\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"setBatchDetachCollectibles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"hasError\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"nftTeamIdToSequenceIdToCollectible\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerPrimary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8\"},{\"name\":\"_posId\",\"type\":\"uint8\"},{\"name\":\"_attributes\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_gameId\",\"type\":\"uint256\"},{\"name\":\"_playerOverrideId\",\"type\":\"uint256\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256\"}],\"name\":\"createPromoCollectible\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"initiateCreateSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOp\",\"type\":\"address\"},{\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setOtherManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seedCreatedCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setPrimaryManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"attachAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"error\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"toggleAttachedEnforcement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"addToApproveList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint256\"}],\"name\":\"setGenerationSeasonController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"generationSeasonController\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleManagerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURIBase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"requestDetachmentOnPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAssetAttachment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"setNFTDetached\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_season\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint8\"}],\"name\":\"updateGenerationStopTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_newOverrideId\",\"type\":\"uint256\"}],\"name\":\"setPlayerOverrideId\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC721_RECEIVED\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerSecondary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBK\",\"type\":\"address\"}],\"name\":\"setBanker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getPlayerId\",\"outputs\":[{\"name\":\"playerId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AssetUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Created\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"MLBNFT","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b844c610420cdd36c8a3fb492ba0f595eacb52f350ee6bdad4aae6fb4b0665e0"}]}