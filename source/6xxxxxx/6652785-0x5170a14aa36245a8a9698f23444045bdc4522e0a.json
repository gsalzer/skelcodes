{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\nlibrary SafeMath {\r\n function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n        return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n    }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\ncontract DVPgame {\r\n    ERC20 public token;\r\n    uint256[] map;\r\n    using SafeERC20 for ERC20;\r\n    using SafeMath for uint256;\r\n    \r\n    constructor(address addr) payable{\r\n        token = ERC20(addr);\r\n    }\r\n    \r\n    function (){\r\n        if(map.length>=uint256(msg.sender)){\r\n            require(map[uint256(msg.sender)]!=1);\r\n        }\r\n        \r\n        if(token.balanceOf(this)==0){\r\n            //airdrop is over\r\n            selfdestruct(msg.sender);\r\n        }else{\r\n            token.safeTransfer(msg.sender,100);\r\n            \r\n            if (map.length <= uint256(msg.sender)) {\r\n                map.length = uint256(msg.sender) + 1;\r\n            }\r\n            map[uint256(msg.sender)] = 1;  \r\n\r\n        }\r\n    }\r\n    \r\n    //Guess the value(param:x) of the keccak256 value modulo 10000 of the future block (param:blockNum)\r\n    function guess(uint256 x,uint256 blockNum) public payable {\r\n        require(msg.value == 0.001 ether || token.allowance(msg.sender,address(this))>=1*(10**18));\r\n        require(blockNum>block.number);\r\n        if(token.allowance(msg.sender,address(this))>0){\r\n            token.safeTransferFrom(msg.sender,address(this),1*(10**18));\r\n        }\r\n        if (map.length <= uint256(msg.sender)+x) {\r\n            map.length = uint256(msg.sender)+x + 1;\r\n        }\r\n\r\n        map[uint256(msg.sender)+x] = blockNum;\r\n    }\r\n\r\n    //Run a lottery\r\n    function lottery(uint256 x) public {\r\n        require(map[uint256(msg.sender)+x]!=0);\r\n        require(block.number > map[uint256(msg.sender)+x]);\r\n        require(block.blockhash(map[uint256(msg.sender)+x])!=0);\r\n\r\n        uint256 answer = uint256(keccak256(block.blockhash(map[uint256(msg.sender)+x])))%10000;\r\n        \r\n        if (x == answer) {\r\n            token.safeTransfer(msg.sender,token.balanceOf(address(this)));\r\n            selfdestruct(msg.sender);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"blockNum\",\"type\":\"uint256\"}],\"name\":\"guess\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"lottery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"}]","ContractName":"DVPgame","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000008e30ea2329d95802fd804f4291220b0e2f579812","Library":"","SwarmSource":"bzzr://4de7cad24a1be91b4663016b44f08be8c338d4f18001bd133512e68d6e0a2db3"}]}