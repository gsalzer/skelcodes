{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n// File: contracts/crowdsale/Crowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    // The token being sold\r\n    ERC20 public token;\r\n\r\n    // Address where funds are collected\r\n    address public wallet;\r\n\r\n    // How many token units a buyer gets per wei.\r\n    // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n    // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n    // 1 wei will give you 1 unit, or 0.001 TOK.\r\n    uint256 public rate;\r\n\r\n    // Amount of wei raised\r\n    uint256 public weiRaised;\r\n\r\n    // Amount tokens Sold\r\n    uint256 public tokensSold;\r\n    \r\n    /**\r\n    * Event for token purchase logging\r\n    * @param purchaser who paid for the tokens\r\n    * @param beneficiary who got the tokens\r\n    * @param value weis paid for purchase\r\n    * @param amount amount of tokens purchased\r\n    */\r\n    event TokenPurchase(\r\n        address indexed purchaser,\r\n        address indexed beneficiary,\r\n        uint256 value,\r\n        uint256 amount\r\n    );\r\n\r\n    /**\r\n    * @param _rate Number of token units a buyer gets per wei\r\n    * @param _wallet Address where collected funds will be forwarded to\r\n    * @param _token Address of the token being sold\r\n    */\r\n    constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n        require(_rate > 0);\r\n        require(_wallet != address(0));\r\n        require(_token != address(0));\r\n\r\n        rate = _rate;\r\n        wallet = _wallet;\r\n        token = _token;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // Crowdsale external interface\r\n    // -----------------------------------------\r\n\r\n    /**\r\n    * @dev fallback function ***DO NOT OVERRIDE***\r\n    */\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev low level token purchase ***DO NOT OVERRIDE***\r\n    * @param _beneficiary Address performing the token purchase\r\n    */\r\n    function buyTokens(address _beneficiary) public payable {\r\n\r\n        uint256 weiAmount = msg.value;\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n        _preValidatePurchase(_beneficiary, weiAmount, tokens);\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n        tokensSold = tokensSold.add(tokens);\r\n\r\n        _processPurchase(_beneficiary, tokens);\r\n        emit TokenPurchase(\r\n            msg.sender,\r\n            _beneficiary,\r\n            weiAmount,\r\n            tokens\r\n        );\r\n\r\n        _updatePurchasingState(_beneficiary, weiAmount, tokens);\r\n\r\n        _forwardFunds();\r\n        _postValidatePurchase(_beneficiary, weiAmount, tokens);\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // Internal interface (extensible)\r\n    // -----------------------------------------\r\n\r\n    /**\r\n    * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n    * Example from CappedCrowdsale.sol's _preValidatePurchase method: \r\n    *   super._preValidatePurchase(_beneficiary, _weiAmount);\r\n    *   require(weiRaised.add(_weiAmount) <= cap);\r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _weiAmount Value in wei involved in the purchase\r\n    * @param _tokenAmount Value in token involved in the purchase\r\n    */\r\n    function _preValidatePurchase(\r\n        address _beneficiary,\r\n        uint256 _weiAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        require(_beneficiary != address(0));\r\n        require(_weiAmount != 0);\r\n    }\r\n\r\n    /**\r\n    * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _weiAmount Value in wei involved in the purchase\r\n    * @param _tokenAmount Value in token involved in the purchase\r\n    */\r\n    function _postValidatePurchase(\r\n        address _beneficiary,\r\n        uint256 _weiAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        // optional override\r\n    }\r\n\r\n    /**\r\n    * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _tokenAmount Number of tokens to be emitted\r\n    */\r\n    function _deliverTokens(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        token.safeTransfer(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n    * @param _beneficiary Address receiving the tokens\r\n    * @param _tokenAmount Number of tokens to be purchased\r\n    */\r\n    function _processPurchase(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        _deliverTokens(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n    * @param _beneficiary Address receiving the tokens\r\n    * @param _weiAmount Value in wei involved in the purchase\r\n    * @param _tokenAmount Value in token involved in the purchase\r\n    */\r\n    function _updatePurchasingState(\r\n        address _beneficiary,\r\n        uint256 _weiAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        // optional override\r\n    }\r\n\r\n    /**\r\n    * @dev Override to extend the way in which ether is converted to tokens.\r\n    * @param _weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 _weiAmount)\r\n        internal view returns (uint256)\r\n    {\r\n        return _weiAmount.mul(rate);\r\n    }\r\n\r\n    /**\r\n    * @dev Determines how ETH is stored/forwarded on purchases.\r\n    */\r\n    function _forwardFunds() internal {\r\n        wallet.transfer(msg.value);\r\n    }\r\n}\r\n\r\n// File: contracts/crowdsale/validation/TimedCrowdsale.sol\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public openingTime;\r\n    uint256 public closingTime;\r\n\r\n    /**\r\n    * @dev Reverts if not in crowdsale time range.\r\n    */\r\n    modifier onlyWhileOpen {\r\n        // solium-disable-next-line security/no-block-members\r\n        require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor, takes crowdsale opening and closing times.\r\n    * @param _openingTime Crowdsale opening time\r\n    * @param _closingTime Crowdsale closing time\r\n    */\r\n    constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n        // solium-disable-next-line security/no-block-members\r\n        require(_openingTime >= block.timestamp);\r\n        require(_closingTime > _openingTime);\r\n\r\n        openingTime = _openingTime;\r\n        closingTime = _closingTime;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n    * @return Whether crowdsale period has elapsed\r\n    */\r\n    function hasClosed() public view returns (bool) {\r\n        // solium-disable-next-line security/no-block-members\r\n        return block.timestamp > closingTime;\r\n    }\r\n\r\n    /**\r\n    * @dev Extend parent behavior requiring to be within contributing period\r\n    * @param _beneficiary Token purchaser\r\n    * @param _weiAmount Amount of wei contributed\r\n    * @param _tokenAmount Amount of token purchased\r\n    */\r\n    function _preValidatePurchase(\r\n        address _beneficiary,\r\n        uint256 _weiAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n        onlyWhileOpen\r\n    {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/crowdsale/validation/MilestoneCrowdsale.sol\r\n\r\n/**\r\n * @title MilestoneCrowdsale\r\n * @dev Crowdsale with multiple milestones separated by time and cap\r\n * @author Nikola Wyatt <nikola.wyatt@foodnation.io>\r\n */\r\ncontract MilestoneCrowdsale is TimedCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 public constant MAX_MILESTONE = 10;\r\n\r\n    /**\r\n    * Define pricing schedule using milestones.\r\n    */\r\n    struct Milestone {\r\n\r\n        // Milestone index in array\r\n        uint256 index;\r\n\r\n        // UNIX timestamp when this milestone starts\r\n        uint256 startTime;\r\n\r\n        // Amount of tokens sold in milestone\r\n        uint256 tokensSold;\r\n\r\n        // Maximum amount of Tokens accepted in the current Milestone.\r\n        uint256 cap;\r\n\r\n        // How many tokens per wei you will get after this milestone has been passed\r\n        uint256 rate;\r\n\r\n    }\r\n\r\n    /**\r\n    * Store milestones in a fixed array, so that it can be seen in a blockchain explorer\r\n    * Milestone 0 is always (0, 0)\r\n    * (TODO: change this when we confirm dynamic arrays are explorable)\r\n    */\r\n    Milestone[10] public milestones;\r\n\r\n    // How many active milestones have been created\r\n    uint256 public milestoneCount = 0;\r\n\r\n\r\n    bool public milestoningFinished = false;\r\n\r\n    constructor(        \r\n        uint256 _openingTime,\r\n        uint256 _closingTime\r\n        ) \r\n        TimedCrowdsale(_openingTime, _closingTime)\r\n        public \r\n        {\r\n        }\r\n\r\n    /**\r\n    * @dev Contruction, setting a list of milestones\r\n    * @param _milestoneStartTime uint[] milestones start time \r\n    * @param _milestoneCap uint[] milestones cap \r\n    * @param _milestoneRate uint[] milestones price \r\n    */\r\n    function setMilestonesList(uint256[] _milestoneStartTime, uint256[] _milestoneCap, uint256[] _milestoneRate) public {\r\n        // Need to have tuples, length check\r\n        require(!milestoningFinished);\r\n        require(_milestoneStartTime.length > 0);\r\n        require(_milestoneStartTime.length == _milestoneCap.length && _milestoneCap.length == _milestoneRate.length);\r\n        require(_milestoneStartTime[0] == openingTime);\r\n        require(_milestoneStartTime[_milestoneStartTime.length-1] < closingTime);\r\n\r\n        for (uint iterator = 0; iterator < _milestoneStartTime.length; iterator++) {\r\n            if (iterator > 0) {\r\n                assert(_milestoneStartTime[iterator] > milestones[iterator-1].startTime);\r\n            }\r\n            milestones[iterator] = Milestone({\r\n                index: iterator,\r\n                startTime: _milestoneStartTime[iterator],\r\n                tokensSold: 0,\r\n                cap: _milestoneCap[iterator],\r\n                rate: _milestoneRate[iterator]\r\n            });\r\n            milestoneCount++;\r\n        }\r\n        milestoningFinished = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Iterate through milestones. You reach end of milestones when rate = 0\r\n    * @return tuple (time, rate)\r\n    */\r\n    function getMilestoneTimeAndRate(uint256 n) public view returns (uint256, uint256) {\r\n        return (milestones[n].startTime, milestones[n].rate);\r\n    }\r\n\r\n    /**\r\n    * @dev Checks whether the cap of a milestone has been reached.\r\n    * @return Whether the cap was reached\r\n    */\r\n    function capReached(uint256 n) public view returns (bool) {\r\n        return milestones[n].tokensSold >= milestones[n].cap;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks amount of tokens sold in milestone.\r\n    * @return Amount of tokens sold in milestone\r\n    */\r\n    function getTokensSold(uint256 n) public view returns (uint256) {\r\n        return milestones[n].tokensSold;\r\n    }\r\n\r\n    function getFirstMilestone() private view returns (Milestone) {\r\n        return milestones[0];\r\n    }\r\n\r\n    function getLastMilestone() private view returns (Milestone) {\r\n        return milestones[milestoneCount-1];\r\n    }\r\n\r\n    function getFirstMilestoneStartsAt() public view returns (uint256) {\r\n        return getFirstMilestone().startTime;\r\n    }\r\n\r\n    function getLastMilestoneStartsAt() public view returns (uint256) {\r\n        return getLastMilestone().startTime;\r\n    }\r\n\r\n    /**\r\n    * @dev Get the current milestone or bail out if we are not in the milestone periods.\r\n    * @return {[type]} [description]\r\n    */\r\n    function getCurrentMilestoneIndex() internal view onlyWhileOpen returns  (uint256) {\r\n        uint256 index;\r\n\r\n        // Found the current milestone by evaluating time. \r\n        // If (now < next start) the current milestone is the previous\r\n        // Stops loop if finds current\r\n        for(uint i = 0; i < milestoneCount; i++) {\r\n            index = i;\r\n            // solium-disable-next-line security/no-block-members\r\n            if(block.timestamp < milestones[i].startTime) {\r\n                index = i - 1;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // For the next code, you may ask why not assert if last milestone surpass cap...\r\n        // Because if its last and it is capped we would like to finish not sell any more tokens \r\n        // Check if the current milestone has reached it's cap\r\n        if (milestones[index].tokensSold > milestones[index].cap) {\r\n            index = index + 1;\r\n        }\r\n\r\n        return index;\r\n    }\r\n\r\n    /**\r\n    * @dev Extend parent behavior requiring purchase to respect the funding cap from the currentMilestone.\r\n    * @param _beneficiary Token purchaser\r\n    * @param _weiAmount Amount of wei contributed\r\n    * @param _tokenAmount Amount of token purchased\r\n    \r\n    */\r\n    function _preValidatePurchase(\r\n        address _beneficiary,\r\n        uint256 _weiAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\r\n        require(milestones[getCurrentMilestoneIndex()].tokensSold.add(_tokenAmount) <= milestones[getCurrentMilestoneIndex()].cap);\r\n    }\r\n\r\n    /**\r\n    * @dev Extend parent behavior to update current milestone state and index\r\n    * @param _beneficiary Token purchaser\r\n    * @param _weiAmount Amount of wei contributed\r\n    * @param _tokenAmount Amount of token purchased\r\n    */\r\n    function _updatePurchasingState(\r\n        address _beneficiary,\r\n        uint256 _weiAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        super._updatePurchasingState(_beneficiary, _weiAmount, _tokenAmount);\r\n        milestones[getCurrentMilestoneIndex()].tokensSold = milestones[getCurrentMilestoneIndex()].tokensSold.add(_tokenAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the current price.\r\n    * @return The current price or 0 if we are outside milestone period\r\n    */\r\n    function getCurrentRate() internal view returns (uint result) {\r\n        return milestones[getCurrentMilestoneIndex()].rate;\r\n    }\r\n\r\n    /**\r\n    * @dev Override to extend the way in which ether is converted to tokens.\r\n    * @param _weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 _weiAmount)\r\n        internal view returns (uint256)\r\n    {\r\n        return _weiAmount.mul(getCurrentRate());\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/price/USDPrice.sol\r\n\r\n/**\r\n* @title USDPrice\r\n* @dev Contract that calculates the price of tokens in USD cents.\r\n* Note that this contracts needs to be updated\r\n*/\r\ncontract USDPrice is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // PRICE of 1 ETHER in USD in cents\r\n    // So, if price is: $271.90, the value in variable will be: 27190\r\n    uint256 public ETHUSD;\r\n\r\n    // Time of Last Updated Price\r\n    uint256 public updatedTime;\r\n\r\n    // Historic price of ETH in USD in cents\r\n    mapping (uint256 => uint256) public priceHistory;\r\n\r\n    event PriceUpdated(uint256 price);\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    function getHistoricPrice(uint256 time) public view returns (uint256) {\r\n        return priceHistory[time];\r\n    } \r\n\r\n    function updatePrice(uint256 price) public onlyOwner {\r\n        require(price > 0);\r\n\r\n        priceHistory[updatedTime] = ETHUSD;\r\n\r\n        ETHUSD = price;\r\n        // solium-disable-next-line security/no-block-members\r\n        updatedTime = block.timestamp;\r\n\r\n        emit PriceUpdated(ETHUSD);\r\n    }\r\n\r\n    /**\r\n    * @dev Override to extend the way in which ether is converted to USD.\r\n    * @param _weiAmount Value in wei to be converted into tokens\r\n    * @return The value of wei amount in USD cents\r\n    */\r\n    function getPrice(uint256 _weiAmount)\r\n        public view returns (uint256)\r\n    {\r\n        return _weiAmount.mul(ETHUSD);\r\n    }\r\n    \r\n}\r\n\r\n// File: contracts/Sale.sol\r\n\r\ninterface MintableERC20 {\r\n    function mint(address _to, uint256 _amount) public returns (bool);\r\n}\r\n/**\r\n * @title PreSale\r\n * @dev Crowdsale accepting contributions only within a time frame, \r\n * having milestones defined, the price is defined in USD\r\n * having a mechanism to refund sales if soft cap not capReached();\r\n */\r\ncontract PreSale is Ownable, Crowdsale, MilestoneCrowdsale {\r\n    using SafeMath for uint256;\r\n\r\n    /// Max amount of tokens to be contributed\r\n    uint256 public cap;\r\n\r\n    /// Minimum amount of wei per contribution\r\n    uint256 public minimumContribution;\r\n    \r\n    bool public isFinalized = false;\r\n\r\n    USDPrice private usdPrice; \r\n\r\n    event Finalized();\r\n\r\n    constructor(\r\n        uint256 _rate,\r\n        address _wallet,\r\n        ERC20 _token,\r\n        uint256 _openingTime,\r\n        uint256 _closingTime,\r\n        uint256 _cap,\r\n        uint256 _minimumContribution,\r\n        USDPrice _usdPrice\r\n    )\r\n        Crowdsale(_rate, _wallet, _token)\r\n        MilestoneCrowdsale(_openingTime, _closingTime)\r\n        public\r\n    {  \r\n        require(_cap > 0);\r\n        require(_minimumContribution > 0);\r\n        \r\n        cap = _cap;\r\n        minimumContribution = _minimumContribution;\r\n\r\n        usdPrice = _usdPrice;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Checks whether the cap has been reached.\r\n    * @return Whether the cap was reached\r\n    */\r\n    function capReached() public view returns (bool) {\r\n        return tokensSold >= cap;\r\n    }\r\n\r\n    /**\r\n    * @dev Must be called after crowdsale ends, to do some extra finalization\r\n    * work. Calls the contract's finalization function.\r\n    */\r\n    function finalize() public onlyOwner {\r\n        require(!isFinalized);\r\n        require(hasClosed());\r\n\r\n        emit Finalized();\r\n\r\n        isFinalized = true;\r\n    }\r\n\r\n    /**\r\n    * @dev Override to extend the way in which ether is converted to tokens.\r\n    * @param _weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 _weiAmount)\r\n        internal view returns (uint256)\r\n    {\r\n        return usdPrice.getPrice(_weiAmount).div(getCurrentRate());\r\n    }\r\n\r\n    /**\r\n    * @dev Extend parent behavior sending heartbeat to token.\r\n    * @param _beneficiary Address receiving the tokens\r\n    * @param _weiAmount Value in wei involved in the purchase\r\n    * @param _tokenAmount Value in token involved in the purchase\r\n    */\r\n    function _updatePurchasingState(\r\n        address _beneficiary,\r\n        uint256 _weiAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        super._updatePurchasingState(_beneficiary, _weiAmount, _tokenAmount);\r\n    }\r\n    \r\n    /**\r\n    * @dev Overrides delivery by minting tokens upon purchase. - MINTED Crowdsale\r\n    * @param _beneficiary Token purchaser\r\n    * @param _tokenAmount Number of tokens to be minted\r\n    */\r\n    function _deliverTokens(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        // Potentially dangerous assumption about the type of the token.\r\n        require(MintableERC20(address(token)).mint(_beneficiary, _tokenAmount));\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Extend parent behavior requiring purchase to respect the funding cap.\r\n    * @param _beneficiary Token purchaser\r\n    * @param _weiAmount Amount of wei contributed\r\n    * @param _tokenAmount Amount of token purchased\r\n    */\r\n    function _preValidatePurchase(\r\n        address _beneficiary,\r\n        uint256 _weiAmount,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        super._preValidatePurchase(_beneficiary, _weiAmount, _tokenAmount);\r\n        require(_weiAmount >= minimumContribution);\r\n        require(tokensSold.add(_tokenAmount) <= cap);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"milestoneCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getMilestoneTimeAndRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFirstMilestoneStartsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_milestoneStartTime\",\"type\":\"uint256[]\"},{\"name\":\"_milestoneCap\",\"type\":\"uint256[]\"},{\"name\":\"_milestoneRate\",\"type\":\"uint256[]\"}],\"name\":\"setMilestonesList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumContribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_MILESTONE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"milestoningFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLastMilestoneStartsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"milestones\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"tokensSold\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_minimumContribution\",\"type\":\"uint256\"},{\"name\":\"_usdPrice\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PreSale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000bd753de77c5efb62cfb542e02de4b18e9734e87a000000000000000000000000bd2db105b965d74e91deed64ec4b441beab9d498000000000000000000000000000000000000000000000000000000005c218f20000000000000000000000000000000000000000000000000000000005c774eb0000000000000000000000000000000000000000000295be96e6406697200000000000000000000000000000000000000000000000000000006f05b59d3b20000000000000000000000000000b7cfd7f79aa6efb213daf5523c25e4bce11e1037","Library":"","SwarmSource":"bzzr://a4b944261044547f628cee1531a10e135594e0e7643cd8a45f0d0641daa1cf1c"}]}