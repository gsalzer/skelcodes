{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/** \r\n * @title IndexConsumer\r\n * @dev This contract adds an autoincrementing index to contracts. \r\n */\r\ncontract IndexConsumer {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /** The index */\r\n    uint256 private freshIndex = 0;\r\n\r\n    /** Fetch the next index */\r\n    function nextIndex() internal returns (uint256) {\r\n        uint256 theIndex = freshIndex;\r\n        freshIndex = freshIndex.add(1);\r\n        return theIndex;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title CapTables\r\n * @dev The sole purpose of this contract is to store the cap tables of securities\r\n * created by the OFN system.  We take the position that a security is defined\r\n * by its cap table and not by its transfer rules.  So a security is\r\n * represented by a unique integer index.  A security has a fixed amount and we\r\n * preserve this invariant by allowing no other cap table updates beside\r\n * transfers.\r\n */\r\ncontract CapTables is IndexConsumer {\r\n    using SafeMath for uint256;\r\n\r\n    /** Address of security */\r\n    mapping(uint256 => address) public addresses;\r\n    mapping(address => uint) private indexes;\r\n\r\n    /** `capTable(security, user) == userBalance` */\r\n    mapping(uint256 => mapping(address => uint256)) public capTable;\r\n\r\n    /** Total token supplies */\r\n    mapping(uint256 => uint256) public totalSupply;\r\n\r\n    /* EVENTS */\r\n\r\n    \r\n\r\n    event NewSecurity(uint256 security);\r\n    event SecurityMigration(uint256 security, address newAddress);\r\n\r\n    modifier onlySecurity(uint256 security) {  \r\n        require(\r\n            msg.sender == addresses[security], \r\n            \"this method MUST be called by the security's control account\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /** @dev retrieve the balance at a given address */\r\n    function balanceOf(uint256 security, address user) public view returns (uint256) {\r\n        return capTable[security][user];\r\n    }\r\n\r\n    /** @dev Add a security to the contract. */\r\n    function initialize(uint256 supply, address manager) public returns (uint256) {\r\n        uint256 index = nextIndex();\r\n        addresses[index] = manager;\r\n        capTable[index][manager] = supply;\r\n        totalSupply[index] = supply;\r\n        indexes[manager] = index;\r\n        emit NewSecurity(index);\r\n        return index;\r\n    }\r\n\r\n\r\n    /** @dev Migrate a security to a new address, if its transfer restriction rules change. */\r\n    function migrate(uint256 security, address newAddress) public onlySecurity(security) {\r\n        addresses[security] = newAddress;\r\n        emit SecurityMigration(security, newAddress);\r\n    }\r\n\r\n    /** @dev Transfer an amount of security. */\r\n    function transfer(uint256 security, address src, address dest, uint256 amount) \r\n        public \r\n        onlySecurity(security) \r\n    {\r\n        capTable[security][src] = capTable[security][src].sub(amount);\r\n        capTable[security][dest] = capTable[security][dest].add(amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"security\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"security\",\"type\":\"uint256\"},{\"name\":\"src\",\"type\":\"address\"},{\"name\":\"dest\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"security\",\"type\":\"uint256\"},{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"migrate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"capTable\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"supply\",\"type\":\"uint256\"},{\"name\":\"manager\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"security\",\"type\":\"uint256\"}],\"name\":\"NewSecurity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"security\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"SecurityMigration\",\"type\":\"event\"}]","ContractName":"CapTables","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7dd2f662fdb758933d9a72de90b02cd791dce5ac655dbc853b3a2762f441274e"}]}