{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/*************** TPL Crypto Copycats Cooperative (CCC) - Devcon4 **************\r\n * Use at your own risk, these contracts are experimental and lightly tested! *\r\n * Documentation & tests at https://github.com/TPL-protocol/tpl-contracts     *\r\n * Implements an Attribute Registry https://github.com/0age/AttributeRegistry *\r\n *                                                                            *\r\n * Source layout:                                    Line #                   *\r\n *  - interface AttributeRegistryInterface             25                     *\r\n *  - interface TPLBasicValidatorInterface             79                     *\r\n *  - interface BasicJurisdictionInterface            132                     *\r\n *  - contract TPLBasicValidator                      350                     *\r\n *    - is TPLBasicValidatorInterface                                         *\r\n *  - contract CryptoCopycatsCooperative              516                     *\r\n *    - is TPLBasicValidator                                                  *\r\n *                                                                            *\r\n *   https://github.com/TPL-protocol/tpl-contracts/blob/master/LICENSE.md     *\r\n ******************************************************************************/\r\n\r\n\r\n/**\r\n * @title Attribute Registry interface. EIP-165 ID: 0x5f46473f\r\n */\r\ninterface AttributeRegistryInterface {\r\n  /**\r\n   * @notice Check if an attribute of the type with ID `attributeTypeID` has\r\n   * been assigned to the account at `account` and is currently valid.\r\n   * @param account address The account to check for a valid attribute.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return True if the attribute is assigned and valid, false otherwise.\r\n   * @dev This function MUST return either true or false - i.e. calling this\r\n   * function MUST NOT cause the caller to revert.\r\n   */\r\n  function hasAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Retrieve the value of the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account`, assuming it is valid.\r\n   * @param account address The account to check for the given attribute value.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return The attribute value if the attribute is valid, reverts otherwise.\r\n   * @dev This function MUST revert if a directly preceding or subsequent\r\n   * function call to `hasAttribute` with identical `account` and\r\n   * `attributeTypeID` parameters would return false.\r\n   */\r\n  function getAttributeValue(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the registry.\r\n   * @return The number of available attribute types.\r\n   * @dev This function MUST return a positive integer value  - i.e. calling\r\n   * this function MUST NOT cause the caller to revert.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   * @dev This function MUST revert if the provided `index` value falls outside\r\n   * of the range of the value returned from a directly preceding or subsequent\r\n   * function call to `countAttributeTypes`. It MUST NOT revert if the provided\r\n   * `index` value falls inside said range.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title TPL Basic Validator interface. EIP-165 ID: 0xa1833e9a\r\n */\r\ninterface TPLBasicValidatorInterface {\r\n  /**\r\n   * @notice Check if contract is assigned as a validator on the jurisdiction.\r\n   * @return True if validator is assigned, false otherwise.\r\n   */  \r\n  function isValidator() external view returns (bool);\r\n\r\n  /**\r\n   * @notice Check if the validator is approved to issue attributes of the type\r\n   * with ID `attributeTypeID` on the jurisdiction.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return True if validator is approved to issue attributes of given type.\r\n   */  \r\n  function canIssueAttributeType(\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Check if the validator is approved to issue an attribute of the\r\n   * type with ID `attributeTypeID` to account `account` on the jurisdiction.\r\n   * @param account address The account to check for issuing the attribute to.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return Bool indicating if attribute is issuable & byte with status code.\r\n   */  \r\n  function canIssueAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool, bytes1);\r\n\r\n  /**\r\n   * @notice Check if the validator is approved to revoke an attribute of the\r\n   * type with ID `attributeTypeID` from account `account` on the jurisdiction.\r\n   * @param account address The checked account for revoking the attribute from.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return Bool indicating if attribute is revocable & byte with status code.\r\n   */  \r\n  function canRevokeAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool, bytes1);\r\n\r\n  /**\r\n   * @notice Get account of utilized jurisdiction and associated attribute\r\n   * registry managed by the jurisdiction.\r\n   * @return The account of the jurisdiction.\r\n   */\r\n  function getJurisdiction() external view returns (address);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic TPL Jurisdiction Interface.\r\n */\r\ninterface BasicJurisdictionInterface {\r\n  // declare events\r\n  event AttributeTypeAdded(uint256 indexed attributeTypeID, string description);\r\n  \r\n  event AttributeTypeRemoved(uint256 indexed attributeTypeID);\r\n  \r\n  event ValidatorAdded(address indexed validator, string description);\r\n  \r\n  event ValidatorRemoved(address indexed validator);\r\n  \r\n  event ValidatorApprovalAdded(\r\n    address validator,\r\n    uint256 indexed attributeTypeID\r\n  );\r\n\r\n  event ValidatorApprovalRemoved(\r\n    address validator,\r\n    uint256 indexed attributeTypeID\r\n  );\r\n\r\n  event AttributeAdded(\r\n    address validator,\r\n    address indexed attributee,\r\n    uint256 attributeTypeID,\r\n    uint256 attributeValue\r\n  );\r\n\r\n  event AttributeRemoved(\r\n    address validator,\r\n    address indexed attributee,\r\n    uint256 attributeTypeID\r\n  );\r\n\r\n  /**\r\n  * @notice Add an attribute type with ID `ID` and description `description` to\r\n  * the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to add.\r\n  * @param description string A description of the attribute type.\r\n  * @dev Once an attribute type is added with a given ID, the description of the\r\n  * attribute type cannot be changed, even if the attribute type is removed and\r\n  * added back later.\r\n  */\r\n  function addAttributeType(uint256 ID, string description) external;\r\n\r\n  /**\r\n  * @notice Remove the attribute type with ID `ID` from the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to remove.\r\n  * @dev All issued attributes of the given type will become invalid upon\r\n  * removal, but will become valid again if the attribute is reinstated.\r\n  */\r\n  function removeAttributeType(uint256 ID) external;\r\n\r\n  /**\r\n  * @notice Add account `validator` as a validator with a description\r\n  * `description` who can be approved to set attributes of specific types.\r\n  * @param validator address The account to assign as the validator.\r\n  * @param description string A description of the validator.\r\n  * @dev Note that the jurisdiction can add iteslf as a validator if desired.\r\n  */\r\n  function addValidator(address validator, string description) external;\r\n\r\n  /**\r\n  * @notice Remove the validator at address `validator` from the jurisdiction.\r\n  * @param validator address The account of the validator to remove.\r\n  * @dev Any attributes issued by the validator will become invalid upon their\r\n  * removal. If the validator is reinstated, those attributes will become valid\r\n  * again. Any approvals to issue attributes of a given type will need to be\r\n  * set from scratch in the event a validator is reinstated.\r\n  */\r\n  function removeValidator(address validator) external;\r\n\r\n  /**\r\n  * @notice Approve the validator at address `validator` to issue attributes of\r\n  * the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator to approve.\r\n  * @param attributeTypeID uint256 The ID of the approved attribute type.\r\n  */\r\n  function addValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Deny the validator at address `validator` the ability to continue to\r\n  * issue attributes of the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator with removed approval.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to unapprove.\r\n  * @dev Any attributes of the specified type issued by the validator in\r\n  * question will become invalid once the approval is removed. If the approval\r\n  * is reinstated, those attributes will become valid again. The approval will\r\n  * also be removed if the approved validator is removed.\r\n  */\r\n  function removeValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Issue an attribute of the type with ID `attributeTypeID` and a value\r\n  * of `value` to `account` if `message.caller.address()` is approved validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @param value uint256 An optional value for the issued attribute.\r\n  * @dev Existing attributes of the given type on the address must be removed\r\n  * in order to set a new attribute. Be aware that ownership of the account to\r\n  * which the attribute is assigned may still be transferable - restricting\r\n  * assignment to externally-owned accounts may partially alleviate this issue.\r\n  */\r\n  function issueAttribute(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value\r\n  ) external payable;\r\n\r\n  /**\r\n  * @notice Revoke the attribute of the type with ID `attributeTypeID` from\r\n  * `account` if `message.caller.address()` is the issuing validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @dev Validators may still revoke issued attributes even after they have been\r\n  * removed or had their approval to issue the attribute type removed - this\r\n  * enables them to address any objectionable issuances before being reinstated.\r\n  */\r\n  function revokeAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Determine if a validator at account `validator` is able to issue\r\n   * attributes of the type with ID `attributeTypeID`.\r\n   * @param validator address The account of the validator.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check.\r\n   * @return True if the validator can issue attributes of the given type, false\r\n   * otherwise.\r\n   */\r\n  function canIssueAttributeType(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Get a description of the attribute type with ID `attributeTypeID`.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return A description of the attribute type.\r\n   */\r\n  function getAttributeTypeDescription(\r\n    uint256 attributeTypeID\r\n  ) external view returns (string description);\r\n  \r\n  /**\r\n   * @notice Get a description of the validator at account `validator`.\r\n   * @param validator address The account of the validator in question.\r\n   * @return A description of the validator.\r\n   */\r\n  function getValidatorDescription(\r\n    address validator\r\n  ) external view returns (string description);\r\n\r\n  /**\r\n   * @notice Find the validator that issued the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account` and determine if the\r\n   * validator is still valid.\r\n   * @param account address The account that contains the attribute be checked.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return The validator and the current status of the validator as it\r\n   * pertains to the attribute type in question.\r\n   * @dev if no attribute of the given attribute type exists on the account, the\r\n   * function will return (address(0), false).\r\n   */\r\n  function getAttributeValidator(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (address validator, bool isStillValid);\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the jurisdiction.\r\n   * @return The number of available attribute types.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the IDs of all available attribute types on the jurisdiction.\r\n   * @return A dynamic array containing all available attribute type IDs.\r\n   */\r\n  function getAttributeTypeIDs() external view returns (uint256[]);\r\n\r\n  /**\r\n   * @notice Count the number of validators defined by the jurisdiction.\r\n   * @return The number of defined validators.\r\n   */\r\n  function countValidators() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the account of the validator at index `index`.\r\n   * @param index uint256 The index of the validator in question.\r\n   * @return The account of the validator.\r\n   */\r\n  function getValidator(uint256 index) external view returns (address);\r\n\r\n  /**\r\n   * @notice Get the accounts of all available validators on the jurisdiction.\r\n   * @return A dynamic array containing all available validator accounts.\r\n   */\r\n  function getValidators() external view returns (address[]);\r\n}\r\n\r\n\r\n/**\r\n * @title An instance of TPLBasicValidator, issue & revoke an attribute type.\r\n */\r\ncontract TPLBasicValidator is TPLBasicValidatorInterface {\r\n\r\n  // declare registry interface, used to request attributes from a jurisdiction\r\n  AttributeRegistryInterface internal _registry;\r\n\r\n  // declare registry interface, set to same address as the registry\r\n  BasicJurisdictionInterface internal _jurisdiction;\r\n\r\n  // declare attribute ID required in order to receive transferred tokens\r\n  uint256 internal _validAttributeTypeID;\r\n\r\n  /**\r\n  * @notice The constructor function, with an associated attribute registry at\r\n  * `registry` and an assignable attribute type with ID `validAttributeTypeID`.\r\n  * @param registry address The account of the associated attribute registry.  \r\n  * @param validAttributeTypeID uint256 The ID of the required attribute type.\r\n  * @dev Note that it may be appropriate to require that the referenced\r\n  * attribute registry supports the correct interface via EIP-165.\r\n  */\r\n  constructor(\r\n    AttributeRegistryInterface registry,\r\n    uint256 validAttributeTypeID\r\n  ) public {\r\n    _registry = AttributeRegistryInterface(registry);\r\n    _jurisdiction = BasicJurisdictionInterface(registry);\r\n    _validAttributeTypeID = validAttributeTypeID;\r\n  }\r\n\r\n  /**\r\n   * @notice Check if contract is assigned as a validator on the jurisdiction.\r\n   * @return True if validator is assigned, false otherwise.\r\n   */  \r\n  function isValidator() external view returns (bool) {\r\n    uint256 totalValidators = _jurisdiction.countValidators();\r\n    \r\n    for (uint256 i = 0; i < totalValidators; i++) {\r\n      address validator = _jurisdiction.getValidator(i);\r\n      if (validator == address(this)) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * @notice Check if the validator is approved to issue attributes of the type\r\n   * with ID `attributeTypeID` on the jurisdiction.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return True if validator is approved to issue attributes of given type.\r\n   */  \r\n  function canIssueAttributeType(\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool) {\r\n    return (\r\n      _validAttributeTypeID == attributeTypeID &&\r\n      _jurisdiction.canIssueAttributeType(address(this), _validAttributeTypeID)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Check if the validator is approved to issue an attribute of the\r\n   * type with ID `attributeTypeID` to account `account` on the jurisdiction.\r\n   * @param account address The account to check for issuing the attribute to.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return Bool indicating if attribute is issuable & byte with status code.\r\n   * @dev This function could definitely use additional checks and error codes.\r\n   */  \r\n  function canIssueAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool, bytes1) {\r\n    // Only the predefined attribute type can be issued by this validator.\r\n    if (_validAttributeTypeID != attributeTypeID) {\r\n      return (false, hex\"A0\");\r\n    }\r\n\r\n    // Attributes can't be issued if one already exists on the given account.\r\n    if (_registry.hasAttribute(account, _validAttributeTypeID)) {\r\n      return (false, hex\"B0\");\r\n    }\r\n\r\n    return (true, hex\"01\");\r\n  }\r\n\r\n  /**\r\n   * @notice Check if the validator is approved to revoke an attribute of the\r\n   * type with ID `attributeTypeID` from account `account` on the jurisdiction.\r\n   * @param account address The checked account for revoking the attribute from.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return Bool indicating if attribute is revocable & byte with status code.\r\n   * @dev This function could definitely use additional checks and error codes.\r\n   */  \r\n  function canRevokeAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool, bytes1) {\r\n    // Only the predefined attribute type can be revoked by this validator.\r\n    if (_validAttributeTypeID != attributeTypeID) {\r\n      return (false, hex\"A0\");\r\n    }\r\n\r\n    // Attributes can't be revoked if they don't exist on the given account.\r\n    if (!_registry.hasAttribute(account, _validAttributeTypeID)) {\r\n      return (false, hex\"B0\");\r\n    }\r\n\r\n    // Only the issuing validator can revoke an attribute.\r\n    (address validator, bool unused) = _jurisdiction.getAttributeValidator(\r\n      account,\r\n      _validAttributeTypeID\r\n    );\r\n    unused;\r\n\r\n    if (validator != address(this)) {\r\n      return (false, hex\"C0\");\r\n    }    \r\n\r\n    return (true, hex\"01\");\r\n  }\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type required to hold tokens.\r\n   * @return The ID of the required attribute type.\r\n   */\r\n  function getValidAttributeID() external view returns (uint256) {\r\n    return _validAttributeTypeID;\r\n  }\r\n\r\n  /**\r\n   * @notice Get account of utilized jurisdiction and associated attribute\r\n   * registry managed by the jurisdiction.\r\n   * @return The account of the jurisdiction.\r\n   */\r\n  function getJurisdiction() external view returns (address) {\r\n    return address(_jurisdiction);\r\n  }\r\n\r\n  /**\r\n   * @notice Issue an attribute of the type with the default ID to account\r\n   * `account` on the jurisdiction. Values are left at zero.\r\n   * @param account address The account to issue the attribute to.\r\n   * @return True if attribute has been successfully issued, false otherwise.\r\n   */  \r\n  function _issueAttribute(address account) internal returns (bool) {\r\n    _jurisdiction.issueAttribute(account, _validAttributeTypeID, 0);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Revoke an attribute of the type with ID `attributeTypeID` from\r\n   * account `account` on the jurisdiction.\r\n   * @param account address The account to revoke the attribute from.\r\n   * @return True if attribute has been successfully revoked, false otherwise.\r\n   */  \r\n  function _revokeAttribute(address account) internal returns (bool) {\r\n    _jurisdiction.revokeAttribute(account, _validAttributeTypeID);\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title An instance of TPLBasicValidator with external functions to add and\r\n * revoke attributes.\r\n */\r\ncontract CryptoCopycatsCooperative is TPLBasicValidator {\r\n\r\n  string public name = \"Crypto Copycats Cooperative\";\r\n\r\n  mapping(address => bool) private _careCoordinator;\r\n\r\n  /**\r\n  * @notice The constructor function, with an associated attribute registry at\r\n  * `registry` and an assignable attribute type with ID `validAttributeTypeID`.\r\n  * @param registry address The account of the associated attribute registry.  \r\n  * @param validAttributeTypeID uint256 The ID of the required attribute type.\r\n  * @dev Note that it may be appropriate to require that the referenced\r\n  * attribute registry supports the correct interface via EIP-165.\r\n  */\r\n  constructor(\r\n    AttributeRegistryInterface registry,\r\n    uint256 validAttributeTypeID\r\n  ) public TPLBasicValidator(registry, validAttributeTypeID) {\r\n    _careCoordinator[msg.sender] = true;\r\n  }\r\n\r\n  modifier onlyCareCoordinators() {\r\n    require(\r\n      _careCoordinator[msg.sender],\r\n      \"This method may only be called by a care coordinator.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function addCareCoordinator(address account) external onlyCareCoordinators {\r\n    _careCoordinator[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @notice Issue an attribute of the type with the default ID to `msg.sender`\r\n   * on the jurisdiction. Values are left at zero.\r\n   */  \r\n  function issueAttribute(\r\n    bool doYouLoveCats,\r\n    bool doYouLoveDogsMoreThanCats,\r\n    bool areYouACrazyCatLady\r\n  ) external {\r\n    require(doYouLoveCats, \"only cat lovers allowed\");\r\n    require(doYouLoveDogsMoreThanCats, \"no liars allowed\");\r\n    require(!areYouACrazyCatLady, \"we are very particular\");\r\n    require(_issueAttribute(msg.sender));\r\n  }\r\n\r\n  /**\r\n   * @notice Revoke an attribute from the type with the default ID from\r\n   * `msg.sender` on the jurisdiction.\r\n   */  \r\n  function revokeAttribute(address account) external onlyCareCoordinators {\r\n    require(_revokeAttribute(account));\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getJurisdiction\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"canIssueAttribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"canRevokeAttribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"canIssueAttributeType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addCareCoordinator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"doYouLoveCats\",\"type\":\"bool\"},{\"name\":\"doYouLoveDogsMoreThanCats\",\"type\":\"bool\"},{\"name\":\"areYouACrazyCatLady\",\"type\":\"bool\"}],\"name\":\"issueAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"revokeAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidAttributeID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"registry\",\"type\":\"address\"},{\"name\":\"validAttributeTypeID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"CryptoCopycatsCooperative","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"000000000000000000000000951996f7f031ddc2f6f2b9f680454f8cc1aa776e00000000000000000000000000000000000000000000000000000000000056ce","Library":"","SwarmSource":"bzzr://976710c443ff31880a58482e1deb1154ef6778f4ff397acbf8bec9d9bf84e524"}]}