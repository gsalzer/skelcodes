{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n   @title SafeMath\r\n   @notice Implements SafeMath\r\n*/\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n\r\n        assert(a == 0 || c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n\r\n        return a - b;\r\n    }\r\n\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n\r\n        assert(c >= a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Hasher {\r\n\r\n    /*\r\n     *  Public pure functions\r\n     */\r\n    function hashUuid(\r\n        string _symbol,\r\n        string _name,\r\n        uint256 _chainIdValue,\r\n        uint256 _chainIdUtility,\r\n        address _openSTUtility,\r\n        uint256 _conversionRate,\r\n        uint8 _conversionRateDecimals)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            _symbol,\r\n            _name,\r\n            _chainIdValue,\r\n            _chainIdUtility,\r\n            _openSTUtility,\r\n            _conversionRate,\r\n            _conversionRateDecimals);\r\n    }\r\n\r\n    function hashStakingIntent(\r\n        bytes32 _uuid,\r\n        address _account,\r\n        uint256 _accountNonce,\r\n        address _beneficiary,\r\n        uint256 _amountST,\r\n        uint256 _amountUT,\r\n        uint256 _escrowUnlockHeight)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            _uuid,\r\n            _account,\r\n            _accountNonce,\r\n            _beneficiary,\r\n            _amountST,\r\n            _amountUT,\r\n            _escrowUnlockHeight);\r\n    }\r\n\r\n    function hashRedemptionIntent(\r\n        bytes32 _uuid,\r\n        address _account,\r\n        uint256 _accountNonce,\r\n        address _beneficiary,\r\n        uint256 _amountUT,\r\n        uint256 _escrowUnlockHeight)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            _uuid,\r\n            _account,\r\n            _accountNonce,\r\n            _beneficiary,\r\n            _amountUT,\r\n            _escrowUnlockHeight);\r\n    }\r\n}\r\n\r\n/**\r\n   @title Owned\r\n   @notice Implements basic ownership with 2-step transfers\r\n*/\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address public proposedOwner;\r\n\r\n    event OwnershipTransferInitiated(address indexed _proposedOwner);\r\n    event OwnershipTransferCompleted(address indexed _newOwner);\r\n\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    function isOwner(address _address) internal view returns (bool) {\r\n        return (_address == owner);\r\n    }\r\n\r\n\r\n    function initiateOwnershipTransfer(address _proposedOwner) public onlyOwner returns (bool) {\r\n        proposedOwner = _proposedOwner;\r\n\r\n        OwnershipTransferInitiated(_proposedOwner);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    function completeOwnershipTransfer() public returns (bool) {\r\n        require(msg.sender == proposedOwner);\r\n\r\n        owner = proposedOwner;\r\n        proposedOwner = address(0);\r\n\r\n        OwnershipTransferCompleted(owner);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n   @title OpsManaged\r\n   @notice Implements OpenST ownership and permission model\r\n*/\r\ncontract OpsManaged is Owned {\r\n\r\n    address public opsAddress;\r\n    address public adminAddress;\r\n\r\n    event AdminAddressChanged(address indexed _newAddress);\r\n    event OpsAddressChanged(address indexed _newAddress);\r\n\r\n\r\n    function OpsManaged() public\r\n        Owned()\r\n    {\r\n    }\r\n\r\n\r\n    modifier onlyAdmin() {\r\n        require(isAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyAdminOrOps() {\r\n        require(isAdmin(msg.sender) || isOps(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyOwnerOrAdmin() {\r\n        require(isOwner(msg.sender) || isAdmin(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    modifier onlyOps() {\r\n        require(isOps(msg.sender));\r\n        _;\r\n    }\r\n\r\n\r\n    function isAdmin(address _address) internal view returns (bool) {\r\n        return (adminAddress != address(0) && _address == adminAddress);\r\n    }\r\n\r\n\r\n    function isOps(address _address) internal view returns (bool) {\r\n        return (opsAddress != address(0) && _address == opsAddress);\r\n    }\r\n\r\n\r\n    function isOwnerOrOps(address _address) internal view returns (bool) {\r\n        return (isOwner(_address) || isOps(_address));\r\n    }\r\n\r\n\r\n    // Owner and Admin can change the admin address. Address can also be set to 0 to 'disable' it.\r\n    function setAdminAddress(address _adminAddress) external onlyOwnerOrAdmin returns (bool) {\r\n        require(_adminAddress != owner);\r\n        require(_adminAddress != address(this));\r\n        require(!isOps(_adminAddress));\r\n\r\n        adminAddress = _adminAddress;\r\n\r\n        AdminAddressChanged(_adminAddress);\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    // Owner and Admin can change the operations address. Address can also be set to 0 to 'disable' it.\r\n    function setOpsAddress(address _opsAddress) external onlyOwnerOrAdmin returns (bool) {\r\n        require(_opsAddress != owner);\r\n        require(_opsAddress != address(this));\r\n        require(!isAdmin(_opsAddress));\r\n\r\n        opsAddress = _opsAddress;\r\n\r\n        OpsAddressChanged(_opsAddress);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n   @title EIP20Interface\r\n   @notice Provides EIP20 token interface\r\n*/\r\ncontract EIP20Interface {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function name() public view returns (string);\r\n    function symbol() public view returns (string);\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract CoreInterface {\r\n    \r\n    function registrar() public view returns (address /* registrar */);\r\n\r\n    function chainIdRemote() public view returns (uint256 /* chainIdRemote */);\r\n    function openSTRemote() public view returns (address /* OpenSTRemote */);\r\n}\r\n\r\ncontract ProtocolVersioned {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event ProtocolTransferInitiated(address indexed _existingProtocol, address indexed _proposedProtocol, uint256 _activationHeight);\r\n    event ProtocolTransferRevoked(address indexed _existingProtocol, address indexed _revokedProtocol);\r\n    event ProtocolTransferCompleted(address indexed _newProtocol);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    /// Blocks to wait before the protocol transfer can be completed\r\n    /// This allows anyone with a stake to unstake under the existing\r\n    /// protocol if they disagree with the new proposed protocol\r\n    /// @dev from OpenST ^v1.0 this constant will be set to a significant value\r\n    /// ~ 1 week at 15 seconds per block\r\n    uint256 constant private PROTOCOL_TRANSFER_BLOCKS_TO_WAIT = 40320;\r\n    \r\n    /*\r\n     *  Storage\r\n     */\r\n    /// OpenST protocol contract\r\n    address public openSTProtocol;\r\n    /// proposed OpenST protocol\r\n    address public proposedProtocol;\r\n    /// earliest protocol transfer height\r\n    uint256 public earliestTransferHeight;\r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n    modifier onlyProtocol() {\r\n        require(msg.sender == openSTProtocol);\r\n        _;\r\n    }\r\n\r\n    modifier onlyProposedProtocol() {\r\n        require(msg.sender == proposedProtocol);\r\n        _;\r\n    }\r\n\r\n    modifier afterWait() {\r\n        require(earliestTransferHeight <= block.number);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != 0);\r\n        _;\r\n    }\r\n    \r\n    // TODO: [ben] add hasCode modifier so that for \r\n    //       a significant wait time the code at the proposed new\r\n    //       protocol can be reviewed\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Constructor set the OpenST Protocol\r\n    function ProtocolVersioned(address _protocol) \r\n        public\r\n        notNull(_protocol)\r\n    {\r\n        openSTProtocol = _protocol;\r\n    }\r\n\r\n    /// @dev initiate protocol transfer\r\n    function initiateProtocolTransfer(\r\n        address _proposedProtocol)\r\n        public \r\n        onlyProtocol\r\n        notNull(_proposedProtocol)\r\n        returns (bool)\r\n    {\r\n        require(_proposedProtocol != openSTProtocol);\r\n        require(proposedProtocol == address(0));\r\n\r\n        earliestTransferHeight = block.number + blocksToWaitForProtocolTransfer();\r\n        proposedProtocol = _proposedProtocol;\r\n\r\n        ProtocolTransferInitiated(openSTProtocol, _proposedProtocol, earliestTransferHeight);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev only after the waiting period, can\r\n    ///      proposed protocol complete the transfer\r\n    function completeProtocolTransfer()\r\n        public\r\n        onlyProposedProtocol\r\n        afterWait\r\n        returns (bool) \r\n    {\r\n        openSTProtocol = proposedProtocol;\r\n        proposedProtocol = address(0);\r\n        earliestTransferHeight = 0;\r\n\r\n        ProtocolTransferCompleted(openSTProtocol);\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @dev protocol can revoke initiated protocol\r\n    ///      transfer\r\n    function revokeProtocolTransfer()\r\n        public\r\n        onlyProtocol\r\n        returns (bool)\r\n    {\r\n        require(proposedProtocol != address(0));\r\n\r\n        address revokedProtocol = proposedProtocol;\r\n        proposedProtocol = address(0);\r\n        earliestTransferHeight = 0;\r\n\r\n        ProtocolTransferRevoked(openSTProtocol, revokedProtocol);\r\n\r\n        return true;\r\n    }\r\n\r\n    function blocksToWaitForProtocolTransfer() public pure returns (uint256) {\r\n        return PROTOCOL_TRANSFER_BLOCKS_TO_WAIT;\r\n    }\r\n}\r\n\r\n/// @title SimpleStake - stakes the value of an EIP20 token on Ethereum\r\n///        for a utility token on the OpenST platform\r\n/// @author OpenST Ltd.\r\ncontract SimpleStake is ProtocolVersioned {\r\n    using SafeMath for uint256;\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event ReleasedStake(address indexed _protocol, address indexed _to, uint256 _amount);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    /// EIP20 token contract that can be staked\r\n    EIP20Interface public eip20Token;\r\n    /// UUID for the utility token\r\n    bytes32 public uuid;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Contract constructor sets the protocol and the EIP20 token to stake\r\n    /// @param _eip20Token EIP20 token that will be staked\r\n    /// @param _openSTProtocol OpenSTProtocol contract that governs staking\r\n    /// @param _uuid Unique Universal Identifier of the registered utility token\r\n    function SimpleStake(\r\n        EIP20Interface _eip20Token,\r\n        address _openSTProtocol,\r\n        bytes32 _uuid)\r\n        ProtocolVersioned(_openSTProtocol)\r\n        public\r\n    {\r\n        eip20Token = _eip20Token;\r\n        uuid = _uuid;\r\n    }\r\n\r\n    /// @dev Allows the protocol to release the staked amount\r\n    ///      into provided address.\r\n    ///      The protocol MUST be a contract that sets the rules\r\n    ///      on how the stake can be released and to who.\r\n    ///      The protocol takes the role of an \"owner\" of the stake.\r\n    /// @param _to Beneficiary of the amount of the stake\r\n    /// @param _amount Amount of stake to release to beneficiary\r\n    function releaseTo(address _to, uint256 _amount) \r\n        public \r\n        onlyProtocol\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(eip20Token.transfer(_to, _amount));\r\n        \r\n        ReleasedStake(msg.sender, _to, _amount);\r\n\r\n        return true;\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev total stake is the balance of the staking contract\r\n    ///      accidental transfers directly to SimpleStake bypassing\r\n    ///      the OpenST protocol will not mint new utility tokens,\r\n    ///      but will add to the total stake.\r\n    ///      (accidental) donations can not be prevented\r\n    function getTotalStake()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return eip20Token.balanceOf(this);\r\n    }\r\n}\r\n\r\n/// @title AM1OpenSTValue - value staking contract for OpenST\r\ncontract AM1OpenSTValue is OpsManaged, Hasher {\r\n    using SafeMath for uint256;\r\n    \r\n    /*\r\n     *  Events\r\n     */\r\n    event UtilityTokenRegistered(bytes32 indexed _uuid, address indexed stake,\r\n        string _symbol, string _name, uint8 _decimals, uint256 _conversionRate, uint8 _conversionRateDecimals,\r\n        uint256 _chainIdUtility, address indexed _stakingAccount);\r\n\r\n    event StakingIntentDeclared(bytes32 indexed _uuid, address indexed _staker,\r\n        uint256 _stakerNonce, address _beneficiary, uint256 _amountST,\r\n        uint256 _amountUT, uint256 _unlockHeight, bytes32 _stakingIntentHash,\r\n        uint256 _chainIdUtility);\r\n\r\n    event ProcessedStake(bytes32 indexed _uuid, bytes32 indexed _stakingIntentHash,\r\n        address _stake, address _staker, uint256 _amountST, uint256 _amountUT);\r\n\r\n    event RevertedStake(bytes32 indexed _uuid, bytes32 indexed _stakingIntentHash,\r\n        address _staker, uint256 _amountST, uint256 _amountUT);\r\n\r\n    event RedemptionIntentConfirmed(bytes32 indexed _uuid, bytes32 _redemptionIntentHash,\r\n        address _redeemer, address _beneficiary, uint256 _amountST, uint256 _amountUT, uint256 _expirationHeight);\r\n\r\n    event ProcessedUnstake(bytes32 indexed _uuid, bytes32 indexed _redemptionIntentHash,\r\n        address stake, address _redeemer, address _beneficiary, uint256 _amountST);\r\n\r\n    event RevertedUnstake(bytes32 indexed _uuid, bytes32 indexed _redemptionIntentHash,\r\n        address _redeemer, address _beneficiary, uint256 _amountST);\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint8 public constant TOKEN_DECIMALS = 18;\r\n    uint256 public constant DECIMALSFACTOR = 10**uint256(TOKEN_DECIMALS);\r\n    // ~3 weeks, assuming ~15s per block\r\n    uint256 private constant BLOCKS_TO_WAIT_LONG = 120960;\r\n    // ~3 days, assuming ~15s per block\r\n    uint256 private constant BLOCKS_TO_WAIT_SHORT = 17280;\r\n\r\n    /*\r\n     *  Structures\r\n     */\r\n    struct UtilityToken {\r\n        string  symbol;\r\n        string  name;\r\n        uint256 conversionRate;\r\n        uint8 conversionRateDecimals;\r\n        uint8   decimals;\r\n        uint256 chainIdUtility;\r\n        SimpleStake simpleStake;\r\n        address stakingAccount;\r\n    }\r\n\r\n    struct Stake {\r\n        bytes32 uuid;\r\n        address staker;\r\n        address beneficiary;\r\n        uint256 nonce;\r\n        uint256 amountST;\r\n        uint256 amountUT;\r\n        uint256 unlockHeight;\r\n    }\r\n\r\n    struct Unstake {\r\n        bytes32 uuid;\r\n        address redeemer;\r\n        address beneficiary;\r\n        uint256 amountST;\r\n        // @dev consider removal of amountUT\r\n        uint256 amountUT;\r\n        uint256 expirationHeight;\r\n    }\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    uint256 public chainIdValue;\r\n    EIP20Interface public valueToken;\r\n    address public registrar;\r\n    bytes32[] public uuids;\r\n    bool public deactivated;\r\n    mapping(uint256 /* chainIdUtility */ => CoreInterface) internal cores;\r\n    mapping(bytes32 /* uuid */ => UtilityToken) public utilityTokens;\r\n    /// nonce makes the staking process atomic across the two-phased process\r\n    /// and protects against replay attack on (un)staking proofs during the process.\r\n    /// On the value chain nonces need to strictly increase by one; on the utility\r\n    /// chain the nonce need to strictly increase (as one value chain can have multiple\r\n    /// utility chains)\r\n    mapping(address /* (un)staker */ => uint256) internal nonces;\r\n    /// register the active stakes and unstakes\r\n    mapping(bytes32 /* hashStakingIntent */ => Stake) public stakes;\r\n    mapping(bytes32 /* hashRedemptionIntent */ => Unstake) public unstakes;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier onlyRegistrar() {\r\n        // for now keep unique registrar\r\n        require(msg.sender == registrar);\r\n        _;\r\n    }\r\n\r\n    function AM1OpenSTValue(\r\n        uint256 _chainIdValue,\r\n        EIP20Interface _eip20token,\r\n        address _registrar)\r\n        public\r\n        OpsManaged()\r\n    {\r\n        require(_chainIdValue != 0);\r\n        require(_eip20token != address(0));\r\n        require(_registrar != address(0));\r\n\r\n        chainIdValue = _chainIdValue;\r\n        valueToken = _eip20token;\r\n        // registrar cannot be reset\r\n        // TODO: require it to be a contract\r\n        registrar = _registrar;\r\n        deactivated = false;\r\n    }\r\n\r\n    /*\r\n     *  External functions\r\n     */\r\n    /// @dev In order to stake the tx.origin needs to set an allowance\r\n    ///      for the OpenSTValue contract to transfer to itself to hold\r\n    ///      during the staking process.\r\n    function stake(\r\n        bytes32 _uuid,\r\n        uint256 _amountST,\r\n        address _beneficiary)\r\n        external\r\n        returns (\r\n        uint256 amountUT,\r\n        uint256 nonce,\r\n        uint256 unlockHeight,\r\n        bytes32 stakingIntentHash)\r\n        /* solhint-disable-next-line function-max-lines */\r\n    {\r\n        require(!deactivated);\r\n        /* solhint-disable avoid-tx-origin */\r\n        // check the staking contract has been approved to spend the amount to stake\r\n        // OpenSTValue needs to be able to transfer the stake into its balance for\r\n        // keeping until the two-phase process is completed on both chains.\r\n        require(_amountST > 0);\r\n        // Consider the security risk of using tx.origin; at the same time an allowance\r\n        // needs to be set before calling stake over a potentially malicious contract at stakingAccount.\r\n        // The second protection is that the staker needs to check the intent hash before\r\n        // signing off on completing the two-phased process.\r\n        require(valueToken.allowance(tx.origin, address(this)) >= _amountST);\r\n\r\n        require(utilityTokens[_uuid].simpleStake != address(0));\r\n        require(_beneficiary != address(0));\r\n\r\n        UtilityToken storage utilityToken = utilityTokens[_uuid];\r\n\r\n        // if the staking account is set to a non-zero address,\r\n        // then all transactions have come (from/over) the staking account,\r\n        // whether this is an EOA or a contract; tx.origin is putting forward the funds\r\n        if (utilityToken.stakingAccount != address(0)) require(msg.sender == utilityToken.stakingAccount);\r\n        require(valueToken.transferFrom(tx.origin, address(this), _amountST));\r\n\r\n        amountUT = (_amountST.mul(utilityToken.conversionRate))\r\n            .div(10**uint256(utilityToken.conversionRateDecimals));\r\n        unlockHeight = block.number + blocksToWaitLong();\r\n\r\n        nonces[tx.origin]++;\r\n        nonce = nonces[tx.origin];\r\n\r\n        stakingIntentHash = hashStakingIntent(\r\n            _uuid,\r\n            tx.origin,\r\n            nonce,\r\n            _beneficiary,\r\n            _amountST,\r\n            amountUT,\r\n            unlockHeight\r\n        );\r\n\r\n        stakes[stakingIntentHash] = Stake({\r\n            uuid:         _uuid,\r\n            staker:       tx.origin,\r\n            beneficiary:  _beneficiary,\r\n            nonce:        nonce,\r\n            amountST:     _amountST,\r\n            amountUT:     amountUT,\r\n            unlockHeight: unlockHeight\r\n        });\r\n\r\n        StakingIntentDeclared(_uuid, tx.origin, nonce, _beneficiary,\r\n            _amountST, amountUT, unlockHeight, stakingIntentHash, utilityToken.chainIdUtility);\r\n\r\n        return (amountUT, nonce, unlockHeight, stakingIntentHash);\r\n        /* solhint-enable avoid-tx-origin */\r\n    }\r\n\r\n    function processStaking(\r\n        bytes32 _stakingIntentHash)\r\n        external\r\n        returns (address stakeAddress)\r\n    {\r\n        require(_stakingIntentHash != \"\");\r\n\r\n        Stake storage stake = stakes[_stakingIntentHash];\r\n\r\n        // note: as processStaking incurs a cost for the staker, we provide a fallback\r\n        // in v0.9 for registrar to process the staking on behalf of the staker,\r\n        // as the staker could fail to process the stake and avoid the cost of staking;\r\n        // this will be replaced with a signature carry-over implementation instead, where\r\n        // the signature of the intent hash suffices on value and utility chain, decoupling\r\n        // it from the transaction to processStaking and processMinting\r\n        require(stake.staker == msg.sender || registrar == msg.sender);\r\n        // as this bears the cost, there is no need to require\r\n        // that the stake.unlockHeight is not yet surpassed\r\n        // as is required on processMinting\r\n\r\n        UtilityToken storage utilityToken = utilityTokens[stake.uuid];\r\n        stakeAddress = address(utilityToken.simpleStake);\r\n        require(stakeAddress != address(0));\r\n\r\n        assert(valueToken.balanceOf(address(this)) >= stake.amountST);\r\n        require(valueToken.transfer(stakeAddress, stake.amountST));\r\n\r\n        ProcessedStake(stake.uuid, _stakingIntentHash, stakeAddress, stake.staker,\r\n            stake.amountST, stake.amountUT);\r\n\r\n        delete stakes[_stakingIntentHash];\r\n\r\n        return stakeAddress;\r\n    }\r\n\r\n    function revertStaking(\r\n        bytes32 _stakingIntentHash)\r\n        external\r\n        returns (\r\n        bytes32 uuid,\r\n        uint256 amountST,\r\n        address staker)\r\n    {\r\n        require(_stakingIntentHash != \"\");\r\n\r\n        Stake storage stake = stakes[_stakingIntentHash];\r\n\r\n        // require that the stake is unlocked and exists\r\n        require(stake.unlockHeight > 0);\r\n        require(stake.unlockHeight <= block.number);\r\n\r\n        assert(valueToken.balanceOf(address(this)) >= stake.amountST);\r\n        // revert the amount that was intended to be staked back to staker\r\n        require(valueToken.transfer(stake.staker, stake.amountST));\r\n\r\n        uuid = stake.uuid;\r\n        amountST = stake.amountST;\r\n        staker = stake.staker;\r\n\r\n        RevertedStake(stake.uuid, _stakingIntentHash, stake.staker,\r\n            stake.amountST, stake.amountUT);\r\n\r\n        delete stakes[_stakingIntentHash];\r\n\r\n        return (uuid, amountST, staker);\r\n    }\r\n\r\n    function confirmRedemptionIntent(\r\n        bytes32 _uuid,\r\n        address _redeemer,\r\n        uint256 _redeemerNonce,\r\n        address _beneficiary,\r\n        uint256 _amountUT,\r\n        uint256 _redemptionUnlockHeight,\r\n        bytes32 _redemptionIntentHash)\r\n        external\r\n        onlyRegistrar\r\n        returns (\r\n        uint256 amountST,\r\n        uint256 expirationHeight)\r\n    {\r\n        require(utilityTokens[_uuid].simpleStake != address(0));\r\n        require(_amountUT > 0);\r\n        require(_beneficiary != address(0));\r\n        // later core will provide a view on the block height of the\r\n        // utility chain\r\n        require(_redemptionUnlockHeight > 0);\r\n        require(_redemptionIntentHash != \"\");\r\n\r\n        require(nonces[_redeemer] + 1 == _redeemerNonce);\r\n        nonces[_redeemer]++;\r\n\r\n        bytes32 redemptionIntentHash = hashRedemptionIntent(\r\n            _uuid,\r\n            _redeemer,\r\n            nonces[_redeemer],\r\n            _beneficiary,\r\n            _amountUT,\r\n            _redemptionUnlockHeight\r\n        );\r\n\r\n        require(_redemptionIntentHash == redemptionIntentHash);\r\n\r\n        expirationHeight = block.number + blocksToWaitShort();\r\n\r\n        UtilityToken storage utilityToken = utilityTokens[_uuid];\r\n        // minimal precision to unstake 1 STWei\r\n        require(_amountUT >= (utilityToken.conversionRate.div(10**uint256(utilityToken.conversionRateDecimals))));\r\n        amountST = (_amountUT\r\n            .mul(10**uint256(utilityToken.conversionRateDecimals))).div(utilityToken.conversionRate);\r\n\r\n        require(valueToken.balanceOf(address(utilityToken.simpleStake)) >= amountST);\r\n\r\n        unstakes[redemptionIntentHash] = Unstake({\r\n            uuid:         _uuid,\r\n            redeemer:     _redeemer,\r\n            beneficiary:  _beneficiary,\r\n            amountUT:     _amountUT,\r\n            amountST:     amountST,\r\n            expirationHeight: expirationHeight\r\n        });\r\n\r\n        RedemptionIntentConfirmed(_uuid, redemptionIntentHash, _redeemer,\r\n            _beneficiary, amountST, _amountUT, expirationHeight);\r\n\r\n        return (amountST, expirationHeight);\r\n    }\r\n\r\n    function processUnstaking(\r\n        bytes32 _redemptionIntentHash)\r\n        external\r\n        returns (\r\n        address stakeAddress)\r\n    {\r\n        require(_redemptionIntentHash != \"\");\r\n\r\n        Unstake storage unstake = unstakes[_redemptionIntentHash];\r\n        require(unstake.redeemer == msg.sender);\r\n\r\n        // as the process unstake results in a gain for the caller\r\n        // it needs to expire well before the process redemption can\r\n        // be reverted in OpenSTUtility\r\n        require(unstake.expirationHeight > block.number);\r\n\r\n        UtilityToken storage utilityToken = utilityTokens[unstake.uuid];\r\n        stakeAddress = address(utilityToken.simpleStake);\r\n        require(stakeAddress != address(0));\r\n\r\n        require(utilityToken.simpleStake.releaseTo(unstake.beneficiary, unstake.amountST));\r\n\r\n        ProcessedUnstake(unstake.uuid, _redemptionIntentHash, stakeAddress,\r\n            unstake.redeemer, unstake.beneficiary, unstake.amountST);\r\n\r\n        delete unstakes[_redemptionIntentHash];\r\n\r\n        return stakeAddress;\r\n    }\r\n\r\n    function revertUnstaking(\r\n        bytes32 _redemptionIntentHash)\r\n        external\r\n        returns (\r\n        bytes32 uuid,\r\n        address redeemer,\r\n        address beneficiary,\r\n        uint256 amountST)\r\n    {\r\n        require(_redemptionIntentHash != \"\");\r\n\r\n        Unstake storage unstake = unstakes[_redemptionIntentHash];\r\n\r\n        // require that the unstake has expired and that the redeemer has not\r\n        // processed the unstaking, ie unstake has not been deleted\r\n        require(unstake.expirationHeight > 0);\r\n        require(unstake.expirationHeight <= block.number);\r\n\r\n        uuid = unstake.uuid;\r\n        redeemer = unstake.redeemer;\r\n        beneficiary = unstake.beneficiary;\r\n        amountST = unstake.amountST;\r\n\r\n        delete unstakes[_redemptionIntentHash];\r\n\r\n        RevertedUnstake(uuid, _redemptionIntentHash, redeemer, beneficiary, amountST);\r\n\r\n        return (uuid, redeemer, beneficiary, amountST);\r\n    }\r\n\r\n    function core(\r\n        uint256 _chainIdUtility)\r\n        external\r\n        view\r\n        returns (address /* core address */ )\r\n    {\r\n        return address(cores[_chainIdUtility]);\r\n    }\r\n\r\n    /*\r\n     *  Public view functions\r\n     */\r\n    function getNextNonce(\r\n        address _account)\r\n        public\r\n        view\r\n        returns (uint256 /* nextNonce */)\r\n    {\r\n        return (nonces[_account] + 1);\r\n    }\r\n\r\n    function blocksToWaitLong() public pure returns (uint256) {\r\n        return BLOCKS_TO_WAIT_LONG;\r\n    }\r\n\r\n    function blocksToWaitShort() public pure returns (uint256) {\r\n        return BLOCKS_TO_WAIT_SHORT;\r\n    }\r\n\r\n    /// @dev Returns size of uuids\r\n    /// @return size\r\n    function getUuidsSize() public view returns (uint256) {\r\n        return uuids.length;\r\n    }\r\n\r\n    /*\r\n     *  Registrar functions\r\n     */\r\n    function addCore(\r\n        CoreInterface _core)\r\n        public\r\n        onlyRegistrar\r\n        returns (bool /* success */)\r\n    {\r\n        require(address(_core) != address(0));\r\n        // core constructed with same registrar\r\n        require(registrar == _core.registrar());\r\n        // on value chain core only tracks a remote utility chain\r\n        uint256 chainIdUtility = _core.chainIdRemote();\r\n        require(chainIdUtility != 0);\r\n        // cannot overwrite core for given chainId\r\n        require(cores[chainIdUtility] == address(0));\r\n\r\n        cores[chainIdUtility] = _core;\r\n\r\n        return true;\r\n    }\r\n\r\n    function registerUtilityToken(\r\n        string _symbol,\r\n        string _name,\r\n        uint256 _conversionRate,\r\n        uint8 _conversionRateDecimals,\r\n        uint256 _chainIdUtility,\r\n        address _stakingAccount,\r\n        bytes32 _checkUuid)\r\n        public\r\n        onlyRegistrar\r\n        returns (bytes32 uuid)\r\n    {\r\n        require(bytes(_name).length > 0);\r\n        require(bytes(_symbol).length > 0);\r\n        require(_conversionRate > 0);\r\n        require(_conversionRateDecimals <= 5);\r\n\r\n        address openSTRemote = cores[_chainIdUtility].openSTRemote();\r\n        require(openSTRemote != address(0));\r\n\r\n        uuid = hashUuid(\r\n            _symbol,\r\n            _name,\r\n            chainIdValue,\r\n            _chainIdUtility,\r\n            openSTRemote,\r\n            _conversionRate,\r\n            _conversionRateDecimals);\r\n\r\n        require(uuid == _checkUuid);\r\n\r\n        require(address(utilityTokens[uuid].simpleStake) == address(0));\r\n\r\n        SimpleStake simpleStake = new SimpleStake(\r\n            valueToken, address(this), uuid);\r\n\r\n        utilityTokens[uuid] = UtilityToken({\r\n            symbol:         _symbol,\r\n            name:           _name,\r\n            conversionRate: _conversionRate,\r\n            conversionRateDecimals: _conversionRateDecimals,\r\n            decimals:       TOKEN_DECIMALS,\r\n            chainIdUtility: _chainIdUtility,\r\n            simpleStake:    simpleStake,\r\n            stakingAccount: _stakingAccount\r\n        });\r\n        uuids.push(uuid);\r\n\r\n        UtilityTokenRegistered(uuid, address(simpleStake), _symbol, _name,\r\n            TOKEN_DECIMALS, _conversionRate, _conversionRateDecimals, _chainIdUtility, _stakingAccount);\r\n\r\n        return uuid;\r\n    }\r\n\r\n    /*\r\n     *  Administrative functions\r\n     */\r\n    function initiateProtocolTransfer(\r\n        ProtocolVersioned _simpleStake,\r\n        address _proposedProtocol)\r\n        public\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        _simpleStake.initiateProtocolTransfer(_proposedProtocol);\r\n\r\n        return true;\r\n    }\r\n\r\n    // on the very first released version v0.9.1 there is no need\r\n    // to completeProtocolTransfer from a previous version\r\n\r\n    /* solhint-disable-next-line separate-by-one-line-in-contract */\r\n    function revokeProtocolTransfer(\r\n        ProtocolVersioned _simpleStake)\r\n        public\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        _simpleStake.revokeProtocolTransfer();\r\n\r\n        return true;\r\n    }\r\n\r\n    function deactivate()\r\n        public\r\n        onlyAdmin\r\n        returns (\r\n        bool result)\r\n    {\r\n        deactivated = true;\r\n        return deactivated;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_accountNonce\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_amountUT\",\"type\":\"uint256\"},{\"name\":\"_escrowUnlockHeight\",\"type\":\"uint256\"}],\"name\":\"hashRedemptionIntent\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chainIdValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"uuids\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_simpleStake\",\"type\":\"address\"},{\"name\":\"_proposedProtocol\",\"type\":\"address\"}],\"name\":\"initiateProtocolTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adminAddress\",\"type\":\"address\"}],\"name\":\"setAdminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksToWaitShort\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deactivate\",\"outputs\":[{\"name\":\"result\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deactivated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_redemptionIntentHash\",\"type\":\"bytes32\"}],\"name\":\"revertUnstaking\",\"outputs\":[{\"name\":\"uuid\",\"type\":\"bytes32\"},{\"name\":\"redeemer\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amountST\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOKEN_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUuidsSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"name\":\"_redeemer\",\"type\":\"address\"},{\"name\":\"_redeemerNonce\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_amountUT\",\"type\":\"uint256\"},{\"name\":\"_redemptionUnlockHeight\",\"type\":\"uint256\"},{\"name\":\"_redemptionIntentHash\",\"type\":\"bytes32\"}],\"name\":\"confirmRedemptionIntent\",\"outputs\":[{\"name\":\"amountST\",\"type\":\"uint256\"},{\"name\":\"expirationHeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_simpleStake\",\"type\":\"address\"}],\"name\":\"revokeProtocolTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_opsAddress\",\"type\":\"address\"}],\"name\":\"setOpsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_accountNonce\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_amountST\",\"type\":\"uint256\"},{\"name\":\"_amountUT\",\"type\":\"uint256\"},{\"name\":\"_escrowUnlockHeight\",\"type\":\"uint256\"}],\"name\":\"hashStakingIntent\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksToWaitLong\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALSFACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"opsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_conversionRate\",\"type\":\"uint256\"},{\"name\":\"_conversionRateDecimals\",\"type\":\"uint8\"},{\"name\":\"_chainIdUtility\",\"type\":\"uint256\"},{\"name\":\"_stakingAccount\",\"type\":\"address\"},{\"name\":\"_checkUuid\",\"type\":\"bytes32\"}],\"name\":\"registerUtilityToken\",\"outputs\":[{\"name\":\"uuid\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"stakes\",\"outputs\":[{\"name\":\"uuid\",\"type\":\"bytes32\"},{\"name\":\"staker\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"amountST\",\"type\":\"uint256\"},{\"name\":\"amountUT\",\"type\":\"uint256\"},{\"name\":\"unlockHeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getNextNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_core\",\"type\":\"address\"}],\"name\":\"addCore\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"unstakes\",\"outputs\":[{\"name\":\"uuid\",\"type\":\"bytes32\"},{\"name\":\"redeemer\",\"type\":\"address\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"amountST\",\"type\":\"uint256\"},{\"name\":\"amountUT\",\"type\":\"uint256\"},{\"name\":\"expirationHeight\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_chainIdUtility\",\"type\":\"uint256\"}],\"name\":\"core\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"name\":\"_amountST\",\"type\":\"uint256\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"stake\",\"outputs\":[{\"name\":\"amountUT\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"unlockHeight\",\"type\":\"uint256\"},{\"name\":\"stakingIntentHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_redemptionIntentHash\",\"type\":\"bytes32\"}],\"name\":\"processUnstaking\",\"outputs\":[{\"name\":\"stakeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"initiateOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_chainIdValue\",\"type\":\"uint256\"},{\"name\":\"_chainIdUtility\",\"type\":\"uint256\"},{\"name\":\"_openSTUtility\",\"type\":\"address\"},{\"name\":\"_conversionRate\",\"type\":\"uint256\"},{\"name\":\"_conversionRateDecimals\",\"type\":\"uint8\"}],\"name\":\"hashUuid\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposedOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"completeOwnershipTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"valueToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakingIntentHash\",\"type\":\"bytes32\"}],\"name\":\"revertStaking\",\"outputs\":[{\"name\":\"uuid\",\"type\":\"bytes32\"},{\"name\":\"amountST\",\"type\":\"uint256\"},{\"name\":\"staker\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakingIntentHash\",\"type\":\"bytes32\"}],\"name\":\"processStaking\",\"outputs\":[{\"name\":\"stakeAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"utilityTokens\",\"outputs\":[{\"name\":\"symbol\",\"type\":\"string\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"conversionRate\",\"type\":\"uint256\"},{\"name\":\"conversionRateDecimals\",\"type\":\"uint8\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"chainIdUtility\",\"type\":\"uint256\"},{\"name\":\"simpleStake\",\"type\":\"address\"},{\"name\":\"stakingAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_chainIdValue\",\"type\":\"uint256\"},{\"name\":\"_eip20token\",\"type\":\"address\"},{\"name\":\"_registrar\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"stake\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_symbol\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_decimals\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_conversionRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_conversionRateDecimals\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"_chainIdUtility\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_stakingAccount\",\"type\":\"address\"}],\"name\":\"UtilityTokenRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_stakerNonce\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountST\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountUT\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_unlockHeight\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stakingIntentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_chainIdUtility\",\"type\":\"uint256\"}],\"name\":\"StakingIntentDeclared\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_stakingIntentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_stake\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountST\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountUT\",\"type\":\"uint256\"}],\"name\":\"ProcessedStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_stakingIntentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountST\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountUT\",\"type\":\"uint256\"}],\"name\":\"RevertedStake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_redemptionIntentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_redeemer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountST\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amountUT\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_expirationHeight\",\"type\":\"uint256\"}],\"name\":\"RedemptionIntentConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_redemptionIntentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"stake\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_redeemer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountST\",\"type\":\"uint256\"}],\"name\":\"ProcessedUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_uuid\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"_redemptionIntentHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_redeemer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amountST\",\"type\":\"uint256\"}],\"name\":\"RevertedUnstake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"AdminAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newAddress\",\"type\":\"address\"}],\"name\":\"OpsAddressChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_proposedOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferInitiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferCompleted\",\"type\":\"event\"}]","ContractName":"AM1OpenSTValue","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000010000000000000000000000002c4e8f2d746113d0696ce89b35f0d8bf88e0aeca000000000000000000000000d184c79481774a4c2ea2dad4d14f9c6396e17c65","Library":"","SwarmSource":"bzzr://57c2b322f85a7a97c5c8159f257def6ef24dcdd73fbc42c381a425777da012d8"}]}