{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.19;\r\n\r\n// File: contracts\\MultiOwnable.sol\r\n\r\n/**\r\n * FEATURE 2): MultiOwnable implementation\r\n * Transactions approved by _multiRequires of _multiOwners' addresses will be executed. \r\n\r\n * All functions needing unit-tests cannot be INTERNAL\r\n */\r\ncontract MultiOwnable {\r\n\r\n    address[8] m_owners;\r\n    uint m_numOwners;\r\n    uint m_multiRequires;\r\n\r\n    mapping (bytes32 => uint) internal m_pendings;\r\n\r\n    event AcceptConfirm(bytes32 operation, address indexed who, uint confirmTotal);\r\n    \r\n    // constructor is given number of sigs required to do protected \"multiOwner\" transactions\r\n    function MultiOwnable (address[] _multiOwners, uint _multiRequires) public {\r\n        require(0 < _multiRequires && _multiRequires <= _multiOwners.length);\r\n        m_numOwners = _multiOwners.length;\r\n        require(m_numOwners <= 8);   // Bigger then 8 co-owners, not support !\r\n        for (uint i = 0; i < _multiOwners.length; ++i) {\r\n            m_owners[i] = _multiOwners[i];\r\n            require(m_owners[i] != address(0));\r\n        }\r\n        m_multiRequires = _multiRequires;\r\n    }\r\n\r\n    // Any one of the owners, will approve the action\r\n    modifier anyOwner {\r\n        if (isOwner(msg.sender)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    // Requiring num > m_multiRequires owners, to approve the action\r\n    modifier mostOwner(bytes32 operation) {\r\n        if (checkAndConfirm(msg.sender, operation)) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function isOwner(address currentUser) public view returns (bool) {\r\n        for (uint i = 0; i < m_numOwners; ++i) {\r\n            if (m_owners[i] == currentUser) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function checkAndConfirm(address currentUser, bytes32 operation) public returns (bool) {\r\n        uint ownerIndex = m_numOwners;\r\n        uint i;\r\n        for (i = 0; i < m_numOwners; ++i) {\r\n            if (m_owners[i] == currentUser) {\r\n                ownerIndex = i;\r\n            }\r\n        }\r\n        if (ownerIndex == m_numOwners) {\r\n            return false;  // Not Owner\r\n        }\r\n        \r\n        uint newBitFinger = (m_pendings[operation] | (2 ** ownerIndex));\r\n\r\n        uint confirmTotal = 0;\r\n        for (i = 0; i < m_numOwners; ++i) {\r\n            if ((newBitFinger & (2 ** i)) > 0) {\r\n                confirmTotal ++;\r\n            }\r\n        }\r\n        \r\n        AcceptConfirm(operation, currentUser, confirmTotal);\r\n\r\n        if (confirmTotal >= m_multiRequires) {\r\n            delete m_pendings[operation];\r\n            return true;\r\n        }\r\n        else {\r\n            m_pendings[operation] = newBitFinger;\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\Pausable.sol\r\n\r\n/**\r\n * FEATURE 3): Pausable implementation\r\n */\r\ncontract Pausable is MultiOwnable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool paused = false;\r\n\r\n    // Modifier to make a function callable only when the contract is not paused.\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    // Modifier to make a function callable only when the contract is paused.\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    // called by the owner to pause, triggers stopped state\r\n    function pause() mostOwner(keccak256(msg.data)) whenNotPaused public {\r\n        paused = true;\r\n        Pause();\r\n    }\r\n\r\n    // called by the owner to unpause, returns to normal state\r\n    function unpause() mostOwner(keccak256(msg.data)) whenPaused public {\r\n        paused = false;\r\n        Unpause();\r\n    }\r\n\r\n    function isPause() view public returns(bool) {\r\n        return paused;\r\n    }\r\n}\r\n\r\n// File: contracts\\SafeMath.sol\r\n\r\n/**\r\n* Standard SafeMath Library: zeppelin-solidity/contracts/math/SafeMath.sol\r\n*/\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts\\AdvisorGPX.sol\r\n\r\n/**\r\n * The updated body of smart contract.\r\n * %6 fund will be transferred to ParcelX advisors automatically. \r\n */\r\ncontract AdvisorGPX is MultiOwnable, Pausable {\r\n\r\n    using SafeMath for uint256;\r\n    \r\n    address internal advisor = 0xd173bdd2f4ccd88b35b83a8bc35dd05a3b5a3c79;\r\n    uint internal payAdvisorFlag = 0;\r\n\r\n    function AdvisorGPX(address[] _multiOwners, uint _multiRequires) \r\n        MultiOwnable(_multiOwners, _multiRequires) public {\r\n    }\r\n    \r\n    event Deposit(address indexed who, uint256 value);\r\n    event Withdraw(address indexed who, uint256 value, address indexed lastApprover, string extra);\r\n    event AdviseFee(address advisor, uint256 advfee);\r\n\r\n    function getTime() public view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    function getBalance() public view returns (uint256) {\r\n        return this.balance;\r\n    }\r\n    \r\n    /**\r\n     * FEATURE : Buyable\r\n     * minimum of 0.001 ether for purchase in the public, pre-ico, and private sale\r\n     * Code caculates the endtime via python: \r\n     *   d1 = datetime.datetime.strptime(\"2018-10-31 23:59:59\", '%Y-%m-%d %H:%M:%S')\r\n     *   t = time.mktime(d1.timetuple())\r\n     *   d2 = datetime.datetime.fromtimestamp(t)\r\n     *   assert (d1 == d2)  # print d2.strftime('%Y-%m-%d %H:%M:%S')\r\n     *   print t # = 1541001599\r\n     */\r\n    function buy() payable whenNotPaused public returns (bool) {\r\n        Deposit(msg.sender, msg.value);\r\n        require(msg.value >= 0.001 ether);\r\n        \r\n        // Fee to advisors\r\n        if (now > 1541001599 && payAdvisorFlag == 0) {\r\n            payAdvisorFlag = payAdvisorFlag + 1;\r\n            uint256 advfee = this.balance.div(20) + this.balance.div(100);  // = 6.0 %, Not float in Solidity, So use INT/div to approach. \r\n            if (advfee > 0) {\r\n                advisor.transfer(advfee);   // Prevent using call() or send()\r\n            }\r\n            AdviseFee(advisor, advfee);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    // gets called when no other function matches\r\n    function () payable public {\r\n        if (msg.value > 0) {\r\n            buy();\r\n        }\r\n    }\r\n\r\n    function execute(address _to, uint256 _value, string _extra) mostOwner(keccak256(msg.data)) external returns (bool){\r\n        require(_to != address(0));\r\n        _to.transfer(_value);   // Prevent using call() or send()\r\n        Withdraw(_to, _value, msg.sender, _extra);\r\n        return true;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"currentUser\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"currentUser\",\"type\":\"address\"},{\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"checkAndConfirm\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_extra\",\"type\":\"string\"}],\"name\":\"execute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_multiOwners\",\"type\":\"address[]\"},{\"name\":\"_multiRequires\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"lastApprover\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"extra\",\"type\":\"string\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"advisor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"advfee\",\"type\":\"uint256\"}],\"name\":\"AdviseFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"confirmTotal\",\"type\":\"uint256\"}],\"name\":\"AcceptConfirm\",\"type\":\"event\"}]","ContractName":"AdvisorGPX","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000530c5de3558ba36b383f73dff4ad8078f2584fe5000000000000000000000000e7b63545572ad7c8fa80fc35a4f97c4e54e72ff3000000000000000000000000141c9ff89e2193f620e5ee0fd950b464ad6872b2","Library":"","SwarmSource":"bzzr://b0478bf79c015f9c71b2c01c35e4adc2b2fadc8d6ef480f572795e1be9889914"}]}