{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract SuperBank {\r\n    using SafeMath for *;\r\n\r\n    struct Investment {\r\n        uint256 amount;\r\n        uint256 safeAmount;\r\n        uint256 atBlock;\r\n        uint256 withdraw;\r\n        uint256 canWithdraw;\r\n        uint256 maxWithdraw;\r\n    }\r\n\r\n    uint256 public startBlockNo;\r\n    uint256 public startTotal;\r\n\r\n    uint256 public total;\r\n    uint256 public people;\r\n    uint256 public floatFund;\r\n    uint256 public safeFund;\r\n\r\n    uint256 public bonus;\r\n    uint256 public bonusEndTime;\r\n    address public leader;\r\n    uint256 public lastPrice;\r\n\r\n    mapping (address => Investment) public invested_m;\r\n\r\n    address public owner; \r\n\r\n    constructor()\r\n        public\r\n    {\r\n        owner = msg.sender;\r\n        startBlockNo = block.number + (5900 * 14);\r\n        // 1000 ether\r\n        startTotal = 1000000000000000000000;\r\n    }\r\n\r\n    modifier onlyOwner() \r\n    {\r\n        require(owner == msg.sender, \"only owner can do it\");\r\n        _;    \r\n    }\r\n\r\n    /**\r\n     * @dev invest\r\n     * \r\n     * radical investment\r\n     */\r\n    function()\r\n        public\r\n        payable\r\n    {\r\n        if (msg.value == 0)\r\n        {\r\n            withdraw();\r\n        } else {\r\n            invest(2, address(0));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev invest\r\n     */\r\n    function invest(uint8 _type, address _ref)\r\n        public\r\n        payable\r\n    {\r\n        uint256 _eth = msg.value;\r\n        uint256 _now = now;\r\n        uint256 _safe_p;\r\n        uint256 _other_p;\r\n        uint256 _return_p;\r\n        uint256 _safeAmount;\r\n        uint256 _otherAmount;\r\n        uint256 _returnAmount;\r\n        uint256 _teamAmount;\r\n        uint256 _promoteAmount;\r\n\r\n        require(msg.value >= 1000000000, \"not enough ether\");\r\n\r\n        withdraw();\r\n\r\n        if (invested_m[msg.sender].amount == 0)\r\n        {\r\n            people = people.add(1);\r\n        }\r\n\r\n        if (_type == 1)\r\n        {\r\n            _safe_p = 80;\r\n            _other_p = 5;\r\n            _return_p = 130;\r\n        } else {\r\n            _safe_p = 40;\r\n            _other_p = 25;\r\n            _return_p = 170;\r\n        }\r\n\r\n        _safeAmount = (_eth.mul(_safe_p) / 100);\r\n        _returnAmount = (_eth.mul(_return_p) / 100);\r\n\r\n        invested_m[msg.sender].amount = _eth.add(invested_m[msg.sender].amount);\r\n        invested_m[msg.sender].safeAmount = _safeAmount.add(invested_m[msg.sender].safeAmount);\r\n        invested_m[msg.sender].maxWithdraw = _returnAmount.add(invested_m[msg.sender].maxWithdraw);\r\n\r\n        total = total.add(_eth);\r\n        safeFund = safeFund.add(_safeAmount);\r\n        \r\n        //start ?\r\n        if (block.number < startBlockNo && startTotal <= total) \r\n        {\r\n            startBlockNo = block.number;\r\n        }\r\n\r\n        if (_ref != address(0) && _ref != msg.sender)\r\n        {\r\n            uint256 _refTotal = invested_m[_ref].amount;\r\n            if (_refTotal < 5000000000000000000)\r\n            {\r\n                _promoteAmount = (_eth.mul(3) / 100);\r\n                _teamAmount = (_eth.mul(7) / 100);\r\n            } else if (_refTotal < 20000000000000000000) {\r\n                _promoteAmount = (_eth.mul(5) / 100);\r\n                _teamAmount = (_eth.mul(5) / 100);\r\n            } else {\r\n                _promoteAmount = (_eth.mul(7) / 100);\r\n                _teamAmount = (_eth.mul(3) / 100);\r\n            }\r\n\r\n            _ref.transfer(_promoteAmount);\r\n        } else {\r\n            _teamAmount = (_eth.mul(10) / 100);\r\n        }\r\n\r\n        owner.transfer(_teamAmount);\r\n\r\n        _otherAmount = (_eth.mul(_other_p) / 100);\r\n\r\n        floatFund = floatFund.add(_otherAmount);\r\n\r\n        // bonus\r\n        if (bonusEndTime != 0 && bonusEndTime < _now)\r\n        {   \r\n            uint256 bonus_t = bonus;\r\n            address leader_t = leader;\r\n            bonus = 0;\r\n            leader = address(0);\r\n            lastPrice = 0;\r\n            bonusEndTime = 0;\r\n            leader_t.transfer(bonus_t);\r\n        }\r\n        bonus = bonus.add(_otherAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev withdraws\r\n     */\r\n    function withdraw()\r\n        public\r\n    {\r\n        uint256 _blockNo = block.number;\r\n        uint256 _leaveWithdraw = invested_m[msg.sender].maxWithdraw.sub(invested_m[msg.sender].canWithdraw);\r\n        uint256 _blockSub;\r\n\r\n        if (_blockNo < startBlockNo)\r\n        {\r\n            _blockSub = 0;\r\n        } else {\r\n            if (invested_m[msg.sender].atBlock < startBlockNo)\r\n            {\r\n                _blockSub = _blockNo.sub(startBlockNo);\r\n            } else {\r\n                _blockSub = _blockNo.sub(invested_m[msg.sender].atBlock);\r\n            }\r\n        }\r\n\r\n        uint256 _canAmount = ((invested_m[msg.sender].amount.mul(5) / 100).mul(_blockSub) / 5900);\r\n\r\n        if (_canAmount > _leaveWithdraw)\r\n        {\r\n            _canAmount = _leaveWithdraw;\r\n        }\r\n        invested_m[msg.sender].canWithdraw = _canAmount.add(invested_m[msg.sender].canWithdraw);\r\n\r\n        uint256 _realAmount = invested_m[msg.sender].canWithdraw.sub(invested_m[msg.sender].withdraw);\r\n        \r\n        if (_realAmount > 0)\r\n        {\r\n            if (invested_m[msg.sender].safeAmount >= _realAmount)\r\n            {\r\n                safeFund = safeFund.sub(_realAmount);\r\n                invested_m[msg.sender].safeAmount = invested_m[msg.sender].safeAmount.sub(_realAmount);\r\n            } else {\r\n                uint256 _extraAmount = _realAmount.sub(invested_m[msg.sender].safeAmount);\r\n                if (floatFund >= _extraAmount)\r\n                {\r\n                    floatFund = floatFund.sub(_extraAmount);\r\n                } else {\r\n                    _realAmount = floatFund.add(invested_m[msg.sender].safeAmount);\r\n                    floatFund = 0;\r\n                }\r\n                safeFund = safeFund.sub(invested_m[msg.sender].safeAmount);\r\n                invested_m[msg.sender].safeAmount = 0;\r\n            }\r\n        }\r\n\r\n        invested_m[msg.sender].withdraw = _realAmount.add(invested_m[msg.sender].withdraw);\r\n        invested_m[msg.sender].atBlock = _blockNo;\r\n\r\n        if (_realAmount > 0)\r\n        {\r\n            msg.sender.transfer(_realAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev bid\r\n     */\r\n    function bid(address _ref)\r\n        public\r\n        payable\r\n    {\r\n        uint256 _eth = msg.value;\r\n        uint256 _ethUse = msg.value;\r\n        uint256 _now = now;\r\n        uint256 _promoteAmount;\r\n        uint256 _teamAmount;\r\n        uint256 _otherAmount;\r\n\r\n        require(block.number >= startBlockNo, \"Need start\");\r\n\r\n        // bonus\r\n        if (bonusEndTime != 0 && bonusEndTime < _now)\r\n        {   \r\n            uint256 bonus_t = bonus;\r\n            address leader_t = leader;\r\n            bonus = 0;\r\n            leader = address(0);\r\n            lastPrice = 0;\r\n            bonusEndTime = 0;\r\n            leader_t.transfer(bonus_t);\r\n        }\r\n\r\n        uint256 _maxPrice = (1000000000000000000).add(lastPrice);\r\n        // less than (lastPrice + 0.1Ether) ?\r\n        require(_eth >= (100000000000000000).add(lastPrice), \"Need more Ether\");\r\n        // more than (lastPrice + 1Ether) ?\r\n        if (_eth > _maxPrice)\r\n        {\r\n            _ethUse = _maxPrice;\r\n            // refund\r\n            msg.sender.transfer(_eth.sub(_ethUse));\r\n        }\r\n\r\n        bonusEndTime = _now + 12 hours;\r\n        leader = msg.sender;\r\n        lastPrice = _ethUse;\r\n\r\n        if (_ref != address(0) && _ref != msg.sender)\r\n        {\r\n            uint256 _refTotal = invested_m[_ref].amount;\r\n            if (_refTotal < 5000000000000000000)\r\n            {\r\n                _promoteAmount = (_ethUse.mul(3) / 100);\r\n                _teamAmount = (_ethUse.mul(7) / 100);\r\n            } else if (_refTotal < 20000000000000000000) {\r\n                _promoteAmount = (_ethUse.mul(5) / 100);\r\n                _teamAmount = (_ethUse.mul(5) / 100);\r\n            } else {\r\n                _promoteAmount = (_ethUse.mul(7) / 100);\r\n                _teamAmount = (_ethUse.mul(3) / 100);\r\n            }\r\n\r\n            _ref.transfer(_promoteAmount);\r\n        } else {\r\n            _teamAmount = (_ethUse.mul(10) / 100);\r\n        }\r\n\r\n        owner.transfer(_teamAmount);\r\n\r\n        _otherAmount = (_ethUse.mul(45) / 100);\r\n\r\n        floatFund = floatFund.add(_otherAmount);\r\n        bonus = bonus.add(_otherAmount);\r\n    }\r\n\r\n    /**\r\n     * @dev change owner.\r\n     */\r\n    function changeOwner(address newOwner)\r\n        onlyOwner()\r\n        public\r\n    {\r\n        owner = newOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev getInfo\r\n     */\r\n    function getInfo()\r\n        public \r\n        view \r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, uint256)\r\n    {\r\n        return (\r\n            startBlockNo,\r\n            startTotal,\r\n            total,\r\n            people,\r\n            floatFund,\r\n            safeFund,\r\n            bonus,\r\n            bonusEndTime,\r\n            leader,\r\n            lastPrice\r\n        );\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"lastPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startBlockNo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leader\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invested_m\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"safeAmount\",\"type\":\"uint256\"},{\"name\":\"atBlock\",\"type\":\"uint256\"},{\"name\":\"withdraw\",\"type\":\"uint256\"},{\"name\":\"canWithdraw\",\"type\":\"uint256\"},{\"name\":\"maxWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"people\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"safeFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"floatFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint8\"},{\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"SuperBank","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://29eb579ce8d6fc2a6a833ce826509ffc7eaf57fa336558855d4d0ac29e4724e0"}]}