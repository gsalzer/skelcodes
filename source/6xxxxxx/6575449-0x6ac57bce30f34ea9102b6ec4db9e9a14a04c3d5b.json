{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n\r\ninterface ERC20 {\r\n    event Transfer(address indexed from, address indexed to, uint256 value);  \r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    function transfer(address to, uint256 value) external returns (bool ok);\r\n    function transferFrom(address from, address to, uint256 value) external returns (bool ok);\r\n    function approve(address spender, uint256 value) external returns (bool ok);  \r\n    function totalSupply() external view returns(uint256);\r\n}\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\ncontract Ownable {    \r\n    address public owner;\r\n    address public tempOwner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event OwnershipTransferRequest(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    // Constructor which will assing the admin to the contract deployer.\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Modifier which will make sure only admin can call a particuler function.\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    // This method is used to transfer ownership to a new admin. This is the first of the two stesps.\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferRequest(owner, newOwner);\r\n        tempOwner = newOwner;\r\n    }\r\n  \r\n    // This is the second of two steps of ownership transfer, new admin has to call to confirm transfer.\r\n    function acceptOwnership() public {  \r\n        require(tempOwner==msg.sender);\r\n        emit OwnershipTransferred(owner,msg.sender);\r\n        owner = msg.sender;\r\n    }\r\n}\r\n\r\n\r\n\r\n/*\r\n* The HITT token contract, it is a standard ERC20 contract with a small updates to accomodate \r\n* our conditions of adding, validating the stakes.\r\n* \r\n* Author : Vikas\r\n* Auditor : Darryl Morris\r\n*/\r\ncontract HITT is ERC20,Ownable {    \r\n    using SafeMath for uint256;\r\n    string public constant name = \"Health Information Transfer Token\";\r\n    string public constant symbol = \"HITT\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 private constant totalSupply1 = 1000000000 * 10 ** uint256(decimals);\r\n    address[] public founders = [\r\n        0x89Aa30ca3572eB725e5CCdcf39d44BAeD5179560, \r\n        0x1c61461794df20b0Ed8C8D6424Fd7B312722181f];\r\n    address[] public advisors = [\r\n        0xc83eDeC2a4b6A992d8fcC92484A82bC312E885B5, \r\n        0x9346e8A0C76825Cd95BC3679ab83882Fd66448Ab, \r\n        0x3AA2958c7799faAEEbE446EE5a5D90057fB5552d, \r\n        0xF90f4D2B389D499669f62F3a6F5E0701DFC202aF, \r\n        0x45fF9053b44914Eedc90432c3B6674acDD400Cf1, \r\n        0x663070ab83fEA900CB7DCE7c92fb44bA9E0748DE];\r\n    mapping (address => uint256)  balances;\r\n    mapping (address => mapping (address => uint256))  allowed;\r\n    mapping (address => uint64) lockTimes;\r\n    \r\n    /*\r\n    * 31104000 = 360 Days in seconds. We're not using whole 365 days for `tokenLockTime` \r\n    * because we have used multiple of 90 for 3M, 6M, 9M and 12M in the Hodler Smart contract's time calculation as well.\r\n    * We shall use it to lock the tokens of Advisors and Founders. \r\n    */\r\n    uint64 public constant tokenLockTime = 31104000;\r\n    \r\n    /*\r\n    * Need to update the actual value during deployement. update needed.\r\n    * This is HODL pool. It shall be distributed for the whole year as a \r\n    * HODL bonus among the people who shall not move their ICO tokens for \r\n    * 3,6,9 and 12 months respectively. \r\n    */\r\n    uint256 public constant hodlerPoolTokens = 15000000 * 10 ** uint256(decimals) ; \r\n    Hodler public hodlerContract;\r\n\r\n    /*\r\n    * The constructor method which will initialize the token supply.\r\n    * We've multiple `Transfer` events emitting from the Constructor so that Etherscan can pick \r\n    * it as the contributor's address and can show correct informtaion on the site.\r\n    * We're deliberately choosing the manual transfer of the tokens to the advisors and the founders over the \r\n    * internal `_transfer()` because the admin might use the same account for deploying this Contract and as an founder address.\r\n    * which will have `locktime`.\r\n    */\r\n    constructor() public {\r\n        uint8 i=0 ;\r\n        balances[0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6] = totalSupply1;\r\n        emit Transfer(0x0,0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6,totalSupply1);\r\n        uint256 length = founders.length ;\r\n        for( ; i < length ; i++ ){\r\n            /*\r\n            * These 45 days shall be used to distribute the tokens to the contributors of the ICO.\r\n            */\r\n            lockTimes[founders[i]] = uint64(block.timestamp + 365 days + tokenLockTime );\r\n        }\r\n        length = advisors.length ;\r\n        for( i=0 ; i < length ; i++ ){\r\n            lockTimes[advisors[i]] = uint64(block.timestamp +  365 days + tokenLockTime); \r\n            balances[0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6] = balances[0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6].sub(40000 * 10 ** uint256(decimals));\r\n            balances[advisors[i]] = 40000 * 10 ** uint256(decimals) ;\r\n            emit Transfer( 0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6, advisors[i], 40000 * 10 ** uint256(decimals) );\r\n        }\r\n        balances[0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6] = balances[0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6].sub(130000000 * 10 ** uint256(decimals));\r\n        balances[founders[0]] = 100000000 * 10 ** uint256(decimals) ;\r\n        balances[founders[1]] =  30000000 * 10 ** uint256(decimals) ; \r\n        emit Transfer( 0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6, founders[0], 100000000 * 10 ** uint256(decimals) );\r\n        emit Transfer( 0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6, founders[1],  30000000 * 10 ** uint256(decimals) );\r\n        hodlerContract = new Hodler(hodlerPoolTokens, msg.sender); \r\n        balances[0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6] = balances[0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6].sub(hodlerPoolTokens);\r\n        balances[address(hodlerContract)] = hodlerPoolTokens; // giving the total hodler bonus to the HODLER contract to distribute.        \r\n        assert(totalSupply1 == balances[0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6].add(hodlerPoolTokens.add((130000000 * 10 ** uint256(decimals)).add(length.mul(40000 * 10 ** uint256(decimals))))));\r\n        emit Transfer( 0x60Bf75BB47cbD4cD1eeC7Cd48eab1F16Ebe822c6, address(hodlerContract), hodlerPoolTokens );\r\n    }\r\n    \r\n\r\n    /*\r\n    * Constant function to return the total supply of the HITT contract\r\n    */\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalSupply1;\r\n    }\r\n\r\n    /* \r\n    * Transfer amount from one account to another. The code takes care that it doesn't transfer the tokens to contracts. \r\n    * This function trigger the action to invalidate the participant's right to get the\r\n    *  HODL rewards if they make any transaction within the hodl period.\r\n    * Getting into the HODL club is optional by not moving their tokens after receiving tokens in their wallet for \r\n    * pre-defined period like 3,6,9 or 12 months.\r\n    * More details are here about the HODL T&C : https://medium.com/@Vikas1188/lets-hodl-with-emrify-bc5620a14237\r\n    */\r\n    function _transfer(address _from, address _to, uint256 _value) internal returns (bool) {\r\n        require(!isContract(_to));\r\n        require(block.timestamp > lockTimes[_from]);\r\n        uint256 prevBalTo = balances[_to] ;\r\n        uint256 prevBalFrom = balances[_from];\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        if(hodlerContract.isValid(_from)) {\r\n            require(hodlerContract.invalidate(_from));\r\n        }\r\n        emit Transfer(_from, _to, _value);\r\n        assert(_value == balances[_to].sub(prevBalTo));\r\n        assert(_value == prevBalFrom.sub(balances[_from]));\r\n        return true;\r\n    }\r\n\t\r\n    /*\r\n    * Standard token transfer method.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        return _transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /*\r\n    * This method will allow a 3rd person to spend tokens (requires `approval()` \r\n    * to be called before with that 3rd person's address)\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= allowed[_from][msg.sender]); \r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        return _transfer(_from, _to, _value);\r\n    }\r\n\r\n    /*\r\n    * Approve `_spender` to move `_value` tokens from owner's account\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(block.timestamp>lockTimes[msg.sender]);\r\n        allowed[msg.sender][_spender] = _value; \r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /*\r\n    * Returns balance\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /*\r\n    * Returns whether the `_spender` address is allowed to move the coins of the `_owner` \r\n    */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    /*\r\n    * This method will be used by the admin to allocate tokens to multiple contributors in a single shot.\r\n    */\r\n    function saleDistributionMultiAddress(address[] _addresses,uint256[] _values) public onlyOwner returns (bool) {    \r\n        require( _addresses.length > 0 && _addresses.length == _values.length); \r\n        uint256 length = _addresses.length ;\r\n        for(uint8 i=0 ; i < length ; i++ )\r\n        {\r\n            if(_addresses[i] != address(0) && _addresses[i] != owner) {\r\n                require(hodlerContract.addHodlerStake(_addresses[i], _values[i]));\r\n                _transfer( msg.sender, _addresses[i], _values[i]) ;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n     \r\n    /*\r\n    * This method will be used to send tokens to multiple addresses.\r\n    */\r\n    function batchTransfer(address[] _addresses,uint256[] _values) public  returns (bool) {    \r\n        require(_addresses.length > 0 && _addresses.length == _values.length);\r\n        uint256 length = _addresses.length ;\r\n        for( uint8 i = 0 ; i < length ; i++ ){\r\n            \r\n            if(_addresses[i] != address(0)) {\r\n                _transfer(msg.sender, _addresses[i], _values[i]);\r\n            }\r\n        }\r\n        return true;\r\n    }   \r\n    \r\n    /*\r\n    * This method checks whether the address is a contract or not. \r\n    */\r\n    function isContract(address _addr) private view returns (bool) {\r\n        uint32 size;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return (size > 0);\r\n    }\r\n    \r\n}\r\n\r\n\r\ncontract Hodler is Ownable {\r\n    using SafeMath for uint256;\r\n    bool istransferringTokens = false;\r\n    address public admin; // getting updated in constructor\r\n    \r\n    /* \r\n    * HODLER reward tracker\r\n    * stake amount per address\r\n    * Claim flags for 3,6,9 & 12 months respectiviely.\r\n    * It shall be really useful to get the details whether a particular address got his claims.\r\n    */\r\n    struct HODL {\r\n        uint256 stake;\r\n        bool claimed3M;\r\n        bool claimed6M;\r\n        bool claimed9M;\r\n        bool claimed12M;\r\n    }\r\n\r\n    mapping (address => HODL) public hodlerStakes;\r\n\r\n    /* \r\n    * Total current staking value & count of hodler addresses.\r\n    * hodlerTotalValue = ∑ all the valid distributed tokens. \r\n    * This shall be the reference in which we shall distribute the HODL bonus.\r\n    * hodlerTotalCount = count of the different addresses who is still HODLing their intial distributed tokens.\r\n    */\r\n    uint256 public hodlerTotalValue;\r\n    uint256 public hodlerTotalCount;\r\n\r\n    /*\r\n    * To keep the snapshot of the tokens for 3,6,9 & 12 months after token sale.\r\n    * Since people shall invalidate their stakes during the HODL period, we shall keep \r\n    * decreasing their share from the `hodlerTotalValue`. it shall always have the \r\n    * user's ICO contribution who've not invalidated their stakes.\r\n    */\r\n    uint256 public hodlerTotalValue3M;\r\n    uint256 public hodlerTotalValue6M;\r\n    uint256 public hodlerTotalValue9M;\r\n    uint256 public hodlerTotalValue12M;\r\n\r\n    /*\r\n    * This shall be set deterministically to 45 days in the constructor itself \r\n    * from the deployment date of the Token Contract. \r\n    */\r\n    uint256 public hodlerTimeStart;\r\n \r\n    /*\r\n    * Reward HITT token amount for 3,6,9 & 12 months respectively, which shall be \r\n    * calculated deterministically in the contructor\r\n    */\r\n    uint256 public TOKEN_HODL_3M;\r\n    uint256 public TOKEN_HODL_6M;\r\n    uint256 public TOKEN_HODL_9M;\r\n    uint256 public TOKEN_HODL_12M;\r\n\r\n    /* \r\n    * Total amount of tokens claimed so far while the HODL period\r\n    */\r\n    uint256 public claimedTokens;\r\n    \r\n    event LogHodlSetStake(address indexed _beneficiary, uint256 _value);\r\n    event LogHodlClaimed(address indexed _beneficiary, uint256 _value);\r\n\r\n    ERC20 public tokenContract;\r\n    \r\n    /*\r\n    * Modifier: before hodl is started\r\n    */\r\n    modifier beforeHodlStart() {\r\n        require(block.timestamp < hodlerTimeStart);\r\n        _;\r\n    }\r\n\r\n    /*\r\n    * Constructor: It shall set values deterministically\r\n    * It should be created by a token distribution contract\r\n    * Because we cannot multiply rational with integer, \r\n    * we are using 75 instead of 7.5 and dividing with 1000 instaed of 100.\r\n    */\r\n    constructor(uint256 _stake, address _admin) public {\r\n        TOKEN_HODL_3M = (_stake*75)/1000;\r\n        TOKEN_HODL_6M = (_stake*15)/100;\r\n        TOKEN_HODL_9M = (_stake*30)/100;\r\n        TOKEN_HODL_12M = (_stake*475)/1000;\r\n        tokenContract = ERC20(msg.sender);\r\n        hodlerTimeStart = block.timestamp.add(365 days) ; // These 45 days shall be used to distribute the tokens to the contributors of the ICO\r\n        admin = _admin;\r\n    }\r\n    \r\n    /*\r\n    * This method will only be called by the `saleDistributionMultiAddress()` \r\n    * from the Token Contract. \r\n    */\r\n    function addHodlerStake(address _beneficiary, uint256 _stake) public onlyOwner beforeHodlStart returns (bool) {\r\n        // real change and valid _beneficiary is needed\r\n        if (_stake == 0 || _beneficiary == address(0))\r\n            return false;\r\n        \r\n        // add stake and maintain count\r\n        if (hodlerStakes[_beneficiary].stake == 0)\r\n            hodlerTotalCount = hodlerTotalCount.add(1);\r\n        hodlerStakes[_beneficiary].stake = hodlerStakes[_beneficiary].stake.add(_stake);\r\n        hodlerTotalValue = hodlerTotalValue.add(_stake);\r\n        emit LogHodlSetStake(_beneficiary, hodlerStakes[_beneficiary].stake);\r\n        return true;\r\n    }\r\n   \r\n    /* \r\n    * This method can only be called by HITT token contract.\r\n    * This will return true: when we successfully invalidate a stake\r\n    * false: When we try to invalidate the stake of either already\r\n    * invalidated or not participated stake holder in Pre-ico\r\n    */ \r\n    function invalidate(address _account) public onlyOwner returns (bool) {\r\n        if (hodlerStakes[_account].stake > 0 ) {\r\n            hodlerTotalValue = hodlerTotalValue.sub(hodlerStakes[_account].stake); \r\n            hodlerTotalCount = hodlerTotalCount.sub(1);\r\n            updateAndGetHodlTotalValue();\r\n            delete hodlerStakes[_account];\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /* \r\n    * This method will be used whether the particular user has HODL stake or not.   \r\n    */\r\n    function isValid(address _account) view public returns (bool) {\r\n        if (hodlerStakes[_account].stake > 0) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    /*\r\n    * Claiming HODL reward for an address.\r\n    * Ideally it shall be called by Admin. But it can be called by anyone \r\n    * by passing the beneficiery address.\r\n    */\r\n    function claimHodlRewardFor(address _beneficiary) public returns (bool) {\r\n        require(block.timestamp.sub(hodlerTimeStart)<= 450 days ); \r\n        // only when the address has a valid stake\r\n        require(hodlerStakes[_beneficiary].stake > 0);\r\n        updateAndGetHodlTotalValue();\r\n        uint256 _stake = calculateStake(_beneficiary);\r\n        if (_stake > 0) {\r\n            if (istransferringTokens == false) {\r\n            // increasing claimed tokens\r\n            claimedTokens = claimedTokens.add(_stake);\r\n                istransferringTokens = true;\r\n            // Transferring tokens\r\n            require(tokenContract.transfer(_beneficiary, _stake));\r\n                istransferringTokens = false ;\r\n            emit LogHodlClaimed(_beneficiary, _stake);\r\n            return true;\r\n            }\r\n        } \r\n        return false;\r\n    }\r\n\r\n    /* \r\n    * This method is to calculate the HODL stake for a particular user at a time.\r\n    */\r\n    function calculateStake(address _beneficiary) internal returns (uint256) {\r\n        uint256 _stake = 0;\r\n                \r\n        HODL memory hodler = hodlerStakes[_beneficiary];\r\n        \r\n        if(( hodler.claimed3M == false ) && ( block.timestamp.sub(hodlerTimeStart)) >= 90 days){ \r\n            _stake = _stake.add(hodler.stake.mul(TOKEN_HODL_3M).div(hodlerTotalValue3M));\r\n            hodler.claimed3M = true;\r\n        }\r\n        if(( hodler.claimed6M == false ) && ( block.timestamp.sub(hodlerTimeStart)) >= 180 days){ \r\n            _stake = _stake.add(hodler.stake.mul(TOKEN_HODL_6M).div(hodlerTotalValue6M));\r\n            hodler.claimed6M = true;\r\n        }\r\n        if(( hodler.claimed9M == false ) && ( block.timestamp.sub(hodlerTimeStart)) >= 270 days ){ \r\n            _stake = _stake.add(hodler.stake.mul(TOKEN_HODL_9M).div(hodlerTotalValue9M));\r\n            hodler.claimed9M = true;\r\n        }\r\n        if(( hodler.claimed12M == false ) && ( block.timestamp.sub(hodlerTimeStart)) >= 360 days){ \r\n            _stake = _stake.add(hodler.stake.mul(TOKEN_HODL_12M).div(hodlerTotalValue12M));\r\n            hodler.claimed12M = true;\r\n        }\r\n        \r\n        hodlerStakes[_beneficiary] = hodler;\r\n        return _stake;\r\n    }\r\n    \r\n    /*\r\n    * This method is to complete HODL period. Any leftover tokens will \r\n    * return to admin and then will be added to the growth pool after 450 days .\r\n    */\r\n    function finalizeHodler() public returns (bool) {\r\n        require(msg.sender == admin);\r\n        require(block.timestamp >= hodlerTimeStart.add( 450 days ) ); \r\n        uint256 amount = tokenContract.balanceOf(this);\r\n        require(amount > 0);\r\n        if (istransferringTokens == false) {\r\n            istransferringTokens = true;\r\n            require(tokenContract.transfer(admin,amount));\r\n            istransferringTokens = false;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    \r\n\r\n    /*\r\n    * `claimHodlRewardsForMultipleAddresses()` for multiple addresses.\r\n    * Anyone can call this function and distribute hodl rewards.\r\n    * `_beneficiaries` is the array of addresses for which we want to claim HODL rewards.\r\n    */\r\n    function claimHodlRewardsForMultipleAddresses(address[] _beneficiaries) external returns (bool) {\r\n        require(block.timestamp.sub(hodlerTimeStart) <= 450 days ); \r\n        uint8 length = uint8(_beneficiaries.length);\r\n        for (uint8 i = 0; i < length ; i++) {\r\n            if(hodlerStakes[_beneficiaries[i]].stake > 0 && (hodlerStakes[_beneficiaries[i]].claimed3M == false || hodlerStakes[_beneficiaries[i]].claimed6M == false || hodlerStakes[_beneficiaries[i]].claimed9M == false || hodlerStakes[_beneficiaries[i]].claimed12M == false)) { \r\n                require(claimHodlRewardFor(_beneficiaries[i]));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    \r\n    /* \r\n    * This method is used to set the amount of `hodlerTotalValue` remaining.\r\n    * `hodlerTotalValue` will keep getting lower as the people shall be invalidating their stakes over the period of 12 months.\r\n    * Setting 3, 6, 9 & 12 months total staked token value.\r\n    */\r\n    function updateAndGetHodlTotalValue() public returns (uint) {\r\n        if (block.timestamp >= hodlerTimeStart+ 90 days && hodlerTotalValue3M == 0) {   \r\n            hodlerTotalValue3M = hodlerTotalValue;\r\n        }\r\n\r\n        if (block.timestamp >= hodlerTimeStart+ 180 days && hodlerTotalValue6M == 0) { \r\n            hodlerTotalValue6M = hodlerTotalValue;\r\n        }\r\n\r\n        if (block.timestamp >= hodlerTimeStart+ 270 days && hodlerTotalValue9M == 0) { \r\n            hodlerTotalValue9M = hodlerTotalValue;\r\n        }\r\n        if (block.timestamp >= hodlerTimeStart+ 360 days && hodlerTotalValue12M == 0) { \r\n            hodlerTotalValue12M = hodlerTotalValue;\r\n        }\r\n\r\n        return hodlerTotalValue;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerPoolTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"batchTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_values\",\"type\":\"uint256[]\"}],\"name\":\"saleDistributionMultiAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tempOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hodlerContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"advisors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"founders\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenLockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"HITT","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ae0a5a9d6a368277850f7ba95a878b9c21d80577cadcd858cd56e387a2e35d7f"}]}