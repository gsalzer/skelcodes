{"status":"1","message":"OK","result":[{"SourceCode":"// Copyright (c) 2018, Jack Parkinson. All rights reserved.\r\n// Use of this source code is governed by the BSD 3-Clause\r\n// license that can be found in the LICENSE file at\r\n// github.com/parkinsonj/exchangeth/blob/master/LICENSE\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary Orders {\r\n    struct Order {\r\n        address tokenOffered;\r\n        uint256 valueOffered;\r\n        address tokenWanted;\r\n        uint256 valueWanted;\r\n        uint256 expiry;\r\n    }   \r\n\r\n    struct Orderbook {\r\n        uint256 lastId;\r\n        mapping (uint256 => Order) orders;\r\n        mapping (uint256 => address) makers;\r\n        mapping (uint256 => uint256) indices;\r\n        uint256[] ids;\r\n    }\r\n\r\n    modifier onlyExisting(Orderbook storage self, uint256 _id) {\r\n        require(self.makers[_id] != address(0), \"Order does not exist.\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValid(address _tokenOffered, address _tokenWanted, uint256 _expiry) {\r\n        // Special case: expiry = 0 implies the order should not expire.\r\n        if (_expiry > 0) { require(_expiry > block.timestamp, \"Expiry must be in the future.\"); }\r\n\r\n        // Check specified addresses are contracts; this does not guarantee that they are token\r\n        // contracts but is a cheap check that prevents accidentally using an ordinary user address.\r\n        //\r\n        // Using ERC165 would be a more complete solution, but many ERC20 tokens do not support that\r\n        // standard.\r\n        //\r\n        // It is debatable whether a stronger check is even worthwhile since in case that a user\r\n        // creates an order with a non-token address, the worst case scenario is that the offer\r\n        // cannot be closed. That is, the maximum potential loss is merely the gas used to create\r\n        // the bad order.\r\n        require(isContract(_tokenOffered), \"Not a contract.\");\r\n        require(isContract(_tokenWanted), \"Not a contract.\");\r\n        _;\r\n    } \r\n\r\n    function createOrder(\r\n        Orderbook storage self,\r\n        address _maker,\r\n        address _tokenOffered,\r\n        uint256 _valueOffered,\r\n        address _tokenWanted,\r\n        uint256 _valueWanted,\r\n        uint256 _expiry\r\n    )\r\n        internal\r\n        onlyValid(_tokenOffered, _tokenWanted, _expiry)\r\n        returns (uint256)\r\n    {\r\n        uint256 id = ++self.lastId; \r\n        self.orders[id] = Order(_tokenOffered, _valueOffered, _tokenWanted, _valueWanted, _expiry);\r\n        self.makers[id] = _maker;\r\n        \r\n        uint256 index = self.ids.length++;\r\n        self.ids[index] = id;\r\n        self.indices[id] = index;\r\n        \r\n        return id;\r\n    }\r\n\r\n    function updateOrder(\r\n        Orderbook storage self,\r\n        uint256 _id,\r\n        address _tokenOffered,\r\n        uint256 _valueOffered,\r\n        address _tokenWanted,\r\n        uint256 _valueWanted,\r\n        uint256 _expiry\r\n    )\r\n        internal\r\n        onlyExisting(self, _id)\r\n        onlyValid(_tokenOffered, _tokenWanted, _expiry)\r\n    {\r\n        Order storage o = self.orders[_id];\r\n        o.tokenOffered = _tokenOffered;\r\n        o.valueOffered = _valueOffered;\r\n        o.tokenWanted = _tokenWanted;\r\n        o.valueWanted = _valueWanted;\r\n        o.expiry = _expiry;\r\n    }\r\n\r\n    function removeOrder(Orderbook storage self, uint256 _id) internal onlyExisting(self, _id) {\r\n        // Get index of order to be removed.\r\n        uint256 index = self.indices[_id];\r\n\r\n        // Decrement the size of ids by moving the final element to the index-th position.\r\n        uint256 id = self.ids[self.ids.length-1];\r\n        self.ids[index] = id;\r\n        self.ids.length--;\r\n\r\n        // Update index for id and delete references to _id.\r\n        self.indices[id] = index;\r\n        delete self.makers[_id];\r\n        delete self.orders[_id];\r\n        delete self.indices[_id];\r\n    }\r\n\r\n    function getOrderAndMaker(Orderbook storage self, uint256 _id) internal view onlyExisting(self, _id) returns (Order memory, address) {\r\n        return (self.orders[_id], self.makers[_id]);\r\n    }\r\n        \r\n    function isContract(address _token) private view returns (bool) {\r\n        uint256 size;\r\n        assembly { size := extcodesize(_token) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract Exchangeth {\r\n    using Orders for Orders.Orderbook;\r\n    \r\n    Orders.Orderbook private orderbook;\r\n    uint256 private constant UINT256_MAX = ~uint256(0);\r\n\r\n    event OpenedOrder(uint256 indexed id, address indexed by);\r\n\tevent ClosedOrder(uint256 indexed id, address indexed by);\r\n\tevent CancelledOrder(uint256 indexed id, address indexed by);\r\n    event UpdatedOrder(uint256 indexed id, address indexed by);\r\n    \r\n    modifier onlyMaker(uint256 _id) {\r\n        require(msg.sender == orderbook.makers[_id], \"\");\r\n        _;\r\n    }    \r\n\r\n\tfunction make(\r\n        address _tokenOffered,\r\n        uint256 _valueOffered,\r\n        address _tokenWanted,\r\n        uint256 _valueWanted,\r\n        uint256 _expiry\r\n    )\r\n        external\r\n        returns (uint256)\r\n    {\r\n        uint256 id = orderbook.createOrder(msg.sender, _tokenOffered, _valueOffered, _tokenWanted, _valueWanted, _expiry);\r\n        emit OpenedOrder(id, msg.sender);\r\n        return id;\r\n\t}\r\n    \r\n\tfunction take(uint256 _id) external {\r\n        (Orders.Order memory o, address maker) = orderbook.getOrderAndMaker(_id);\r\n\r\n        if (o.expiry > 0) { require(o.expiry > block.timestamp); }\r\n\r\n        orderbook.removeOrder(_id);\r\n        transferFrom(o.tokenWanted, msg.sender, maker, o.valueWanted);\r\n        transferFrom(o.tokenOffered, maker, msg.sender, o.valueOffered);\r\n\r\n\t\temit ClosedOrder(_id, msg.sender);\r\n\t}\r\n\r\n\tfunction cancel(uint256 _id) external onlyMaker(_id) {\r\n        orderbook.removeOrder(_id);\r\n\t\temit CancelledOrder(_id, msg.sender);\r\n\t}\r\n\r\n    function update(\r\n        uint256 _id,\r\n        address _tokenOffered,\r\n        uint256 _valueOffered,\r\n        address _tokenWanted,\r\n        uint256 _valueWanted,\r\n        uint256 _expiry\r\n    )\r\n        external\r\n        onlyMaker(_id)\r\n    {\r\n        orderbook.updateOrder(_id, _tokenOffered, _valueOffered, _tokenWanted, _valueWanted, _expiry);\r\n        emit UpdatedOrder(_id, msg.sender);\r\n    }\r\n\r\n    function ids() external view returns (uint256[] memory) {\r\n        return orderbook.ids;\r\n    }\r\n\r\n    function order(uint256 _id) external view returns (address, address, uint256, address, uint256, uint256) {\r\n        (Orders.Order memory o, address maker) = orderbook.getOrderAndMaker(_id);\r\n        return (maker, o.tokenOffered, o.valueOffered, o.tokenWanted, o.valueWanted, o.expiry);\r\n    }\r\n\r\n    function transferFrom(address _token, address _from, address _to, uint256 _val) private {\r\n        bytes memory encoded = abi.encodeWithSignature(\"transferFrom(address,address,uint256)\", _from, _to, _val);\r\n        bool success;\r\n        bool result;\r\n        assembly {\r\n            let data := add(0x20, encoded)\r\n            let size := mload(encoded)\r\n            success := call(\r\n                gas,\r\n                _token,\r\n                0,\r\n                data,\r\n                size,\r\n                data,\r\n                0x20\r\n            )\r\n            result := mload(data)\r\n        }\r\n        require(success && result, \"Token transfer failed.\");\r\n    }    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"order\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"take\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_tokenOffered\",\"type\":\"address\"},{\"name\":\"_valueOffered\",\"type\":\"uint256\"},{\"name\":\"_tokenWanted\",\"type\":\"address\"},{\"name\":\"_valueWanted\",\"type\":\"uint256\"},{\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenOffered\",\"type\":\"address\"},{\"name\":\"_valueOffered\",\"type\":\"uint256\"},{\"name\":\"_tokenWanted\",\"type\":\"address\"},{\"name\":\"_valueWanted\",\"type\":\"uint256\"},{\"name\":\"_expiry\",\"type\":\"uint256\"}],\"name\":\"make\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"OpenedOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"ClosedOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"CancelledOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"UpdatedOrder\",\"type\":\"event\"}]","ContractName":"Exchangeth","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://45ef27468f5b6bbd51f5b3734879f1a2522e0cd11f6cdb51bd12d6a410d72c01"}]}