{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\n/**\r\n * @dev Implementation of standard for detect smart contract interfaces.\r\n */\r\ncontract SupportsInterface {\r\n    /**\r\n     * @dev Mapping of supported intefraces.\r\n     * @notice You must not set element 0xffffffff to true.\r\n     */\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     */\r\n    constructor()\r\n    public\r\n    {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check which interfaces are suported by this contract.\r\n     * @param _interfaceID Id of the interface.\r\n     */\r\n    function supportsInterface(\r\n        bytes4 _interfaceID\r\n    )\r\n    external\r\n    view\r\n    returns (bool)\r\n    {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Utility library of inline functions on addresses.\r\n */\r\nlibrary AddressUtils {\r\n\r\n    /**\r\n     * @dev Returns whether the target address is a contract.\r\n     * @param _addr Address to check.\r\n     */\r\n    function isContract(\r\n        address _addr\r\n    )\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        uint256 size;\r\n\r\n        /**\r\n         * XXX Currently there is no better way to check if there is a contract in an address than to\r\n         * check the size of the code at that address.\r\n         * See https://ethereum.stackexchange.com/a/14016/36603 for more details about how this works.\r\n         * TODO: Check this again before the Serenity release, because all addresses will be\r\n         * contracts then.\r\n         */\r\n        assembly { size := extcodesize(_addr) } // solium-disable-line security/no-inline-assembly\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @dev Implementation of ERC-721 non-fungible token standard specifically for WeTrust Spring.\r\n */\r\ncontract NFToken is ERC721, SupportsInterface, ERC721Metadata, ERC721Enumerable {\r\n    using AddressUtils for address;\r\n\r\n    ///////////////////////////\r\n    // Constants\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev Magic value of a smart contract that can recieve NFT.\r\n     * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n     */\r\n    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    //////////////////////////\r\n    // Events\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev Emits when ownership of any NFT changes by any mechanism. This event emits when NFTs are\r\n     * created (`from` == 0) and destroyed (`to` == 0). Exception: during contract creation, any\r\n     * number of NFTs may be created and assigned without emitting Transfer. At the time of any\r\n     * transfer, the approved address for that NFT (if any) is reset to none.\r\n     * @param _from Sender of NFT (if address is zero address it indicates token creation).\r\n     * @param _to Receiver of NFT (if address is zero address it indicates token destruction).\r\n     * @param _tokenId The NFT that got transfered.\r\n     */\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when the approved address for an NFT is changed or reaffirmed. The zero\r\n     * address indicates there is no approved address. When a Transfer event emits, this also\r\n     * indicates that the approved address for that NFT (if any) is reset to none.\r\n     * @param _owner Owner of NFT.\r\n     * @param _approved Address that we are approving.\r\n     * @param _tokenId NFT which we are approving.\r\n     */\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /**\r\n     * @dev This emits when an operator is enabled or disabled for an owner. The operator can manage\r\n     * all NFTs of the owner.\r\n     * @param _owner Owner of NFT.\r\n     * @param _operator Address to which we are setting operator rights.\r\n     * @param _approved Status of operator rights(true if operator rights are given and false if\r\n     * revoked).\r\n     */\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    ////////////////////////////////\r\n    // Modifiers\r\n    ///////////////////////////////\r\n\r\n    /**\r\n     * @dev Guarantees that the msg.sender is an owner or operator of the given NFT.\r\n     * @param _tokenId ID of the NFT to validate.\r\n     */\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = nft[_tokenId].owner;\r\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender], \"Sender is not an authorized operator of this token\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that the msg.sender is allowed to transfer NFT.\r\n     * @param _tokenId ID of the NFT to transfer.\r\n     */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = nft[_tokenId].owner;\r\n        require(\r\n            tokenOwner == msg.sender ||\r\n            getApproved(_tokenId) == msg.sender || ownerToOperators[tokenOwner][msg.sender],\r\n            \"Sender does not have permission to transfer this Token\");\r\n\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check to make sure the address is not zero address\r\n     * @param toTest The Address to make sure it's not zero address\r\n     */\r\n    modifier onlyNonZeroAddress(address toTest) {\r\n        require(toTest != address(0), \"Address must be non zero address\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that no owner exists for the nft\r\n     * @param nftId NFT to test\r\n     */\r\n    modifier noOwnerExists(uint256 nftId) {\r\n        require(nft[nftId].owner == address(0), \"Owner must not exist for this token\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarantees that an owner exists for the nft\r\n     * @param nftId NFT to test\r\n     */\r\n    modifier ownerExists(uint256 nftId) {\r\n        require(nft[nftId].owner != address(0), \"Owner must exist for this token\");\r\n        _;\r\n    }\r\n\r\n    ///////////////////////////\r\n    // Storage Variable\r\n    //////////////////////////\r\n\r\n    /**\r\n     * @dev name of the NFT\r\n     */\r\n    string nftName = \"WeTrust Nifty\";\r\n\r\n    /**\r\n     * @dev NFT symbol\r\n     */\r\n    string nftSymbol = \"SPRN\";\r\n\r\n    /**\r\n     * @dev hostname to be used as base for tokenURI\r\n     */\r\n    string public hostname = \"https://spring.wetrust.io/shiba/\";\r\n\r\n    /**\r\n     * @dev A mapping from NFT ID to the address that owns it.\r\n     */\r\n    mapping (uint256 => NFT) public nft;\r\n\r\n    /**\r\n     * @dev List of NFTs\r\n     */\r\n    uint256[] nftList;\r\n\r\n    /**\r\n    * @dev Mapping from owner address to count of his tokens.\r\n    */\r\n    mapping (address => uint256[]) internal ownerToTokenList;\r\n\r\n    /**\r\n     * @dev Mapping from owner address to mapping of operator addresses.\r\n     */\r\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n\r\n    struct NFT {\r\n        address owner;\r\n        address approval;\r\n        bytes32 traits;\r\n        uint16 edition;\r\n        bytes4 nftType;\r\n        bytes32 recipientId;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    ////////////////////////////////\r\n    // Public Functions\r\n    ///////////////////////////////\r\n\r\n    /**\r\n     * @dev Contract constructor.\r\n     */\r\n    constructor() public {\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721MetaData\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of NFTs owned by `_owner`. NFTs assigned to the zero address are\r\n     * considered invalid, and this function throws for queries about the zero address.\r\n     * @param _owner Address for whom to query the balance.\r\n     */\r\n    function balanceOf(address _owner) onlyNonZeroAddress(_owner) public view returns (uint256) {\r\n        return ownerToTokenList[_owner].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the address of the owner of the NFT. NFTs assigned to zero address are considered\r\n     * invalid, and queries about them do throw.\r\n     * @param _tokenId The identifier for an NFT.\r\n     */\r\n    function ownerOf(uint256 _tokenId) ownerExists(_tokenId) external view returns (address _owner) {\r\n        return nft[_tokenId].owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of an NFT from one address to another address.\r\n     * @notice Throws unless `msg.sender` is the current owner, an authorized operator, or the\r\n     * approved address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is\r\n     * the zero address. Throws if `_tokenId` is not a valid NFT. When transfer is complete, this\r\n     * function checks if `_to` is a smart contract (code size > 0). If so, it calls `onERC721Received`\r\n     * on `_to` and throws if the return value is not `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     * @param _data Additional data with no specified format, sent in call to `_to`.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers the ownership of an NFT from one address to another address.\r\n     * @notice This works identically to the other function with an extra data parameter, except this\r\n     * function just sets data to \"\"\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Throws unless `msg.sender` is the current owner, an authorized operator, or the approved\r\n     * address for this NFT. Throws if `_from` is not the current owner. Throws if `_to` is the zero\r\n     * address. Throws if `_tokenId` is not a valid NFT.\r\n     * @notice The caller is responsible to confirm that `_to` is capable of receiving NFTs or else\r\n     * they maybe be permanently lost.\r\n     * @param _from The current owner of the NFT.\r\n     * @param _to The new owner.\r\n     * @param _tokenId The NFT to transfer.\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _tokenId)\r\n        onlyNonZeroAddress(_to)\r\n        canTransfer(_tokenId)\r\n        ownerExists(_tokenId)\r\n        external\r\n    {\r\n\r\n        address tokenOwner = nft[_tokenId].owner;\r\n        require(tokenOwner == _from, \"from address must be owner of tokenId\");\r\n\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Set or reaffirm the approved address for an NFT.\r\n     * @notice The zero address indicates there is no approved address. Throws unless `msg.sender` is\r\n     * the current NFT owner, or an authorized operator of the current owner.\r\n     * @param _approved Address to be approved for the given NFT ID.\r\n     * @param _tokenId ID of the token to be approved.\r\n     */\r\n    function approve(address _approved, uint256 _tokenId)\r\n        canOperate(_tokenId)\r\n        ownerExists(_tokenId)\r\n        external\r\n    {\r\n\r\n        address tokenOwner = nft[_tokenId].owner;\r\n        require(_approved != tokenOwner, \"approved address cannot be owner of the token\");\r\n\r\n        nft[_tokenId].approval = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Enables or disables approval for a third party (\"operator\") to manage all of\r\n     * `msg.sender`'s assets. It also emits the ApprovalForAll event.\r\n     * @notice This works even if sender doesn't own any tokens at the time.\r\n     * @param _operator Address to add to the set of authorized operators.\r\n     * @param _approved True if the operators is approved, false to revoke approval.\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved)\r\n        onlyNonZeroAddress(_operator)\r\n        external\r\n    {\r\n\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the approved address for a single NFT.\r\n     * @notice Throws if `_tokenId` is not a valid NFT.\r\n     * @param _tokenId ID of the NFT to query the approval of.\r\n     */\r\n    function getApproved(uint256 _tokenId)\r\n        ownerExists(_tokenId)\r\n        public view returns (address)\r\n    {\r\n\r\n        return nft[_tokenId].approval;\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if `_operator` is an approved operator for `_owner`.\r\n     * @param _owner The address that owns the NFTs.\r\n     * @param _operator The address that acts on behalf of the owner.\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        onlyNonZeroAddress(_owner)\r\n        onlyNonZeroAddress(_operator)\r\n        external view returns (bool)\r\n    {\r\n\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev return token list of owned by the owner\r\n     * @param owner The address that owns the NFTs.\r\n     */\r\n    function getOwnedTokenList(address owner) view public returns(uint256[] tokenList) {\r\n        return ownerToTokenList[owner];\r\n    }\r\n\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string _name) {\r\n        return nftName;\r\n    }\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string _symbol) {\r\n        return nftSymbol;\r\n    }\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string) {\r\n        return appendUintToString(hostname, _tokenId);\r\n    }\r\n\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256) {\r\n        return nftList.length;\r\n    }\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < nftList.length, \"index out of range\");\r\n        return nftList[_index];\r\n    }\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        require(_index < balanceOf(_owner), \"index out of range\");\r\n        return ownerToTokenList[_owner][_index];\r\n    }\r\n\r\n    /////////////////////////////\r\n    // Private Functions\r\n    ////////////////////////////\r\n\r\n    /**\r\n     * @dev append uint to the end of string\r\n     * @param inStr input string\r\n     * @param v uint value v\r\n     * credit goes to : https://ethereum.stackexchange.com/questions/10811/solidity-concatenate-uint-into-a-string\r\n     */\r\n\r\n    function appendUintToString(string inStr, uint v) pure internal returns (string str) {\r\n        uint maxlength = 100;\r\n        bytes memory reversed = new bytes(maxlength);\r\n        uint i = 0;\r\n        while (v != 0) {\r\n            uint remainder = v % 10;\r\n            v = v / 10;\r\n            reversed[i++] = byte(48 + remainder);\r\n        }\r\n        bytes memory inStrb = bytes(inStr);\r\n        bytes memory s = new bytes(inStrb.length + i);\r\n        uint j;\r\n        for (j = 0; j < inStrb.length; j++) {\r\n            s[j] = inStrb[j];\r\n        }\r\n        for (j = 0; j < i; j++) {\r\n            s[j + inStrb.length] = reversed[i - 1 - j];\r\n        }\r\n        str = string(s);\r\n    }\r\n\r\n    /**\r\n     * @dev Actually preforms the transfer.\r\n     * @notice Does NO checks.\r\n     * @param _to Address of a new owner.\r\n     * @param _tokenId The NFT that is being transferred.\r\n     */\r\n    function _transfer(address _to, uint256 _tokenId) private {\r\n        address from = nft[_tokenId].owner;\r\n        clearApproval(_tokenId);\r\n\r\n        removeNFToken(from, _tokenId);\r\n        addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n\r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data)\r\n        onlyNonZeroAddress(_to)\r\n        canTransfer(_tokenId)\r\n        ownerExists(_tokenId)\r\n        internal\r\n    {\r\n        address tokenOwner = nft[_tokenId].owner;\r\n        require(tokenOwner == _from, \"from address must be owner of tokenId\");\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (_to.isContract()) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED, \"reciever contract did not return the correct return value\");\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Clears the current approval of a given NFT ID.\r\n     * @param _tokenId ID of the NFT to be transferred.\r\n     */\r\n    function clearApproval(uint256 _tokenId) private {\r\n        if(nft[_tokenId].approval != address(0))\r\n        {\r\n            delete nft[_tokenId].approval;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Removes a NFT from owner.\r\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n     * @param _from Address from wich we want to remove the NFT.\r\n     * @param _tokenId Which NFT we want to remove.\r\n     */\r\n    function removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(nft[_tokenId].owner == _from, \"from address must be owner of tokenId\");\r\n        uint256[] storage tokenList = ownerToTokenList[_from];\r\n        assert(tokenList.length > 0);\r\n\r\n        for (uint256 i = 0; i < tokenList.length; i++) {\r\n            if (tokenList[i] == _tokenId) {\r\n                tokenList[i] = tokenList[tokenList.length - 1];\r\n                delete tokenList[tokenList.length - 1];\r\n                tokenList.length--;\r\n                break;\r\n            }\r\n        }\r\n        delete nft[_tokenId].owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Assignes a new NFT to owner.\r\n     * @notice Use and override this function with caution. Wrong usage can have serious consequences.\r\n     * @param _to Address to wich we want to add the NFT.\r\n     * @param _tokenId Which NFT we want to add.\r\n     */\r\n    function addNFToken(address _to, uint256 _tokenId)\r\n        noOwnerExists(_tokenId)\r\n        internal\r\n    {\r\n        nft[_tokenId].owner = _to;\r\n        ownerToTokenList[_to].push(_tokenId);\r\n    }\r\n\r\n}\r\n\r\n\r\n//@dev Implemention of NFT for WeTrust Spring\r\ncontract SpringNFT is NFToken{\r\n\r\n\r\n    //////////////////////////////\r\n    // Events\r\n    /////////////////////////////\r\n    event RecipientUpdate(bytes32 indexed recipientId, bytes32 updateId);\r\n\r\n    //////////////////////////////\r\n    // Modifiers\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @dev Guarrentees that recipient Exists\r\n     * @param id receipientId to check\r\n     */\r\n    modifier recipientExists(bytes32 id) {\r\n        require(recipients[id].exists, \"Recipient Must exist\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarrentees that recipient does not Exists\r\n     * @param id receipientId to check\r\n     */\r\n    modifier recipientDoesNotExists(bytes32 id) {\r\n        require(!recipients[id].exists, \"Recipient Must not exists\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarrentees that msg.sender is wetrust owned signer address\r\n     */\r\n    modifier onlyByWeTrustSigner() {\r\n        require(msg.sender == wetrustSigner, \"sender must be from WeTrust Signer Address\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarrentees that msg.sender is wetrust owned manager address\r\n     */\r\n    modifier onlyByWeTrustManager() {\r\n        require(msg.sender == wetrustManager, \"sender must be from WeTrust Manager Address\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarrentees that msg.sender is either wetrust recipient\r\n     * @param id receipientId to check\r\n     */\r\n    modifier onlyByWeTrustOrRecipient(bytes32 id) {\r\n        require(msg.sender == wetrustSigner || msg.sender == recipients[id].owner, \"sender must be from WeTrust or Recipient's owner address\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Guarrentees that contract is not in paused state\r\n     */\r\n    modifier onlyWhenNotPaused() {\r\n        require(!paused, \"contract is currently in paused state\");\r\n        _;\r\n    }\r\n\r\n    //////////////////////////////\r\n    // Storage Variables\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @dev wetrust controlled address that is used to create new NFTs\r\n     */\r\n    address public wetrustSigner;\r\n\r\n    /**\r\n     *@dev wetrust controlled address that is used to switch the signer address\r\n     */\r\n    address public wetrustManager;\r\n\r\n    /**\r\n     * @dev if paused is true, suspend most of contract's functionality\r\n     */\r\n    bool public paused;\r\n\r\n    /**\r\n     * @dev mapping of recipients from WeTrust Spring platform\r\n     */\r\n    mapping(bytes32 => Recipient) public recipients;\r\n    /**\r\n     * @dev mapping to a list of updates made by recipients\r\n     */\r\n    mapping(bytes32 => Update[]) public recipientUpdates;\r\n\r\n    /**\r\n     * @dev Stores the Artist signed Message who created the NFT\r\n     */\r\n    mapping (uint256 => bytes) public nftArtistSignature;\r\n\r\n    struct Update {\r\n        bytes32 id;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    struct Recipient {\r\n        string name;\r\n        string url;\r\n        address owner;\r\n        uint256 nftCount;\r\n        bool exists;\r\n    }\r\n\r\n    //////////////////////////////\r\n    // Public functions\r\n    /////////////////////////////\r\n\r\n    /**\r\n     * @dev contract constructor\r\n     */\r\n    constructor (address signer, address manager) NFToken() public {\r\n        wetrustSigner = signer;\r\n        wetrustManager = manager;\r\n    }\r\n\r\n    /**\r\n     * @dev Create a new NFT\r\n     * @param tokenId create new NFT with this tokenId\r\n     * @param receiver the owner of the new NFT\r\n     * @param recipientId The issuer of the NFT\r\n     * @param traits NFT Traits\r\n     * @param nftType Type of the NFT\r\n     */\r\n\r\n    function createNFT(\r\n        uint256 tokenId,\r\n        address receiver,\r\n        bytes32 recipientId,\r\n        bytes32 traits,\r\n        bytes4 nftType)\r\n        noOwnerExists(tokenId)\r\n        onlyByWeTrustSigner\r\n        onlyWhenNotPaused public\r\n    {\r\n        mint(tokenId, receiver, recipientId, traits, nftType);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows anyone to redeem a token by providing a signed Message from Spring platform\r\n     * @param signedMessage A signed Message containing the NFT parameter from Spring platform\r\n     * The Signed Message must be concatenated in the following format\r\n     * - address to (the smart contract address)\r\n     * - uint256 tokenId\r\n     * - bytes4 nftType\r\n     * - bytes32 traits\r\n     * - bytes32 recipientId\r\n     * - bytes32 r of Signature\r\n     * - bytes32 s of Signature\r\n     * - uint8 v of Signature\r\n     */\r\n    function redeemToken(bytes signedMessage) onlyWhenNotPaused public {\r\n        address to;\r\n        uint256 tokenId;\r\n        bytes4 nftType;\r\n        bytes32 traits;\r\n        bytes32 recipientId;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        byte vInByte;\r\n        uint8 v;\r\n        string memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n\r\n        assembly {\r\n            to := mload(add(signedMessage, 32))\r\n            tokenId := mload(add(signedMessage, 64))\r\n            nftType := mload(add(signedMessage, 96)) // first 32 bytes are data padding\r\n            traits := mload(add(signedMessage, 100))\r\n            recipientId := mload(add(signedMessage, 132))\r\n            r := mload(add(signedMessage, 164))\r\n            s := mload(add(signedMessage, 196))\r\n            vInByte := mload(add(signedMessage, 228))\r\n        }\r\n        require(to == address(this), \"This signed Message is not meant for this smart contract\");\r\n        v = uint8(vInByte);\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n\r\n        require(nft[tokenId].owner == address(0), \"This token has been redeemed already\");\r\n        bytes32 msgHash = createRedeemMessageHash(tokenId, nftType, traits, recipientId);\r\n        bytes32 preFixedMsgHash = keccak256(\r\n            abi.encodePacked(\r\n                prefix,\r\n                msgHash\r\n            ));\r\n\r\n        address signer = ecrecover(preFixedMsgHash, v, r, s);\r\n\r\n        require(signer == wetrustSigner, \"WeTrust did not authorized this redeem script\");\r\n        return mint(tokenId, msg.sender, recipientId, traits, nftType);\r\n    }\r\n\r\n    /**\r\n     * @dev Add a new reciepient of WeTrust Spring\r\n     * @param recipientId Unique identifier of receipient\r\n     * @param name of the Recipient\r\n     * @param url link to the recipient's website\r\n     * @param owner Address owned by the recipient\r\n     */\r\n    function addRecipient(bytes32 recipientId, string name, string url, address owner)\r\n        onlyByWeTrustSigner\r\n        onlyWhenNotPaused\r\n        recipientDoesNotExists(recipientId)\r\n        public\r\n    {\r\n        require(bytes(name).length > 0, \"name must not be empty string\"); // no empty string\r\n\r\n        recipients[recipientId].name = name;\r\n        recipients[recipientId].url = url;\r\n        recipients[recipientId].owner = owner;\r\n        recipients[recipientId].exists = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Add an link to the update the recipient had made\r\n     * @param recipientId The issuer of the update\r\n     * @param updateId unique id of the update\r\n     */\r\n    function addRecipientUpdate(bytes32 recipientId, bytes32 updateId)\r\n        onlyWhenNotPaused\r\n        recipientExists(recipientId)\r\n        onlyByWeTrustOrRecipient(recipientId)\r\n        public\r\n    {\r\n        recipientUpdates[recipientId].push(Update(updateId, now));\r\n        emit RecipientUpdate(recipientId, updateId);\r\n    }\r\n\r\n    /**\r\n     * @dev Change recipient information\r\n     * @param recipientId to change\r\n     * @param name new name of the recipient\r\n     * @param url new link of the recipient\r\n     * @param owner new address owned by the recipient\r\n     */\r\n    function updateRecipientInfo(bytes32 recipientId, string name, string url, address owner)\r\n        onlyByWeTrustSigner\r\n        onlyWhenNotPaused\r\n        recipientExists(recipientId)\r\n        public\r\n    {\r\n        require(bytes(name).length > 0, \"name must not be empty string\"); // no empty string\r\n\r\n        recipients[recipientId].name = name;\r\n        recipients[recipientId].url = url;\r\n        recipients[recipientId].owner = owner;\r\n    }\r\n\r\n    /**\r\n     * @dev add a artist signed message for a particular NFT\r\n     * @param nftId NFT to add the signature to\r\n     * @param artistSignature Artist Signed Message\r\n     */\r\n    function addArtistSignature(uint256 nftId, bytes artistSignature) onlyByWeTrustSigner onlyWhenNotPaused public {\r\n        require(nftArtistSignature[nftId].length == 0, \"Artist Signature already exist for this token\"); // make sure no prior signature exists\r\n\r\n        nftArtistSignature[nftId] = artistSignature;\r\n    }\r\n\r\n    /**\r\n     * @dev Set whether or not the contract is paused\r\n     * @param _paused status to put the contract in\r\n     */\r\n    function setPaused(bool _paused) onlyByWeTrustManager public {\r\n        paused = _paused;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer the WeTrust signer of NFT contract to a new address\r\n     * @param newAddress new WeTrust owned address\r\n     */\r\n    function changeWeTrustSigner(address newAddress) onlyWhenNotPaused onlyByWeTrustManager public {\r\n        wetrustSigner = newAddress;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the number of updates recipients had made\r\n     * @param recipientId receipientId to check\r\n     */\r\n    function getUpdateCount(bytes32 recipientId) view public returns(uint256 count) {\r\n        return recipientUpdates[recipientId].length;\r\n    }\r\n\r\n    /**\r\n     * @dev returns the message hash to be signed for redeem token\r\n     * @param tokenId id of the token to be created\r\n     * @param nftType Type of NFT to be created\r\n     * @param traits Traits of NFT to be created\r\n     * @param recipientId Issuer of the NFT\r\n     */\r\n    function createRedeemMessageHash(\r\n        uint256 tokenId,\r\n        bytes4 nftType,\r\n        bytes32 traits,\r\n        bytes32 recipientId)\r\n        view public returns(bytes32 msgHash)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                address(this),\r\n                tokenId,\r\n                nftType,\r\n                traits,\r\n                recipientId\r\n            ));\r\n    }\r\n\r\n    /**\r\n     * @dev Determines the edition of the NFT\r\n     *      formula used to determine edition Size given the edition Number:\r\n     *      f(x) = min(300x + 100, 5000)\r\n     * using equation: g(x) = 150x^2 - 50x + 1 if x <= 16\r\n     * else g(x) = 5000(x-16) - g(16)\r\n     * maxEdition = 5000\r\n     * @param nextNFTcount to determine edition for\r\n     */\r\n    function determineEdition(uint256 nextNFTcount) pure public returns (uint16 edition) {\r\n        uint256 output;\r\n        uint256 valueWhenXisSixteen = 37601; // g(16)\r\n        if (nextNFTcount < valueWhenXisSixteen) {\r\n            output = (sqrt(2500 + (600 * (nextNFTcount - 1))) + 50) / 300;\r\n        } else {\r\n            output = ((nextNFTcount - valueWhenXisSixteen) / 5000) + 16;\r\n        }\r\n\r\n        if (output > 5000) {\r\n            output = 5000;\r\n        }\r\n\r\n        edition = uint16(output); // we don't have to worry about casting because output will always be less than or equal to 5000\r\n    }\r\n\r\n    /**\r\n     * @dev set new host name for this nft contract\r\n     * @param newHostName new host name to use\r\n     */\r\n    function setNFTContractInfo(string newHostName, string newName, string newSymbol) onlyByWeTrustManager external {\r\n        hostname = newHostName;\r\n        nftName = newName;\r\n        nftSymbol = newSymbol;\r\n    }\r\n    //////////////////////////\r\n    // Private Functions\r\n    /////////////////////////\r\n\r\n    /**\r\n     * @dev Find the Square root of a number\r\n     * @param x input\r\n     * Credit goes to: https://ethereum.stackexchange.com/questions/2910/can-i-square-root-in-solidity\r\n     */\r\n\r\n    function sqrt(uint x) pure internal returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Add the new NFT to the storage\r\n     * @param receiver the owner of the new NFT\r\n     * @param recipientId The issuer of the NFT\r\n     * @param traits NFT Traits\r\n     * @param nftType Type of the NFT\r\n     */\r\n    function mint(uint256 tokenId, address receiver, bytes32 recipientId, bytes32 traits, bytes4 nftType)\r\n        recipientExists(recipientId)\r\n        internal\r\n    {\r\n        nft[tokenId].owner = receiver;\r\n        nft[tokenId].traits = traits;\r\n        nft[tokenId].recipientId = recipientId;\r\n        nft[tokenId].nftType = nftType;\r\n        nft[tokenId].createdAt = now;\r\n        nft[tokenId].edition = determineEdition(recipients[recipientId].nftCount + 1);\r\n\r\n        recipients[recipientId].nftCount++;\r\n        ownerToTokenList[receiver].push(tokenId);\r\n\r\n        nftList.push(tokenId);\r\n\r\n        emit Transfer(address(0), receiver, tokenId);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipientId\",\"type\":\"bytes32\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"updateRecipientInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nftArtistSignature\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wetrustSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recipientUpdates\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"createdAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paused\",\"type\":\"bool\"}],\"name\":\"setPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHostName\",\"type\":\"string\"},{\"name\":\"newName\",\"type\":\"string\"},{\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"setNFTContractInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"changeWeTrustSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nftId\",\"type\":\"uint256\"},{\"name\":\"artistSignature\",\"type\":\"bytes\"}],\"name\":\"addArtistSignature\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hostname\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nextNFTcount\",\"type\":\"uint256\"}],\"name\":\"determineEdition\",\"outputs\":[{\"name\":\"edition\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"getOwnedTokenList\",\"outputs\":[{\"name\":\"tokenList\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipientId\",\"type\":\"bytes32\"},{\"name\":\"updateId\",\"type\":\"bytes32\"}],\"name\":\"addRecipientUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"recipientId\",\"type\":\"bytes32\"},{\"name\":\"traits\",\"type\":\"bytes32\"},{\"name\":\"nftType\",\"type\":\"bytes4\"}],\"name\":\"createNFT\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipientId\",\"type\":\"bytes32\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"addRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"nftType\",\"type\":\"bytes4\"},{\"name\":\"traits\",\"type\":\"bytes32\"},{\"name\":\"recipientId\",\"type\":\"bytes32\"}],\"name\":\"createRedeemMessageHash\",\"outputs\":[{\"name\":\"msgHash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"nft\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"approval\",\"type\":\"address\"},{\"name\":\"traits\",\"type\":\"bytes32\"},{\"name\":\"edition\",\"type\":\"uint16\"},{\"name\":\"nftType\",\"type\":\"bytes4\"},{\"name\":\"recipientId\",\"type\":\"bytes32\"},{\"name\":\"createdAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wetrustManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"recipientId\",\"type\":\"bytes32\"}],\"name\":\"getUpdateCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"recipients\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"nftCount\",\"type\":\"uint256\"},{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signedMessage\",\"type\":\"bytes\"}],\"name\":\"redeemToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"signer\",\"type\":\"address\"},{\"name\":\"manager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipientId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"updateId\",\"type\":\"bytes32\"}],\"name\":\"RecipientUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"SpringNFT","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000073d2548a9e19cbeb4b361ba963ad4977e413787d0000000000000000000000000ed8c3d25849fe3fe918a8863a04e71036cbc501","Library":"","SwarmSource":"bzzr://514dedde700f631ebbb6f7b3851e82b40362df44bcf3bfcd0fa39e62f39ff67c"}]}