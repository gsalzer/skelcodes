{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// Contract setup ====================\r\ncontract Ownable {\r\n    address public owner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function Ownable() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract JCLYLong is Pausable  {\r\n    using SafeMath for *;\r\n\t\r\n    event KeyPurchase(address indexed purchaser, uint256 eth, uint256 amount);\r\n    event LeekStealOn();\r\n\r\n    address private constant WALLET_ETH_COM1   = 0x2509CF8921b95bef38DEb80fBc420Ef2bbc53ce3; \r\n    address private constant WALLET_ETH_COM2   = 0x18d9fc8e3b65124744553d642989e3ba9e41a95a; \r\n\r\n    // Configurables  ====================\r\n    uint256 constant private rndInit_ = 1 hours;      \r\n    uint256 constant private rndInc_ = 30 seconds;   \r\n    uint256 constant private rndMax_ = 24 hours;    \r\n\r\n    // eth limiter\r\n    uint256 constant private ethLimiterRange1_ = 1e20;\r\n    uint256 constant private ethLimiterRange2_ = 5e20;\r\n    uint256 constant private ethLimiter1_ = 2e18;\r\n    uint256 constant private ethLimiter2_ = 7e18;\r\n\r\n    // whitelist range\r\n    uint256 constant private whitelistRange_ = 3 days;\r\n\r\n    // for price \r\n    uint256 constant private priceStage1_ = 500e18;\r\n    uint256 constant private priceStage2_ = 1000e18;\r\n    uint256 constant private priceStage3_ = 2000e18;\r\n    uint256 constant private priceStage4_ = 4000e18;\r\n    uint256 constant private priceStage5_ = 8000e18;\r\n    uint256 constant private priceStage6_ = 16000e18;\r\n    uint256 constant private priceStage7_ = 32000e18;\r\n    uint256 constant private priceStage8_ = 64000e18;\r\n    uint256 constant private priceStage9_ = 128000e18;\r\n    uint256 constant private priceStage10_ = 256000e18;\r\n    uint256 constant private priceStage11_ = 512000e18;\r\n    uint256 constant private priceStage12_ = 1024000e18;\r\n\r\n    // for gu phrase\r\n    uint256 constant private guPhrase1_ = 5 days;\r\n    uint256 constant private guPhrase2_ = 7 days;\r\n    uint256 constant private guPhrase3_ = 9 days;\r\n    uint256 constant private guPhrase4_ = 11 days;\r\n    uint256 constant private guPhrase5_ = 13 days;\r\n    uint256 constant private guPhrase6_ = 15 days;\r\n    uint256 constant private guPhrase7_ = 17 days;\r\n    uint256 constant private guPhrase8_ = 19 days;\r\n    uint256 constant private guPhrase9_ = 21 days;\r\n    uint256 constant private guPhrase10_ = 23 days;\r\n\r\n\r\n// Data setup ====================\r\n    uint256 public contractStartDate_;    // contract creation time\r\n    uint256 public allMaskGu_; // for sharing eth-profit by holding gu\r\n    uint256 public allGuGiven_; // for sharing eth-profit by holding gu\r\n    mapping (uint256 => uint256) public playOrders_; // playCounter => pID\r\n// AIRDROP DATA \r\n    uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot\r\n    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop\r\n// LEEKSTEAL DATA \r\n    uint256 public leekStealPot_;             // person who gets the first leeksteal wins part of this pot\r\n    uint256 public leekStealTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning leek steal\r\n    uint256 public leekStealToday_;\r\n    bool public leekStealOn_;\r\n    mapping (uint256 => uint256) public dayStealTime_; // dayNum => time that makes leekSteal available\r\n// PLAYER DATA \r\n    uint256 public pID_;        // total number of players\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    // mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping (uint256 => Datasets.Player) public plyr_;   // (pID => data) player data\r\n    mapping (uint256 => mapping (uint256 => Datasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id\r\n    mapping (uint256 => mapping (uint256 => Datasets.PlayerPhrases)) public plyrPhas_;    // (pID => phraseID => data) player round data by player id & round id\r\n// ROUND DATA \r\n    uint256 public rID_;    // round id number / total rounds that have happened\r\n    mapping (uint256 => Datasets.Round) public round_;   // (rID => data) round data\r\n// PHRASE DATA \r\n    uint256 public phID_; // gu phrase ID\r\n    mapping (uint256 => Datasets.Phrase) public phrase_;   // (phID_ => data) round data\r\n// WHITELIST\r\n    mapping(address => bool) public whitelisted_Prebuy; // pID => isWhitelisted\r\n\r\n// Constructor ====================\r\n    constructor()\r\n        public\r\n    {\r\n        // set genesis player\r\n        pIDxAddr_[WALLET_ETH_COM1] = 1; \r\n        plyr_[1].addr = WALLET_ETH_COM1; \r\n        pIDxAddr_[WALLET_ETH_COM2] = 2; \r\n        plyr_[2].addr = WALLET_ETH_COM2; \r\n        pID_ = 2;\r\n    }\r\n\r\n// Modifiers ====================\r\n\r\n    modifier isActivated() {\r\n        require(activated_ == true); \r\n        _;\r\n    }\r\n    \r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;    \r\n    }\r\n    \r\n// Public functions ====================\r\n    /**\r\n     * @dev emergency buy uses last stored affiliate ID\r\n     */\r\n    function()\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // determine if player is new or not\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        if (_pID == 0)\r\n        {\r\n            pID_++; // grab their player ID and last aff ID, from player names contract \r\n            pIDxAddr_[msg.sender] = pID_; // set up player account \r\n            plyr_[pID_].addr = msg.sender; // set up player account \r\n            _pID = pID_;\r\n        } \r\n        \r\n        // buy core \r\n        buyCore(_pID, plyr_[_pID].laff);\r\n    }\r\n \r\n    function buyXid(uint256 _affID)\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        // determine if player is new or not\r\n        uint256 _pID = pIDxAddr_[msg.sender]; // fetch player id\r\n        if (_pID == 0)\r\n        {\r\n            pID_++; // grab their player ID and last aff ID, from player names contract \r\n            pIDxAddr_[msg.sender] = pID_; // set up player account \r\n            plyr_[pID_].addr = msg.sender; // set up player account \r\n            _pID = pID_;\r\n        } \r\n        \r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own\r\n        if (_affID == 0 || _affID == _pID || _affID > pID_)\r\n        {\r\n            _affID = plyr_[_pID].laff; // use last stored affiliate code \r\n\r\n        // if affiliate code was given & its not the same as previously stored \r\n        } \r\n        else if (_affID != plyr_[_pID].laff) \r\n        {\r\n            if (plyr_[_pID].laff == 0)\r\n                plyr_[_pID].laff = _affID; // update last affiliate \r\n            else \r\n                _affID = plyr_[_pID].laff;\r\n        } \r\n\r\n        // buy core \r\n        buyCore(_pID, _affID);\r\n    }\r\n\r\n    function reLoadXid()\r\n        isActivated()\r\n        isHuman()\r\n        public\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender]; // fetch player ID\r\n        require(_pID > 0);\r\n\r\n        reLoadCore(_pID, plyr_[_pID].laff);\r\n    }\r\n\r\n    function reLoadCore(uint256 _pID, uint256 _affID)\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        // whitelist checking\r\n        if (_now < round_[rID_].strt + whitelistRange_) {\r\n            require(whitelisted_Prebuy[plyr_[_pID].addr] || whitelisted_Prebuy[plyr_[_affID].addr]);\r\n        }\r\n        \r\n        // if round is active\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) \r\n        {\r\n            uint256 _eth = withdrawEarnings(_pID, false);\r\n            plyr_[_pID].gen = 0;\r\n            \r\n            // call core \r\n            core(_rID, _pID, _eth, _affID);\r\n        \r\n        // if round is not active and end round needs to be ran   \r\n        } else if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n            // end the round (distributes pot) & start new round\r\n            round_[_rID].ended = true;\r\n            endRound();\r\n        }\r\n    }\r\n    \r\n    function withdraw()\r\n        isActivated()\r\n        isHuman()\r\n        public\r\n    {\r\n        // setup local rID \r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // fetch player ID\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        \r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n        \r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {   \r\n            // end the round (distributes pot)\r\n\t\t\tround_[_rID].ended = true;\r\n            endRound();\r\n            \r\n\t\t\t// get their earnings\r\n            _eth = withdrawEarnings(_pID, true);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);    \r\n            \r\n            \r\n        // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID, true);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n        }\r\n    }\r\n\r\n    function updateWhitelist(address[] _addrs, bool _isWhitelisted)\r\n        public\r\n        onlyOwner\r\n    {\r\n        for (uint i = 0; i < _addrs.length; i++) {\r\n            whitelisted_Prebuy[_addrs[i]] = _isWhitelisted;\r\n\r\n            // determine if player is new or not\r\n            uint256 _pID = pIDxAddr_[msg.sender];\r\n            if (_pID == 0)\r\n            {\r\n                pID_++; \r\n                pIDxAddr_[_addrs[i]] = pID_;\r\n                plyr_[pID_].addr = _addrs[i];\r\n            } \r\n        }\r\n    }\r\n\r\n    function safeDrain() \r\n        public\r\n        onlyOwner\r\n    {\r\n        owner.transfer(this.balance);\r\n    }\r\n    \r\n\r\n// Getters ====================\r\n    \r\n    function getPrice()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {   \r\n        uint256 keys = keysRec(round_[rID_].eth, 1e18);\r\n        return (1e36 / keys);\r\n    }\r\n    \r\n    function getTimeLeft()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        if (_now < round_[_rID].end)\r\n            if (_now > round_[_rID].strt)\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                return( (round_[_rID].strt).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n    \r\n    function getPlayerVaults(uint256 _pID)\r\n        public\r\n        view\r\n        returns(uint256 ,uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // if round has ended.  but round end has not been run (so contract has not distributed winnings)\r\n        if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0)\r\n        {\r\n            // if player is winner \r\n            if (round_[_rID].plyr == _pID)\r\n            {\r\n                return\r\n                (\r\n                    (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\r\n                    (plyr_[_pID].gen).add(calcUnMaskedKeyEarnings(_pID, plyr_[_pID].lrnd)),\r\n                    (plyr_[_pID].genGu).add(calcUnMaskedGuEarnings(_pID)),\r\n                    plyr_[_pID].aff,\r\n                    plyr_[_pID].refund\r\n                );\r\n            // if player is not the winner\r\n            } else {\r\n                return\r\n                (\r\n                    plyr_[_pID].win,\r\n                    (plyr_[_pID].gen).add(calcUnMaskedKeyEarnings(_pID, plyr_[_pID].lrnd)),\r\n                    (plyr_[_pID].genGu).add(calcUnMaskedGuEarnings(_pID)),\r\n                    plyr_[_pID].aff,\r\n                    plyr_[_pID].refund\r\n                );\r\n            }\r\n            \r\n        // if round is still going on, or round has ended and round end has been ran\r\n        } else {\r\n            return\r\n            (\r\n                plyr_[_pID].win,\r\n                (plyr_[_pID].gen).add(calcUnMaskedKeyEarnings(_pID, plyr_[_pID].lrnd)),\r\n                (plyr_[_pID].genGu).add(calcUnMaskedGuEarnings(_pID)),\r\n                plyr_[_pID].aff,\r\n                plyr_[_pID].refund\r\n            );\r\n        }\r\n    }\r\n    \r\n    function getCurrentRoundInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, uint256, uint256)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        return\r\n        (\r\n            _rID,                           //0\r\n            round_[_rID].allkeys,           //1\r\n            round_[_rID].keys,              //2\r\n            allGuGiven_,                    //3\r\n            round_[_rID].end,               //4\r\n            round_[_rID].strt,              //5\r\n            round_[_rID].pot,               //6\r\n            plyr_[round_[_rID].plyr].addr,  //7\r\n            round_[_rID].eth,               //8\r\n            airDropTracker_ + (airDropPot_ * 1000)   //9\r\n        );\r\n    }\r\n\r\n    function getCurrentPhraseInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local phID\r\n        uint256 _phID = phID_;\r\n        \r\n        return\r\n        (\r\n            _phID,                            //0\r\n            phrase_[_phID].eth,               //1\r\n            phrase_[_phID].guGiven,           //2\r\n            phrase_[_phID].minEthRequired,    //3\r\n            phrase_[_phID].guPoolAllocation   //4\r\n        );\r\n    }\r\n\r\n    function getPlayerInfoByAddress(address _addr)\r\n        public \r\n        view \r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        // setup local rID, phID\r\n        uint256 _rID = rID_;\r\n        uint256 _phID = phID_;\r\n        \r\n        if (_addr == address(0))\r\n        {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        return\r\n        (\r\n            _pID,      // 0\r\n            plyrRnds_[_pID][_rID].keys,         //1\r\n            plyr_[_pID].gu,                     //2\r\n            plyr_[_pID].laff,                    //3\r\n            (plyr_[_pID].gen).add(calcUnMaskedKeyEarnings(_pID, plyr_[_pID].lrnd)).add(plyr_[_pID].genGu).add(calcUnMaskedGuEarnings(_pID)), //4\r\n            plyr_[_pID].aff,                    //5\r\n            plyrRnds_[_pID][_rID].eth,           //6      totalIn for the round\r\n            plyrPhas_[_pID][_phID].eth,          //7      curr phrase referral eth\r\n            plyr_[_pID].referEth,               // 8      total referral eth\r\n            plyr_[_pID].withdraw                // 9      totalOut\r\n        );\r\n    }\r\n\r\n    function buyCore(uint256 _pID, uint256 _affID)\r\n        whenNotPaused\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab time\r\n        uint256 _now = now;\r\n\r\n        // whitelist checking\r\n        if (_now < round_[rID_].strt + whitelistRange_) {\r\n            require(whitelisted_Prebuy[plyr_[_pID].addr] || whitelisted_Prebuy[plyr_[_affID].addr]);\r\n        }\r\n        \r\n        // if round is active\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) \r\n        {\r\n            // call core \r\n            core(_rID, _pID, msg.value, _affID);\r\n        \r\n        // if round is not active     \r\n        } else {\r\n            // check to see if end round needs to be ran\r\n            if (_now > round_[_rID].end && round_[_rID].ended == false) \r\n            {\r\n                // end the round (distributes pot) & start new round\r\n\t\t\t    round_[_rID].ended = true;\r\n                endRound();\r\n            }\r\n            \r\n            // put eth in players vault \r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n    \r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID)\r\n        private\r\n    {\r\n        // if player is new to current round\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n        {\r\n            // if player has played a previous round, move their unmasked earnings\r\n            // from that round to gen vault.\r\n            if (plyr_[_pID].lrnd != 0)\r\n                updateGenVault(_pID, plyr_[_pID].lrnd);\r\n            \r\n            plyr_[_pID].lrnd = rID_; // update player's last round played\r\n        }\r\n        \r\n        // early round eth limiter (0-100 eth)\r\n        uint256 _availableLimit;\r\n        uint256 _refund;\r\n        if (round_[_rID].eth < ethLimiterRange1_ && plyrRnds_[_pID][_rID].eth.add(_eth) > ethLimiter1_)\r\n        {\r\n            _availableLimit = (ethLimiter1_).sub(plyrRnds_[_pID][_rID].eth);\r\n            _refund = _eth.sub(_availableLimit);\r\n            plyr_[_pID].refund = plyr_[_pID].refund.add(_refund);\r\n            _eth = _availableLimit;\r\n        } else if (round_[_rID].eth < ethLimiterRange2_ && plyrRnds_[_pID][_rID].eth.add(_eth) > ethLimiter2_)\r\n        {\r\n            _availableLimit = (ethLimiter2_).sub(plyrRnds_[_pID][_rID].eth);\r\n            _refund = _eth.sub(_availableLimit);\r\n            plyr_[_pID].refund = plyr_[_pID].refund.add(_refund);\r\n            _eth = _availableLimit;\r\n        }\r\n        \r\n        // if eth left is greater than min eth allowed (sorry no pocket lint)\r\n        if (_eth > 1e9) \r\n        {\r\n            // mint the new keys\r\n            uint256 _keys = keysRec(round_[_rID].eth, _eth);\r\n            \r\n            // if they bought at least 1 whole key\r\n            if (_keys >= 1e18)\r\n            {\r\n                updateTimer(_keys, _rID);\r\n\r\n                // set new leaders\r\n                if (round_[_rID].plyr != _pID)\r\n                    round_[_rID].plyr = _pID;\r\n\r\n                emit KeyPurchase(plyr_[round_[_rID].plyr].addr, _eth, _keys);\r\n            }\r\n            \r\n            // manage airdrops\r\n            if (_eth >= 1e17)\r\n            {\r\n                airDropTracker_++;\r\n                if (airdrop() == true)\r\n                {\r\n                    // gib muni\r\n                    uint256 _prize;\r\n                    if (_eth >= 1e19)\r\n                    {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(75)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                        \r\n                        // let event know a tier 3 prize was won \r\n                    } else if (_eth >= 1e18 && _eth < 1e19) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(50)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                        \r\n                        // let event know a tier 2 prize was won \r\n                    } else if (_eth >= 1e17 && _eth < 1e18) {\r\n                        // calculate prize and give it to winner\r\n                        _prize = ((airDropPot_).mul(25)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        \r\n                        // adjust airDropPot \r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n                        \r\n                        // let event know a tier 3 prize was won \r\n                    }\r\n\r\n                    // reset air drop tracker\r\n                    airDropTracker_ = 0;\r\n                }\r\n            }   \r\n            \r\n            leekStealGo();\r\n\r\n            // update player \r\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n            round_[_rID].playCtr++;\r\n            playOrders_[round_[_rID].playCtr] = pID_; // for recording the 500 winners\r\n            \r\n            // update round\r\n            round_[_rID].allkeys = _keys.add(round_[_rID].allkeys);\r\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n    \r\n            // distribute eth\r\n            distributeExternal(_rID, _pID, _eth, _affID);\r\n            distributeInternal(_rID, _pID, _eth, _keys);\r\n\r\n            // manage gu-referral\r\n            updateGuReferral(_pID, _affID, _eth);\r\n\r\n            checkDoubledProfit(_pID, _rID);\r\n            checkDoubledProfit(_affID, _rID);\r\n        }\r\n    }\r\n\r\n    function checkDoubledProfit(uint256 _pID, uint256 _rID)\r\n        private\r\n    {   \r\n        // if pID has no keys, skip this\r\n        uint256 _keys = plyrRnds_[_pID][_rID].keys;\r\n        if (_keys > 0) {\r\n\r\n            // zero out keys if the accumulated profit doubled\r\n            uint256 _balance = (plyr_[_pID].gen).add(calcUnMaskedKeyEarnings(_pID, plyr_[_pID].lrnd));\r\n            if (_balance.add(plyrRnds_[_pID][_rID].genWithdraw) >= (plyrRnds_[_pID][_rID].eth))\r\n            {\r\n                updateGenVault(_pID, plyr_[_pID].lrnd);\r\n\r\n                round_[_rID].keys = round_[_rID].keys.sub(_keys);\r\n                plyrRnds_[_pID][_rID].keys = plyrRnds_[_pID][_rID].keys.sub(_keys);\r\n            }   \r\n        }\r\n    }\r\n\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 _startEth;\r\n        uint256 _incrRate;\r\n        uint256 _initPrice;\r\n\r\n        if (_curEth < priceStage1_) {\r\n            _startEth = 0;\r\n            _initPrice = 33333; //3e-5;\r\n            _incrRate = 50000000; //2e-8;\r\n        }\r\n        else if (_curEth < priceStage2_) {\r\n            _startEth = priceStage1_;\r\n            _initPrice =  25000; // 4e-5;\r\n            _incrRate = 50000000; //2e-8;\r\n        }\r\n        else if (_curEth < priceStage3_) {\r\n            _startEth = priceStage2_;\r\n            _initPrice = 20000; //5e-5;\r\n            _incrRate = 50000000; //2e-8;;\r\n        }\r\n        else if (_curEth < priceStage4_) {\r\n            _startEth = priceStage3_;\r\n            _initPrice = 12500; //8e-5;\r\n            _incrRate = 26666666; //3.75e-8;\r\n        }\r\n        else if (_curEth < priceStage5_) {\r\n            _startEth = priceStage4_;\r\n            _initPrice = 5000; //2e-4;\r\n            _incrRate = 17777777; //5.625e-8;\r\n        }\r\n        else if (_curEth < priceStage6_) {\r\n            _startEth = priceStage5_;\r\n            _initPrice = 2500; // 4e-4;\r\n            _incrRate = 10666666; //9.375e-8;\r\n        }\r\n        else if (_curEth < priceStage7_) {\r\n            _startEth = priceStage6_;\r\n            _initPrice = 1000; //0.001;\r\n            _incrRate = 5688282; //1.758e-7;\r\n        }\r\n        else if (_curEth < priceStage8_) {\r\n            _startEth = priceStage7_;\r\n            _initPrice = 250; //0.004;\r\n            _incrRate = 2709292; //3.691e-7;\r\n        }\r\n        else if (_curEth < priceStage9_) {\r\n            _startEth = priceStage8_;\r\n            _initPrice = 62; //0.016;\r\n            _incrRate = 1161035; //8.613e-7;\r\n        }\r\n        else if (_curEth < priceStage10_) {\r\n            _startEth = priceStage9_;\r\n            _initPrice = 14; //0.071;\r\n            _incrRate = 451467; //2.215e-6;\r\n        }\r\n        else if (_curEth < priceStage11_) {\r\n            _startEth = priceStage10_;\r\n            _initPrice = 2; //0.354;\r\n            _incrRate = 144487; //6.921e-6;\r\n        }\r\n        else if (_curEth < priceStage12_) {\r\n            _startEth = priceStage11_;\r\n            _initPrice = 0; //2.126;\r\n            _incrRate = 40128; //2.492e-5;\r\n        }\r\n        else {\r\n            _startEth = priceStage12_;\r\n            _initPrice = 0;\r\n            _incrRate = 40128; //2.492e-5;\r\n        }\r\n\r\n        return _newEth.mul(((_incrRate.mul(_initPrice)) / (_incrRate.add(_initPrice.mul((_curEth.sub(_startEth))/1e18)))));\r\n    }\r\n\r\n    function updateGuReferral(uint256 _pID, uint256 _affID, uint256 _eth) private {\r\n        uint256 _newPhID = updateGuPhrase();\r\n\r\n        // update phrase, and distribute remaining gu for the last phrase\r\n        if (phID_ < _newPhID) {\r\n            updateReferralMasks(phID_);\r\n            plyr_[1].gu = (phrase_[_newPhID].guPoolAllocation / 10).add(plyr_[1].gu); // give 20% gu to community first, at the beginning of the phrase start\r\n            plyr_[2].gu = (phrase_[_newPhID].guPoolAllocation / 10).add(plyr_[2].gu); // give 20% gu to community first, at the beginning of the phrase start\r\n            phrase_[_newPhID].guGiven = (phrase_[_newPhID].guPoolAllocation / 5).add(phrase_[_newPhID].guGiven);\r\n            allGuGiven_ = (phrase_[_newPhID].guPoolAllocation / 5).add(allGuGiven_);\r\n            phID_ = _newPhID; // update the phrase ID\r\n        }\r\n\r\n        // update referral eth on affiliate\r\n        if (_affID != 0 && _affID != _pID) {\r\n            plyrPhas_[_affID][_newPhID].eth = _eth.add(plyrPhas_[_affID][_newPhID].eth);\r\n            plyr_[_affID].referEth = _eth.add(plyr_[_affID].referEth);\r\n            phrase_[_newPhID].eth = _eth.add(phrase_[_newPhID].eth);\r\n        }\r\n            \r\n        uint256 _remainGuReward = phrase_[_newPhID].guPoolAllocation.sub(phrase_[_newPhID].guGiven);\r\n        // if 1) one has referral amt larger than requirement, 2) has remaining => then distribute certain amt of Gu, i.e. update gu instead of adding gu\r\n        if (plyrPhas_[_affID][_newPhID].eth >= phrase_[_newPhID].minEthRequired && _remainGuReward >= 1e18) {\r\n            // check if need to reward more gu\r\n            uint256 _totalReward = plyrPhas_[_affID][_newPhID].eth / phrase_[_newPhID].minEthRequired;\r\n            _totalReward = _totalReward.mul(1e18);\r\n            uint256 _rewarded = plyrPhas_[_affID][_newPhID].guRewarded;\r\n            uint256 _toReward = _totalReward.sub(_rewarded);\r\n            if (_remainGuReward < _toReward) _toReward =  _remainGuReward;\r\n\r\n            // give out gu reward\r\n            if (_toReward > 0) {\r\n                plyr_[_affID].gu = _toReward.add(plyr_[_affID].gu); // give gu to player\r\n                plyrPhas_[_affID][_newPhID].guRewarded = _toReward.add(plyrPhas_[_affID][_newPhID].guRewarded);\r\n                phrase_[_newPhID].guGiven = 1e18.add(phrase_[_newPhID].guGiven);\r\n                allGuGiven_ = 1e18.add(allGuGiven_);\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateReferralMasks(uint256 _phID) private {\r\n        uint256 _remainGu = phrase_[phID_].guPoolAllocation.sub(phrase_[phID_].guGiven);\r\n        if (_remainGu > 0 && phrase_[_phID].eth > 0) {\r\n            // remaining gu per total ethIn in the phrase\r\n            uint256 _gpe = (_remainGu.mul(1e18)) / phrase_[_phID].eth;\r\n            phrase_[_phID].mask = _gpe.add(phrase_[_phID].mask); // should only added once\r\n        }\r\n    }\r\n\r\n    function transferGu(address _to, uint256 _guAmt) \r\n        public\r\n        whenNotPaused\r\n        returns (bool) \r\n    {\r\n        uint256 _pIDFrom = pIDxAddr_[msg.sender];\r\n\r\n        // check if the sender (_pIDFrom) is not found or admin player\r\n        require(plyr_[_pIDFrom].addr == msg.sender);\r\n\r\n        uint256 _pIDTo = pIDxAddr_[_to];\r\n\r\n        plyr_[_pIDFrom].gu = plyr_[_pIDFrom].gu.sub(_guAmt);\r\n        plyr_[_pIDTo].gu = plyr_[_pIDTo].gu.add(_guAmt);\r\n        return true;\r\n    }\r\n    \r\n    function updateGuPhrase() \r\n        private\r\n        returns (uint256) // return phraseNum\r\n    {\r\n        if (now <= contractStartDate_ + guPhrase1_) {\r\n            phrase_[1].minEthRequired = 5e18;\r\n            phrase_[1].guPoolAllocation = 100e18;\r\n            return 1; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase2_) {\r\n            phrase_[2].minEthRequired = 4e18;\r\n            phrase_[2].guPoolAllocation = 200e18;\r\n            return 2; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase3_) {\r\n            phrase_[3].minEthRequired = 3e18;\r\n            phrase_[3].guPoolAllocation = 400e18;\r\n            return 3; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase4_) {\r\n            phrase_[4].minEthRequired = 2e18;\r\n            phrase_[4].guPoolAllocation = 800e18;\r\n            return 4; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase5_) {\r\n            phrase_[5].minEthRequired = 1e18;\r\n            phrase_[5].guPoolAllocation = 1600e18;\r\n            return 5; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase6_) {\r\n            phrase_[6].minEthRequired = 1e18;\r\n            phrase_[6].guPoolAllocation = 3200e18;\r\n            return 6; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase7_) {\r\n            phrase_[7].minEthRequired = 1e18;\r\n            phrase_[7].guPoolAllocation = 6400e18;\r\n            return 7; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase8_) {\r\n            phrase_[8].minEthRequired = 1e18;\r\n            phrase_[8].guPoolAllocation = 12800e18;\r\n            return 8; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase9_) {\r\n            phrase_[9].minEthRequired = 1e18;\r\n            phrase_[9].guPoolAllocation = 25600e18;\r\n            return 9; \r\n        }\r\n        if (now <= contractStartDate_ + guPhrase10_) {\r\n            phrase_[10].minEthRequired = 1e18;\r\n            phrase_[10].guPoolAllocation = 51200e18;\r\n            return 10; \r\n        }\r\n        phrase_[11].minEthRequired = 0;\r\n        phrase_[11].guPoolAllocation = 0;\r\n        return 11;\r\n    }\r\n\r\n    function leekStealGo() private {\r\n        // get a number for today dayNum \r\n        uint leekStealToday_ = (now.sub(round_[rID_].strt) / 1 days); \r\n        if (dayStealTime_[leekStealToday_] == 0) // if there hasn't a winner today, proceed\r\n        {\r\n            leekStealTracker_++;\r\n            if (randomNum(leekStealTracker_) == true)\r\n            {\r\n                dayStealTime_[leekStealToday_] = now;\r\n                leekStealOn_ = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function stealTheLeek() public {\r\n        if (leekStealOn_)\r\n        {   \r\n            if (now.sub(dayStealTime_[leekStealToday_]) > 300) // if time passed 5min, turn off and exit\r\n            {\r\n                leekStealOn_ = false;\r\n            } else {   \r\n                // if yes then assign the 1eth, if the pool has 1eth\r\n                if (leekStealPot_ > 1e18) {\r\n                    uint256 _pID = pIDxAddr_[msg.sender]; // fetch player ID\r\n                    plyr_[_pID].win = plyr_[_pID].win.add(1e18);\r\n                    leekStealPot_ = leekStealPot_.sub(1e18);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function calcUnMaskedKeyEarnings(uint256 _pID, uint256 _rIDlast)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (    (((round_[_rIDlast].maskKey).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1e18))  >    (plyrRnds_[_pID][_rIDlast].maskKey)       )\r\n            return(  (((round_[_rIDlast].maskKey).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1e18)).sub(plyrRnds_[_pID][_rIDlast].maskKey)  );\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function calcUnMaskedGuEarnings(uint256 _pID)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if (    ((allMaskGu_.mul(plyr_[_pID].gu)) / (1e18))  >    (plyr_[_pID].maskGu)      )\r\n            return(  ((allMaskGu_.mul(plyr_[_pID].gu)) / (1e18)).sub(plyr_[_pID].maskGu)   );\r\n        else\r\n            return 0;\r\n    }\r\n    \r\n    function endRound()\r\n        private\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab our winning player id\r\n        uint256 _winPID = round_[_rID].plyr;\r\n        \r\n        // grab our pot amount\r\n        uint256 _pot = round_[_rID].pot;\r\n        \r\n        // calculate our winner share, community rewards, gen share, \r\n        // jcg share, and amount reserved for next pot \r\n        uint256 _win = (_pot.mul(40)) / 100;\r\n        uint256 _res = (_pot.mul(10)) / 100;\r\n\r\n        \r\n        // pay our winner\r\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\r\n\r\n        // pay the rest of the 500 winners\r\n        pay500Winners(_pot);\r\n        \r\n        // start next round\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndInit_);\r\n        round_[_rID].pot = _res;\r\n    }\r\n\r\n    function pay500Winners(uint256 _pot) private {\r\n        uint256 _rID = rID_;\r\n        uint256 _plyCtr = round_[_rID].playCtr;\r\n\r\n        // pay the 2-10th\r\n        uint256 _win2 = _pot.mul(25).div(100).div(9);\r\n        for (uint256 i = _plyCtr.sub(9); i <= _plyCtr.sub(1); i++) {\r\n            plyr_[playOrders_[i]].win = _win2.add(plyr_[playOrders_[i]].win);\r\n        }\r\n\r\n        // pay the 11-100th\r\n        uint256 _win3 = _pot.mul(15).div(100).div(90);\r\n        for (uint256 j = _plyCtr.sub(99); j <= _plyCtr.sub(10); j++) {\r\n            plyr_[playOrders_[j]].win = _win3.add(plyr_[playOrders_[j]].win);\r\n        }\r\n\r\n        // pay the 101-500th\r\n        uint256 _win4 = _pot.mul(10).div(100).div(400);\r\n        for (uint256 k = _plyCtr.sub(499); k <= _plyCtr.sub(100); k++) {\r\n            plyr_[playOrders_[k]].win = _win4.add(plyr_[playOrders_[k]].win);\r\n        }\r\n    }\r\n    \r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast)\r\n        private \r\n    {\r\n        uint256 _earnings = calcUnMaskedKeyEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in gen vault\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            plyrRnds_[_pID][_rIDlast].maskKey = _earnings.add(plyrRnds_[_pID][_rIDlast].maskKey);\r\n        }\r\n    }\r\n\r\n    function updateGenGuVault(uint256 _pID)\r\n        private \r\n    {\r\n        uint256 _earnings = calcUnMaskedGuEarnings(_pID);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in genGu vault\r\n            plyr_[_pID].genGu = _earnings.add(plyr_[_pID].genGu);\r\n            // zero out their earnings by updating mask\r\n            plyr_[_pID].maskGu = _earnings.add(plyr_[_pID].maskGu);\r\n        }\r\n    }\r\n\r\n    function updateReferralGu(uint256 _pID)\r\n        private \r\n    {\r\n        // get current phID\r\n        uint256 _phID = phID_;\r\n\r\n        // get last claimed phID till\r\n        uint256 _lastClaimedPhID = plyr_[_pID].lastClaimedPhID;\r\n\r\n        // calculate the gu Shares using these two input\r\n        uint256 _guShares;\r\n        for (uint i = (_lastClaimedPhID + 1); i < _phID; i++) {\r\n            _guShares = (((phrase_[i].mask).mul(plyrPhas_[_pID][i].eth))/1e18).add(_guShares);\r\n           \r\n            // update record\r\n            plyr_[_pID].lastClaimedPhID = i;\r\n            phrase_[i].guGiven = _guShares.add(phrase_[i].guGiven);\r\n            plyrPhas_[_pID][i].guRewarded = _guShares.add(plyrPhas_[_pID][i].guRewarded);\r\n        }\r\n\r\n        // put gu in player\r\n        plyr_[_pID].gu = _guShares.add(plyr_[_pID].gu);\r\n\r\n        // zero out their earnings by updating mask\r\n        plyr_[_pID].maskGu = ((allMaskGu_.mul(_guShares)) / 1e18).add(plyr_[_pID].maskGu);\r\n\r\n        allGuGiven_ = _guShares.add(allGuGiven_);\r\n    }\r\n    \r\n    function updateTimer(uint256 _keys, uint256 _rID)\r\n        private\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // calculate time based on number of keys bought\r\n        uint256 _newTime;\r\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\r\n        \r\n        // compare to max and set new end time\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n    \r\n    function airdrop()\r\n        private \r\n        view \r\n        returns(bool)\r\n    {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            \r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n\r\n    function randomNum(uint256 _tracker)\r\n        private \r\n        view \r\n        returns(bool)\r\n    {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            \r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < _tracker)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n\r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID)\r\n        private\r\n    {\r\n        // pay 2% out to community rewards\r\n        uint256 _com = _eth / 100;\r\n        address(WALLET_ETH_COM1).transfer(_com); // 1%\r\n        address(WALLET_ETH_COM2).transfer(_com); // 1%\r\n        \r\n        // distribute 10% share to affiliate (8% + 2%)\r\n        uint256 _aff = _eth / 10;\r\n        \r\n        // check: affiliate must not be self, and must have an ID\r\n        if (_affID != _pID && _affID != 0) {\r\n            plyr_[_affID].aff = (_aff.mul(8)/10).add(plyr_[_affID].aff); // distribute 8% to 1st aff\r\n\r\n            uint256 _affID2 =  plyr_[_affID].laff; // get 2nd aff\r\n            if (_affID2 != _pID && _affID2 != 0) {\r\n                plyr_[_affID2].aff = (_aff.mul(2)/10).add(plyr_[_affID2].aff); // distribute 2% to 2nd aff\r\n            }\r\n        } else {\r\n            plyr_[1].aff = _aff.add(plyr_[_affID].aff);\r\n        }\r\n    }\r\n    \r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _keys)\r\n        private\r\n    {\r\n        // calculate gen share\r\n        uint256 _gen = (_eth.mul(40)) / 100; // 40%\r\n\r\n        // calculate jcg share\r\n        uint256 _jcg = (_eth.mul(20)) / 100; // 20%\r\n        \r\n        // toss 3% into airdrop pot \r\n        uint256 _air = (_eth.mul(3)) / 100;\r\n        airDropPot_ = airDropPot_.add(_air);\r\n\r\n        // toss 5% into leeksteal pot \r\n        uint256 _steal = (_eth / 20);\r\n        leekStealPot_ = leekStealPot_.add(_steal);\r\n        \r\n        // update eth balance (eth = eth - (2% com share + 3% airdrop + 5% leekSteal + 10% aff share))\r\n        _eth = _eth.sub(((_eth.mul(20)) / 100)); \r\n        \r\n        // calculate pot \r\n        uint256 _pot = _eth.sub(_gen).sub(_jcg);\r\n        \r\n        // distribute gen n jcg share (thats what updateMasks() does) and adjust\r\n        // balances for dust.\r\n        uint256 _dustKey = updateKeyMasks(_rID, _pID, _gen, _keys);\r\n        uint256 _dustGu = updateGuMasks(_pID, _jcg);\r\n        \r\n        // add eth to pot\r\n        round_[_rID].pot = _pot.add(_dustKey).add(_dustGu).add(round_[_rID].pot);\r\n    }\r\n\r\n    function updateKeyMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n        uint256 _ppt = (_gen.mul(1e18)) / (round_[_rID].keys);\r\n        round_[_rID].maskKey = _ppt.add(round_[_rID].maskKey);\r\n            \r\n        // calculate player earning from their own buy (only based on the keys\r\n        // they just bought).  & update player earnings mask\r\n        uint256 _pearn = (_ppt.mul(_keys)) / (1e18);\r\n        plyrRnds_[_pID][_rID].maskKey = (((round_[_rID].maskKey.mul(_keys)) / (1e18)).sub(_pearn)).add(plyrRnds_[_pID][_rID].maskKey);\r\n        \r\n        // calculate & return dust\r\n        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1e18)));\r\n    }\r\n\r\n    function updateGuMasks(uint256 _pID, uint256 _jcg)\r\n        private\r\n        returns(uint256)\r\n    {   \r\n        if (allGuGiven_ > 0) {\r\n            // calc profit per gu & round mask based on this buy:  (dust goes to pot)\r\n            uint256 _ppg = (_jcg.mul(1e18)) / allGuGiven_;\r\n            allMaskGu_ = _ppg.add(allMaskGu_);\r\n\r\n            // calculate player earning from their own buy\r\n            // & update player earnings mask\r\n            uint256 _pearn = (_ppg.mul(plyr_[_pID].gu)) / (1e18);\r\n            plyr_[_pID].maskGu = (((allMaskGu_.mul(plyr_[_pID].gu)) / (1e18)).sub(_pearn)).add(plyr_[_pID].maskGu);\r\n            \r\n            // calculate & return dust\r\n            return (_jcg.sub((_ppg.mul(allGuGiven_)) / (1e18)));\r\n        } else {\r\n            return _jcg;\r\n        }\r\n    }\r\n    \r\n    function withdrawEarnings(uint256 _pID, bool isWithdraw)\r\n        whenNotPaused\r\n        private\r\n        returns(uint256)\r\n    {\r\n        updateGenGuVault(_pID);\r\n\r\n        updateReferralGu(_pID);\r\n\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        if (isWithdraw) plyrRnds_[_pID][plyr_[_pID].lrnd].genWithdraw = plyr_[_pID].gen.add(plyrRnds_[_pID][plyr_[_pID].lrnd].genWithdraw); // for doubled profit\r\n\r\n        // from all vaults \r\n        uint256 _earnings = plyr_[_pID].gen.add(plyr_[_pID].win).add(plyr_[_pID].genGu).add(plyr_[_pID].aff).add(plyr_[_pID].refund);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].genGu = 0;\r\n            plyr_[_pID].aff = 0;\r\n            plyr_[_pID].refund = 0;\r\n            if (isWithdraw) plyr_[_pID].withdraw = _earnings.add(plyr_[_pID].withdraw);\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n\r\n    bool public activated_ = false;\r\n    function activate()\r\n        onlyOwner\r\n        public\r\n    {\r\n        // can only be ran once\r\n        require(activated_ == false);\r\n        \r\n        // activate the contract \r\n        activated_ = true;\r\n        contractStartDate_ = now;\r\n        \r\n        // lets start first round\r\n        rID_ = 1;\r\n        round_[1].strt = now;\r\n        round_[1].end = now + rndInit_;\r\n    }\r\n}\r\n\r\nlibrary Datasets {\r\n    struct Player {\r\n        address addr;   // player address\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 genGu;  // general gu vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 refund;  // refund vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n        uint256 withdraw; // sum of withdraw\r\n        uint256 maskGu; // player mask gu: for sharing eth-profit by holding gu\r\n        uint256 gu;     \r\n        uint256 referEth; // total referral \r\n        uint256 lastClaimedPhID; // at which phID player has claimed the remaining gu\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round\r\n        uint256 keys;   // keys\r\n        uint256 maskKey;   // player mask key: for sharing eth-profit by holding keys\r\n        uint256 genWithdraw;  // eth withdraw from gen vault\r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 allkeys; // all keys\r\n        uint256 keys;   // active keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 maskKey;   // global mask on key shares: for sharing eth-profit by holding keys\r\n        uint256 playCtr;   // play counter for playOrders\r\n    }\r\n    struct PlayerPhrases {\r\n        uint256 eth;   // amount of eth in of the referral\r\n        uint256 guRewarded;  // if have taken the gu through referral\r\n    }\r\n    struct Phrase {\r\n        uint256 eth;   // amount of total eth in of the referral\r\n        uint256 guGiven; // amount of gu distributed \r\n        uint256 mask;  // a rate of remainGu per ethIn shares: for sharing gu-reward by referral eth\r\n        uint256 minEthRequired;  // min refer.eth to get 1 gu\r\n        uint256 guPoolAllocation; // total number of gu\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"leekStealPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"allkeys\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"maskKey\",\"type\":\"uint256\"},{\"name\":\"playCtr\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playOrders_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractStartDate_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allMaskGu_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leekStealOn_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stealTheLeek\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelisted_Prebuy\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leekStealToday_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPhraseInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allGuGiven_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrPhas_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"guRewarded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leekStealTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"maskKey\",\"type\":\"uint256\"},{\"name\":\"genWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reLoadXid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addrs\",\"type\":\"address[]\"},{\"name\":\"_isWhitelisted\",\"type\":\"bool\"}],\"name\":\"updateWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dayStealTime_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affID\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"phrase_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"guGiven\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"minEthRequired\",\"type\":\"uint256\"},{\"name\":\"guPoolAllocation\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"genGu\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"refund\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"withdraw\",\"type\":\"uint256\"},{\"name\":\"maskGu\",\"type\":\"uint256\"},{\"name\":\"gu\",\"type\":\"uint256\"},{\"name\":\"referEth\",\"type\":\"uint256\"},{\"name\":\"lastClaimedPhID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"safeDrain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_guAmt\",\"type\":\"uint256\"}],\"name\":\"transferGu\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"KeyPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LeekStealOn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"JCLYLong","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2938538815376220ca4b5ac4adfc48cd4c29359e48181384bc879ab8c629d96f"}]}