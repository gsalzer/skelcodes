{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\nlibrary UrlStr {\r\n  \r\n  // generate url by tokenId\r\n  // baseUrl must end with 00000000\r\n  function generateUrl(string url,uint256 _tokenId) internal pure returns (string _url){\r\n    _url = url;\r\n    bytes memory _tokenURIBytes = bytes(_url);\r\n    uint256 base_len = _tokenURIBytes.length - 1;\r\n    _tokenURIBytes[base_len - 7] = byte(48 + _tokenId / 10000000 % 10);\r\n    _tokenURIBytes[base_len - 6] = byte(48 + _tokenId / 1000000 % 10);\r\n    _tokenURIBytes[base_len - 5] = byte(48 + _tokenId / 100000 % 10);\r\n    _tokenURIBytes[base_len - 4] = byte(48 + _tokenId / 10000 % 10);\r\n    _tokenURIBytes[base_len - 3] = byte(48 + _tokenId / 1000 % 10);\r\n    _tokenURIBytes[base_len - 2] = byte(48 + _tokenId / 100 % 10);\r\n    _tokenURIBytes[base_len - 1] = byte(48 + _tokenId / 10 % 10);\r\n    _tokenURIBytes[base_len - 0] = byte(48 + _tokenId / 1 % 10);\r\n  }\r\n}\r\n\r\ninterface ERC165 {\r\n  \r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId) external view returns (bool);\r\n}\r\n\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external view returns (string _name);\r\n\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() external view returns (string _symbol);\r\n\r\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n  ///  Metadata JSON Schema\".\r\n  function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\ncontract SupportsInterfaceWithLookup is ERC165 {\r\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n  /**\r\n   * 0x01ffc9a7 ===\r\n   *   bytes4(keccak256('supportsInterface(bytes4)'))\r\n   */\r\n\r\n  /**\r\n   * @dev a mapping of interface id to whether or not it's supported\r\n   */\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * @dev A contract implementing SupportsInterfaceWithLookup\r\n   * implement ERC165 itself\r\n   */\r\n  constructor()\r\n    public\r\n  {\r\n    _registerInterface(InterfaceId_ERC165);\r\n  }\r\n\r\n  /**\r\n   * @dev implement supportsInterface(bytes4) using a lookup table\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool)\r\n  {\r\n    return supportedInterfaces[_interfaceId];\r\n  }\r\n\r\n  /**\r\n   * @dev private method for registering an interface\r\n   */\r\n  function _registerInterface(bytes4 _interfaceId)\r\n    internal\r\n  {\r\n    require(_interfaceId != 0xffffffff);\r\n    supportedInterfaces[_interfaceId] = true;\r\n  }\r\n}\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n/**\r\n * @title Operator\r\n * @dev Allow two roles: 'owner' or 'operator'\r\n *      - owner: admin/superuser (e.g. with financial rights)\r\n *      - operator: can update configurations\r\n */\r\ncontract Operator is Ownable {\r\n    address[] public operators;\r\n\r\n    uint public MAX_OPS = 20; // Default maximum number of operators allowed\r\n\r\n    mapping(address => bool) public isOperator;\r\n\r\n    event OperatorAdded(address operator);\r\n    event OperatorRemoved(address operator);\r\n\r\n    // @dev Throws if called by any non-operator account. Owner has all ops rights.\r\n    modifier onlyOperator() {\r\n        require(\r\n            isOperator[msg.sender] || msg.sender == owner,\r\n            \"Permission denied. Must be an operator or the owner.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner or operators to add operators\r\n     * @param _newOperator New operator address\r\n     */\r\n    function addOperator(address _newOperator) public onlyOwner {\r\n        require(\r\n            _newOperator != address(0),\r\n            \"Invalid new operator address.\"\r\n        );\r\n\r\n        // Make sure no dups\r\n        require(\r\n            !isOperator[_newOperator],\r\n            \"New operator exists.\"\r\n        );\r\n\r\n        // Only allow so many ops\r\n        require(\r\n            operators.length < MAX_OPS,\r\n            \"Overflow.\"\r\n        );\r\n\r\n        operators.push(_newOperator);\r\n        isOperator[_newOperator] = true;\r\n\r\n        emit OperatorAdded(_newOperator);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner or operators to remove operator\r\n     * @param _operator Address of the operator to be removed\r\n     */\r\n    function removeOperator(address _operator) public onlyOwner {\r\n        // Make sure operators array is not empty\r\n        require(\r\n            operators.length > 0,\r\n            \"No operator.\"\r\n        );\r\n\r\n        // Make sure the operator exists\r\n        require(\r\n            isOperator[_operator],\r\n            \"Not an operator.\"\r\n        );\r\n\r\n        // Manual array manipulation:\r\n        // - replace the _operator with last operator in array\r\n        // - remove the last item from array\r\n        address lastOperator = operators[operators.length - 1];\r\n        for (uint i = 0; i < operators.length; i++) {\r\n            if (operators[i] == _operator) {\r\n                operators[i] = lastOperator;\r\n            }\r\n        }\r\n        operators.length -= 1; // remove the last element\r\n\r\n        isOperator[_operator] = false;\r\n        emit OperatorRemoved(_operator);\r\n    }\r\n\r\n    // @dev Remove ALL operators\r\n    function removeAllOps() public onlyOwner {\r\n        for (uint i = 0; i < operators.length; i++) {\r\n            isOperator[operators[i]] = false;\r\n        }\r\n        operators.length = 0;\r\n    }\r\n}\r\ncontract Pausable is Operator {\r\n\r\n  event FrozenFunds(address target, bool frozen);\r\n\r\n  bool public isPaused = false;\r\n  \r\n  mapping(address => bool)  frozenAccount;\r\n\r\n  modifier whenNotPaused {\r\n    require(!isPaused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused {\r\n    require(isPaused);\r\n    _;  \r\n  }\r\n\r\n  modifier whenNotFreeze(address _target) {\r\n    require(_target != address(0));\r\n    require(!frozenAccount[_target]);\r\n    _;\r\n  }\r\n\r\n  function isFrozen(address _target) external view returns (bool) {\r\n    require(_target != address(0));\r\n    return frozenAccount[_target];\r\n  }\r\n\r\n  function doPause() external  whenNotPaused onlyOwner {\r\n    isPaused = true;\r\n  }\r\n\r\n  function doUnpause() external  whenPaused onlyOwner {\r\n    isPaused = false;\r\n  }\r\n\r\n  function freezeAccount(address _target, bool _freeze) public onlyOwner {\r\n    require(_target != address(0));\r\n    frozenAccount[_target] = _freeze;\r\n    emit FrozenFunds(_target, _freeze);\r\n  }\r\n\r\n}\r\n\r\ninterface ERC998ERC721TopDown {\r\n    event ReceivedChild(address indexed _from, uint256 indexed _tokenId, address indexed _childContract, uint256 _childTokenId);\r\n    event TransferChild(uint256 indexed tokenId, address indexed _to, address indexed _childContract, uint256 _childTokenId);\r\n\r\n    function rootOwnerOf(uint256 _tokenId) external view returns (bytes32 rootOwner);\r\n    function rootOwnerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 rootOwner);\r\n    function ownerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId);\r\n    function onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) external returns (bytes4);\r\n    function transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\r\n    function safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external;\r\n    function safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId, bytes _data) external;\r\n    function transferChildToParent(uint256 _fromTokenId, address _toContract, uint256 _toTokenId, address _childContract, uint256 _childTokenId, bytes _data) external;\r\n    // getChild function enables older contracts like cryptokitties to be transferred into a composable\r\n    // The _childContract must approve this contract. Then getChild can be called.\r\n    function getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) external;\r\n}\r\n\r\ninterface ERC998ERC721TopDownEnumerable {\r\n    function totalChildContracts(uint256 _tokenId) external view returns (uint256);\r\n    function childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract);\r\n    function totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256);\r\n    function childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId);\r\n}\r\n\r\ninterface ERC998ERC20TopDown {\r\n    event ReceivedERC20(address indexed _from, uint256 indexed _tokenId, address indexed _erc20Contract, uint256 _value);\r\n    event TransferERC20(uint256 indexed _tokenId, address indexed _to, address indexed _erc20Contract, uint256 _value);\r\n\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) external;\r\n    function balanceOfERC20(uint256 _tokenId, address __erc20Contract) external view returns (uint256);\r\n    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external;\r\n    function transferERC223(uint256 _tokenId, address _to, address _erc223Contract, uint256 _value, bytes _data) external;\r\n    function getERC20(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) external;\r\n\r\n}\r\n\r\ninterface ERC998ERC20TopDownEnumerable {\r\n    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256);\r\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address);\r\n}\r\n\r\ninterface ERC20AndERC223 {\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function transfer(address to, uint value) external returns (bool success);\r\n    function transfer(address to, uint value, bytes data) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n}\r\n\r\ninterface ERC998ERC721BottomUp {\r\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external;\r\n}\r\n\r\ncontract ComposableTopDown is Pausable, ERC721, ERC998ERC721TopDown, ERC998ERC721TopDownEnumerable,\r\nERC998ERC20TopDown, ERC998ERC20TopDownEnumerable {\r\n    // return this.rootOwnerOf.selector ^ this.rootOwnerOfChild.selector ^\r\n    //   this.tokenOwnerOf.selector ^ this.ownerOfChild.selector;\r\n    bytes32 constant ERC998_MAGIC_VALUE = 0xcd740db5;\r\n\r\n    // tokenId => token owner\r\n    mapping(uint256 => address) internal tokenIdToTokenOwner;\r\n\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n\r\n    // token owner address => token count\r\n    mapping(address => uint256) internal tokenOwnerToTokenCount;\r\n\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n\r\n\r\n    //constructor(string _name, string _symbol) public ERC721Token(_name, _symbol) {}\r\n\r\n  function _mint(address _to,uint256 _tokenId) internal whenNotPaused {\r\n    tokenIdToTokenOwner[_tokenId] = _to;\r\n    tokenOwnerToTokenCount[_to]++;\r\n    emit Transfer(address(0), _to, _tokenId);\r\n  }\r\n\r\n    //from zepellin ERC721Receiver.sol\r\n    //old version\r\n    bytes4 constant ERC721_RECEIVED_OLD = 0xf0b9e5ba;\r\n    //new version\r\n    bytes4 constant ERC721_RECEIVED_NEW = 0x150b7a02;\r\n\r\n    ////////////////////////////////////////////////////////\r\n    // ERC721 implementation\r\n    ////////////////////////////////////////////////////////\r\n\r\n    function isContract(address _addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(_addr)}\r\n        return size > 0;\r\n    }\r\n\r\n    function rootOwnerOf(uint256 _tokenId) public view returns (bytes32 rootOwner) {\r\n        return rootOwnerOfChild(address(0), _tokenId);\r\n    }\r\n\r\n    // returns the owner at the top of the tree of composables\r\n    // Use Cases handled:\r\n    // Case 1: Token owner is this contract and token.\r\n    // Case 2: Token owner is other top-down composable\r\n    // Case 3: Token owner is other contract\r\n    // Case 4: Token owner is user\r\n    function rootOwnerOfChild(address _childContract, uint256 _childTokenId) public view returns (bytes32 rootOwner) {\r\n        address rootOwnerAddress;\r\n        if (_childContract != address(0)) {\r\n            (rootOwnerAddress, _childTokenId) = _ownerOfChild(_childContract, _childTokenId);\r\n        }\r\n        else {\r\n            rootOwnerAddress = tokenIdToTokenOwner[_childTokenId];\r\n        }\r\n        // Case 1: Token owner is this contract and token.\r\n        while (rootOwnerAddress == address(this)) {\r\n            (rootOwnerAddress, _childTokenId) = _ownerOfChild(rootOwnerAddress, _childTokenId);\r\n        }\r\n\r\n        bool callSuccess;\r\n        bytes memory calldata;\r\n        // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n        calldata = abi.encodeWithSelector(0xed81cdda, address(this), _childTokenId);\r\n        assembly {\r\n            callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n            if callSuccess {\r\n                rootOwner := mload(calldata)\r\n            }\r\n        }\r\n        if(callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n            // Case 2: Token owner is other top-down composable\r\n            return rootOwner;\r\n        }\r\n        else {\r\n            // Case 3: Token owner is other contract\r\n            // Or\r\n            // Case 4: Token owner is user\r\n            return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n        }\r\n    }\r\n\r\n\r\n    // returns the owner at the top of the tree of composables\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address tokenOwner) {\r\n        tokenOwner = tokenIdToTokenOwner[_tokenId];\r\n        require(tokenOwner != address(0));\r\n        return tokenOwner;\r\n    }\r\n\r\n    function balanceOf(address _tokenOwner) external view returns (uint256) {\r\n        require(_tokenOwner != address(0));\r\n        return tokenOwnerToTokenCount[_tokenOwner];\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) external whenNotPaused {\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender]);\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] = _approved;\r\n        emit Approval(rootOwner, _approved, _tokenId);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address)  {\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        return rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external whenNotPaused {\r\n        require(_operator != address(0));\r\n        tokenOwnerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool)  {\r\n        require(_owner != address(0));\r\n        require(_operator != address(0));\r\n        return tokenOwnerToOperators[_owner][_operator];\r\n    }\r\n\r\n\r\n    function _transferFrom(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\r\n        require(_from != address(0));\r\n        require(tokenIdToTokenOwner[_tokenId] == _from);\r\n        require(_to != address(0));\r\n        require(!frozenAccount[_from]);                  \r\n        require(!frozenAccount[_to]); \r\n        if(msg.sender != _from) {\r\n            bytes32 rootOwner;\r\n            bool callSuccess;\r\n            // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n            bytes memory calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, _from, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if(callSuccess == true) {\r\n                require(rootOwner >> 224 != ERC998_MAGIC_VALUE, \"Token is child of other top down composable\");\r\n            }\r\n            require(tokenOwnerToOperators[_from][msg.sender] ||\r\n            rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId] == msg.sender);\r\n        }\r\n\r\n        // clear approval\r\n        if (rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId] != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n            emit Approval(_from, address(0), _tokenId);\r\n        }\r\n\r\n        // remove and transfer token\r\n        if (_from != _to) {\r\n            assert(tokenOwnerToTokenCount[_from] > 0);\r\n            tokenOwnerToTokenCount[_from]--;\r\n            tokenIdToTokenOwner[_tokenId] = _to;\r\n            tokenOwnerToTokenCount[_to]++;\r\n        }\r\n        emit Transfer(_from, _to, _tokenId);\r\n\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _transferFrom(_from, _to, _tokenId);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _transferFrom(_from, _to, _tokenId);\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, \"\");\r\n            require(retval == ERC721_RECEIVED_OLD);\r\n        }\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\r\n        _transferFrom(_from, _to, _tokenId);\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == ERC721_RECEIVED_OLD);\r\n        }\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    // ERC998ERC721 and ERC998ERC721Enumerable implementation\r\n    ////////////////////////////////////////////////////////\r\n\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n\r\n    // tokenId => (child address => contract index+1)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n\r\n    // tokenId => (child address => (child token => child index+1)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n\r\n    // child address => childId => tokenId\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n\r\n\r\n    function _removeChild(uint256 _tokenId, address _childContract, uint256 _childTokenId) internal whenNotPaused {\r\n        uint256 tokenIndex = childTokenIndex[_tokenId][_childContract][_childTokenId];\r\n        require(tokenIndex != 0, \"Child token not owned by token.\");\r\n\r\n        // remove child token\r\n        uint256 lastTokenIndex = childTokens[_tokenId][_childContract].length - 1;\r\n        uint256 lastToken = childTokens[_tokenId][_childContract][lastTokenIndex];\r\n        // if (_childTokenId == lastToken) {\r\n            childTokens[_tokenId][_childContract][tokenIndex - 1] = lastToken;\r\n            childTokenIndex[_tokenId][_childContract][lastToken] = tokenIndex;\r\n        // }\r\n        childTokens[_tokenId][_childContract].length--;\r\n        delete childTokenIndex[_tokenId][_childContract][_childTokenId];\r\n        delete childTokenOwner[_childContract][_childTokenId];\r\n\r\n        // remove contract\r\n        if (lastTokenIndex == 0) {\r\n            uint256 lastContractIndex = childContracts[_tokenId].length - 1;\r\n            address lastContract = childContracts[_tokenId][lastContractIndex];\r\n            if (_childContract != lastContract) {\r\n                uint256 contractIndex = childContractIndex[_tokenId][_childContract];\r\n                childContracts[_tokenId][contractIndex] = lastContract;\r\n                childContractIndex[_tokenId][lastContract] = contractIndex;\r\n            }\r\n            childContracts[_tokenId].length--;\r\n            delete childContractIndex[_tokenId][_childContract];\r\n        }\r\n    }\r\n\r\n    function safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external {\r\n        _transferChild(_fromTokenId, _to, _childContract, _childTokenId);\r\n        ERC721(_childContract).safeTransferFrom(this, _to, _childTokenId);\r\n    }\r\n\r\n    function safeTransferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId, bytes _data) external {\r\n        _transferChild(_fromTokenId, _to, _childContract, _childTokenId);\r\n        ERC721(_childContract).safeTransferFrom(this, _to, _childTokenId, _data); \r\n    }\r\n\r\n    function transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) external {\r\n        _transferChild(_fromTokenId, _to, _childContract, _childTokenId);\r\n        //this is here to be compatible with cryptokitties and other old contracts that require being owner and approved\r\n        // before transferring.\r\n        //does not work with current standard which does not allow approving self, so we must let it fail in that case.\r\n        //0x095ea7b3 == \"approve(address,uint256)\"\r\n        bytes memory calldata = abi.encodeWithSelector(0x095ea7b3, this, _childTokenId);\r\n        assembly {\r\n            let success := call(gas, _childContract, 0, add(calldata, 0x20), mload(calldata), calldata, 0)\r\n        }\r\n        ERC721(_childContract).transferFrom(this, _to, _childTokenId);\r\n    }\r\n\r\n    function _transferChild(uint256 _fromTokenId, address _to, address _childContract, uint256 _childTokenId) internal {\r\n        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(tokenId > 0 || childTokenIndex[tokenId][_childContract][_childTokenId] > 0);\r\n        require(tokenId == _fromTokenId);\r\n        require(_to != address(0));\r\n        address rootOwner = address(rootOwnerOf(tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][tokenId] == msg.sender);\r\n        _removeChild(tokenId, _childContract, _childTokenId);\r\n        emit TransferChild(_fromTokenId, _to, _childContract, _childTokenId);\r\n    }\r\n\r\n    function transferChildToParent(uint256 _fromTokenId, address _toContract, uint256 _toTokenId, address _childContract, uint256 _childTokenId, bytes _data) external {\r\n        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(tokenId > 0 || childTokenIndex[tokenId][_childContract][_childTokenId] > 0);\r\n        require(tokenId == _fromTokenId);\r\n        require(_toContract != address(0));\r\n        address rootOwner = address(rootOwnerOf(tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][tokenId] == msg.sender);\r\n        _removeChild(_fromTokenId, _childContract, _childTokenId);\r\n        ERC998ERC721BottomUp(_childContract).transferToParent(address(this), _toContract, _toTokenId, _childTokenId, _data);\r\n        emit TransferChild(_fromTokenId, _toContract, _childContract, _childTokenId);\r\n    }\r\n\r\n\r\n    // this contract has to be approved first in _childContract\r\n    function getChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) external {\r\n        _receiveChild(_from, _tokenId, _childContract, _childTokenId);\r\n        require(_from == msg.sender ||\r\n        ERC721(_childContract).isApprovedForAll(_from, msg.sender) ||\r\n        ERC721(_childContract).getApproved(_childTokenId) == msg.sender);\r\n        ERC721(_childContract).transferFrom(_from, this, _childTokenId);\r\n    }\r\n\r\n    function onERC721Received(address _from, uint256 _childTokenId, bytes _data) external returns (bytes4) {\r\n        require(_data.length > 0, \"_data must contain the uint256 tokenId to transfer the child token to.\");\r\n        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes\r\n        uint256 tokenId;\r\n        assembly {tokenId := calldataload(132)}\r\n        if (_data.length < 32) {\r\n            tokenId = tokenId >> 256 - _data.length * 8;\r\n        }\r\n        _receiveChild(_from, tokenId, msg.sender, _childTokenId);\r\n        require(ERC721(msg.sender).ownerOf(_childTokenId) != address(0), \"Child token not owned.\");\r\n        return ERC721_RECEIVED_OLD;\r\n    }\r\n\r\n    function onERC721Received(address _operator, address _from, uint256 _childTokenId, bytes _data) external returns (bytes4) {\r\n        require(_data.length > 0, \"_data must contain the uint256 tokenId to transfer the child token to.\");\r\n        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes\r\n        uint256 tokenId;\r\n        assembly {tokenId := calldataload(164)}\r\n        if (_data.length < 32) {\r\n            tokenId = tokenId >> 256 - _data.length * 8;\r\n        }\r\n        _receiveChild(_from, tokenId, msg.sender, _childTokenId);\r\n        require(ERC721(msg.sender).ownerOf(_childTokenId) != address(0), \"Child token not owned.\");\r\n        return ERC721_RECEIVED_NEW;\r\n    }\r\n\r\n    function _receiveChild(address _from, uint256 _tokenId, address _childContract, uint256 _childTokenId) internal whenNotPaused {\r\n        require(tokenIdToTokenOwner[_tokenId] != address(0), \"_tokenId does not exist.\");\r\n        require(childTokenIndex[_tokenId][_childContract][_childTokenId] == 0, \"Cannot receive child token because it has already been received.\");\r\n        uint256 childTokensLength = childTokens[_tokenId][_childContract].length;\r\n        if (childTokensLength == 0) {\r\n            childContractIndex[_tokenId][_childContract] = childContracts[_tokenId].length;\r\n            childContracts[_tokenId].push(_childContract);\r\n        }\r\n        childTokens[_tokenId][_childContract].push(_childTokenId);\r\n        childTokenIndex[_tokenId][_childContract][_childTokenId] = childTokensLength + 1;\r\n        childTokenOwner[_childContract][_childTokenId] = _tokenId;\r\n        emit ReceivedChild(_from, _tokenId, _childContract, _childTokenId);\r\n    }\r\n\r\n    function _ownerOfChild(address _childContract, uint256 _childTokenId) internal view returns (address parentTokenOwner, uint256 parentTokenId) {\r\n        parentTokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(parentTokenId > 0 || childTokenIndex[parentTokenId][_childContract][_childTokenId] > 0);\r\n        return (tokenIdToTokenOwner[parentTokenId], parentTokenId);\r\n    }\r\n\r\n    function ownerOfChild(address _childContract, uint256 _childTokenId) external view returns (bytes32 parentTokenOwner, uint256 parentTokenId) {\r\n        parentTokenId = childTokenOwner[_childContract][_childTokenId];\r\n        require(parentTokenId > 0 || childTokenIndex[parentTokenId][_childContract][_childTokenId] > 0);\r\n        return (ERC998_MAGIC_VALUE << 224 | bytes32(tokenIdToTokenOwner[parentTokenId]), parentTokenId);\r\n    }\r\n\r\n    function childExists(address _childContract, uint256 _childTokenId) external view returns (bool) {\r\n        uint256 tokenId = childTokenOwner[_childContract][_childTokenId];\r\n        return childTokenIndex[tokenId][_childContract][_childTokenId] != 0;\r\n    }\r\n\r\n    function totalChildContracts(uint256 _tokenId) external view returns (uint256) {\r\n        return childContracts[_tokenId].length;\r\n    }\r\n\r\n    function childContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address childContract) {\r\n        require(_index < childContracts[_tokenId].length, \"Contract address does not exist for this token and index.\");\r\n        return childContracts[_tokenId][_index];\r\n    }\r\n\r\n    function totalChildTokens(uint256 _tokenId, address _childContract) external view returns (uint256) {\r\n        return childTokens[_tokenId][_childContract].length;\r\n    }\r\n\r\n    function childTokenByIndex(uint256 _tokenId, address _childContract, uint256 _index) external view returns (uint256 childTokenId) {\r\n        require(_index < childTokens[_tokenId][_childContract].length, \"Token does not own a child token at contract address and index.\");\r\n        return childTokens[_tokenId][_childContract][_index];\r\n    }\r\n\r\n    ////////////////////////////////////////////////////////\r\n    // ERC998ERC223 and ERC998ERC223Enumerable implementation\r\n    ////////////////////////////////////////////////////////\r\n\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) erc20Contracts;\r\n\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) erc20Balances;\r\n\r\n    function balanceOfERC20(uint256 _tokenId, address _erc20Contract) external view returns (uint256) {\r\n        return erc20Balances[_tokenId][_erc20Contract];\r\n    }\r\n\r\n    function removeERC20(uint256 _tokenId, address _erc20Contract, uint256 _value) private {\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract];\r\n        require(erc20Balance >= _value, \"Not enough token available to transfer.\");\r\n        uint256 newERC20Balance = erc20Balance - _value;\r\n        erc20Balances[_tokenId][_erc20Contract] = newERC20Balance;\r\n        if (newERC20Balance == 0) {\r\n            uint256 lastContractIndex = erc20Contracts[_tokenId].length - 1;\r\n            address lastContract = erc20Contracts[_tokenId][lastContractIndex];\r\n            if (_erc20Contract != lastContract) {\r\n                uint256 contractIndex = erc20ContractIndex[_tokenId][_erc20Contract];\r\n                erc20Contracts[_tokenId][contractIndex] = lastContract;\r\n                erc20ContractIndex[_tokenId][lastContract] = contractIndex;\r\n            }\r\n            erc20Contracts[_tokenId].length--;\r\n            delete erc20ContractIndex[_tokenId][_erc20Contract];\r\n        }\r\n    }\r\n\r\n\r\n    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external {\r\n        require(_to != address(0));\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender);\r\n        removeERC20(_tokenId, _erc20Contract, _value);\r\n        require(ERC20AndERC223(_erc20Contract).transfer(_to, _value), \"ERC20 transfer failed.\");\r\n        emit TransferERC20(_tokenId, _to, _erc20Contract, _value);\r\n    }\r\n\r\n    // implementation of ERC 223\r\n    function transferERC223(uint256 _tokenId, address _to, address _erc223Contract, uint256 _value, bytes _data) external {\r\n        require(_to != address(0));\r\n        address rootOwner = address(rootOwnerOf(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender);\r\n        removeERC20(_tokenId, _erc223Contract, _value);\r\n        require(ERC20AndERC223(_erc223Contract).transfer(_to, _value, _data), \"ERC223 transfer failed.\");\r\n        emit TransferERC20(_tokenId, _to, _erc223Contract, _value);\r\n    }\r\n\r\n    // this contract has to be approved first by _erc20Contract\r\n    function getERC20(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) public {\r\n        bool allowed = _from == msg.sender;\r\n        if (!allowed) {\r\n            uint256 remaining;\r\n            // 0xdd62ed3e == allowance(address,address)\r\n            bytes memory calldata = abi.encodeWithSelector(0xdd62ed3e, _from, msg.sender);\r\n            bool callSuccess;\r\n            assembly {\r\n                callSuccess := staticcall(gas, _erc20Contract, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    remaining := mload(calldata)\r\n                }\r\n            }\r\n            require(callSuccess, \"call to allowance failed\");\r\n            require(remaining >= _value, \"Value greater than remaining\");\r\n            allowed = true;\r\n        }\r\n        require(allowed, \"not allowed to getERC20\");\r\n        erc20Received(_from, _tokenId, _erc20Contract, _value);\r\n        require(ERC20AndERC223(_erc20Contract).transferFrom(_from, this, _value), \"ERC20 transfer failed.\");\r\n    }\r\n\r\n    function erc20Received(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) private {\r\n        require(tokenIdToTokenOwner[_tokenId] != address(0), \"_tokenId does not exist.\");\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract];\r\n        if (erc20Balance == 0) {\r\n            erc20ContractIndex[_tokenId][_erc20Contract] = erc20Contracts[_tokenId].length;\r\n            erc20Contracts[_tokenId].push(_erc20Contract);\r\n        }\r\n        erc20Balances[_tokenId][_erc20Contract] += _value;\r\n        emit ReceivedERC20(_from, _tokenId, _erc20Contract, _value);\r\n    }\r\n\r\n    // used by ERC 223\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) external {\r\n        require(_data.length > 0, \"_data must contain the uint256 tokenId to transfer the token to.\");\r\n        require(isContract(msg.sender), \"msg.sender is not a contract\");\r\n        /**************************************\r\n        * TODO move to library\r\n        **************************************/\r\n        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes\r\n        uint256 tokenId;\r\n        assembly {\r\n            tokenId := calldataload(132)\r\n        }\r\n        if (_data.length < 32) {\r\n            tokenId = tokenId >> 256 - _data.length * 8;\r\n        }\r\n        //END TODO\r\n        erc20Received(_from, tokenId, msg.sender, _value);\r\n    }\r\n\r\n\r\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address) {\r\n        require(_index < erc20Contracts[_tokenId].length, \"Contract address does not exist for this token and index.\");\r\n        return erc20Contracts[_tokenId][_index];\r\n    }\r\n\r\n    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256) {\r\n        return erc20Contracts[_tokenId].length;\r\n    }\r\n}\r\n\r\ncontract ERC998TopDownToken is SupportsInterfaceWithLookup, ERC721Enumerable, ERC721Metadata, ComposableTopDown {\r\n  using UrlStr for string;\r\n  using SafeMath for uint256;\r\n\r\n  string internal BASE_URL = \"https://www.bitguild.com/bitizens/api/avatar/getAvatar/00000000\";\r\n\r\n  bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n  bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n              \r\n  // Mapping from owner to list of owned token IDs\r\n  mapping(address => uint256[]) internal ownedTokens;\r\n\r\n  // Mapping from token ID to index of the owner tokens list\r\n  mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n  // Array with all token ids, used for enumeration\r\n  uint256[] internal allTokens;\r\n\r\n  // Mapping from token id to position in the allTokens array\r\n  mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n  /**\r\n   * @dev Constructor function\r\n   */\r\n  constructor() public {\r\n    // register the supported interfaces to conform to ERC721 via ERC165\r\n    _registerInterface(InterfaceId_ERC721Enumerable);\r\n    _registerInterface(InterfaceId_ERC721Metadata);\r\n    _registerInterface(bytes4(ERC998_MAGIC_VALUE));\r\n  }\r\n\r\n  modifier existsToken(uint256 _tokenId){\r\n    address owner = tokenIdToTokenOwner[_tokenId];\r\n    require(owner != address(0), \"This tokenId is invalid\"); \r\n    _;\r\n  }\r\n\r\n  function updateBaseURI(string _url) external onlyOwner {\r\n    BASE_URL = _url;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token name\r\n   * @return string representing the token name\r\n   */\r\n  function name() external view returns (string) {\r\n    return \"Bitizen\";\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token symbol\r\n   * @return string representing the token symbol\r\n   */\r\n  function symbol() external view returns (string) {\r\n    return \"BTZN\";\r\n  }\r\n\r\n  /**\r\n   * @dev Returns an URI for a given token ID\r\n   * Throws if the token ID does not exist. May return an empty string.\r\n   * @param _tokenId uint256 ID of the token to query\r\n   */\r\n  function tokenURI(uint256 _tokenId) external view existsToken(_tokenId) returns (string) {\r\n    return BASE_URL.generateUrl(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n   * @param _owner address owning the tokens list to be accessed\r\n   * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n   * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n   */\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    require(address(0) != _owner);\r\n    require(_index < tokenOwnerToTokenCount[_owner]);\r\n    return ownedTokens[_owner][_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the total amount of tokens stored by the contract\r\n   * @return uint256 representing the total amount of tokens\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return allTokens.length;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the token ID at a given index of all the tokens in this contract\r\n   * Reverts if the index is greater or equal to the total number of tokens\r\n   * @param _index uint256 representing the index to be accessed of the tokens list\r\n   * @return uint256 token ID at the given index of the tokens list\r\n   */\r\n  function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n    require(_index < totalSupply());\r\n    return allTokens[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to add a token ID to the list of a given address\r\n   * @param _to address representing the new owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n   */\r\n  function _addTokenTo(address _to, uint256 _tokenId) internal whenNotPaused {\r\n    uint256 length = ownedTokens[_to].length;\r\n    ownedTokens[_to].push(_tokenId);\r\n    ownedTokensIndex[_tokenId] = length;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to remove a token ID from the list of a given address\r\n   * @param _from address representing the previous owner of the given token ID\r\n   * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n   */\r\n  function _removeTokenFrom(address _from, uint256 _tokenId) internal whenNotPaused {\r\n    uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n    uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n    uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n    ownedTokens[_from][tokenIndex] = lastToken;\r\n    ownedTokens[_from][lastTokenIndex] = 0;\r\n    // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n    // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n    // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n    ownedTokens[_from].length--;\r\n    ownedTokensIndex[_tokenId] = 0;\r\n    ownedTokensIndex[lastToken] = tokenIndex;\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function to mint a new token\r\n   * Reverts if the given token ID already exists\r\n   * @param _to address the beneficiary that will own the minted token\r\n   * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n   */\r\n  function _mint(address _to, uint256 _tokenId) internal whenNotPaused {\r\n    super._mint(_to, _tokenId);\r\n    _addTokenTo(_to,_tokenId);\r\n    allTokensIndex[_tokenId] = allTokens.length;\r\n    allTokens.push(_tokenId);\r\n  }\r\n\r\n  //override\r\n  //add Enumerable info\r\n  function _transferFrom(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\r\n    // not allown to transfer when  only one  avatar\r\n    super._transferFrom(_from, _to, _tokenId);\r\n    _addTokenTo(_to,_tokenId);\r\n    _removeTokenFrom(_from, _tokenId);\r\n  }\r\n}\r\n\r\ninterface AvatarChildService {\r\n  /**\r\n      @dev if you want your contract become a avatar child, please let your contract inherit this interface\r\n      @param _tokenId1  first child token id\r\n      @param _tokenId2  second child token id\r\n      @return  true will unmount first token before mount ,false will directly mount child\r\n   */\r\n   function compareItemSlots(uint256 _tokenId1, uint256 _tokenId2) external view returns (bool _res);\r\n\r\n  /**\r\n   @dev if you want your contract become a avatar child, please let your contract inherit this interface\r\n   @return return true will be to avatar child\r\n   */\r\n   function isAvatarChild(uint256 _tokenId) external view returns(bool);\r\n}\r\n\r\ninterface AvatarService {\r\n  function updateAvatarInfo(address _owner, uint256 _tokenId, string _name, uint256 _dna) external;\r\n  function createAvatar(address _owner, string _name, uint256 _dna) external  returns(uint256);\r\n  function getMountedChildren(address _owner,uint256 _tokenId, address _childAddress) external view returns(uint256[]); \r\n  function getAvatarInfo(uint256 _tokenId) external view returns (string _name, uint256 _dna);\r\n  function getOwnedAvatars(address _owner) external view returns(uint256[] _avatars);\r\n  function unmount(address _owner, address _childContract, uint256[] _children, uint256 _avatarId) external;\r\n  function mount(address _owner, address _childContract, uint256[] _children, uint256 _avatarId) external;\r\n}\r\n\r\ncontract AvatarToken is ERC998TopDownToken, AvatarService {\r\n  \r\n  using UrlStr for string;\r\n\r\n  enum ChildHandleType{NULL, MOUNT, UNMOUNT}\r\n\r\n  event ChildHandle(address indexed from, uint256 parent, address indexed childAddr, uint256[] children, ChildHandleType _type);\r\n\r\n  event AvatarTransferStateChanged(address indexed _owner, bool _newState);\r\n\r\n  struct Avatar {\r\n    // avatar name\r\n    string name;\r\n    // avatar gen,this decide avatar appearance \r\n    uint256 dna;\r\n  }\r\n  \r\n  // avatar id index\r\n  uint256 internal avatarIndex = 0;\r\n  // avatar id => avatar\r\n  mapping(uint256 => Avatar) avatars;\r\n  // true avatar can do transfer \r\n  bool public avatarTransferState = false;\r\n\r\n  function changeAvatarTransferState(bool _newState) public onlyOwner {\r\n\tif(avatarTransferState == _newState) return;\r\n    avatarTransferState = _newState;\r\n    emit AvatarTransferStateChanged(owner, avatarTransferState);\r\n  }\r\n\r\n  function createAvatar(address _owner, string _name, uint256 _dna) external onlyOperator returns(uint256) {\r\n    return _createAvatar(_owner, _name, _dna);\r\n  }\r\n\r\n  function getMountedChildren(address _owner, uint256 _avatarId, address _childAddress)\r\n  external\r\n  view \r\n  onlyOperator\r\n  existsToken(_avatarId) \r\n  returns(uint256[]) {\r\n    require(_childAddress != address(0));\r\n    require(tokenIdToTokenOwner[_avatarId] == _owner);\r\n    return childTokens[_avatarId][_childAddress];\r\n  }\r\n  \r\n  function updateAvatarInfo(address _owner, uint256 _avatarId, string _name, uint256 _dna) external onlyOperator existsToken(_avatarId){\r\n    require(_owner != address(0), \"Invalid address\");\r\n    require(_owner == tokenIdToTokenOwner[_avatarId] || msg.sender == owner);\r\n    Avatar storage avatar = avatars[_avatarId];\r\n    avatar.name = _name;\r\n    avatar.dna = _dna;\r\n  }\r\n\r\n  function getOwnedAvatars(address _owner) external view onlyOperator returns(uint256[] _avatars) {\r\n    require(_owner != address(0));\r\n    _avatars = ownedTokens[_owner];\r\n  }\r\n\r\n  function getAvatarInfo(uint256 _avatarId) external view existsToken(_avatarId) returns(string _name, uint256 _dna) {\r\n    Avatar storage avatar = avatars[_avatarId];\r\n    _name = avatar.name;\r\n    _dna = avatar.dna;\r\n  }\r\n\r\n  function unmount(address _owner, address _childContract, uint256[] _children, uint256 _avatarId) external onlyOperator {\r\n    if(_children.length == 0) return;\r\n    require(ownerOf(_avatarId) == _owner); // check avatar owner\r\n    uint256[] memory mountedChildren = childTokens[_avatarId][_childContract]; \r\n    if (mountedChildren.length == 0) return;\r\n    uint256[] memory unmountChildren = new uint256[](_children.length); // record unmount children \r\n    for(uint8 i = 0; i < _children.length; i++) {\r\n      uint256 child = _children[i];\r\n      if(_isMounted(mountedChildren, child)){  \r\n        unmountChildren[i] = child;\r\n        _removeChild(_avatarId, _childContract, child);\r\n        ERC721(_childContract).transferFrom(this, _owner, child);\r\n      }\r\n    }\r\n    if(unmountChildren.length > 0 ) \r\n      emit ChildHandle(_owner, _avatarId, _childContract, unmountChildren, ChildHandleType.UNMOUNT);\r\n  }\r\n\r\n  function mount(address _owner, address _childContract, uint256[] _children, uint256 _avatarId) external onlyOperator {\r\n    if(_children.length == 0) return;\r\n    require(ownerOf(_avatarId) == _owner); // check avatar owner\r\n    for(uint8 i = 0; i < _children.length; i++) {\r\n      uint256 child = _children[i];\r\n      require(ERC721(_childContract).ownerOf(child) == _owner); // check child owner  \r\n      _receiveChild(_owner, _avatarId, _childContract, child);\r\n      ERC721(_childContract).transferFrom(_owner, this, child);\r\n    }\r\n    emit ChildHandle(_owner, _avatarId, _childContract, _children, ChildHandleType.MOUNT);\r\n  }\r\n\r\n  // check every have mounted children with the will mount child relationship\r\n  function _checkChildRule(address _owner, uint256 _avatarId, address _childContract, uint256 _child) internal {\r\n    uint256[] memory tokens = childTokens[_avatarId][_childContract];\r\n    if (tokens.length == 0) {\r\n      if (!AvatarChildService(_childContract).isAvatarChild(_child)) {\r\n        revert(\"it can't be avatar child\");\r\n      }\r\n    }\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      if (AvatarChildService(_childContract).compareItemSlots(tokens[i], _child)) {\r\n        _removeChild(_avatarId, _childContract, tokens[i]);\r\n        ERC721(_childContract).transferFrom(this, _owner, tokens[i]);\r\n      }\r\n    }\r\n  }\r\n  /// false will ignore not mounted children on this avatar and not exist children\r\n  function _isMounted(uint256[] mountedChildren, uint256 _toMountToken) private pure returns (bool) {\r\n    for(uint8 i = 0; i < mountedChildren.length; i++) {\r\n      if(mountedChildren[i] == _toMountToken){\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // create avatar \r\n  function _createAvatar(address _owner, string _name, uint256 _dna) private returns(uint256 _avatarId) {\r\n    require(_owner != address(0));\r\n    Avatar memory avatar = Avatar(_name, _dna);\r\n    _avatarId = ++avatarIndex;\r\n    avatars[_avatarId] = avatar;\r\n    _mint(_owner, _avatarId);\r\n  }\r\n\r\n  // override  \r\n  function _transferFrom(address _from, address _to, uint256 _avatarId) internal whenNotPaused {\r\n    // add transfer control\r\n    require(avatarTransferState == true, \"current time not allown transfer avatar\");\r\n    super._transferFrom(_from, _to, _avatarId);\r\n  }\r\n\r\n  // override\r\n  function _receiveChild(address _from, uint256 _avatarId, address _childContract, uint256 _childTokenId) internal whenNotPaused {\r\n    _checkChildRule(_from, _avatarId, _childContract, _childTokenId);\r\n    super._receiveChild(_from, _avatarId, _childContract, _childTokenId);\r\n  }\r\n\r\n  function () public payable {\r\n    revert();\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_toContract\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferChildToParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newState\",\"type\":\"bool\"}],\"name\":\"changeAvatarTransferState\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"childContractByIndex\",\"outputs\":[{\"name\":\"childContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"childTokenByIndex\",\"outputs\":[{\"name\":\"childTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_avatarId\",\"type\":\"uint256\"},{\"name\":\"_childAddress\",\"type\":\"address\"}],\"name\":\"getMountedChildren\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_avatarId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"updateAvatarInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doUnpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_childContract\",\"type\":\"address\"}],\"name\":\"totalChildTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"rootOwnerOf\",\"outputs\":[{\"name\":\"rootOwner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_avatarId\",\"type\":\"uint256\"}],\"name\":\"getAvatarInfo\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_dna\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"childExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"erc20ContractByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_children\",\"type\":\"uint256[]\"},{\"name\":\"_avatarId\",\"type\":\"uint256\"}],\"name\":\"mount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_OPS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"totalChildContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_url\",\"type\":\"string\"}],\"name\":\"updateBaseURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOperator\",\"type\":\"address\"}],\"name\":\"addOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"totalERC20Contracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"getChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"removeAllOps\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"transferChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_dna\",\"type\":\"uint256\"}],\"name\":\"createAvatar\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_erc223Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferERC223\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_children\",\"type\":\"uint256[]\"},{\"name\":\"_avatarId\",\"type\":\"uint256\"}],\"name\":\"unmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"}],\"name\":\"balanceOfERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"operators\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avatarTransferState\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"}],\"name\":\"isFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOfChild\",\"outputs\":[{\"name\":\"parentTokenOwner\",\"type\":\"bytes32\"},{\"name\":\"parentTokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwnedAvatars\",\"outputs\":[{\"name\":\"_avatars\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_childContract\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"rootOwnerOfChild\",\"outputs\":[{\"name\":\"rootOwner\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_childTokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"parent\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"childAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"children\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"_type\",\"type\":\"uint8\"}],\"name\":\"ChildHandle\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newState\",\"type\":\"bool\"}],\"name\":\"AvatarTransferStateChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"ReceivedERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"TransferERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_childContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"ReceivedChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_childContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_childTokenId\",\"type\":\"uint256\"}],\"name\":\"TransferChild\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"OperatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AvatarToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://99c30dd2bcebae0fac5336977aa5817ca5831d7e9781032a44b67ab5c1b240e2"}]}