{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.3;\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"Sender not authorised.\");\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract ERC677 is ERC20 {\r\n    function transferAndCall(address to, uint value, bytes data) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n    @title ItMap, a solidity iterable map\r\n    @dev Credit to: https://gist.github.com/ethers/7e6d443818cbc9ad2c38efa7c0f363d1\r\n */\r\nlibrary itmap {\r\n    struct entry {\r\n        // Equal to the index of the key of this item in keys, plus 1.\r\n        uint keyIndex;\r\n        uint value;\r\n    }\r\n\r\n    struct itmap {\r\n        mapping(uint => entry) data;\r\n        uint[] keys;\r\n    }\r\n    \r\n    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {\r\n        entry storage e = self.data[key];\r\n        e.value = value;\r\n        if (e.keyIndex > 0) {\r\n            return true;\r\n        } else {\r\n            e.keyIndex = ++self.keys.length;\r\n            self.keys[e.keyIndex - 1] = key;\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function remove(itmap storage self, uint key) internal returns (bool success) {\r\n        entry storage e = self.data[key];\r\n        if (e.keyIndex == 0)\r\n            return false;\r\n        \r\n        if (e.keyIndex < self.keys.length) {\r\n            // Move an existing element into the vacated key slot.\r\n            self.data[self.keys[self.keys.length - 1]].keyIndex = e.keyIndex;\r\n            self.keys[e.keyIndex - 1] = self.keys[self.keys.length - 1];\r\n            self.keys.length -= 1;\r\n            delete self.data[key];\r\n            return true;\r\n        }\r\n    }\r\n    \r\n    function contains(itmap storage self, uint key) internal view returns (bool exists) {\r\n        return self.data[key].keyIndex > 0;\r\n    }\r\n    \r\n    function size(itmap storage self) internal view returns (uint) {\r\n        return self.keys.length;\r\n    }\r\n    \r\n    function get(itmap storage self, uint key) internal view returns (uint) {\r\n        return self.data[key].value;\r\n    }\r\n    \r\n    function getKey(itmap storage self, uint idx) internal view returns (uint) {\r\n        return self.keys[idx];\r\n    }\r\n}\r\n\r\n/**\r\n    @title PoolOwners, the crowdsale contract for LinkPool ownership\r\n */\r\ncontract PoolOwners is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n    using itmap for itmap.itmap;\r\n\r\n    struct Owner {\r\n        uint256 key;\r\n        uint256 percentage;\r\n        uint256 shareTokens;\r\n        mapping(address => uint256) balance;\r\n    }\r\n    mapping(address => Owner) public owners;\r\n\r\n    struct Distribution {\r\n        address token;\r\n        uint256 amount;\r\n        uint256 owners;\r\n        uint256 claimed;\r\n        mapping(address => bool) claimedAddresses;\r\n    }\r\n    mapping(uint256 => Distribution) public distributions;\r\n\r\n    mapping(address => uint256) public tokenBalance;\r\n    mapping(address => uint256) public totalReturned;\r\n\r\n    mapping(address => bool) private whitelist;\r\n\r\n    itmap.itmap ownerMap;\r\n    \r\n    uint256 public totalContributed     = 0;\r\n    uint256 public totalOwners          = 0;\r\n    uint256 public totalDistributions   = 0;\r\n    bool    public distributionActive   = false;\r\n    uint256 public distributionMinimum  = 20 ether;\r\n    uint256 public precisionMinimum     = 0.04 ether;\r\n    bool    public locked               = false;\r\n    address public wallet;\r\n\r\n    bool    private contributionStarted = false;\r\n    uint256 private valuation           = 4000 ether;\r\n    uint256 private hardCap             = 1000 ether;\r\n\r\n    event Contribution(address indexed sender, uint256 share, uint256 amount);\r\n    event ClaimedTokens(address indexed owner, address indexed token, uint256 amount, uint256 claimedStakers, uint256 distributionId);\r\n    event TokenDistributionActive(address indexed token, uint256 amount, uint256 distributionId, uint256 amountOfOwners);\r\n    event TokenWithdrawal(address indexed token, address indexed owner, uint256 amount);\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner, uint256 amount);\r\n    event TokenDistributionComplete(address indexed token, uint256 amountOfOwners);\r\n\r\n    modifier onlyWhitelisted() {\r\n        require(whitelist[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev Constructor set set the wallet initally\r\n        @param _wallet Address of the ETH wallet\r\n     */\r\n    constructor(address _wallet) public {\r\n        require(_wallet != address(0));\r\n        wallet = _wallet;\r\n    }\r\n\r\n    /**\r\n        @dev Fallback function, redirects to contribution\r\n        @dev Transfers tokens to LP wallet address\r\n     */\r\n    function() public payable {\r\n        require(contributionStarted, \"Contribution phase hasn't started\");\r\n        require(whitelist[msg.sender], \"You are not whitelisted\");\r\n        contribute(msg.sender, msg.value); \r\n        wallet.transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n        @dev Manually set a contribution, used by owners to increase owners amounts\r\n        @param _sender The address of the sender to set the contribution for you\r\n        @param _amount The amount that the owner has sent\r\n     */\r\n    function setContribution(address _sender, uint256 _amount) public onlyOwner() { contribute(_sender, _amount); }\r\n\r\n    /**\r\n        @dev Registers a new contribution, sets their share\r\n        @param _sender The address of the wallet contributing\r\n        @param _amount The amount that the owner has sent\r\n     */\r\n    function contribute(address _sender, uint256 _amount) private {\r\n        require(!locked, \"Crowdsale period over, contribution is locked\");\r\n        require(!distributionActive, \"Cannot contribute when distribution is active\");\r\n        require(_amount >= precisionMinimum, \"Amount needs to be above the minimum contribution\");\r\n        require(hardCap >= _amount, \"Your contribution is greater than the hard cap\");\r\n        require(_amount % precisionMinimum == 0, \"Your amount isn't divisible by the minimum precision\");\r\n        require(hardCap >= totalContributed.add(_amount), \"Your contribution would cause the total to exceed the hardcap\");\r\n\r\n        totalContributed = totalContributed.add(_amount);\r\n        uint256 share = percent(_amount, valuation, 5);\r\n\r\n        Owner storage o = owners[_sender];\r\n        if (o.percentage != 0) { // Existing owner\r\n            o.shareTokens = o.shareTokens.add(_amount);\r\n            o.percentage = o.percentage.add(share);\r\n        } else { // New owner\r\n            o.key = totalOwners;\r\n            require(ownerMap.insert(o.key, uint(_sender)) == false);\r\n            totalOwners += 1;\r\n            o.shareTokens = _amount;\r\n            o.percentage = share;\r\n        }\r\n\r\n        if (!whitelist[msg.sender]) {\r\n            whitelist[msg.sender] = true;\r\n        }\r\n\r\n        emit Contribution(_sender, share, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev Whitelist a wallet address\r\n        @param _owner Wallet of the owner\r\n     */\r\n    function whitelistWallet(address _owner) external onlyOwner() {\r\n        require(!locked, \"Can't whitelist when the contract is locked\");\r\n        require(_owner != address(0), \"Empty address\");\r\n        whitelist[_owner] = true;\r\n    }\r\n\r\n    /**\r\n        @dev Start the distribution phase\r\n     */\r\n    function startContribution() external onlyOwner() {\r\n        require(!contributionStarted, \"Contribution has started\");\r\n        contributionStarted = true;\r\n    }\r\n\r\n    /**\r\n        @dev Manually set a share directly, used to set the LinkPool members as owners\r\n        @param _owner Wallet address of the owner\r\n        @param _value The equivalent contribution value\r\n     */\r\n    function setOwnerShare(address _owner, uint256 _value) public onlyOwner() {\r\n        require(!locked, \"Can't manually set shares, it's locked\");\r\n        require(!distributionActive, \"Cannot set owners share when distribution is active\");\r\n\r\n        Owner storage o = owners[_owner];\r\n        if (o.shareTokens == 0) {\r\n            whitelist[_owner] = true;\r\n            require(ownerMap.insert(totalOwners, uint(_owner)) == false);\r\n            o.key = totalOwners;\r\n            totalOwners += 1;\r\n        }\r\n        o.shareTokens = _value;\r\n        o.percentage = percent(_value, valuation, 5);\r\n    }\r\n\r\n    /**\r\n        @dev Transfer part or all of your ownership to another address\r\n        @param _receiver The address that you're sending to\r\n        @param _amount The amount of ownership to send, for your balance refer to `ownerShareTokens`\r\n     */\r\n    function sendOwnership(address _receiver, uint256 _amount) public onlyWhitelisted() {\r\n        Owner storage o = owners[msg.sender];\r\n        Owner storage r = owners[_receiver];\r\n\r\n        require(o.shareTokens > 0, \"You don't have any ownership\");\r\n        require(o.shareTokens >= _amount, \"The amount exceeds what you have\");\r\n        require(!distributionActive, \"Distribution cannot be active when sending ownership\");\r\n        require(_amount % precisionMinimum == 0, \"Your amount isn't divisible by the minimum precision amount\");\r\n\r\n        o.shareTokens = o.shareTokens.sub(_amount);\r\n\r\n        if (o.shareTokens == 0) {\r\n            o.percentage = 0;\r\n            require(ownerMap.remove(o.key) == true);\r\n        } else {\r\n            o.percentage = percent(o.shareTokens, valuation, 5);\r\n        }\r\n        if (r.shareTokens == 0) {\r\n            if (!whitelist[_receiver]) {\r\n                r.key = totalOwners;\r\n                whitelist[_receiver] = true;\r\n                totalOwners += 1;\r\n            }\r\n            require(ownerMap.insert(r.key, uint(_receiver)) == false);\r\n        }\r\n        r.shareTokens = r.shareTokens.add(_amount);\r\n        r.percentage = r.percentage.add(percent(_amount, valuation, 5));\r\n\r\n        emit OwnershipTransferred(msg.sender, _receiver, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev Lock the contribution/shares methods\r\n     */\r\n    function lockShares() public onlyOwner() {\r\n        require(!locked, \"Shares already locked\");\r\n        locked = true;\r\n    }\r\n\r\n    /**\r\n        @dev Start the distribution phase in the contract so owners can claim their tokens\r\n        @param _token The token address to start the distribution of\r\n     */\r\n    function distributeTokens(address _token) public onlyWhitelisted() {\r\n        require(!distributionActive, \"Distribution is already active\");\r\n        distributionActive = true;\r\n\r\n        ERC677 erc677 = ERC677(_token);\r\n\r\n        uint256 currentBalance = erc677.balanceOf(this) - tokenBalance[_token];\r\n        require(currentBalance > distributionMinimum, \"Amount in the contract isn't above the minimum distribution limit\");\r\n\r\n        totalDistributions++;\r\n        Distribution storage d = distributions[totalDistributions]; \r\n        d.owners = ownerMap.size();\r\n        d.amount = currentBalance;\r\n        d.token = _token;\r\n        d.claimed = 0;\r\n        totalReturned[_token] += currentBalance;\r\n\r\n        emit TokenDistributionActive(_token, currentBalance, totalDistributions, d.owners);\r\n    }\r\n\r\n    /**\r\n        @dev Claim tokens by a owner address to add them to their balance\r\n        @param _owner The address of the owner to claim tokens for\r\n     */\r\n    function claimTokens(address _owner) public {\r\n        Owner storage o = owners[_owner];\r\n        Distribution storage d = distributions[totalDistributions]; \r\n\r\n        require(o.shareTokens > 0, \"You need to have a share to claim tokens\");\r\n        require(distributionActive, \"Distribution isn't active\");\r\n        require(!d.claimedAddresses[_owner], \"Tokens already claimed for this address\");\r\n\r\n        address token = d.token;\r\n        uint256 tokenAmount = d.amount.mul(o.percentage).div(100000);\r\n        o.balance[token] = o.balance[token].add(tokenAmount);\r\n        tokenBalance[token] = tokenBalance[token].add(tokenAmount);\r\n\r\n        d.claimed++;\r\n        d.claimedAddresses[_owner] = true;\r\n\r\n        emit ClaimedTokens(_owner, token, tokenAmount, d.claimed, totalDistributions);\r\n\r\n        if (d.claimed == d.owners) {\r\n            distributionActive = false;\r\n            emit TokenDistributionComplete(token, totalOwners);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @dev Withdraw tokens from your contract balance\r\n        @param _token The token address for token claiming\r\n        @param _amount The amount of tokens to withdraw\r\n     */\r\n    function withdrawTokens(address _token, uint256 _amount) public {\r\n        require(_amount > 0, \"You have requested for 0 tokens to be withdrawn\");\r\n\r\n        Owner storage o = owners[msg.sender];\r\n        Distribution storage d = distributions[totalDistributions]; \r\n\r\n        if (distributionActive && !d.claimedAddresses[msg.sender]) {\r\n            claimTokens(msg.sender);\r\n        }\r\n        require(o.balance[_token] >= _amount, \"Amount requested is higher than your balance\");\r\n\r\n        o.balance[_token] = o.balance[_token].sub(_amount);\r\n        tokenBalance[_token] = tokenBalance[_token].sub(_amount);\r\n\r\n        ERC677 erc677 = ERC677(_token);\r\n        require(erc677.transfer(msg.sender, _amount) == true);\r\n\r\n        emit TokenWithdrawal(_token, msg.sender, _amount);\r\n    }\r\n\r\n    /**\r\n        @dev Set the minimum amount to be of transfered in this contract to start distribution\r\n        @param _minimum The minimum amount\r\n     */\r\n    function setDistributionMinimum(uint256 _minimum) public onlyOwner() {\r\n        distributionMinimum = _minimum;\r\n    }\r\n\r\n    /**\r\n        @dev Set the wallet address to receive the crowdsale contributions\r\n        @param _wallet The wallet address\r\n     */\r\n    function setEthWallet(address _wallet) public onlyOwner() {\r\n        wallet = _wallet;\r\n    }\r\n\r\n    /**\r\n        @dev Returns whether the address is whitelisted\r\n        @param _owner The address of the owner\r\n     */\r\n    function isWhitelisted(address _owner) public view returns (bool) {\r\n        return whitelist[_owner];\r\n    }\r\n\r\n    /**\r\n        @dev Returns the contract balance of the sender for a given token\r\n        @param _token The address of the ERC token\r\n     */\r\n    function getOwnerBalance(address _token) public view returns (uint256) {\r\n        Owner storage o = owners[msg.sender];\r\n        return o.balance[_token];\r\n    }\r\n\r\n    /**\r\n        @dev Returns a owner, all the values in the struct\r\n        @param _owner Address of the owner\r\n     */\r\n    function getOwner(address _owner) public view returns (uint256, uint256, uint256) {\r\n        Owner storage o = owners[_owner];\r\n        return (o.key, o.shareTokens, o.percentage);\r\n    }\r\n\r\n    /**\r\n        @dev Returns the current amount of active owners, ie share above 0\r\n     */\r\n    function getCurrentOwners() public view returns (uint) {\r\n        return ownerMap.size();\r\n    }\r\n\r\n    /**\r\n        @dev Returns owner address based on the key\r\n        @param _key The key of the address in the map\r\n     */\r\n    function getOwnerAddress(uint _key) public view returns (address) {\r\n        return address(ownerMap.get(_key));\r\n    }\r\n\r\n    /**\r\n        @dev Returns whether a owner has claimed their tokens\r\n        @param _owner The address of the owner\r\n        @param _dId The distribution id\r\n     */\r\n    function hasClaimed(address _owner, uint256 _dId) public view returns (bool) {\r\n        Distribution storage d = distributions[_dId]; \r\n        return d.claimedAddresses[_owner];\r\n    }\r\n\r\n    /**\r\n        @dev Credit to Rob Hitchens: https://stackoverflow.com/a/42739843\r\n     */\r\n    function percent(uint numerator, uint denominator, uint precision) private pure returns (uint quotient) {\r\n        uint _numerator = numerator * 10 ** (precision+1);\r\n        uint _quotient = ((_numerator / denominator) + 5) / 10;\r\n        return ( _quotient);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"key\",\"type\":\"uint256\"},{\"name\":\"percentage\",\"type\":\"uint256\"},{\"name\":\"shareTokens\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDistributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimum\",\"type\":\"uint256\"}],\"name\":\"setDistributionMinimum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"distributions\",\"outputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"owners\",\"type\":\"uint256\"},{\"name\":\"claimed\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"whitelistWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"getOwnerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"setEthWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalReturned\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"distributeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_dId\",\"type\":\"uint256\"}],\"name\":\"hasClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockShares\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"setContribution\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"locked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"precisionMinimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributionMinimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"setOwnerShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_key\",\"type\":\"uint256\"}],\"name\":\"getOwnerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sendOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"getOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"share\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"claimedStakers\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"distributionId\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"distributionId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountOfOwners\",\"type\":\"uint256\"}],\"name\":\"TokenDistributionActive\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountOfOwners\",\"type\":\"uint256\"}],\"name\":\"TokenDistributionComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PoolOwners","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e2d06414b011d6dfff2d7181feb37e68e8322d61","Library":"","SwarmSource":"bzzr://2e84954c3094728f2bc2f5930d5141bef792a71b9a32d5de773f4f08aa084c72"}]}