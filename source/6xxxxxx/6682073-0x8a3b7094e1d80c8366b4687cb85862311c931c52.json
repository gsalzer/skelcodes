{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// Fallback ERC20 token definition.\r\ncontract tokenFallback {\r\n\tuint256 public totalSupply;\r\n\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\r\n\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\tevent Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract TokenBurner {\r\n\tstruct Claim {\r\n\t\tuint256[] amount;\r\n\t\tstring[] pubkey;\r\n\t}\r\n\r\n\tstruct BatchTime {\r\n\t\tuint256 blockNumber;\r\n\t\tuint256 eventCount;\r\n\t}\r\n\r\n\t// Keep track of token burn batches - use this number for filtering in the emitted Burn event.\r\n\tuint16 public AEdeliveryBatchCounter = 0;\r\n\r\n\t// The admin who may count up the AE delivery batch count\r\n\taddress public AEdmin;\r\n\taddress public AEToken;\r\n\r\n\t// check if transaction sender is AEdmin.\r\n\tmodifier onlyAEdmin() {\r\n\t\trequire (msg.sender == AEdmin);\r\n\t\t_;\r\n\t}\r\n\r\n\tmapping(address => Claim) burned;\r\n\t// count the amount of burns for later filtering of all burnings\r\n\tuint256 public burnCount;\r\n\t// track amount of burn events for each delivery period e.g. for checking if the event scanner missed something\r\n\tmapping(uint16 => BatchTime) public batchTimes;\r\n\r\n\tconstructor(address _AEdmin, address _AEToken) public {\r\n\t\trequire (_AEdmin != 0x0);\r\n\t\tAEdmin = _AEdmin;\r\n\r\n\t\tif (_AEToken == 0x0) {\r\n\t\t\t_AEToken = 0x5CA9a71B1d01849C0a95490Cc00559717fCF0D1d; // Mainnet contract\r\n\t\t}\r\n\r\n\t\tAEToken = _AEToken;\r\n\t}\r\n\r\n\t// check if address starts with an ak_\r\n\tfunction checkAddress(bytes str) public pure returns (bool) {\r\n\t\tbytes memory ak = \"ak_\";\r\n\t\tbytes memory result = new bytes(3);\r\n\t\tfor(uint i = 0; i < 3; i++) {\r\n\t\t\tresult[i-0] = str[i];\r\n\t\t}\r\n\t\treturn (keccak256(result) == keccak256(ak));\r\n\t}\r\n\r\n\tfunction receiveApproval(\r\n\t\t\taddress _from,\r\n\t\t\tuint256 _value,\r\n\t\t\taddress _token,\r\n\t\t\tbytes _pubkey\r\n\t\t\t) public returns (bool) {\r\n\r\n\t\t// Only let people burn AE through original AEToken contract.\r\n\t\trequire(msg.sender == AEToken);\r\n\r\n\t\t// minimal form of type checking with room for unexpected outcomes of base58 encodings\r\n\r\n\t\t// we need to cast _pubKey to string before performing length checks, because sometimes\r\n\t\t// transaction data can have extra zeros at the end, which are cut away when\r\n\t\t// casting string from bytes\r\n\t\tstring memory pubKeyString = string(_pubkey);\r\n\r\n\t\trequire (bytes(pubKeyString).length > 50 && bytes(pubKeyString).length < 70);\r\n\t\trequire (checkAddress(_pubkey));\r\n\r\n\t\trequire(tokenFallback(_token).transferFrom(_from, this, _value));\r\n\t\tburned[_from].pubkey.push(pubKeyString); // pushing pubkey and value, to allow 1 user burn n times to m pubkeys\r\n\t\tburned[_from].amount.push(_value);\r\n\t\temit Burn(_from, _pubkey, _value, ++burnCount, AEdeliveryBatchCounter);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction countUpDeliveryBatch()\r\n\t\tpublic onlyAEdmin\r\n\t\t{\r\n\t\t\tbatchTimes[AEdeliveryBatchCounter].blockNumber = block.number;\r\n\t\t\tbatchTimes[AEdeliveryBatchCounter].eventCount = burnCount;\r\n\t\t\t++AEdeliveryBatchCounter;\r\n\t\t}\r\n\r\n\tevent Burn(address indexed _from, bytes _pubkey, uint256 _value, uint256 _count, uint16 indexed _deliveryPeriod);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"AEdeliveryBatchCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"burnCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"str\",\"type\":\"bytes\"}],\"name\":\"checkAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"countUpDeliveryBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_pubkey\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"name\":\"batchTimes\",\"outputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"eventCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AEToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AEdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_AEdmin\",\"type\":\"address\"},{\"name\":\"_AEToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_pubkey\",\"type\":\"bytes\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_count\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_deliveryPeriod\",\"type\":\"uint16\"}],\"name\":\"Burn\",\"type\":\"event\"}]","ContractName":"TokenBurner","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000eb31d878b60bac00f5a8888fe6ca43abe546c7e80000000000000000000000005ca9a71b1d01849c0a95490cc00559717fcf0d1d","Library":"","SwarmSource":"bzzr://f8d5aecce6dbc1818575b48d3973735787c33b16841468a3eeb3a352c286a5f4"}]}