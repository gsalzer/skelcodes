{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\ncontract ErcInterface {\r\n    function transferFrom(address _from, address _to, uint256 _value) public;\r\n    function transfer(address _to, uint256 _value) public;\r\n    function balanceOf(address _who) public returns(uint256);\r\n}\r\n\r\ncontract Ownable {\r\n    \r\n    address public owner;\r\n\r\n    /**\r\n     * The address whcih deploys this contrcat is automatically assgined ownership.\r\n     * */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * Functions with this modifier can only be executed by the owner of the contract. \r\n     * */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n\r\n    /**\r\n    * Transfers ownership to new Ethereum address. This function can only be called by the \r\n    * owner.\r\n    * @param _newOwner the address to be granted ownership.\r\n    **/\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != 0x0);\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ncontract FOXTWidget is Ownable {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    ErcInterface public constant FOXT = ErcInterface(0xFbe878CED08132bd8396988671b450793C44bC12); \r\n    \r\n    bool public contractFrozen;\r\n    \r\n    uint256 private rate;\r\n    uint256 private purchaseTimeLimit;\r\n    uint256 private txFee;\r\n\r\n    mapping (address => uint256) private purchaseDeadlines;\r\n    mapping (address => uint256) private maxPurchase;\r\n    mapping (address => bool) private isBotAddress;\r\n    \r\n    \r\n    address[] private botsOwedTxFees;\r\n    uint256 private indexOfOwedTxFees;\r\n    \r\n    event TokensPurchased(address indexed by, address indexed recipient, uint256 total, uint256 value);\r\n    event RateUpdated(uint256 latestRate);\r\n    \r\n    constructor() public {\r\n        purchaseTimeLimit = 10 minutes;\r\n        txFee = 300e14; //same as 0.03 ETH.\r\n        contractFrozen = false;\r\n        indexOfOwedTxFees = 0;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the owner to freeze / unfreeze the contract \r\n     * */\r\n    function toggleFreeze() public onlyOwner {\r\n        contractFrozen = !contractFrozen;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the owner of the contract to add a bot address\r\n     * */\r\n    function addBotAddress(address _botAddress) public onlyOwner {\r\n        require(!isBotAddress[_botAddress]);\r\n        isBotAddress[_botAddress] = true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the owner of the contract to remove a bot address \r\n     */\r\n    function removeBotAddress(address _botAddress) public onlyOwner  {\r\n        require(isBotAddress[_botAddress]);\r\n        isBotAddress[_botAddress] = false;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the owner to change the time limit which buyers will have once they\r\n     * have been permitted to buy tokens with the contract update. \r\n     * \r\n     * @param _newPurchaseTimeLimit The new time limit which buyers will have to \r\n     * make a purchase. \r\n     * \r\n     * @return true if the function exeutes successfully, false otherwise\r\n     * */\r\n    function changeTimeLimitMinutes(uint256 _newPurchaseTimeLimit) public onlyOwner returns(bool) {\r\n        require(_newPurchaseTimeLimit > 0 && _newPurchaseTimeLimit != purchaseTimeLimit);\r\n        purchaseTimeLimit = _newPurchaseTimeLimit;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the owner to change the fixed transaction fee which will be charged \r\n     * to the buyers. \r\n     * \r\n     * @param _newTxFee The new transaction fee which will be charged to the buyers. \r\n     * \r\n     * @return true if the function exeutes successfully, false otherwise\r\n     * */\r\n    function changeTxFee(uint256 _newTxFee) public onlyOwner returns(bool) {\r\n        require(_newTxFee != txFee);\r\n        txFee = _newTxFee;\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Functions with this modifier can only be invoked by either one of the bot  \r\n     * addresses or the owner of the contract. \r\n     * */\r\n    modifier restricted {\r\n        require(isBotAddress[msg.sender] || msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the bot or the owner of the contract to update the contract (will \r\n     * usuall by invoked right before a buyer will make a purchase). \r\n     * \r\n     * @param _rate The rate at which the FOXT tokens are shwon on Coin Market Cap.\r\n     * @param _purchaser The address of the buyer.\r\n     * @param _ethInvestment The total amoun of ETH the buyer has specified he \r\n     * or she will send to the contract. \r\n     * \r\n     * @return true if the function exeutes successfully, false otherwise\r\n     * */\r\n    function updateContract(uint256 _rate, address _purchaser, uint256 _ethInvestment) public restricted returns(bool){\r\n        require(!contractFrozen);\r\n        require(_purchaser != address(0x0));\r\n        require(_ethInvestment > 0);\r\n        require(_rate != 0);\r\n        if(_rate != rate) {\r\n            rate = _rate;\r\n        }\r\n        maxPurchase[_purchaser] = _ethInvestment;\r\n        purchaseDeadlines[_purchaser] = now.add(purchaseTimeLimit);\r\n        botsOwedTxFees.push(msg.sender);\r\n        emit RateUpdated(rate);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @return The purchaseTimeLimit\r\n     * */\r\n    function getTimePurchase() public view returns(uint256) {\r\n        return purchaseTimeLimit;\r\n    }\r\n    \r\n        /**\r\n     * @return The current rate shown on Coin Market Cap. \r\n     * */\r\n    function getRate() public view returns(uint256) {\r\n        return rate;\r\n    }\r\n    \r\n    \r\n    \r\n    /**\r\n     * Checks if a purchaser is permitted to make a purchase by checking \r\n     * the following conditions. 1st condition is that the bot updated the contract \r\n     * with the purcahser's address no longer than the purchase deadline ago. 2nd \r\n     * condition is that the purchaser is allowed to make an investment which is \r\n     * greater than 0. \r\n     * \r\n     * @return true if the purchaser is permitted to make a purchase, false \r\n     * otherwise.\r\n     * */\r\n    function addrCanPurchase(address _purchaser) public view returns(bool) {\r\n        return now < purchaseDeadlines[_purchaser] && maxPurchase[_purchaser] > 0;\r\n    }\r\n    \r\n\r\n    /**\r\n     * Allows users to buy FOXT tokens. For the function to execute successfully\r\n     * the following conditions must be met: 1st the purchaser must purcahse the \r\n     * tokens before the time limit is up (time limit is set when the bot updates\r\n     * the contract). 2nd the purchaser must send at least enough ETH to cover the \r\n     * txFee to cover the cost of the update, however, if the purchaser sends more \r\n     * ETH than specified in the update, the purchaser will still get FOXT tokens \r\n     * but also the remaining ETH will be refunded. \r\n     * \r\n     * @param _purchaser The address of the buyer\r\n     * \r\n     * @return true if the function exeutes successfully, false otherwise\r\n     * */\r\n    function buyTokens(address _purchaser) public payable returns(bool){\r\n        require(!contractFrozen);\r\n        require(addrCanPurchase(_purchaser));\r\n        require(msg.value > txFee);\r\n        uint256 msgVal = msg.value;\r\n        if(msgVal > maxPurchase[_purchaser]) {\r\n            msg.sender.transfer(msg.value.sub(maxPurchase[_purchaser]));\r\n            msgVal = maxPurchase[_purchaser];\r\n        }\r\n        maxPurchase[_purchaser] = 0;\r\n        msgVal = msgVal.sub(txFee);\r\n        botsOwedTxFees[indexOfOwedTxFees].transfer(txFee);\r\n        indexOfOwedTxFees = indexOfOwedTxFees.add(1);\r\n        uint256 toSend = msgVal.mul(rate);\r\n        FOXT.transfer(_purchaser, toSend);\r\n        emit TokensPurchased(msg.sender, _purchaser, toSend, msg.value);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Fallback function invokes the buyTokens function. \r\n     * */\r\n    function() public payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the owner of the contract to withdraw all ETH.\r\n     * */\r\n    function withdrawETH() public onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the owner of the contract to withdraw FOXT tokens.\r\n     * \r\n     * @param _recipient The address of the receiver.\r\n     * @param _totalTokens The number of FOXT tokens to send. \r\n     * */\r\n    function withdrawFoxt(address _recipient, uint256 _totalTokens) public onlyOwner {\r\n        FOXT.transfer(_recipient, _totalTokens);\r\n    }\r\n    \r\n    \r\n    /**\r\n     * Allows the owner of the contract to withdraw any ERC20 token.\r\n     * \r\n     * @param _tokenAddr The contract address of the ERC20 token.\r\n     * @param _recipient The address of the receiver.\r\n     * @param _totalTokens The number of tokens to send\r\n     * */\r\n    function withdrawAnyERC20(address _tokenAddr, address _recipient, uint256 _totalTokens) public onlyOwner {\r\n        ErcInterface token = ErcInterface(_tokenAddr);\r\n        token.transfer(_recipient, _totalTokens);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"toggleFreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_totalTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawAnyERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_purchaser\",\"type\":\"address\"}],\"name\":\"addrCanPurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newTxFee\",\"type\":\"uint256\"}],\"name\":\"changeTxFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimePurchase\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_totalTokens\",\"type\":\"uint256\"}],\"name\":\"withdrawFoxt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newPurchaseTimeLimit\",\"type\":\"uint256\"}],\"name\":\"changeTimeLimitMinutes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOXT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_botAddress\",\"type\":\"address\"}],\"name\":\"removeBotAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_botAddress\",\"type\":\"address\"}],\"name\":\"addBotAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_purchaser\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_purchaser\",\"type\":\"address\"},{\"name\":\"_ethInvestment\",\"type\":\"uint256\"}],\"name\":\"updateContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"latestRate\",\"type\":\"uint256\"}],\"name\":\"RateUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FOXTWidget","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cf95b4ab133181511b3355a035b5865ce1dd17fa70bf6b001c313a1f64d212ac"}]}