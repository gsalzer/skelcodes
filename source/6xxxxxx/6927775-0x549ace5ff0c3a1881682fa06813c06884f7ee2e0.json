{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n \r\n/**\r\n * Copyright 2018, Flowchain.co\r\n *\r\n * The FlowchainCoin (FLC) smart contract of private sale Round A\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n    int256 constant private INT256_MIN = -2**255;\r\n\r\n    /**\r\n    * @dev Multiplies two unsigned integers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two signed integers, reverts on overflow.\r\n    */\r\n    function mul(int256 a, int256 b) internal pure returns (int256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        require(!(a == -1 && b == INT256_MIN)); // This is the only case of overflow not detected by the check below\r\n\r\n        int256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two unsigned integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Solidity only automatically asserts when dividing by 0\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two signed integers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(int256 a, int256 b) internal pure returns (int256) {\r\n        require(b != 0); // Solidity only automatically asserts when dividing by 0\r\n        require(!(b == -1 && a == INT256_MIN)); // This is the only case of overflow\r\n\r\n        int256 c = a / b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two unsigned integers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two signed integers, reverts on overflow.\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a - b;\r\n        require((b >= 0 && c <= a) || (b < 0 && c > a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two unsigned integers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two signed integers, reverts on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns (int256) {\r\n        int256 c = a + b;\r\n        require((b >= 0 && c >= a) || (b < 0 && c < a));\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two unsigned integers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface Token {\r\n    function mintToken(address to, uint amount) external returns (bool success);  \r\n    function setupMintableAddress(address _mintable) public returns (bool success);\r\n}\r\n\r\ncontract MintableSale {\r\n    // @notice Create a new mintable sale\r\n    /// @param rate The exchange rate\r\n    /// @param fundingGoalInEthers The funding goal in ethers\r\n    /// @param durationInMinutes The duration of the sale in minutes\r\n    /// @return \r\n    function createMintableSale(uint256 rate, uint256 fundingGoalInEthers, uint durationInMinutes) external returns (bool success);\r\n}\r\n\r\ncontract EarlyTokenSale is MintableSale {\r\n    using SafeMath for uint256;\r\n    uint256 public fundingGoal;\r\n    uint256 public tokensPerEther;\r\n    uint public deadline;\r\n    address public multiSigWallet;\r\n    uint256 public amountRaised;\r\n    Token public tokenReward;\r\n    mapping(address => uint256) public balanceOf;\r\n    bool fundingGoalReached = false;\r\n    bool crowdsaleClosed = false;\r\n    address public creator;\r\n    address public addressOfTokenUsedAsReward;\r\n    bool public isFunding = false;\r\n\r\n    /* accredited investors */\r\n    mapping (address => uint256) public accredited;\r\n\r\n    event FundTransfer(address backer, uint amount);\r\n\r\n    /* Constrctor function */\r\n    function EarlyTokenSale(\r\n        address _addressOfTokenUsedAsReward\r\n    ) payable {\r\n        creator = msg.sender;\r\n        multiSigWallet = 0x9581973c54fce63d0f5c4c706020028af20ff723;\r\n        // Token Contract\r\n        addressOfTokenUsedAsReward = _addressOfTokenUsedAsReward;\r\n        tokenReward = Token(addressOfTokenUsedAsReward);\r\n        // Setup accredited investors\r\n        setupAccreditedAddress(0xec7210E3db72651Ca21DA35309A20561a6F374dd, 1000);\r\n    }\r\n\r\n    // @dev Start a new mintable sale.\r\n    // @param rate The exchange rate in ether, for example 1 ETH = 6400 FLC\r\n    // @param fundingGoalInEthers\r\n    // @param durationInMinutes\r\n    function createMintableSale(uint256 rate, uint256 fundingGoalInEthers, uint durationInMinutes) external returns (bool success) {\r\n        require(msg.sender == creator);\r\n        require(isFunding == false);\r\n        require(rate <= 6400 && rate >= 1);                   // rate must be between 1 and 6400\r\n        require(fundingGoalInEthers >= 1000);        \r\n        require(durationInMinutes >= 60 minutes);\r\n\r\n        deadline = now + durationInMinutes * 1 minutes;\r\n        fundingGoal = amountRaised + fundingGoalInEthers * 1 ether;\r\n        tokensPerEther = rate;\r\n        isFunding = true;\r\n        return true;    \r\n    }\r\n\r\n    modifier afterDeadline() { if (now > deadline) _; }\r\n    modifier beforeDeadline() { if (now <= deadline) _; }\r\n\r\n    /// @param _accredited The address of the accredited investor\r\n    /// @param _amountInEthers The amount of remaining ethers allowed to invested\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function setupAccreditedAddress(address _accredited, uint _amountInEthers) public returns (bool success) {\r\n        require(msg.sender == creator);    \r\n        accredited[_accredited] = _amountInEthers * 1 ether;\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function returns the amount of remaining ethers allowed to invested\r\n    /// @return The amount\r\n    function getAmountAccredited(address _accredited) view returns (uint256) {\r\n        uint256 amount = accredited[_accredited];\r\n        return amount;\r\n    }\r\n\r\n    function closeSale() beforeDeadline {\r\n        require(msg.sender == creator);    \r\n        isFunding = false;\r\n    }\r\n\r\n    // change creator address\r\n    function changeCreator(address _creator) external {\r\n        require(msg.sender == creator);\r\n        creator = _creator;\r\n    }\r\n\r\n    /// @dev This function returns the current exchange rate during the sale\r\n    /// @return The address of token creator\r\n    function getRate() beforeDeadline view returns (uint) {\r\n        return tokensPerEther;\r\n    }\r\n\r\n    /// @dev This function returns the amount raised in wei\r\n    /// @return The address of token creator\r\n    function getAmountRaised() view returns (uint) {\r\n        return amountRaised;\r\n    }\r\n\r\n    function () payable {\r\n        // check if we can offer the private sale\r\n        require(isFunding == true && amountRaised < fundingGoal);\r\n\r\n        // the minimum deposit is 1 ETH\r\n        uint256 amount = msg.value;        \r\n        require(amount >= 1 ether);\r\n\r\n        require(accredited[msg.sender] - amount >= 0); \r\n\r\n        multiSigWallet.transfer(amount);      \r\n        balanceOf[msg.sender] += amount;\r\n        accredited[msg.sender] -= amount;\r\n        amountRaised += amount;\r\n        FundTransfer(msg.sender, amount);\r\n\r\n        uint256 value = amount.mul(tokensPerEther);        \r\n        tokenReward.mintToken(msg.sender, value);        \r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"multiSigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"rate\",\"type\":\"uint256\"},{\"name\":\"fundingGoalInEthers\",\"type\":\"uint256\"},{\"name\":\"durationInMinutes\",\"type\":\"uint256\"}],\"name\":\"createMintableSale\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAmountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"changeCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingGoal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"accredited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addressOfTokenUsedAsReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_accredited\",\"type\":\"address\"}],\"name\":\"getAmountAccredited\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accredited\",\"type\":\"address\"},{\"name\":\"_amountInEthers\",\"type\":\"uint256\"}],\"name\":\"setupAccreditedAddress\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addressOfTokenUsedAsReward\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"backer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"}]","ContractName":"EarlyTokenSale","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000005b53f9755f82439cba66007ec7073c59e0da4a7d","Library":"","SwarmSource":"bzzr://2fe24dfbc7bf806a84fd673eac4d9edeacd916a712926fc29a3c7fc2dbdabae7"}]}