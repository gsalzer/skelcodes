{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract DateTime {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct _DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) public pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) public pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                dt.hour = getHour(timestamp);\r\n\r\n                // Minute\r\n                dt.minute = getMinute(timestamp);\r\n\r\n                // Second\r\n                dt.second = getSecond(timestamp);\r\n\r\n                // Day of week.\r\n                dt.weekday = getWeekday(timestamp);\r\n        }\r\n\r\n        function getYear(uint timestamp) public pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) public pure returns (uint8) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60 / 60) % 24);\r\n        }\r\n\r\n        function getMinute(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / 60) % 60);\r\n        }\r\n\r\n        function getSecond(uint timestamp) public pure returns (uint8) {\r\n                return uint8(timestamp % 60);\r\n        }\r\n\r\n        function getWeekday(uint timestamp) public pure returns (uint8) {\r\n                return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, 0, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, minute, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) {\r\n                uint16 i;\r\n\r\n                // Year\r\n                for (i = ORIGIN_YEAR; i < year; i++) {\r\n                        if (isLeapYear(i)) {\r\n                                timestamp += LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                timestamp += YEAR_IN_SECONDS;\r\n                        }\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                for (i = 1; i < month; i++) {\r\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n                }\r\n\r\n                // Day\r\n                timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n                // Hour\r\n                timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n                // Minute\r\n                timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n                // Second\r\n                timestamp += second;\r\n\r\n                return timestamp;\r\n        }\r\n}\r\n\r\ncontract ERC20xVariables {\r\n    address public creator;\r\n    address public lib;\r\n\r\n    uint256 constant public MAX_UINT256 = 2**256 - 1;\r\n    mapping(address => uint) public balances;\r\n    mapping(address => mapping(address => uint)) public allowed;\r\n\r\n    uint8 public constant decimals = 18;\r\n    string public name;\r\n    string public symbol;\r\n    uint public totalSupply;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    event Created(address creator, uint supply);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\ncontract ERC20x is ERC20xVariables {\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        _transferBalance(msg.sender, _to, _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(allowance >= _value);\r\n        _transferBalance(_from, _to, _value);\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferToContract(address _to, uint256 _value, bytes data) public returns (bool) {\r\n        _transferBalance(msg.sender, _to, _value);\r\n        bytes4 sig = bytes4(keccak256(\"receiveTokens(address,uint256,bytes)\"));\r\n        require(_to.call(sig, msg.sender, _value, data));\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function _transferBalance(address _from, address _to, uint _value) internal {\r\n        require(balances[_from] >= _value);\r\n        balances[_from] -= _value;\r\n        balances[_to] += _value;\r\n    }\r\n}\r\n\r\ncontract VariableSupplyToken is ERC20x {\r\n    function grant(address to, uint256 amount) public {\r\n        require(msg.sender == creator);\r\n        require(balances[to] + amount >= amount);\r\n        balances[to] += amount;\r\n        totalSupply += amount;\r\n    }\r\n\r\n    function burn(address from, uint amount) public {\r\n        require(msg.sender == creator);\r\n        require(balances[from] >= amount);\r\n        balances[from] -= amount;\r\n        totalSupply -= amount;\r\n    }\r\n}\r\n\r\ncontract OptionToken is ERC20xVariables {\r\n\r\n    constructor(string _name, string _symbol, address _lib) public {\r\n        creator = msg.sender;\r\n        lib = _lib;\r\n        name = _name;\r\n        symbol = _symbol;\r\n    }\r\n\r\n    function() public {\r\n        require(\r\n            lib.delegatecall(msg.data)\r\n        );\r\n    }\r\n}\r\n\r\n// we don't store much state here either\r\ncontract Token is VariableSupplyToken {\r\n    constructor() public {\r\n        creator = msg.sender;\r\n        name = \"Decentralized Settlement Facility Token\";\r\n        symbol = \"DSF\";\r\n\r\n        // this needs to be here to avoid zero initialization of token rights.\r\n        totalSupply = 1;\r\n        balances[0x0] = 1;\r\n    }\r\n}\r\n\r\ncontract Protocol is DateTime {\r\n    \r\n    address public lib;\r\n    ERC20x public usdERC20;\r\n    Token public protocolToken;\r\n\r\n    // We use \"flavor\" because type is a reserved word in many programming languages\r\n    enum Flavor {\r\n        Call,\r\n        Put\r\n    }\r\n\r\n    struct OptionSeries {\r\n        uint expiration;\r\n        Flavor flavor;\r\n        uint strike;\r\n    }\r\n\r\n    uint public constant DURATION = 12 hours;\r\n    uint public constant HALF_DURATION = DURATION / 2;\r\n\r\n    mapping(bytes32 => address) public seriesToken;\r\n    mapping(address => uint) public openInterest;\r\n    mapping(address => uint) public earlyExercised;\r\n    mapping(address => uint) public totalInterest;\r\n    mapping(address => mapping(address => uint)) public writers;\r\n    mapping(address => OptionSeries) public seriesInfo;\r\n    mapping(address => uint) public holdersSettlement;\r\n\r\n    bytes4 public constant GRANT = bytes4(keccak256(\"grant(address,uint256)\"));\r\n    bytes4 public constant BURN = bytes4(keccak256(\"burn(address,uint256)\"));\r\n\r\n    bytes4 public constant RECEIVE_ETH = bytes4(keccak256(\"receiveETH(address,uint256)\"));\r\n    bytes4 public constant RECEIVE_USD = bytes4(keccak256(\"receiveUSD(address,uint256)\"));\r\n\r\n    uint public deployed;\r\n\r\n    mapping(address => uint) public expectValue;\r\n    bool isAuction;\r\n\r\n    uint public constant ONE_MILLION = 1000000;\r\n\r\n    // maximum token holder rights capped at 3.7% of total supply?\r\n    // Why 3.7%?\r\n    // I could make up some fancy explanation\r\n    // and use the phrase \"byzantine fault tolerance\" somehow\r\n    // Or I could just say that 3.7% allows for a total of 27 independent actors\r\n    // that are all receiving the maximum benefit, and it solves all the other\r\n    // issues of disincentivizing centralization and \"rich get richer\" mechanics, so I chose 27 'cause it just has a nice \"decentralized\" feel to it.\r\n    // 21 would have been fine, as few as ten probably would have been ok 'cause people can just pool anyways\r\n    // up to a thousand or so probably wouldn't have hurt either.\r\n    // In the end it really doesn't matter as long as the game ends up being played fairly.\r\n\r\n    // I'm sure someone will take my system and parameterize it differently at some point and bill it as a totally new product.\r\n    uint public constant PREFERENCE_MAX = 0.037 ether;\r\n\r\n    constructor(address _usd) public {\r\n        lib = new VariableSupplyToken();\r\n        protocolToken = new Token();\r\n        usdERC20 = ERC20x(_usd);\r\n        deployed = now;\r\n    }\r\n\r\n    function() public payable {\r\n        revert();\r\n    }\r\n\r\n    event SeriesIssued(address series);\r\n\r\n    function issue(uint expiration, Flavor flavor, uint strike) public returns (address) {\r\n        require(strike >= 20 ether);\r\n        require(strike % 20 ether == 0);\r\n        require(strike <= 10000 ether);\r\n\r\n        // require expiration to be at noon UTC\r\n        require(expiration % 86400 == 43200);\r\n\r\n        // valid expirations: 7n + 1 where n = (unix timestamp / 86400)\r\n        require(((expiration / 86400) + 2) % 7 == 0);\r\n        require(expiration > now + 12 hours);\r\n        require(expiration < now + 365 days);\r\n\r\n        // compute the symbol based on datetime library\r\n        _DateTime memory exp = parseTimestamp(expiration);\r\n\r\n        uint strikeCode = strike / 1 ether;\r\n\r\n        string memory name = _name(exp, flavor, strikeCode);\r\n\r\n        string memory symbol = _symbol(exp, flavor, strikeCode);\r\n\r\n        bytes32 id = _seriesHash(expiration, flavor, strike);\r\n        require(seriesToken[id] == address(0));\r\n        address series = new OptionToken(name, symbol, lib);\r\n        seriesToken[id] = series;\r\n        seriesInfo[series] = OptionSeries(expiration, flavor, strike);\r\n        emit SeriesIssued(series);\r\n        return series;\r\n    }\r\n\r\n    function _name(_DateTime exp, Flavor flavor, uint strikeCode) private pure returns (string) {\r\n        return string(\r\n            abi.encodePacked(\r\n                _monthName(exp.month),\r\n                \" \",\r\n                uint2str(exp.day),\r\n                \" \",\r\n                uint2str(strikeCode),\r\n                \"-\",\r\n                flavor == Flavor.Put ? \"PUT\" : \"CALL\"\r\n            )\r\n        );\r\n    }\r\n\r\n    function _symbol(_DateTime exp, Flavor flavor, uint strikeCode) private pure returns (string) {\r\n        uint monthChar = 64 + exp.month;\r\n        if (flavor == Flavor.Put) {\r\n            monthChar += 12;\r\n        }\r\n\r\n        uint dayChar = 65 + (exp.day - 1) / 7;\r\n\r\n        return string(\r\n            abi.encodePacked(\r\n                \"∆\",\r\n                byte(monthChar),\r\n                byte(dayChar),\r\n                uint2str(strikeCode)\r\n            )\r\n        );\r\n    }\r\n\r\n    function open(address _series, uint amount) public payable returns (bool) {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        bytes32 id = _seriesHash(series.expiration, series.flavor, series.strike);\r\n        require(seriesToken[id] == _series);\r\n        require(_series.call(GRANT, msg.sender, amount));\r\n\r\n        require(now < series.expiration);\r\n\r\n        if (series.flavor == Flavor.Call) {\r\n            require(msg.value == amount);\r\n        } else {\r\n            require(msg.value == 0);\r\n            uint escrow = amount * series.strike;\r\n            require(escrow / amount == series.strike);\r\n            escrow /= 1 ether;\r\n            require(usdERC20.transferFrom(msg.sender, this, escrow));\r\n        }\r\n        \r\n        openInterest[_series] += amount;\r\n        totalInterest[_series] += amount;\r\n        writers[_series][msg.sender] += amount;\r\n\r\n        return true;\r\n    }\r\n\r\n    function close(address _series, uint amount) public {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        require(now < series.expiration);\r\n        require(openInterest[_series] >= amount);\r\n        require(_series.call(BURN, msg.sender, amount));\r\n\r\n        require(writers[_series][msg.sender] >= amount);\r\n        writers[_series][msg.sender] -= amount;\r\n        openInterest[_series] -= amount;\r\n        totalInterest[_series] -= amount;\r\n        \r\n        if (series.flavor == Flavor.Call) {\r\n            msg.sender.transfer(amount);\r\n        } else {\r\n            require(\r\n                usdERC20.transfer(msg.sender, amount * series.strike / 1 ether));\r\n        }\r\n    }\r\n    \r\n    function exercise(address _series, uint amount) public payable {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        require(now < series.expiration);\r\n        require(openInterest[_series] >= amount);\r\n        require(_series.call(BURN, msg.sender, amount));\r\n\r\n        uint usd = amount * series.strike;\r\n        require(usd / amount == series.strike);\r\n        usd /= 1 ether;\r\n\r\n        openInterest[_series] -= amount;\r\n        earlyExercised[_series] += amount;\r\n\r\n        if (series.flavor == Flavor.Call) {\r\n            msg.sender.transfer(amount);\r\n            require(msg.value == 0);\r\n            require(usdERC20.transferFrom(msg.sender, this, usd));\r\n        } else {\r\n            require(msg.value == amount);\r\n            require(usdERC20.transfer(msg.sender, usd));\r\n        }\r\n    }\r\n    \r\n    function receive() public payable {\r\n        require(expectValue[msg.sender] == msg.value);\r\n        expectValue[msg.sender] = 0;\r\n    }\r\n\r\n    function bid(address _series, uint amount) public payable {\r\n\r\n        require(isAuction == false);\r\n        isAuction = true;\r\n\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        uint start = series.expiration;\r\n        uint time = now + _timePreference(msg.sender);\r\n\r\n        require(time > start);\r\n        require(time < start + DURATION);\r\n\r\n        uint elapsed = time - start;\r\n\r\n        amount = _min(amount, openInterest[_series]);\r\n\r\n        if ((now - deployed) / 1 weeks < 8) {\r\n            _grantReward(msg.sender, amount);\r\n        }\r\n\r\n        openInterest[_series] -= amount;\r\n\r\n        uint offer;\r\n        uint givGet;\r\n        bool result;\r\n\r\n        if (series.flavor == Flavor.Call) {\r\n            require(msg.value == 0);\r\n\r\n            offer = (series.strike * DURATION) / elapsed;\r\n            givGet = offer * amount / 1 ether;\r\n            holdersSettlement[_series] += givGet - amount * series.strike / 1 ether;\r\n\r\n            bool hasFunds = usdERC20.balanceOf(msg.sender) >= givGet && usdERC20.allowance(msg.sender, this) >= givGet;\r\n\r\n            if (hasFunds) {\r\n                msg.sender.transfer(amount);\r\n            } else {\r\n                result = msg.sender.call.value(amount)(RECEIVE_ETH, _series, amount);\r\n                require(result);\r\n            }\r\n\r\n            require(usdERC20.transferFrom(msg.sender, this, givGet));\r\n        } else {\r\n            offer = (DURATION * 1 ether * 1 ether) / (series.strike * elapsed);\r\n            givGet = (amount * 1 ether) / offer;\r\n\r\n            holdersSettlement[_series] += amount * series.strike / 1 ether - givGet;\r\n            require(usdERC20.transfer(msg.sender, givGet));\r\n\r\n            if (msg.value == 0) {\r\n                require(expectValue[msg.sender] == 0);\r\n                expectValue[msg.sender] = amount;\r\n\r\n                result = msg.sender.call(RECEIVE_USD, _series, givGet);\r\n                require(result);\r\n                require(expectValue[msg.sender] == 0);\r\n            } else {\r\n                require(msg.value >= amount);\r\n                msg.sender.transfer(msg.value - amount);\r\n            }\r\n        }\r\n\r\n        isAuction = false;\r\n    }\r\n\r\n    function redeem(address _series) public {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n\r\n        require(now > series.expiration + DURATION);\r\n\r\n        uint unsettledPercent = openInterest[_series] * 1 ether / totalInterest[_series];\r\n        uint exercisedPercent = (totalInterest[_series] - openInterest[_series]) * 1 ether / totalInterest[_series];\r\n        uint owed;\r\n\r\n        if (series.flavor == Flavor.Call) {\r\n            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;\r\n            if (owed > 0) {\r\n                msg.sender.transfer(owed);\r\n            }\r\n\r\n            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;\r\n            owed = owed * series.strike / 1 ether;\r\n            if (owed > 0) {\r\n                require(usdERC20.transfer(msg.sender, owed));\r\n            }\r\n        } else {\r\n            owed = writers[_series][msg.sender] * unsettledPercent / 1 ether;\r\n            owed = owed * series.strike / 1 ether;\r\n            if (owed > 0) {\r\n                require(usdERC20.transfer(msg.sender, owed));\r\n            }\r\n\r\n            owed = writers[_series][msg.sender] * exercisedPercent / 1 ether;\r\n            if (owed > 0) {\r\n                msg.sender.transfer(owed);\r\n            }\r\n        }\r\n\r\n        writers[_series][msg.sender] = 0;\r\n    }\r\n\r\n    function settle(address _series) public {\r\n        OptionSeries memory series = seriesInfo[_series];\r\n        require(now > series.expiration + DURATION);\r\n\r\n        uint bal = ERC20x(_series).balanceOf(msg.sender);\r\n        require(_series.call(BURN, msg.sender, bal));\r\n\r\n        uint percent = bal * 1 ether / (totalInterest[_series] - earlyExercised[_series]);\r\n        uint owed = holdersSettlement[_series] * percent / 1 ether;\r\n        require(usdERC20.transfer(msg.sender, owed));\r\n    }\r\n\r\n    function _timePreference(address from) public view returns (uint) {\r\n        return (_unsLn(_preference(from) * 1000000 + 1 ether) * 171) / 1 ether;\r\n    }\r\n\r\n    function _grantReward(address to, uint amount) private {\r\n        uint percentOfMax = _preference(to) * 1 ether / PREFERENCE_MAX;\r\n        require(percentOfMax <= 1 ether);\r\n        uint percentGrant = 1 ether - percentOfMax;\r\n\r\n\r\n        uint elapsed = (now - deployed) / 1 weeks;\r\n        elapsed = _min(elapsed, 7);\r\n        uint div = 10**elapsed;\r\n        uint reward = percentGrant * (amount * (ONE_MILLION / div)) / 1 ether;\r\n\r\n        require(address(protocolToken).call(GRANT, to, reward));\r\n    }\r\n\r\n    function _preference(address from) public view returns (uint) {\r\n        return _min(\r\n            protocolToken.balanceOf(from) * 1 ether / protocolToken.totalSupply(),\r\n            PREFERENCE_MAX\r\n        );\r\n    }\r\n\r\n    function _min(uint a, uint b) pure public returns (uint) {\r\n        if (a > b)\r\n            return b;\r\n        return a;\r\n    }\r\n\r\n    function _max(uint a, uint b) pure public returns (uint) {\r\n        if (a > b)\r\n            return a;\r\n        return b;\r\n    }\r\n    \r\n    function _seriesHash(uint expiration, Flavor flavor, uint strike) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(expiration, flavor, strike));\r\n    }\r\n\r\n    function _monthName(uint month) public pure returns (string) {\r\n        string[12] memory names = [\"JAN\", \"FEB\", \"MAR\", \"APR\", \"MAY\", \"JUN\", \"JUL\", \"AUG\", \"SEP\", \"OCT\", \"NOV\", \"DEC\"];\r\n        return names[month-1];\r\n    }\r\n\r\n    function _unsLn(uint x) pure public returns (uint log) {\r\n        log = 0;\r\n        \r\n        // not a true ln function, we can't represent the negatives\r\n        if (x < 1 ether)\r\n            return 0;\r\n\r\n        while (x >= 1.5 ether) {\r\n            log += 0.405465 ether;\r\n            x = x * 2 / 3;\r\n        }\r\n        \r\n        x = x - 1 ether;\r\n        uint y = x;\r\n        uint i = 1;\r\n\r\n        while (i < 10) {\r\n            log += (y / i);\r\n            i = i + 1;\r\n            y = y * x / 1 ether;\r\n            log -= (y / i);\r\n            i = i + 1;\r\n            y = y * x / 1 ether;\r\n        }\r\n         \r\n        return(log);\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"open\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"protocolToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GRANT\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"}],\"name\":\"_unsLn\",\"outputs\":[{\"name\":\"log\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getHour\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"seriesToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RECEIVE_USD\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"flavor\",\"type\":\"uint8\"},{\"name\":\"strike\",\"type\":\"uint256\"}],\"name\":\"_seriesHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getWeekday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"earlyExercised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"writers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"},{\"name\":\"minute\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RECEIVE_ETH\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HALF_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"_preference\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getSecond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"_max\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"},{\"name\":\"minute\",\"type\":\"uint8\"},{\"name\":\"second\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lib\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"flavor\",\"type\":\"uint8\"},{\"name\":\"strike\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_MILLION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"month\",\"type\":\"uint256\"}],\"name\":\"_monthName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receive\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"isLeapYear\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"_min\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"expectValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"_timePreference\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint256\"}],\"name\":\"leapYearsBefore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"getDaysInMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PREFERENCE_MAX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BURN\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"seriesInfo\",\"outputs\":[{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"flavor\",\"type\":\"uint8\"},{\"name\":\"strike\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"holdersSettlement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"exercise\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_series\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"openInterest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_usd\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"series\",\"type\":\"address\"}],\"name\":\"SeriesIssued\",\"type\":\"event\"}]","ContractName":"Protocol","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000089d24a6b4ccb1b6faa2625fe562bdd9a23260359","Library":"","SwarmSource":"bzzr://3b525d5fd225801b85d16785edca710e13aa9033f451cc3c8966c488d341decc"}]}