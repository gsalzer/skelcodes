{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.7;\r\ncontract MobaBase {\r\n    address public owner = 0x0;\r\n    bool public isLock = false;\r\n    constructor ()  public  {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    event transferToOwnerEvent(uint256 price);\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner,\"only owner can call this function\");\r\n        _;\r\n    }\r\n    \r\n    modifier notLock {\r\n        require(isLock == false,\"contract current is lock status\");\r\n        _;\r\n    }\r\n    \r\n    modifier msgSendFilter() {\r\n        address addr = msg.sender;\r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size <= 0,\"address must is not contract\");\r\n        require(msg.sender == tx.origin, \"msg.sender must equipt tx.origin\");\r\n        _;\r\n    }\r\n    \r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        if (newOwner != address(0)) {\r\n            owner = newOwner;\r\n        }\r\n    }\r\n    \r\n    function transferToOwner()    \r\n    onlyOwner \r\n    msgSendFilter \r\n    public {\r\n        uint256 totalBalace = address(this).balance;\r\n        owner.transfer(totalBalace);\r\n        emit transferToOwnerEvent(totalBalace);\r\n    }\r\n    \r\n    function updateLock(bool b) onlyOwner public {\r\n        \r\n        require(isLock != b,\" updateLock new status == old status\");\r\n        isLock = b;\r\n    }\r\n    \r\n   \r\n}\r\n\r\n\r\ncontract IRandomUtil{\r\n     function getBaseRandom() public view returns (bytes32);\r\n     function addContractAddr() public;\r\n}\r\n\r\ncontract BRRandom {\r\n    \r\n    IRandomUtil private baseRandom;\r\n    address internal mainnet_random_addr = 0x31E0d4b2d086e8Bfc25A10bE133dEc09cb5284d2;\r\n    \r\n    function initRandom (address addr) internal  {\r\n        \r\n        require(baseRandom == address(0x0),\"BRRandom has been init!\");\r\n        baseRandom = IRandomUtil(addr);\r\n        baseRandom.addContractAddr();\r\n        require(getBaseRandom() != 0,\"random init has error\");\r\n    }\r\n    \r\n    function getBaseRandom() public view returns (bytes32) {\r\n         return baseRandom.getBaseRandom();\r\n     }\r\n}\r\n\r\n///////////////////////////////////////////////yaoq邀请///////////////////////////\r\n\r\ncontract IInviteData{\r\n    \r\n    function GetAddressByName(bytes32 name) public view returns (address);\r\n}\r\ncontract BRInvite{\r\n    \r\n    uint private inviteRate = 10;\r\n    IInviteData public mInviteData;\r\n\r\n    address internal mainnet_invite_addr = 0x008796E9e3b15869D444B8AabdA0d3ea7eEafDEa96;\r\n    \r\n    function initInviteAddr (address addr,uint rate) internal  {\r\n        \r\n        require(mInviteData == address(0x0),\"BRInvite has been init!\");\r\n        mInviteData = IInviteData(addr);\r\n        inviteRate  = rate;\r\n    }\r\n    \r\n    function GetAddressByName(bytes32 name) public view returns (address) {\r\n         return mInviteData.GetAddressByName(name);\r\n    }\r\n    \r\n    \r\n   function getInviteRate() public view returns (uint) {\r\n       return inviteRate;\r\n   }\r\n}\r\ncontract IConfigData {\r\n   function getPrice() public view returns (uint256);\r\n   function getWinRate(uint8 winCount) public pure returns (uint);\r\n   function getOverRate(uint8 winCount) public pure returns (uint);\r\n   function getPumpRate() public view returns(uint8);\r\n   function getBaseRandom() public returns (bytes32);\r\n   function GetAddressByName(bytes32 name) public view returns (address);\r\n   function getInviteRate() public view returns (uint);\r\n   function loseHandler(address addr,uint8 wincount) public ;\r\n}\r\n\r\ncontract IERC20Token {\r\n    function name() public view returns (string) ;\r\n    function symbol() public view returns (string); \r\n    function decimals() public view returns (uint8); \r\n    function totalSupply() public view returns (uint256); \r\n    function balanceOf(address _owner) public view returns (uint256);\r\n    function allowance(address _owner, address _spender) public view returns (uint256);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\ncontract ConvertUtil{\r\n    \r\n     function bytesToUint(bytes b) internal pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i<b.length;i++){\r\n            number = number + uint(b[i])*(2**(8*(b.length-(i+1))));\r\n        }\r\n        return number;\r\n    }\r\n    \r\n   function slice(bytes memory data,uint start,uint len) internal pure returns(bytes){\r\n      bytes memory b=new bytes(len);\r\n      for(uint i=0;i<len;i++){\r\n          b[i]=data[i+start];\r\n      }\r\n      return b;\r\n  }\r\n    \r\n    function stringToBytes32( bytes source) internal pure returns (bytes32 result) {\r\n  \r\n        if (source.length == 0) {\r\n            return 0x0;\r\n        }\r\n    \r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n    \r\n    function isNotContract(address addr) internal view returns (bool) {\r\n        \r\n        uint size;\r\n        assembly { size := extcodesize(addr) }\r\n        require(size <= 0,\"address must is not contract\");\r\n        \r\n        if(size <= 0)\r\n            return true;\r\n        return false;\r\n    }\r\n}\r\n\r\ncontract BRBasketballTokenControl is MobaBase,ConvertUtil{\r\n    \r\n    Winner public mWinner;\r\n\r\n    uint gameIndex;\r\n    IConfigData public mNewConfig;\r\n    IConfigData public mConfig = IConfigData(0x00e04c5271ee336cc7b499a2765a752f3f99e65fee);\r\n    IERC20Token public token  =  IERC20Token(0x007a6eBE5Cc20DA8655640fC1112522367569F2114);\r\n\r\n    constructor(address config,address tokenAddr) public {\r\n        mConfig = IConfigData(config);\r\n        if(token != address(0)){\r\n            token   = IERC20Token(tokenAddr);\r\n        }\r\n        startNewGame();\r\n    }\r\n    event pkEvent(address winAddr,address pkAddr,bytes32 pkInviteName,uint winRate,uint overRate,uint curWinRate,uint curOverRate,bool pkIsWin,uint256 price);\r\n    event gameOverEvent(uint gameIndex,address winAddr,uint256 price,uint256 totalBalace);\r\n    struct Winner {\r\n        uint8 num;\r\n        uint8 winCount;\r\n        address addr;\r\n    }\r\n    \r\n    function updateConfig(address newAddr)\r\n    onlyOwner \r\n    public{\r\n        mNewConfig = IConfigData(newAddr);\r\n    }\r\n    \r\n\r\n    \r\n    ////////////////////////////////////////////////////////\r\n    // handle logic gate after receive Token\r\n    ////////////////////////////////////////////////////////\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\r\n       \r\n        IERC20Token t = IERC20Token(_token);\r\n        require(_token == address(token),\"token is error\" );\r\n        require(_from == tx.origin,  \"token from must equal tx.origin\");\r\n        require(isNotContract(_from),\"token from  is not Contract\");\r\n        require(_value ==  mConfig.getPrice(),\"value is error\" );\r\n        require(t.transferFrom(_from, this, _value),\"transferFrom has error\");\r\n\r\n        bytes memory inviteBytes = slice(_extraData,0,_extraData.length-1);\r\n        bytes memory numBytes = slice(_extraData,_extraData.length-1,1);\r\n        uint8  num = uint8(bytesToUint(numBytes));\r\n        bytes32 inviteName = stringToBytes32(inviteBytes);\r\n        PK(_from,num,inviteName);\r\n    }\r\n    \r\n    \r\n\r\n    function PK(address pkAddr,uint8 num,bytes32 name) \r\n    notLock\r\n    private  {\r\n        \r\n        uint winRate  = mConfig.getWinRate(mWinner.winCount);\r\n\r\n        uint curWinRate ; uint curOverRate;\r\n        (curWinRate,curOverRate) = getRandom(100);\r\n        \r\n        inviteHandler(name);\r\n        address oldWinAddr = mWinner.addr;\r\n        if(mWinner.addr == address(0) ) {\r\n            mWinner = Winner(num,0,pkAddr);\r\n        }\r\n        else if( winRate < curWinRate ) {\r\n            mWinner = Winner(num,1,pkAddr);\r\n        }\r\n        else{\r\n       \r\n            mWinner.winCount = mWinner.winCount + 1;\r\n        }\r\n        bool pkIsWin = (pkAddr == mWinner.addr);\r\n        uint overRate = mConfig.getOverRate(mWinner.winCount);\r\n        emit pkEvent(mWinner.addr,pkAddr,name, winRate, overRate, curWinRate, curOverRate,pkIsWin, mConfig.getPrice());\r\n        if(oldWinAddr != address(0) && curOverRate < overRate  ) {\r\n        \r\n          require(mWinner.addr != address(0),\"Winner.addr is null\");\r\n          \r\n          uint pumpRate = mConfig.getPumpRate();\r\n          uint totalBalace = token.balanceOf(address(this));\r\n          \r\n          uint giveToOwn   = totalBalace * pumpRate / 100;\r\n          uint giveToActor = totalBalace - giveToOwn;\r\n          \r\n          token.transfer(owner,giveToOwn);\r\n          token.transfer(mWinner.addr,giveToActor);\r\n            \r\n         emit gameOverEvent(gameIndex, mWinner.addr,mConfig.getPrice(),giveToActor);\r\n          startNewGame();\r\n        }\r\n    }\r\n    \r\n    function startNewGame() private {\r\n        \r\n        gameIndex++;\r\n        mWinner = Winner(0,1,address(0));\r\n        if(mNewConfig != address(0) && mNewConfig != mConfig){\r\n            mConfig = mNewConfig;\r\n        }\r\n    }\r\n    \r\n    function inviteHandler(bytes32 inviteName) private {\r\n        \r\n        if(mConfig == address(0)) {\r\n          return ;\r\n        }\r\n        if( mConfig.getInviteRate() <= 0 ){\r\n            return;\r\n        }\r\n        address inviteAddr = mConfig.GetAddressByName(inviteName);\r\n        if(inviteAddr != address(0)) {\r\n           uint giveToToken   = mConfig.getPrice() * mConfig.getInviteRate() / 100;\r\n           token.transfer(inviteAddr,giveToToken);\r\n        }\r\n    }\r\n    function getRandom(uint maxNum) private returns(uint,uint) {\r\n     \r\n        bytes32 curRandom = mConfig.getBaseRandom();\r\n        \r\n        curRandom = keccak256(abi.encodePacked(tx.origin,now,tx.gasprice,curRandom,block.timestamp ,block.number, block.difficulty,((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) ));\r\n\r\n        uint value1 = (uint(curRandom) % maxNum);\r\n        curRandom  = keccak256(abi.encodePacked(tx.origin,now,tx.gasprice,curRandom,value1,block.timestamp ,block.number, block.difficulty,((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) ));\r\n        uint value2 = (uint(curRandom) % maxNum);\r\n       \r\n        return (value1,value2);\r\n    }\r\n    \r\n    function getGameInfo() public view returns (uint index,uint price,uint256 balace, \r\n                                          uint winNum,uint winCount,address WinAddr,uint winRate,uint winOverRate,\r\n                                          uint pkOverRate\r\n                                          ){\r\n        uint curbalace    =  token.balanceOf(address(this));\r\n        uint winnernum   = mWinner.num;\r\n        uint winnercount = mWinner.winCount;\r\n        address winneraddr  = mWinner.addr;\r\n        uint curWinRate  = mConfig.getWinRate(mWinner.winCount);\r\n        uint curOverRate = mConfig.getOverRate(mWinner.winCount);\r\n        uint curPkOverRate= mConfig.getOverRate(1);\r\n        return (gameIndex, mConfig.getPrice(), curbalace,\r\n                winnernum,winnercount,winneraddr,curWinRate,curOverRate,\r\n                curPkOverRate);\r\n    }\r\n    function () payable public {\r\n        require(msg.value == 0 );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mWinner\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint8\"},{\"name\":\"winCount\",\"type\":\"uint8\"},{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"balace\",\"type\":\"uint256\"},{\"name\":\"winNum\",\"type\":\"uint256\"},{\"name\":\"winCount\",\"type\":\"uint256\"},{\"name\":\"WinAddr\",\"type\":\"address\"},{\"name\":\"winRate\",\"type\":\"uint256\"},{\"name\":\"winOverRate\",\"type\":\"uint256\"},{\"name\":\"pkOverRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferToOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAddr\",\"type\":\"address\"}],\"name\":\"updateConfig\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mNewConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"b\",\"type\":\"bool\"}],\"name\":\"updateLock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"config\",\"type\":\"address\"},{\"name\":\"tokenAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pkAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pkInviteName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"winRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"overRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"curWinRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"curOverRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pkIsWin\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"pkEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"gameIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalBalace\",\"type\":\"uint256\"}],\"name\":\"gameOverEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"transferToOwnerEvent\",\"type\":\"event\"}]","ContractName":"BRBasketballTokenControl","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e04c5271ee336cc7b499a2765a752f3f99e65fee0000000000000000000000007a6ebe5cc20da8655640fc1112522367569f2114","Library":"","SwarmSource":"bzzr://f3ad4991fbb46f0b7b19ba85d5e5d7761afa753cbf368650cef6dc2c0cbe3586"}]}