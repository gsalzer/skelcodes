{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net\r\n *\r\n * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt\r\n * \r\n ** Code Modified by : TokenMagic\r\n ** Change Log: \r\n *** Solidity version upgraded from 0.4.8 to 0.4.23\r\n *** Functions Added: setPresaleParticipantWhitelist, setFreezeEnd, getInvestorsCount\r\n */\r\n\r\n\r\npragma solidity ^0.4.23;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract Haltable is Ownable {\r\n  bool public halted;\r\n\r\n  modifier stopInEmergency {\r\n    require(!halted);\r\n    _;\r\n  }\r\n\r\n  modifier stopNonOwnersInEmergency {\r\n    require(!halted && msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyInEmergency {\r\n    require(halted);\r\n    _;\r\n  }\r\n\r\n  // called by the owner on emergency, triggers stopped state\r\n  function halt() external onlyOwner {\r\n    halted = true;\r\n  }\r\n\r\n  // called by the owner on end of emergency, returns to normal state\r\n  function unhalt() external onlyOwner onlyInEmergency {\r\n    halted = false;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract HoardCrowdsale {\r\n    function invest(address addr,uint tokenAmount) public payable {\r\n    }\r\n}\r\nlibrary SafeMathLib {\r\n\r\n  function times(uint a, uint b) public pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n  \r\n}\r\n\r\n\r\ncontract HoardPresale is Ownable {\r\n\r\n  using SafeMathLib for uint;\r\n  \r\n  /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\r\n  mapping (address => bool) public presaleParticipantWhitelist;\r\n  \r\n  /** Who are our investors */\r\n  address[] public investors;\r\n  mapping (address => bool) private investorsMapping;\r\n\r\n  /** How much they have invested */\r\n  mapping(address => uint) public balances;\r\n  \r\n  /** A mapping of buyers and their amounts of total tokens due */\r\n  mapping(address => uint256) public tokenDue;\r\n\r\n  /** When our refund freeze is over (UNIX timestamp) */\r\n  uint public freezeEndsAt;\r\n  \r\n  /* How many wei of funding pre-sale have raised */\r\n  uint public weiRaised = 0;\r\n\r\n  /** Maximum pre-sale ETH fund limit in Wei  */\r\n  uint public maxFundLimit = 16000000000000000000000; //16000 ETH\r\n  \r\n  /** Our ICO contract where we will move the funds */\r\n  HoardCrowdsale public crowdsale;\r\n\r\n  /**\r\n  * Define pricing schedule using tranches.\r\n  */\r\n  struct Tranche {\r\n    // Amount in weis when this tranche becomes active\r\n    uint amount;\r\n    // How many tokens per satoshi you will get while this tranche is active\r\n    uint price;\r\n  }\r\n  \r\n  // Store tranches in a fixed array, so that it can be seen in a blockchain explorer\r\n  // Tranche 0 is always (0, 0)\r\n  // (TODO: change this when we confirm dynamic arrays are explorable)\r\n  //\r\n  /* Calculations made by $500/ETH as rate */\r\n  /*\r\n  0 to 114 ETH = 120000000000000 WEI = 0.00012 ETH\r\n  114 ETH to 10000 ETH = 142857142857500 WEI = 0.0001428571428575 ETH\r\n  10000 ETH to 14000 ETH = 200000000000000 WEI = 0.0002 ETH\r\n  */\r\n  Tranche[10] public tranches;\r\n\r\n  // How many active tranches we have\r\n  uint public trancheCount;\r\n  uint public constant MAX_TRANCHES = 10;\r\n  uint public tokenDecimals = 18;\r\n  \r\n  event Invested(address investor, uint value);\r\n  event Refunded(address investor, uint value);\r\n  \r\n  //Event to show whitelisted address\r\n  event Whitelisted(address[] addr, bool status);\r\n  \r\n  //Event to show when freezeends data changed\r\n  event FreezeEndChanged(uint newFreezeEnd);\r\n  \r\n  //Event to show crowdsale address changes\r\n  event CrowdsaleAdded(address newCrowdsale);\r\n  \r\n  /**\r\n   * Create presale contract\r\n   */\r\n   \r\n  constructor(address _owner, uint _freezeEndsAt) public {\r\n    require(_owner != address(0) && _freezeEndsAt != 0);\r\n    owner = _owner;\r\n    freezeEndsAt = _freezeEndsAt;\r\n  }\r\n\r\n  /**\r\n   * Receive funds for presale\r\n   * Modified by: TokenMagic\r\n   */\r\n   \r\n  function() public payable {  \r\n    // Only Whitelisted addresses can contribute\r\n    require(presaleParticipantWhitelist[msg.sender]);\r\n    require(trancheCount > 0);\r\n    \r\n    address investor = msg.sender;\r\n\r\n    bool existing = investorsMapping[investor];\r\n\r\n    balances[investor] = balances[investor].add(msg.value);\r\n    weiRaised = weiRaised.add(msg.value);\r\n    require(weiRaised <= maxFundLimit);\r\n    \r\n    uint weiAmount = msg.value;\r\n    uint tokenAmount = calculatePrice(weiAmount);\r\n    \r\n    // Add the amount of tokens they are now due to total tally\r\n    tokenDue[investor] = tokenDue[investor].add(tokenAmount);\r\n        \r\n    if(!existing) {\r\n      investors.push(investor);\r\n      investorsMapping[investor] = true;\r\n    }\r\n\r\n    emit Invested(investor, msg.value);\r\n  }\r\n  \r\n  /**\r\n   * Add KYC whitelisted pre-sale participant ETH addresses to contract.\r\n   * Added by: TokenMagic\r\n   */\r\n  function setPresaleParticipantWhitelist(address[] addr, bool status) public onlyOwner {\r\n    for(uint i = 0; i < addr.length; i++ ){\r\n      presaleParticipantWhitelist[addr[i]] = status;\r\n    }\r\n    emit Whitelisted(addr, status);\r\n  }\r\n    \r\n   /**\r\n   * Allow owner to set freezeEndsAt (Timestamp).\r\n   * Added by: TokenMagic\r\n   */\r\n  function setFreezeEnd(uint _freezeEndsAt) public onlyOwner {\r\n    require(_freezeEndsAt != 0);\r\n    freezeEndsAt = _freezeEndsAt;\r\n    emit FreezeEndChanged(freezeEndsAt);\r\n  }  \r\n    \r\n  /**\r\n   * Move single pre-sale participant's fund to the crowdsale contract.\r\n   * Modified by: TokenMagic\r\n   */\r\n  function participateCrowdsaleInvestor(address investor) public onlyOwner {\r\n\r\n    // Crowdsale not yet set\r\n    require(address(crowdsale) != 0);\r\n\r\n    if(balances[investor] > 0) {\r\n      uint amount = balances[investor];\r\n      uint tokenAmount = tokenDue[investor];\r\n      delete balances[investor];\r\n      delete tokenDue[investor];\r\n      crowdsale.invest.value(amount)(investor,tokenAmount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Move all pre-sale participants fund to the crowdsale contract.\r\n   *\r\n   */\r\n  function participateCrowdsaleAll() public onlyOwner {\r\n    // We might hit a max gas limit in this loop,\r\n    // and in this case you can simply call participateCrowdsaleInvestor() for all investors\r\n    for(uint i = 0; i < investors.length; i++) {\r\n      participateCrowdsaleInvestor(investors[i]);\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * Move selected pre-sale participants fund to the crowdsale contract.\r\n   *\r\n   */\r\n  function participateCrowdsaleSelected(address[] addr) public onlyOwner {\r\n    for(uint i = 0; i < addr.length; i++ ){\r\n      participateCrowdsaleInvestor(investors[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * ICO never happened. Allow refund.\r\n   * Modified by: TokenMagic\r\n   */\r\n  function refund() public {\r\n\r\n    // Trying to ask refund too soon\r\n    require(now > freezeEndsAt && balances[msg.sender] > 0);\r\n\r\n    address investor = msg.sender;\r\n    uint amount = balances[investor];\r\n    delete balances[investor];\r\n    emit Refunded(investor, amount);\r\n    investor.transfer(amount);\r\n  }\r\n\r\n  /**\r\n   * Set the crowdsale contract address, where we will move presale funds when the crowdsale opens.\r\n   */\r\n  function setCrowdsale(HoardCrowdsale _crowdsale) public onlyOwner {\r\n    crowdsale = _crowdsale;\r\n    emit CrowdsaleAdded(crowdsale);\r\n  }\r\n\r\n  /**\r\n  * Get total investors count\r\n  * Added by: TokenMagic\r\n  */ \r\n  function getInvestorsCount() public view returns(uint investorsCount) {\r\n    return investors.length;\r\n  }\r\n  \r\n  /// @dev Contruction, creating a list of tranches\r\n  /// @param _tranches uint[] tranches Pairs of (start amount, price)\r\n  function setPricing(uint[] _tranches) public onlyOwner {\r\n    // Need to have tuples, length check\r\n    if(_tranches.length % 2 == 1 || _tranches.length >= MAX_TRANCHES*2) {\r\n      revert();\r\n    }\r\n\r\n    trancheCount = _tranches.length / 2;\r\n\r\n    uint highestAmount = 0;\r\n\r\n    for(uint i=0; i<_tranches.length/2; i++) {\r\n      tranches[i].amount = _tranches[i*2];\r\n      tranches[i].price = _tranches[i*2+1];\r\n\r\n      // No invalid steps\r\n      if((highestAmount != 0) && (tranches[i].amount <= highestAmount)) {\r\n        revert();\r\n      }\r\n\r\n      highestAmount = tranches[i].amount;\r\n    }\r\n\r\n    // We need to start from zero, otherwise we blow up our deployment\r\n    if(tranches[0].amount != 0) {\r\n      revert();\r\n    }\r\n\r\n    // Last tranche price must be zero, terminating the crowdale\r\n    if(tranches[trancheCount-1].price != 0) {\r\n      revert();\r\n    }\r\n  }\r\n  \r\n  /// @dev Get the current tranche or bail out if we are not in the tranche periods.\r\n  /// @return {[type]} [description]\r\n  function getCurrentTranche() private view returns (Tranche) {\r\n    uint i;\r\n\r\n    for(i=0; i < tranches.length; i++) {\r\n      if(weiRaised <= tranches[i].amount) {\r\n        return tranches[i-1];\r\n      }\r\n    }\r\n  }\r\n  \r\n  /// @dev Get the current price.\r\n  /// @return The current price or 0 if we are outside trache ranges\r\n  function getCurrentPrice() public view returns (uint result) {\r\n    return getCurrentTranche().price;\r\n  }\r\n  \r\n  /// @dev Calculate the current price for buy in amount.\r\n  function calculatePrice(uint value) public view returns (uint) {\r\n    uint multiplier = 10 ** tokenDecimals;\r\n    uint price = getCurrentPrice();\r\n    return value.times(multiplier) / price;\r\n  }\r\n  \r\n  /// @dev Iterate through tranches. You reach end of tranches when price = 0\r\n  /// @return tuple (time, price)\r\n  function getTranche(uint n) public view returns (uint, uint) {\r\n    return (tranches[n].amount, tranches[n].price);\r\n  }\r\n\r\n  function getFirstTranche() private view returns (Tranche) {\r\n    return tranches[0];\r\n  }\r\n\r\n  function getLastTranche() private view returns (Tranche) {\r\n    return tranches[trancheCount-1];\r\n  }\r\n\r\n  function getPricingStartsAt() public view returns (uint) {\r\n    return getFirstTranche().amount;\r\n  }\r\n\r\n  function getPricingEndsAt() public view returns (uint) {\r\n    return getLastTranche().amount;\r\n  }\r\n  \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tranches\",\"type\":\"uint256[]\"}],\"name\":\"setPricing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"presaleParticipantWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address[]\"}],\"name\":\"participateCrowdsaleSelected\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"participateCrowdsaleInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tranches\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPricingStartsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenDecimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenDue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"name\":\"setCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_freezeEndsAt\",\"type\":\"uint256\"}],\"name\":\"setFreezeEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trancheCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezeEndsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxFundLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPricingEndsAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_TRANCHES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calculatePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"participateCrowdsaleAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address[]\"},{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setPresaleParticipantWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"n\",\"type\":\"uint256\"}],\"name\":\"getTranche\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"result\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestorsCount\",\"outputs\":[{\"name\":\"investorsCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_freezeEndsAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Invested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Refunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Whitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newFreezeEnd\",\"type\":\"uint256\"}],\"name\":\"FreezeEndChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newCrowdsale\",\"type\":\"address\"}],\"name\":\"CrowdsaleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"HoardPresale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000246e84f1f0344ed216b6f164c864fa35f76876c2000000000000000000000000000000000000000000000000000000005bfa4168","Library":"SafeMathLib:a3ef8C9a5868043dcDA059eA534b9f0914aF2bbB","SwarmSource":"bzzr://3474434c7db08a7ad3f643734577d08d4bd074964b3eacd78f289ab02550f09f"}]}