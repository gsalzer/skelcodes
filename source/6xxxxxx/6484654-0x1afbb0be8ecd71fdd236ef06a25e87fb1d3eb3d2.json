{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/pricing/CvcPricingInterface.sol\r\n\r\n/**\r\n * @title CvcPricingInterface\r\n * @dev This contract defines the pricing service interface.\r\n */\r\ncontract CvcPricingInterface {\r\n\r\n    /**\r\n    * @dev Returns the price by Credential Item ID.\r\n    * @param _idv IDV address.\r\n    * @param _credentialItemId Credential Item ID.\r\n    * @return bytes32 Price ID.\r\n    * @return uint256 Price value.\r\n    * @return address IDV address.\r\n    * @return string Credential Item type.\r\n    * @return string Credential Item name.\r\n    * @return string Credential Item version.\r\n    */\r\n    function getPriceByCredentialItemId(\r\n        address _idv,\r\n        bytes32 _credentialItemId\r\n        ) external view returns (\r\n            bytes32 id,\r\n            uint256 price,\r\n            address idv,\r\n            string credentialItemType,\r\n            string credentialItemName,\r\n            string credentialItemVersion,\r\n            bool deprecated\r\n        );\r\n}\r\n\r\n// File: contracts/escrow/CvcEscrowInterface.sol\r\n\r\n/**\r\n * @title CvcEscrowInterface\r\n * @dev This contract defines the escrow service interface.\r\n */\r\ncontract CvcEscrowInterface {\r\n\r\n    /// Describes all possible states of the escrow placement:\r\n    /// Empty - the placement with specific ID is unknown to the contract. i.e. was never placed.\r\n    /// Placed - the placement is active, pending to be released or canceled.\r\n    /// Released - the placement has been released and Identity Validator received payment.\r\n    /// Canceled - the placement has been canceled and Identity Requester got refund, no payment was made to Identity Validator.\r\n    enum PlacementState {Empty, Placed, Released, Canceled}\r\n\r\n    /**\r\n    * @dev The EscrowPlaced event is emitted when the placement is made and the corresponding amount of tokens\r\n    * transferred from Identity Requester account to the escrow account.\r\n    * The event is emitted individually for each placement item with unique scope request ID.\r\n    *\r\n    * @param idr ID Requester address.\r\n    * @param idv Identity Validator address.\r\n    * @param scopeRequestId Scope request identifier.\r\n    * @param amount CVC token amount in creds (CVC x 10e-8).\r\n    * @param credentialItemIds Array of credential item IDs.\r\n    * @param placementId Escrow Placement Identifier\r\n    */\r\n    event EscrowPlaced(\r\n        address indexed idr,\r\n        address indexed idv,\r\n        bytes32 indexed scopeRequestId,\r\n        uint256 amount,\r\n        bytes32[] credentialItemIds,\r\n        bytes32 placementId\r\n    );\r\n\r\n    /**\r\n    * @dev The EscrowMoved event is emitted for each placement item with unique scope request ID kept in escrow upon\r\n    * placement partial release. It contains the old and new placement ID to track placement item lifecycle.\r\n    * The placement ID from the latest EscrowMoved event effectively points to the active placement containing\r\n    * specific scope request ID.\r\n    *\r\n    * @param idr ID Requester address.\r\n    * @param idv Identity Validator address.\r\n    * @param scopeRequestId Scope request identifier.\r\n    * @param amount CVC token amount in creds (CVC x 10e-8).\r\n    * @param credentialItemIds Array of credential item IDs.\r\n    * @param oldPlacementId Escrow Placement Identifier of the partially released placement.\r\n    * @param placementId Escrow Placement Identifier of new placement.\r\n    */\r\n    event EscrowMoved(\r\n        address indexed idr,\r\n        address indexed idv,\r\n        bytes32 indexed scopeRequestId,\r\n        uint256 amount,\r\n        bytes32[] credentialItemIds,\r\n        bytes32 oldPlacementId,\r\n        bytes32 placementId\r\n    );\r\n\r\n    /**\r\n    * @dev The EscrowReleased event is emitted when the placement is released and the corresponding amount of tokens\r\n    * transferred from escrow account to Identity Validator account.\r\n    * The event is emitted individually for each placement item with unique scope request ID.\r\n    *\r\n    * @param idr ID Requester address.\r\n    * @param idv Identity Validator address.\r\n    * @param scopeRequestId Scope request identifier.\r\n    * @param platformFee CVC token amount transferred to the marketplace maintainer account as service fee.\r\n    * @param idvFee CVC token amount transferred to the Identity Validator account.\r\n    * @param credentialItemIds Array of credential item IDs.\r\n    * @param placementId Escrow Placement Identifier\r\n    */\r\n    event EscrowReleased(\r\n        address indexed idr,\r\n        address indexed idv,\r\n        bytes32 indexed scopeRequestId,\r\n        uint256 platformFee,\r\n        uint256 idvFee,\r\n        bytes32[] credentialItemIds,\r\n        bytes32 placementId\r\n    );\r\n\r\n\r\n    /**\r\n    * @dev The EscrowCanceled event is emitted when the placement is canceled and the corresponding amount of tokens\r\n    * refunded from escrow account to Identity Requester account.\r\n    * The event is emitted individually for each placement item with unique scope request ID.\r\n    *\r\n    * @param idr ID Requester address.\r\n    * @param idv Identity Validator address.\r\n    * @param scopeRequestId Scope request identifier.\r\n    * @param amount CVC token amount in creds (CVC x 10e-8) refunded to Identity Requester.\r\n    * @param credentialItemIds Array of credential item IDs.\r\n    * @param placementId Escrow Placement Identifier\r\n    */\r\n    event EscrowCanceled(\r\n        address indexed idr,\r\n        address indexed idv,\r\n        bytes32 indexed scopeRequestId,\r\n        uint256 amount,\r\n        bytes32[] credentialItemIds,\r\n        bytes32 placementId\r\n    );\r\n\r\n    /**\r\n    * @dev Handles escrow placement for a single scope request.\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestId Scope request identifier\r\n    * @param _amount CVC token amount in creds (CVC x 10e-8)\r\n    * @param _credentialItemIds Array of credential item IDs\r\n    * @return bytes32 New Placement ID\r\n    */\r\n    function place(address _idv, bytes32 _scopeRequestId, uint256 _amount, bytes32[] _credentialItemIds)\r\n        external\r\n        returns (bytes32);\r\n\r\n    /**\r\n    * @dev Handles escrow placement for multiple scope requests grouped by credential item IDs.\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds Array of scope request IDs\r\n    * @param _amount CVC token amount in creds (CVC x 10e-8)\r\n    * @param _credentialItemIds Array of credential item IDs\r\n    * @return bytes32 New Placement ID\r\n    */\r\n    function placeBatch(address _idv, bytes32[] _scopeRequestIds, uint256 _amount, bytes32[] _credentialItemIds)\r\n        external\r\n        returns (bytes32);\r\n\r\n    /**\r\n    * @dev Releases escrow placement for a single scope request and distributes funds.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestId Scope request identifier\r\n    */\r\n    function release(address _idr, address _idv, bytes32 _scopeRequestId) external;\r\n\r\n    /**\r\n    * @dev Releases escrow placement for multiple scope requests and distributes funds.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIdsToRelease Array of scope request IDs which will be released\r\n    * @param _scopeRequestIdsToKeep Array of scope request IDs which will be kept in escrow\r\n    * @return bytes32 Placement ID of remaining part of the batch. Empty when the placement was fully released\r\n    */\r\n    function releaseBatch(\r\n        address _idr,\r\n        address _idv,\r\n        bytes32[] _scopeRequestIdsToRelease,\r\n        bytes32[] _scopeRequestIdsToKeep\r\n    )\r\n        external\r\n        returns (bytes32);\r\n\r\n    /**\r\n    * @dev Refunds escrowed tokens for a single scope request back to Identity Requester.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestId Scope request identifier\r\n    */\r\n    function refund(address _idr, address _idv, bytes32 _scopeRequestId) external;\r\n\r\n\r\n    /**\r\n    * @dev Refunds escrowed tokens for multiple scope requests back to Identity Requester.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds Array of scope request IDs\r\n    */\r\n    function refundBatch(address _idr, address _idv, bytes32[] _scopeRequestIds) external;\r\n\r\n    /**\r\n    * @dev Returns placement details.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestId Scope request identifier\r\n    * @return uint256 CVC token amount in creds (CVC x 10e-8)\r\n    * @return PlacementState One of the CvcEscrowInterface.PlacementState values.\r\n    * @return bytes32[] Array of credential item IDs.\r\n    * @return uint256 Block confirmations since escrow was placed.\r\n    * @return bool True if placement can be refunded otherwise false\r\n    */\r\n    function verify(address _idr, address _idv, bytes32 _scopeRequestId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 placementAmount,\r\n            PlacementState placementState,\r\n            bytes32[] credentialItemIds,\r\n            uint256 confirmations,\r\n            bool refundable\r\n        );\r\n\r\n    /**\r\n    * @dev Returns placement details.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds Array of scope request IDs\r\n    * @return uint256 CVC token amount in creds (CVC x 10e-8)\r\n    * @return PlacementState One of the CvcEscrowInterface.PlacementState values.\r\n    * @return bytes32[] Array of credential item IDs.\r\n    * @return uint256 Block confirmations since escrow was placed.\r\n    * @return bool True if placement can be refunded otherwise false\r\n    */\r\n    function verifyBatch(address _idr, address _idv, bytes32[] _scopeRequestIds)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 placementAmount,\r\n            PlacementState placementState,\r\n            bytes32[] credentialItemIds,\r\n            uint256 confirmations,\r\n            bool refundable\r\n        );\r\n\r\n\r\n    /**\r\n    * @dev Returns placement details.\r\n    * @param _placementId Escrow Placement identifier.\r\n    * @return uint256 CVC token amount in creds (CVC x 10e-8)\r\n    * @return PlacementState One of the CvcEscrowInterface.PlacementState values.\r\n    * @return bytes32[] Array of credential item IDs.\r\n    * @return uint256 Block confirmations since escrow was placed.\r\n    * @return bool True if placement can be refunded otherwise false\r\n    */\r\n    function verifyPlacement(bytes32 _placementId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 placementAmount,\r\n            PlacementState placementState,\r\n            bytes32[] credentialItemIds,\r\n            uint256 confirmations,\r\n            bool refundable\r\n        );\r\n\r\n\r\n    /**\r\n    * @dev Calculates escrow placement identifier.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds An array of scope request identifiers\r\n    * @return bytes32 Placement ID\r\n    */\r\n    function calculatePlacementId(address _idr, address _idv, bytes32[] _scopeRequestIds)\r\n        public\r\n        pure\r\n        returns (bytes32);\r\n\r\n}\r\n\r\n// File: contracts/upgradeability/EternalStorage.sol\r\n\r\n/**\r\n * @title EternalStorage\r\n * @dev This contract defines the generic storage structure\r\n * so that it could be re-used to implement any domain specific storage functionality\r\n */\r\ncontract EternalStorage {\r\n\r\n    mapping(bytes32 => uint256) internal uintStorage;\r\n    mapping(bytes32 => string) internal stringStorage;\r\n    mapping(bytes32 => address) internal addressStorage;\r\n    mapping(bytes32 => bytes) internal bytesStorage;\r\n    mapping(bytes32 => bool) internal boolStorage;\r\n    mapping(bytes32 => int256) internal intStorage;\r\n    mapping(bytes32 => bytes32) internal bytes32Storage;\r\n\r\n}\r\n\r\n// File: contracts/upgradeability/ImplementationStorage.sol\r\n\r\n/**\r\n * @title ImplementationStorage\r\n * @dev This contract stores proxy implementation address.\r\n */\r\ncontract ImplementationStorage {\r\n\r\n    /**\r\n     * @dev Storage slot with the address of the current implementation.\r\n     * This is the keccak-256 hash of \"cvc.proxy.implementation\", and is validated in the constructor.\r\n     */\r\n    bytes32 internal constant IMPLEMENTATION_SLOT = 0xa490aab0d89837371982f93f57ffd20c47991f88066ef92475bc8233036969bb;\r\n\r\n    /**\r\n    * @dev Constructor\r\n    */\r\n    constructor() public {\r\n        assert(IMPLEMENTATION_SLOT == keccak256(\"cvc.proxy.implementation\"));\r\n    }\r\n\r\n    /**\r\n     * @dev Returns the current implementation.\r\n     * @return Address of the current implementation\r\n     */\r\n    function implementation() public view returns (address impl) {\r\n        bytes32 slot = IMPLEMENTATION_SLOT;\r\n        assembly {\r\n            impl := sload(slot)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/Initializable.sol\r\n\r\n/**\r\n * @title Initializable\r\n * @dev This contract provides basic initialization control\r\n */\r\ncontract Initializable is EternalStorage, ImplementationStorage {\r\n\r\n    /**\r\n    Data structures and storage layout:\r\n    mapping(bytes32 => bool) initialized;\r\n    **/\r\n\r\n    /**\r\n     * @dev Throws if called before contract was initialized.\r\n     */\r\n    modifier onlyInitialized() {\r\n        // require(initialized[implementation()]);\r\n        require(boolStorage[keccak256(abi.encodePacked(implementation(), \"initialized\"))], \"Contract is not initialized\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Controls the initialization state, allowing to call an initialization function only once.\r\n     */\r\n    modifier initializes() {\r\n        address impl = implementation();\r\n        // require(!initialized[implementation()]);\r\n        require(!boolStorage[keccak256(abi.encodePacked(impl, \"initialized\"))], \"Contract is already initialized\");\r\n        _;\r\n        // initialized[implementation()] = true;\r\n        boolStorage[keccak256(abi.encodePacked(impl, \"initialized\"))] = true;\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev This contract has an owner address providing basic authorization control\r\n */\r\ncontract Ownable is EternalStorage {\r\n\r\n    /**\r\n    Data structures and storage layout:\r\n    address owner;\r\n    **/\r\n\r\n    /**\r\n     * @dev Event to show ownership has been transferred\r\n     * @param previousOwner representing the address of the previous owner\r\n     * @param newOwner representing the address of the new owner\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner(), \"Message sender must be contract admin\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Tells the address of the owner\r\n     * @return the address of the owner\r\n     */\r\n    function owner() public view returns (address) {\r\n        // return owner;\r\n        return addressStorage[keccak256(\"owner\")];\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner the address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Contract owner cannot be zero address\");\r\n        setOwner(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets a new owner address\r\n     */\r\n    function setOwner(address newOwner) internal {\r\n        emit OwnershipTransferred(owner(), newOwner);\r\n        // owner = newOwner;\r\n        addressStorage[keccak256(\"owner\")] = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/upgradeability/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable, ImplementationStorage {\r\n\r\n    /**\r\n    Data structures and storage layout:\r\n    mapping(bytes32 => bool) paused;\r\n    **/\r\n\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused(), \"Contract is paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused(), \"Contract must be paused\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        // paused[implementation()] = true;\r\n        boolStorage[keccak256(abi.encodePacked(implementation(), \"paused\"))] = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        // paused[implementation()] = false;\r\n        boolStorage[keccak256(abi.encodePacked(implementation(), \"paused\"))] = false;\r\n        emit Unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns true when the contract is paused.\r\n     * @return bool\r\n     */\r\n    function paused() public view returns (bool) {\r\n        // return paused[implementation()];\r\n        return boolStorage[keccak256(abi.encodePacked(implementation(), \"paused\"))];\r\n    }\r\n}\r\n\r\n// File: contracts/escrow/CvcEscrow.sol\r\n\r\n/**\r\n * @title CvcEscrow\r\n * @dev This contract provides escrow service functionality for the Identity.com marketplace.\r\n * It controls an escrow placement's lifecycle which involves transferring a pre-approved amount funds\r\n * from the Identity Requester account to its own account and keeping them until the marketplace deal is complete.\r\n *\r\n * Glossary:\r\n * Identity Requester (IDR) - Business entities requesting verifiable Credentials from a user in order to authenticate them.\r\n * Identity Validator (IDV) - Businesses or organizations that validate a user's identity and provide verifiable credentials.\r\n * Scope Request            - A request for identity information about a user from an IDR to an IDV.\r\n * Credential Item          - A single item in a set of verifiable credentials that an IDR can specify within a scope request.\r\n *\r\n * The marketplace flow has 2 possible outcomes:\r\n * 1. release - when user's personally identifiable information (PII) has been delivered to Identity Requester.\r\n *     In this case the release functionality is triggered and the contract transfers escrowed funds\r\n *     to the Identity Validator account, excluding the marketplace fee (if applied).\r\n *\r\n * 2. cancellation - when user's personally identifiable information (PII) has NOT been delivered to Identity Requester.\r\n *     In this case the refund procedure can be executed and all the escrowed funds will be returned\r\n *     back to Identity Requester account.\r\n *\r\n * The escrow contract depends on other marketplace contracts, such as:\r\n * CvcToken - to perform CVC transfers.\r\n * CvcPricing - to check the actual marketplace prices and ensure that placed amount of tokens\r\n *                covers the Credential Items price and matches the expectation of all involved parties.\r\n */\r\ncontract CvcEscrow is EternalStorage, Initializable, Pausable, CvcEscrowInterface {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n    Data structures and storage layout:\r\n    struct EscrowPlacement {\r\n        uint256 state;\r\n        uint256 amount;\r\n        uint256 credentialItemIdsCount;\r\n        bytes32[] credentialItemIds;\r\n        uint256 blockNumber;\r\n    }\r\n    uint256 timeoutThreshold;\r\n    uint256 platformFeeRate;\r\n    address cvcToken;\r\n    address cvcPricing;\r\n    address platform;\r\n    mapping(bytes32 => EscrowPlacement) placements;\r\n    **/\r\n\r\n    /// The divisor for calculating platform fee rate.\r\n    /// Solidity does not support floats,\r\n    /// so we provide rather big unsigned integer and then divide it by this constant\r\n    uint256 constant public RATE_PRECISION = 1e8;\r\n\r\n    /**\r\n    * @dev Constructor\r\n    * @param _token CVC Token contract address\r\n    * @param _platform Platform address to send retained fee to\r\n    * @param _pricing Pricing contract address to lookup for escrow amount before placing\r\n    */\r\n    constructor(address _token, address _platform, address _pricing) public {\r\n        initialize(_token, _platform, _pricing, msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev Handles escrow placement for a single scope request.\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestId Scope request identifier\r\n    * @param _amount CVC token amount in creds (CVC x 10e-8)\r\n    * @param _credentialItemIds Array of credential item IDs\r\n    * @return bytes32 New Placement ID\r\n    */\r\n    function place(\r\n        address _idv,\r\n        bytes32 _scopeRequestId,\r\n        uint256 _amount,\r\n        bytes32[] _credentialItemIds\r\n    )\r\n        external\r\n        onlyInitialized\r\n        whenNotPaused\r\n        returns (bytes32)\r\n    {\r\n        // Prepare a batch with single scope request ID.\r\n        bytes32[] memory scopeRequestIds = new bytes32[](1);\r\n        scopeRequestIds[0] = _scopeRequestId;\r\n\r\n        return makePlacement(_idv, scopeRequestIds, _amount, _credentialItemIds);\r\n    }\r\n\r\n    /**\r\n    * @dev Handles escrow placement for multiple scope requests grouped by credential item IDs.\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds Array of scope request IDs\r\n    * @param _amount CVC token amount in creds (CVC x 10e-8)\r\n    * @param _credentialItemIds Array of credential item IDs\r\n    * @return bytes32 New Placement ID\r\n    */\r\n    function placeBatch(address _idv, bytes32[] _scopeRequestIds, uint256 _amount, bytes32[] _credentialItemIds)\r\n        external\r\n        onlyInitialized\r\n        whenNotPaused\r\n        returns (bytes32)\r\n    {\r\n        return makePlacement(_idv, _scopeRequestIds, _amount, _credentialItemIds);\r\n    }\r\n\r\n    /**\r\n    * @dev Releases escrow placement and distributes funds.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestId Scope request identifier\r\n    */\r\n    function release(address _idr, address _idv, bytes32 _scopeRequestId)\r\n        external\r\n        onlyOwner\r\n        onlyInitialized\r\n        whenNotPaused\r\n    {\r\n        // Prepare a batch with single scope request ID.\r\n        bytes32[] memory scopeRequestIdsToRelease = new bytes32[](1);\r\n        scopeRequestIdsToRelease[0] = _scopeRequestId;\r\n\r\n        // itemsToKeep is empty to indicate full release.\r\n        makePartialRelease(_idr, _idv, scopeRequestIdsToRelease, new bytes32[](0));\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Releases escrow placement for multiple scope requests and distributes funds.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIdsToRelease Array of scope request IDs which will be released\r\n    * @param _scopeRequestIdsToKeep Array of scope request IDs which will be kept in escrow\r\n    * @return bytes32 Placement ID of remaining part of the batch. Empty when the placement was fully released\r\n    */\r\n    function releaseBatch(\r\n        address _idr,\r\n        address _idv,\r\n        bytes32[] _scopeRequestIdsToRelease,\r\n        bytes32[] _scopeRequestIdsToKeep\r\n    )\r\n        external\r\n        onlyOwner\r\n        onlyInitialized\r\n        whenNotPaused\r\n        returns (bytes32)\r\n    {\r\n        return makePartialRelease(_idr, _idv, _scopeRequestIdsToRelease, _scopeRequestIdsToKeep);\r\n    }\r\n\r\n    /**\r\n    * @dev Refunds escrowed tokens for a single scope request back to Identity Requester.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestId Scope request ID\r\n    */\r\n    function refund(address _idr, address _idv, bytes32 _scopeRequestId) external onlyInitialized whenNotPaused {\r\n        // Prepare a batch with single scope request ID.\r\n        bytes32[] memory scopeRequestIds = new bytes32[](1);\r\n        scopeRequestIds[0] = _scopeRequestId;\r\n        makeFullRefund(_idr, _idv, scopeRequestIds);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Refunds escrowed tokens for for multiple scope requests back to Identity Requester.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds Array of scope request IDs\r\n    */\r\n    function refundBatch(address _idr, address _idv, bytes32[] _scopeRequestIds)\r\n        external\r\n        onlyInitialized\r\n        whenNotPaused\r\n    {\r\n        makeFullRefund(_idr, _idv, _scopeRequestIds);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement details.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestId Scope request ID\r\n    * @return uint256 CVC token amount in creds (CVC x 10e-8)\r\n    * @return PlacementState One of the CvcEscrowInterface.PlacementState values\r\n    * @return bytes32[] Array of credential item IDs\r\n    * @return uint256 Block confirmations since escrow was placed\r\n    * @return bool True if placement can be refunded otherwise false\r\n    */\r\n    function verify(address _idr, address _idv, bytes32 _scopeRequestId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 placementAmount,\r\n            PlacementState placementState,\r\n            bytes32[] credentialItemIds,\r\n            uint256 confirmations,\r\n            bool refundable\r\n        )\r\n    {\r\n        // Prepare a batch with single scope request ID.\r\n        bytes32[] memory scopeRequestIds = new bytes32[](1);\r\n        scopeRequestIds[0] = _scopeRequestId;\r\n\r\n        return getPlacement(calculatePlacementId(_idr, _idv, scopeRequestIds));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement details.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds Array of scope request IDs\r\n    * @return uint256 CVC token amount in creds (CVC x 10e-8)\r\n    * @return PlacementState One of the CvcEscrowInterface.PlacementState values\r\n    * @return bytes32[] Array of credential item IDs\r\n    * @return uint256 Block confirmations since escrow was placed\r\n    * @return bool True if placement can be refunded otherwise false\r\n    */\r\n    function verifyBatch(address _idr, address _idv, bytes32[] _scopeRequestIds)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 placementAmount,\r\n            PlacementState placementState,\r\n            bytes32[] credentialItemIds,\r\n            uint256 confirmations,\r\n            bool refundable\r\n        )\r\n    {\r\n        return getPlacement(calculatePlacementId(_idr, _idv, _scopeRequestIds));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement details.\r\n    * @param _placementId Escrow Placement identifier.\r\n    * @return uint256 CVC token amount in creds (CVC x 10e-8)\r\n    * @return PlacementState One of the CvcEscrowInterface.PlacementState values.\r\n    * @return bytes32[] Array of credential item IDs.\r\n    * @return uint256 Block confirmations since escrow was placed.\r\n    * @return bool True if placement can be refunded otherwise false\r\n    */\r\n    function verifyPlacement(bytes32 _placementId)\r\n        external\r\n        view\r\n        returns (\r\n            uint256 placementAmount,\r\n            PlacementState placementState,\r\n            bytes32[] credentialItemIds,\r\n            uint256 confirmations,\r\n            bool refundable\r\n        )\r\n    {\r\n        return getPlacement(_placementId);\r\n    }\r\n\r\n    /**\r\n    * @dev Contract initialization method.\r\n    * @param _token CVC Token contract address\r\n    * @param _platform Platform address to send retained fee to\r\n    * @param _pricing Pricing contract address to lookup for escrow amount before placing\r\n    * @param _owner Owner address, used for release\r\n    */\r\n    function initialize(address _token, address _platform, address _pricing, address _owner)\r\n        public\r\n        initializes\r\n    {\r\n        // Ensure contracts.\r\n        require(AddressUtils.isContract(_token), \"Initialization error: no contract code at token contract address\");\r\n        require(AddressUtils.isContract(_pricing), \"Initialization error: no contract code at pricing contract address\");\r\n\r\n        /// Timeout value for escrowed funds before refund is available.\r\n        /// Currently represents number of blocks for approx 24 hours.\r\n        // timeoutThreshold = 5800;\r\n        uintStorage[keccak256(\"timeout.threshold\")] = 5800;\r\n        /// The percentage of escrowed funds retained as a platform fee.\r\n        /// The default rate is 10% (0.1 * 10^8).\r\n        // platformFeeRate = 1e7;\r\n        uintStorage[keccak256(\"platform.fee.rate\")] = 1e7;\r\n        // Initialize current implementation owner address.\r\n        setOwner(_owner);\r\n        // CVC Token contract address to transfer CVC tokens.\r\n        // cvcToken = _token;\r\n        addressStorage[keccak256(\"cvc.token\")] = _token;\r\n        // Pricing contract address to lookup attestation prices.\r\n        // cvcPricing = _pricing;\r\n        addressStorage[keccak256(\"cvc.pricing\")] = _pricing;\r\n        // Platform address is used to transfer platform usage fee.\r\n        // platform = _platform;\r\n        addressStorage[keccak256(\"platform\")] = _platform;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates escrow placement identifier.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds An array of scope request identifiers\r\n    * @return bytes32 Placement ID\r\n    */\r\n    function calculatePlacementId(address _idr, address _idv, bytes32[] _scopeRequestIds)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        require(_idr != address(0), \"Cannot calculate placement ID with IDR being a zero address\");\r\n        require(_idv != address(0), \"Cannot calculate placement ID with IDV being a zero address\");\r\n\r\n        return keccak256(abi.encodePacked(_idr, _idv, calculateBatchReference(_scopeRequestIds)));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns platform fee amount based on given placement amount and current platform fee rate.\r\n    * @param _amount Escrow placement total amount.\r\n    * @return uint256\r\n    */\r\n    function calculatePlatformFee(uint256 _amount) public view returns (uint256) {\r\n        return (_amount.mul(platformFeeRate()).add(RATE_PRECISION.div(2))).div(RATE_PRECISION);\r\n    }\r\n\r\n    /**\r\n    * @dev Sets timeout threshold. Ensures it's more than 0.\r\n    * @param _threshold New timeout threshold value\r\n    */\r\n    function setTimeoutThreshold(uint256 _threshold) public onlyOwner onlyInitialized {\r\n        require(_threshold > 0, \"Timeout threshold cannot be zero\");\r\n        // timeoutThreshold = _threshold;\r\n        uintStorage[keccak256(\"timeout.threshold\")] = _threshold;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns actual escrow timeout threshold value.\r\n    * @return uint256\r\n    */\r\n    function timeoutThreshold() public view returns (uint256) {\r\n        // return timeoutThreshold;\r\n        return uintStorage[keccak256(\"timeout.threshold\")];\r\n    }\r\n\r\n    /**\r\n    * @dev Allows to change platform fee rate.\r\n    * @param _feeRate A platform fee rate in percentage, e.g. 1e7 (10%).\r\n    */\r\n    function setFeeRate(uint256 _feeRate) public onlyOwner onlyInitialized {\r\n        require(_feeRate <= RATE_PRECISION, \"Platform fee rate cannot be more than 100%\");\r\n        // platformFeeRate = _feeRate;\r\n        uintStorage[keccak256(\"platform.fee.rate\")] = _feeRate;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns actual platform fee rate value.\r\n    * @return uint256\r\n    */\r\n    function platformFeeRate() public view returns (uint256) {\r\n        // return platformFeeRate;\r\n        return uintStorage[keccak256(\"platform.fee.rate\")];\r\n    }\r\n\r\n    /**\r\n    * @dev Returns CvcToken contact instance.\r\n    * @return ERC20\r\n    */\r\n    function token() public view returns (ERC20) {\r\n        // return ERC20(cvcToken);\r\n        return ERC20(addressStorage[keccak256(\"cvc.token\")]);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns CvcPricing contact instance.\r\n    * @return CvcPricingInterface\r\n    */\r\n    function pricing() public view returns (CvcPricingInterface) {\r\n        // return CvcPricingInterface(cvcPricing);\r\n        return CvcPricingInterface(addressStorage[keccak256(\"cvc.pricing\")]);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns platform address.\r\n    * @return address\r\n    */\r\n    function platformAddress() public view returns (address) {\r\n        // return platform;\r\n        return addressStorage[keccak256(\"platform\")];\r\n    }\r\n\r\n    /**\r\n    * @dev Stores placement data against the placement ID.\r\n    * @param _placementId Unique placement identifier\r\n    * @param _amount CVC token amount in creds (CVC x 10e-8)\r\n    * @param _credentialItemIds Array of credential item IDs\r\n    * @param _blockNumber Block number at which the placement is received\r\n    */\r\n    function saveNewPlacement(bytes32 _placementId, uint256 _amount, bytes32[] _credentialItemIds, uint256 _blockNumber)\r\n        internal\r\n    {\r\n        // Verify current state for given placementId to ensure operation is allowed.\r\n        PlacementState placementState = getPlacementState(_placementId);\r\n        // Placement is allowed when:\r\n        //  1. it is a completely new escrow placement with fresh ID (Empty state)\r\n        //  2. the placement with given ID was refunded (Canceled state)\r\n        require(\r\n            placementState == PlacementState.Empty || placementState == PlacementState.Canceled,\r\n            \"Invalid placement state: must be new or canceled\"\r\n        );\r\n\r\n        // Write placement data into the contract storage.\r\n        setPlacementState(_placementId, PlacementState.Placed);\r\n        setPlacementCredentialItemIds(_placementId, _credentialItemIds);\r\n        setPlacementAmount(_placementId, _amount);\r\n        setPlacementBlockNumber(_placementId, _blockNumber);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement total price based on number of credential items and their current market prices.\r\n    * @param _idv Identity Validator address\r\n    * @param _credentialItemIds Array of credential item IDs\r\n    * @param _batchSize Number of scope request IDs in placement\r\n    * @return uint256\r\n    */\r\n    function getPlacementPrice(address _idv, bytes32[] _credentialItemIds, uint256 _batchSize)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 price = 0;\r\n        uint256 credentialItemPrice;\r\n        CvcPricingInterface cvcPricing = pricing();\r\n        for (uint256 i = 0; i < _credentialItemIds.length; i++) {\r\n            (\r\n\r\n\r\n\r\n\r\n            , credentialItemPrice, , , , ,) = cvcPricing.getPriceByCredentialItemId(_idv, _credentialItemIds[i]);\r\n            price = price.add(credentialItemPrice);\r\n        }\r\n        return price.mul(_batchSize);\r\n    }\r\n\r\n    /**\r\n    * @dev Check if the escrow placement can be refunded back to Identity Requester.\r\n    * @param _placementState The escrow placement state.\r\n    * @param _placementBlockNumber The escrow placement block number.\r\n    * @return bool Whether escrow can be refunded.\r\n    */\r\n    function isRefundable(PlacementState _placementState, uint256 _placementBlockNumber) internal view returns (bool) {\r\n        // Refund is allowed if the escrowed placement is still in \"Placed\" state & timeout is reached.\r\n        // Timeout reached when number of blocks after the escrow was placed is greater than timeout threshold.\r\n        return _placementState == PlacementState.Placed && block.number.sub(_placementBlockNumber) > timeoutThreshold();\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers funds from IRD account and stores the placement data.\r\n    * @param _idv Address of Identity Validator\r\n    * @param _scopeRequestIds Array of scope request IDs\r\n    * @param _amount CVC token amount in creds (CVC x 10e-8)\r\n    * @param _credentialItemIds Array of credential item IDs\r\n    * @return bytes32 New Placement ID\r\n    */\r\n    function makePlacement(address _idv, bytes32[] _scopeRequestIds, uint256 _amount, bytes32[] _credentialItemIds)\r\n        internal\r\n        returns (bytes32)\r\n    {\r\n        // Calculate placement ID to validate arguments.\r\n        bytes32 placementId = calculatePlacementId(msg.sender, _idv, _scopeRequestIds);\r\n\r\n        // Ensure escrow amount is matching the total price of all credential items.\r\n        require(\r\n            _amount == getPlacementPrice(_idv, _credentialItemIds, _scopeRequestIds.length),\r\n            \"Placement amount does not match credential item total price\"\r\n        );\r\n\r\n        // Store new placement data.\r\n        saveNewPlacement(placementId, _amount, _credentialItemIds, block.number);\r\n\r\n        // Transferring funds from IDR to escrow contract address.\r\n        require(token().transferFrom(msg.sender, this, _amount), \"Token transfer from IDR account failed\");\r\n\r\n        // Emitting escrow placement event for each individual scope request ID.\r\n        uint256 amountPerItem = _amount.div(_scopeRequestIds.length);\r\n        for (uint256 i = 0; i < _scopeRequestIds.length; i++) {\r\n            emit EscrowPlaced(msg.sender, _idv, _scopeRequestIds[i], amountPerItem, _credentialItemIds, placementId);\r\n        }\r\n\r\n        return placementId;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculates scope request batch reference.\r\n    * @param _scopeRequestIds An array of scope request identifiers\r\n    * @return bytes32 Batch reference\r\n    */\r\n    function calculateBatchReference(bytes32[] _scopeRequestIds)\r\n        internal\r\n        pure\r\n        returns (bytes32 batchReference)\r\n    {\r\n        // In order to increase batch reference entropy and prevent potential collision\r\n        // caused by small difference between two or more scope request IDs from the same batch\r\n        // we hash the scope request ID before adding to the batch reference.\r\n        for (uint256 i = 0; i < _scopeRequestIds.length; i++) {\r\n            // Ensure scopeRequestId is not empty & add its hash to batch reference.\r\n            require(_scopeRequestIds[i] != 0x0, \"Cannot calculate batch reference with empty scope request ID\");\r\n            batchReference = batchReference ^ keccak256(abi.encodePacked(_scopeRequestIds[i]));\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Releases placed batch items.\r\n    * In case of partial release keeps the remaining part in escrow under new placement ID.\r\n    * If the entire batch is release, empty bytes returned instead.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _itemsToRelease Array of scope request IDs to be released\r\n    * @param _itemsToKeep Array of scope request IDs to keep in escrow\r\n    * @return bytes32 Placement ID of remaining part of the batch. Empty when the placement was fully released\r\n    */\r\n    function makePartialRelease(address _idr, address _idv, bytes32[] _itemsToRelease, bytes32[] _itemsToKeep)\r\n        internal\r\n        returns (bytes32)\r\n    {\r\n        // Restore initial placement ID.\r\n        bytes32 batchReference = calculateBatchReference(_itemsToRelease);\r\n        if (_itemsToKeep.length > 0) {\r\n            batchReference = batchReference ^ calculateBatchReference(_itemsToKeep);\r\n        }\r\n        bytes32 placementId = keccak256(abi.encodePacked(_idr, _idv, batchReference));\r\n\r\n        // Allow release only when the escrow exists and it is not refundable yet.\r\n        // If placement found by ID, we can be sure two arrays of scope request IDs together formed the initial batch.\r\n        PlacementState placementState = getPlacementState(placementId);\r\n        require(placementState == PlacementState.Placed, \"Invalid placement state: must be placed\");\r\n        require(!isRefundable(placementState, getPlacementBlockNumber(placementId)), \"Timed out: release is not possible anymore\");\r\n\r\n        // Change placement state to released.\r\n        setPlacementState(placementId, PlacementState.Released);\r\n\r\n        // Calculate released token amount.\r\n        uint256 totalBatchSize = _itemsToRelease.length.add(_itemsToKeep.length);\r\n        uint256 placementAmount = getPlacementAmount(placementId);\r\n        uint256 amountToRelease = placementAmount.mul(_itemsToRelease.length).div(totalBatchSize);\r\n\r\n        // Release batch items and distribute escrowed funds.\r\n        releaseEscrowedFunds(placementId, _idr, _idv, _itemsToRelease, amountToRelease);\r\n\r\n        // Return empty bytes when the entire batch released.\r\n        if (_itemsToKeep.length == 0)\r\n            return 0x0;\r\n\r\n        // Keep the remaining part of the batch in escrow.\r\n        uint256 amountToKeep = placementAmount.mul(_itemsToKeep.length).div(totalBatchSize);\r\n        return keepPlacement(placementId, _idr, _idv, _itemsToKeep, amountToKeep);\r\n    }\r\n\r\n    /**\r\n    * @dev Refunds escrowed tokens for for multiple scope requests back to Identity Requester.\r\n    * @param _idr Address of Identity Requester\r\n    * @param _idv Address of Identity Validator\r\n    * @param _itemsToRefund Array of scope request IDs to be refunded\r\n    */\r\n    function makeFullRefund(address _idr, address _idv, bytes32[] _itemsToRefund) internal {\r\n        // Calculate placement ID to validate arguments.\r\n        bytes32 placementId = calculatePlacementId(_idr, _idv, _itemsToRefund);\r\n\r\n        // Check if refund is allowed.\r\n        require(\r\n            isRefundable(getPlacementState(placementId), getPlacementBlockNumber(placementId)),\r\n            \"Placement is not refundable yet\"\r\n        );\r\n\r\n        // Mark the escrow placement Canceled.\r\n        setPlacementState(placementId, PlacementState.Canceled);\r\n\r\n        // Transfer funds from the escrow contract balance to IDR account.\r\n        uint256 placementAmount = getPlacementAmount(placementId);\r\n        require(token().transfer(_idr, placementAmount), \"Token transfer to IDR account failed\");\r\n\r\n        // Emitting escrow cancellation event for each individual scope request ID.\r\n        uint256 amountPerItem = placementAmount.div(_itemsToRefund.length);\r\n        bytes32[] memory credentialItemIds = getPlacementCredentialItemIds(placementId);\r\n        for (uint256 i = 0; i < _itemsToRefund.length; i++) {\r\n            emit EscrowCanceled(_idr, _idv, _itemsToRefund[i], amountPerItem, credentialItemIds, placementId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Stores items as a new placement.\r\n    * @param _placementId Current placement identifier.\r\n    * @param _idr Address of Identity Requester.\r\n    * @param _idv Address of Identity Validator.\r\n    * @param _itemsToKeep Array of scope request IDs to keep in escrow.\r\n    * @param _amount New Placement amount.\r\n    * @return bytes32 New Placement ID.\r\n    */\r\n    function keepPlacement(bytes32 _placementId, address _idr, address _idv,  bytes32[] _itemsToKeep, uint256 _amount)\r\n        internal\r\n        returns (bytes32)\r\n    {\r\n        // Calculate new placement ID.\r\n        bytes32 newPlacementId = calculatePlacementId(_idr, _idv, _itemsToKeep);\r\n        // Store data against new placement ID. Copy unchanged data from old placement.\r\n        bytes32[] memory credentialItemIds = getPlacementCredentialItemIds(_placementId);\r\n        saveNewPlacement(newPlacementId, _amount, credentialItemIds, getPlacementBlockNumber(_placementId));\r\n\r\n        uint256 amountPerItem = _amount.div(_itemsToKeep.length);\r\n        for (uint256 i = 0; i < _itemsToKeep.length; i++) {\r\n            emit EscrowMoved(_idr, _idv, _itemsToKeep[i], amountPerItem, credentialItemIds, _placementId, newPlacementId);\r\n        }\r\n\r\n        return newPlacementId;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers funds to IDV withholding platform fee (if applied).\r\n    * @param _placementId Released placement identifier.\r\n    * @param _idr Address of Identity Requester.\r\n    * @param _idv Address of Identity Validator.\r\n    * @param _releasedItems Array of released scope request IDs.\r\n    * @param _amount Amount to release.\r\n    */\r\n    function releaseEscrowedFunds(bytes32 _placementId, address _idr, address _idv, bytes32[] _releasedItems, uint256 _amount)\r\n        internal\r\n    {\r\n        // Calculate token distribution.\r\n        uint256 platformFee = calculatePlatformFee(_amount);\r\n        uint256 idvFee = platformFee > 0 ? _amount.sub(platformFee) : _amount;\r\n\r\n        // Transfer tokens from escrow to IDV.\r\n        ERC20 cvcToken = token();\r\n        require(cvcToken.transfer(_idv, idvFee), \"Token transfer to IDV account failed\");\r\n\r\n        // Transfer tokens from escrow to platform operator address.\r\n        if (platformFee > 0) {\r\n            require(cvcToken.transfer(platformAddress(), platformFee), \"Token transfer to platform account failed\");\r\n        }\r\n\r\n        logBatchRelease(\r\n            _placementId,\r\n            _idr,\r\n            _idv,\r\n            _releasedItems,\r\n            platformFee.div(_releasedItems.length),\r\n            idvFee.div(_releasedItems.length)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Emits EscrowReleased event for each released item.\r\n    * @param _placementId Released placement identifier.\r\n    * @param _idr Address of Identity Requester.\r\n    * @param _idv Address of Identity Validator.\r\n    * @param _releasedItems Array of released scope request IDs.\r\n    * @param _itemPlatformFee Platform fee charged per one item.\r\n    * @param _itemIdvFee Identity Validator fee charged per one item.\r\n    */\r\n    function logBatchRelease(\r\n        bytes32 _placementId,\r\n        address _idr,\r\n        address _idv,\r\n        bytes32[] _releasedItems,\r\n        uint256 _itemPlatformFee,\r\n        uint256 _itemIdvFee\r\n    )\r\n        internal\r\n    {\r\n        bytes32[] memory credentialItemIds = getPlacementCredentialItemIds(_placementId);\r\n        for (uint256 i = 0; i < _releasedItems.length; i++) {\r\n            emit EscrowReleased(\r\n                _idr,\r\n                _idv,\r\n                _releasedItems[i],\r\n                _itemPlatformFee,\r\n                _itemIdvFee,\r\n                credentialItemIds,\r\n                _placementId\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement details.\r\n    * @param _placementId Escrow Placement identifier.\r\n    * @return uint256 CVC token amount in creds (CVC x 10e-8)\r\n    * @return PlacementState One of the CvcEscrowInterface.PlacementState values.\r\n    * @return bytes32[] Array of credential item IDs.\r\n    * @return uint256 Block confirmations since escrow was placed.\r\n    * @return bool True if placement can be refunded otherwise false\r\n    */\r\n    function getPlacement(bytes32 _placementId)\r\n        internal\r\n        view\r\n        returns (\r\n            uint256 placementAmount,\r\n            PlacementState placementState,\r\n            bytes32[] credentialItemIds,\r\n            uint256 confirmations,\r\n            bool refundable\r\n        )\r\n    {\r\n        placementState = getPlacementState(_placementId);\r\n        // Placement amount value is returned for Placed placements, otherwise 0;\r\n        placementAmount = placementState == PlacementState.Placed ? getPlacementAmount(_placementId) : 0;\r\n        credentialItemIds = getPlacementCredentialItemIds(_placementId);\r\n\r\n        // 0 when empty, number of blocks in other states\r\n        uint256 placementBlockNumber = getPlacementBlockNumber(_placementId);\r\n        confirmations = placementState == PlacementState.Empty ? 0 : block.number.sub(placementBlockNumber);\r\n\r\n        refundable = isRefundable(placementState, placementBlockNumber);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement state.\r\n    * @param _placementId The placement ID.\r\n    * @return PlacementState\r\n    */\r\n    function getPlacementState(bytes32 _placementId) internal view returns (PlacementState) {\r\n        // return PlacementState(placements[_placementId].state);\r\n        return PlacementState(uintStorage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".state\"))]);\r\n    }\r\n\r\n    /**\r\n    * @dev Saves placement state.\r\n    * @param _placementId The placement ID.\r\n    * @param state Placement state.\r\n    */\r\n    function setPlacementState(bytes32 _placementId, PlacementState state) internal {\r\n        // placements[_placementId].state = uint256(state);\r\n        uintStorage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".state\"))] = uint256(state);\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement amount.\r\n    * @param _placementId The placement ID.\r\n    * @return uint256\r\n    */\r\n    function getPlacementAmount(bytes32 _placementId) internal view returns (uint256) {\r\n        // return placements[_placementId].amount;\r\n        return uintStorage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".amount\"))];\r\n    }\r\n\r\n    /**\r\n    * @dev Saves placement amount.\r\n    * @param _placementId The placement ID.\r\n    * @param _amount Placement amount.\r\n    */\r\n    function setPlacementAmount(bytes32 _placementId, uint256 _amount) internal {\r\n        // placements[_placementId].amount = _amount;\r\n        uintStorage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".amount\"))] = _amount;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement credential item IDs.\r\n    * @param _placementId The placement ID.\r\n    * @return bytes32[] Array of credential item IDs.\r\n    */\r\n    function getPlacementCredentialItemIds(bytes32 _placementId)\r\n        internal\r\n        view\r\n        returns (bytes32[])\r\n    {\r\n        // uint256 count = placements[_placementId].credentialItemIdsCount;\r\n        uint256 count = uintStorage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".credentialItemIds\"))];\r\n        bytes32[] memory credentialItemIds = new bytes32[](count);\r\n        for (uint256 i = 0; i < count; i++) {\r\n            // credentialItemIds[i] = placements[_placementId].credentialItemIds[i];\r\n            credentialItemIds[i] = bytes32Storage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".credentialItemIds.\", i))];\r\n        }\r\n\r\n        return credentialItemIds;\r\n    }\r\n\r\n    /**\r\n    * @dev Saves placement credential item IDs.\r\n    * @param _placementId The placement ID.\r\n    * @param _credentialItemIds Array of credential item IDs.\r\n    */\r\n    function setPlacementCredentialItemIds(bytes32 _placementId, bytes32[] _credentialItemIds) internal\r\n    {\r\n        // placements[_placementId].credentialItemIdsCount = _credentialItemIds.length;\r\n        uintStorage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".credentialItemIds\"))] = _credentialItemIds.length;\r\n        for (uint256 i = 0; i < _credentialItemIds.length; i++) {\r\n            // placements[_placementId].credentialItemIds[i] = _credentialItemIds[i];\r\n            bytes32Storage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".credentialItemIds.\", i))] = _credentialItemIds[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Returns placement block number.\r\n    * @param _placementId The placement ID.\r\n    * @return uint256\r\n    */\r\n    function getPlacementBlockNumber(bytes32 _placementId) internal view returns (uint256) {\r\n        // return placements[_placementId].blockNumber;\r\n        return uintStorage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".blockNumber\"))];\r\n    }\r\n\r\n    /**\r\n    * @dev Saves placement block number.\r\n    * @param _placementId The placement ID.\r\n    * @param _blockNumber Placement block number.\r\n    */\r\n    function setPlacementBlockNumber(bytes32 _placementId, uint256 _blockNumber) internal {\r\n        // placements[_placementId].blockNumber = _blockNumber;\r\n        uintStorage[keccak256(abi.encodePacked(\"placements.\", _placementId, \".blockNumber\"))] = _blockNumber;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"calculatePlatformFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_placementId\",\"type\":\"bytes32\"}],\"name\":\"verifyPlacement\",\"outputs\":[{\"name\":\"placementAmount\",\"type\":\"uint256\"},{\"name\":\"placementState\",\"type\":\"uint8\"},{\"name\":\"credentialItemIds\",\"type\":\"bytes32[]\"},{\"name\":\"confirmations\",\"type\":\"uint256\"},{\"name\":\"refundable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setTimeoutThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RATE_PRECISION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestIds\",\"type\":\"bytes32[]\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_credentialItemIds\",\"type\":\"bytes32[]\"}],\"name\":\"placeBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_feeRate\",\"type\":\"uint256\"}],\"name\":\"setFeeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementation\",\"outputs\":[{\"name\":\"impl\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pricing\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestId\",\"type\":\"bytes32\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_credentialItemIds\",\"type\":\"bytes32[]\"}],\"name\":\"place\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idr\",\"type\":\"address\"},{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestId\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idr\",\"type\":\"address\"},{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestIdsToRelease\",\"type\":\"bytes32[]\"},{\"name\":\"_scopeRequestIdsToKeep\",\"type\":\"bytes32[]\"}],\"name\":\"releaseBatch\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeoutThreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idr\",\"type\":\"address\"},{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestId\",\"type\":\"bytes32\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_idr\",\"type\":\"address\"},{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestIds\",\"type\":\"bytes32[]\"}],\"name\":\"verifyBatch\",\"outputs\":[{\"name\":\"placementAmount\",\"type\":\"uint256\"},{\"name\":\"placementState\",\"type\":\"uint8\"},{\"name\":\"credentialItemIds\",\"type\":\"bytes32[]\"},{\"name\":\"confirmations\",\"type\":\"uint256\"},{\"name\":\"refundable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_idr\",\"type\":\"address\"},{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestIds\",\"type\":\"bytes32[]\"}],\"name\":\"refundBatch\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_idr\",\"type\":\"address\"},{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestId\",\"type\":\"bytes32\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"placementAmount\",\"type\":\"uint256\"},{\"name\":\"placementState\",\"type\":\"uint8\"},{\"name\":\"credentialItemIds\",\"type\":\"bytes32[]\"},{\"name\":\"confirmations\",\"type\":\"uint256\"},{\"name\":\"refundable\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformFeeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_platform\",\"type\":\"address\"},{\"name\":\"_pricing\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_idr\",\"type\":\"address\"},{\"name\":\"_idv\",\"type\":\"address\"},{\"name\":\"_scopeRequestIds\",\"type\":\"bytes32[]\"}],\"name\":\"calculatePlacementId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_platform\",\"type\":\"address\"},{\"name\":\"_pricing\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"idv\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"scopeRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"credentialItemIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"placementId\",\"type\":\"bytes32\"}],\"name\":\"EscrowPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"idv\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"scopeRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"credentialItemIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"oldPlacementId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"placementId\",\"type\":\"bytes32\"}],\"name\":\"EscrowMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"idv\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"scopeRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"platformFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"idvFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"credentialItemIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"placementId\",\"type\":\"bytes32\"}],\"name\":\"EscrowReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"idr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"idv\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"scopeRequestId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"credentialItemIds\",\"type\":\"bytes32[]\"},{\"indexed\":false,\"name\":\"placementId\",\"type\":\"bytes32\"}],\"name\":\"EscrowCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CvcEscrow","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000041e5560054824ea6b0732e656e3ad64e20e94e45000000000000000000000000870eac2766e2b051d739fc4b258069e0fb6372ed000000000000000000000000c59ade7f6ce5c061635d6db788a9477a3a3bc59f","Library":"","SwarmSource":"bzzr://366a919649902ec9b05ae5121bb100f47b74d7e3e407e2d7b3c9d4e4f02701e7"}]}