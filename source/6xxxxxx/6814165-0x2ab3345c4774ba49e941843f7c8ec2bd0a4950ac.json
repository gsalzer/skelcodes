{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/**\r\n*\r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n* Web site         - https://two4ever.club\r\n* Telegram_chat - https://t.me/two4everClub\r\n* Twitter          - https://twitter.com/ClubTwo4ever\r\n* Youtube          - https://www.youtube.com/channel/UCl4-t8RS3-kEJIGQN6Xbtng\r\n* Email:           - mailto:admin(at sign)two4ever.club  \r\n* \r\n* --- Contract configuration:\r\n*   - Daily payment of a deposit of 2%\r\n*   - Minimal contribution 0.01 eth\r\n*   - Currency and payment - ETH\r\n*   - Contribution allocation schemes:\r\n*       -- 5% Referral program (3% first level, 2% second level)\r\n*       -- 7% Advertising\r\n*       -- 5% Operating Expenses\r\n        -- 83% dividend payments\r\n* \r\n* --- Referral Program:\r\n*   - We have 2 level referral program.\r\n*   - After your referral investment you will receive 3% of his investment \r\n*   as one time bonus from 1 level and 2% form his referrals.\r\n*   - To become your referral, you future referral should specify your address\r\n*   in field DATA, while transferring ETH.\r\n*   - When making the every deposit, the referral must indicate your wallet in the data field!\r\n*   - You must have a deposit in the contract, otherwise the person invited by you will not be assigned to you\r\n*\r\n* --- Awards:   \r\n*   - The Best Investor\r\n*       Largest investor becomes common referrer for investors without referrer \r\n*       and get a lump sum of 3% of their deposits. To become winner you must invest\r\n*       more than previous winner.\r\n* \r\n*   - The Best Promoter\r\n*       Investor with the most referrals becomes common referrer for investors without referrer\r\n*       and get a lump sum of 2% of their deposits. To become winner you must invite more than\r\n*       previous winner.\r\n*\r\n* --- About the Project:\r\n*   ETH cryptocurrency distribution project\r\n*   Blockchain-enabled smart contracts have opened a new era of trustless relationships without intermediaries.\r\n*   This technology opens incredible financial possibilities. Our automated investment distribution model\r\n*   is written into a smart contract, uploaded to the Ethereum blockchain and can be freely accessed online.\r\n*   In order to insure our investors' complete secuirty, full control over the project has been transferred\r\n*   from the organizers to the smart contract: nobody can influence the system's permanent autonomous functioning.\r\n* \r\n* --- How to invest:\r\n*  1. Send from ETH wallet to the smart contract address any amount from 0.01 ETH.\r\n*  2. Verify your transaction in the history of your application or etherscan.io, specifying the address \r\n*     of your wallet.\r\n* --- How to get dividends:\r\n*     Send 0 air to the address of the contract. Be careful. You can get your dividends only once every 24 hours.\r\n*  \r\n* --- RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n*     You can check the payments on the etherscan.io site, in the \"Internal Txns\" tab of your wallet.\r\n*\r\n* ---It is not allowed to transfer from exchanges, only from your personal ETH wallet, for which you \r\n* have private keys.\r\n* \r\n* Contracts reviewed and approved by pros!\r\n* \r\n* Main contract - Two4ever. You can view the contract code by scrolling down.\r\n*/\r\ncontract Storage {\r\n// define investor model   \r\n    struct investor {\r\n        uint keyIndex;\r\n        uint value;\r\n        uint paymentTime;\r\n        uint refs;\r\n        uint refBonus;\r\n    }\r\n    // define bestAddress model for bestInvestor and bestPromoter\r\n    struct bestAddress {\r\n        uint value;\r\n        address addr;\r\n    }\r\n    // statistic model\r\n    struct recordStats {\r\n        uint strg;\r\n        uint invested;\r\n    }\r\n  \r\n    struct Data {\r\n        mapping(uint => recordStats) stats;\r\n        mapping(address => investor) investors;\r\n        address[] keys;\r\n        bestAddress bestInvestor;\r\n        bestAddress bestPromoter;\r\n    }\r\n\r\n    Data private d;\r\n\r\n    // define log event when change value of  \"bestInvestor\" or \"bestPromoter\" changed\r\n    event LogBestInvestorChanged(address indexed addr, uint when, uint invested);\r\n    event LogBestPromoterChanged(address indexed addr, uint when, uint refs);\r\n\r\n    //creating contract \r\n    constructor() public {\r\n        d.keys.length++;\r\n    }\r\n    //insert new investor  \r\n    function insert(address addr, uint value) public  returns (bool) {\r\n        uint keyIndex = d.investors[addr].keyIndex;\r\n        if (keyIndex != 0) return false;\r\n        d.investors[addr].value = value;\r\n        keyIndex = d.keys.length++;\r\n        d.investors[addr].keyIndex = keyIndex;\r\n        d.keys[keyIndex] = addr;\r\n        updateBestInvestor(addr, d.investors[addr].value);\r\n    \r\n        return true;\r\n    }\r\n    // get full information about investor by \"addr\"\r\n    function investorFullInfo(address addr) public view returns(uint, uint, uint, uint, uint) {\r\n        return (\r\n        d.investors[addr].keyIndex,\r\n        d.investors[addr].value,\r\n        d.investors[addr].paymentTime,\r\n        d.investors[addr].refs,\r\n        d.investors[addr].refBonus\r\n        );\r\n    }\r\n    // get base information about investor by \"addr\"\r\n    function investorBaseInfo(address addr) public view returns(uint, uint, uint, uint) {\r\n        return (\r\n        d.investors[addr].value,\r\n        d.investors[addr].paymentTime,\r\n        d.investors[addr].refs,\r\n        d.investors[addr].refBonus\r\n        );\r\n    }\r\n    // get short information about investor by \"addr\"\r\n    function investorShortInfo(address addr) public view returns(uint, uint) {\r\n        return (\r\n        d.investors[addr].value,\r\n        d.investors[addr].refBonus\r\n        );\r\n    }\r\n    // get current  Best Investor \r\n    function getBestInvestor() public view returns(uint, address) {\r\n        return (\r\n        d.bestInvestor.value,\r\n        d.bestInvestor.addr\r\n        );\r\n    }\r\n\r\n    // get current  Best Promoter \r\n    function getBestPromoter() public view returns(uint, address) {\r\n        return (\r\n        d.bestPromoter.value,\r\n        d.bestPromoter.addr\r\n        );\r\n    }\r\n\r\n    // add referral bonus to address \r\n    function addRefBonus(address addr, uint refBonus) public  returns (bool) {\r\n        if (d.investors[addr].keyIndex == 0) return false;\r\n        d.investors[addr].refBonus += refBonus;\r\n        return true;\r\n    }\r\n\r\n    // add referral bonus to address  and update current Best Promoter value\r\n    function addRefBonusWithRefs(address addr, uint refBonus) public  returns (bool) {\r\n        if (d.investors[addr].keyIndex == 0) return false;\r\n        d.investors[addr].refBonus += refBonus;\r\n        d.investors[addr].refs++;\r\n        updateBestPromoter(addr, d.investors[addr].refs);\r\n        return true;\r\n    }\r\n\r\n    //add  amount of invest by the address of  investor \r\n    function addValue(address addr, uint value) public  returns (bool) {\r\n        if (d.investors[addr].keyIndex == 0) return false;\r\n        d.investors[addr].value += value;\r\n        updateBestInvestor(addr, d.investors[addr].value);\r\n        return true;\r\n    }\r\n\r\n    // update statistics\r\n    function updateStats(uint dt, uint invested, uint strg) public {\r\n        d.stats[dt].invested += invested;\r\n        d.stats[dt].strg += strg;\r\n    }\r\n\r\n    // get current statistics\r\n    function stats(uint dt) public view returns (uint invested, uint strg) {\r\n        return ( \r\n        d.stats[dt].invested,\r\n        d.stats[dt].strg\r\n        );\r\n    }\r\n\r\n    // update current \"Best Investor\"\r\n    function updateBestInvestor(address addr, uint investorValue) internal {\r\n        if(investorValue > d.bestInvestor.value){\r\n            d.bestInvestor.value = investorValue;\r\n            d.bestInvestor.addr = addr;\r\n            emit LogBestInvestorChanged(addr, now, d.bestInvestor.value);\r\n        }      \r\n    }\r\n\r\n    // update value of current \"Best Promoter\"\r\n    function updateBestPromoter(address addr, uint investorRefs) internal {\r\n        if(investorRefs > d.bestPromoter.value){\r\n            d.bestPromoter.value = investorRefs;\r\n            d.bestPromoter.addr = addr;\r\n            emit LogBestPromoterChanged(addr, now, d.bestPromoter.value);\r\n        }      \r\n    }\r\n\r\n    // set time of payment \r\n    function setPaymentTime(address addr, uint paymentTime) public  returns (bool) {\r\n        if (d.investors[addr].keyIndex == 0) return false;\r\n        d.investors[addr].paymentTime = paymentTime;\r\n        return true;\r\n    }\r\n\r\n    // set referral bonus\r\n    function setRefBonus(address addr, uint refBonus) public  returns (bool) {\r\n        if (d.investors[addr].keyIndex == 0) return false;\r\n        d.investors[addr].refBonus = refBonus;\r\n        return true;\r\n    }\r\n\r\n    // check if contains such address in storage\r\n    function contains(address addr) public view returns (bool) {\r\n        return d.investors[addr].keyIndex > 0;\r\n    }\r\n\r\n    // return current number of investors\r\n    function size() public view returns (uint) {\r\n        return d.keys.length;\r\n    }\r\n}\r\n//contract for restricting access to special functionality\r\ncontract Accessibility {\r\n\r\n    address public owner;\r\n    //access modifier\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"access denied\");\r\n        _;\r\n    }\r\n    //constructor with assignment of contract holder value\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    // deletion of contract holder\r\n    function waiver() internal {\r\n        delete owner;\r\n    }\r\n}\r\n\r\n//main contract\r\ncontract Two4ever is Accessibility  {\r\n    //connecting needed libraries\r\n    using Helper for *;\r\n    using Math for *;\r\n    // define internal model of percents\r\n    struct percent {\r\n        uint val;\r\n        uint den;\r\n    }\r\n  // contract name\r\n    string public  name;\r\n  // define storage\r\n    Storage private strg;\r\n  // collection of key value pairs ffor referrals\r\n    mapping(address => address) private referrals;\r\n  //variable for admin address\r\n    address public adminAddr;\r\n  //variable for  advertise address\r\n    address public advertiseAddr;\r\n  // time  when start current wave\r\n    uint public waveStartup;\r\n\r\n    uint public totalInvestors;\r\n    uint public totalInvested;\r\n  // define constants\r\n  //size of minimal investing\r\n    uint public constant minInvesment = 10 finney; // 0.01 eth\r\n  //max size of balance \r\n    uint public constant maxBalance = 100000 ether; \r\n  // time period when dividends can be accrued\r\n    uint public constant dividendsPeriod = 24 hours; //24 hours\r\n\r\n  // define contracts percents \r\n    // percent of main dividends \r\n    percent private dividends;\r\n    // percent of admin interest \r\n    percent private adminInterest ;\r\n   // percent of 1-st level referral \r\n    percent private ref1Bonus ;\r\n   // percent of 2-nd level referral \r\n    percent private ref2Bonus ;\r\n   // percent of advertising interest \r\n    percent private advertisePersent ;\r\n    // event call when Balance has Changed\r\n    event LogBalanceChanged(uint when, uint balance);\r\n\r\n  // custom modifier for  event broadcasting\r\n    modifier balanceChanged {\r\n        _;\r\n        emit LogBalanceChanged(now, address(this).balance);\r\n    }\r\n    // constructor\r\n    // creating  contract. This function call once when contract is publishing.\r\n    constructor()  public {\r\n        name = \"two4ever.club\";\r\n      // set admin address by account address who  has published\r\n        adminAddr = msg.sender;\r\n        advertiseAddr = msg.sender;\r\n    //define value of main percents\r\n        dividends = percent(2, 100); //  2%\r\n        adminInterest = percent(5, 100); //  5%\r\n        ref1Bonus = percent(3, 100); //  3%\r\n        ref2Bonus = percent(2, 100); //  2%\r\n        advertisePersent = percent(7, 100); //  7% \r\n    // start new wave \r\n        start();\r\n    }\r\n    // set the value of the wallet address for advertising expenses\r\n    function setAdvertisingAddress(address addr) public onlyOwner {\r\n        if(addr.notEmptyAddr())\r\n        {\r\n            advertiseAddr = addr;\r\n        }\r\n    }\r\n    //set the value of the wallet address for operating expenses\r\n    function setAdminsAddress(address addr) public onlyOwner {\r\n        if(addr.notEmptyAddr())\r\n        {\r\n            adminAddr = addr;\r\n        }\r\n    }\r\n    // deletion of contract holder\r\n    function doWaiver() public onlyOwner {\r\n        waiver();\r\n    }\r\n\r\n    //functions is calling when transfer money to address of this contract\r\n    function() public payable {\r\n    // investor get him dividends when send value = 0   to address of this contract\r\n        if (msg.value == 0) {\r\n            getDividends();\r\n            return;\r\n        }\r\n\r\n    // getting referral address from data of request \r\n        address a = msg.data.toAddr();\r\n    //call invest function\r\n        invest(a);\r\n    }\r\n    // private function for get dividends\r\n    function _getMydividends(bool withoutThrow) private {\r\n    // get  investor info\r\n        Storage.investor memory investor = getMemInvestor(msg.sender);\r\n    //check if investor exists\r\n        if(investor.keyIndex <= 0){\r\n            if(withoutThrow){\r\n                return;\r\n            }\r\n            revert(\"sender is not investor\");\r\n    }\r\n\r\n    // calculate how many days have passed after last payment\r\n        uint256 daysAfter = now.sub(investor.paymentTime).div(dividendsPeriod);\r\n        if(daysAfter <= 0){\r\n            if(withoutThrow){\r\n                return;\r\n            }\r\n            revert(\"the latest payment was earlier than dividends period\");\r\n        }\r\n        assert(strg.setPaymentTime(msg.sender, now));\r\n\r\n    // calc valaue of dividends\r\n        uint value = Math.div(Math.mul(dividends.val,investor.value),dividends.den) * daysAfter;\r\n    // add referral bonus to dividends\r\n        uint divid = value+ investor.refBonus; \r\n    // check if enough money on balance of contract for payment\r\n        if (address(this).balance < divid) {\r\n            start();\r\n            return;\r\n        }\r\n  \r\n    // send dividends and ref bonus\r\n        if (investor.refBonus > 0) {\r\n            assert(strg.setRefBonus(msg.sender, 0));\r\n    //send dividends and referral bonus to investor\r\n            msg.sender.transfer(value+investor.refBonus);\r\n        } else {\r\n    //send dividends to investor\r\n            msg.sender.transfer(value);\r\n        }      \r\n    }\r\n    // public function for calling get dividends\r\n    function getDividends() public balanceChanged {\r\n        _getMydividends(false);\r\n    }\r\n    // function for investing money from investor\r\n    function invest(address ref) public payable balanceChanged {\r\n    //check minimum requirements\r\n        require(msg.value >= minInvesment, \"msg.value must be >= minInvesment\");\r\n        require(address(this).balance <= maxBalance, \"the contract eth balance limit\");\r\n    //save current money value\r\n        uint value = msg.value;\r\n    // ref system works only once for sender-referral\r\n        if (!referrals[msg.sender].notEmptyAddr()) {\r\n      //process first level of referrals\r\n            if (notZeroNotSender(ref) && strg.contains(ref)) {\r\n          //calc the reward\r\n                uint reward = Math.div(Math.mul(ref1Bonus.val,value),ref1Bonus.den);\r\n                assert(strg.addRefBonusWithRefs(ref, reward)); // referrer 1 bonus\r\n                referrals[msg.sender] = ref;\r\n\r\n        //process second level of referrals\r\n                if (notZeroNotSender(referrals[ref]) && strg.contains(referrals[ref]) && ref != referrals[ref]) { \r\n         //calc the reward\r\n                    reward = Math.div(Math.mul(ref2Bonus.val, value),ref2Bonus.den);\r\n                    assert(strg.addRefBonus(referrals[ref], reward)); // referrer 2 bonus\r\n                }\r\n                }else{\r\n         // get current Best Investor  \r\n                Storage.bestAddress memory bestInvestor = getMemBestInvestor();\r\n        // get current Best Promoter  \r\n                Storage.bestAddress memory bestPromoter = getMemBestPromoter();\r\n\r\n                if(notZeroNotSender(bestInvestor.addr)){\r\n                    assert(strg.addRefBonus(bestInvestor.addr, Math.div(Math.mul(ref1Bonus.val, value),ref1Bonus.den))); // referrer 1 bonus\r\n                    referrals[msg.sender] = bestInvestor.addr;\r\n                }\r\n                if(notZeroNotSender(bestPromoter.addr)){\r\n                    assert(strg.addRefBonus(bestPromoter.addr, Math.div(Math.mul(ref2Bonus.val, value),ref2Bonus.den))); // referrer 2 bonus\r\n                    referrals[msg.sender] = bestPromoter.addr;\r\n                }\r\n            }\r\n    }\r\n\r\n        _getMydividends(true);\r\n\r\n    // send admins share\r\n        adminAddr.transfer(Math.div(Math.mul(adminInterest.val, msg.value),adminInterest.den));\r\n    // send advertise share \r\n        advertiseAddr.transfer(Math.div(Math.mul(advertisePersent.val, msg.value),advertisePersent.den));\r\n    \r\n    // update statistics\r\n        if (strg.contains(msg.sender)) {\r\n            assert(strg.addValue(msg.sender, value));\r\n            strg.updateStats(now, value, 0);\r\n        } else {\r\n            assert(strg.insert(msg.sender, value));\r\n            strg.updateStats(now, value, 1);\r\n        }\r\n    \r\n        assert(strg.setPaymentTime(msg.sender, now));\r\n    //increase count of investments\r\n        totalInvestors++;\r\n    //increase amount of investments\r\n        totalInvested += msg.value;\r\n    }\r\n/*views */\r\n    // show number of investors\r\n    function investorsNumber() public view returns(uint) {\r\n        return strg.size()-1;\r\n    // -1 because see Storage constructor where keys.length++ \r\n    }\r\n    //show current contract balance\r\n    function balanceETH() public view returns(uint) {\r\n        return address(this).balance;\r\n    }\r\n    // show value of dividend percent\r\n    function DividendsPercent() public view returns(uint) {\r\n        return dividends.val;\r\n    }\r\n    // show value of admin percent\r\n    function AdminPercent() public view returns(uint) {\r\n        return adminInterest.val;\r\n    }\r\n     // show value of advertise persent\r\n    function AdvertisePersent() public view returns(uint) {\r\n        return advertisePersent.val;\r\n    }\r\n    // show value of referral of 1-st level percent\r\n    function FirstLevelReferrerPercent() public view returns(uint) {\r\n        return ref1Bonus.val; \r\n    }\r\n    // show value of referral of 2-nd level percent\r\n    function SecondLevelReferrerPercent() public view returns(uint) {\r\n        return ref2Bonus.val;\r\n    }\r\n    // show value of statisctics by date\r\n    function statistic(uint date) public view returns(uint amount, uint user) {\r\n        (amount, user) = strg.stats(date);\r\n    }\r\n    // show investor info  by address\r\n    function investorInfo(address addr) public view returns(uint value, uint paymentTime, uint refsCount, uint refBonus, bool isReferral) {\r\n        (value, paymentTime, refsCount, refBonus) = strg.investorBaseInfo(addr);\r\n        isReferral = referrals[addr].notEmptyAddr();\r\n    }\r\n  // show best investor info\r\n    function bestInvestor() public view returns(uint invested, address addr) {\r\n        (invested, addr) = strg.getBestInvestor();\r\n    }\r\n  // show best promoter info\r\n    function bestPromoter() public view returns(uint refs, address addr) {\r\n        (refs, addr) = strg.getBestPromoter();\r\n    }\r\n  // return full investor info by address\r\n    function getMemInvestor(address addr) internal view returns(Storage.investor) {\r\n        (uint a, uint b, uint c, uint d, uint e) = strg.investorFullInfo(addr);\r\n        return Storage.investor(a, b, c, d, e);\r\n    }\r\n  //return best investor  info \r\n    function getMemBestInvestor() internal view returns(Storage.bestAddress) {\r\n        (uint value, address addr) = strg.getBestInvestor();\r\n        return Storage.bestAddress(value, addr);\r\n    }\r\n  //return best investor promoter \r\n    function getMemBestPromoter() internal view returns(Storage.bestAddress) {\r\n        (uint value, address addr) = strg.getBestPromoter();\r\n        return Storage.bestAddress(value, addr);\r\n    }\r\n    // check if address is not empty and not equal sender address\r\n    function notZeroNotSender(address addr) internal view returns(bool) {\r\n        return addr.notEmptyAddr() && addr != msg.sender;\r\n    }\r\n\r\n/**end views */\r\n// start wave  \r\n    function start() private {\r\n        strg = new Storage();\r\n        totalInvestors = 0;\r\n        waveStartup = now;\r\n    }\r\n}\r\n\r\n// Math library with simple arithmetical functions\r\nlibrary Math {\r\n    //multiplying\r\n    function mul(uint256 num1, uint256 num2) internal pure returns (uint256) {\r\n        return  num1 * num2;\r\n        if (num1 == 0) {\r\n            return 0;\r\n        }\r\n        return num1 * num2;   \r\n    }\r\n    //divide\r\n    function div(uint256 num1, uint256 num2) internal pure returns (uint256) {\r\n        uint256 result = 0;\r\n        require(num2 > 0); \r\n        result = num1 / num2;\r\n        return result;\r\n    }\r\n    //subtract \r\n    function sub(uint256 num1, uint256 num2) internal pure returns (uint256) {\r\n        require(num2 <= num1);\r\n        uint256 result = 0;\r\n        result = num1 - num2;\r\n        return result;\r\n    }\r\n    //add \r\n    function add(uint256 num1, uint256 num2) internal pure returns (uint256) {\r\n        uint256 result = num1 + num2;\r\n        require(result >= num1);\r\n\r\n        return result;\r\n    }\r\n    //module\r\n    function mod(uint256 num1, uint256 num2) internal pure returns (uint256) {\r\n        require(num2 != 0);\r\n        return num1 % num2;\r\n    } \r\n}\r\n// Helper library with simple additional functions\r\nlibrary Helper{\r\n    //check if the address is not empty\r\n    function notEmptyAddr(address addr) internal pure returns(bool) {\r\n        return !(addr == address(0));\r\n    }\r\n     //check if the address is  empty\r\n    function isEmptyAddr(address addr) internal pure returns(bool) {\r\n        return addr == address(0);\r\n    }\r\n    // convert to address \r\n    function toAddr(uint source) internal pure returns(address) {\r\n        return address(source);\r\n    }\r\n    //convert  from bytes to address\r\n    function toAddr(bytes source) internal pure returns(address addr) {\r\n        assembly { addr := mload(add(source,0x14)) }\r\n        return addr;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AdvertisePersent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bestInvestor\",\"outputs\":[{\"name\":\"invested\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FirstLevelReferrerPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AdminPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minInvesment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"statistic\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bestPromoter\",\"outputs\":[{\"name\":\"refs\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doWaiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DividendsPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dividendsPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertiseAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SecondLevelReferrerPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdvertisingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"},{\"name\":\"refsCount\",\"type\":\"uint256\"},{\"name\":\"refBonus\",\"type\":\"uint256\"},{\"name\":\"isReferral\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"waveStartup\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceETH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"LogBalanceChanged\",\"type\":\"event\"}]","ContractName":"Two4ever","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://09dbaa2cc218f2231f5c22d7c5ad9b64ba98131938bf5bc10688c81264171f16"}]}