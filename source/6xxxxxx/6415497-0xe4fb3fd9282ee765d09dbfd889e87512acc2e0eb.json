{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.7;\r\n\r\n/* */\r\ncontract Footballmatches {\r\n    \r\n    /* */\r\n    struct FootballMatch {\r\n\r\n\t\t//       sender              team    amount\r\n\t    mapping (address => mapping (uint => uint)) bets;\r\n\t    \r\n\t    uint    totalAmount;\r\n\t    uint    claimedAmount;\r\n\t    uint[3] pools;\t\t\t// draw; 1st wins; 2nd wins\r\n\t    uint    startTime;\r\n\t    \r\n\t    uint winner;\t\t\t// 0 - draw; 1 - 1st team; 2 - 2nd team\r\n\t    bool isWinnerSet;\r\n\t    bool ownerHasClaimed;   \r\n    }    \r\n\r\n\t/* constants */    \r\n    uint constant private FEE_PERCENTAGE = 2;\r\n    \r\n    /* variables */\r\n    address         private owner;\r\n    FootballMatch[] private matches;\r\n    \r\n    /* events */\r\n    event Bet(\r\n        address indexed from, \r\n        uint    indexed matchId,\r\n        uint            team, \r\n        uint    indexed value\r\n    );\r\n    \r\n    event Claim(\r\n        address indexed from, \r\n        uint    indexed matchId, \r\n        uint            value\r\n    );    \r\n    \r\n    /* modifiers */\r\n    \r\n    /* */\r\n\tmodifier ownerOnly() {\r\n\t    require(msg.sender == owner);\r\n\t    _;\r\n\t}\r\n\t\r\n\t/* */\r\n\tmodifier winnerSet(uint matchId) {\r\n\t\trequire(matches[matchId].isWinnerSet == true);\r\n\t\t_;\r\n\t}\t\r\n\t\r\n\t/* */\r\n\tmodifier matchValid(uint matchId) {\r\n\t\trequire(matchId >= 0 && matchId < matches.length);\r\n\t\t_;\r\n\t}\r\n\t\r\n\t/* */\r\n\tmodifier teamValid(uint team) {\r\n\t\trequire(team == 0 || team == 1 || team == 2);\r\n\t\t_;\r\n\t}\t\r\n\t\r\n\t/* */\r\n\tmodifier afterStartTime(uint matchId) {\r\n\t    require(now >= matches[matchId].startTime);\r\n\t    _;\r\n\t}\t\r\n\t\r\n\t/* */\r\n\tmodifier beforeStartTime(uint matchId) {\r\n\t    require(now < matches[matchId].startTime);\r\n\t    _;\r\n\t}\t\r\n    \r\n\t/* */    \r\n    constructor() public {\r\n        \r\n        owner = msg.sender;\r\n        \r\n        uint startTime1 = 1538499300;\r\n        uint startTime2 = 1538506800;\r\n        uint startTime3 = 1538585700;\r\n        uint startTime4 = 1538593200;\r\n        \r\n        newFootballMatch(startTime1); // \"Hoffenheim\",  \"Man. City\",\r\n        newFootballMatch(startTime1); // \"Juventus\",    \"Young Boys\"\r\n        newFootballMatch(startTime2); // \"AEK\",         \"Benfica\"\r\n        newFootballMatch(startTime2); // \"Bayern\",      \"Ajax\"\r\n        newFootballMatch(startTime2); // \"Lyon\",        \"Shakhtar Donetsk\"\r\n        newFootballMatch(startTime2); // \"Roma\",        \"Plzeň\"\r\n        newFootballMatch(startTime2); // \"CSKA Moskva\", \"Real Madrid\"\r\n        newFootballMatch(startTime2); // \"Man. United\", \"Valencia\"\r\n        \r\n        newFootballMatch(startTime3); // \"Paris\",            \"Crvena zvezda\"\r\n        newFootballMatch(startTime3); // \"Lokomotiv Moskva\", \"Schalke\"\r\n        newFootballMatch(startTime4); // \"Dortmund\",         \"Monaco\"\r\n        newFootballMatch(startTime4); // \"Atlético\",         \"Club Brugge\"\r\n        newFootballMatch(startTime4); // \"PSV\",              \"Internazionale\"\r\n        newFootballMatch(startTime4); // \"Tottenham\",        \"Barcelona\"\r\n        newFootballMatch(startTime4); // \"Napoli\",           \"Liverpool\"\r\n        newFootballMatch(startTime4); // \"Porto\",            \"Galatasaray\"\r\n    }\r\n    \r\n    /* */\r\n    function newFootballMatch(uint startTime) private ownerOnly {\r\n\r\n\t\tuint matchId = matches.length;\r\n\t\tmatches.length += 1;\r\n\t\t\r\n\t\tmatches[matchId].startTime = startTime;        \r\n    }    \r\n    \r\n\t/* */\r\n\tfunction calculateFee(uint value) private pure returns (uint) {\r\n\t    return SafeMath.div(SafeMath.mul(value, FEE_PERCENTAGE), 100);\r\n\t}\r\n\t\r\n\t/* */\r\n\tfunction getOwnerPayout(uint matchId) private \r\n\t\twinnerSet(matchId) ownerOnly returns (uint) {\r\n\t\r\n\t\tif (matches[matchId].ownerHasClaimed) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\t\r\n\t\tuint payout = 0;\r\n\t\tif (matches[matchId].pools[matches[matchId].winner] != 0) {\r\n\t\t\t// we have at least one bet on a winning result\r\n\t\t\tpayout = calculateFee(matches[matchId].totalAmount);\r\n\t\t} else {\r\n\t\t\t// we have no bets on a winning result\r\n\t\t\tpayout = matches[matchId].totalAmount;\r\n\t\t}\r\n\t\t\r\n\t\tmatches[matchId].ownerHasClaimed = true;\r\n\t\treturn payout;\r\n\t}\r\n\t\r\n\t/* */\r\n\tfunction getNormalPayout(uint matchId) private \r\n\t\twinnerSet(matchId) returns (uint) {\r\n\t\r\n\t\tuint bet = matches[matchId].bets[msg.sender][matches[matchId].winner];\r\n\t\tif (bet == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n    \r\n        uint fee        = calculateFee(matches[matchId].totalAmount);\r\n        uint taxedTotal = SafeMath.sub(matches[matchId].totalAmount, fee);\r\n        uint total      = matches[matchId].pools[matches[matchId].winner];\r\n        \r\n        uint payout = SafeMath.div(SafeMath.mul(taxedTotal, bet), total);\r\n        \r\n        matches[matchId].bets[msg.sender][matches[matchId].winner] = 0;\r\n        return payout;\r\n\t}\r\n\t\r\n\t/* */\r\n\tfunction getTotalAmount(uint matchId) public \r\n\t\tmatchValid(matchId) view returns (uint) {\r\n\t\t    \r\n        return matches[matchId].totalAmount;\r\n    }\r\n    \r\n\t/* */\r\n\tfunction getClaimedAmount(uint matchId) public \r\n\t\tmatchValid(matchId) ownerOnly view returns (uint) {\r\n\t\t    \r\n        return matches[matchId].claimedAmount;\r\n    }     \r\n    \r\n    /* */\r\n    function setWinner(uint matchId, uint team) external \r\n    \tmatchValid(matchId) teamValid(team) afterStartTime(matchId) ownerOnly {\r\n    \t    \r\n        matches[matchId].winner      = team;\r\n        matches[matchId].isWinnerSet = true;\r\n    }    \r\n    \r\n\t/* */\r\n    function bet(uint matchId, uint team) external payable \r\n    \tmatchValid(matchId) teamValid(team) beforeStartTime(matchId) {\r\n    \t    \r\n        require(msg.value > 0);\r\n        \r\n        matches[matchId].totalAmount = \r\n        \tSafeMath.add(matches[matchId].totalAmount, msg.value);\r\n        matches[matchId].pools[team] = \r\n        \tSafeMath.add(matches[matchId].pools[team], msg.value);\r\n        matches[matchId].bets[msg.sender][team] = \r\n        \tSafeMath.add(matches[matchId].bets[msg.sender][team], msg.value);\r\n        \r\n        emit Bet(msg.sender, matchId, team, msg.value);\r\n    }\r\n    \r\n    /* */\r\n    function claim(uint matchId) external \r\n    \tmatchValid(matchId) winnerSet(matchId) {\r\n    \r\n    \tuint payout = 0;\r\n    \t\r\n    \tif (msg.sender == owner) {\r\n    \t\tpayout = getOwnerPayout(matchId); \r\n    \t}\r\n    \t\r\n    \t// owner can bet too\r\n    \tpayout = SafeMath.add(payout, getNormalPayout(matchId));\r\n    \trequire(payout > 0);\r\n    \t\r\n    \tmatches[matchId].claimedAmount = \r\n    \t\tSafeMath.add(matches[matchId].claimedAmount, payout);\r\n        msg.sender.transfer(payout);\r\n        \r\n        emit Claim(msg.sender, matchId, payout);\r\n    }     \r\n\r\n    /**********\r\n     Standard kill() function to recover funds \r\n     **********/\r\n\t/*    \r\n    function kill() {\r\n        if (msg.sender == owner) {\r\n            suicide(owner); // kills this contract and sends remaining funds back to creator\r\n        }\r\n    }\r\n    */\r\n}\r\n\r\n/*****************************************************************************/\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c){\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256){\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256){\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c){\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"getClaimedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"}],\"name\":\"setWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"matchId\",\"type\":\"uint256\"}],\"name\":\"getTotalAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"team\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Bet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"matchId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Claim\",\"type\":\"event\"}]","ContractName":"Footballmatches","CompilerVersion":"v0.4.26-nightly.2018.9.25+commit.1b8334e5","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f39d2b50256cccc81daeddaf72cfbf2c5439bee791a08e4f28ca12adbcfb71f2"}]}