{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\n\r\n\r\n\r\ninterface ERC20Interface {\r\nfunction totalSupply() external view returns (uint256);\r\n\r\n\r\n\r\n\r\nfunction balanceOf(address who) external view returns (uint256);\r\n\r\n\r\n\r\n\r\nfunction allowance(address owner, address spender)\r\nexternal view returns (uint256);\r\n\r\n\r\n\r\n\r\nfunction transfer(address to, uint256 value) external returns (bool);\r\n\r\n\r\n\r\n\r\nfunction approve(address spender, uint256 value)\r\nexternal returns (bool);\r\n\r\n\r\n\r\n\r\nfunction transferFrom(address from, address to, uint256 value)\r\nexternal returns (bool);\r\n\r\n\r\n\r\n\r\nevent Transfer(\r\naddress indexed from,\r\naddress indexed to,\r\nuint256 value\r\n);\r\n\r\n\r\n\r\n\r\nevent Approval(\r\naddress indexed owner,\r\naddress indexed spender,\r\nuint256 value\r\n);\r\n}\r\n\r\n\r\n\r\n\r\ncontract OpsCoin is ERC20Interface {\r\n\r\n\r\n\r\n\r\n/**\r\n@notice © Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\r\n*/\r\n\r\n\r\n\r\n\r\nusing SafeMath for uint256;\r\n\r\n\r\n\r\n\r\nstring public symbol;\r\nstring public name;\r\naddress public owner;\r\nuint256 public totalSupply;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nmapping (address => uint256) private balances;\r\nmapping (address => mapping (address => uint256)) private allowed;\r\nmapping (address => mapping (address => uint)) private timeLock;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconstructor() {\r\nsymbol = \"OPS\";\r\nname = \"EY OpsCoin\";\r\ntotalSupply = 1000000;\r\nowner = msg.sender;\r\nbalances[owner] = totalSupply;\r\nemit Transfer(address(0), owner, totalSupply);\r\n}\r\n\r\n\r\n\r\n\r\n//only owner  modifier\r\nmodifier onlyOwner () {\r\nrequire(msg.sender == owner);\r\n_;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nself destruct added by westlad\r\n*/\r\nfunction close() public onlyOwner {\r\nselfdestruct(owner);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Gets the balance of the specified address.\r\n* @param _address The address to query the balance of.\r\n* @return An uint256 representing the amount owned by the passed address.\r\n*/\r\nfunction balanceOf(address _address) public view returns (uint256) {\r\nreturn balances[_address];\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n* @param _owner address The address which owns the funds.\r\n* @param _spender address The address which will spend the funds.\r\n* @return A uint256 specifying the amount of tokens still available for the spender.\r\n*/\r\nfunction allowance(address _owner, address _spender) public view returns (uint256)\r\n{\r\nreturn allowed[_owner][_spender];\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Total number of tokens in existence\r\n*/\r\nfunction totalSupply() public view returns (uint256) {\r\nreturn totalSupply;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Internal function that mints an amount of the token and assigns it to\r\n* an account. This encapsulates the modification of balances such that the\r\n* proper events are emitted.\r\n* @param _account The account that will receive the created tokens.\r\n* @param _amount The amount that will be created.\r\n*/\r\nfunction mint(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount > 0);\r\ntotalSupply = totalSupply.add(_amount);\r\nbalances[_account] = balances[_account].add(_amount);\r\nemit Transfer(address(0), _account, _amount);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Internal function that burns an amount of the token of a given\r\n* account.\r\n* @param _account The account whose tokens will be burnt.\r\n* @param _amount The amount that will be burnt.\r\n*/\r\nfunction burn(address _account, uint256 _amount) public {\r\nrequire(_account != 0);\r\nrequire(_amount <= balances[_account]);\r\n\r\n\r\n\r\n\r\ntotalSupply = totalSupply.sub(_amount);\r\nbalances[_account] = balances[_account].sub(_amount);\r\nemit Transfer(_account, address(0), _amount);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Internal function that burns an amount of the token of a given\r\n* account, deducting from the sender's allowance for said account. Uses the\r\n* internal burn function.\r\n* @param _account The account whose tokens will be burnt.\r\n* @param _amount The amount that will be burnt.\r\n*/\r\nfunction burnFrom(address _account, uint256 _amount) public {\r\nrequire(_amount <= allowed[_account][msg.sender]);\r\n\r\n\r\n\r\n\r\nallowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount);\r\nemit Approval(_account, msg.sender, allowed[_account][msg.sender]);\r\nburn(_account, _amount);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Transfer token for a specified address\r\n* @param _to The address to transfer to.\r\n* @param _value The amount to be transferred.\r\n*/\r\nfunction transfer(address _to, uint256 _value) public returns (bool) {\r\nrequire(_value <= balances[msg.sender]);\r\nrequire(_to != address(0));\r\n\r\n\r\n\r\n\r\nbalances[msg.sender] = balances[msg.sender].sub(_value);\r\nbalances[_to] = balances[_to].add(_value);\r\nemit Transfer(msg.sender, _to, _value);\r\nreturn true;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n* Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n* @param _spender The address which will spend the funds.\r\n* @param _value The amount of tokens to be spent.\r\n*/\r\nfunction approve(address _spender, uint256 _value) public returns (bool) {\r\nrequire(_spender != address(0));\r\n\r\n\r\n\r\n\r\nallowed[msg.sender][_spender] = _value;\r\nemit Approval(msg.sender, _spender, _value);\r\nreturn true;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Approve the passed address to spend the specified amount of tokens after a specfied amount of time on behalf of msg.sender.\r\n* Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n* and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n* race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n* https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n* @param _spender The address which will spend the funds.\r\n* @param _value The amount of tokens to be spent.\r\n* @param _timeLockTill The time until when this amount cannot be withdrawn\r\n*/\r\nfunction approveAt(address _spender, uint256 _value, uint _timeLockTill) public returns (bool) {\r\nrequire(_spender != address(0));\r\n\r\n\r\n\r\n\r\nallowed[msg.sender][_spender] = _value;\r\ntimeLock[msg.sender][_spender] = _timeLockTill;\r\nemit Approval(msg.sender, _spender, _value);\r\nreturn true;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Transfer tokens from one address to another\r\n* @param _from address The address which you want to send tokens from\r\n* @param _to address The address which you want to transfer to\r\n* @param _value uint256 the amount of tokens to be transferred\r\n*/\r\nfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool)\r\n{\r\nrequire(_value <= balances[_from]);\r\nrequire(_value <= allowed[_from][msg.sender]);\r\nrequire(_to != address(0));\r\n\r\n\r\n\r\n\r\nbalances[_from] = balances[_from].sub(_value);\r\nbalances[_to] = balances[_to].add(_value);\r\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\nemit Transfer(_from, _to, _value);\r\nreturn true;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Transfer tokens from one address to another\r\n* @param _from address The address which you want to send tokens from\r\n* @param _to address The address which you want to transfer to\r\n* @param _value uint256 the amount of tokens to be transferred\r\n*/\r\nfunction transferFromAt(address _from, address _to, uint256 _value) public returns (bool)\r\n{\r\nrequire(_value <= balances[_from]);\r\nrequire(_value <= allowed[_from][msg.sender]);\r\nrequire(_to != address(0));\r\nrequire(block.timestamp > timeLock[_from][msg.sender]);\r\n\r\n\r\n\r\n\r\nbalances[_from] = balances[_from].sub(_value);\r\nbalances[_to] = balances[_to].add(_value);\r\nallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\nemit Transfer(_from, _to, _value);\r\nreturn true;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Increase the amount of tokens that an owner allowed to a spender.\r\n* approve should be called when allowed_[_spender] == 0. To increment\r\n* allowed value is better to use this function to avoid 2 calls (and wait until\r\n* the first transaction is mined)\r\n* From MonolithDAO Token.sol\r\n* @param _spender The address which will spend the funds.\r\n* @param _addedValue The amount of tokens to increase the allowance by.\r\n*/\r\nfunction increaseAllowance(address _spender, uint256 _addedValue) public returns (bool)\r\n{\r\nrequire(_spender != address(0));\r\n\r\n\r\n\r\n\r\nallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\r\nemit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\nreturn true;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n* approve should be called when allowed_[_spender] == 0. To decrement\r\n* allowed value is better to use this function to avoid 2 calls (and wait until\r\n* the first transaction is mined)\r\n* From MonolithDAO Token.sol\r\n* @param _spender The address which will spend the funds.\r\n* @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n*/\r\nfunction decreaseAllowance(address _spender, uint256 _subtractedValue) public returns (bool)\r\n{\r\nrequire(_spender != address(0));\r\n\r\n\r\n\r\n\r\nallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].sub(_subtractedValue));\r\nemit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\nreturn true;\r\n}\r\n\r\n\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Verifier{\r\nfunction verifyTx(\r\nuint[2],\r\nuint[2],\r\nuint[2][2],\r\nuint[2],\r\nuint[2],\r\nuint[2],\r\nuint[2],\r\nuint[2],\r\naddress\r\n) public pure returns (bool){}\r\n\r\n\r\n\r\n\r\n/**\r\n@notice © Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\r\n*/\r\nfunction getInputBits(uint, address) public view returns(bytes8){}\r\n}\r\n\r\n\r\n\r\n\r\ncontract OpsCoinShield{\r\n\r\n\r\n\r\n\r\n/**\r\n@notice © Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\r\n\r\n\r\n\r\n\r\nContract to enable the management of ZKSnark-hidden coin transactions.\r\n*/\r\n\r\n\r\n\r\n\r\naddress public owner;\r\nbytes8[merkleWidth] ns; //store spent token nullifiers\r\nuint constant merkleWidth = 256;\r\nuint constant merkleDepth = 9;\r\nuint constant lastRow = merkleDepth-1;\r\nuint private balance = 0;\r\nbytes8[merkleWidth] private zs; //array holding the commitments.  Basically the bottom row of the merkle tree\r\nuint private zCount; //remember the number of commitments we hold\r\nuint private nCount; //remember the number of commitments we spent\r\nbytes8[] private roots; //holds each root we've calculated so that we can pull the one relevant to the prover\r\nuint private currentRootIndex; //holds the index for the current root so that the\r\n//prover can provide it later and this contract can look up the relevant root\r\nVerifier private mv; //the verification smart contract that the mint function uses\r\nVerifier private sv; //the verification smart contract that the transfer function uses\r\nOpsCoin private ops; //the OpsCoin ERC20-like token contract\r\nstruct Proof { //recast this as a struct because otherwise, as a set of local variable, it takes too much stack space\r\nuint[2] a;\r\nuint[2] a_p;\r\nuint[2][2] b;\r\nuint[2] b_p;\r\nuint[2] c;\r\nuint[2] c_p;\r\nuint[2] h;\r\nuint[2] k;\r\n}\r\n//Proof proof; //not used - proof is now set per address\r\nmapping(address => Proof) private proofs;\r\n\r\n\r\n\r\n\r\nconstructor(address mintVerifier, address transferVerifier, address opsCoin) public {\r\n// TODO - you can get a way with a single, generic verifier.\r\nowner = msg.sender;\r\nmv = Verifier(mintVerifier);\r\nsv = Verifier(transferVerifier);\r\nops = OpsCoin(opsCoin);\r\n}\r\n\r\n\r\n\r\n\r\n//only owner  modifier\r\nmodifier onlyOwner () {\r\nrequire(msg.sender == owner);\r\n_;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nself destruct added by westlad\r\n*/\r\nfunction close() public onlyOwner {\r\nselfdestruct(owner);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nfunction getMintVerifier() public view returns(address){\r\nreturn address(mv);\r\n}\r\n\r\n\r\n\r\n\r\nfunction getTransferVerifier() public view returns(address){\r\nreturn address(sv);\r\n}\r\n\r\n\r\n\r\n\r\nfunction getOpsCoin() public view returns(address){\r\nreturn address(ops);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nThe mint function accepts opscoin and creates the same amount as a commitment.\r\n*/\r\nfunction mint(uint amount) public {\r\n//first, verify the proof\r\n\r\n\r\n\r\n\r\nbool result = mv.verifyTx(\r\nproofs[msg.sender].a,\r\nproofs[msg.sender].a_p,\r\nproofs[msg.sender].b,\r\nproofs[msg.sender].b_p,\r\nproofs[msg.sender].c,\r\nproofs[msg.sender].c_p,\r\nproofs[msg.sender].h,\r\nproofs[msg.sender].k,\r\nmsg.sender);\r\n\r\n\r\n\r\n\r\nrequire(result); //the proof must check out\r\n//transfer OPS from the sender to this contract\r\nops.transferFrom(msg.sender, address(this), amount);\r\n//save the commitments\r\nbytes8 z = mv.getInputBits(64, msg.sender);//recover the input params from MintVerifier\r\nzs[zCount++] = z; //add the token\r\nrequire(uint(mv.getInputBits(0, msg.sender))==amount); //check we've been correctly paid\r\nbytes8 root = merkle(0,0); //work out the Merkle root as it's now different\r\ncurrentRootIndex = roots.push(root)-1; //and save it to the list\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nThe transfer function transfers a commitment to a new owner\r\n*/\r\nfunction transfer() public {\r\n//verification contract\r\nbool result = sv.verifyTx(\r\nproofs[msg.sender].a,\r\nproofs[msg.sender].a_p,\r\nproofs[msg.sender].b,\r\nproofs[msg.sender].b_p,\r\nproofs[msg.sender].c,\r\nproofs[msg.sender].c_p,\r\nproofs[msg.sender].h,\r\nproofs[msg.sender].k,\r\nmsg.sender);\r\nrequire(result); //the proof must verify. The spice must flow.\r\n\r\n\r\n\r\n\r\nbytes8 nc = sv.getInputBits(0, msg.sender);\r\nbytes8 nd = sv.getInputBits(64, msg.sender);\r\nbytes8 ze = sv.getInputBits(128, msg.sender);\r\nbytes8 zf = sv.getInputBits(192, msg.sender);\r\nfor (uint i=0; i<nCount; i++) { //check this is an unspent coin\r\nrequire(ns[i]!=nc && ns[i]!=nd);\r\n}\r\nns[nCount++] = nc; //remember we spent it\r\nns[nCount++] = nd; //remember we spent it\r\nzs[zCount++] = ze; //add Bob's commitment to the list of commitments\r\nzs[zCount++] = zf; //add Alice's commitment to the list of commitment\r\nbytes8 root = merkle(0,0); //work out the Merkle root as it's now different\r\ncurrentRootIndex = roots.push(root)-1; //and save it to the list\r\n}\r\n\r\n\r\n\r\n\r\nfunction burn(address payTo) public {\r\n//first, verify the proof\r\nbool result = mv.verifyTx(\r\nproofs[msg.sender].a,\r\nproofs[msg.sender].a_p,\r\nproofs[msg.sender].b,\r\nproofs[msg.sender].b_p,\r\nproofs[msg.sender].c,\r\nproofs[msg.sender].c_p,\r\nproofs[msg.sender].h,\r\nproofs[msg.sender].k,\r\nmsg.sender);\r\n\r\n\r\n\r\n\r\nrequire(result); //the proof must check out ok\r\n//transfer OPS from this contract to the nominated address\r\nbytes8 C = mv.getInputBits(0, msg.sender);//recover the coin value\r\nuint256 value = uint256(C); //convert the coin value to a uint\r\nops.transfer(payTo, value); //and pay the man\r\nbytes8 Nc = mv.getInputBits(64, msg.sender); //recover the nullifier\r\nns[nCount++] = Nc; //add the nullifier to the list of nullifiers\r\nbytes8 root = merkle(0,0); //work out the Merkle root as it's now different\r\ncurrentRootIndex = roots.push(root)-1; //and save it to the list\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nThis function is only needed because mint and transfer otherwise use too many\r\nlocal variables for the limited stack space, rather than pass a proof as\r\nparameters to these functions (more logical)\r\n*/\r\nfunction setProofParams(\r\nuint[2] a,\r\nuint[2] a_p,\r\nuint[2][2] b,\r\nuint[2] b_p,\r\nuint[2] c,\r\nuint[2] c_p,\r\nuint[2] h,\r\nuint[2] k)\r\npublic {\r\n//TODO there must be a shorter way to do this:\r\nproofs[msg.sender].a[0] = a[0];\r\nproofs[msg.sender].a[1] = a[1];\r\nproofs[msg.sender].a_p[0] = a_p[0];\r\nproofs[msg.sender].a_p[1] = a_p[1];\r\nproofs[msg.sender].b[0][0] = b[0][0];\r\nproofs[msg.sender].b[0][1] = b[0][1];\r\nproofs[msg.sender].b[1][0] = b[1][0];\r\nproofs[msg.sender].b[1][1] = b[1][1];\r\nproofs[msg.sender].b_p[0] = b_p[0];\r\nproofs[msg.sender].b_p[1] = b_p[1];\r\nproofs[msg.sender].c[0] = c[0];\r\nproofs[msg.sender].c[1] = c[1];\r\nproofs[msg.sender].c_p[0] = c_p[0];\r\nproofs[msg.sender].c_p[1] = c_p[1];\r\nproofs[msg.sender].h[0] = h[0];\r\nproofs[msg.sender].h[1] = h[1];\r\nproofs[msg.sender].k[0] = k[0];\r\nproofs[msg.sender].k[1] = k[1];\r\n}\r\n\r\n\r\n\r\n\r\nfunction getTokens() public view returns(bytes8[merkleWidth], uint root) {\r\n//need the commitments to compute a proof and also an index to look up the current\r\n//root.\r\nreturn (zs,currentRootIndex);\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\nFunction to return the root that was current at rootIndex\r\n*/\r\nfunction getRoot(uint rootIndex) view public returns(bytes8) {\r\nreturn roots[rootIndex];\r\n}\r\n\r\n\r\n\r\n\r\nfunction computeMerkle() public view returns (bytes8){//for backwards compat\r\nreturn merkle(0,0);\r\n}\r\n\r\n\r\n\r\n\r\nfunction merkle(uint r, uint t) public view returns (bytes8) {\r\n//This is a recursive approach, which seems efficient but we do end up\r\n//calculating the whole tree from scratch each time.  Need to look at storing\r\n//intermediate values and seeing if that will make it cheaper.\r\nif (r==lastRow) {\r\nreturn zs[t];\r\n} else {\r\nreturn bytes8(sha256(merkle(r+1,2*t)^merkle(r+1,2*t+1))<<192);\r\n}\r\n}\r\n}\r\n\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Multiplies two numbers, reverts on overflow.\r\n*/\r\nfunction mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n// Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n// benefit is lost if 'b' is also tested.\r\n// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\nif (a == 0) {\r\nreturn 0;\r\n}\r\n\r\n\r\n\r\n\r\nuint256 c = a * b;\r\nrequire(c / a == b);\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n*/\r\nfunction div(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b > 0); // Solidity only automatically asserts when dividing by 0\r\nuint256 c = a / b;\r\n// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n*/\r\nfunction sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b <= a);\r\nuint256 c = a - b;\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Adds two numbers, reverts on overflow.\r\n*/\r\nfunction add(uint256 a, uint256 b) internal pure returns (uint256) {\r\nuint256 c = a + b;\r\nrequire(c >= a);\r\n\r\n\r\n\r\n\r\nreturn c;\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n* reverts when dividing by zero.\r\n*/\r\nfunction mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\nrequire(b != 0);\r\nreturn a % b;\r\n}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"computeMerkle\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256[2]\"},{\"name\":\"a_p\",\"type\":\"uint256[2]\"},{\"name\":\"b\",\"type\":\"uint256[2][2]\"},{\"name\":\"b_p\",\"type\":\"uint256[2]\"},{\"name\":\"c\",\"type\":\"uint256[2]\"},{\"name\":\"c_p\",\"type\":\"uint256[2]\"},{\"name\":\"h\",\"type\":\"uint256[2]\"},{\"name\":\"k\",\"type\":\"uint256[2]\"}],\"name\":\"setProofParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payTo\",\"type\":\"address\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMintVerifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpsCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rootIndex\",\"type\":\"uint256\"}],\"name\":\"getRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8[256]\"},{\"name\":\"root\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransferVerifier\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"r\",\"type\":\"uint256\"},{\"name\":\"t\",\"type\":\"uint256\"}],\"name\":\"merkle\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"mintVerifier\",\"type\":\"address\"},{\"name\":\"transferVerifier\",\"type\":\"address\"},{\"name\":\"opsCoin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"OpsCoinShield","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000006b98f17897a5086ff3e7357290b36022798d8850000000000000000000000000cb4ccc716abe1b5be15870e2bfa12bf5f0b501e600000000000000000000000009b2d8b8741538abf56f47be76e37aed31f00e0d","Library":"","SwarmSource":"bzzr://380fd5ff48ceaaf6670658c3ac63d271688f8b9c2d785a7322506859585d1467"}]}