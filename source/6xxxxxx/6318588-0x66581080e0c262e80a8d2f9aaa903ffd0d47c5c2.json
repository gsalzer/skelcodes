{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\ncontract AccessControl {\r\n     /// @dev Emited when contract is upgraded - See README.md for updgrade plan\r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n\r\n    address newContractAddress;\r\n\r\n    uint public totalTipForDeveloper = 0;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress, \"You're not a CEO!\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress, \"You're not a CFO!\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress, \"You're not a COO!\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyCLevel() {\r\n        require((msg.sender == cooAddress || msg.sender == ceoAddress || msg.sender == cfoAddress), \"You're not C-Level\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Wrong send eth! It's will tip for developer\r\n    function () public payable{\r\n        totalTipForDeveloper = totalTipForDeveloper + msg.value;\r\n    }\r\n\r\n    /// @dev Add tip for developer\r\n    /// @param valueTip The value of tip\r\n    function addTipForDeveloper(uint valueTip) internal {\r\n        totalTipForDeveloper += valueTip;\r\n    }\r\n\r\n    /// @dev Developer can withdraw tip.\r\n    function withdrawTipForDeveloper() external onlyCEO {\r\n        require(totalTipForDeveloper > 0, \"Need more tip to withdraw!\");\r\n        msg.sender.transfer(totalTipForDeveloper);\r\n        totalTipForDeveloper = 0;\r\n    }\r\n\r\n    // updgrade\r\n    function setNewAddress(address newContract) external onlyCEO whenPaused {\r\n        newContractAddress = newContract;\r\n        emit ContractUpgrade(newContract);\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) external onlyCEO {\r\n        require(_newCEO != address(0), \"Address to set CEO wrong!\");\r\n\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new CFO\r\n    function setCFO(address _newCFO) external onlyCEO {\r\n        require(_newCFO != address(0), \"Address to set CFO wrong!\");\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address _newCOO) external onlyCEO {\r\n        require(_newCOO != address(0), \"Address to set COO wrong!\");\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /*Pausable functionality adapted from OpenZeppelin */\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"Paused!\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused, \"Not paused!\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() external onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    /// @notice This is public rather than external so it can be called by\r\n    ///  derived contracts.\r\n    function unpause() public onlyCEO whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract RPSCore is AccessControl {\r\n    uint constant ROCK = 1000;\r\n    uint constant PAPER = 2000;\r\n    uint constant SCISSOR = 3000;\r\n\r\n    uint constant GAME_RESULT_DRAW = 1;\r\n    uint constant GAME_RESULT_HOST_WIN = 2;\r\n    uint constant GAME_RESULT_GUEST_WIN = 3;\r\n\r\n    uint constant DEVELOPER_TIP_PERCENT = 1;\r\n    uint constant DEVELOPER_TIP_MIN = 0.0005 ether;\r\n\r\n    uint constant VALUE_BET_MIN = 0.01 ether;\r\n    uint constant VALUE_BET_MAX = 5 ether;\r\n\r\n    struct GameInfo {\r\n        uint id;\r\n        uint valueBet;\r\n        address addressHost;  \r\n    }\r\n\r\n    struct GameSecret {\r\n        uint gestureHost;\r\n    }\r\n\r\n    event LogCloseGameSuccessed(uint _id, uint _valueReturn);\r\n    event LogCreateGameSuccessed(uint _id, uint _valuePlayerHostBid);\r\n    event LogJoinAndBattleSuccessed(uint _id,\r\n                                    uint _result,\r\n                                    address indexed _addressPlayerWin,\r\n                                    address indexed _addressPlayerLose,\r\n                                    uint _valuePlayerWin,\r\n                                    uint _valuePlayerLose,\r\n                                    uint _gesturePlayerWin,\r\n                                    uint _gesturePlayerLose);\r\n \r\n    uint public totalCreatedGame;\r\n    uint public totalAvailableGames;\r\n    GameInfo[] public arrAvailableGames;\r\n    mapping(uint => uint) idToIndexAvailableGames;\r\n    mapping(uint => GameSecret) idToGameSecret;\r\n\r\n    constructor() public {\r\n        ceoAddress = msg.sender;\r\n        cfoAddress = msg.sender;\r\n        cooAddress = msg.sender;\r\n\r\n        totalCreatedGame = 0;\r\n        totalAvailableGames = 0;\r\n    }\r\n\r\n    function createGame(uint _gestureHost)\r\n        external\r\n        payable\r\n        verifiedGesture(_gestureHost)\r\n        verifiedValueBet(msg.value)\r\n    {\r\n        GameInfo memory gameInfo = GameInfo({\r\n            id: totalCreatedGame + 1,\r\n            addressHost: msg.sender,\r\n            valueBet: msg.value\r\n        });\r\n\r\n        GameSecret memory gameSecret = GameSecret({\r\n            gestureHost: _gestureHost\r\n        });\r\n\r\n        arrAvailableGames.push(gameInfo);\r\n        idToIndexAvailableGames[gameInfo.id] = arrAvailableGames.length - 1;\r\n        idToGameSecret[gameInfo.id] = gameSecret;\r\n\r\n        totalCreatedGame++;\r\n        totalAvailableGames++;\r\n\r\n        emit LogCreateGameSuccessed(gameInfo.id, gameInfo.valueBet);\r\n    }\r\n\r\n    function joinGameAndBattle(uint _id, uint _gestureGuest)\r\n        external\r\n        payable \r\n        verifiedGesture(_gestureGuest)\r\n        verifiedValueBet(msg.value)\r\n        verifiedGameAvailable(_id)\r\n    {\r\n        uint result = GAME_RESULT_DRAW;\r\n        uint gestureHostCached = 0;\r\n\r\n        GameInfo memory gameInfo = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n       \r\n        require(gameInfo.addressHost != msg.sender, \"Don't play with yourself\");\r\n        require(msg.value == gameInfo.valueBet, \"Value bet to battle not extractly with value bet of host\");\r\n        \r\n        gestureHostCached = idToGameSecret[gameInfo.id].gestureHost;\r\n\r\n        //Result: [Draw] => Return money to host and guest players (No fee)\r\n        if(gestureHostCached == _gestureGuest) {\r\n            result = GAME_RESULT_DRAW;\r\n            sendPayment(msg.sender, msg.value);\r\n            sendPayment(gameInfo.addressHost, gameInfo.valueBet);\r\n            destroyGame(_id);\r\n            emit LogJoinAndBattleSuccessed(_id,\r\n                                            GAME_RESULT_DRAW,\r\n                                            gameInfo.addressHost,\r\n                                            msg.sender,\r\n                                            0,\r\n                                            0,\r\n                                            gestureHostCached, \r\n                                            _gestureGuest);\r\n        }\r\n        else {\r\n            if(gestureHostCached == ROCK) \r\n                result = _gestureGuest == SCISSOR ? GAME_RESULT_HOST_WIN : GAME_RESULT_GUEST_WIN;\r\n            else\r\n                if(gestureHostCached == PAPER) \r\n                    result = (_gestureGuest == ROCK ? GAME_RESULT_HOST_WIN : GAME_RESULT_GUEST_WIN);\r\n                else\r\n                    if(gestureHostCached == SCISSOR) \r\n                        result = (_gestureGuest == PAPER ? GAME_RESULT_HOST_WIN : GAME_RESULT_GUEST_WIN);\r\n\r\n            //Result: [Win] => Return money to winner (Winner will pay 1% fee)\r\n            uint valueTip = getValueTip(gameInfo.valueBet);\r\n            addTipForDeveloper(valueTip);\r\n            \r\n            if(result == GAME_RESULT_HOST_WIN) {\r\n                sendPayment(gameInfo.addressHost, gameInfo.valueBet * 2 - valueTip);\r\n                destroyGame(_id);    \r\n                emit LogJoinAndBattleSuccessed(_id,\r\n                                                result,\r\n                                                gameInfo.addressHost,\r\n                                                msg.sender,\r\n                                                gameInfo.valueBet - valueTip,\r\n                                                gameInfo.valueBet,\r\n                                                gestureHostCached,\r\n                                                _gestureGuest);\r\n            }\r\n            else {\r\n                sendPayment(msg.sender, gameInfo.valueBet * 2 - valueTip);\r\n                destroyGame(_id);\r\n                emit LogJoinAndBattleSuccessed(_id,\r\n                                                result,\r\n                                                msg.sender,\r\n                                                gameInfo.addressHost,\r\n                                                gameInfo.valueBet - valueTip,\r\n                                                gameInfo.valueBet,\r\n                                                _gestureGuest,\r\n                                                gestureHostCached);\r\n            }          \r\n        }\r\n\r\n    }\r\n\r\n    function closeMyGame(uint _id) external payable verifiedHostOfGame(_id) verifiedGameAvailable(_id) {\r\n        GameInfo storage gameInfo = arrAvailableGames[idToIndexAvailableGames[_id]];\r\n\r\n        require(gameInfo.valueBet > 0, \"Can't close game!\");\r\n\r\n        uint valueBet = gameInfo.valueBet;\r\n        gameInfo.valueBet = 0;\r\n        sendPayment(gameInfo.addressHost, valueBet);\r\n        destroyGame(_id);\r\n        emit LogCloseGameSuccessed(_id, valueBet);\r\n    }\r\n\r\n    function () public payable {\r\n    }\r\n\r\n    function destroyGame(uint _id) private {\r\n        uint indexGameInfo = idToIndexAvailableGames[_id];\r\n        delete idToIndexAvailableGames[_id];\r\n        delete idToGameSecret[_id];\r\n        removeGameInfoFromArray(indexGameInfo);\r\n        totalAvailableGames--;\r\n    }\r\n\r\n    function removeGameInfoFromArray(uint _index) private {\r\n        if(_index >= 0 && arrAvailableGames.length > 0) {\r\n            if(_index == arrAvailableGames.length - 1)\r\n            arrAvailableGames.length--;\r\n            else {\r\n                arrAvailableGames[_index] = arrAvailableGames[arrAvailableGames.length - 1];\r\n                idToIndexAvailableGames[arrAvailableGames[_index].id] = _index;\r\n                arrAvailableGames.length--;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getValueTip(uint _valueWin) private pure returns(uint) {\r\n        uint valueTip = _valueWin * DEVELOPER_TIP_PERCENT / 100;\r\n\r\n        if(valueTip < DEVELOPER_TIP_MIN)\r\n            valueTip = DEVELOPER_TIP_MIN;\r\n\r\n        return valueTip;\r\n    }\r\n\r\n    function sendPayment(address _receiver, uint _amount) private {\r\n        _receiver.transfer(_amount);\r\n    }\r\n\r\n    modifier verifiedGameAvailable(uint _id) {\r\n        require(idToIndexAvailableGames[_id] >= 0, \"Game ID not exist!\");\r\n        _;\r\n    }\r\n\r\n    modifier verifiedGesture(uint _resultSelect) {\r\n        require((_resultSelect == ROCK || _resultSelect == PAPER || _resultSelect == SCISSOR), \"Gesture can't verify\");\r\n        _;\r\n    }\r\n\r\n    modifier verifiedHostOfGame(uint _id) {\r\n        require(msg.sender == arrAvailableGames[idToIndexAvailableGames[_id]].addressHost, \"Verify host of game failed\");\r\n        _;\r\n    }\r\n\r\n    modifier verifiedValueBet(uint _valueBet) {\r\n        require(_valueBet >= VALUE_BET_MIN && _valueBet <= VALUE_BET_MAX, \"Your value bet out of rule\");\r\n        _;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTipForDeveloper\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"closeMyGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAvailableGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gestureHost\",\"type\":\"uint256\"}],\"name\":\"createGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"setNewAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCreatedGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_gestureGuest\",\"type\":\"uint256\"}],\"name\":\"joinGameAndBattle\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTipForDeveloper\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"arrAvailableGames\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"valueBet\",\"type\":\"uint256\"},{\"name\":\"addressHost\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_valueReturn\",\"type\":\"uint256\"}],\"name\":\"LogCloseGameSuccessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_valuePlayerHostBid\",\"type\":\"uint256\"}],\"name\":\"LogCreateGameSuccessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_result\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_addressPlayerWin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_addressPlayerLose\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_valuePlayerWin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_valuePlayerLose\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gesturePlayerWin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_gesturePlayerLose\",\"type\":\"uint256\"}],\"name\":\"LogJoinAndBattleSuccessed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"RPSCore","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2cef5f5160b7dfeb83d2c9e8f69d46884a60c18005d02761d8c14b07a1161ce8"}]}