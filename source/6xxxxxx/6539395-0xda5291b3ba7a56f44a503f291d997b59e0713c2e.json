{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title Initializable\r\n *\r\n * @dev Helper contract to support initializer functions. To use it, replace\r\n * the constructor with a function that has the `initializer` modifier.\r\n * WARNING: Unlike constructors, initializer functions must be manually\r\n * invoked. This applies both to deploying an Initializable contract, as well\r\n * as extending an Initializable contract via inheritance.\r\n * WARNING: When used with inheritance, manual care must be taken to not invoke\r\n * a parent initializer twice, or ensure that all initializers are idempotent,\r\n * because this is not dealt with automatically as with constructors.\r\n */\r\ncontract Initializable {\r\n\r\n  /**\r\n   * @dev Indicates that the contract has been initialized.\r\n   */\r\n  bool private initialized;\r\n\r\n  /**\r\n   * @dev Indicates that the contract is in the process of being initialized.\r\n   */\r\n  bool private initializing;\r\n\r\n  /**\r\n   * @dev Modifier to use in the initializer function of a contract.\r\n   */\r\n  modifier initializer() {\r\n    require(initializing || isConstructor() || !initialized, \"Contract instance has already been initialized\");\r\n\r\n    bool wasInitializing = initializing;\r\n    initializing = true;\r\n    initialized = true;\r\n\r\n    _;\r\n\r\n    initializing = wasInitializing;\r\n  }\r\n\r\n  /// @dev Returns true if and only if the function is running in the constructor\r\n  function isConstructor() private view returns (bool) {\r\n    // extcodesize checks the size of the code stored in an address, and\r\n    // address returns the current address. Since the code is still not\r\n    // deployed when running a constructor, any checks on its code size will\r\n    // yield zero, making it an effective way to detect if a contract is\r\n    // under construction or not.\r\n    uint256 cs;\r\n    assembly { cs := extcodesize(address) }\r\n    return cs == 0;\r\n  }\r\n\r\n  // Reserved storage space to allow for layout changes in the future.\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Initializable {\r\n  address private _owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function initialize(address sender) public initializer {\r\n    _owner = sender;\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(_owner);\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n\r\ncontract PauserRole is Initializable {\r\n  using Roles for Roles.Role;\r\n\r\n  event PauserAdded(address indexed account);\r\n  event PauserRemoved(address indexed account);\r\n\r\n  Roles.Role private pausers;\r\n\r\n  function initialize(address sender) public initializer {\r\n    if (!isPauser(sender)) {\r\n      _addPauser(sender);\r\n    }\r\n  }\r\n\r\n  modifier onlyPauser() {\r\n    require(isPauser(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isPauser(address account) public view returns (bool) {\r\n    return pausers.has(account);\r\n  }\r\n\r\n  function addPauser(address account) public onlyPauser {\r\n    _addPauser(account);\r\n  }\r\n\r\n  function renouncePauser() public {\r\n    _removePauser(msg.sender);\r\n  }\r\n\r\n  function _addPauser(address account) internal {\r\n    pausers.add(account);\r\n    emit PauserAdded(account);\r\n  }\r\n\r\n  function _removePauser(address account) internal {\r\n    pausers.remove(account);\r\n    emit PauserRemoved(account);\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Initializable, PauserRole {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n  function initialize(address sender) public initializer {\r\n    PauserRole.initialize(sender);\r\n  }\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns(bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyPauser whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyPauser whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n\r\n  uint256[50] private ______gap;\r\n}\r\n\r\n\r\n/**\r\n * @title Attribute Registry interface. EIP-165 ID: 0x5f46473f\r\n */\r\ninterface AttributeRegistryInterface {\r\n  /**\r\n   * @notice Check if an attribute of the type with ID `attributeTypeID` has\r\n   * been assigned to the account at `account` and is still valid.\r\n   * @param account address The account to check for a valid attribute.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return True if the attribute is assigned and valid, false otherwise.\r\n   */\r\n  function hasAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Retrieve the value of the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account`, assuming it is valid.\r\n   * @param account address The account to check for the given attribute value.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return The attribute value if the attribute is valid, reverts otherwise.\r\n   */\r\n  function getAttributeValue(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the registry.\r\n   * @return The number of available attribute types.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic TPL Jurisdiction Interface.\r\n */\r\ninterface BasicJurisdictionInterface {\r\n  // declare events\r\n  event AttributeTypeAdded(uint256 indexed attributeTypeID, string description);\r\n  \r\n  event AttributeTypeRemoved(uint256 indexed attributeTypeID);\r\n  \r\n  event ValidatorAdded(address indexed validator, string description);\r\n  \r\n  event ValidatorRemoved(address indexed validator);\r\n  \r\n  event ValidatorApprovalAdded(\r\n    address validator,\r\n    uint256 indexed attributeTypeID\r\n  );\r\n\r\n  event ValidatorApprovalRemoved(\r\n    address validator,\r\n    uint256 indexed attributeTypeID\r\n  );\r\n\r\n  event AttributeAdded(\r\n    address validator,\r\n    address indexed attributee,\r\n    uint256 attributeTypeID,\r\n    uint256 attributeValue\r\n  );\r\n\r\n  event AttributeRemoved(\r\n    address validator,\r\n    address indexed attributee,\r\n    uint256 attributeTypeID\r\n  );\r\n\r\n  /**\r\n  * @notice Add an attribute type with ID `ID` and description `description` to\r\n  * the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to add.\r\n  * @param description string A description of the attribute type.\r\n  * @dev Once an attribute type is added with a given ID, the description of the\r\n  * attribute type cannot be changed, even if the attribute type is removed and\r\n  * added back later.\r\n  */\r\n  function addAttributeType(uint256 ID, string description) external;\r\n\r\n  /**\r\n  * @notice Remove the attribute type with ID `ID` from the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to remove.\r\n  * @dev All issued attributes of the given type will become invalid upon\r\n  * removal, but will become valid again if the attribute is reinstated.\r\n  */\r\n  function removeAttributeType(uint256 ID) external;\r\n\r\n  /**\r\n  * @notice Add account `validator` as a validator with a description\r\n  * `description` who can be approved to set attributes of specific types.\r\n  * @param validator address The account to assign as the validator.\r\n  * @param description string A description of the validator.\r\n  * @dev Note that the jurisdiction can add iteslf as a validator if desired.\r\n  */\r\n  function addValidator(address validator, string description) external;\r\n\r\n  /**\r\n  * @notice Remove the validator at address `validator` from the jurisdiction.\r\n  * @param validator address The account of the validator to remove.\r\n  * @dev Any attributes issued by the validator will become invalid upon their\r\n  * removal. If the validator is reinstated, those attributes will become valid\r\n  * again. Any approvals to issue attributes of a given type will need to be\r\n  * set from scratch in the event a validator is reinstated.\r\n  */\r\n  function removeValidator(address validator) external;\r\n\r\n  /**\r\n  * @notice Approve the validator at address `validator` to issue attributes of\r\n  * the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator to approve.\r\n  * @param attributeTypeID uint256 The ID of the approved attribute type.\r\n  */\r\n  function addValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Deny the validator at address `validator` the ability to continue to\r\n  * issue attributes of the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator with removed approval.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to unapprove.\r\n  * @dev Any attributes of the specified type issued by the validator in\r\n  * question will become invalid once the approval is removed. If the approval\r\n  * is reinstated, those attributes will become valid again. The approval will\r\n  * also be removed if the approved validator is removed.\r\n  */\r\n  function removeValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n  * @notice Issue an attribute of the type with ID `attributeTypeID` and a value\r\n  * of `value` to `account` if `message.caller.address()` is approved validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @param value uint256 An optional value for the issued attribute.\r\n  * @dev Existing attributes of the given type on the address must be removed\r\n  * in order to set a new attribute. Be aware that ownership of the account to\r\n  * which the attribute is assigned may still be transferable - restricting\r\n  * assignment to externally-owned accounts may partially alleviate this issue.\r\n  */\r\n  function issueAttribute(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value\r\n  ) external payable;\r\n\r\n  /**\r\n  * @notice Revoke the attribute of the type with ID `attributeTypeID` from\r\n  * `account` if `message.caller.address()` is the issuing validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @dev Validators may still revoke issued attributes even after they have been\r\n  * removed or had their approval to issue the attribute type removed - this\r\n  * enables them to address any objectionable issuances before being reinstated.\r\n  */\r\n  function revokeAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external;\r\n\r\n  /**\r\n   * @notice Determine if a validator at account `validator` is able to issue\r\n   * attributes of the type with ID `attributeTypeID`.\r\n   * @param validator address The account of the validator.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check.\r\n   * @return True if the validator can issue attributes of the given type, false\r\n   * otherwise.\r\n   */\r\n  function canIssueAttributeType(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool);\r\n\r\n  /**\r\n   * @notice Get a description of the attribute type with ID `attributeTypeID`.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return A description of the attribute type.\r\n   */\r\n  function getAttributeTypeInformation(\r\n    uint256 attributeTypeID\r\n  ) external view returns (string description);\r\n  \r\n  /**\r\n   * @notice Get a description of the validator at account `validator`.\r\n   * @param validator address The account of the validator in question.\r\n   * @return A description of the validator.\r\n   */\r\n  function getValidatorInformation(\r\n    address validator\r\n  ) external view returns (string description);\r\n\r\n  /**\r\n   * @notice Find the validator that issued the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account` and determine if the\r\n   * validator is still valid.\r\n   * @param account address The account that contains the attribute be checked.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return The validator and the current status of the validator as it\r\n   * pertains to the attribute type in question.\r\n   * @dev if no attribute of the given attribute type exists on the account, the\r\n   * function will return (address(0), false).\r\n   */\r\n  function getAttributeValidator(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (address validator, bool isStillValid);\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the jurisdiction.\r\n   * @return The number of available attribute types.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the IDs of all available attribute types on the jurisdiction.\r\n   * @return A dynamic array containing all available attribute type IDs.\r\n   */\r\n  function getAttributeTypeIDs() external view returns (uint256[]);\r\n\r\n  /**\r\n   * @notice Count the number of validators defined by the jurisdiction.\r\n   * @return The number of defined validators.\r\n   */\r\n  function countValidators() external view returns (uint256);\r\n\r\n  /**\r\n   * @notice Get the account of the validator at index `index`.\r\n   * @param index uint256 The index of the validator in question.\r\n   * @return The account of the validator.\r\n   */\r\n  function getValidator(uint256 index) external view returns (address);\r\n\r\n  /**\r\n   * @notice Get the accounts of all available validators on the jurisdiction.\r\n   * @return A dynamic array containing all available validator accounts.\r\n   */\r\n  function getValidators() external view returns (address[]);\r\n}\r\n\r\n\r\n/**\r\n * @title A basic TPL jurisdiction for assigning attributes to addresses.\r\n */\r\ncontract BasicJurisdiction is Initializable, Ownable, Pausable, AttributeRegistryInterface, BasicJurisdictionInterface {\r\n  using SafeMath for uint256;\r\n\r\n  // validators are entities who can add or authorize addition of new attributes\r\n  struct Validator {\r\n    bool exists;\r\n    uint256 index; // NOTE: consider use of uint248 to pack index with exists\r\n    string description;\r\n  }\r\n\r\n  // attributes are properties that validators associate with specific addresses\r\n  struct IssuedAttribute {\r\n    bool exists;\r\n    address validator;\r\n    uint256 value;\r\n  }\r\n\r\n  // attributes also have associated type - metadata common to each attribute\r\n  struct AttributeType {\r\n    bool exists;\r\n    uint256 index;  // NOTE: consider use of uint248 to pack index with exists\r\n    string description;\r\n    mapping(address => bool) approvedValidators;\r\n  }\r\n\r\n  // top-level information about attribute types is held in a mapping of structs\r\n  mapping(uint256 => AttributeType) private _attributeTypes;\r\n\r\n  // the jurisdiction retains a mapping of addresses with assigned attributes\r\n  mapping(address => mapping(uint256 => IssuedAttribute)) private _issuedAttributes;\r\n\r\n  // there is also a mapping to identify all approved validators and their keys\r\n  mapping(address => Validator) private _validators;\r\n\r\n  // once attribute types are assigned to an ID, they cannot be modified\r\n  mapping(uint256 => bytes32) private _attributeTypeHashes;\r\n\r\n  // attribute approvals by validator are held in a mapping\r\n  mapping(address => uint256[]) private _validatorApprovals;\r\n\r\n   // attribute approval index by validator is tracked as well\r\n  mapping(address => mapping(uint256 => uint256)) private _validatorApprovalsIndex;\r\n\r\n  // IDs for all supplied attributes are held in an array (enables enumeration)\r\n  uint256[] private _attributeIDs;\r\n\r\n  // addresses for all designated validators are also held in an array\r\n  address[] private _validatorAccounts;\r\n\r\n  /**\r\n  * @notice Add an attribute type with ID `ID` and description `description` to\r\n  * the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to add.\r\n  * @param description string A description of the attribute type.\r\n  * @dev Once an attribute type is added with a given ID, the description of the\r\n  * attribute type cannot be changed, even if the attribute type is removed and\r\n  * added back later.\r\n  */\r\n  function addAttributeType(\r\n    uint256 ID,\r\n    string description\r\n  ) external onlyOwner whenNotPaused {\r\n    // prevent existing attributes with the same id from being overwritten\r\n    require(\r\n      isAttributeType(ID) == false,\r\n      \"an attribute type with the provided ID already exists\"\r\n    );\r\n\r\n    // calculate a hash of the attribute type based on the type's properties\r\n    bytes32 hash = keccak256(\r\n      abi.encodePacked(\r\n        ID, false, false, description\r\n      )\r\n    );\r\n\r\n    // store hash if attribute type is the first one registered with provided ID\r\n    if (_attributeTypeHashes[ID] == bytes32(0)) {\r\n      _attributeTypeHashes[ID] = hash;\r\n    }\r\n\r\n    // prevent addition if different attribute type with the same ID has existed\r\n    require(\r\n      hash == _attributeTypeHashes[ID],\r\n      \"attribute type properties must match initial properties assigned to ID\"\r\n    );\r\n\r\n    // set the attribute mapping, assigning the index as the end of attributeID\r\n    _attributeTypes[ID] = AttributeType({\r\n      exists: true,\r\n      index: _attributeIDs.length,\r\n      description: description\r\n      // NOTE: no approvedValidators variable declaration - must be added later\r\n    });\r\n    \r\n    // add the attribute type id to the end of the attributeID array\r\n    _attributeIDs.push(ID);\r\n\r\n    // log the addition of the attribute type\r\n    emit AttributeTypeAdded(ID, description);\r\n  }\r\n\r\n  /**\r\n  * @notice Remove the attribute type with ID `ID` from the jurisdiction.\r\n  * @param ID uint256 The ID of the attribute type to remove.\r\n  * @dev All issued attributes of the given type will become invalid upon\r\n  * removal, but will become valid again if the attribute is reinstated.\r\n  */\r\n  function removeAttributeType(uint256 ID) external onlyOwner whenNotPaused {\r\n    // if the attribute id does not exist, there is nothing to remove\r\n    require(\r\n      isAttributeType(ID),\r\n      \"unable to remove, no attribute type with the provided ID\"\r\n    );\r\n\r\n    // get the attribute ID at the last index of the array\r\n    uint256 lastAttributeID = _attributeIDs[_attributeIDs.length.sub(1)];\r\n\r\n    // set the attributeID at attribute-to-delete.index to the last attribute ID\r\n    _attributeIDs[_attributeTypes[ID].index] = lastAttributeID;\r\n\r\n    // update the index of the attribute type that was moved\r\n    _attributeTypes[lastAttributeID].index = _attributeTypes[ID].index;\r\n    \r\n    // remove the (now duplicate) attribute ID at the end by trimming the array\r\n    _attributeIDs.length--;\r\n\r\n    // delete the attribute type's record from the mapping\r\n    delete _attributeTypes[ID];\r\n\r\n    // log the removal of the attribute type\r\n    emit AttributeTypeRemoved(ID);\r\n  }\r\n\r\n  /**\r\n  * @notice Add account `validator` as a validator with a description\r\n  * `description` who can be approved to set attributes of specific types.\r\n  * @param validator address The account to assign as the validator.\r\n  * @param description string A description of the validator.\r\n  * @dev Note that the jurisdiction can add iteslf as a validator if desired.\r\n  */\r\n  function addValidator(\r\n    address validator,\r\n    string description\r\n  ) external onlyOwner whenNotPaused {\r\n    // check that an empty address was not provided by mistake\r\n    require(validator != address(0), \"must supply a valid address\");\r\n\r\n    // prevent existing validators from being overwritten\r\n    require(\r\n      isValidator(validator) == false,\r\n      \"a validator with the provided address already exists\"\r\n    );\r\n    \r\n    // create a record for the validator\r\n    _validators[validator] = Validator({\r\n      exists: true,\r\n      index: _validatorAccounts.length,\r\n      description: description\r\n    });\r\n\r\n    // add the validator to the end of the _validatorAccounts array\r\n    _validatorAccounts.push(validator);\r\n    \r\n    // log the addition of the new validator\r\n    emit ValidatorAdded(validator, description);\r\n  }\r\n\r\n  /**\r\n  * @notice Remove the validator at address `validator` from the jurisdiction.\r\n  * @param validator address The account of the validator to remove.\r\n  * @dev Any attributes issued by the validator will become invalid upon their\r\n  * removal. If the validator is reinstated, those attributes will become valid\r\n  * again. Any approvals to issue attributes of a given type will need to be\r\n  * set from scratch in the event a validator is reinstated.\r\n  */\r\n  function removeValidator(address validator) external onlyOwner whenNotPaused {\r\n    // check that a validator exists at the provided address\r\n    require(\r\n      isValidator(validator),\r\n      \"unable to remove, no validator located at the provided address\"\r\n    );\r\n\r\n    // first, start removing validator approvals until gas is exhausted\r\n    while (_validatorApprovals[validator].length > 0 && gasleft() > 25000) {\r\n      // locate the index of last attribute ID in the validator approval group\r\n      uint256 lastIndex = _validatorApprovals[validator].length.sub(1);\r\n\r\n      // locate the validator approval to be removed\r\n      uint256 targetApproval = _validatorApprovals[validator][lastIndex];\r\n\r\n      // remove the record of the approval from the associated attribute type\r\n      delete _attributeTypes[targetApproval].approvedValidators[validator];\r\n\r\n      // remove the record of the index of the approval\r\n      delete _validatorApprovalsIndex[validator][targetApproval];\r\n\r\n      // drop the last attribute ID from the validator approval group\r\n      _validatorApprovals[validator].length--;\r\n    }\r\n\r\n    // require that all approvals were successfully removed\r\n    require(\r\n      _validatorApprovals[validator].length == 0,\r\n      \"Cannot remove validator - first remove any existing validator approvals\"\r\n    );\r\n\r\n    // get the validator address at the last index of the array\r\n    address lastAccount = _validatorAccounts[_validatorAccounts.length.sub(1)];\r\n\r\n    // set the address at validator-to-delete.index to last validator address\r\n    _validatorAccounts[_validators[validator].index] = lastAccount;\r\n\r\n    // update the index of the attribute type that was moved\r\n    _validators[lastAccount].index = _validators[validator].index;\r\n    \r\n    // remove (duplicate) validator address at the end by trimming the array\r\n    _validatorAccounts.length--;\r\n\r\n    // remove the validator record\r\n    delete _validators[validator];\r\n\r\n    // log the removal of the validator\r\n    emit ValidatorRemoved(validator);\r\n  }\r\n\r\n  /**\r\n  * @notice Approve the validator at address `validator` to issue attributes of\r\n  * the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator to approve.\r\n  * @param attributeTypeID uint256 The ID of the approved attribute type.\r\n  */\r\n  function addValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external onlyOwner whenNotPaused {\r\n    // check that the attribute is predefined and that the validator exists\r\n    require(\r\n      isValidator(validator) && isAttributeType(attributeTypeID),\r\n      \"must specify both a valid attribute and an available validator\"\r\n    );\r\n\r\n    // check that the validator is not already approved\r\n    require(\r\n      _attributeTypes[attributeTypeID].approvedValidators[validator] == false,\r\n      \"validator is already approved on the provided attribute\"\r\n    );\r\n\r\n    // set the validator approval status on the attribute\r\n    _attributeTypes[attributeTypeID].approvedValidators[validator] = true;\r\n\r\n    // add the record of the index of the validator approval to be added\r\n    uint256 index = _validatorApprovals[validator].length;\r\n    _validatorApprovalsIndex[validator][attributeTypeID] = index;\r\n\r\n    // include the attribute type in the validator approval mapping\r\n    _validatorApprovals[validator].push(attributeTypeID);\r\n\r\n    // log the addition of the validator's attribute type approval\r\n    emit ValidatorApprovalAdded(validator, attributeTypeID);\r\n  }\r\n\r\n  /**\r\n  * @notice Deny the validator at address `validator` the ability to continue to\r\n  * issue attributes of the type with ID `attributeTypeID`.\r\n  * @param validator address The account of the validator with removed approval.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to unapprove.\r\n  * @dev Any attributes of the specified type issued by the validator in\r\n  * question will become invalid once the approval is removed. If the approval\r\n  * is reinstated, those attributes will become valid again. The approval will\r\n  * also be removed if the approved validator is removed.\r\n  */\r\n  function removeValidatorApproval(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external onlyOwner whenNotPaused {\r\n    // check that the attribute is predefined and that the validator exists\r\n    require(\r\n      canValidate(validator, attributeTypeID),\r\n      \"unable to remove validator approval, attribute is already unapproved\"\r\n    );\r\n\r\n    // remove the validator approval status from the attribute\r\n    delete _attributeTypes[attributeTypeID].approvedValidators[validator];\r\n\r\n    // locate the index of the last validator approval\r\n    uint256 lastIndex = _validatorApprovals[validator].length.sub(1);\r\n\r\n    // locate the last attribute ID in the validator approval group\r\n    uint256 lastAttributeID = _validatorApprovals[validator][lastIndex];\r\n\r\n    // locate the index of the validator approval to be removed\r\n    uint256 index = _validatorApprovalsIndex[validator][attributeTypeID];\r\n\r\n    // replace the validator approval with the last approval in the array\r\n    _validatorApprovals[validator][index] = lastAttributeID;\r\n\r\n    // drop the last attribute ID from the validator approval group\r\n    _validatorApprovals[validator].length--;\r\n\r\n    // update the record of the index of the swapped-in approval\r\n    _validatorApprovalsIndex[validator][lastAttributeID] = index;\r\n\r\n    // remove the record of the index of the removed approval\r\n    delete _validatorApprovalsIndex[validator][attributeTypeID];\r\n    \r\n    // log the removal of the validator's attribute type approval\r\n    emit ValidatorApprovalRemoved(validator, attributeTypeID);\r\n  }\r\n\r\n  /**\r\n  * @notice Issue an attribute of the type with ID `attributeTypeID` and a value\r\n  * of `value` to `account` if `message.caller.address()` is approved validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @param value uint256 An optional value for the issued attribute.\r\n  * @dev Existing attributes of the given type on the address must be removed\r\n  * in order to set a new attribute. Be aware that ownership of the account to\r\n  * which the attribute is assigned may still be transferable - restricting\r\n  * assignment to externally-owned accounts may partially alleviate this issue.\r\n  */\r\n  function issueAttribute(\r\n    address account,\r\n    uint256 attributeTypeID,\r\n    uint256 value\r\n  ) external payable whenNotPaused {\r\n    require(\r\n      msg.value == 0,\r\n      \"Basic jurisdictions do not support payments when assigning attributes\"\r\n    );\r\n\r\n    require(\r\n      canValidate(msg.sender, attributeTypeID),\r\n      \"only approved validators may assign attributes of this type\"\r\n    );\r\n\r\n    require(\r\n      _issuedAttributes[account][attributeTypeID].validator == address(0),\r\n      \"duplicate attributes are not supported, remove existing attribute first\"\r\n    );\r\n\r\n    // store attribute value and amount of ether staked in correct scope\r\n    _issuedAttributes[account][attributeTypeID] = IssuedAttribute({\r\n      exists: true,\r\n      validator: msg.sender,\r\n      value: value\r\n    });\r\n\r\n    // log the addition of the attribute\r\n    emit AttributeAdded(msg.sender, account, attributeTypeID, value);\r\n  }\r\n\r\n  /**\r\n  * @notice Revoke the attribute of the type with ID `attributeTypeID` from\r\n  * `account` if `message.caller.address()` is the issuing validator.\r\n  * @param account address The account to issue the attribute on.\r\n  * @param attributeTypeID uint256 The ID of the attribute type to issue.\r\n  * @dev Validators may still revoke issued attributes even after they have been\r\n  * removed or had their approval to issue the attribute type removed - this\r\n  * enables them to address any objectionable issuances before being reinstated.\r\n  */\r\n  function revokeAttribute(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external whenNotPaused {\r\n    // ensure that an attribute with the given account and attribute exists\r\n    require(\r\n      _issuedAttributes[account][attributeTypeID].exists,\r\n      \"only existing attributes may be removed\"\r\n    );\r\n\r\n    // determine the assigned validator on the user attribute\r\n    address validator = _issuedAttributes[account][attributeTypeID].validator;\r\n    \r\n    // caller must be either the jurisdiction owner or the assigning validator\r\n    require(\r\n      msg.sender == validator || msg.sender == owner(),\r\n      \"only jurisdiction or issuing validators may revoke arbitrary attributes\"\r\n    );\r\n\r\n    // remove the attribute from the designated user account\r\n    delete _issuedAttributes[account][attributeTypeID];\r\n\r\n    // log the removal of the attribute\r\n    emit AttributeRemoved(validator, account, attributeTypeID);\r\n  }  \r\n\r\n  /**\r\n   * @notice Check if an attribute of the type with ID `attributeTypeID` has\r\n   * been assigned to the account at `account` and is still valid.\r\n   * @param account address The account to check for a valid attribute.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return True if the attribute is assigned and valid, false otherwise.\r\n   */\r\n  function hasAttribute(\r\n    address account, \r\n    uint256 attributeTypeID\r\n  ) external view returns (bool) {\r\n    address validator = _issuedAttributes[account][attributeTypeID].validator;\r\n    return (\r\n      _validators[validator].exists &&        //isValidator(validator)\r\n      _attributeTypes[attributeTypeID].approvedValidators[validator] &&\r\n      _attributeTypes[attributeTypeID].exists //isAttributeType(attributeTypeID)    \r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieve the value of the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account`, assuming it is valid.\r\n   * @param account address The account to check for the given attribute value.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return The attribute value if the attribute is valid, reverts otherwise.\r\n   */\r\n  function getAttributeValue(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (uint256 value) {\r\n    address validator = _issuedAttributes[account][attributeTypeID].validator;\r\n    require(\r\n      (\r\n        _validators[validator].exists &&\r\n        _attributeTypes[attributeTypeID].approvedValidators[validator] &&\r\n        _attributeTypes[attributeTypeID].exists\r\n      ),\r\n      \"could not find an attribute value at the provided address and ID\"\r\n    );\r\n\r\n    return _issuedAttributes[account][attributeTypeID].value;\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if a validator at account `validator` is able to issue\r\n   * attributes of the type with ID `attributeTypeID`.\r\n   * @param validator address The account of the validator.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check.\r\n   * @return True if the validator can issue attributes of the given type, false\r\n   * otherwise.\r\n   */\r\n  function canIssueAttributeType(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) external view returns (bool) {\r\n    return canValidate(validator, attributeTypeID);\r\n  }\r\n\r\n  /**\r\n   * @notice Get a description of the attribute type with ID `attributeTypeID`.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check for.\r\n   * @return A description of the attribute type.\r\n   */\r\n  function getAttributeTypeInformation(\r\n    uint256 attributeTypeID\r\n  ) external view returns (\r\n    string description\r\n  ) {\r\n    return _attributeTypes[attributeTypeID].description;\r\n  }\r\n\r\n  /**\r\n   * @notice Get a description of the validator at account `validator`.\r\n   * @param validator address The account of the validator in question.\r\n   * @return A description of the validator.\r\n   */\r\n  function getValidatorInformation(\r\n    address validator\r\n  ) external view returns (\r\n    string description\r\n  ) {\r\n    return _validators[validator].description;\r\n  }\r\n\r\n  /**\r\n   * @notice Find the validator that issued the attribute of the type with ID\r\n   * `attributeTypeID` on the account at `account` and determine if the\r\n   * validator is still valid.\r\n   * @param account address The account that contains the attribute be checked.\r\n   * @param attributeTypeID uint256 The ID of the attribute type in question.\r\n   * @return The validator and the current status of the validator as it\r\n   * pertains to the attribute type in question.\r\n   * @dev if no attribute of the given attribute type exists on the account, the\r\n   * function will return (address(0), false).\r\n   */\r\n  function getAttributeValidator(\r\n    address account,\r\n    uint256 attributeTypeID\r\n  ) external view returns (\r\n    address validator,\r\n    bool isStillValid\r\n  ) {\r\n    address issuer = _issuedAttributes[account][attributeTypeID].validator;\r\n    return (issuer, canValidate(issuer, attributeTypeID));\r\n  }\r\n\r\n  /**\r\n   * @notice Count the number of attribute types defined by the jurisdiction.\r\n   * @return The number of available attribute types.\r\n   */\r\n  function countAttributeTypes() external view returns (uint256) {\r\n    return _attributeIDs.length;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the ID of the attribute type at index `index`.\r\n   * @param index uint256 The index of the attribute type in question.\r\n   * @return The ID of the attribute type.\r\n   */\r\n  function getAttributeTypeID(uint256 index) external view returns (uint256) {\r\n    return _attributeIDs[index];\r\n  }\r\n\r\n  /**\r\n   * @notice Get the IDs of all available attribute types on the jurisdiction.\r\n   * @return A dynamic array containing all available attribute type IDs.\r\n   */\r\n  function getAttributeTypeIDs() external view returns (uint256[]) {\r\n    return _attributeIDs;\r\n  }\r\n\r\n  /**\r\n   * @notice Count the number of validators defined by the jurisdiction.\r\n   * @return The number of defined validators.\r\n   */\r\n  function countValidators() external view returns (uint256) {\r\n    return _validatorAccounts.length;\r\n  }\r\n\r\n  /**\r\n   * @notice Get the account of the validator at index `index`.\r\n   * @param index uint256 The index of the validator in question.\r\n   * @return The account of the validator.\r\n   */\r\n  function getValidator(\r\n    uint256 index\r\n  ) external view returns (address) {\r\n    return _validatorAccounts[index];\r\n  }\r\n\r\n  /**\r\n   * @notice Get the accounts of all available validators on the jurisdiction.\r\n   * @return A dynamic array containing all available validator accounts.\r\n   */\r\n  function getValidators() external view returns (address[]) {\r\n    return _validatorAccounts;\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if the interface ID `interfaceID` is supported (ERC-165)\r\n   * @param interfaceID bytes4 The interface ID in question.\r\n   * @return True if the interface is supported, false otherwise.\r\n   * @dev this function will produce a compiler warning recommending that the\r\n   * visibility be set to pure, but the interface expects a view function.\r\n   * Supported interfaces include ERC-165 (0x01ffc9a7) and the attribute\r\n   * registry interface (0x5f46473f).\r\n   */\r\n  function supportsInterface(bytes4 interfaceID) external view returns (bool) {\r\n    return (\r\n      interfaceID == this.supportsInterface.selector || // ERC165\r\n      interfaceID == (\r\n        this.hasAttribute.selector \r\n        ^ this.getAttributeValue.selector\r\n        ^ this.countAttributeTypes.selector\r\n        ^ this.getAttributeTypeID.selector\r\n      ) // AttributeRegistryInterface\r\n    ); // 0x01ffc9a7 || 0x5f46473f\r\n  }\r\n\r\n  /**\r\n  * @notice The initializer function for the jurisdiction, with owner and pauser\r\n  * roles initially assigned to contract creator (`message.caller.address()`).\r\n  * @param sender address The account to be set as pauser and owner of the contract.\r\n  */\r\n  function initialize(address sender) public initializer {\r\n    Ownable.initialize(sender);\r\n    Pausable.initialize(sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if an attribute type with ID `attributeTypeID` is\r\n   * currently defined on the jurisdiction.\r\n   * @param attributeTypeID uint256 The attribute type ID in question.\r\n   * @return True if the attribute type is defined, false otherwise.\r\n   */\r\n  function isAttributeType(uint256 attributeTypeID) public view returns (bool) {\r\n    return _attributeTypes[attributeTypeID].exists;\r\n  }\r\n\r\n  /**\r\n   * @notice Determine if the account `account` is currently assigned as a\r\n   * validator on the jurisdiction.\r\n   * @param account address The account to check for validator status.\r\n   * @return True if the account is assigned as a validator, false otherwise.\r\n   */\r\n  function isValidator(address account) public view returns (bool) {\r\n    return _validators[account].exists;\r\n  }\r\n\r\n  /**\r\n   * @notice Internal function to determine if a validator at account\r\n   * `validator` can issue attributes of the type with ID `attributeTypeID`.\r\n   * @param validator address The account of the validator.\r\n   * @param attributeTypeID uint256 The ID of the attribute type to check.\r\n   * @return True if the validator can issue attributes of the given type, false\r\n   * otherwise.\r\n   */\r\n  function canValidate(\r\n    address validator,\r\n    uint256 attributeTypeID\r\n  ) internal view returns (bool) {\r\n    return (\r\n      _validators[validator].exists &&   // isValidator(validator)\r\n      _attributeTypes[attributeTypeID].approvedValidators[validator] &&\r\n      _attributeTypes[attributeTypeID].exists // isAttributeType(attributeTypeID)\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getAttributeTypeID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"getAttributeValidator\",\"outputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"isStillValid\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"getValidatorInformation\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"isAttributeType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"removeValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"hasAttribute\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"issueAttribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"description\",\"type\":\"string\"}],\"name\":\"addValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"getAttributeTypeInformation\",\"outputs\":[{\"name\":\"description\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"addValidatorApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"}],\"name\":\"removeAttributeType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAttributeTypeIDs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ID\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"}],\"name\":\"addAttributeType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"removeValidatorApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getValidators\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"getAttributeValue\",\"outputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"countAttributeTypes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"validator\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"canIssueAttributeType\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"revokeAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"AttributeTypeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"AttributeTypeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"description\",\"type\":\"string\"}],\"name\":\"ValidatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"}],\"name\":\"ValidatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"ValidatorApprovalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"ValidatorApprovalRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attributee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attributeTypeID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"attributeValue\",\"type\":\"uint256\"}],\"name\":\"AttributeAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"attributee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"attributeTypeID\",\"type\":\"uint256\"}],\"name\":\"AttributeRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BasicJurisdiction","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://24f922e32afed63a29a5a67d3650c9f34de0c0511d5f6354201163e9e26ab2b9"}]}