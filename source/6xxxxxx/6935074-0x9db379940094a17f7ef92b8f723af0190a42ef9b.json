{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract GameBoard {\r\n\r\n  uint8 constant public minSquareId = 1;\r\n  uint8 constant public maxSquareId = 2;\r\n  uint8 constant public numSquares = 2;\r\n}\r\n\r\ncontract JackpotRules {\r\n  using SafeMath for uint256;\r\n\r\n  constructor() public {}\r\n\r\n  // NOTE: The next methods *must* add up to 100%\r\n\r\n  // 50%\r\n  function _winnerJackpot(uint256 jackpot) public pure returns (uint256) {\r\n    return jackpot.div(2);\r\n  }\r\n\r\n  // 40%\r\n  function _landholderJackpot(uint256 jackpot) public pure returns (uint256) {\r\n    return (jackpot.mul(2)).div(5);\r\n  }\r\n\r\n  // 5%\r\n  function _nextPotJackpot(uint256 jackpot) public pure returns (uint256) {\r\n    return jackpot.div(20);\r\n  }\r\n\r\n  // 5%\r\n  function _teamJackpot(uint256 jackpot) public pure returns (uint256) {\r\n    return jackpot.div(20);\r\n  }\r\n}\r\n\r\nlibrary Math {\r\n  /**\r\n  * @dev Returns the largest of two numbers.\r\n  */\r\n  function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the smallest of two numbers.\r\n  */\r\n  function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  /**\r\n  * @dev Calculates the average of two numbers. Since these are integers,\r\n  * averages of an even and odd number cannot be represented, and will be\r\n  * rounded down.\r\n  */\r\n  function average(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // (a + b) / 2 can overflow, so we distribute\r\n    return (a / 2) + (b / 2) + ((a % 2 + b % 2) / 2);\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\ncontract PullPayment {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) public payments;\r\n    uint256 public totalPayments;\r\n\r\n    /**\r\n     * @dev Withdraw accumulated balance, called by payee.\r\n     */\r\n    function withdrawPayments() public {\r\n        address payee = msg.sender;\r\n        uint256 payment = payments[payee];\r\n\r\n        require(payment != 0);\r\n        require(address(this).balance >= payment);\r\n\r\n        totalPayments = totalPayments.sub(payment);\r\n        payments[payee] = 0;\r\n\r\n        payee.transfer(payment);\r\n    }\r\n\r\n    /**\r\n     * @dev Called by the payer to store the sent amount as credit to be pulled.\r\n     * @param dest The destination address of the funds.\r\n     * @param amount The amount to transfer.\r\n     */\r\n    function asyncSend(address dest, uint256 amount) internal {\r\n        payments[dest] = payments[dest].add(amount);\r\n        totalPayments = totalPayments.add(amount);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract TaxRules {\r\n    using SafeMath for uint256;\r\n\r\n    constructor() public {}\r\n\r\n    // 10%\r\n    function _priceToTax(uint256 price) public pure returns (uint256) {\r\n        return price.div(10);\r\n    }\r\n\r\n    // NOTE: The next methods *must* add up to 100%\r\n\r\n    // 40%\r\n    function _jackpotTax(uint256 tax) public pure returns (uint256) {\r\n        return (tax.mul(2)).div(5);\r\n    }\r\n\r\n    // 38%\r\n    function _totalLandholderTax(uint256 tax) public pure returns (uint256) {\r\n        return (tax.mul(19)).div(50);\r\n    }\r\n\r\n    // 17%/12%\r\n    function _teamTax(uint256 tax, bool hasReferrer) public pure returns (uint256) {\r\n        if (hasReferrer) {\r\n            return (tax.mul(3)).div(25);\r\n        } else {\r\n            return (tax.mul(17)).div(100);\r\n        }\r\n    }\r\n    \r\n    // sell 25% of tokens\r\n    function _p3dSellPercentage(uint256 tokens) public pure returns (uint256) {\r\n        return tokens.div(4);\r\n    }\r\n\r\n    // 5% although only invoked if _teamTax is lower value\r\n    function _referrerTax(uint256 tax, bool hasReferrer)  public pure returns (uint256) {\r\n        if (hasReferrer) {\r\n            return tax.div(20);\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n\r\n    // 5%\r\n    function _nextPotTax(uint256 tax) public pure returns (uint256) {\r\n        return tax.div(20);\r\n    }\r\n}\r\n\r\ncontract Commercializ3d is\r\n    GameBoard,\r\n    PullPayment,\r\n    Ownable,\r\n    TaxRules,\r\n    JackpotRules {\r\n    using SafeMath for uint256;\r\n    using Math for uint256;\r\n\r\n    enum Stage {\r\n        DutchAuction,\r\n        GameRounds\r\n    }\r\n    Stage public stage = Stage.DutchAuction;\r\n\r\n    modifier atStage(Stage _stage) {\r\n        require(\r\n            stage == _stage,\r\n            \"Function cannot be called at this stage.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    constructor(uint startingStage) public {\r\n        if (startingStage == uint(Stage.GameRounds)) {\r\n            stage = Stage.GameRounds;\r\n            _startGameRound();\r\n        } else {\r\n            _startAuction();\r\n        }\r\n    }\r\n\r\n    mapping(uint8 => address) public squareToOwner;\r\n    mapping(uint8 => uint256) public squareToPrice;\r\n    uint256 public totalSquareValue;\r\n\r\n    function _changeSquarePrice(uint8 squareId, uint256 newPrice) private {\r\n        uint256 oldPrice = squareToPrice[squareId];\r\n        squareToPrice[squareId] = newPrice;\r\n        totalSquareValue = (totalSquareValue.sub(oldPrice)).add(newPrice);\r\n    }\r\n\r\n    event SquareOwnerChanged(\r\n        uint8 indexed squareId,\r\n        address indexed oldOwner,\r\n        address indexed newOwner,\r\n        uint256 oldPrice,\r\n        uint256 newPrice\r\n    );\r\n\r\n    HourglassInterface constant P3DContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n    \r\n    function _buyP3D(uint256 amount) private {\r\n        P3DContract.buy.value(amount)(0xB111DaBb8EdD8260B5c1E471945A62bE2eE24470);\r\n    }\r\n    \r\n    function _sendP3D(address to, uint256 amount) private {\r\n        P3DContract.transfer(to, amount);\r\n    }\r\n    \r\n    function getP3DBalance() view public returns(uint256) {\r\n        return (P3DContract.balanceOf(address(this)));\r\n    }\r\n    \r\n    function getDivsBalance() view public returns(uint256) {\r\n        return (P3DContract.dividendsOf(address(this)));\r\n    }\r\n    \r\n    function withdrawContractBalance() external onlyOwner {\r\n        uint256 contractBalance = address(this).balance;\r\n        uint256 withdrawableBalance = contractBalance.sub(totalPayments);\r\n\r\n        // No withdrawal necessary if <= 0 balance\r\n        require(withdrawableBalance > 0);\r\n\r\n        asyncSend(msg.sender, withdrawableBalance);\r\n    }\r\n\r\n    event AuctionStarted(\r\n        uint256 startingAuctionPrice,\r\n        uint256 endingAuctionPrice,\r\n        uint256 auctionDuration,\r\n        uint256 startTime\r\n    );\r\n\r\n    event AuctionEnded(\r\n        uint256 endTime\r\n    );\r\n\r\n    uint256 constant public startingAuctionPrice = 0.1 ether;\r\n    uint256 constant public endingAuctionPrice = 0.00 ether;\r\n    uint256 constant public auctionDuration = 5 days; // period over which land price decreases linearly\r\n\r\n    uint256 public numBoughtSquares;\r\n    uint256 public auctionStartTime;\r\n\r\n    function buySquareAtAuction(uint8 squareId, uint256 newPrice, address referrer) public payable atStage(Stage.DutchAuction) {\r\n        require(\r\n            squareToOwner[squareId] == address(0) && squareToPrice[squareId] == 0,\r\n            \"This square has already been auctioned off\"\r\n        );\r\n\r\n        uint256 tax = _priceToTax(newPrice);\r\n        uint256 price = getSquarePriceAuction();\r\n\r\n        require(\r\n            msg.value >= tax.add(price),\r\n            \"Must pay the full price and tax for a square on auction\"\r\n        );\r\n\r\n        _distributeAuctionTax(msg.value, referrer);\r\n\r\n        squareToOwner[squareId] = msg.sender;\r\n        _changeSquarePrice(squareId, newPrice);\r\n\r\n        numBoughtSquares = numBoughtSquares.add(1);\r\n\r\n        emit SquareOwnerChanged(squareId, address(0), msg.sender, price, newPrice);\r\n\r\n        if (numBoughtSquares >= numSquares) {\r\n            endAuction();\r\n        }\r\n    }\r\n\r\n    function _distributeAuctionTax(uint256 tax, address referrer) private {\r\n        _distributeLandholderTax(_totalLandholderTax(tax));\r\n\r\n        uint256 totalJackpotTax = _jackpotTax(tax).add(_nextPotTax(tax));\r\n        nextJackpot = nextJackpot.add(totalJackpotTax);\r\n\r\n        // NOTE: referrer tax comes out of p3d tax\r\n        bool hasReferrer = referrer != address(0);\r\n        _buyP3D(_teamTax(tax, hasReferrer));\r\n        asyncSend(referrer, _referrerTax(tax, hasReferrer));\r\n    }\r\n\r\n    function getSquarePriceAuction() public view atStage(Stage.DutchAuction) returns (uint256) {\r\n        return endingAuctionPrice;\r\n    }\r\n\r\n    function endAuction() private {\r\n        require(\r\n            numBoughtSquares >= numSquares,\r\n            \"All squares must be purchased to end round\"\r\n        );\r\n\r\n        stage = Stage.GameRounds;\r\n        _startGameRound();\r\n\r\n        emit AuctionEnded(now);\r\n    }\r\n\r\n    function _startAuction() private {\r\n        auctionStartTime = now;\r\n        numBoughtSquares = 0;\r\n\r\n        emit AuctionStarted(startingAuctionPrice,\r\n                            endingAuctionPrice,\r\n                            auctionDuration,\r\n                            auctionStartTime);\r\n    }\r\n\r\n    uint256 constant public startingRoundExtension = 1 minutes;\r\n    uint256 constant public halvingVolume = 10 ether;\r\n    uint256 constant public minRoundExtension = 10 seconds;\r\n\r\n    uint256 public roundNumber = 0;\r\n\r\n    uint256 public curExtensionVolume;\r\n    uint256 public curRoundExtension;\r\n\r\n    uint256 public roundEndTime;\r\n\r\n    uint256 public jackpot;\r\n    uint256 public nextJackpot;\r\n\r\n    event SquarePriceChanged(\r\n        uint8 indexed squareId,\r\n        address indexed owner,\r\n        uint256 oldPrice,\r\n        uint256 newPrice\r\n    );\r\n\r\n    event GameRoundStarted(\r\n        uint256 initJackpot,\r\n        uint256 endTime,\r\n        uint256 roundNumber\r\n    );\r\n\r\n    event GameRoundExtended(\r\n        uint256 endTime\r\n    );\r\n\r\n    event GameRoundEnded(\r\n        uint256 jackpot\r\n    );\r\n\r\n    function roundTimeRemaining() public view atStage(Stage.GameRounds) returns (uint256)  {\r\n        if (_roundOver()) {\r\n            return 0;\r\n        } else {\r\n            return roundEndTime.sub(now);\r\n        }\r\n    }\r\n\r\n    function _extendRound() private {\r\n        roundEndTime = roundEndTime.max(now.add(curRoundExtension));\r\n\r\n        emit GameRoundExtended(roundEndTime);\r\n    }\r\n\r\n    function _startGameRound() private {\r\n        curExtensionVolume = 0 ether;\r\n        curRoundExtension = startingRoundExtension;\r\n\r\n        jackpot = nextJackpot;\r\n        nextJackpot = 0;\r\n\r\n        roundNumber = roundNumber.add(1);\r\n\r\n        _extendRound();\r\n\r\n        emit GameRoundStarted(jackpot, roundEndTime, roundNumber);\r\n    }\r\n\r\n    function _roundOver() private view returns (bool) {\r\n        return now >= roundEndTime;\r\n    }\r\n\r\n    modifier duringRound() {\r\n        require(\r\n            !_roundOver(),\r\n            \"Round is over\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // needed for round extension halving\r\n    function _logRoundExtensionVolume(uint256 amount) private {\r\n        curExtensionVolume = curExtensionVolume.add(amount);\r\n\r\n        if (curExtensionVolume >= halvingVolume) {\r\n            curRoundExtension = curRoundExtension.div(2).max(minRoundExtension);\r\n            curExtensionVolume = 0 ether;\r\n        }\r\n    }\r\n\r\n    function endGameRound() public atStage(Stage.GameRounds) {\r\n        require(\r\n            _roundOver(),\r\n            \"Round must be over!\"\r\n        );\r\n\r\n        _distributeJackpot();\r\n\r\n        emit GameRoundEnded(jackpot);\r\n\r\n        _startGameRound();\r\n    }\r\n\r\n    function setSquarePrice(uint8 squareId, uint256 newPrice, address referrer)\r\n        public\r\n        payable\r\n        atStage(Stage.GameRounds)\r\n        duringRound {\r\n        require(\r\n            squareToOwner[squareId] == msg.sender,\r\n            \"Can't set square price for a square you don't own!\"\r\n        );\r\n\r\n        uint256 tax = _priceToTax(newPrice);\r\n\r\n        require(\r\n            msg.value >= tax,\r\n            \"Must pay tax on new square price!\"\r\n        );\r\n\r\n        uint256 oldPrice = squareToPrice[squareId];\r\n        _distributeTax(msg.value, referrer);\r\n        _changeSquarePrice(squareId, newPrice);\r\n\r\n        // NOTE: Currently we extend round for 'every' square price change. Alternatively could do only on\r\n        // increases or decreases or changes exceeding some magnitude\r\n        _extendRound();\r\n        _logRoundExtensionVolume(msg.value);\r\n\r\n        emit SquarePriceChanged(squareId, squareToOwner[squareId], oldPrice, newPrice);\r\n    }\r\n\r\n    function buySquare(uint8 squareId, uint256 newPrice, address referrer)\r\n        public\r\n        payable\r\n        atStage(Stage.GameRounds)\r\n        duringRound {\r\n        address oldOwner = squareToOwner[squareId];\r\n        require(\r\n            oldOwner != msg.sender,\r\n            \"Can't buy a square you already own\"\r\n        );\r\n\r\n        uint256 tax = _priceToTax(newPrice);\r\n\r\n        uint256 oldPrice = squareToPrice[squareId];\r\n        require(\r\n            msg.value >= tax.add(oldPrice),\r\n            \"Must pay full price and tax for square\"\r\n        );\r\n\r\n        // pay seller\r\n        asyncSend(oldOwner, squareToPrice[squareId]);\r\n        squareToOwner[squareId] = msg.sender;\r\n\r\n        uint256 actualTax = msg.value.sub(oldPrice);\r\n        _distributeTax(actualTax, referrer);\r\n\r\n        _changeSquarePrice(squareId, newPrice);\r\n        _extendRound();\r\n        _logRoundExtensionVolume(msg.value);\r\n\r\n        emit SquareOwnerChanged(squareId, oldOwner, msg.sender, oldPrice, newPrice);\r\n    }\r\n\r\n    function _distributeJackpot() private {\r\n        uint256 winnerJackpot = _winnerJackpot(jackpot);\r\n        uint256 landholderJackpot = _landholderJackpot(jackpot);\r\n        \r\n        // get divs\r\n        uint256 divs = getDivsBalance();\r\n        if (divs > 0) {\r\n            P3DContract.withdraw();\r\n        }\r\n        \r\n        // add divs to landholderJackpot\r\n        landholderJackpot = landholderJackpot.add(divs);\r\n        \r\n        _distributeWinnerAndLandholderJackpot(winnerJackpot, landholderJackpot);\r\n\r\n        _buyP3D(_teamJackpot(jackpot));\r\n        \r\n        nextJackpot = nextJackpot.add(_nextPotJackpot(jackpot));\r\n    }\r\n\r\n    function _calculatePriceComplement(uint8 squareId) private view returns (uint256) {\r\n        return totalSquareValue.sub(squareToPrice[squareId]);\r\n    }\r\n\r\n    // NOTE: These are bundled together so that we only have to compute complements once\r\n    function _distributeWinnerAndLandholderJackpot(uint256 winnerJackpot, uint256 landholderJackpot) private {\r\n        uint256[] memory complements = new uint256[](numSquares + 1); // inc necessary b/c squares are 1-indexed\r\n        uint256 totalPriceComplement = 0;\r\n\r\n        uint256 bestComplement = 0;\r\n        uint8 lastWinningSquareId = 0;\r\n        for (uint8 i = minSquareId; i <= maxSquareId; i++) {\r\n            uint256 priceComplement = _calculatePriceComplement(i);\r\n\r\n            // update winner\r\n            if (bestComplement == 0 || priceComplement > bestComplement) {\r\n                bestComplement = priceComplement;\r\n                lastWinningSquareId = i;\r\n            }\r\n\r\n            complements[i] = priceComplement;\r\n            totalPriceComplement = totalPriceComplement.add(priceComplement);\r\n        }\r\n        uint256 numWinners = 0;\r\n        for (i = minSquareId; i <= maxSquareId; i++) {\r\n            if (_calculatePriceComplement(i) == bestComplement) {\r\n                numWinners++;\r\n            }\r\n        }\r\n        \r\n        // transfer some % P3D tokens to (why? see )\r\n        uint256 p3dTokens = getP3DBalance();\r\n    \r\n        // distribute jackpot among all winners. save time on the majority (1-winner) case\r\n        if (numWinners == 1) {\r\n            asyncSend(squareToOwner[lastWinningSquareId], winnerJackpot);\r\n            \r\n            if (p3dTokens > 0) {\r\n                _sendP3D(squareToOwner[lastWinningSquareId], _p3dSellPercentage(p3dTokens));\r\n            }\r\n        } else {\r\n            for (i = minSquareId; i <= maxSquareId; i++) {\r\n                if (_calculatePriceComplement(i) == bestComplement) {\r\n                    asyncSend(squareToOwner[i], winnerJackpot.div(numWinners));\r\n                    \r\n                    if (p3dTokens > 0) {\r\n                        _sendP3D(squareToOwner[i], _p3dSellPercentage(p3dTokens));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // distribute landholder things\r\n        for (i = minSquareId; i <= maxSquareId; i++) {\r\n            // NOTE: We don't exclude the jackpot winner(s) here, so the winner(s) is paid 'twice'\r\n            uint256 landholderAllocation = complements[i].mul(landholderJackpot).div(totalPriceComplement);\r\n\r\n            asyncSend(squareToOwner[i], landholderAllocation);\r\n        }\r\n    }\r\n\r\n    function _distributeTax(uint256 tax, address referrer) private {\r\n        jackpot = jackpot.add(_jackpotTax(tax));\r\n\r\n        _distributeLandholderTax(_totalLandholderTax(tax));\r\n        nextJackpot = nextJackpot.add(_nextPotTax(tax));\r\n\r\n        // NOTE: referrer tax comes out of p3d tax\r\n        bool hasReferrer = referrer != address(0);\r\n        _buyP3D(_teamTax(tax, hasReferrer));\r\n        asyncSend(referrer, _referrerTax(tax, hasReferrer));\r\n    }\r\n\r\n    function _distributeLandholderTax(uint256 tax) private {\r\n        for (uint8 square = minSquareId; square <= maxSquareId; square++) {\r\n            if (squareToOwner[square] != address(0) && squareToPrice[square] != 0) {\r\n                uint256 squarePrice = squareToPrice[square];\r\n                uint256 allocation = tax.mul(squarePrice).div(totalSquareValue);\r\n\r\n                asyncSend(squareToOwner[square], allocation);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function() payable {}\r\n}\r\n\r\ninterface HourglassInterface  {\r\n    function() payable external;\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function sell(uint256 _amountOfTokens) external;\r\n    function reinvest() external;\r\n    function withdraw() external;\r\n    function exit() external;\r\n    function dividendsOf(address _playerAddress) external view returns(uint256);\r\n    function balanceOf(address _playerAddress) external view returns(uint256);\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n    function stakingRequirement() external view returns(uint256);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"totalPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"_winnerJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSquarePriceAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"_jackpotTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endGameRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingRoundExtension\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDivsBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"_nextPotJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startingAuctionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"},{\"name\":\"hasReferrer\",\"type\":\"bool\"}],\"name\":\"_teamTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endingAuctionPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"halvingVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numBoughtSquares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSquareId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"_landholderJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPayments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"_totalLandholderTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minSquareId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"squareToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"}],\"name\":\"_nextPotTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curExtensionVolume\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numSquares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"_priceToTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"squareId\",\"type\":\"uint8\"},{\"name\":\"newPrice\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"setSquarePrice\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tax\",\"type\":\"uint256\"},{\"name\":\"hasReferrer\",\"type\":\"bool\"}],\"name\":\"_referrerTax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundTimeRemaining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getP3DBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawContractBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curRoundExtension\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"squareToPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSquareValue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"squareId\",\"type\":\"uint8\"},{\"name\":\"newPrice\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buySquare\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"_teamJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"_p3dSellPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minRoundExtension\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payments\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"squareId\",\"type\":\"uint8\"},{\"name\":\"newPrice\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"buySquareAtAuction\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"auctionStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"startingStage\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"squareId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"SquareOwnerChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startingAuctionPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingAuctionPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"auctionDuration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"AuctionStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"AuctionEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"squareId\",\"type\":\"uint8\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"SquarePriceChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"initJackpot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"roundNumber\",\"type\":\"uint256\"}],\"name\":\"GameRoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"GameRoundExtended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"jackpot\",\"type\":\"uint256\"}],\"name\":\"GameRoundEnded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Commercializ3d","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://6795f0ab8851a6ab53f8b185f20ef86b1cf697e3eda0a0ba97ee38c1cb5c9f28"}]}