{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @dev Pulled from OpenZeppelin: https://git.io/vbaRf\r\n *   When this is in a public release we will switch to not vendoring this file\r\n *\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Extracting these values isn't possible without assembly\r\n    // solhint-disable no-inline-assembly\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SigningLogic is contract implementing signature recovery from typed data signatures\r\n * @notice Recovers signatures based on the SignTypedData implementation provided by ethSigUtil\r\n * @dev This contract is inherited by other contracts.\r\n */\r\ncontract SigningLogic {\r\n\r\n  // Signatures contain a nonce to make them unique. usedSignatures tracks which signatures\r\n  //  have been used so they can't be replayed\r\n  mapping (bytes32 => bool) public usedSignatures;\r\n\r\n  function burnSignatureDigest(bytes32 _signatureDigest, address _sender) internal {\r\n    bytes32 _txDataHash = keccak256(abi.encode(_signatureDigest, _sender));\r\n    require(!usedSignatures[_txDataHash], \"Signature not unique\");\r\n    usedSignatures[_txDataHash] = true;\r\n  }\r\n\r\n  bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n  );\r\n\r\n  bytes32 constant ATTESTATION_REQUEST_TYPEHASH = keccak256(\r\n    \"AttestationRequest(bytes32 dataHash,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant ADD_ADDRESS_TYPEHASH = keccak256(\r\n    \"AddAddress(address addressToAdd,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant REMOVE_ADDRESS_TYPEHASH = keccak256(\r\n    \"RemoveAddress(address addressToRemove,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant PAY_TOKENS_TYPEHASH = keccak256(\r\n    \"PayTokens(address sender,address receiver,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant RELEASE_TOKENS_FOR_TYPEHASH = keccak256(\r\n    \"ReleaseTokensFor(address sender,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant ATTEST_FOR_TYPEHASH = keccak256(\r\n    \"AttestFor(address subject,address requester,uint256 reward,bytes32 dataHash,bytes32 requestNonce)\"\r\n  );\r\n\r\n  bytes32 constant CONTEST_FOR_TYPEHASH = keccak256(\r\n    \"ContestFor(address requester,uint256 reward,bytes32 requestNonce)\"\r\n  );\r\n\r\n  bytes32 constant REVOKE_ATTESTATION_FOR_TYPEHASH = keccak256(\r\n    \"RevokeAttestationFor(bytes32 link,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant VOTE_FOR_TYPEHASH = keccak256(\r\n    \"VoteFor(uint16 choice,address voter,bytes32 nonce,address poll)\"\r\n  );\r\n\r\n  bytes32 constant LOCKUP_TOKENS_FOR_TYPEHASH = keccak256(\r\n    \"LockupTokensFor(address sender,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 DOMAIN_SEPARATOR;\r\n\r\n  constructor (string name, string version, uint256 chainId) public {\r\n    DOMAIN_SEPARATOR = hash(EIP712Domain({\r\n      name: name,\r\n      version: version,\r\n      chainId: chainId,\r\n      verifyingContract: this\r\n    }));\r\n  }\r\n\r\n  struct EIP712Domain {\r\n      string  name;\r\n      string  version;\r\n      uint256 chainId;\r\n      address verifyingContract;\r\n  }\r\n\r\n  function hash(EIP712Domain eip712Domain) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      EIP712DOMAIN_TYPEHASH,\r\n      keccak256(bytes(eip712Domain.name)),\r\n      keccak256(bytes(eip712Domain.version)),\r\n      eip712Domain.chainId,\r\n      eip712Domain.verifyingContract\r\n    ));\r\n  }\r\n\r\n  struct AttestationRequest {\r\n      bytes32 dataHash;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AttestationRequest request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ATTESTATION_REQUEST_TYPEHASH,\r\n      request.dataHash,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct AddAddress {\r\n      address addressToAdd;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AddAddress request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ADD_ADDRESS_TYPEHASH,\r\n      request.addressToAdd,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct RemoveAddress {\r\n      address addressToRemove;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(RemoveAddress request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      REMOVE_ADDRESS_TYPEHASH,\r\n      request.addressToRemove,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct PayTokens {\r\n      address sender;\r\n      address receiver;\r\n      uint256 amount;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(PayTokens request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      PAY_TOKENS_TYPEHASH,\r\n      request.sender,\r\n      request.receiver,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct AttestFor {\r\n      address subject;\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 dataHash;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(AttestFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ATTEST_FOR_TYPEHASH,\r\n      request.subject,\r\n      request.requester,\r\n      request.reward,\r\n      request.dataHash,\r\n      request.requestNonce\r\n    ));\r\n  }\r\n\r\n  struct ContestFor {\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(ContestFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      CONTEST_FOR_TYPEHASH,\r\n      request.requester,\r\n      request.reward,\r\n      request.requestNonce\r\n    ));\r\n  }\r\n\r\n  struct RevokeAttestationFor {\r\n      bytes32 link;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(RevokeAttestationFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      REVOKE_ATTESTATION_FOR_TYPEHASH,\r\n      request.link,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct VoteFor {\r\n      uint16 choice;\r\n      address voter;\r\n      bytes32 nonce;\r\n      address poll;\r\n  }\r\n\r\n  function hash(VoteFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      VOTE_FOR_TYPEHASH,\r\n      request.choice,\r\n      request.voter,\r\n      request.nonce,\r\n      request.poll\r\n    ));\r\n  }\r\n\r\n  struct LockupTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(LockupTokensFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      LOCKUP_TOKENS_FOR_TYPEHASH,\r\n      request.sender,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct ReleaseTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(ReleaseTokensFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      RELEASE_TOKENS_FOR_TYPEHASH,\r\n      request.sender,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  function generateRequestAttestationSchemaHash(\r\n    bytes32 _dataHash,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AttestationRequest(\r\n          _dataHash,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateAddAddressSchemaHash(\r\n    address _addressToAdd,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AddAddress(\r\n          _addressToAdd,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateRemoveAddressSchemaHash(\r\n    address _addressToRemove,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(RemoveAddress(\r\n          _addressToRemove,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generatePayTokensSchemaHash(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(PayTokens(\r\n          _sender,\r\n          _receiver,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateAttestForDelegationSchemaHash(\r\n    address _subject,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AttestFor(\r\n          _subject,\r\n          _requester,\r\n          _reward,\r\n          _dataHash,\r\n          _requestNonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateContestForDelegationSchemaHash(\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _requestNonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(ContestFor(\r\n          _requester,\r\n          _reward,\r\n          _requestNonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateRevokeAttestationForDelegationSchemaHash(\r\n    bytes32 _link,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(RevokeAttestationFor(\r\n          _link,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateVoteForDelegationSchemaHash(\r\n    uint16 _choice,\r\n    address _voter,\r\n    bytes32 _nonce,\r\n    address _poll\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(VoteFor(\r\n          _choice,\r\n          _voter,\r\n          _nonce,\r\n          _poll\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateLockupTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(LockupTokensFor(\r\n          _sender,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateReleaseTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(ReleaseTokensFor(\r\n          _sender,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function recoverSigner(bytes32 _hash, bytes _sig) internal pure returns (address) {\r\n    address signer = ECRecovery.recover(_hash, _sig);\r\n    require(signer != address(0));\r\n\r\n    return signer;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Initializable\r\n * @dev The Initializable contract has an initializer address, and provides basic authorization control\r\n * only while in initialization mode. Once changed to production mode the inializer loses authority\r\n */\r\ncontract Initializable {\r\n  address public initializer;\r\n  bool public initializing;\r\n\r\n  event InitializationEnded();\r\n\r\n  /**\r\n   * @dev The Initializable constructor sets the initializer to the provided address\r\n   */\r\n  constructor(address _initializer) public {\r\n    initializer = _initializer;\r\n    initializing = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyDuringInitialization() {\r\n    require(msg.sender == initializer, 'Method can only be called by initializer');\r\n    require(initializing, 'Method can only be called during initialization');\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the initializer to end the initialization period\r\n   */\r\n  function endInitialization() public onlyDuringInitialization {\r\n    initializing = false;\r\n    emit InitializationEnded();\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Bloom account registry\r\n * @notice Account Registry Logic allows users to link multiple addresses to the same owner\r\n *\r\n */\r\ncontract AccountRegistryLogic is Initializable, SigningLogic {\r\n  /**\r\n   * @notice The AccountRegistry constructor configures the signing logic implementation\r\n   */\r\n  constructor(\r\n    address _initializer\r\n  ) public Initializable(_initializer) SigningLogic(\"Bloom Account Registry\", \"2\", 1) {}\r\n\r\n  event AddressLinked(address indexed currentAddress, address indexed newAddress, uint256 indexed linkId);\r\n  event AddressUnlinked(address indexed addressToRemove);\r\n\r\n  // Counter to generate unique link Ids\r\n  uint256 linkCounter;\r\n  mapping(address => uint256) public linkIds;\r\n\r\n  /**\r\n   * @notice Add an address to an existing id on behalf of a user to pay the gas costs\r\n   * @param _currentAddress Address to which user wants to link another address. May currently be linked to another address\r\n   * @param _currentAddressSig Signed message from address currently associated with account confirming intention\r\n   * @param _newAddress Address to add to account. Cannot currently be linked to another address\r\n   * @param _newAddressSig Signed message from new address confirming ownership by the sender\r\n   * @param _nonce hex string used when generating sigs to make them one time use\r\n   */\r\n  function linkAddresses(\r\n    address _currentAddress,\r\n    bytes _currentAddressSig,\r\n    address _newAddress,\r\n    bytes _newAddressSig,\r\n    bytes32 _nonce\r\n    ) external {\r\n      // Confirm newAddress is not linked to another account\r\n      require(linkIds[_newAddress] == 0);\r\n      // Confirm new address is signed by current address and is unused\r\n      validateLinkSignature(_currentAddress, _newAddress, _nonce, _currentAddressSig);\r\n\r\n      // Confirm current address is signed by new address and is unused\r\n      validateLinkSignature(_newAddress, _currentAddress, _nonce, _newAddressSig);\r\n\r\n      // Get linkId of current address if exists. Otherwise use incremented linkCounter\r\n      if (linkIds[_currentAddress] == 0) {\r\n        linkIds[_currentAddress] = ++linkCounter;\r\n      }\r\n      linkIds[_newAddress] = linkIds[_currentAddress];\r\n\r\n      emit AddressLinked(_currentAddress, _newAddress, linkIds[_currentAddress]);\r\n  }\r\n\r\n  /**\r\n   * @notice Remove an address from a link relationship\r\n   * @param _addressToRemove Address to unlink from all other addresses\r\n   * @param _unlinkSignature Signed message from address currently associated with account confirming intention to unlink\r\n   * @param _nonce hex string used when generating sigs to make them one time use\r\n   */\r\n  function unlinkAddress(\r\n    address _addressToRemove,\r\n    bytes32 _nonce,\r\n    bytes _unlinkSignature\r\n  ) external {\r\n    // Confirm unlink request is signed by sender and is unused\r\n    validateUnlinkSignature(_addressToRemove, _nonce, _unlinkSignature);\r\n    linkIds[_addressToRemove] = 0;\r\n\r\n    emit AddressUnlinked(_addressToRemove);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify link signature is valid and unused V\r\n   * @param _currentAddress Address signing intention to link\r\n   * @param _addressToAdd Address being linked\r\n   * @param _nonce Unique nonce for this request\r\n   * @param _linkSignature Signature of address a\r\n   */\r\n  function validateLinkSignature(\r\n    address _currentAddress,\r\n    address _addressToAdd,\r\n    bytes32 _nonce,\r\n    bytes _linkSignature\r\n  ) private {\r\n    bytes32 _signatureDigest = generateAddAddressSchemaHash(_addressToAdd, _nonce);\r\n    require(_currentAddress == recoverSigner(_signatureDigest, _linkSignature));\r\n    burnSignatureDigest(_signatureDigest, _currentAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify unlink signature is valid and unused \r\n   * @param _addressToRemove Address being unlinked\r\n   * @param _nonce Unique nonce for this request\r\n   * @param _unlinkSignature Signature of senderAddress\r\n   */\r\n  function validateUnlinkSignature(\r\n    address _addressToRemove,\r\n    bytes32 _nonce,\r\n    bytes _unlinkSignature\r\n  ) private {\r\n\r\n    // require that address to remove is currently linked to senderAddress\r\n    require(linkIds[_addressToRemove] != 0, \"Address does not have active link\");\r\n\r\n    bytes32 _signatureDigest = generateRemoveAddressSchemaHash(_addressToRemove, _nonce);\r\n\r\n    require(_addressToRemove == recoverSigner(_signatureDigest, _unlinkSignature));\r\n    burnSignatureDigest(_signatureDigest, _addressToRemove);\r\n  }\r\n\r\n  /**\r\n   * @notice Submit link completed prior to deployment of this contract\r\n   * @dev Gives initializer privileges to write links during the initialization period without signatures\r\n   * @param _currentAddress Address to which user wants to link another address. May currently be linked to another address\r\n   * @param _newAddress Address to add to account. Cannot currently be linked to another address\r\n   */\r\n  function migrateLink(\r\n    address _currentAddress,\r\n    address _newAddress\r\n  ) external onlyDuringInitialization {\r\n    // Confirm newAddress is not linked to another account\r\n    require(linkIds[_newAddress] == 0);\r\n\r\n    // Get linkId of current address if exists. Otherwise use incremented linkCounter\r\n    if (linkIds[_currentAddress] == 0) {\r\n      linkIds[_currentAddress] = ++linkCounter;\r\n    }\r\n    linkIds[_newAddress] = linkIds[_currentAddress];\r\n\r\n    emit AddressLinked(_currentAddress, _newAddress, linkIds[_currentAddress]);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title AttestationLogic allows users to submit attestations given valid signatures\r\n * @notice Attestation Logic Logic provides a public interface for Bloom and\r\n *  users to submit attestations.\r\n */\r\ncontract AttestationLogic is Initializable, SigningLogic{\r\n    TokenEscrowMarketplace public tokenEscrowMarketplace;\r\n\r\n  /**\r\n   * @notice AttestationLogic constructor sets the implementation address of all related contracts\r\n   * @param _tokenEscrowMarketplace Address of marketplace holding tokens which are\r\n   *  released to attesters upon completion of a job\r\n   */\r\n  constructor(\r\n    address _initializer,\r\n    TokenEscrowMarketplace _tokenEscrowMarketplace\r\n    ) Initializable(_initializer) SigningLogic(\"Bloom Attestation Logic\", \"2\", 1) public {\r\n    tokenEscrowMarketplace = _tokenEscrowMarketplace;\r\n  }\r\n\r\n  event TraitAttested(\r\n    address subject,\r\n    address attester,\r\n    address requester,\r\n    bytes32 dataHash\r\n    );\r\n  event AttestationRejected(address indexed attester, address indexed requester);\r\n  event AttestationRevoked(bytes32 link, address attester);\r\n  event TokenEscrowMarketplaceChanged(address oldTokenEscrowMarketplace, address newTokenEscrowMarketplace);\r\n\r\n  /**\r\n   * @notice Function for attester to submit attestation from their own account) \r\n   * @dev Wrapper for attestForUser using msg.sender\r\n   * @param _subject User this attestation is about\r\n   * @param _requester User requesting and paying for this attestation in BLT\r\n   * @param _reward Payment to attester from requester in BLT\r\n   * @param _requesterSig Signature authorizing payment from requester to attester\r\n   * @param _dataHash Hash of data being attested and nonce\r\n   * @param _requestNonce Nonce in sig signed by subject and requester so they can't be replayed\r\n   * @param _subjectSig Signed authorization from subject with attestation agreement\r\n   */\r\n  function attest(\r\n    address _subject,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes _requesterSig,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce,\r\n    bytes _subjectSig // Sig of subject with requester, attester, dataHash, requestNonce\r\n  ) external {\r\n    attestForUser(\r\n      _subject,\r\n      msg.sender,\r\n      _requester,\r\n      _reward,\r\n      _requesterSig,\r\n      _dataHash,\r\n      _requestNonce,\r\n      _subjectSig\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Submit attestation for a user in order to pay the gas costs\r\n   * @dev Recover signer of delegation message. If attester matches delegation signature, add the attestation\r\n   * @param _subject user this attestation is about\r\n   * @param _attester user completing the attestation\r\n   * @param _requester user requesting this attestation be completed and paying for it in BLT\r\n   * @param _reward payment to attester from requester in BLT wei\r\n   * @param _requesterSig signature authorizing payment from requester to attester\r\n   * @param _dataHash hash of data being attested and nonce\r\n   * @param _requestNonce Nonce in sig signed by subject and requester so they can't be replayed\r\n   * @param _subjectSig signed authorization from subject with attestation agreement\r\n   * @param _delegationSig signature authorizing attestation on behalf of attester\r\n   */\r\n  function attestFor(\r\n    address _subject,\r\n    address _attester,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes _requesterSig,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce,\r\n    bytes _subjectSig, // Sig of subject with dataHash and requestNonce\r\n    bytes _delegationSig\r\n  ) external {\r\n    // Confirm attester address matches recovered address from signature\r\n    validateAttestForSig(_subject, _attester, _requester, _reward, _dataHash, _requestNonce, _delegationSig);\r\n    attestForUser(\r\n      _subject,\r\n      _attester,\r\n      _requester,\r\n      _reward,\r\n      _requesterSig,\r\n      _dataHash,\r\n      _requestNonce,\r\n      _subjectSig\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Perform attestation\r\n   * @dev Verify valid certainty level and user addresses\r\n   * @param _subject user this attestation is about\r\n   * @param _attester user completing the attestation\r\n   * @param _requester user requesting this attestation be completed and paying for it in BLT\r\n   * @param _reward payment to attester from requester in BLT wei\r\n   * @param _requesterSig signature authorizing payment from requester to attester\r\n   * @param _dataHash hash of data being attested and nonce\r\n   * @param _requestNonce Nonce in sig signed by subject and requester so they can't be replayed\r\n   * @param _subjectSig signed authorization from subject with attestation agreement\r\n   */\r\n  function attestForUser(\r\n    address _subject,\r\n    address _attester,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes _requesterSig,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce,\r\n    bytes _subjectSig\r\n    ) private {\r\n    \r\n    validateSubjectSig(\r\n      _subject,\r\n      _dataHash,\r\n      _requestNonce,\r\n      _subjectSig\r\n    );\r\n\r\n    emit TraitAttested(\r\n      _subject,\r\n      _attester,\r\n      _requester,\r\n      _dataHash\r\n    );\r\n\r\n    if (_reward > 0) {\r\n      tokenEscrowMarketplace.requestTokenPayment(_requester, _attester, _reward, _requestNonce, _requesterSig);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Function for attester to reject an attestation and receive payment \r\n   *  without associating the negative attestation with the subject's bloomId\r\n   * @param _requester User requesting and paying for this attestation in BLT\r\n   * @param _reward Payment to attester from requester in BLT\r\n   * @param _requestNonce Nonce in sig signed by requester so it can't be replayed\r\n   * @param _requesterSig Signature authorizing payment from requester to attester\r\n   */\r\n  function contest(\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _requestNonce,\r\n    bytes _requesterSig\r\n  ) external {\r\n    contestForUser(\r\n      msg.sender,\r\n      _requester,\r\n      _reward,\r\n      _requestNonce,\r\n      _requesterSig\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Function for attester to reject an attestation and receive payment \r\n   *  without associating the negative attestation with the subject's bloomId\r\n   *  Perform on behalf of attester to pay gas fees\r\n   * @param _requester User requesting and paying for this attestation in BLT\r\n   * @param _attester user completing the attestation\r\n   * @param _reward Payment to attester from requester in BLT\r\n   * @param _requestNonce Nonce in sig signed by requester so it can't be replayed\r\n   * @param _requesterSig Signature authorizing payment from requester to attester\r\n   */\r\n  function contestFor(\r\n    address _attester,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _requestNonce,\r\n    bytes _requesterSig,\r\n    bytes _delegationSig\r\n  ) external {\r\n    validateContestForSig(\r\n      _attester,\r\n      _requester,\r\n      _reward,\r\n      _requestNonce,\r\n      _delegationSig\r\n    );\r\n    contestForUser(\r\n      _attester,\r\n      _requester,\r\n      _reward,\r\n      _requestNonce,\r\n      _requesterSig\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Private function for attester to reject an attestation and receive payment \r\n   *  without associating the negative attestation with the subject's bloomId\r\n   * @param _attester user completing the attestation\r\n   * @param _requester user requesting this attestation be completed and paying for it in BLT\r\n   * @param _reward payment to attester from requester in BLT wei\r\n   * @param _requestNonce Nonce in sig signed by requester so it can't be replayed\r\n   * @param _requesterSig signature authorizing payment from requester to attester\r\n   */\r\n  function contestForUser(\r\n    address _attester,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _requestNonce,\r\n    bytes _requesterSig\r\n    ) private {\r\n\r\n    if (_reward > 0) {\r\n      tokenEscrowMarketplace.requestTokenPayment(_requester, _attester, _reward, _requestNonce, _requesterSig);\r\n    }\r\n    emit AttestationRejected(_attester, _requester);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify subject signature is valid \r\n   * @param _subject user this attestation is about\r\n   * @param _dataHash hash of data being attested and nonce\r\n   * param _requestNonce Nonce in sig signed by subject so it can't be replayed\r\n   * @param _subjectSig Signed authorization from subject with attestation agreement\r\n   */\r\n  function validateSubjectSig(\r\n    address _subject,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce,\r\n    bytes _subjectSig\r\n  ) private {\r\n    bytes32 _signatureDigest = generateRequestAttestationSchemaHash(_dataHash, _requestNonce);\r\n    require(_subject == recoverSigner(_signatureDigest, _subjectSig));\r\n    burnSignatureDigest(_signatureDigest, _subject);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify attester delegation signature is valid \r\n   * @param _subject user this attestation is about\r\n   * @param _attester user completing the attestation\r\n   * @param _requester user requesting this attestation be completed and paying for it in BLT\r\n   * @param _reward payment to attester from requester in BLT wei\r\n   * @param _dataHash hash of data being attested and nonce\r\n   * @param _requestNonce nonce in sig signed by subject so it can't be replayed\r\n   * @param _delegationSig signature authorizing attestation on behalf of attester\r\n   */\r\n  function validateAttestForSig(\r\n    address _subject,\r\n    address _attester,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce,\r\n    bytes _delegationSig\r\n  ) private {\r\n    bytes32 _delegationDigest = generateAttestForDelegationSchemaHash(_subject, _requester, _reward, _dataHash, _requestNonce);\r\n    require(_attester == recoverSigner(_delegationDigest, _delegationSig), 'Invalid AttestFor Signature');\r\n    burnSignatureDigest(_delegationDigest, _attester);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify attester delegation signature is valid \r\n   * @param _attester user completing the attestation\r\n   * @param _requester user requesting this attestation be completed and paying for it in BLT\r\n   * @param _reward payment to attester from requester in BLT wei\r\n   * @param _requestNonce nonce referenced in TokenEscrowMarketplace so payment sig can't be replayed\r\n   * @param _delegationSig signature authorizing attestation on behalf of attester\r\n   */\r\n  function validateContestForSig(\r\n    address _attester,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _requestNonce,\r\n    bytes _delegationSig\r\n  ) private {\r\n    bytes32 _delegationDigest = generateContestForDelegationSchemaHash(_requester, _reward, _requestNonce);\r\n    require(_attester == recoverSigner(_delegationDigest, _delegationSig), 'Invalid ContestFor Signature');\r\n    burnSignatureDigest(_delegationDigest, _attester);\r\n  }\r\n\r\n  /**\r\n   * @notice Submit attestation completed prior to deployment of this contract\r\n   * @dev Gives initializer privileges to write attestations during the initialization period without signatures\r\n   * @param _requester user requesting this attestation be completed \r\n   * @param _attester user completing the attestation\r\n   * @param _subject user this attestation is about\r\n   * @param _dataHash hash of data being attested\r\n   */\r\n  function migrateAttestation(\r\n    address _requester,\r\n    address _attester,\r\n    address _subject,\r\n    bytes32 _dataHash\r\n  ) public onlyDuringInitialization {\r\n    emit TraitAttested(\r\n      _subject,\r\n      _attester,\r\n      _requester,\r\n      _dataHash\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Revoke an attestation\r\n   * @dev Link is included in dataHash and cannot be directly connected to a BloomID\r\n   * @param _link bytes string embedded in dataHash to link revocation\r\n   */\r\n  function revokeAttestation(\r\n    bytes32 _link\r\n    ) external {\r\n      revokeAttestationForUser(_link, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Revoke an attestation\r\n   * @dev Link is included in dataHash and cannot be directly connected to a BloomID\r\n   * @param _link bytes string embedded in dataHash to link revocation\r\n   */\r\n  function revokeAttestationFor(\r\n    address _sender,\r\n    bytes32 _link,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n    ) external {\r\n      validateRevokeForSig(_sender, _link, _nonce, _delegationSig);\r\n      revokeAttestationForUser(_link, _sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify revocation signature is valid \r\n   * @param _link bytes string embedded in dataHash to link revocation\r\n   * @param _sender user revoking attestation\r\n   * @param _delegationSig signature authorizing revocation on behalf of revoker\r\n   */\r\n  function validateRevokeForSig(\r\n    address _sender,\r\n    bytes32 _link,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n  ) private {\r\n    bytes32 _delegationDigest = generateRevokeAttestationForDelegationSchemaHash(_link, _nonce);\r\n    require(_sender == recoverSigner(_delegationDigest, _delegationSig), 'Invalid RevokeFor Signature');\r\n    burnSignatureDigest(_delegationDigest, _sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Revoke an attestation\r\n   * @dev Link is included in dataHash and cannot be directly connected to a BloomID\r\n   * @param _link bytes string embedded in dataHash to link revocation\r\n   * @param _sender address identify revoker\r\n   */\r\n  function revokeAttestationForUser(\r\n    bytes32 _link,\r\n    address _sender\r\n    ) private {\r\n      emit AttestationRevoked(_link, _sender);\r\n  }\r\n\r\n    /**\r\n   * @notice Set the implementation of the TokenEscrowMarketplace contract by setting a new address\r\n   * @dev Restricted to initializer\r\n   * @param _newTokenEscrowMarketplace Address of new SigningLogic implementation\r\n   */\r\n  function setTokenEscrowMarketplace(TokenEscrowMarketplace _newTokenEscrowMarketplace) external onlyDuringInitialization {\r\n    address oldTokenEscrowMarketplace = tokenEscrowMarketplace;\r\n    tokenEscrowMarketplace = _newTokenEscrowMarketplace;\r\n    emit TokenEscrowMarketplaceChanged(oldTokenEscrowMarketplace, tokenEscrowMarketplace);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    assert(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    assert(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    assert(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @notice TokenEscrowMarketplace is an ERC20 payment channel that enables users to send BLT by exchanging signatures off-chain\r\n *  Users approve the contract address to transfer BLT on their behalf using the standard ERC20.approve function\r\n *  After approval, either the user or the contract admin initiates the transfer of BLT into the contract\r\n *  Once in the contract, users can send payments via a signed message to another user. \r\n *  The signature transfers BLT from lockup to the recipient's balance\r\n *  Users can withdraw funds at any time. Or the admin can release them on the user's behalf\r\n *  \r\n *  BLT is stored in the contract by address\r\n *  \r\n *  Only the AttestationLogic contract is authorized to release funds once a jobs is complete\r\n */\r\ncontract TokenEscrowMarketplace is SigningLogic {\r\n  using SafeERC20 for ERC20;\r\n  using SafeMath for uint256;\r\n\r\n  address public attestationLogic;\r\n\r\n  mapping(address => uint256) public tokenEscrow;\r\n  ERC20 public token;\r\n\r\n  event TokenMarketplaceWithdrawal(address escrowPayer, uint256 amount);\r\n  event TokenMarketplaceEscrowPayment(address escrowPayer, address escrowPayee, uint256 amount);\r\n  event TokenMarketplaceDeposit(address escrowPayer, uint256 amount);\r\n\r\n  /**\r\n   * @notice The TokenEscrowMarketplace constructor initializes the interfaces to the other contracts\r\n   * @dev Some actions are restricted to be performed by the attestationLogic contract.\r\n   *  Signing logic is upgradeable in case the signTypedData spec changes\r\n   * @param _token Address of BLT\r\n   * @param _attestationLogic Address of current attestation logic contract\r\n   */\r\n  constructor(\r\n    ERC20 _token,\r\n    address _attestationLogic\r\n    ) public SigningLogic(\"Bloom Token Escrow Marketplace\", \"2\", 1) {\r\n    token = _token;\r\n    attestationLogic = _attestationLogic;\r\n  }\r\n\r\n  modifier onlyAttestationLogic() {\r\n    require(msg.sender == attestationLogic);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Lockup tokens for set time period on behalf of user. Must be preceeded by approve\r\n   * @dev Authorized by a signTypedData signature by sender\r\n   *  Sigs can only be used once. They contain a unique nonce\r\n   *  So an action can be repeated, with a different signature\r\n   * @param _sender User locking up their tokens\r\n   * @param _amount Tokens to lock up\r\n   * @param _nonce Unique Id so signatures can't be replayed\r\n   * @param _delegationSig Signed hash of these input parameters so an admin can submit this on behalf of a user\r\n   */\r\n  function moveTokensToEscrowLockupFor(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n    ) external {\r\n      validateLockupTokensSig(\r\n        _sender,\r\n        _amount,\r\n        _nonce,\r\n        _delegationSig\r\n      );\r\n      moveTokensToEscrowLockupForUser(_sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify lockup signature is valid\r\n   * @param _sender User locking up their tokens\r\n   * @param _amount Tokens to lock up\r\n   * @param _nonce Unique Id so signatures can't be replayed\r\n   * @param _delegationSig Signed hash of these input parameters so an admin can submit this on behalf of a user\r\n   */\r\n  function validateLockupTokensSig(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n  ) private {\r\n    bytes32 _signatureDigest = generateLockupTokensDelegationSchemaHash(_sender, _amount, _nonce);\r\n    require(_sender == recoverSigner(_signatureDigest, _delegationSig), 'Invalid LockupTokens Signature');\r\n    burnSignatureDigest(_signatureDigest, _sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Lockup tokens by user. Must be preceeded by approve\r\n   * @param _amount Tokens to lock up\r\n   */\r\n  function moveTokensToEscrowLockup(uint256 _amount) external {\r\n    moveTokensToEscrowLockupForUser(msg.sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Lockup tokens for set time. Must be preceeded by approve\r\n   * @dev Private function called by appropriate public function\r\n   * @param _sender User locking up their tokens\r\n   * @param _amount Tokens to lock up\r\n   */\r\n  function moveTokensToEscrowLockupForUser(\r\n    address _sender,\r\n    uint256 _amount\r\n    ) private {\r\n    token.safeTransferFrom(_sender, this, _amount);\r\n    addToEscrow(_sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Withdraw tokens from escrow back to requester\r\n   * @dev Authorized by a signTypedData signature by sender\r\n   *  Sigs can only be used once. They contain a unique nonce\r\n   *  So an action can be repeated, with a different signature\r\n   * @param _sender User withdrawing their tokens\r\n   * @param _amount Tokens to withdraw\r\n   * @param _nonce Unique Id so signatures can't be replayed\r\n   * @param _delegationSig Signed hash of these input parameters so an admin can submit this on behalf of a user\r\n   */\r\n  function releaseTokensFromEscrowFor(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n    ) external {\r\n      validateReleaseTokensSig(\r\n        _sender,\r\n        _amount,\r\n        _nonce,\r\n        _delegationSig\r\n      );\r\n      releaseTokensFromEscrowForUser(_sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify lockup signature is valid\r\n   * @param _sender User withdrawing their tokens\r\n   * @param _amount Tokens to lock up\r\n   * @param _nonce Unique Id so signatures can't be replayed\r\n   * @param _delegationSig Signed hash of these input parameters so an admin can submit this on behalf of a user\r\n   */\r\n  function validateReleaseTokensSig(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n\r\n  ) private {\r\n    bytes32 _signatureDigest = generateReleaseTokensDelegationSchemaHash(_sender, _amount, _nonce);\r\n    require(_sender == recoverSigner(_signatureDigest, _delegationSig), 'Invalid ReleaseTokens Signature');\r\n    burnSignatureDigest(_signatureDigest, _sender);\r\n  }\r\n\r\n  /**\r\n   * @notice Release tokens back to payer's available balance if lockup expires\r\n   * @dev Token balance retreived by accountId. Can be different address from the one that deposited tokens\r\n   * @param _amount Tokens to retreive from escrow\r\n   */\r\n  function releaseTokensFromEscrow(uint256 _amount) external {\r\n    releaseTokensFromEscrowForUser(msg.sender, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Release tokens back to payer's available balance\r\n   * @param _payer User retreiving tokens from escrow\r\n   * @param _amount Tokens to retreive from escrow\r\n   */\r\n  function releaseTokensFromEscrowForUser(\r\n    address _payer,\r\n    uint256 _amount\r\n    ) private {\r\n      subFromEscrow(_payer, _amount);\r\n      token.safeTransfer(_payer, _amount);\r\n      emit TokenMarketplaceWithdrawal(_payer, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Pay from escrow of payer to available balance of receiever\r\n   * @dev Private function to modify balances on payment\r\n   * @param _payer User with tokens in escrow\r\n   * @param _receiver User receiving tokens\r\n   * @param _amount Tokens being sent\r\n   */\r\n  function payTokensFromEscrow(address _payer, address _receiver, uint256 _amount) private {\r\n    subFromEscrow(_payer, _amount);\r\n    token.safeTransfer(_receiver, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Pay tokens to receiver from payer's escrow given a valid signature\r\n   * @dev Execution restricted to attestationLogic contract\r\n   * @param _payer User paying tokens from escrow\r\n   * @param _receiver User receiving payment\r\n   * @param _amount Tokens being paid\r\n   * @param _nonce Unique Id for sig to make it one-time-use\r\n   * @param _paymentSig Signed parameters by payer authorizing payment\r\n   */\r\n  function requestTokenPayment(\r\n    address _payer,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _paymentSig\r\n    ) external onlyAttestationLogic {\r\n\r\n    validatePaymentSig(\r\n      _payer,\r\n      _receiver,\r\n      _amount,\r\n      _nonce,\r\n      _paymentSig\r\n    );\r\n    payTokensFromEscrow(_payer, _receiver, _amount);\r\n    emit TokenMarketplaceEscrowPayment(_payer, _receiver, _amount);\r\n  }\r\n\r\n  /**\r\n   * @notice Verify payment signature is valid\r\n   * @param _payer User paying tokens from escrow\r\n   * @param _receiver User receiving payment\r\n   * @param _amount Tokens being paid\r\n   * @param _nonce Unique Id for sig to make it one-time-use\r\n   * @param _paymentSig Signed parameters by payer authorizing payment\r\n   */\r\n  function validatePaymentSig(\r\n    address _payer,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce,\r\n    bytes _paymentSig\r\n\r\n  ) private {\r\n    bytes32 _signatureDigest = generatePayTokensSchemaHash(_payer, _receiver, _amount, _nonce);\r\n    require(_payer == recoverSigner(_signatureDigest, _paymentSig), 'Invalid Payment Signature');\r\n    burnSignatureDigest(_signatureDigest, _payer);\r\n  }\r\n\r\n  /**\r\n   * @notice Helper function to add to escrow balance \r\n   * @param _from Account address for escrow mapping\r\n   * @param _amount Tokens to lock up\r\n   */\r\n  function addToEscrow(address _from, uint256 _amount) private {\r\n    tokenEscrow[_from] = tokenEscrow[_from].add(_amount);\r\n    emit TokenMarketplaceDeposit(_from, _amount);\r\n  }\r\n\r\n  /**\r\n   * Helper function to reduce escrow token balance of user\r\n   */\r\n  function subFromEscrow(address _from, uint256 _amount) private {\r\n    require(tokenEscrow[_from] >= _amount);\r\n    tokenEscrow[_from] = tokenEscrow[_from].sub(_amount);\r\n  }\r\n}\r\n\r\ncontract BatchInitializer is Ownable{\r\n\r\n  AccountRegistryLogic public registryLogic;\r\n  AttestationLogic public attestationLogic;\r\n  address public admin;\r\n\r\n  constructor(\r\n    AttestationLogic _attestationLogic,\r\n    AccountRegistryLogic _registryLogic\r\n    ) public {\r\n    attestationLogic = _attestationLogic;\r\n    registryLogic = _registryLogic;\r\n    admin = owner;\r\n  }\r\n\r\n  event linkSkipped(address currentAddress, address newAddress);\r\n\r\n  /**\r\n   * @dev Restricted to admin\r\n   */\r\n  modifier onlyAdmin {\r\n    require(msg.sender == admin);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @notice Change the address of the admin, who has the privilege to create new accounts\r\n   * @dev Restricted to AccountRegistry owner and new admin address cannot be 0x0\r\n   * @param _newAdmin Address of new admin\r\n   */\r\n  function setAdmin(address _newAdmin) external onlyOwner {\r\n    admin = _newAdmin;\r\n  }\r\n\r\n  function setRegistryLogic(AccountRegistryLogic _newRegistryLogic) external onlyOwner {\r\n    registryLogic = _newRegistryLogic;\r\n  }\r\n\r\n  function setAttestationLogic(AttestationLogic _newAttestationLogic) external onlyOwner {\r\n    attestationLogic = _newAttestationLogic;\r\n  }\r\n\r\n  function setTokenEscrowMarketplace(TokenEscrowMarketplace _newMarketplace) external onlyOwner {\r\n    attestationLogic.setTokenEscrowMarketplace(_newMarketplace);\r\n  }\r\n\r\n  function endInitialization(Initializable _initializable) external onlyOwner {\r\n    _initializable.endInitialization();\r\n  }\r\n\r\n  function batchLinkAddresses(address[] _currentAddresses, address[] _newAddresses) external onlyAdmin {\r\n    require(_currentAddresses.length == _newAddresses.length);\r\n    for (uint256 i = 0; i < _currentAddresses.length; i++) {\r\n      if (registryLogic.linkIds(_newAddresses[i]) > 0) {\r\n        emit linkSkipped(_currentAddresses[i], _newAddresses[i]);\r\n      } else {\r\n        registryLogic.migrateLink(_currentAddresses[i], _newAddresses[i]);\r\n      }\r\n    }\r\n  }\r\n\r\n  function batchMigrateAttestations(\r\n    address[] _requesters,\r\n    address[] _attesters,\r\n    address[] _subjects,\r\n    bytes32[] _dataHashes\r\n    ) external onlyAdmin {\r\n    require(\r\n      _requesters.length == _attesters.length &&\r\n      _requesters.length == _subjects.length &&\r\n      _requesters.length == _dataHashes.length\r\n      );\r\n    // This loop will fail if args don't all have equal length\r\n    for (uint256 i = 0; i < _requesters.length; i++) {\r\n      attestationLogic.migrateAttestation(\r\n        _requesters[i],\r\n        _attesters[i],\r\n        _subjects[i],\r\n        _dataHashes[i]\r\n        );\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_currentAddresses\",\"type\":\"address[]\"},{\"name\":\"_newAddresses\",\"type\":\"address[]\"}],\"name\":\"batchLinkAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRegistryLogic\",\"type\":\"address\"}],\"name\":\"setRegistryLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newMarketplace\",\"type\":\"address\"}],\"name\":\"setTokenEscrowMarketplace\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAttestationLogic\",\"type\":\"address\"}],\"name\":\"setAttestationLogic\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"attestationLogic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_requesters\",\"type\":\"address[]\"},{\"name\":\"_attesters\",\"type\":\"address[]\"},{\"name\":\"_subjects\",\"type\":\"address[]\"},{\"name\":\"_dataHashes\",\"type\":\"bytes32[]\"}],\"name\":\"batchMigrateAttestations\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initializable\",\"type\":\"address\"}],\"name\":\"endInitialization\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registryLogic\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_attestationLogic\",\"type\":\"address\"},{\"name\":\"_registryLogic\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAddress\",\"type\":\"address\"}],\"name\":\"linkSkipped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BatchInitializer","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://cd2821053837038fe87c1312a18026e24b1da55788c77e9e65393282aa34d645"}]}