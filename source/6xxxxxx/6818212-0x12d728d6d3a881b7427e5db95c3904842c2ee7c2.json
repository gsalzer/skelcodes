{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\n/**\r\n    This contract represents a sort of time-limited challenge,\r\n    where users can vote for some candidates.\r\n    After the deadline comes the contract will define a winner and vote holders can get their reward.\r\n**/\r\ncontract VotingChallenge {\r\n    VotingChallengeForwarder forwarder;\r\n\r\n    uint public challengeDuration;\r\n    uint public challengePrize;\r\n    uint public creatorPrize;\r\n    uint public cryptoVersusPrize;\r\n    uint public challengeStarted;\r\n    uint public candidatesNumber;\r\n    address public creator;\r\n    uint16 public creatorFee;       // measured in in tenths of a percent\r\n    address public cryptoVersusWallet;\r\n    uint16 public cryptoVersusFee;  // measured in in tenths of a percent\r\n    uint public winner;\r\n    bool public isVotingPeriod;\r\n    bool public beforeVoting;\r\n    uint[] public votes;\r\n    mapping( address => mapping (uint => uint)) public userVotesDistribution;\r\n    mapping( address => address[2] ) public userReferrers;\r\n\r\n    // Modifiers\r\n    modifier inVotingPeriod() {\r\n        require(isVotingPeriod);\r\n        _;\r\n    }\r\n\r\n    modifier afterVotingPeriod() {\r\n        require(!isVotingPeriod);\r\n        _;\r\n    }\r\n\r\n    modifier onlyCreator() {\r\n        require(msg.sender == creator);\r\n        _;\r\n    }\r\n\r\n    // Events\r\n    event ChallengeBegins(address _creator, uint16 _creatorFee, uint _candidatesNumber, uint _challengeDuration);\r\n    event NewVotesFor(address _participant, uint _candidate, uint _votes);\r\n    event TransferVotes(address _from, address _to, uint _candidateIndex, uint _votes);\r\n    event EndOfChallenge(uint _winner, uint _winnerVotes, uint _challengePrize);\r\n    event RewardWasPaid(address _participant, uint _amount);\r\n    event ReferrerRewardWasPaid(address _via, address _to, uint amount);\r\n    event CreatorRewardWasPaid(address _creator, uint _amount);\r\n    event CryptoVersusRewardWasPaid(address _cryptoVersusWallet, uint _amount);\r\n\r\n    // Constructor\r\n    constructor(uint _challengeDuration, uint _candidatesNumber, uint16 _creatorFee, address _forwarder) public {\r\n        forwarder = VotingChallengeForwarder(_forwarder);\r\n        challengeDuration = _challengeDuration;\r\n        candidatesNumber = _candidatesNumber;\r\n        votes.length = candidatesNumber + 1; // we will never use the first elements of array (with zero index)\r\n        creator = msg.sender;\r\n        cryptoVersusWallet = 0xa0bedE75cfeEF0266f8A31b47074F5f9fBE1df80;\r\n        creatorFee = _creatorFee;\r\n        cryptoVersusFee = 33;\r\n        beforeVoting = true;\r\n\r\n        // Check that creatorFee and cryptoVersusFee are less than 1000\r\n        if(creatorFee > 1000) {\r\n            creatorFee = 1000;\r\n            cryptoVersusFee = 0;\r\n            return;\r\n        }\r\n        if(cryptoVersusFee > 1000) {\r\n            cryptoVersusFee = 1000;\r\n            creatorFee = 0;\r\n            return;\r\n        }\r\n        if(creatorFee + cryptoVersusFee > 1000) {\r\n            cryptoVersusFee = 1000 - creatorFee;\r\n        }\r\n    }\r\n\r\n    // Last block timestamp getter\r\n    function getTime() public view returns (uint) {\r\n        return now;\r\n    }\r\n\r\n    function getAllVotes() public view returns (uint[] memory) {\r\n        return votes;\r\n    }\r\n\r\n    // Start challenge\r\n    function startChallenge() public onlyCreator {\r\n        require(beforeVoting);\r\n        isVotingPeriod = true;\r\n        beforeVoting = false;\r\n        challengeStarted = now;\r\n\r\n        emit ChallengeBegins(creator, creatorFee, candidatesNumber, challengeDuration);\r\n    }\r\n\r\n    // Change creator address\r\n    function changeCreator(address newCreator) public onlyCreator {\r\n        creator = newCreator;\r\n    }\r\n\r\n    // Change Crypto Versus wallet address\r\n    function changeWallet(address newWallet) public {\r\n        require(msg.sender == cryptoVersusWallet);\r\n        cryptoVersusWallet = newWallet;\r\n    }\r\n\r\n    // Vote for candidate\r\n    function voteForCandidate(uint candidate) public payable inVotingPeriod {\r\n        require(candidate <= candidatesNumber);\r\n        require(candidate > 0);\r\n        require(msg.value > 0);\r\n        require(!timeOver());\r\n\r\n        // Add new votes for community\r\n        // uint weighted = msg.value * (1 - .7 * (now - challengeStarted) / challengeDuration);\r\n        votes[candidate] += msg.value;\r\n\r\n        // Change the votes distribution\r\n        userVotesDistribution[msg.sender][candidate] += msg.value;\r\n\r\n        // Fire the event\r\n        emit NewVotesFor(msg.sender, candidate, msg.value);\r\n    }\r\n\r\n    function voteForCandidate(uint candidate, address referrer1) public payable inVotingPeriod {\r\n        userReferrers[msg.sender][0] = referrer1;\r\n        voteForCandidate(candidate);\r\n    }\r\n\r\n    function voteForCandidate(uint candidate, address referrer1, address referrer2) public payable inVotingPeriod {\r\n        userReferrers[msg.sender][1] = referrer2;\r\n        voteForCandidate(candidate, referrer1);\r\n    }\r\n\r\n    // Vote for candidate\r\n    function voteForCandidateViaProxy(uint candidate, address sender) public payable inVotingPeriod {\r\n        require(candidate <= candidatesNumber);\r\n        require(candidate > 0);\r\n        require(msg.value > 0);\r\n        require(!timeOver());\r\n\r\n        // Add new votes for community\r\n        // uint weighted = msg.value * (1 - .7 * (now - challengeStarted) / challengeDuration);\r\n        votes[candidate] += msg.value;\r\n\r\n        // Change the votes distribution\r\n        userVotesDistribution[sender][candidate] += msg.value;\r\n\r\n        // Fire the event\r\n        emit NewVotesFor(sender, candidate, msg.value);\r\n    }\r\n\r\n    // Transfer votes to anybody\r\n    function transferVotes (address to, uint candidate) public inVotingPeriod {\r\n        require(userVotesDistribution[msg.sender][candidate] > 0);\r\n        uint votesToTransfer = userVotesDistribution[msg.sender][candidate];\r\n        userVotesDistribution[msg.sender][candidate] = 0;\r\n        userVotesDistribution[to][candidate] += votesToTransfer;\r\n\r\n        // Fire the event\r\n        emit TransferVotes(msg.sender, to, candidate, votesToTransfer);\r\n    }\r\n\r\n    function timeOver() public view returns (bool) {\r\n        return challengeStarted + challengeDuration <= now;\r\n    }\r\n\r\n    // Check the deadline\r\n    // If success then define a winner and close the challenge\r\n    function checkEndOfChallenge() public inVotingPeriod returns (bool) {\r\n        if (!timeOver())\r\n            return false;\r\n        uint theWinner;\r\n        uint winnerVotes;\r\n        uint actualBalance = address(this).balance;\r\n\r\n        for (uint i = 1; i <= candidatesNumber; i++) {\r\n            if (votes[i] > winnerVotes) {\r\n                winnerVotes = votes[i];\r\n                theWinner = i;\r\n            }\r\n        }\r\n        winner = theWinner;\r\n        creatorPrize = (actualBalance * creatorFee) / 1000;\r\n        cryptoVersusPrize = (actualBalance * cryptoVersusFee) / 1000;\r\n        challengePrize = actualBalance - creatorPrize - cryptoVersusPrize;\r\n        isVotingPeriod = false;\r\n\r\n        // Fire the event\r\n        emit EndOfChallenge(winner, winnerVotes, challengePrize);\r\n        return true;\r\n    }\r\n\r\n    // Send a reward if user voted for a winner\r\n    function getReward() public afterVotingPeriod {\r\n        if (userVotesDistribution[msg.sender][winner] > 0) {\r\n            // Compute a vote ratio and send the reward\r\n            uint userVotesForWinner = userVotesDistribution[msg.sender][winner];\r\n            userVotesDistribution[msg.sender][winner] = 0;\r\n            uint reward = (challengePrize * userVotesForWinner) / votes[winner];\r\n            msg.sender.transfer(reward);\r\n\r\n            // Fire the event\r\n            emit RewardWasPaid(msg.sender, reward);\r\n        }\r\n    }\r\n\r\n    // Send a reward if user voted for a winner\r\n    function sendReward(address to) public afterVotingPeriod {\r\n        uint userVotesForWinner = userVotesDistribution[to][winner];\r\n        uint userVotesForLoser = 0;\r\n        for (uint i = 1; i <= candidatesNumber; i++) {\r\n            if (i == winner) continue;\r\n            userVotesForLoser += userVotesDistribution[to][i];\r\n            userVotesDistribution[to][i] = 0;\r\n        }\r\n        address referrer1 = userReferrers[to][0];\r\n        address referrer2 = userReferrers[to][1];\r\n\r\n        if (userVotesForWinner > 0) {\r\n            userVotesDistribution[to][winner] = 0;\r\n            // Compute a vote ratio and send the reward\r\n            uint reward = (challengePrize * userVotesForWinner) / votes[winner];\r\n            uint actualReward = (address(this).balance * userVotesForWinner) / votes[winner];\r\n            to.transfer(reward);\r\n\r\n            if (reward > 0 && referrer1 != 0x0) {\r\n                uint reward1 = actualReward / 100 * 2;  // 2%\r\n                forwarder.forward.value(reward1)(referrer1, to);\r\n                emit ReferrerRewardWasPaid(to, referrer1, reward1);\r\n            }\r\n            if (reward > 0 && referrer2 != 0x0) {\r\n                uint reward2 = actualReward / 1000 * 2;  // 0.2%\r\n                forwarder.forward.value(reward2)(referrer2, to);\r\n                emit ReferrerRewardWasPaid(to, referrer2, reward2);\r\n            }\r\n\r\n            // Fire the event\r\n            emit RewardWasPaid(to, reward);\r\n        }\r\n        if (userVotesForLoser > 0) {\r\n            if (referrer1 != 0x0) {\r\n                uint rewardl1 = userVotesForLoser / 100 * 1;  // 1%\r\n                forwarder.forward.value(rewardl1)(referrer1, to);\r\n                emit ReferrerRewardWasPaid(to, referrer1, rewardl1);\r\n            }\r\n            if (referrer2 != 0x0) {\r\n                uint rewardl2 = userVotesForLoser / 1000 * 1;  // 0.1%\r\n                forwarder.forward.value(rewardl2)(referrer2, to);\r\n                emit ReferrerRewardWasPaid(to, referrer2, rewardl2);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Send a reward to challenge creator\r\n    function sendCreatorReward() public afterVotingPeriod {\r\n        if (creatorPrize > 0) {\r\n            uint creatorReward = creatorPrize;\r\n            creatorPrize = 0;\r\n            creator.transfer(creatorReward);\r\n\r\n            // Fire the event\r\n            emit CreatorRewardWasPaid(creator, creatorReward);\r\n        }\r\n    }\r\n\r\n    // Send a reward to cryptoVersusWallet\r\n    function sendCryptoVersusReward() public afterVotingPeriod {\r\n        if (cryptoVersusPrize > 0) {\r\n            uint cryptoVersusReward = cryptoVersusPrize;\r\n            cryptoVersusPrize = 0;\r\n            cryptoVersusWallet.transfer(cryptoVersusReward);\r\n\r\n            // Fire the event\r\n            emit CryptoVersusRewardWasPaid(cryptoVersusWallet, cryptoVersusReward);\r\n        }\r\n    }\r\n}\r\n\r\ncontract VotingChallengeProxy {\r\n    VotingChallenge challenge;\r\n    uint candidate;\r\n\r\n    constructor(address _mainAddress, uint _candidate) public {\r\n        challenge = VotingChallenge(_mainAddress);\r\n        candidate = _candidate;\r\n    }\r\n\r\n    function() public payable {\r\n        challenge.voteForCandidateViaProxy.value(msg.value)(candidate, msg.sender);\r\n    }\r\n}\r\n\r\ncontract VotingChallengeForwarder {\r\n    mapping ( address => address[] ) public sendersHash;\r\n    mapping ( address => uint[] ) public sumsHash;\r\n\r\n    function forward(address to, address sender) public payable {\r\n        to.transfer(msg.value);\r\n        sendersHash[to].push(sender);\r\n        sumsHash[to].push(msg.value);\r\n    }\r\n\r\n    function getSendersHash(address user) public view returns (address[]) {\r\n        return sendersHash[user];\r\n    }\r\n\r\n    function getSumsHash(address user) public view returns (uint[]) {\r\n        return sumsHash[user];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sumsHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sendersHash\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"forward\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getSumsHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getSendersHash\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"VotingChallengeForwarder","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f92a8626778d9ee5525418b52ae50651bcde131e349a4092b6d1fadeeb01a2c2"}]}