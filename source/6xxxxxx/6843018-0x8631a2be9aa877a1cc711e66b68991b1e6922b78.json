{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n *  https://Smart-234.io\r\n *\r\n * Smart-contract start at 11 Dec 2018 10:00 UTC\r\n *\r\n *\r\n * Smart-234 Contract\r\n *  - GAIN 2.34% PER 24 HOURS\r\n *  -     +0.02% every day before the payment\r\n *\r\n *  - Minimal contribution 0.01 eth\r\n *  - Currency and payment - ETH\r\n *  - Contribution allocation schemes:\r\n *    -- 96% payments\r\n *    -- 4% Marketing\r\n *\r\n *\r\n * You get MORE PROFIT if you withdraw later !\r\n * Increase of the total rate of return by 0.02% every day before the payment.\r\n * The increase in profitability affects all previous days!\r\n *  After the dividend is paid, the rate of return is returned to 2.34 % per day\r\n *\r\n *           For example: if the Deposit is 10 ETH\r\n *\r\n *                days      |   %    |   profit\r\n *          --------------------------------------\r\n *            1 (>24 hours) | 2.36 % | 0.235 ETH\r\n *              10          | 2.54 % | 2.54  ETH\r\n *              30          | 2.94 % | 8.82  ETH\r\n *              50          | 3.34 % | 16.7  ETH\r\n *              100         | 4.34 % | 43.4  ETH\r\n *\r\n *\r\n * How to use:\r\n *  1. Send any amount of ether to make an investment\r\n *  2a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're spending too much on GAS)\r\n *  OR\r\n *  2b. Send more ether to reinvest AND get your profit at the same time\r\n *\r\n * RECOMMENDED GAS LIMIT: 250000\r\n * RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n *\r\n * Contract reviewed and approved by experts!\r\n *\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        uint256 c = _a / _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract InvestorsStorage {\r\n    using SafeMath for uint256;\r\n\r\n    address private owner;\r\n    uint private _investorsCount;\r\n\r\n    struct Deposit {\r\n        uint amount;\r\n        uint start;\r\n    }\r\n\r\n    struct Investor {\r\n        Deposit[] deposits;\r\n        uint checkpoint;\r\n        address referrer;\r\n    }\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function addDeposit(address _address, uint _value) external onlyOwner {\r\n        investors[_address].deposits.push(Deposit(_value, block.timestamp));\r\n        if (investors[_address].checkpoint == 0) {\r\n            investors[_address].checkpoint = block.timestamp;\r\n            _investorsCount += 1;\r\n        }\r\n    }\r\n\r\n    function updateCheckpoint(address _address) external onlyOwner {\r\n        investors[_address].checkpoint = block.timestamp;\r\n    }\r\n\r\n    function addReferrer(address _referral, address _referrer) external onlyOwner {\r\n        investors[_referral].referrer = _referrer;\r\n    }\r\n\r\n    function getInterest(address _address, uint _index, bool _exception) public view returns(uint) {\r\n        if (investors[_address].deposits[_index].amount > 0) {\r\n            if (_exception) {\r\n                uint time = investors[_address].deposits[_index].start;\r\n            } else {\r\n                time = investors[_address].checkpoint;\r\n            }\r\n            return(234 + ((block.timestamp - time) / 1 days) * 2);\r\n        }\r\n    }\r\n\r\n    function isException(address _address, uint _index) public view returns(bool) {\r\n        if (investors[_address].deposits[_index].start > investors[_address].checkpoint) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    function d(address _address, uint _index) public view returns(uint) {\r\n        return investors[_address].deposits[_index].amount;\r\n    }\r\n\r\n    function c(address _address) public view returns(uint) {\r\n        return investors[_address].checkpoint;\r\n    }\r\n\r\n    function r(address _address) external view returns(address) {\r\n        return investors[_address].referrer;\r\n    }\r\n\r\n    function s(address _address, uint _index) public view returns(uint) {\r\n        return investors[_address].deposits[_index].start;\r\n    }\r\n\r\n    function sumOfDeposits(address _address) external view returns(uint) {\r\n        uint sum;\r\n        for (uint i = 0; i < investors[_address].deposits.length; i++) {\r\n            sum += investors[_address].deposits[i].amount;\r\n        }\r\n        return sum;\r\n    }\r\n\r\n    function amountOfDeposits(address _address) external view returns(uint) {\r\n        return investors[_address].deposits.length;\r\n    }\r\n\r\n    function dividends(address _address) external view returns(uint) {\r\n        uint _payout;\r\n        uint percent = getInterest(_address, 0, false);\r\n\r\n        for (uint i = 0; i < investors[_address].deposits.length; i++) {\r\n            if (!isException(_address, i)) {\r\n                _payout += (d(_address, i).mul(percent).div(10000)).mul(block.timestamp.sub(c(_address))).div(1 days);\r\n            } else {\r\n                _payout += (d(_address, i).mul(getInterest(_address, i, true)).div(10000)).mul(block.timestamp.sub(s(_address, i))).div(1 days);\r\n            }\r\n        }\r\n\r\n        return _payout;\r\n    }\r\n\r\n    function investorsCount() external view returns(uint) {\r\n        return _investorsCount;\r\n    }\r\n}\r\n\r\ncontract Smart234 {\r\n    using SafeMath for uint;\r\n\r\n    address admin;\r\n    uint waveStartUp;\r\n\r\n    uint invested;\r\n    uint payed;\r\n    uint startTime;\r\n\r\n    event LogInvestment(address indexed _addr, uint _value, uint _bonus);\r\n    event LogIncome(address indexed _addr, uint _value);\r\n    event LogReferrerAdded(address indexed _investor, address indexed _referrer);\r\n    event LogRefBonus(address indexed _investor, address indexed _referrer, uint _amount, uint indexed _level);\r\n    event LogNewWave(uint _waveStartUp);\r\n\r\n    InvestorsStorage private x;\r\n\r\n    modifier notOnPause() {\r\n        require(waveStartUp <= block.timestamp);\r\n        _;\r\n    }\r\n\r\n    function bytesToAddress(bytes _source) internal pure returns(address parsedReferrer) {\r\n        assembly {\r\n            parsedReferrer := mload(add(_source,0x14))\r\n        }\r\n        return parsedReferrer;\r\n    }\r\n\r\n    function addReferrer() internal returns(uint) {\r\n        address _referrer = bytesToAddress(bytes(msg.data));\r\n        if (_referrer != msg.sender) {\r\n            x.addReferrer(msg.sender, _referrer);\r\n            emit LogReferrerAdded(msg.sender, _referrer);\r\n            return(msg.value / 20);\r\n        }\r\n    }\r\n\r\n    function refSystem() private {\r\n        address first = x.r(msg.sender);\r\n        if (x.amountOfDeposits(first) < 500) {\r\n            x.addDeposit(first, msg.value / 10);\r\n            emit LogRefBonus(msg.sender, first, msg.value / 10, 1);\r\n        }\r\n        address second = x.r(first);\r\n        if (second != 0x0) {\r\n            if (x.amountOfDeposits(second) < 500) {\r\n                x.addDeposit(second, msg.value / 20);\r\n                emit LogRefBonus(msg.sender, second, msg.value / 20, 2);\r\n            }\r\n            address third = x.r(second);\r\n            if (third != 0x0) {\r\n                if (x.amountOfDeposits(third) < 500) {\r\n                    x.addDeposit(third, msg.value * 3 / 100);\r\n                    emit LogRefBonus(msg.sender, third, msg.value * 3 / 100, 3);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    constructor(address _admin) public {\r\n        admin = _admin;\r\n        x = new InvestorsStorage();\r\n        startTime = now;\r\n        // waveStartUp = 1544522400;\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value == 0) {\r\n            withdraw();\r\n        } else {\r\n            invest();\r\n        }\r\n    }\r\n\r\n    function invest() notOnPause public payable {\r\n        // require(msg.value >= 0.01 ether);\r\n        admin.transfer(msg.value / 25);\r\n\r\n        if (x.r(msg.sender) != 0x0) {\r\n            refSystem();\r\n        } else if (msg.data.length == 20) {\r\n            uint bonus = addReferrer();\r\n            refSystem();\r\n        }\r\n\r\n        x.addDeposit(msg.sender, msg.value + bonus);\r\n\r\n        invested += msg.value;\r\n        emit LogInvestment(msg.sender, msg.value, bonus);\r\n    }\r\n\r\n    function withdraw() public {\r\n\r\n        uint _payout = x.dividends(msg.sender);\r\n\r\n        if (_payout > 0) {\r\n\r\n            if (_payout > address(this).balance) {\r\n                nextWave();\r\n                return;\r\n            }\r\n\r\n            x.updateCheckpoint(msg.sender);\r\n            admin.transfer(_payout / 25);\r\n            msg.sender.transfer(_payout * 24 / 25);\r\n            emit LogIncome(msg.sender, _payout);\r\n            payed += _payout;\r\n        }\r\n    }\r\n\r\n    function getDeposits(address _address) external view returns(uint) {\r\n        return x.sumOfDeposits(_address);\r\n    }\r\n\r\n    function getDividends(address _address) external view returns(uint) {\r\n        return x.dividends(_address);\r\n    }\r\n\r\n    function getDividendsWithFee(address _address) external view returns(uint) {\r\n        return x.dividends(_address) * 24 / 25;\r\n    }\r\n\r\n    function getDaysAfterStart() external view returns(uint) {\r\n        return (block.timestamp.sub(startTime)) / 1 days;\r\n    }\r\n\r\n    function investorsCount() external view returns(uint) {\r\n        return x.investorsCount();\r\n    }\r\n\r\n    function getInvestedAmount() external view returns(uint) {\r\n        return invested;\r\n    }\r\n\r\n    function getPayedAmount() external view returns(uint) {\r\n        return payed;\r\n    }\r\n\r\n    function nextWave() private {\r\n        x = new InvestorsStorage();\r\n        invested = 0;\r\n        payed = 0;\r\n        waveStartUp = block.timestamp + 7 days;\r\n        emit LogNewWave(waveStartUp);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getPayedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInvestedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDeposits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDaysAfterStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDividendsWithFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogIncome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"LogReferrerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"LogRefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_waveStartUp\",\"type\":\"uint256\"}],\"name\":\"LogNewWave\",\"type\":\"event\"}]","ContractName":"Smart234","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000007ad3cc40eb43dc3f137308e5d7f3c0dde631792","Library":"","SwarmSource":"bzzr://b3e4fe134bc6515dc715fe10bcc0d434d748750fa2b8e17bc55c215dcbc9320a"}]}