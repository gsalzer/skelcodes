{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n// Contract is owned by CryptX Financial \r\n// Owner ethereum address is 0x5F96FEC8db3548e0FC24C1ABe8C1a1eABd2Fad91\r\n//Safe math ensures that the mathematical operations work as intended\r\ncontract SafeMath {                 \r\n    function safeAdd(uint a, uint b) public pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function safeSub(uint a, uint b) public pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function safeMul(uint a, uint b) public pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function safeDiv(uint a, uint b) public pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n// ERC20 Contract Interface for interacting with the Contract\r\ncontract Interface { \r\n    \r\n    // Shows the total supply of token on the ethereum blockchain\r\n    function Supply() public constant returns (uint);\r\n    \r\n    // Shows the token balance of the ethereum wallet address if any\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    \r\n    // Transfering the token to any ethereum wallet address\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    \r\n    // This generates a public event on the ethereum blockchain for transfer notification\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n\r\n}\r\n// CRYPTXFINANCIALToken contract\r\ncontract CRYPTXFINANCIALToken is Interface, SafeMath {\r\n    string public symbol;\r\n    string public name;\r\n    uint8 public decimals;\r\n    uint public totalSupply;\r\n    address owner;\r\n\r\n    mapping(address => uint) public balanceOf; // this creates an array of all the balances\r\n    mapping (address => bool) public frozenAccount; // this creates an array of all frozen ethereum wallet address\r\n\r\n    event Burn(address indexed from, uint256 value); // This generates a public event on the ethereum blockchain for burn notification\r\n    event FrozenFunds(address target, bool frozen);  // This generates a public event on the ethereum blockchain for freeze notification\r\n\r\n    constructor() public {\r\n        symbol = \"CRYPTX\";\r\n        name = \"CRYPTX FINANCIAL Token\";\r\n        decimals = 18;\r\n        owner = msg.sender; // Assigns the contract depoloyer as the contract owner\r\n        totalSupply = 250000000000000000000000000; // Total number of tokens minted\r\n        balanceOf[0x393869c02e4281144eDa540b35F306686D6DBc5c] = 162500000000000000000000000; // Number of tokens for the crowd sale\r\n        balanceOf[0xd74Ac74CF89B3F4d6B0306fA044a81061E71ba35] = 87500000000000000000000000; // Number of tokens retained \r\n        emit Transfer(address(0), 0x393869c02e4281144eDa540b35F306686D6DBc5c, 162500000000000000000000000);\r\n        emit Transfer(address(0), 0xd74Ac74CF89B3F4d6B0306fA044a81061E71ba35, 87500000000000000000000000);\r\n    }\r\n\r\n    // Shows the total supply of token on the ethereum blockchain\r\n    function Supply() public constant returns (uint) {\r\n        return totalSupply  - balanceOf[address(0)]; // totalSupply excluding the burnt tokens\r\n    }\r\n\r\n    // Shows the token balance of the ethereum wallet address if any \r\n    function balanceOf(address tokenOwner) public constant returns (uint balance) {\r\n        return balanceOf[tokenOwner];  // ethereum wallet address is passed as argument\r\n    }\r\n\r\n    // Transfering the token to any ERC20 wallet address\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        require(to != 0x0); // Use burn function to do this \r\n        require(tokens > 0); // No 0 value transactions allowed\r\n        require(!frozenAccount[msg.sender]); // Cannot send from a frozen wallet address\r\n        require(!frozenAccount[to]); // Cannot send to a frozen wallet address\r\n        require(balanceOf[msg.sender] >= tokens); // Check if enough balance is there from the sender\r\n        require(safeAdd(balanceOf[to], tokens) > balanceOf[to]); // Cannot send 0 tokens\r\n        uint256 previousBalances = safeAdd(balanceOf[msg.sender], balanceOf[to]); \r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], tokens); // Subract tokens from the sender wallet address\r\n        balanceOf[to] = safeAdd(balanceOf[to], tokens); // Add the tokens to receiver wallet address\r\n        emit Transfer(msg.sender, to, tokens); \r\n        require(balanceOf[msg.sender] + balanceOf[to] == previousBalances); // Checks intergrity of the Transfer\r\n        return true; // Transfer done\r\n    }\r\n\r\n    // Not allowing a particular ethereum wallet address to send or receive tokens in case of blacklisting reactively\r\n    function freezeAccount(address target, bool freeze)  public {\r\n        require(msg.sender == owner); // Only the contract owner can freeze an ethereum wallet\r\n        frozenAccount[target] = freeze; // Freezes the target ethereum wallet\r\n        emit FrozenFunds(target, freeze); \r\n    }\r\n\r\n    // Makes the token unusable\r\n     function burn(uint256 amount) public returns (bool success) {\r\n        require(balanceOf[msg.sender] >= amount); // Checks if the particular ethereum wallet address has enough tokens to Burn\r\n        balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], amount); // Subract the tokens to be burnt from the user ethereum wallet address\r\n        totalSupply = safeSub(totalSupply, amount); // Subract the tokens burnt from the total Supply\r\n        emit Burn(msg.sender, amount); \r\n        return true; // tokens burnt successfully\r\n    }\r\n\r\n    // Cannot accept ethereum \r\n    //Please dont send ethereum to this contract address\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeSub\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeDiv\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeMul\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"},{\"name\":\"b\",\"type\":\"uint256\"}],\"name\":\"safeAdd\",\"outputs\":[{\"name\":\"c\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Supply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"CRYPTXFINANCIALToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7d05a125fa20154a3f0a0a5f01625e789c392ff0f41126dbdc45273034ef9d06"}]}