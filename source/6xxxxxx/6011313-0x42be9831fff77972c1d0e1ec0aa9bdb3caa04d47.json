{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// 22.07.18\r\n\r\n\r\n//*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\r\n//\r\n//  Ethertote token contract\r\n//\r\n//  (parts of the token contract\r\n//  are based on the 'MiniMeToken' - Jordi Baylina)\r\n//\r\n//  Fully ERC20 Compliant token\r\n//\r\n//  Name:            Ethertote\r\n//  Symbol:          TOTE\r\n//  Decimals:        0\r\n//  Total supply:    10000000 (10 million tokens)\r\n//\r\n//*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/*/\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// TokenController contract is called when `_owner` sends ether to the \r\n// Ethertote Token contract\r\n// ----------------------------------------------------------------------------\r\ncontract TokenController {\r\n\r\n    function proxyPayments(address _owner) public payable returns(bool);\r\n    function onTransfer(address _from, address _to, uint _amount) public returns(bool);\r\n    function onApprove(address _owner, address _spender, uint _amount) public returns(bool);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ApproveAndCallFallBack\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// The main EthertoteToken contract, the default controller is the msg.sender\r\n// that deploys the contract\r\n// ----------------------------------------------------------------------------\r\ncontract EthertoteToken {\r\n\r\n    // Variables to ensure contract is conforming to ERC220\r\n    string public name;                \r\n    uint8 public decimals;             \r\n    string public symbol;              \r\n    uint public _totalSupply;\r\n    \r\n    // Addtional variables \r\n    string public version; \r\n    address public contractOwner;\r\n    address public thisContractAddress;\r\n    address public EthertoteAdminAddress;\r\n    \r\n    bool public tokenGenerationLock;            // ensure tokens can only be minted once\r\n    \r\n    // the controller takes full control of the contract\r\n    address public controller;\r\n    \r\n    // null address which will be assigned as controller for security purposes\r\n    address public relinquishOwnershipAddress = 0x0000000000000000000000000000000000000000;\r\n    \r\n    \r\n    // Modifier to ensure generateTokens() is only ran once by the constructor\r\n    modifier onlyController { \r\n        require(\r\n            msg.sender == controller\r\n            ); \r\n            _; \r\n    }\r\n    \r\n    \r\n    modifier onlyContract { \r\n        require(\r\n            address(this) == thisContractAddress\r\n            \r\n        ); \r\n        _; \r\n    }\r\n    \r\n    \r\n    modifier EthertoteAdmin { \r\n        require(\r\n            msg.sender == EthertoteAdminAddress\r\n            \r\n        ); \r\n        _; \r\n    }\r\n\r\n\r\n    // Checkpoint is the struct that attaches a block number to a\r\n    // given value, and the block number attached is the one that last changed the\r\n    // value\r\n    struct  Checkpoint {\r\n        uint128 fromBlock;\r\n        uint128 value;\r\n    }\r\n\r\n    // parentToken will be 0x0 for the token unless cloned\r\n    EthertoteToken private parentToken;\r\n\r\n    // parentSnapShotBlock is the block number from the Parent Token which will\r\n    // be 0x0 unless cloned\r\n    uint private parentSnapShotBlock;\r\n\r\n    // creationBlock is the 'genesis' block number when contract is deployed\r\n    uint public creationBlock;\r\n\r\n    // balances is the mapping which tracks the balance of each address\r\n    mapping (address => Checkpoint[]) balances;\r\n\r\n    // allowed is the mapping which tracks any extra transfer rights \r\n    // as per ERC20 token standards\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    // Checkpoint array tracks the history of the totalSupply of the token\r\n    Checkpoint[] totalSupplyHistory;\r\n\r\n    // needs to be set to 'true' to allow tokens to be transferred\r\n    bool public transfersEnabled;\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Constructor function initiated automatically when contract is deployed\r\n// ----------------------------------------------------------------------------\r\n    constructor() public {\r\n        \r\n        controller = msg.sender;\r\n        EthertoteAdminAddress = msg.sender;\r\n        tokenGenerationLock = false;\r\n        \r\n    // --------------------------------------------------------------------\r\n    // set the following values prior to deployment\r\n    // --------------------------------------------------------------------\r\n    \r\n        name = \"Ethertote\";                                   // Set the name\r\n        symbol = \"TOTE\";                                 // Set the symbol\r\n        decimals = 0;                                       // Set the decimals\r\n        _totalSupply = 10000000 * 10**uint(decimals);       // 10,000,000 tokens\r\n        \r\n        version = \"Ethertote Token contract - version 1.0\";\r\n    \r\n    //---------------------------------------------------------------------\r\n\r\n        // Additional variables set by the constructor\r\n        contractOwner = msg.sender;\r\n        thisContractAddress = address(this);\r\n\r\n        transfersEnabled = true;                            // allows tokens to be traded\r\n        \r\n        creationBlock = block.number;                       // sets the genesis block\r\n\r\n\r\n        // Now call the internal generateTokens function to create the tokens \r\n        // and send them to owner\r\n        generateTokens(contractOwner, _totalSupply);\r\n        \r\n        // Now that the tokens have been generated, finally reliquish \r\n        // ownership of the token contract for security purposes\r\n        controller = relinquishOwnershipAddress;\r\n    }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface Methods for full compliance\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n// ----------------------------------------------------------------------------\r\n\r\n    // totalSupply //\r\n    function totalSupply() public constant returns (uint) {\r\n        return totalSupplyAt(block.number);\r\n    }\r\n    \r\n    // balanceOf //\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balanceOfAt(_owner, block.number);\r\n    }\r\n\r\n    // allowance //\r\n    function allowance(address _owner, address _spender\r\n    ) public constant returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    // transfer //\r\n    function transfer(address _to, uint256 _amount\r\n    ) public returns (bool success) {\r\n        \r\n        require(transfersEnabled);\r\n        \r\n        // prevent tokens from ever being sent back to the contract address \r\n        require(_to != address(this) );\r\n        // prevent tokens from ever accidentally being sent to the nul (0x0) address\r\n        require(_to != 0x0);\r\n        doTransfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    // approve //\r\n    function approve(address _spender, uint256 _amount) public returns (bool success) {\r\n        require(transfersEnabled);\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        if (isContract(controller)) {\r\n            require(TokenController(controller).onApprove(msg.sender, _spender, _amount));\r\n        }\r\n\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n    // transferFrom\r\n    function transferFrom(address _from, address _to, uint256 _amount\r\n    ) public returns (bool success) {\r\n        \r\n        // prevent tokens from ever being sent back to the contract address \r\n        require(_to != address(this) );\r\n        // prevent tokens from ever accidentally being sent to the nul (0x0) address\r\n        require(_to != 0x0);\r\n        \r\n        if (msg.sender != controller) {\r\n            require(transfersEnabled);\r\n\r\n            require(allowed[_from][msg.sender] >= _amount);\r\n            allowed[_from][msg.sender] -= _amount;\r\n        }\r\n        doTransfer(_from, _to, _amount);\r\n        return true;\r\n    }\r\n    \r\n// ----------------------------------------------------------------------------\r\n//  ERC20 compliant events\r\n// ----------------------------------------------------------------------------\r\n\r\n    event Transfer(\r\n        address indexed _from, address indexed _to, uint256 _amount\r\n        );\r\n    \r\n    event Approval(\r\n        address indexed _owner, address indexed _spender, uint256 _amount\r\n        );\r\n\r\n// ----------------------------------------------------------------------------\r\n\r\n    // once constructor assigns control to 0x0 the contract cannot be changed\r\n    function changeController(address _newController) onlyController private {\r\n        controller = _newController;\r\n    }\r\n    \r\n    function doTransfer(address _from, address _to, uint _amount) internal {\r\n\r\n           if (_amount == 0) {\r\n               emit Transfer(_from, _to, _amount); \r\n               return;\r\n           }\r\n\r\n           require(parentSnapShotBlock < block.number);\r\n\r\n           // Do not allow transfer to 0x0 or the token contract itself\r\n           // require((_to != 0) && (_to != address(this)));\r\n           \r\n           require(_to != address(this));\r\n           \r\n           \r\n\r\n           // If the amount being transfered is more than the balance of the\r\n           //  account, the transfer throws\r\n           uint previousBalanceFrom = balanceOfAt(_from, block.number);\r\n           require(previousBalanceFrom >= _amount);\r\n\r\n           // Alerts the token controller of the transfer\r\n           if (isContract(controller)) {\r\n               require(TokenController(controller).onTransfer(_from, _to, _amount));\r\n           }\r\n\r\n           // First update the balance array with the new value for the address\r\n           //  sending the tokens\r\n           updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\r\n\r\n           // Then update the balance array with the new value for the address\r\n           //  receiving the tokens\r\n           uint previousBalanceTo = balanceOfAt(_to, block.number);\r\n           \r\n           // Check for overflow\r\n           require(previousBalanceTo + _amount >= previousBalanceTo); \r\n           updateValueAtNow(balances[_to], previousBalanceTo + _amount);\r\n\r\n           // An event to make the transfer easy to find on the blockchain\r\n           emit Transfer(_from, _to, _amount);\r\n\r\n    }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// approveAndCall allows users to use their tokens to interact with contracts\r\n// in a single function call\r\n// msg.sender approves `_spender` to send an `_amount` of tokens on\r\n// its behalf, and then a function is triggered in the contract that is\r\n// being approved, `_spender`. This allows users to use their tokens to\r\n// interact with contracts in one function call instead of two\r\n    \r\n// _spender is the address of the contract able to transfer the tokens\r\n// _amount is the amount of tokens to be approved for transfer\r\n// return 'true' if the function call was successful\r\n// ----------------------------------------------------------------------------    \r\n    function approveAndCall(address _spender, uint256 _amount, bytes _extraData\r\n    ) public returns (bool success) {\r\n        require(approve(_spender, _amount));\r\n\r\n        ApproveAndCallFallBack(_spender).receiveApproval(\r\n            msg.sender,\r\n            _amount,\r\n            this,\r\n            _extraData\r\n        );\r\n        return true;\r\n    }\r\n\r\n\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Query the balance of an address at a specific block number\r\n// ----------------------------------------------------------------------------\r\n    function balanceOfAt(address _owner, uint _blockNumber) public constant\r\n        returns (uint) {\r\n\r\n        if ((balances[_owner].length == 0)\r\n            || (balances[_owner][0].fromBlock > _blockNumber)) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        } \r\n        \r\n        else {\r\n            return getValueAt(balances[_owner], _blockNumber);\r\n        }\r\n    }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Queries the total supply of tokens at a specific block number\r\n// will return 0 if called before the creationBlock value\r\n// ----------------------------------------------------------------------------\r\n    function totalSupplyAt(uint _blockNumber) public constant returns(uint) {\r\n        if (\r\n            (totalSupplyHistory.length == 0) ||\r\n            (totalSupplyHistory[0].fromBlock > _blockNumber)\r\n            ) {\r\n            if (address(parentToken) != 0) {\r\n                return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\r\n            } else {\r\n                return 0;\r\n            }\r\n\r\n        } \r\n        else {\r\n            return getValueAt(totalSupplyHistory, _blockNumber);\r\n        }\r\n    }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// The generateTokens function will generate the initial supply of tokens\r\n// Can only be called once during the constructor as it has the onlyContract\r\n// modifier attached to the function\r\n// ----------------------------------------------------------------------------\r\n    function generateTokens(address _owner, uint _theTotalSupply) \r\n    private onlyContract returns (bool) {\r\n        require(tokenGenerationLock == false);\r\n        uint curTotalSupply = totalSupply();\r\n        require(curTotalSupply + _theTotalSupply >= curTotalSupply); // Check for overflow\r\n        uint previousBalanceTo = balanceOf(_owner);\r\n        require(previousBalanceTo + _totalSupply >= previousBalanceTo); // Check for overflow\r\n        updateValueAtNow(totalSupplyHistory, curTotalSupply + _totalSupply);\r\n        updateValueAtNow(balances[_owner], previousBalanceTo + _totalSupply);\r\n        emit Transfer(0, _owner, _totalSupply);\r\n        tokenGenerationLock = true;\r\n        return true;\r\n    }\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Enable tokens transfers to allow tokens to be traded\r\n// ----------------------------------------------------------------------------\r\n\r\n    function enableTransfers(bool _transfersEnabled) private onlyController {\r\n        transfersEnabled = _transfersEnabled;\r\n    }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Internal helper functions\r\n// ----------------------------------------------------------------------------\r\n\r\n    function getValueAt(Checkpoint[] storage checkpoints, uint _block\r\n    ) constant internal returns (uint) {\r\n        if (checkpoints.length == 0) return 0;\r\n\r\n        if (_block >= checkpoints[checkpoints.length-1].fromBlock)\r\n            return checkpoints[checkpoints.length-1].value;\r\n        if (_block < checkpoints[0].fromBlock) return 0;\r\n\r\n        // Binary search of the value in the array\r\n        uint min = 0;\r\n        uint max = checkpoints.length-1;\r\n        while (max > min) {\r\n            uint mid = (max + min + 1)/ 2;\r\n            if (checkpoints[mid].fromBlock<=_block) {\r\n                min = mid;\r\n            } else {\r\n                max = mid-1;\r\n            }\r\n        }\r\n        return checkpoints[min].value;\r\n    }\r\n\r\n// ----------------------------------------------------------------------------\r\n// function used to update the `balances` map and the `totalSupplyHistory`\r\n// ----------------------------------------------------------------------------\r\n    function updateValueAtNow(Checkpoint[] storage checkpoints, uint _value\r\n    ) internal  {\r\n        if ((checkpoints.length == 0)\r\n        || (checkpoints[checkpoints.length -1].fromBlock < block.number)) {\r\n               Checkpoint storage newCheckPoint = checkpoints[ checkpoints.length++ ];\r\n               newCheckPoint.fromBlock =  uint128(block.number);\r\n               newCheckPoint.value = uint128(_value);\r\n           } else {\r\n               Checkpoint storage oldCheckPoint = checkpoints[checkpoints.length-1];\r\n               oldCheckPoint.value = uint128(_value);\r\n           }\r\n    }\r\n\r\n// ----------------------------------------------------------------------------\r\n// function to check if address is a contract\r\n// ----------------------------------------------------------------------------\r\n    function isContract(address _addr) constant internal returns(bool) {\r\n        uint size;\r\n        if (_addr == 0) return false;\r\n        assembly {\r\n            size := extcodesize(_addr)\r\n        }\r\n        return size>0;\r\n    }\r\n\r\n// ----------------------------------------------------------------------------\r\n// Helper function to return a min betwen the two uints\r\n// ----------------------------------------------------------------------------\r\n    function min(uint a, uint b) pure internal returns (uint) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n// ----------------------------------------------------------------------------\r\n// fallback function: If the contract's controller has not been set to 0, \r\n// then the `proxyPayment` method is called which relays the eth and creates \r\n// tokens as described in the token controller contract\r\n// ----------------------------------------------------------------------------\r\n    function () public payable {\r\n        require(isContract(controller));\r\n        require(\r\n            TokenController(controller).proxyPayments.value(msg.value)(msg.sender)\r\n            );\r\n    }\r\n\r\n\r\n    event ClaimedTokens(\r\n        address indexed _token, address indexed _controller, uint _amount\r\n        );\r\n\r\n// ----------------------------------------------------------------------------\r\n// This method can be used by the controller to extract other tokens accidentally \r\n// sent to this contract.\r\n// _token is the address of the token contract to recover\r\n//  can be set to 0 to extract eth\r\n// ----------------------------------------------------------------------------\r\n    function withdrawOtherTokens(address _token) EthertoteAdmin public {\r\n        if (_token == 0x0) {\r\n            controller.transfer(address(this).balance);\r\n            return;\r\n        }\r\n        EthertoteToken token = EthertoteToken(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(controller, balance);\r\n        emit ClaimedTokens(_token, controller, balance);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"creationBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"thisContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"balanceOfAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relinquishOwnershipAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EthertoteAdminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"totalSupplyAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"withdrawOtherTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenGenerationLock\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ClaimedTokens\",\"type\":\"event\"}]","ContractName":"EthertoteToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e3ad4c5e9c5666834e79684c2968772453ec3be759c9db1a6e9bf1fddbb5ae40"}]}