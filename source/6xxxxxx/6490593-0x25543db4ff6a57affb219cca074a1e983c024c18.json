{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\n/// Code for ERC20+alpha token\r\n/// @author A. Vidovic\r\ncontract EPCToken {\r\n    string public name = 'Earth Power Coin';    //fancy name\r\n    uint8 public decimals = 18;                 //How many decimals to show. It's like comparing 1 wei to 1 ether.\r\n    string public symbol = 'EPC';               //Identifier\r\n    string public version = '1.3';\r\n\r\n    uint256 weisPerEth = 1000000000000000000;\r\n    /// total amount of tokens\r\n    uint256 public totalSupply = 20000000000 * weisPerEth;\r\n    uint256 public tokenWeisPerEth = 25000 * 1000000000000000000;  // 1 ETH = 0.00004 EPC\r\n    address owner0;     // just in case an owner change would be mistaken\r\n    address owner;\r\n    uint256 public saleCap = 2000000000 * weisPerEth;\r\n    uint256 public notAttributed = totalSupply - saleCap;\r\n\r\n    constructor(\r\n        uint256 _initialAmount,\r\n        uint256 _saleCap,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _decimalUnits\r\n        ) public {\r\n        totalSupply = _initialAmount * weisPerEth;           // Update total supply\r\n        saleCap = _saleCap * weisPerEth;\r\n        notAttributed = totalSupply - saleCap;               // saleCap is an attributed amount\r\n        name = _tokenName;                                   // Set the name for display purposes\r\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\r\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\r\n\r\n        owner0 = msg.sender;\r\n        owner = msg.sender;\r\n        \r\n        balances[owner] = 100 * weisPerEth;                  // initial allocation for test purposes\r\n        notAttributed -= balances[owner];\r\n        emit Transfer(0, owner, balances[owner]);\r\n    }\r\n    \r\n    modifier ownerOnly {\r\n        require(owner == msg.sender || owner0 == msg.sender);\r\n        _;\r\n    }\r\n\r\n    function setOwner(address _newOwner) public ownerOnly {\r\n        if (owner0 == 0) {\r\n            if (owner == 0) {\r\n                owner0 = _newOwner;\r\n            } else {\r\n                owner0 = owner;\r\n            }\r\n        }\r\n        owner = _newOwner;\r\n    }\r\n    \r\n    function addToTotalSupply(uint256 _delta) public ownerOnly returns (uint256 availableAmount) {\r\n        totalSupply += _delta * weisPerEth;\r\n        notAttributed += _delta * weisPerEth;\r\n        return notAttributed;\r\n    }\r\n    \r\n    function withdraw() public ownerOnly {\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n    function setSaleCap(uint256 _saleCap) public ownerOnly returns (uint256 toBeSold) {\r\n        notAttributed += saleCap;           // restore remaining previous saleCap to notAttributed pool\r\n        saleCap = _saleCap * weisPerEth;\r\n        if (saleCap > notAttributed) {      // not oversold amount \r\n            saleCap = notAttributed;\r\n        }\r\n        notAttributed -= saleCap;           // attribute this new cap\r\n        return saleCap;\r\n    }\r\n    \r\n    bool public onSaleFlag = false;\r\n    \r\n    function setSaleFlag(bool _saleFlag) public ownerOnly {\r\n        onSaleFlag = _saleFlag;\r\n    }\r\n    \r\n    bool public useWhitelistFlag = false;\r\n    \r\n    function setUseWhitelistFlag(bool _useWhitelistFlag) public ownerOnly {\r\n        useWhitelistFlag = _useWhitelistFlag;\r\n    }\r\n    \r\n    function calcTokenSold(uint256 _ethValue) public view returns (uint256 tokenValue) {\r\n        return _ethValue * tokenWeisPerEth / weisPerEth;\r\n    }\r\n    \r\n    uint256 public percentFrozenWhenBought = 75;   // % of tokens you buy that you can't use right away\r\n    uint256 public percentUnfrozenAfterBuyPerPeriod = 25;  //  % of bought tokens you get to use after each period\r\n    uint public buyUnfreezePeriodSeconds = 30 * 24 * 3600;  // aforementioned period\r\n    \r\n    function setPercentFrozenWhenBought(uint256 _percentFrozenWhenBought) public ownerOnly {\r\n        percentFrozenWhenBought = _percentFrozenWhenBought;\r\n    }\r\n    \r\n    function setPercentUnfrozenAfterBuyPerPeriod(uint256 _percentUnfrozenAfterBuyPerPeriod) public ownerOnly {\r\n        percentUnfrozenAfterBuyPerPeriod = _percentUnfrozenAfterBuyPerPeriod;\r\n    }\r\n    \r\n    function setBuyUnfreezePeriodSeconds(uint _buyUnfreezePeriodSeconds) public ownerOnly {\r\n        buyUnfreezePeriodSeconds = _buyUnfreezePeriodSeconds;\r\n    }\r\n    \r\n    function buy() payable public {\r\n        if (useWhitelistFlag) {\r\n            if (!isWhitelist(msg.sender)) {\r\n                emit NotWhitelisted(msg.sender);\r\n                revert();\r\n            }\r\n        }\r\n        if (saleCap>0) {\r\n            uint256 tokens = calcTokenSold(msg.value);\r\n            if (tokens<=saleCap) {\r\n                if (tokens > 0) { \r\n                    lastUnfrozenTimestamps[msg.sender] = block.timestamp;\r\n                    boughtTokens[msg.sender] += tokens;\r\n                    frozenTokens[msg.sender] += tokens * percentFrozenWhenBought / 100;\r\n                    balances[msg.sender] += tokens * ( 100 - percentFrozenWhenBought) / 100;\r\n                    saleCap -= tokens;\r\n                    emit Transfer(0, msg.sender, tokens);\r\n                } else {\r\n                    revert();\r\n                }\r\n            } else {\r\n                emit NotEnoughTokensLeftForSale(saleCap);\r\n                revert();\r\n            }\r\n        } else {\r\n            emit NotEnoughTokensLeftForSale(saleCap);\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function () payable public {\r\n        //if ether is sent to this address and token sale is not ON, send it back.\r\n        if (!onSaleFlag) {\r\n            revert();\r\n        } else {\r\n            buy();\r\n        }\r\n    }\r\n    \r\n    mapping (address => uint256) public boughtTokens;  // there is some kind of lockup even for those who bought tokens\r\n    mapping (address => uint) public lastUnfrozenTimestamps;\r\n    mapping (address => uint256) public frozenTokens;\r\n    \r\n    uint256 public percentFrozenWhenAwarded = 100;   // % of tokens you are awarded that you can't use right away\r\n    uint256 public percentUnfrozenAfterAwardedPerPeriod = 25;  //  % of bought tokens you get to use after each period\r\n    uint public awardedInitialWaitSeconds = 6 * 30 * 24 * 3600;  // initial waiting period for hodlers\r\n    uint public awardedUnfreezePeriodSeconds = 30 * 24 * 3600;  // aforementioned period\r\n    \r\n    function setPercentFrozenWhenAwarded(uint256 _percentFrozenWhenAwarded) public ownerOnly {\r\n        percentFrozenWhenAwarded = _percentFrozenWhenAwarded;\r\n    }\r\n    \r\n    function setPercentUnfrozenAfterAwardedPerPeriod(uint256 _percentUnfrozenAfterAwardedPerPeriod) public ownerOnly {\r\n        percentUnfrozenAfterAwardedPerPeriod = _percentUnfrozenAfterAwardedPerPeriod;\r\n    }\r\n    \r\n    function setAwardedInitialWaitSeconds(uint _awardedInitialWaitSeconds) public ownerOnly {\r\n        awardedInitialWaitSeconds = _awardedInitialWaitSeconds;\r\n    }\r\n    \r\n    function setAwardedUnfreezePeriodSeconds(uint _awardedUnfreezePeriodSeconds) public ownerOnly {\r\n        awardedUnfreezePeriodSeconds = _awardedUnfreezePeriodSeconds;\r\n    }\r\n    \r\n    function award(address _to, uint256 _nbTokens) public ownerOnly {\r\n        if (notAttributed>0) {\r\n            uint256 tokens = _nbTokens * weisPerEth;\r\n            if (tokens<=notAttributed) {\r\n                if (tokens > 0) {\r\n                    awardedTimestamps[_to] = block.timestamp;\r\n                    awardedTokens[_to] += tokens;\r\n                    frozenAwardedTokens[_to] += tokens * percentFrozenWhenAwarded / 100;\r\n                    balances[_to] += tokens * ( 100 - percentFrozenWhenAwarded) / 100;\r\n                    notAttributed -= tokens;\r\n                    emit Transfer(0, _to, tokens);\r\n                }\r\n            } else {\r\n                emit NotEnoughTokensLeft(notAttributed);\r\n            }\r\n        } else {\r\n            emit NotEnoughTokensLeft(notAttributed);\r\n        }\r\n    }\r\n    \r\n    mapping (address => uint256) public awardedTokens;\r\n    mapping (address => uint) public awardedTimestamps;\r\n    mapping (address => uint) public lastUnfrozenAwardedTimestamps;\r\n    mapping (address => uint256) public frozenAwardedTokens;\r\n    \r\n    /// transfer tokens from unattributed pool without any lockup (e.g. for human sale)\r\n    function grant(address _to, uint256 _nbTokens) public ownerOnly {\r\n        if (notAttributed>0) {\r\n            uint256 tokens = _nbTokens * weisPerEth;\r\n            if (tokens<=notAttributed) {\r\n                if (tokens > 0) {\r\n                    balances[_to] += tokens;\r\n                    notAttributed -= tokens;\r\n                    emit Transfer(0, _to, tokens);\r\n                }\r\n            } else {\r\n                emit NotEnoughTokensLeft(notAttributed);\r\n            }\r\n        } else {\r\n            emit NotEnoughTokensLeft(notAttributed);\r\n        }\r\n    }\r\n    \r\n    function setWhitelist(address _addr, bool _wlStatus) public ownerOnly {\r\n        whitelist[_addr] = _wlStatus;\r\n    }\r\n    \r\n    function isWhitelist(address _addr) public view returns (bool isWhitelisted) {\r\n        return whitelist[_addr]==true;\r\n    }\r\n    \r\n    mapping (address => bool) public whitelist;\r\n    \r\n    function setSaleAddr(address _addr, bool _saleStatus) public ownerOnly {\r\n        saleAddrs[_addr] = _saleStatus;\r\n    }\r\n    \r\n    function isSaleAddr(address _addr) public view returns (bool isASaleAddr) {\r\n        return saleAddrs[_addr]==true;\r\n    }\r\n    \r\n    mapping (address => bool) public saleAddrs;            // marks sale addresses : transfer recipients from those addresses are subjected to buy lockout rules\r\n    \r\n    bool public manualSaleFlag = false;\r\n    \r\n    function setManualSaleFlag(bool _manualSaleFlag) public ownerOnly {\r\n        manualSaleFlag = _manualSaleFlag;\r\n    }\r\n    \r\n    mapping (address => uint256) public balances;      // available on hand\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n    \r\n\r\n    function setBlockedAccount(address _addr, bool _blockedStatus) public ownerOnly {\r\n        blockedAccounts[_addr] = _blockedStatus;\r\n    }\r\n    \r\n    function isBlockedAccount(address _addr) public view returns (bool isAccountBlocked) {\r\n        return blockedAccounts[_addr]==true;\r\n    }\r\n    \r\n    mapping (address => bool) public blockedAccounts;  // mechanism allowing to stop thieves from profiting\r\n    \r\n    /// Used to empty blocked accounts of stolen tokens and return them to rightful owners\r\n    function moveTokens(address _from, address _to, uint256 _amount) public ownerOnly  returns (bool success) {\r\n        if (_amount>0 && balances[_from] >= _amount) {\r\n            balances[_from] -= _amount;\r\n            balances[_to] += _amount;\r\n            emit Transfer(_from, _to, _amount);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    \r\n    function unfreezeBoughtTokens(address _owner) public {\r\n        if (frozenTokens[_owner] > 0) {\r\n            uint elapsed = block.timestamp - lastUnfrozenTimestamps[_owner];\r\n            if (elapsed > buyUnfreezePeriodSeconds) {\r\n                uint256 tokensToUnfreeze = boughtTokens[_owner] * percentUnfrozenAfterBuyPerPeriod / 100;\r\n                if (tokensToUnfreeze > frozenTokens[_owner]) {\r\n                    tokensToUnfreeze = frozenTokens[_owner];\r\n                }\r\n                balances[_owner] += tokensToUnfreeze;\r\n                frozenTokens[_owner] -= tokensToUnfreeze;\r\n                lastUnfrozenTimestamps[_owner] = block.timestamp;\r\n            }\r\n        } \r\n    }\r\n\r\n    function unfreezeAwardedTokens(address _owner) public {\r\n        if (frozenAwardedTokens[_owner] > 0) {\r\n            uint elapsed = 0;\r\n            uint waitTime = awardedInitialWaitSeconds;\r\n            if (lastUnfrozenAwardedTimestamps[_owner]<=0) {\r\n                elapsed = block.timestamp - awardedTimestamps[_owner];\r\n            } else {\r\n                elapsed = block.timestamp - lastUnfrozenAwardedTimestamps[_owner];\r\n                waitTime = awardedUnfreezePeriodSeconds;\r\n            }\r\n            if (elapsed > waitTime) {\r\n                uint256 tokensToUnfreeze = awardedTokens[_owner] * percentUnfrozenAfterAwardedPerPeriod / 100;\r\n                if (tokensToUnfreeze > frozenAwardedTokens[_owner]) {\r\n                    tokensToUnfreeze = frozenAwardedTokens[_owner];\r\n                }\r\n                balances[_owner] += tokensToUnfreeze;\r\n                frozenAwardedTokens[_owner] -= tokensToUnfreeze;\r\n                lastUnfrozenAwardedTimestamps[_owner] = block.timestamp;\r\n            }\r\n        } \r\n    }\r\n    \r\n    function unfreezeTokens(address _owner) public returns (uint256 frozenAmount) {\r\n        unfreezeBoughtTokens(_owner);\r\n        unfreezeAwardedTokens(_owner);\r\n        return frozenTokens[_owner] + frozenAwardedTokens[_owner];\r\n    }\r\n\r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) public returns (uint256 balance) {\r\n        unfreezeTokens(_owner);\r\n        return balances[_owner];\r\n    }\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        //Default assumes totalSupply can't be over max (2^256 - 1).\r\n        //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.\r\n        //Replace the if with this one instead.\r\n        //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (!isBlockedAccount(msg.sender) && (balanceOf(msg.sender) >= _value && _value > 0)) {\r\n            if (isSaleAddr(msg.sender)) {\r\n                if (manualSaleFlag) {\r\n                    boughtTokens[_to] += _value;\r\n                    lastUnfrozenTimestamps[_to] = block.timestamp;\r\n                    frozenTokens[_to] += _value * percentFrozenWhenBought / 100;\r\n                    balances[_to] += _value * ( 100 - percentFrozenWhenBought) / 100;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                balances[_to] += _value;\r\n            }\r\n            balances[msg.sender] -= _value;\r\n            emit Transfer(msg.sender, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false; \r\n        }\r\n    }\r\n\r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\r\n        //same as above. Replace this line with the following if you want to protect against wrapping uints.\r\n        //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\r\n        if (!isBlockedAccount(msg.sender) && (balanceOf(_from) >= _value && allowed[_from][msg.sender] >= _value) && _value > 0) {\r\n            if (isSaleAddr(_from)) {\r\n                if (manualSaleFlag) {\r\n                    boughtTokens[_to] += _value;\r\n                    lastUnfrozenTimestamps[_to] = block.timestamp;\r\n                    frozenTokens[_to] += _value * percentFrozenWhenBought / 100;\r\n                    balances[_to] += _value * ( 100 - percentFrozenWhenBought) / 100;\r\n                } else {\r\n                    return false;\r\n                }\r\n            } else {\r\n                balances[_to] += _value;\r\n            }\r\n            balances[_from] -= _value;\r\n            allowed[_from][msg.sender] -= _value;\r\n            emit Transfer(_from, _to, _value);\r\n            return true;\r\n        } else { \r\n            return false; \r\n        }\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of wei to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n    event NotEnoughTokensLeftForSale(uint256 _tokensLeft);\r\n    event NotEnoughTokensLeft(uint256 _tokensLeft);\r\n    event NotWhitelisted(address _addr);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"manualSaleFlag\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_awardedInitialWaitSeconds\",\"type\":\"uint256\"}],\"name\":\"setAwardedInitialWaitSeconds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"unfreezeAwardedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentFrozenWhenAwarded\",\"type\":\"uint256\"}],\"name\":\"setPercentFrozenWhenAwarded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_awardedUnfreezePeriodSeconds\",\"type\":\"uint256\"}],\"name\":\"setAwardedUnfreezePeriodSeconds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_ethValue\",\"type\":\"uint256\"}],\"name\":\"calcTokenSold\",\"outputs\":[{\"name\":\"tokenValue\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delta\",\"type\":\"uint256\"}],\"name\":\"addToTotalSupply\",\"outputs\":[{\"name\":\"availableAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyUnfreezePeriodSeconds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_useWhitelistFlag\",\"type\":\"bool\"}],\"name\":\"setUseWhitelistFlag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentFrozenWhenBought\",\"type\":\"uint256\"}],\"name\":\"setPercentFrozenWhenBought\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"notAttributed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_wlStatus\",\"type\":\"bool\"}],\"name\":\"setWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_blockedStatus\",\"type\":\"bool\"}],\"name\":\"setBlockedAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_nbTokens\",\"type\":\"uint256\"}],\"name\":\"award\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"awardedInitialWaitSeconds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_nbTokens\",\"type\":\"uint256\"}],\"name\":\"grant\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentUnfrozenAfterAwardedPerPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentFrozenWhenBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"boughtTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"awardedTimestamps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentUnfrozenAfterAwardedPerPeriod\",\"type\":\"uint256\"}],\"name\":\"setPercentUnfrozenAfterAwardedPerPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"unfreezeTokens\",\"outputs\":[{\"name\":\"frozenAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleFlag\",\"type\":\"bool\"}],\"name\":\"setSaleFlag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"saleAddrs\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"awardedUnfreezePeriodSeconds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentUnfrozenAfterBuyPerPeriod\",\"type\":\"uint256\"}],\"name\":\"setPercentUnfrozenAfterBuyPerPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manualSaleFlag\",\"type\":\"bool\"}],\"name\":\"setManualSaleFlag\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"awardedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isSaleAddr\",\"outputs\":[{\"name\":\"isASaleAddr\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_saleStatus\",\"type\":\"bool\"}],\"name\":\"setSaleAddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAwardedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenWeisPerEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"useWhitelistFlag\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isWhitelist\",\"outputs\":[{\"name\":\"isWhitelisted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleCap\",\"type\":\"uint256\"}],\"name\":\"setSaleCap\",\"outputs\":[{\"name\":\"toBeSold\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastUnfrozenAwardedTimestamps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentUnfrozenAfterBuyPerPeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"unfreezeBoughtTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onSaleFlag\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isBlockedAccount\",\"outputs\":[{\"name\":\"isAccountBlocked\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percentFrozenWhenAwarded\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastUnfrozenTimestamps\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyUnfreezePeriodSeconds\",\"type\":\"uint256\"}],\"name\":\"setBuyUnfreezePeriodSeconds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockedAccounts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"name\":\"_saleCap\",\"type\":\"uint256\"},{\"name\":\"_tokenName\",\"type\":\"string\"},{\"name\":\"_tokenSymbol\",\"type\":\"string\"},{\"name\":\"_decimalUnits\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokensLeft\",\"type\":\"uint256\"}],\"name\":\"NotEnoughTokensLeftForSale\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokensLeft\",\"type\":\"uint256\"}],\"name\":\"NotEnoughTokensLeft\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"NotWhitelisted\",\"type\":\"event\"}]","ContractName":"EPCToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000004a817c800000000000000000000000000000000000000000000000000000000007735940000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000e000000000000000000000000000000000000000000000000000000000000000120000000000000000000000000000000000000000000000000000000000000010456172746820506f77657220436f696e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000034550430000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://d83caa65dd6d80c448962ad69f7beb06febdfbd40c0b1930fd826ee1d94a7bc2"}]}