{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Signature verifier\r\n * @dev To verify C level actions\r\n */\r\ncontract SignatureVerifier {\r\n\r\n    function splitSignature(bytes sig)\r\n    internal\r\n    pure\r\n    returns (uint8, bytes32, bytes32)\r\n    {\r\n        require(sig.length == 65);\r\n\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        assembly {\r\n        // first 32 bytes, after the length prefix\r\n            r := mload(add(sig, 32))\r\n        // second 32 bytes\r\n            s := mload(add(sig, 64))\r\n        // final byte (first byte of the next 32 bytes)\r\n            v := byte(0, mload(add(sig, 96)))\r\n        }\r\n        return (v, r, s);\r\n    }\r\n\r\n    // Returns the address that signed a given string message\r\n    function verifyString(\r\n        string message,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n    internal pure\r\n    returns (address signer) {\r\n\r\n        // The message header; we will fill in the length next\r\n        string memory header = \"\\x19Ethereum Signed Message:\\n000000\";\r\n        uint256 lengthOffset;\r\n        uint256 length;\r\n\r\n        assembly {\r\n        // The first word of a string is its length\r\n            length := mload(message)\r\n        // The beginning of the base-10 message length in the prefix\r\n            lengthOffset := add(header, 57)\r\n        }\r\n\r\n        // Maximum length we support\r\n        require(length <= 999999);\r\n        // The length of the message's length in base-10\r\n        uint256 lengthLength = 0;\r\n        // The divisor to get the next left-most message length digit\r\n        uint256 divisor = 100000;\r\n        // Move one digit of the message length to the right at a time\r\n\r\n        while (divisor != 0) {\r\n            // The place value at the divisor\r\n            uint256 digit = length / divisor;\r\n            if (digit == 0) {\r\n                // Skip leading zeros\r\n                if (lengthLength == 0) {\r\n                    divisor /= 10;\r\n                    continue;\r\n                }\r\n            }\r\n            // Found a non-zero digit or non-leading zero digit\r\n            lengthLength++;\r\n            // Remove this digit from the message length's current value\r\n            length -= digit * divisor;\r\n            // Shift our base-10 divisor over\r\n            divisor /= 10;\r\n\r\n            // Convert the digit to its ASCII representation (man ascii)\r\n            digit += 0x30;\r\n            // Move to the next character and write the digit\r\n            lengthOffset++;\r\n            assembly {\r\n                mstore8(lengthOffset, digit)\r\n            }\r\n        }\r\n        // The null string requires exactly 1 zero (unskip 1 leading 0)\r\n        if (lengthLength == 0) {\r\n            lengthLength = 1 + 0x19 + 1;\r\n        } else {\r\n            lengthLength += 1 + 0x19;\r\n        }\r\n        // Truncate the tailing zeros from the header\r\n        assembly {\r\n            mstore(header, lengthLength)\r\n        }\r\n        // Perform the elliptic curve recover operation\r\n        bytes32 check = keccak256(header, message);\r\n        return ecrecover(check, v, r, s);\r\n    }\r\n}\r\n\r\n/**\r\n * @title A DEKLA token access control\r\n * @author DEKLA (https://www.dekla.io)\r\n * @dev The Dekla token has 3 C level address to manage.\r\n * They can execute special actions but it need to be approved by another C level address.\r\n */\r\ncontract AccessControl is SignatureVerifier {\r\n    using SafeMath for uint256;\r\n\r\n    // C level address that can execute special actions.\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n    address public systemAddress;\r\n    uint256 public CLevelTxCount_ = 0;\r\n\r\n    // @dev store nonces\r\n    mapping(address => uint256) nonces;\r\n\r\n    // @dev C level transaction must be approved with another C level address\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier onlySystem() {\r\n        require(msg.sender == systemAddress);\r\n        _;\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        //Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n        // Divide the signature in r, s and v variables\r\n        (v, r, s) = splitSignature(sig);\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n            bytes32 prefixedHash = keccak256(prefix, hash);\r\n            return ecrecover(prefixedHash, v, r, s);\r\n        }\r\n    }\r\n\r\n    function signedCLevel(\r\n        bytes32 _message,\r\n        bytes _sig\r\n    )\r\n    internal\r\n    view\r\n    onlyCLevel\r\n    returns (bool)\r\n    {\r\n        address signer = recover(_message, _sig);\r\n\r\n        require(signer != msg.sender);\r\n        return (\r\n        signer == cooAddress ||\r\n        signer == ceoAddress ||\r\n        signer == cfoAddress\r\n        );\r\n    }\r\n\r\n    event addressLogger(address signer);\r\n\r\n    /**\r\n     * @notice Hash (keccak256) of the payload used by setCEO\r\n     * @param _newCEO address The address of the new CEO\r\n     * @param _nonce uint256 setCEO transaction number.\r\n     */\r\n    function getCEOHashing(address _newCEO, uint256 _nonce) public pure returns (bytes32) {\r\n        return keccak256(bytes4(0x486A0F3E), _newCEO, _nonce);\r\n    }\r\n\r\n    // @dev Assigns a new address to act as the CEO. The C level transaction, must verify.\r\n    // @param _newCEO The address of the new CEO\r\n    function setCEO(\r\n        address _newCEO,\r\n        bytes _sig\r\n    ) external onlyCLevel {\r\n        require(\r\n            _newCEO != address(0) &&\r\n            _newCEO != cfoAddress &&\r\n            _newCEO != cooAddress\r\n        );\r\n\r\n        bytes32 hashedTx = getCEOHashing(_newCEO, nonces[msg.sender]);\r\n        require(signedCLevel(hashedTx, _sig));\r\n        nonces[msg.sender]++;\r\n\r\n        ceoAddress = _newCEO;\r\n        CLevelTxCount_++;\r\n    }\r\n\r\n    /**\r\n     * @notice Hash (keccak256) of the payload used by setCFO\r\n     * @param _newCFO address The address of the new CFO\r\n     * @param _nonce uint256 setCEO transaction number.\r\n     */\r\n    function getCFOHashing(address _newCFO, uint256 _nonce) public pure returns (bytes32) {\r\n        return keccak256(bytes4(0x486A0F01), _newCFO, _nonce);\r\n    }\r\n\r\n    // @dev Assigns a new address to act as the CFO. The C level transaction, must verify.\r\n    // @param _newCFO The address of the new CFO\r\n    function setCFO(\r\n        address _newCFO,\r\n        bytes _sig\r\n    ) external onlyCLevel {\r\n        require(\r\n            _newCFO != address(0) &&\r\n            _newCFO != ceoAddress &&\r\n            _newCFO != cooAddress\r\n        );\r\n\r\n        bytes32 hashedTx = getCFOHashing(_newCFO, nonces[msg.sender]);\r\n        require(signedCLevel(hashedTx, _sig));\r\n        nonces[msg.sender]++;\r\n\r\n        cfoAddress = _newCFO;\r\n        CLevelTxCount_++;\r\n    }\r\n\r\n    /**\r\n     * @notice Hash (keccak256) of the payload used by setCOO\r\n     * @param _newCOO address The address of the new COO\r\n     * @param _nonce uint256 setCEO transaction number.\r\n     */\r\n    function getCOOHashing(address _newCOO, uint256 _nonce) public pure returns (bytes32) {\r\n        return keccak256(bytes4(0x486A0F02), _newCOO, _nonce);\r\n    }\r\n\r\n    // @dev Assigns a new address to act as the COO. The C level transaction, must verify.\r\n    // @param _newCOO The address of the new COO, _sig signature used to verify COO address\r\n    function setCOO(\r\n        address _newCOO,\r\n        bytes _sig\r\n    ) external onlyCLevel {\r\n        require(\r\n            _newCOO != address(0) &&\r\n            _newCOO != ceoAddress &&\r\n            _newCOO != cfoAddress\r\n        );\r\n\r\n        bytes32 hashedTx = getCOOHashing(_newCOO, nonces[msg.sender]);\r\n        require(signedCLevel(hashedTx, _sig));\r\n        nonces[msg.sender]++;\r\n\r\n        cooAddress = _newCOO;\r\n        CLevelTxCount_++;\r\n    }\r\n\r\n    function getNonce() external view returns (uint256) {\r\n        return nonces[msg.sender];\r\n    }\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n}\r\n\r\ncontract PreSaleToken is AccessControl {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // @dev This define events\r\n    event BuyDeklaSuccessful(uint256 dekla, address buyer);\r\n    event SendDeklaSuccessful(uint256 dekla, address buyer);\r\n    event WithdrawEthSuccessful(uint256 price, address receiver);\r\n    event WithdrawDeklaSuccessful(uint256 price, address receiver);\r\n    event UpdateDeklaPriceSuccessful(uint256 bonus, address sender);\r\n\r\n    // @dev This is price of 1 DKL (Dekla Token)\r\n    // Current: 1 DKL = 0.00002259 ETH = 22590000000000 Wei = 0.005$\r\n    uint256 public deklaTokenPrice = 22590000000000;\r\n\r\n    // @dev percent bonus ~ 8.8%\r\n    uint16 public bonus = 880;\r\n\r\n    // @dev decimals unit\r\n    uint256 public decimals = 18;\r\n\r\n    // @dev Dekla Token minimum\r\n    uint256 public deklaMinimum = 5000 * (10 ** decimals);\r\n\r\n    // ERC20 basic token contract being help\r\n    ERC20 public token;\r\n\r\n    // @dev store address and dekla token\r\n    mapping(address => uint256) deklaTokenOf;\r\n\r\n    // @dev sale status\r\n    bool public preSaleEnd;\r\n\r\n    // @dev total dekla token amount for pre-sale\r\n    uint256 public totalToken;\r\n\r\n    // @dev total number of token already been should\r\n    uint256 public soldToken;\r\n\r\n    address public systemAddress;\r\n\r\n    // @dev store nonces\r\n    mapping(address => uint256) nonces;\r\n\r\n    constructor(\r\n        address _ceoAddress,\r\n        address _cfoAddress,\r\n        address _cooAddress,\r\n        address _systemAddress,\r\n        uint256 _totalToken\r\n    ) public {\r\n        require(_totalToken > 0);\r\n        // initial C level address\r\n        ceoAddress = _ceoAddress;\r\n        cfoAddress = _cfoAddress;\r\n        cooAddress = _cooAddress;\r\n        totalToken = _totalToken * (10 ** decimals);\r\n        systemAddress = _systemAddress;\r\n    }\r\n\r\n    //check that the token is set\r\n    modifier validToken() {\r\n        require(token != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier onlySystem() {\r\n        require(msg.sender ==  systemAddress);\r\n        _;\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        //Check the signature length\r\n        if (sig.length != 65) {\r\n            return (address(0));\r\n        }\r\n        // Divide the signature in r, s and v variables\r\n        (v, r, s) = splitSignature(sig);\r\n        // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n        if (v < 27) {\r\n            v += 27;\r\n        }\r\n        // If the version is correct return the signer address\r\n        if (v != 27 && v != 28) {\r\n            return (address(0));\r\n        } else {\r\n            bytes memory prefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n            bytes32 prefixedHash = keccak256(prefix, hash);\r\n            return ecrecover(prefixedHash, v, r, s);\r\n        }\r\n    }\r\n    \r\n    function getNonces(address _sender) public view returns (uint256) {\r\n        return nonces[_sender];\r\n    }\r\n    \r\n    function getTokenAddressHashing(address _token, uint256 _nonce) public pure returns (bytes32) {\r\n        return keccak256(bytes4(0x486A0F03), _token, _nonce);\r\n    }\r\n\r\n    function setTokenAddress(address _token, bytes _sig) external onlyCLevel {\r\n        bytes32 hashedTx = getTokenAddressHashing(_token, nonces[msg.sender]);\r\n        require(signedCLevel(hashedTx, _sig));\r\n        token = ERC20(_token);\r\n        nonces[msg.sender]++;\r\n    }\r\n\r\n    // @dev update selling status\r\n    // @dev _selling == true: sale token is running, _selling = true: sale token is pause/stop\r\n    // @param _selling is status of selling\r\n    function setPreSaleEnd(bool _end) external onlyCLevel {\r\n        preSaleEnd = _end;\r\n    }\r\n\r\n    // @dev get preSaleEnd status\r\n    function isPreSaleEnd() external view returns (bool) {\r\n        return preSaleEnd;\r\n    }\r\n\r\n    function setDeklaPrice(uint256 _price) external onlySystem {\r\n        deklaTokenPrice = _price;\r\n        emit UpdateDeklaPriceSuccessful(_price, msg.sender);\r\n    }\r\n\r\n    // @dev buy Dekla Token with eth of pre-sale\r\n    // @param value is eth balance\r\n    function() external payable {\r\n        // validate sale is opening\r\n        require(!preSaleEnd);\r\n\r\n        // unit of msg.value is Wei\r\n        uint256 amount = msg.value.div(deklaTokenPrice);\r\n        amount = amount * (10 ** decimals);\r\n\r\n        // require total Dekla Token minimum\r\n        require(amount >= deklaMinimum);\r\n\r\n        // update total token left\r\n        soldToken = soldToken.add(amount);\r\n\r\n        if(soldToken < totalToken) {\r\n            // calculate how much Dekla Token buyer will have with bonus is 8,8%\r\n            amount = amount.add(amount.mul(bonus).div(10000));\r\n        }\r\n\r\n        // store dekla balance\r\n        deklaTokenOf[msg.sender] = deklaTokenOf[msg.sender].add(amount);\r\n\r\n        // This notifies clients about the buy dekla\r\n        emit BuyDeklaSuccessful(amount, msg.sender);\r\n    }\r\n\r\n    function getPromoBonusHashing(address _buyer, uint16 _bonus, uint256 _nonce) public pure returns (bytes32) {\r\n        return keccak256(bytes4(0x486A0F2F), _buyer, _bonus, _nonce);\r\n    }\r\n\r\n    // @dev buy Dekla Token with eth of pre-sale\r\n    // @param value is eth balance\r\n    function buyDkl(uint16 _bonus, bytes _sig) external payable {\r\n        // validate sale is opening\r\n        require(!preSaleEnd);\r\n\r\n        // bonus maximum should be <= 1500 ~ 15% and >= 500 ~ 5%\r\n        require(_bonus >= 500 && _bonus <= 1500);\r\n\r\n        bytes32 hashedTx = getPromoBonusHashing(msg.sender, _bonus, nonces[msg.sender]);\r\n\r\n        // promo bonus should sign by systemAddress\r\n        require(recover(hashedTx, _sig) == systemAddress);\r\n\r\n        // update nonces of sender\r\n        nonces[msg.sender]++;\r\n\r\n        // unit of msg.value is Wei\r\n        uint256 amount = msg.value.div(deklaTokenPrice);\r\n        amount = amount * (10 ** decimals);\r\n\r\n        // require total Dekla Token minimum\r\n        require(amount >= deklaMinimum);\r\n\r\n        // update total token left\r\n        soldToken = soldToken.add(amount);\r\n\r\n        if(soldToken < totalToken) {\r\n            // calculate how much Dekla Token buyer will have with bonus\r\n            amount = amount.add(amount.mul(_bonus).div(10000));\r\n        }\r\n\r\n        // store dekla balance\r\n        deklaTokenOf[msg.sender] = deklaTokenOf[msg.sender].add(amount);\r\n\r\n        // This notifies clients about the buy dekla\r\n        emit BuyDeklaSuccessful(amount, msg.sender);\r\n    }\r\n\r\n    // @dev get Dekla Token of user\r\n    function getDeklaTokenOf(address _address) external view returns (uint256) {\r\n        return deklaTokenOf[_address];\r\n    }\r\n\r\n    // @dev calculate Dekla Token received with ETH\r\n    function calculateDekla(uint256 _value) external view returns (uint256) {\r\n        require(_value >= deklaTokenPrice);\r\n        return _value.div(deklaTokenPrice);\r\n    }\r\n\r\n    // @dev send Dekla Token to buyer\r\n    function sendDekla(address _address) external payable validToken {\r\n        // check address\r\n        require(_address != address(0));\r\n\r\n        // get buyer info\r\n        uint256 amount = deklaTokenOf[_address];\r\n\r\n        // buyer dekla should be greater than 0\r\n        require(amount > 0);\r\n\r\n        // check total dekla of owner\r\n        require(token.balanceOf(this) >= amount);\r\n\r\n        // reset dekla\r\n        deklaTokenOf[_address] = 0;\r\n\r\n        // transfer dekla to user\r\n        token.transfer(_address, amount);\r\n\r\n        // notify event to receiver\r\n        emit SendDeklaSuccessful(amount, _address);\r\n    }\r\n\r\n    function sendDeklaToMultipleUsers(address[] _receivers) external payable validToken {\r\n        // check address list not empty\r\n        require(_receivers.length > 0);\r\n\r\n        // loop send dekla\r\n        for (uint i = 0; i < _receivers.length; i++) {\r\n            address _address = _receivers[i];\r\n\r\n            // check address\r\n            require(_address != address(0));\r\n\r\n            // get buyer info\r\n            uint256 amount = deklaTokenOf[_address];\r\n\r\n            // buyer dekla should be greater than 0\r\n            // check total dekla of owner\r\n            if (amount > 0 && token.balanceOf(this) >= amount) {\r\n                // reset dekla\r\n                deklaTokenOf[_address] = 0;\r\n\r\n                // transfer dekla to user\r\n                token.transfer(_address, amount);\r\n\r\n                // notify event to receiver\r\n                emit SendDeklaSuccessful(amount, _address);\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawEthHashing(address _address, uint256 _nonce) public pure returns (bytes32) {\r\n        return keccak256(bytes4(0x486A0F0D), _address, _nonce);\r\n    }\r\n\r\n    // @dev withdraw ETH balance from owner to wallet input\r\n    // @param withdrawWallet is wallet address of receiver ETH\r\n    function withdrawEth(address _withdrawWallet, bytes _sig) external onlyCLevel {\r\n        bytes32 hashedTx = withdrawEthHashing(_withdrawWallet, nonces[msg.sender]);\r\n        require(signedCLevel(hashedTx, _sig));\r\n        nonces[msg.sender]++;\r\n\r\n        uint256 balance = address(this).balance;\r\n\r\n        // balance should be greater than 0\r\n        require(balance > 0);\r\n\r\n        // transfer ETH to receiver\r\n        _withdrawWallet.transfer(balance);\r\n\r\n        // notify event to receiver\r\n        emit WithdrawEthSuccessful(balance, _withdrawWallet);\r\n    }\r\n\r\n    function withdrawDeklaHashing(address _address, uint256 _nonce) public pure returns (bytes32) {\r\n        return keccak256(bytes4(0x486A0F0E), _address, _nonce);\r\n    }\r\n\r\n    // @dev withdraw DKL balance from owner to wallet input\r\n    // @param _walletAddress is wallet address of receiver DKL\r\n    function withdrawDekla(address _withdrawWallet, bytes _sig) external validToken onlyCLevel {\r\n        bytes32 hashedTx = withdrawDeklaHashing(_withdrawWallet, nonces[msg.sender]);\r\n        require(signedCLevel(hashedTx, _sig));\r\n        nonces[msg.sender]++;\r\n\r\n        uint256 balance = token.balanceOf(this);\r\n\r\n        // the sold tokens must be left\r\n        require(balance > soldToken);\r\n\r\n        // transfer dekla to receiver\r\n        token.transfer(_withdrawWallet, balance - soldToken);\r\n\r\n        // notify event to receiver\r\n        emit WithdrawDeklaSuccessful(balance, _withdrawWallet);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawWallet\",\"type\":\"address\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getCFOHashing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"recover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deklaMinimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"withdrawEthHashing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_end\",\"type\":\"bool\"}],\"name\":\"setPreSaleEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"setTokenAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getCEOHashing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"getNonces\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CLevelTxCount_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"calculateDekla\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bonus\",\"type\":\"uint16\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"buyDkl\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawWallet\",\"type\":\"address\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"withdrawDekla\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getCOOHashing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"withdrawDeklaHashing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"sendDekla\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"setDeklaPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"}],\"name\":\"sendDeklaToMultipleUsers\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPreSaleEnd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getTokenAddressHashing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"systemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_bonus\",\"type\":\"uint16\"},{\"name\":\"_nonce\",\"type\":\"uint256\"}],\"name\":\"getPromoBonusHashing\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deklaTokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getDeklaTokenOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ceoAddress\",\"type\":\"address\"},{\"name\":\"_cfoAddress\",\"type\":\"address\"},{\"name\":\"_cooAddress\",\"type\":\"address\"},{\"name\":\"_systemAddress\",\"type\":\"address\"},{\"name\":\"_totalToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dekla\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"BuyDeklaSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dekla\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"SendDeklaSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"WithdrawEthSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"receiver\",\"type\":\"address\"}],\"name\":\"WithdrawDeklaSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"UpdateDeklaPriceSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"addressLogger\",\"type\":\"event\"}]","ContractName":"PreSaleToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007aeaf9c8a62caf79c60b0eeb1e57eaefc140a5ca0000000000000000000000005425a1ca8b650ccfe0620fd10fe6e3dc46f0211d000000000000000000000000d75c77816c83537a6bb97819398fc2694e2e1478000000000000000000000000315fb673a6fa8720cf0341795faad602061d12670000000000000000000000000000000000000000000000000000000003938700","Library":"","SwarmSource":"bzzr://9a648c46ec689257bb71abdd36f40c2578c6c2a2bf369d27ae06a084c750636c"}]}