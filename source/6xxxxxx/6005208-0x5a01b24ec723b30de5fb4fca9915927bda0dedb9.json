{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/SkrumbleStaking.sol\r\n\r\n// File: contracts/SkrumbleStaking.sol\r\n\r\n// Staking Contract for Skrumble Network - https://skrumble.network/\r\n// written by @iamdefinitelyahuman\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\ninterface ERC20 {\r\n  function balanceOf(address _owner) external returns (uint256);\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n}\r\n\r\n\r\ncontract SkrumbleStaking {\r\n\r\n  using SafeMath for uint;\r\n\r\n  bool public isLocked = true;\r\n  address owner;\r\n  address rewardWallet;\r\n  uint balance;\r\n  uint public count;\r\n  uint public limit;\r\n  ERC20 token;\r\n  \r\n  struct Reward {\r\n    uint stakedAmount;\r\n    uint lockupPeriod;\r\n    uint[] rewardAmounts;\r\n    uint[] rewardEpochStart;\r\n  }\r\n  mapping (uint => Reward) public rewardLevels;\r\n\r\n  struct Staker {\r\n    uint balance;\r\n    uint rewardLevel;\r\n    uint stakingSince;\r\n    uint lastClaim;\r\n  }\r\n  mapping (address => Staker) stakerMap;\r\n\r\n  event RewardLevel (uint level, uint amount, uint lockupPeriod, uint[] rewardAmounts, uint[] rewardEpochStart);\r\n  event NewStaker (address staker, uint rewardLevel, uint stakingSince);\r\n  event StakerCount (uint count, uint limit);\r\n  event RewardClaimed (address staker, uint rewardAmount);\r\n\r\n  modifier onlyOwner () {\r\n    require (msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyUnlocked () {\r\n    require (!isLocked);\r\n    _;\r\n  }\r\n\r\n  constructor (address _tokenContract, address _rewardWallet) public {\r\n    owner = msg.sender;\r\n    rewardWallet = _rewardWallet;\r\n    token = ERC20(_tokenContract);\r\n  }\r\n  \r\n  function min (uint a, uint b) pure internal returns (uint) {\r\n    if (a <= b) return a;\r\n    return b;\r\n  }\r\n  \r\n  function max (uint a, uint b) pure internal returns (uint) {\r\n    if (a >= b) return a;\r\n    return b;\r\n  }\r\n  \r\n  function lockContract () public onlyOwner {\r\n    isLocked = true;\r\n  }\r\n  \r\n  function unlockContract () public onlyOwner {\r\n    isLocked = false;\r\n  }\r\n  \r\n  function setRewardWallet (address _rewardWallet) public onlyOwner {\r\n    rewardWallet = _rewardWallet;\r\n  }\r\n  \r\n  function setRewardLevel (uint _level, uint _amount, uint _lockup, uint[] _reward, uint[] _period) public onlyOwner {\r\n    require (_reward.length == _period.length);\r\n    require (_period[_period.length.sub(1)] < 9999999999);\r\n    for (uint i = 1; i < _period.length; i++) {\r\n      require (_period[i] > _period[i.sub(1)]);\r\n    }\r\n    rewardLevels[_level] = Reward(_amount, _lockup, _reward, _period);\r\n    emit RewardLevel (_level, _amount, _lockup, _reward, _period);\r\n  }\r\n  \r\n  function modifyStakerLimit (uint _limit) public onlyOwner {\r\n    require (count <= _limit);\r\n    limit = _limit;\r\n  }\r\n  \r\n  function getAvailableReward (address _staker) view public returns (uint) {\r\n    Staker storage staker = stakerMap[_staker];\r\n    Reward storage reward = rewardLevels[staker.rewardLevel];\r\n    if (staker.balance == 0 || staker.lastClaim.add(86400) > now) {\r\n      return 0;\r\n    }\r\n    uint unclaimed = 0;\r\n    uint periodEnd = 9999999999;\r\n    for (uint i = reward.rewardEpochStart.length; i > 0; i--) {\r\n      uint start = staker.stakingSince.add(reward.rewardEpochStart[i.sub(1)]);\r\n      if (start >= now) {\r\n        continue;\r\n      }\r\n      uint length = min(now, periodEnd).sub(max(start, staker.lastClaim));\r\n      unclaimed = unclaimed.add(reward.rewardAmounts[i.sub(1)].mul(length).div(31622400));\r\n      if (staker.lastClaim >= start) {\r\n        break;\r\n      }\r\n      periodEnd = start;\r\n    }\r\n    return unclaimed;\r\n  }\r\n\r\n  function getStakerInfo (address _staker) view public returns (uint stakedBalance, uint lockedUntil, uint lastClaim) {\r\n    Staker storage staker = stakerMap[_staker];\r\n    Reward storage reward = rewardLevels[staker.rewardLevel];\r\n    return (staker.balance, staker.stakingSince.add(reward.lockupPeriod), staker.lastClaim);\r\n  }\r\n\r\n  function stakeTokens (uint _level) public onlyUnlocked {\r\n    Reward storage reward = rewardLevels[_level];\r\n    require (stakerMap[msg.sender].balance == 0);\r\n    require (count < limit);\r\n    require (token.transferFrom(msg.sender, address(this), reward.stakedAmount));\r\n    count = count.add(1);\r\n    balance = balance.add(reward.stakedAmount);\r\n    stakerMap[msg.sender] = Staker(reward.stakedAmount, _level, now, now);\r\n    emit NewStaker (msg.sender, _level, now);\r\n    emit StakerCount (count, limit);\r\n  }\r\n  \r\n  function unstakeTokens () public onlyUnlocked {\r\n    Staker storage staker = stakerMap[msg.sender];\r\n    Reward storage reward = rewardLevels[staker.rewardLevel];\r\n    require (staker.balance > 0);\r\n    require (staker.stakingSince.add(reward.lockupPeriod) < now);\r\n    if (getAvailableReward(msg.sender) > 0) {\r\n      claimReward();\r\n    }\r\n    require (token.transfer(msg.sender, staker.balance));\r\n    count = count.sub(1);\r\n    balance = balance.sub(staker.balance);\r\n    emit StakerCount (count, limit);\r\n  \tstakerMap[msg.sender] = Staker(0, 0, 0, 0);\r\n  }\r\n  \r\n  function claimReward () public onlyUnlocked {\r\n    uint amount = getAvailableReward(msg.sender);\r\n    require (amount > 0);\r\n    stakerMap[msg.sender].lastClaim = now;\r\n    require (token.transferFrom(rewardWallet, msg.sender, amount));\r\n    emit RewardClaimed (msg.sender, amount);\r\n  }\r\n  \r\n  function transferSKM () public onlyOwner {\r\n    uint fullBalance = token.balanceOf(address(this));\r\n    require (fullBalance > balance);\r\n    require (token.transfer(owner, fullBalance.sub(balance)));\r\n  }\r\n  \r\n  function transferOtherTokens (address _tokenAddr) public onlyOwner {\r\n    require (_tokenAddr != address(token));\r\n    ERC20 _token = ERC20(_tokenAddr);\r\n    require (_token.transfer(owner, _token.balanceOf(address(this))));\r\n  }\r\n\r\n  function claimRewardManually (address _staker) public onlyOwner {\r\n    uint amount = getAvailableReward(_staker);\r\n    require (amount > 0);\r\n    stakerMap[_staker].lastClaim = now;\r\n    require (token.transferFrom(rewardWallet, _staker, amount));\r\n    emit RewardClaimed (_staker, amount);\r\n  }\r\n\r\n  function unstakeTokensManually (address _staker) public onlyOwner {\r\n    Staker storage staker = stakerMap[_staker];\r\n    Reward storage reward = rewardLevels[staker.rewardLevel];\r\n    require (staker.balance > 0);\r\n    require (staker.stakingSince.add(reward.lockupPeriod) < now);\r\n    if (getAvailableReward(_staker) > 0) {\r\n      claimRewardManually(_staker);\r\n    }\r\n    require (token.transfer(_staker, staker.balance));\r\n    count = count.sub(1);\r\n    balance = balance.sub(staker.balance);\r\n    emit StakerCount (count, limit);\r\n  \tstakerMap[_staker] = Staker(0, 0, 0, 0);\r\n  }\r\n\r\n  function stakeTokensManually (address _staker, uint _level, uint time) public onlyOwner {\r\n    Reward storage reward = rewardLevels[_level];\r\n    require (stakerMap[_staker].balance == 0);\r\n    require (count < limit);\r\n    count = count.add(1);\r\n    balance = balance.add(reward.stakedAmount);\r\n    stakerMap[_staker] = Staker(reward.stakedAmount, _level, time, time);\r\n    emit NewStaker (_staker, _level, time);\r\n    emit StakerCount (count, limit);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"modifyStakerLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unlockContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"},{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"time\",\"type\":\"uint256\"}],\"name\":\"stakeTokensManually\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getAvailableReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"claimRewardManually\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rewardWallet\",\"type\":\"address\"}],\"name\":\"setRewardWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"getStakerInfo\",\"outputs\":[{\"name\":\"stakedBalance\",\"type\":\"uint256\"},{\"name\":\"lockedUntil\",\"type\":\"uint256\"},{\"name\":\"lastClaim\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"lockContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"}],\"name\":\"stakeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_staker\",\"type\":\"address\"}],\"name\":\"unstakeTokensManually\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rewardLevels\",\"outputs\":[{\"name\":\"stakedAmount\",\"type\":\"uint256\"},{\"name\":\"lockupPeriod\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstakeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_lockup\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256[]\"},{\"name\":\"_period\",\"type\":\"uint256[]\"}],\"name\":\"setRewardLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferSKM\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddr\",\"type\":\"address\"}],\"name\":\"transferOtherTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_rewardWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockupPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardAmounts\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"rewardEpochStart\",\"type\":\"uint256[]\"}],\"name\":\"RewardLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stakingSince\",\"type\":\"uint256\"}],\"name\":\"NewStaker\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"limit\",\"type\":\"uint256\"}],\"name\":\"StakerCount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"staker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"}]","ContractName":"SkrumbleStaking","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8ca4fab1d7184f3fb8f30d1823db4e46d0d17e7be0ee13711cb3dfdd19980b79"}]}