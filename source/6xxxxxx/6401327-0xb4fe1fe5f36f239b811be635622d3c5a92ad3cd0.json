{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract Base\r\n{\r\n    uint8 constant HEROLEVEL_MIN = 1;\r\n    uint8 constant HEROLEVEL_MAX = 5;\r\n\r\n    uint8 constant LIMITCHIP_MINLEVEL = 3;\r\n    uint constant PARTWEIGHT_NORMAL = 100;\r\n    uint constant PARTWEIGHT_LIMIT = 40;\r\n\r\n    address creator;\r\n\r\n    constructor() public\r\n    {\r\n        creator = msg.sender;\r\n    }\r\n\r\n    modifier MasterAble()\r\n    {\r\n        require(msg.sender == creator);\r\n        _;\r\n    }\r\n\r\n    function IsLimitPart(uint8 level, uint part) internal pure returns(bool)\r\n    {\r\n        if (level < LIMITCHIP_MINLEVEL) return false;\r\n        if (part < GetPartNum(level)) return false;\r\n        return true;\r\n    }\r\n\r\n    function GetPartWeight(uint8 level, uint part) internal pure returns(uint)\r\n    {\r\n        if (IsLimitPart(level, part)) return PARTWEIGHT_LIMIT;\r\n        return PARTWEIGHT_NORMAL;\r\n    }\r\n    \r\n    function GetPartNum(uint8 level) internal pure returns(uint)\r\n    {\r\n        if (level <= 2) return 3;\r\n        else if (level <= 4) return 4;\r\n        return 5;\r\n    }\r\n\r\n}\r\n\r\ncontract BasicTime\r\n{\r\n    uint constant DAY_SECONDS = 60 * 60 * 24;\r\n\r\n    function GetDayCount(uint timestamp) pure internal returns(uint)\r\n    {\r\n        return timestamp/DAY_SECONDS;\r\n    }\r\n\r\n    function GetExpireTime(uint timestamp, uint dayCnt) pure internal returns(uint)\r\n    {\r\n        uint dayEnd = GetDayCount(timestamp) + dayCnt;\r\n        return dayEnd * DAY_SECONDS;\r\n    }\r\n\r\n}\r\n\r\ncontract BasicAuth is Base\r\n{\r\n\r\n    address master;\r\n    mapping(address => bool) auth_list;\r\n\r\n    function InitMaster(address acc) internal\r\n    {\r\n        require(address(0) != acc);\r\n        master = acc;\r\n    }\r\n\r\n    modifier MasterAble()\r\n    {\r\n        require(msg.sender == creator || msg.sender == master);\r\n        _;\r\n    }\r\n\r\n    modifier OwnerAble(address acc)\r\n    {\r\n        require(acc == tx.origin);\r\n        _;\r\n    }\r\n\r\n    modifier AuthAble()\r\n    {\r\n        require(auth_list[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function CanHandleAuth(address from) internal view returns(bool)\r\n    {\r\n        return from == creator || from == master;\r\n    }\r\n    \r\n    function SetAuth(address target) external\r\n    {\r\n        require(CanHandleAuth(tx.origin) || CanHandleAuth(msg.sender));\r\n        auth_list[target] = true;\r\n    }\r\n\r\n    function ClearAuth(address target) external\r\n    {\r\n        require(CanHandleAuth(tx.origin) || CanHandleAuth(msg.sender));\r\n        delete auth_list[target];\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\nlibrary IndexList\r\n{\r\n    function insert(uint32[] storage self, uint32 index, uint pos) external\r\n    {\r\n        require(self.length >= pos);\r\n        self.length++;\r\n        for (uint i=self.length; i>pos; i++)\r\n        {\r\n            self[i+1] = self[i];\r\n        }\r\n        self[pos] = index;\r\n    }\r\n\r\n    function remove(uint32[] storage self, uint32 index) external returns(bool)\r\n    {\r\n        return remove(self,index,0);\r\n    }\r\n\r\n    function remove(uint32[] storage self, uint32 index, uint startPos) public returns(bool)\r\n    {\r\n        for (uint i=startPos; i<self.length; i++)\r\n        {\r\n            if (self[i] != index) continue;\r\n            for (uint j=i; j<self.length-1; j++)\r\n            {\r\n                self[j] = self[j+1];\r\n            }\r\n            delete self[self.length-1];\r\n            self.length--;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n}\r\n\r\nlibrary ItemList {\r\n\r\n    using IndexList for uint32[];\r\n    \r\n    struct Data {\r\n        uint32[] m_List;\r\n        mapping(uint32 => uint) m_Maps;\r\n    }\r\n\r\n    function _insert(Data storage self, uint32 key, uint val) internal\r\n    {\r\n        self.m_List.push(key);\r\n        self.m_Maps[key] = val;\r\n    }\r\n\r\n    function _delete(Data storage self, uint32 key) internal\r\n    {\r\n        self.m_List.remove(key);\r\n        delete self.m_Maps[key];\r\n    }\r\n\r\n    function set(Data storage self, uint32 key, uint num) public\r\n    {\r\n        if (!has(self,key)) {\r\n            if (num == 0) return;\r\n            _insert(self,key,num);\r\n        }\r\n        else if (num == 0) {\r\n            _delete(self,key);\r\n        } \r\n        else {\r\n            uint old = self.m_Maps[key];\r\n            if (old == num) return;\r\n            self.m_Maps[key] = num;\r\n        }\r\n    }\r\n\r\n    function add(Data storage self, uint32 key, uint num) external\r\n    {\r\n        uint iOld = get(self,key);\r\n        uint iNow = iOld+num;\r\n        require(iNow >= iOld);\r\n        set(self,key,iNow);\r\n    }\r\n\r\n    function sub(Data storage self, uint32 key, uint num) external\r\n    {\r\n        uint iOld = get(self,key);\r\n        require(iOld >= num);\r\n        set(self,key,iOld-num);\r\n    }\r\n\r\n    function has(Data storage self, uint32 key) public view returns(bool)\r\n    {\r\n        return self.m_Maps[key] > 0;\r\n    }\r\n\r\n    function get(Data storage self, uint32 key) public view returns(uint)\r\n    {\r\n        return self.m_Maps[key];\r\n    }\r\n\r\n    function list(Data storage self) view external returns(uint32[],uint[])\r\n    {\r\n        uint len = self.m_List.length;\r\n        uint[] memory values = new uint[](len);\r\n        for (uint i=0; i<len; i++)\r\n        {\r\n            uint32 key = self.m_List[i];\r\n            values[i] = self.m_Maps[key];\r\n        }\r\n        return (self.m_List,values);\r\n    }\r\n\r\n    function isEmpty(Data storage self) view external returns(bool)\r\n    {\r\n        return self.m_List.length == 0;\r\n    }\r\n\r\n    function keys(Data storage self) view external returns(uint32[])\r\n    {\r\n        return self.m_List;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract MainBase is Base \r\n{\r\n    modifier ValidLevel(uint8 level)\r\n    {\r\n        require(level<=HEROLEVEL_MAX && level>=HEROLEVEL_MIN);\r\n        _;\r\n    }\r\n\r\n    modifier ValidParts(uint8 level, uint32[] parts)\r\n    {\r\n        require(GetPartNum(level) == parts.length);\r\n        _;\r\n    }\r\n\r\n    modifier ValidPart(uint8 level, uint part)\r\n    {\r\n        require(part > 0);\r\n        require(GetPartNum(level) >= part);\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract MainCard is BasicAuth,MainBase\r\n{\r\n    struct Card {\r\n        uint32 m_Index;\r\n        uint32 m_Duration;\r\n        uint8 m_Level;\r\n        uint16 m_DP;  //DynamicProfit\r\n        uint16 m_DPK; //K is coefficient\r\n        uint16 m_SP;  //StaticProfit\r\n        uint16 m_IP;  //ImmediateProfit\r\n        uint32[] m_Parts;\r\n    }\r\n\r\n    struct CardLib {\r\n        uint32[] m_List;\r\n        mapping(uint32 => Card) m_Lib;\r\n    }\r\n\r\n    CardLib g_CardLib;\r\n\r\n    function AddNewCard(uint32 iCard, uint32 duration, uint8 level, uint16 dp, uint16 dpk, uint16 sp, uint16 ip, uint32[] parts) external MasterAble ValidLevel(level) ValidParts(level,parts)\r\n    {\r\n        require(!CardExists(iCard));\r\n        g_CardLib.m_List.push(iCard);\r\n        g_CardLib.m_Lib[iCard] = Card({\r\n            m_Index   : iCard,\r\n            m_Duration: duration,\r\n            m_Level   : level,\r\n            m_DP      : dp,\r\n            m_DPK     : dpk,\r\n            m_SP      : sp,\r\n            m_IP      : ip,\r\n            m_Parts   : parts\r\n        });\r\n    }\r\n\r\n    function CardExists(uint32 iCard) public view returns(bool)\r\n    {\r\n        Card storage obj = g_CardLib.m_Lib[iCard];\r\n        return obj.m_Index == iCard;\r\n    }\r\n\r\n    function GetCard(uint32 iCard) internal view returns(Card storage)\r\n    {\r\n        return g_CardLib.m_Lib[iCard];\r\n    }\r\n\r\n    function GetCardInfo(uint32 iCard) external view returns(uint32, uint32, uint8, uint16, uint16, uint16, uint16, uint32[])\r\n    {\r\n        Card storage obj = GetCard(iCard);\r\n        return (obj.m_Index, obj.m_Duration, obj.m_Level, obj.m_DP, obj.m_DPK, obj.m_SP, obj.m_IP, obj.m_Parts);\r\n    }\r\n\r\n    function GetExistsCardList() external view returns(uint32[])\r\n    {\r\n        return g_CardLib.m_List;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract MainChip is BasicAuth,MainBase\r\n{\r\n    using IndexList for uint32[];\r\n\r\n    struct Chip\r\n    {\r\n        uint8 m_Level;\r\n        uint8 m_LimitNum;\r\n        uint8 m_Part;\r\n        uint32 m_Index;\r\n        uint256 m_UsedNum;\r\n    }\r\n\r\n    struct PartManager\r\n    {\r\n        uint32[] m_IndexList;   //index list, player can obtain\r\n        uint32[] m_UnableList;  //player can't obtain\r\n    }\r\n\r\n    struct ChipLib\r\n    {\r\n        uint32[] m_List;\r\n        mapping(uint32 => Chip) m_Lib;\r\n        mapping(uint32 => uint[]) m_TempList;\r\n        mapping(uint8 => mapping(uint => PartManager)) m_PartMap;//level -> level list\r\n    }\r\n\r\n    ChipLib g_ChipLib;\r\n\r\n    function AddNewChip(uint32 iChip, uint8 lv, uint8 limit, uint8 part) external MasterAble ValidLevel(lv) ValidPart(lv,part)\r\n    {\r\n        require(!ChipExists(iChip));\r\n        g_ChipLib.m_List.push(iChip);\r\n        g_ChipLib.m_Lib[iChip] = Chip({\r\n            m_Index       : iChip,\r\n            m_Level       : lv,\r\n            m_LimitNum    : limit,\r\n            m_Part        : part,\r\n            m_UsedNum     : 0\r\n        });\r\n        PartManager storage pm = GetPartManager(lv,part);\r\n        pm.m_IndexList.push(iChip);\r\n    }\r\n\r\n    function GetChip(uint32 iChip) internal view returns(Chip storage)\r\n    {\r\n        return g_ChipLib.m_Lib[iChip];\r\n    }\r\n\r\n    function GetPartManager(uint8 level, uint iPart) internal view returns(PartManager storage)\r\n    {\r\n        return g_ChipLib.m_PartMap[level][iPart];\r\n    }\r\n\r\n    function ChipExists(uint32 iChip) public view returns(bool)\r\n    {\r\n        Chip storage obj = GetChip(iChip);\r\n        return obj.m_Index == iChip;\r\n    }\r\n\r\n    function GetChipUsedNum(uint32 iChip) internal view returns(uint)\r\n    {\r\n        Chip storage obj = GetChip(iChip);\r\n        uint[] memory tempList = g_ChipLib.m_TempList[iChip];\r\n        uint num = tempList.length;\r\n        for (uint i=num; i>0; i--)\r\n        {\r\n            if(tempList[i-1]<=now) {\r\n                num -= i;\r\n                break;\r\n            }\r\n        }\r\n        return obj.m_UsedNum + num;\r\n    }\r\n\r\n    function CanObtainChip(uint32 iChip) internal view returns(bool)\r\n    {\r\n        Chip storage obj = GetChip(iChip);\r\n        if (obj.m_LimitNum == 0) return true;\r\n        if (GetChipUsedNum(iChip) < obj.m_LimitNum) return true;\r\n        return false;\r\n    }\r\n\r\n    function CostChip(uint32 iChip) internal\r\n    {\r\n        BeforeChipCost(iChip);\r\n        Chip storage obj = GetChip(iChip);\r\n        obj.m_UsedNum--;\r\n    }\r\n\r\n    function ObtainChip(uint32 iChip) internal\r\n    {\r\n        BeforeChipObtain(iChip);\r\n        Chip storage obj = GetChip(iChip);\r\n        obj.m_UsedNum++;\r\n    }\r\n\r\n    function BeforeChipObtain(uint32 iChip) internal\r\n    {\r\n        Chip storage obj = GetChip(iChip);\r\n        if (obj.m_LimitNum == 0) return;\r\n        uint usedNum = GetChipUsedNum(iChip);\r\n        require(obj.m_LimitNum >= usedNum+1);\r\n        if (obj.m_LimitNum == usedNum+1) {\r\n            PartManager storage pm = GetPartManager(obj.m_Level,obj.m_Part);\r\n            if (pm.m_IndexList.remove(iChip)){\r\n                pm.m_UnableList.push(iChip);\r\n            }\r\n        }\r\n    }\r\n\r\n    function BeforeChipCost(uint32 iChip) internal\r\n    {\r\n        Chip storage obj = GetChip(iChip);\r\n        if (obj.m_LimitNum == 0) return;\r\n        uint usedNum = GetChipUsedNum(iChip);\r\n        require(obj.m_LimitNum >= usedNum);\r\n        if (obj.m_LimitNum == usedNum) {\r\n            PartManager storage pm = GetPartManager(obj.m_Level,obj.m_Part);\r\n            if (pm.m_UnableList.remove(iChip)) {\r\n                pm.m_IndexList.push(iChip);\r\n            }\r\n        }\r\n    }\r\n\r\n    function AddChipTempTime(uint32 iChip, uint expireTime) internal\r\n    {\r\n        uint[] storage list = g_ChipLib.m_TempList[iChip];\r\n        require(list.length==0 || expireTime>=list[list.length-1]);\r\n        BeforeChipObtain(iChip);\r\n        list.push(expireTime);\r\n    }\r\n\r\n    function RefreshChipUnableList(uint8 level) internal\r\n    {\r\n        uint partNum = GetPartNum(level);\r\n        for (uint iPart=1; iPart<=partNum; iPart++)\r\n        {\r\n            PartManager storage pm = GetPartManager(level,iPart);\r\n            for (uint i=pm.m_UnableList.length; i>0; i--)\r\n            {\r\n                uint32 iChip = pm.m_UnableList[i-1];\r\n                if (CanObtainChip(iChip)) {\r\n                    pm.m_IndexList.push(iChip);\r\n                    pm.m_UnableList.remove(iChip,i-1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function GenChipByWeight(uint random, uint8 level, uint[] extWeight) internal view returns(uint32)\r\n    {\r\n        uint partNum = GetPartNum(level);\r\n        uint allWeight;\r\n        uint[] memory newWeight = new uint[](partNum+1);\r\n        uint[] memory realWeight = new uint[](partNum+1);\r\n        for (uint iPart=1; iPart<=partNum; iPart++)\r\n        {\r\n            PartManager storage pm = GetPartManager(level,iPart);\r\n            uint curWeight = extWeight[iPart-1]+GetPartWeight(level,iPart);\r\n            allWeight += pm.m_IndexList.length*curWeight;\r\n            newWeight[iPart] = allWeight;\r\n            realWeight[iPart] = curWeight;\r\n        }\r\n\r\n        uint weight = random % allWeight;\r\n        for (iPart=1; iPart<=partNum; iPart++)\r\n        {\r\n            if (weight >= newWeight[iPart]) continue;\r\n            pm = GetPartManager(level,iPart);\r\n            uint idx = (weight-newWeight[iPart-1])/realWeight[iPart];\r\n            return pm.m_IndexList[idx];\r\n        }\r\n    }\r\n\r\n    function GetChipInfo(uint32 iChip) external view returns(uint32, uint8, uint8, uint, uint8, uint)\r\n    {\r\n        Chip storage obj = GetChip(iChip);\r\n        return (obj.m_Index, obj.m_Level, obj.m_LimitNum, GetPartWeight(obj.m_Level,obj.m_Part), obj.m_Part, GetChipUsedNum(iChip));\r\n    }\r\n\r\n    function GetExistsChipList() external view returns(uint32[])\r\n    {\r\n        return g_ChipLib.m_List;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract MainBonus is BasicTime,BasicAuth,MainBase,MainCard\r\n{\r\n    uint constant BASERATIO = 10000;\r\n\r\n    struct PlayerBonus\r\n    {\r\n        uint m_DrawedDay;\r\n        uint16 m_DDPermanent;// drawed day permanent\r\n        mapping(uint => uint16) m_DayStatic;\r\n        mapping(uint => uint16) m_DayPermanent;\r\n        mapping(uint => uint32[]) m_DayDynamic;\r\n    }\r\n\r\n    struct DayRatio\r\n    {\r\n        uint16 m_Static;\r\n        uint16 m_Permanent;\r\n        uint32[] m_DynamicCard;\r\n        mapping(uint32 => uint) m_CardNum;\r\n    }\r\n\r\n    struct BonusData\r\n    {\r\n        uint m_RewardBonus;//bonus pool,waiting for withdraw\r\n        uint m_RecordDay;// recordday\r\n        uint m_RecordBonus;//recordday bonus , to show\r\n        uint m_RecordPR;// recordday permanent ratio\r\n        mapping(uint => DayRatio) m_DayRatio;\r\n        mapping(uint => uint) m_DayBonus;// day final bonus\r\n        mapping(address => PlayerBonus) m_PlayerBonus;\r\n    }\r\n\r\n    BonusData g_Bonus;\r\n\r\n    constructor() public\r\n    {\r\n        g_Bonus.m_RecordDay = GetDayCount(now);\r\n    }\r\n\r\n    function() external payable {}\r\n\r\n    function NeedRefresh(uint dayNo) internal view returns(bool)\r\n    {\r\n        if (g_Bonus.m_RecordBonus == 0) return false;\r\n        if (g_Bonus.m_RecordDay == dayNo) return false;\r\n        return true;\r\n    }\r\n\r\n    function PlayerNeedRefresh(address acc, uint dayNo) internal view returns(bool)\r\n    {\r\n        if (g_Bonus.m_RecordBonus == 0) return false;\r\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\r\n        if (pb.m_DrawedDay == dayNo) return false;\r\n        return true;\r\n    }\r\n\r\n    function GetDynamicRatio(uint dayNo) internal view returns(uint tempRatio)\r\n    {\r\n        DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\r\n        for (uint i=0; i<dr.m_DynamicCard.length; i++)\r\n        {\r\n            uint32 iCard = dr.m_DynamicCard[i];\r\n            uint num = dr.m_CardNum[iCard];\r\n            Card storage oCard = GetCard(iCard);\r\n            tempRatio += num*oCard.m_DP*oCard.m_DPK/(oCard.m_DPK+num);\r\n        }\r\n    }\r\n\r\n    function GenDayRatio(uint dayNo) internal view returns(uint iDR)\r\n    {\r\n        DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\r\n        iDR += dr.m_Permanent;\r\n        iDR += dr.m_Static;\r\n        iDR += GetDynamicRatio(dayNo);\r\n    }\r\n\r\n    function GetDynamicCardNum(uint32 iCard, uint dayNo) internal view returns(uint num)\r\n    {\r\n        DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\r\n        num = dr.m_CardNum[iCard];\r\n    }\r\n\r\n    function GetPlayerDynamicRatio(address acc, uint dayNo) internal view returns(uint tempRatio)\r\n    {\r\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\r\n        DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\r\n        uint32[] storage cards = pb.m_DayDynamic[dayNo];\r\n        for (uint idx=0; idx<cards.length; idx++)\r\n        {\r\n            uint32 iCard = cards[idx];\r\n            uint num = dr.m_CardNum[iCard];\r\n            Card storage oCard = GetCard(iCard);\r\n            tempRatio += oCard.m_DP*oCard.m_DPK/(oCard.m_DPK+num);\r\n        }\r\n    }\r\n\r\n    function GenPlayerRatio(address acc, uint dayNo) internal view returns(uint tempRatio)\r\n    {\r\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\r\n        tempRatio += pb.m_DayPermanent[dayNo];\r\n        tempRatio += pb.m_DayStatic[dayNo];\r\n        tempRatio += GetPlayerDynamicRatio(acc,dayNo);\r\n    }\r\n\r\n    function RefreshDayBonus() internal\r\n    {\r\n        uint todayNo = GetDayCount(now);\r\n        if (!NeedRefresh(todayNo)) return;\r\n\r\n        uint tempBonus = g_Bonus.m_RecordBonus;\r\n        uint tempPR = g_Bonus.m_RecordPR;\r\n        uint tempRatio;\r\n        for (uint dayNo=g_Bonus.m_RecordDay; dayNo<todayNo; dayNo++)\r\n        {\r\n            tempRatio = tempPR+GenDayRatio(dayNo);\r\n            if (tempRatio == 0) continue;\r\n            DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\r\n            tempPR += dr.m_Permanent;\r\n            g_Bonus.m_DayBonus[dayNo] = tempBonus;\r\n            tempBonus -= tempBonus*tempRatio/BASERATIO;\r\n        }\r\n\r\n        g_Bonus.m_RecordPR = tempPR;\r\n        g_Bonus.m_RecordDay = todayNo;\r\n        g_Bonus.m_RecordBonus = tempBonus;\r\n    }\r\n\r\n    function QueryPlayerBonus(address acc, uint todayNo) view internal returns(uint accBonus,uint16 accPR)\r\n    {\r\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\r\n        accPR = pb.m_DDPermanent;\r\n\r\n        if (!PlayerNeedRefresh(acc, todayNo)) return;\r\n\r\n        uint tempBonus = g_Bonus.m_RecordBonus;\r\n        uint tempPR = g_Bonus.m_RecordPR;\r\n        uint dayNo = pb.m_DrawedDay;\r\n        if (dayNo == 0) return;\r\n        for (; dayNo<todayNo; dayNo++)\r\n        {\r\n            uint tempRatio = tempPR+GenDayRatio(dayNo);\r\n            if (tempRatio == 0) continue;\r\n\r\n            uint accRatio = accPR+GenPlayerRatio(acc,dayNo);\r\n            accPR += pb.m_DayPermanent[dayNo];\r\n\r\n            DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\r\n            if (dayNo >= g_Bonus.m_RecordDay) {\r\n                tempPR += dr.m_Permanent;\r\n                accBonus += tempBonus*accRatio/BASERATIO;\r\n                tempBonus -= tempBonus*tempRatio/BASERATIO;\r\n            }\r\n            else {\r\n                if (accRatio == 0) continue;\r\n                accBonus += g_Bonus.m_DayBonus[dayNo]*accRatio/BASERATIO;\r\n            }\r\n        }\r\n    }\r\n\r\n    function GetDynamicCardAmount(uint32 iCard, uint timestamp) external view returns(uint num)\r\n    {\r\n        num = GetDynamicCardNum(iCard, GetDayCount(timestamp));\r\n    }\r\n\r\n    function AddDynamicProfit(address acc, uint32 iCard, uint duration) internal\r\n    {\r\n        RefreshDayBonus();\r\n        uint todayNo = GetDayCount(now);\r\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\r\n        if (pb.m_DrawedDay == 0) pb.m_DrawedDay = todayNo;\r\n        for (uint dayNo=todayNo; dayNo<todayNo+duration; dayNo++)\r\n        {\r\n            pb.m_DayDynamic[dayNo].push(iCard);\r\n            DayRatio storage dr= g_Bonus.m_DayRatio[dayNo];\r\n            if (dr.m_CardNum[iCard] == 0) {\r\n                dr.m_DynamicCard.push(iCard);\r\n            }\r\n            dr.m_CardNum[iCard]++;\r\n        }\r\n    }\r\n\r\n    function AddStaticProfit(address acc,uint16 ratio,uint duration) internal\r\n    {\r\n        RefreshDayBonus();\r\n        uint todayNo = GetDayCount(now);\r\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\r\n        if (pb.m_DrawedDay == 0) pb.m_DrawedDay = todayNo;\r\n        if (duration == 0) {\r\n            pb.m_DayPermanent[todayNo] += ratio;\r\n            g_Bonus.m_DayRatio[todayNo].m_Permanent += ratio;\r\n        }\r\n        else {\r\n            for (uint dayNo=todayNo; dayNo<todayNo+duration; dayNo++)\r\n            {\r\n                pb.m_DayStatic[dayNo] += ratio;\r\n                g_Bonus.m_DayRatio[dayNo].m_Static += ratio;\r\n            }\r\n        }\r\n    }\r\n\r\n    function ImmediateProfit(address acc, uint ratio) internal\r\n    {\r\n        RefreshDayBonus();\r\n        uint bonus = ratio*g_Bonus.m_RecordBonus/BASERATIO;\r\n        g_Bonus.m_RecordBonus -= bonus;\r\n        g_Bonus.m_RewardBonus -= bonus;\r\n        if (bonus == 0) return\r\n        acc.transfer(bonus);\r\n    }\r\n\r\n\r\n    function ProfitByCard(address acc, uint32 iCard) internal\r\n    {\r\n        Card storage oCard = GetCard(iCard);\r\n        if (oCard.m_IP > 0) {\r\n            ImmediateProfit(acc,oCard.m_IP);\r\n        }\r\n        else if (oCard.m_SP > 0) {\r\n            AddStaticProfit(acc,oCard.m_SP,oCard.m_Duration);\r\n        }\r\n        else {\r\n            AddDynamicProfit(acc,iCard,oCard.m_Duration);\r\n        }\r\n    }\r\n\r\n    function QueryBonus() external view returns(uint)\r\n    {\r\n        uint todayNo = GetDayCount(now);\r\n        if (!NeedRefresh(todayNo)) return g_Bonus.m_RecordBonus;\r\n\r\n        uint tempBonus = g_Bonus.m_RecordBonus;\r\n        uint tempPR = g_Bonus.m_RecordPR;\r\n        uint tempRatio;\r\n        for (uint dayNo=g_Bonus.m_RecordDay; dayNo<todayNo; dayNo++)\r\n        {\r\n            tempRatio = tempPR+GenDayRatio(dayNo);\r\n            if (tempRatio == 0) continue;\r\n            DayRatio storage dr = g_Bonus.m_DayRatio[dayNo];\r\n            tempPR += dr.m_Permanent;\r\n            tempBonus -= tempBonus*tempRatio/BASERATIO;\r\n        }\r\n        return tempBonus;\r\n    }\r\n\r\n    function QueryMyBonus(address acc) external view returns(uint bonus)\r\n    {\r\n        (bonus,) = QueryPlayerBonus(acc, GetDayCount(now));\r\n    }\r\n\r\n    function AddBonus(uint bonus) external AuthAble\r\n    {\r\n        RefreshDayBonus();\r\n        g_Bonus.m_RewardBonus += bonus;\r\n        g_Bonus.m_RecordBonus += bonus;\r\n    }\r\n\r\n    function Withdraw(address acc) external\r\n    {\r\n        RefreshDayBonus();\r\n        PlayerBonus storage pb = g_Bonus.m_PlayerBonus[acc];\r\n        uint bonus;\r\n        uint todayNo = GetDayCount(now);\r\n        (bonus, pb.m_DDPermanent) = QueryPlayerBonus(acc, todayNo);\r\n        require(bonus > 0);\r\n        pb.m_DrawedDay = todayNo;\r\n        acc.transfer(bonus);\r\n        g_Bonus.m_RewardBonus -= bonus;\r\n    }\r\n\r\n    function MasterWithdraw() external\r\n    {\r\n        uint bonus = address(this).balance-g_Bonus.m_RewardBonus;\r\n        require(bonus > 0);\r\n        master.transfer(bonus);\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract MainBag is BasicTime,BasicAuth,MainChip,MainCard\r\n{\r\n    using ItemList for ItemList.Data;\r\n\r\n    struct Bag\r\n    {\r\n        ItemList.Data m_Stuff;\r\n        ItemList.Data m_TempStuff;\r\n        ItemList.Data m_Chips;\r\n        ItemList.Data m_TempCards; // temporary cards\r\n        ItemList.Data m_PermCards; // permanent cards\r\n    }\r\n\r\n    mapping(address => Bag) g_BagList;\r\n\r\n    function GainStuff(address acc, uint32 iStuff, uint iNum) external AuthAble OwnerAble(acc)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        obj.m_Stuff.add(iStuff,iNum);\r\n    }\r\n\r\n    function CostStuff(address acc, uint32 iStuff, uint iNum) external AuthAble OwnerAble(acc)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        obj.m_Stuff.sub(iStuff,iNum);\r\n    }\r\n\r\n    function GetStuffNum(address acc, uint32 iStuff) view external returns(uint)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        return obj.m_Stuff.get(iStuff);\r\n    }\r\n\r\n    function GetStuffList(address acc) external view returns(uint32[],uint[])\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        return obj.m_Stuff.list();\r\n    }\r\n\r\n    function GainTempStuff(address acc, uint32 iStuff, uint dayCnt) external AuthAble OwnerAble(acc)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        require(obj.m_TempStuff.get(iStuff) <= now);\r\n        obj.m_TempStuff.set(iStuff,now+dayCnt*DAY_SECONDS);\r\n    }\r\n\r\n    function GetTempStuffExpire(address acc, uint32 iStuff) external view returns(uint expire)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        expire = obj.m_TempStuff.get(iStuff);\r\n    }\r\n\r\n    function GetTempStuffList(address acc) external view returns(uint32[],uint[])\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        return obj.m_TempStuff.list();\r\n    }\r\n\r\n    function GainChip(address acc, uint32 iChip,bool bGenerated) external AuthAble OwnerAble(acc)\r\n    {\r\n        if (!bGenerated) {\r\n            require(CanObtainChip(iChip));\r\n            ObtainChip(iChip);\r\n        }\r\n        Bag storage obj = g_BagList[acc];\r\n        obj.m_Chips.add(iChip,1);\r\n    }\r\n\r\n    function CostChip(address acc, uint32 iChip) external AuthAble OwnerAble(acc)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        obj.m_Chips.sub(iChip,1);\r\n        CostChip(iChip);\r\n    }\r\n\r\n    function GetChipNum(address acc, uint32 iChip) external view returns(uint)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        return obj.m_Chips.get(iChip);\r\n    }\r\n\r\n    function GetChipList(address acc) external view returns(uint32[],uint[])\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        return obj.m_Chips.list();\r\n    }\r\n\r\n    function GainCard2(address acc, uint32 iCard) internal\r\n    {\r\n        Card storage oCard = GetCard(iCard);\r\n        if (oCard.m_IP > 0) return;\r\n        uint i;\r\n        uint32 iChip;\r\n        Bag storage obj = g_BagList[acc];\r\n        if (oCard.m_Duration > 0) {\r\n            // temporary\r\n            uint expireTime = GetExpireTime(now,oCard.m_Duration);\r\n            for (i=0; i<oCard.m_Parts.length; i++)\r\n            {\r\n                iChip = oCard.m_Parts[i];\r\n                AddChipTempTime(iChip,expireTime);\r\n            }\r\n            obj.m_TempCards.set(iCard,expireTime);\r\n        }\r\n        else {\r\n            // permanent\r\n            for (i=0; i<oCard.m_Parts.length; i++)\r\n            {\r\n                iChip = oCard.m_Parts[i];\r\n                ObtainChip(iChip);\r\n            }\r\n            obj.m_PermCards.set(iCard,1);\r\n        }\r\n    }\r\n\r\n    function HasCard(address acc, uint32 iCard) public view returns(bool)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        if (obj.m_TempCards.get(iCard) > now) return true;\r\n        if (obj.m_PermCards.has(iCard)) return true;\r\n        return false;\r\n    }\r\n\r\n    function GetCardList(address acc) external view returns(uint32[] tempCards, uint[] cardsTime, uint32[] permCards)\r\n    {\r\n        Bag storage obj = g_BagList[acc];\r\n        (tempCards,cardsTime) = obj.m_TempCards.list();\r\n        permCards = obj.m_PermCards.keys();\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Main is MainChip,MainCard,MainBag,MainBonus\r\n{\r\n\r\n    constructor(address Master) public\r\n    {\r\n        InitMaster(Master);\r\n    }\r\n\r\n    function GainCard(address acc, uint32 iCard) external\r\n    {\r\n        require(CardExists(iCard) && !HasCard(acc,iCard));\r\n        GainCard2(acc,iCard);\r\n        ProfitByCard(acc,iCard);\r\n    }\r\n\r\n    function GetDynamicCardAmountList(address acc) external view returns(uint[] amountList)\r\n    {\r\n        Bag storage oBag = g_BagList[acc];\r\n        uint len = oBag.m_TempCards.m_List.length;\r\n        amountList = new uint[](len);\r\n        for (uint i=0; i<len; i++)\r\n        {\r\n            uint32 iCard = oBag.m_TempCards.m_List[i];\r\n            amountList[i] = GetDynamicCardNum(iCard,GetDayCount(now));\r\n        }\r\n    }\r\n\r\n    function GenChipByRandomWeight(uint random, uint8 level, uint[] extWeight) external AuthAble returns(uint32 iChip)\r\n    {\r\n        RefreshChipUnableList(level);\r\n        iChip = GenChipByWeight(random,level,extWeight);\r\n        ObtainChip(iChip);\r\n    }\r\n\r\n    function CheckGenChip(uint32 iChip) external view returns(bool)\r\n    {\r\n        return CanObtainChip(iChip);\r\n    }\r\n\r\n    function GenChip(uint32 iChip) external AuthAble\r\n    {\r\n        require(CanObtainChip(iChip));\r\n        ObtainChip(iChip);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract StoreGifts is BasicAuth\r\n{\r\n    struct Gift\r\n    {\r\n        string m_Key;\r\n        uint m_Expire;\r\n        uint32[] m_ItemIdxList;\r\n        uint[] m_ItemNumlist;\r\n    }\r\n\r\n    mapping(address => mapping(string => bool)) g_Exchange;\r\n    mapping(string => Gift) g_Gifts;\r\n\r\n    constructor(address Master) public\r\n    {\r\n        InitMaster(Master);\r\n    }\r\n\r\n    function HasGift(string key) public view returns(bool)\r\n    {\r\n        Gift storage obj = g_Gifts[key];\r\n        if (bytes(obj.m_Key).length == 0) return false;\r\n        if (obj.m_Expire!=0 && obj.m_Expire<now) return false;\r\n        return true;\r\n    }\r\n\r\n    function AddGift(string key, uint expire, uint32[] idxList, uint[] numList) external MasterAble\r\n    {\r\n        require(!HasGift(key));\r\n        require(now<expire || expire==0);\r\n        g_Gifts[key] = Gift({\r\n            m_Key           : key,\r\n            m_Expire        : expire,\r\n            m_ItemIdxList   : idxList,\r\n            m_ItemNumlist   : numList\r\n        });\r\n    }\r\n\r\n    function DelGift(string key) external MasterAble\r\n    {\r\n        delete g_Gifts[key];\r\n    }\r\n\r\n    function GetGiftInfo(string key) external view returns(uint, uint32[], uint[])\r\n    {\r\n        Gift storage obj = g_Gifts[key];\r\n        return (obj.m_Expire, obj.m_ItemIdxList, obj.m_ItemNumlist);\r\n    }\r\n\r\n    function Exchange(address acc, string key) external OwnerAble(acc) AuthAble\r\n    {\r\n        g_Exchange[acc][key] = true;\r\n    }\r\n\r\n    function IsExchanged(address acc, string key) external view returns(bool)\r\n    {\r\n        return g_Exchange[acc][key];\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract StoreGoods is BasicAuth\r\n{\r\n    using ItemList for ItemList.Data;\r\n\r\n    struct Goods\r\n    {\r\n        uint32 m_Index;\r\n        uint32 m_CostItem;\r\n        uint32 m_ItemRef;\r\n        uint32 m_Amount;\r\n        uint32 m_Duration;\r\n        uint32 m_Expire;\r\n        uint8 m_PurchaseLimit;\r\n        uint8 m_DiscountLimit;\r\n        uint8 m_DiscountRate;\r\n        uint m_CostNum;\r\n    }\r\n\r\n    mapping(uint32 => Goods) g_Goods;\r\n    mapping(address => ItemList.Data) g_PurchaseInfo;\r\n\r\n    constructor(address Master) public\r\n    {\r\n        InitMaster(Master);\r\n    }\r\n\r\n    function AddGoods(\r\n        uint32 iGoods,\r\n        uint32 costItem,\r\n        uint price,\r\n        uint32 itemRef,\r\n        uint32 amount,\r\n        uint32 duration,\r\n        uint32 expire,\r\n        uint8 limit,\r\n        uint8 disCount,\r\n        uint8 disRate\r\n    ) external MasterAble\r\n    {\r\n        require(!HasGoods(iGoods));\r\n        g_Goods[iGoods] = Goods({\r\n            m_Index         :iGoods,\r\n            m_CostItem      :costItem,\r\n            m_ItemRef       :itemRef,\r\n            m_CostNum       :price,\r\n            m_Amount        :amount,\r\n            m_Duration      :duration,\r\n            m_Expire        :expire,\r\n            m_PurchaseLimit :limit,\r\n            m_DiscountLimit :disCount,\r\n            m_DiscountRate  :disRate\r\n        });\r\n    }\r\n\r\n    function DelGoods(uint32 iGoods) external MasterAble\r\n    {\r\n        delete g_Goods[iGoods];\r\n    }\r\n\r\n    function HasGoods(uint32 iGoods) public view returns(bool)\r\n    {\r\n        Goods storage obj = g_Goods[iGoods];\r\n        return obj.m_Index == iGoods;\r\n    }\r\n\r\n    function GetGoodsInfo(uint32 iGoods) external view returns(\r\n        uint32,uint32,uint32,uint32,uint32,uint,uint8,uint8,uint8\r\n    )\r\n    {\r\n        Goods storage obj = g_Goods[iGoods];\r\n        return (\r\n            obj.m_Index,\r\n            obj.m_CostItem,\r\n            obj.m_ItemRef,\r\n            obj.m_Amount,\r\n            obj.m_Duration,\r\n            obj.m_CostNum,\r\n            obj.m_PurchaseLimit,\r\n            obj.m_DiscountLimit,\r\n            obj.m_DiscountRate\r\n        );\r\n    }\r\n\r\n    function GetRealCost(address acc, uint32 iGoods) external view returns(uint)\r\n    {\r\n        Goods storage obj = g_Goods[iGoods];\r\n        if (g_PurchaseInfo[acc].get(iGoods) >= obj.m_DiscountLimit) {\r\n            return obj.m_CostNum;\r\n        }\r\n        else {\r\n            return obj.m_CostNum * obj.m_DiscountRate / 100;\r\n        }\r\n    }\r\n\r\n    function BuyGoods(address acc, uint32 iGoods) external OwnerAble(acc) AuthAble\r\n    {\r\n        g_PurchaseInfo[acc].add(iGoods,1);\r\n    }\r\n\r\n    function IsOnSale(uint32 iGoods) external view returns(bool)\r\n    {\r\n        Goods storage obj = g_Goods[iGoods];\r\n        if (obj.m_Expire == 0) return true;\r\n        if (obj.m_Expire >= now) return true;\r\n        return false;\r\n    }\r\n\r\n    function CheckPurchaseCount(address acc, uint32 iGoods) external view returns(bool)\r\n    {\r\n        Goods storage obj = g_Goods[iGoods];\r\n        if (obj.m_PurchaseLimit == 0) return true;\r\n        if (g_PurchaseInfo[acc].get(iGoods) < obj.m_PurchaseLimit) return true;\r\n        return false;\r\n    }\r\n\r\n    function GetPurchaseInfo(address acc) external view returns(uint32[], uint[])\r\n    {\r\n        return g_PurchaseInfo[acc].list();\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Child is Base {\r\n\r\n    Main g_Main;\r\n\r\n    constructor(Main main) public\r\n    {\r\n        require(main != address(0));\r\n        g_Main = main;\r\n        g_Main.SetAuth(this);\r\n    }\r\n\r\n    function kill() external MasterAble\r\n    {\r\n        g_Main.ClearAuth(this);\r\n        selfdestruct(creator);\r\n    }\r\n\r\n    function AddBonus(uint percent) internal\r\n    {\r\n        address(g_Main).transfer(msg.value);\r\n        g_Main.AddBonus(msg.value * percent / 100);\r\n    }\r\n\r\n    function GenRandom(uint seed,uint base) internal view returns(uint,uint)\r\n    {\r\n        uint r = uint(keccak256(abi.encodePacked(msg.sender,seed,now)));\r\n        if (base != 0) r %= base;\r\n        return (r,seed+1);\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n\r\ncontract Store is Child\r\n{\r\n    uint constant BONUS_PERCENT_PURCHASE = 80;\r\n    uint constant CHIPGIFT_NORMALCHIP_RATE = 10000;\r\n    uint32 constant CHIPGIFT_ITEMINDEX = 24001;\r\n\r\n    uint8 constant EXCHANGE_OK = 0;\r\n    uint8 constant EXCHANGE_KEYERR = 1;\r\n    uint8 constant EXCHANGE_HADGOT = 2;\r\n\r\n    StoreGoods g_Goods;\r\n    StoreGifts g_Gifts;\r\n\r\n    constructor(Main main, StoreGoods goods, StoreGifts gifts) public Child(main)\r\n    {\r\n        g_Goods = goods;\r\n        g_Gifts = gifts;\r\n        g_Goods.SetAuth(this);\r\n        g_Gifts.SetAuth(this);\r\n    }\r\n    \r\n    function kill() external MasterAble\r\n    {\r\n        g_Goods.ClearAuth(this);\r\n    }\r\n\r\n    function GenExtWeightList(uint8 level) internal pure returns(uint[] extList)\r\n    {\r\n        uint partNum = GetPartNum(level);\r\n        extList = new uint[](partNum);\r\n        for (uint i=0; i<partNum; i++)\r\n        {\r\n            uint iPart = i+1;\r\n            if (!IsLimitPart(level,iPart)) {\r\n                extList[i] = GetPartWeight(level, iPart)*CHIPGIFT_NORMALCHIP_RATE;\r\n            }\r\n        }\r\n    }\r\n\r\n    function GiveChipGitf() internal\r\n    {\r\n        for (uint8 level=HEROLEVEL_MIN; level<=HEROLEVEL_MAX; level++)\r\n        {\r\n            (uint random,) = GenRandom(level, 0);\r\n            uint32 iChip = g_Main.GenChipByRandomWeight(random, level, GenExtWeightList(level));\r\n            g_Main.GainChip(msg.sender, iChip, true);\r\n        }\r\n    }\r\n\r\n    function BuyGoods(uint32 iGoods) external payable\r\n    {\r\n        require(g_Goods.HasGoods(iGoods));\r\n        require(g_Goods.IsOnSale(iGoods));\r\n        require(g_Goods.CheckPurchaseCount(msg.sender, iGoods));\r\n        (,uint32 iCostItem,uint32 iItemRef,uint32 iAmount,uint32 iDuration,,,,) = g_Goods.GetGoodsInfo(iGoods);\r\n        uint iCostNum = g_Goods.GetRealCost(msg.sender, iGoods);\r\n        if (iCostItem == 0) {\r\n            // cost ether(wei)\r\n            require(msg.value == iCostNum);\r\n            AddBonus(BONUS_PERCENT_PURCHASE);\r\n        }\r\n        else {\r\n            // cost other stuff\r\n            g_Main.CostStuff(msg.sender,iCostItem,iCostNum);\r\n        }\r\n        g_Goods.BuyGoods(msg.sender, iGoods);\r\n        if (iItemRef == CHIPGIFT_ITEMINDEX) {\r\n            GiveChipGitf();\r\n        }\r\n        else {\r\n            if (iDuration == 0) {\r\n                g_Main.GainStuff(msg.sender, iItemRef, iAmount);\r\n            }\r\n            else {\r\n                g_Main.GainTempStuff(msg.sender, iItemRef, iDuration);\r\n            }\r\n        }\r\n    }\r\n\r\n    function GetPurchaseInfo() external view returns(uint32[] goodsList, uint[] purchaseCountList)\r\n    {\r\n        (goodsList, purchaseCountList) = g_Goods.GetPurchaseInfo(msg.sender);\r\n    }\r\n\r\n    function CheckExchange(string key) public view returns(uint8)\r\n    {\r\n        if (!g_Gifts.HasGift(key)) return EXCHANGE_KEYERR;\r\n        if (g_Gifts.IsExchanged(msg.sender, key)) return EXCHANGE_HADGOT;\r\n        return EXCHANGE_OK;\r\n    }\r\n\r\n    function ExchangeGift(string key) external\r\n    {\r\n        require(CheckExchange(key) == EXCHANGE_OK);\r\n        g_Gifts.Exchange(msg.sender, key);\r\n        (, uint32[] memory idxList, uint[] memory numList) = g_Gifts.GetGiftInfo(key);\r\n        for (uint i=0; i<idxList.length; i++)\r\n        {\r\n            g_Main.GainStuff(msg.sender, idxList[i], numList[i]);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"iGoods\",\"type\":\"uint32\"}],\"name\":\"BuyGoods\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"}],\"name\":\"ExchangeGift\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetPurchaseInfo\",\"outputs\":[{\"name\":\"goodsList\",\"type\":\"uint32[]\"},{\"name\":\"purchaseCountList\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"string\"}],\"name\":\"CheckExchange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"main\",\"type\":\"address\"},{\"name\":\"goods\",\"type\":\"address\"},{\"name\":\"gifts\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Store","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e4d0c33807b4180fcbd3acff8ef0bf97cda7b9a5000000000000000000000000d083713e4d9bc1e4c923795f9f6ce2a97646c11600000000000000000000000028ca75ec687f08d7b606bce1d013b2fdf944df19","Library":"","SwarmSource":"bzzr://cd3b8e071e7417d8eb250bbe194575199a2c20c8c78308c704b6f9d546acc314"}]}