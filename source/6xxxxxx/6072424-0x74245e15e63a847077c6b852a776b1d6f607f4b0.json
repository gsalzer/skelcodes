{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract PoP{\r\n\tusing SafeMath for uint256;\r\n\tusing SafeInt for int256;\r\n\tusing Player for Player.Data;\r\n\tusing BettingRecordArray for BettingRecordArray.Data;\r\n\tusing WrappedArray for WrappedArray.Data;\r\n\tusing FixedPoint for FixedPoint.Data;\r\n\r\n\t// Contract Info\r\n\tstring public name;\r\n  \tstring public symbol;\r\n  \tuint8 public decimals;\r\n  \taddress private author;\r\n\t\r\n  \t// Events for Game\r\n  \tevent Bet(address player, uint256 betAmount, uint256 betNumber, uint256 gameNumber);\r\n\tevent Withdraw(address player, uint256 amount, uint256 numberOfRecordsProcessed);\r\n\tevent EndGame(uint256 currentGameNumber);\t\r\n\r\n\t// Events for Coin\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed owner, address indexed spender, uint256 value);\r\n\tevent Burn(address indexed burner, uint256 value);\r\n\tevent Mined(address indexed miner, uint256 value);\r\n\r\n\t// Init\r\n\tfunction PoP() public {\r\n\t\tname = \"PopCoin\"; \r\n    \tsymbol = \"PoP\"; \r\n    \tdecimals = 18;\r\n    \tauthor = msg.sender;\r\n    \ttotalSupply_ = 10000000 * 10 ** uint256(decimals);\r\n    \tlastBetBlockNumber = 0;\r\n    \tcurrentGameNumber = 0;\r\n    \tcurrentPot = 0;\r\n    \tinitialSeed = 0;\r\n\t\tminimumWager = kBaseMinBetSize.toUInt256Raw();\r\n    \tminimumNumberOfBlocksToEndGame = kLowerBoundBlocksTillGameEnd.add(kUpperBoundBlocksTillGameEnd).toUInt256Raw();\r\n    \tgameHasStarted = false;\r\n    \tcurrentMiningDifficulty = FixedPoint.fromInt256(kStartingGameMiningDifficulty);\r\n\t\tunPromisedSupplyAtStartOfCurrentGame_ = totalSupply_;\r\n\t\tnextGameMaxBlock = kUpperBoundBlocksTillGameEnd;\r\n\t\tnextGameMinBlock = kLowerBoundBlocksTillGameEnd;\r\n    \tcurrentGameInitialMinBetSize = kBaseMinBetSize;\r\n\t}\r\n\r\n\r\n\t// Constants\r\n\tFixedPoint.Data _2pi = FixedPoint.Data({val: 26986075409});\r\n\tFixedPoint.Data _pi = FixedPoint.Data({val: 13493037704});\r\n\tFixedPoint.Data frontWindowAdjustmentRatio = FixedPoint.fromFraction(14, 10); // MC: \r\n\tFixedPoint.Data backWindowAdjustmentRatio = FixedPoint.fromFraction(175, 100); // MC: \r\n\tFixedPoint.Data kBackPayoutEndPointInitial = FixedPoint.fromFraction(1, 2);\r\n\tFixedPoint.Data kFrontPayoutStartPointInitial = FixedPoint.fromFraction(1, 2);\r\n\tuint256 constant kPercentToTakeAsRake = 3; // MC\r\n\tuint256 constant kPercentToTakeAsSeed = 9; // MC\r\n\tuint256 constant kDeveloperMiningPower = 30; // MC\r\n\tuint256 constant kTotalPercent = 100; \r\n\tuint8 constant kStartingGameMiningDifficulty = 1;\r\n\tuint8 constant kDifficultyWindow = 10; // MC\r\n\tFixedPoint.Data kDifficultyDropOffFactor = FixedPoint.fromFraction(8, 10); // MC\r\n\tuint256 constant kWeiConstant = 10 ** 18;\r\n\tFixedPoint.Data kExpectedFirstGameSize = FixedPoint.fromInt256(Int256(10 * kWeiConstant));\r\n\tFixedPoint.Data kExpectedPopCoinToBePromisedPercent = FixedPoint.fromFraction(1, 1000); // MC\r\n\tFixedPoint.Data kLowerBoundBlocksTillGameEnd = FixedPoint.fromInt256(6); // MC\r\n\tFixedPoint.Data kUpperBoundBlocksTillGameEnd = FixedPoint.fromInt256(80); // MC\r\n\tFixedPoint.Data kBaseMinBetSize = FixedPoint.fromInt256(Int256(kWeiConstant/1000)); //MC\r\n\tFixedPoint.Data kMaxPopMiningPotMultiple = FixedPoint.fromFraction(118709955, 1000000); // MC\r\n\r\n\r\n\t// Public Variables\r\n\tuint256 public lastBetBlockNumber;\r\n\tuint256 public minimumNumberOfBlocksToEndGame;\r\n\tuint256 public currentPot;\r\n\tuint256 public currentGameNumber;\r\n\tFixedPoint.Data currentMiningDifficulty;\r\n\tuint256 public initialSeed;\r\n\r\n\r\n\t// Game Private Variables\r\n\tmapping (address => Player.Data) playerCollection;\r\n\tBettingRecordArray.Data currentGameBettingRecords;\r\n\tWrappedArray.Data gameMetaData;\r\n\tmapping (address => uint256) playerInternalWallet;\r\n\tFixedPoint.Data public initialBankrollGrowthAmount; // This is what the current pot will be compared to\r\n\tFixedPoint.Data nextGameInitialMinBetSize;\r\n\tFixedPoint.Data currentGameInitialMinBetSize;\r\n\tFixedPoint.Data nextGameMaxBlock;\r\n\tFixedPoint.Data nextGameMinBlock;\r\n\tuint256 bonusSeed;\r\n\tuint256 minimumWager;\r\n\tuint256 currentBetNumber;\r\n\r\n\t// Coin Private Variables\r\n\tmapping(address => uint256) popBalances;\r\n\tmapping (address => mapping (address => uint256)) internal allowed;\r\n\tuint256 totalSupply_;\r\n\tuint256 supplyMined_;\r\n\tuint256 supplyBurned_;\r\n\tuint256 unPromisedSupplyAtStartOfCurrentGame_;\r\n\tbool gameHasStarted;\r\n\r\n\tfunction startGame () payable public {\r\n\t\trequire (msg.sender == author);\r\n\t\trequire (msg.value > 0);\r\n\t\trequire (gameHasStarted == false);\r\n\t\t\r\n\t\tinitialSeed = initialSeed.add(msg.value);\r\n\t\tcurrentPot = initialSeed;\r\n\t\tgameHasStarted = true;\r\n\t}\r\n\r\n\tfunction updateNextGameMinAndMaxBlockUntilGameEnd (uint256 maxBlocks, uint256 minBlocks) public {\r\n\t\trequire (msg.sender == author);\r\n\t\trequire (maxBlocks > 0);\r\n\t\trequire (minBlocks > 0);\r\n\t\tFixedPoint.Data memory nextMaxBlock = FixedPoint.fromInt256(Int256(maxBlocks));\r\n\t\tFixedPoint.Data memory nextMinBlock = FixedPoint.fromInt256(Int256(minBlocks));\r\n\t\trequire(nextMaxBlock.cmp(kUpperBoundBlocksTillGameEnd.mul(FixedPoint.fromInt256(2))) != 1);\r\n\t\trequire(nextMaxBlock.cmp(kUpperBoundBlocksTillGameEnd.div(FixedPoint.fromInt256(2))) != -1);\r\n\t\trequire(nextMinBlock.cmp(kLowerBoundBlocksTillGameEnd.mul(FixedPoint.fromInt256(2))) != 1);\r\n\t\trequire(nextMaxBlock.cmp(kLowerBoundBlocksTillGameEnd.div(FixedPoint.fromInt256(2))) != -1);\r\n\r\n\t\tnextGameMaxBlock = FixedPoint.fromInt256(Int256(maxBlocks));\r\n\t\tnextGameMinBlock = FixedPoint.fromInt256(Int256(minBlocks));\r\n\t}\r\n\r\n\tfunction addToRakePool () public payable{\r\n\t\tassert (msg.value > 0);\r\n\t\tplayerInternalWallet[this] = playerInternalWallet[this].add(msg.value);\r\n\t}\r\n\r\n\t// Public API\r\n\tfunction bet () payable public {\r\n\t\t// require bet be large enough\r\n\t\trequire(msg.value >= minimumWager); \r\n\t\trequire(gameHasStarted);\r\n\r\n\t\tuint256 betAmount = msg.value;\r\n\r\n\t\t// take rake\r\n\t\tbetAmount = betAmountAfterRakeHasBeenWithdrawnAndProcessed(betAmount);\r\n\r\n\t\tif((block.number.sub(lastBetBlockNumber) >= minimumNumberOfBlocksToEndGame) && (lastBetBlockNumber != 0)) {\r\n\t\t\tprocessEndGame(betAmount);\r\n\t\t} else if (lastBetBlockNumber == 0) {\r\n\t\t\tinitialBankrollGrowthAmount = FixedPoint.fromInt256(Int256(betAmount.add(initialSeed)));\r\n\t\t}\r\n\r\n\t\temit Bet(msg.sender, betAmount, currentBetNumber, currentGameNumber);\r\n\r\n\t\tPlayer.BettingRecord memory newBetRecord = Player.BettingRecord(msg.sender, currentGameNumber, betAmount, currentBetNumber, currentPot.sub(initialSeed), 0, 0, true); \r\n\r\n\t\tPlayer.Data storage currentPlayer = playerCollection[msg.sender];\r\n\r\n\t\tcurrentPlayer.insertBettingRecord(newBetRecord);\r\n\r\n\t\tPlayer.BettingRecord memory oldGameUnprocessedBettingRecord = currentGameBettingRecords.getNextRecord();\r\n\r\n\t\tcurrentGameBettingRecords.pushRecord(newBetRecord);\r\n\r\n\t\tif(oldGameUnprocessedBettingRecord.isActive == true) {\r\n\t\t\tprocessBettingRecord(oldGameUnprocessedBettingRecord);\r\n\t\t}\r\n\r\n\t\tcurrentPot = currentPot.add(betAmount);\r\n\t\tcurrentBetNumber = currentBetNumber.add(1);\r\n\t\tlastBetBlockNumber = block.number;\r\n\t\tFixedPoint.Data memory currentGameSize = FixedPoint.fromInt256(Int256(currentPot));\r\n\t\tFixedPoint.Data memory expectedGameSize = currentMiningDifficulty.mul(kExpectedFirstGameSize);\r\n\t\tminimumNumberOfBlocksToEndGame = calcNumberOfBlocksUntilGameEnds(currentGameSize, expectedGameSize).toUInt256Raw();\r\n\t\tminimumWager = calcMinimumBetSize(currentGameSize, expectedGameSize).toUInt256Raw();\r\n\t}\r\n\r\n\tfunction getMyBetRecordCount() public view returns(uint256) {\r\n\t\tPlayer.Data storage currentPlayer = playerCollection[msg.sender];\r\n\t\treturn currentPlayer.unprocessedBettingRecordCount();\r\n\t}\r\n\t\r\n\t\r\n\tfunction playerPopMining(uint256 recordIndex, bool onlyCurrentGame) public view returns(uint256) {\r\n\t\tPlayer.Data storage currentPlayer = playerCollection[msg.sender];\r\n\t\treturn computeAmountToMineForBettingRecord(currentPlayer.getBettingRecordAtIndex(recordIndex), onlyCurrentGame).mul(kTotalPercent - kDeveloperMiningPower).div(kTotalPercent);\r\n\t}\r\n\r\n\tfunction getBetRecord(uint256 recordIndex) public view returns(uint256, uint256, uint256) {\r\n\t\tPlayer.Data storage currentPlayer = playerCollection[msg.sender];\r\n\t\tPlayer.BettingRecord memory bettingRecord = currentPlayer.getBettingRecordAtIndex(recordIndex);\r\n\t\treturn (bettingRecord.gamePotBeforeBet, bettingRecord.wagerAmount, bettingRecord.gameId);\r\n\t}\r\n\r\n\tfunction withdraw (uint256 withdrawCount) public returns(bool res) {\r\n\t\tPlayer.Data storage currentPlayer = playerCollection[msg.sender];\r\n\r\n\t\tuint256 playerBettingRecordCount = currentPlayer.unprocessedBettingRecordCount();\r\n\t\tuint256 numberOfIterations = withdrawCount < playerBettingRecordCount ? withdrawCount : playerBettingRecordCount;\r\n\t\tif(numberOfIterations == 0) {return;}\r\n\r\n\t\tnumberOfIterations = numberOfIterations.add(1);\r\n\r\n\t\tfor (uint256 i = 0 ; i < numberOfIterations; i = i.add(1)) {\r\n\t\t\tPlayer.BettingRecord memory unprocessedRecord = currentPlayer.getNextRecord();\r\n\t\t\tprocessBettingRecord(unprocessedRecord);\r\n\t\t}\r\n\r\n\t\tuint256 playerBalance = playerInternalWallet[msg.sender];\r\n\r\n\t\t\r\n\t\tplayerInternalWallet[msg.sender] = 0;\r\n\r\n\t\tif(playerBalance == 0) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\r\n\t\temit Withdraw(msg.sender, playerBalance, numberOfIterations);\r\n\r\n\t\tif(!msg.sender.send(playerBalance)) {\r\n\t\t\t//If money shipment fails store money back in the container\r\n\t\t\tplayerInternalWallet[msg.sender] = playerBalance;\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\treturn true;\r\n\t}\r\n\r\n\r\n\tfunction getCurrentMiningDifficulty() public view returns(uint256){\r\n\t\treturn UInt256(currentMiningDifficulty.toInt256());\r\n\t}\r\n\r\n\tfunction getPlayerInternalWallet() public view returns(uint256) {\r\n\t\treturn playerInternalWallet[msg.sender];\r\n\t}\r\n\r\n\tfunction getWinningsForRecordId(uint256 recordIndex, bool onlyWithdrawable, bool onlyCurrentGame) public view returns(uint256) {\r\n\t\tPlayer.Data storage currentPlayer = playerCollection[msg.sender];\r\n\t\tPlayer.BettingRecord memory record = currentPlayer.getBettingRecordAtIndex(recordIndex);\r\n\t\tif(onlyCurrentGame && record.gameId != currentGameNumber) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn getWinningsForRecord(record, onlyWithdrawable);\r\n\t}\r\n\r\n\tfunction getWinningsForRecord(Player.BettingRecord record, bool onlyWithdrawable) private view returns(uint256) {\r\n\r\n\t\tif(onlyWithdrawable && recordIsTooNewToProcess(record)) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 payout = getPayoutForPlayer(record).toUInt256Raw();\r\n\t\tpayout = payout.sub(amountToSeedNextRound(payout));\r\n\t\treturn payout.sub(record.withdrawnAmount);\r\n\r\n\t}\r\n\r\n\tfunction totalAmountRaked ()  public constant returns(uint256 res) {\r\n\t\treturn playerInternalWallet[this];\r\n\t}\r\n\r\n\tfunction betAmountAfterRakeHasBeenWithdrawnAndProcessed (uint256 betAmount) private returns(uint256 betLessRake){\r\n\t\tuint256 amountToRake = amountToTakeAsRake(betAmount);\r\n\t\tplayerInternalWallet[this] = playerInternalWallet[this].add(amountToRake);\r\n\t\treturn betAmount.sub(amountToRake);\r\n\t}\r\n\t\r\n\tfunction amountToSeedNextRound (uint256 value) private pure returns(uint256 res) {\r\n\t\treturn value.mul(kPercentToTakeAsSeed).div(kTotalPercent);\r\n\t}\r\n\r\n\tfunction addToBonusSeed () public payable {\r\n\t\trequire (msg.value > 0);\r\n\t\tbonusSeed = bonusSeed.add(msg.value);\r\n\t}\r\n\t\r\n\r\n\tfunction amountToTakeAsRake (uint256 value) private pure returns(uint256 res) {\r\n\t\treturn value.mul(kPercentToTakeAsRake).div(kTotalPercent);\r\n\t}\r\n\r\n\tfunction amountOfPopDeveloperShouldMine (uint256 value) private pure returns(uint256 res) {\r\n\t\treturn value.mul(kDeveloperMiningPower).div(kTotalPercent);\r\n\t}\r\n\r\n\tfunction processEndGame (uint256 lastBetAmount) private {\r\n\t\t// The order of these function calls are dependent on each other\r\n\t\t// Beware when changing order or modifying code \r\n\t\temit EndGame(currentGameNumber);\r\n\t\t// Store game meta Data\r\n\t\tgameMetaData.push(WrappedArray.GameMetaDataElement(currentPot, initialSeed, initialBankrollGrowthAmount.toUInt256Raw(), unPromisedSupplyAtStartOfCurrentGame_, currentMiningDifficulty, true));\r\n\r\n\t\tkUpperBoundBlocksTillGameEnd = nextGameMaxBlock;\r\n\t\tkLowerBoundBlocksTillGameEnd = nextGameMinBlock;\r\n\r\n\t\tunPromisedSupplyAtStartOfCurrentGame_ = unPromisedPop();\r\n\r\n\t\tinitialSeed = amountToSeedNextRound(currentPot).add(bonusSeed);\r\n\t\tbonusSeed = 0;\r\n\t\tcurrentPot = initialSeed;\r\n\t\tcurrentMiningDifficulty = calcDifficulty();\r\n\r\n\t\t// Set initial bet which will calculate the growth factor \r\n\t\tinitialBankrollGrowthAmount = FixedPoint.fromInt256(Int256(lastBetAmount.add(initialSeed)));\r\n\r\n\t\t// Reset current game array \r\n\t\tcurrentGameBettingRecords.resetIndex();\r\n\r\n\t\t// increment game number\r\n\t\tcurrentGameNumber = currentGameNumber.add(1);\r\n\t}\r\n\r\n\tfunction processBettingRecord (Player.BettingRecord record) private {\r\n\t\tPlayer.Data storage currentPlayer = playerCollection[record.playerAddress];\r\n\t\tif(currentPlayer.containsBettingRecordFromId(record.bettingRecordId) == false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Refetch record as player might have withdrawn part\r\n\t\tPlayer.BettingRecord memory bettingRecord = currentPlayer.getBettingRecordForId(record.bettingRecordId);\r\n\r\n\t\tcurrentPlayer.deleteBettingRecordForId(bettingRecord.bettingRecordId);\r\n\r\n\t\t// this assumes compute for value returns total value of record less withdrawnAmount\r\n\t\tuint256 bettingRecordValue = getWinningsForRecord(bettingRecord, true);\r\n\t\tuint256 amountToMineForBettingRecord = computeAmountToMineForBettingRecord(bettingRecord, false);\r\n\r\n\t\t// If it is current game we need to not remove the record as it's value might increase but amend it and re-insert\r\n\t\tif(bettingRecord.gameId == currentGameNumber) {\r\n\t\t\tbettingRecord.withdrawnAmount = bettingRecord.withdrawnAmount.add(bettingRecordValue);\r\n\t\t\tbettingRecord.withdrawnPopAmount = bettingRecord.withdrawnPopAmount.add(amountToMineForBettingRecord);\r\n\t\t\tcurrentPlayer.insertBettingRecord(bettingRecord);\r\n\t\t}\r\n\t\tminePoP(bettingRecord.playerAddress, amountToMineForBettingRecord);\r\n\t\tplayerInternalWallet[bettingRecord.playerAddress] = playerInternalWallet[bettingRecord.playerAddress].add(bettingRecordValue);\r\n\t}\r\n\r\n\tfunction potAmountForRecord (Player.BettingRecord record) private view returns(uint256 potAmount) {\r\n\t\trequire(record.gameId <= currentGameNumber);\r\n\t\tif(record.gameId < currentGameNumber) {\r\n\t\t\treturn gameMetaData.itemAtIndex(record.gameId).totalPotAmount; \r\n\t\t} else {\r\n\t\t\treturn currentPot;\r\n\t\t} \r\n\t}\r\n\r\n\t// This means it is in the front of payout (i.e. one of the last bets)\r\n\tfunction recordIsTooNewToProcess (Player.BettingRecord record) private view returns(bool res) {\r\n\t\tuint256 potAtBet = record.gamePotBeforeBet.add(record.wagerAmount);\r\n\r\n\t\tif(record.gameId == currentGameNumber) {\r\n\t\t\tuint256 halfPot = currentPot.sub(initialSeed).div(2);\r\n\t\t\tif(potAtBet >= halfPot) {\r\n\t\t\t\treturn true; // You are in the front of the array and we won't process your record until you are in the back\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\r\n\tfunction UInt256 (int256 elem) private pure returns(uint256 res) {\r\n\t\tassert(elem >= 0);\r\n\t\treturn uint256(elem);\r\n\t}\r\n\t\r\n\tfunction Int256 (uint256 elem) private pure returns(int256 res) {\r\n\t\tassert(int256(elem) >= 0);\r\n\t\treturn int256(elem);\r\n\t}\r\n\t\r\n\tfunction getBankRollGrowthForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\r\n\t\tif(gameId == currentGameNumber) {\r\n\t\t\treturn FixedPoint.fromInt256(Int256(currentPot)).div(initialBankrollGrowthAmount);\r\n\t\t} else {\r\n\t\t\tWrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\r\n\t\t\treturn FixedPoint.fromInt256(Int256(elem.totalPotAmount)).div(FixedPoint.fromInt256(Int256(elem.initialBet)));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getSeedAmountForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\r\n\t\tif(gameId == currentGameNumber) {\r\n\t\t\treturn FixedPoint.fromInt256(Int256(initialSeed));\r\n\t\t} else {\r\n\t\t\tWrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\r\n\t\t\treturn FixedPoint.fromInt256(Int256(elem.seedAmount));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPayoutForPlayer(Player.BettingRecord playerRecord) internal view returns (FixedPoint.Data) {\r\n\r\n\t\tFixedPoint.Data memory frontWindowAdjustment = getWindowAdjustmentForGameIdAndRatio(playerRecord.gameId, frontWindowAdjustmentRatio);\r\n\t\tFixedPoint.Data memory backWindowAdjustment = getWindowAdjustmentForGameIdAndRatio(playerRecord.gameId, backWindowAdjustmentRatio);\r\n\t\tFixedPoint.Data memory backPayoutEndPoint = kBackPayoutEndPointInitial.div(backWindowAdjustment);\r\n\t\tFixedPoint.Data memory frontPayoutSizePercent = kFrontPayoutStartPointInitial.div(frontWindowAdjustment);\r\n        FixedPoint.Data memory frontPayoutStartPoint = FixedPoint.fromInt256(1).sub(frontPayoutSizePercent);\r\n\r\n        FixedPoint.Data memory potAmountData = FixedPoint.fromInt256(Int256(potAmountForRecord(playerRecord)));\r\n\r\n\t\tFixedPoint.Data memory frontPercent = FixedPoint.fromInt256(0);\r\n\t\tif(playerRecord.gamePotBeforeBet != 0) {\r\n\t\t\tfrontPercent = FixedPoint.fromInt256(Int256(playerRecord.gamePotBeforeBet)).div(potAmountData.sub(getSeedAmountForGameId(playerRecord.gameId)));\r\n\t\t}\r\n\r\n\t\tFixedPoint.Data memory backPercent = FixedPoint.fromInt256(Int256(playerRecord.gamePotBeforeBet)).add(FixedPoint.fromInt256(Int256(playerRecord.wagerAmount))).div(potAmountData.sub(getSeedAmountForGameId(playerRecord.gameId)));\r\n\r\n\t\tif(frontPercent.val < backPayoutEndPoint.val) {\r\n\t\t    if(backPercent.val <= backPayoutEndPoint.val) {\r\n\t\t    \t// Bet started in left half of curve and ended left half of curve \r\n\t\t        return calcWinnings(frontPercent, backPercent, backPayoutEndPoint, _pi.div(backWindowAdjustment), backWindowAdjustment, FixedPoint.fromInt256(0), potAmountData);\r\n\t\t    } else if (backPercent.val <= frontPayoutStartPoint.val) {\r\n\t\t    \t// Bet started in left half of curve and ended in deadzone between curves\r\n\t\t        return calcWinnings(frontPercent, backPayoutEndPoint, backPayoutEndPoint, _pi.div(backWindowAdjustment), backWindowAdjustment, FixedPoint.fromInt256(0), potAmountData);\r\n\t\t    } else {\r\n\t\t    \t// Bet started in left half of curve and ended right half of curve \r\n\t\t        return calcWinnings(frontPercent, backPayoutEndPoint, backPayoutEndPoint, _pi.div(backWindowAdjustment), backWindowAdjustment, FixedPoint.fromInt256(0), potAmountData).add(calcWinnings(FixedPoint.fromInt256(0), backPercent.sub(frontPayoutStartPoint), frontPayoutSizePercent, _pi.div(frontWindowAdjustment), frontWindowAdjustment, _pi.div(frontWindowAdjustment), potAmountData));\r\n\t\t    }\r\n\t\t} else if (frontPercent.val < frontPayoutStartPoint.val) {\r\n\t\t    if (backPercent.val <= frontPayoutStartPoint.val) {\r\n\t\t    \t// Bet started in dead zone and ended in dead zone\r\n\t\t        return FixedPoint.fromInt256(0);\r\n\t\t    } else {\r\n\t\t    \t// Bet started in deadzone and ended in right hand of curve\r\n\t\t        return calcWinnings(FixedPoint.fromInt256(0), backPercent.sub(frontPayoutStartPoint), frontPayoutSizePercent, _pi.div(frontWindowAdjustment), frontWindowAdjustment, _pi.div(frontWindowAdjustment), potAmountData);\r\n\t\t    }\r\n\t\t} else {\r\n\t\t\t// Bet started in right hand of curve and of course ended in right hand of curve\r\n\t\t    return calcWinnings(frontPercent.sub(frontPayoutStartPoint), backPercent.sub(frontPayoutStartPoint), frontPayoutSizePercent, _pi.div(frontWindowAdjustment), frontWindowAdjustment, _pi.div(frontWindowAdjustment), potAmountData);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getWindowAdjustmentForGameIdAndRatio(uint256 gameId, FixedPoint.Data adjustmentRatio) internal view returns (FixedPoint.Data) {\r\n\t\tFixedPoint.Data memory growth = getBankRollGrowthForGameId(gameId);\r\n\t\tFixedPoint.Data memory logGrowthRate = growth.ln();\r\n\t\treturn growth.div(adjustmentRatio.pow(logGrowthRate));\r\n\t}\r\n\r\n\tfunction integrate(FixedPoint.Data x, FixedPoint.Data a) internal pure returns (FixedPoint.Data) {\r\n\t\treturn a.mul(x).sin().div(a).add(x);\r\n\t}\r\n\r\n\tfunction calcWinnings(FixedPoint.Data playerFrontPercent, FixedPoint.Data playerBackPercent, FixedPoint.Data sectionPercentSize, FixedPoint.Data sectionRadiansSize, FixedPoint.Data windowAdjustment, FixedPoint.Data sectionOffset, FixedPoint.Data potSize) internal view returns (FixedPoint.Data) {\r\n\t\tFixedPoint.Data memory startIntegrationPoint = sectionOffset.add(playerFrontPercent.div(sectionPercentSize).mul(sectionRadiansSize));\r\n\t\tFixedPoint.Data memory endIntegrationPoint = sectionOffset.add(playerBackPercent.div(sectionPercentSize).mul(sectionRadiansSize));\r\n\t\treturn integrate(endIntegrationPoint, windowAdjustment).sub(integrate(startIntegrationPoint, windowAdjustment)).mul(potSize).mul(windowAdjustment).div(_2pi);\r\n\t}\r\n\r\n    function computeAmountToMineForBettingRecord (Player.BettingRecord record, bool onlyCurrentGame) internal view returns(uint256 value) {\r\n\t\tif(onlyCurrentGame && record.gameId != currentGameNumber){\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tuint256 payout = getPopPayoutForRecord(record).toUInt256Raw();\r\n\t\treturn payout.sub(record.withdrawnPopAmount);\r\n    }\r\n\r\n    function getPopPayoutForRecord(Player.BettingRecord record) private view returns(FixedPoint.Data value) {\r\n    \t\r\n    \tif(record.isActive == false) {\r\n    \t\treturn FixedPoint.fromInt256(0);\r\n    \t}\r\n\r\n    \treturn totalTokenPayout(getPotAsFixedPointForGameId(record.gameId).sub(getInitialSeedAsFixedPointForGameId(record.gameId)), getDifficultyAsFixedPointForGameId(record.gameId), getPopRemainingAsFixedPointForGameId(record.gameId), record.wagerAmount, record.gamePotBeforeBet); \r\n    }\r\n    \r\n    function unMinedPop () private view returns(uint256 res) {\r\n    \treturn totalSupply_.sub(supplyMined_);\r\n    }\r\n\r\n    function promisedPop () private view returns(uint256) {\r\n    \tFixedPoint.Data memory curPot = getPotAsFixedPointForGameId(currentGameNumber);\r\n    \tFixedPoint.Data memory seed = getInitialSeedAsFixedPointForGameId(currentGameNumber);\r\n    \tFixedPoint.Data memory difficulty = getDifficultyAsFixedPointForGameId(currentGameNumber);\r\n    \tFixedPoint.Data memory unpromised = getPopRemainingAsFixedPointForGameId(currentGameNumber);\r\n\r\n    \tuint256 promisedPopThisGame = totalTokenPayout(curPot.sub(seed), difficulty, unpromised, currentPot.sub(seed.toUInt256Raw()), 0).toUInt256Raw(); \r\n    \treturn totalSupply_.sub(unPromisedSupplyAtStartOfCurrentGame_).add(promisedPopThisGame);\r\n    }\r\n\r\n    function unPromisedPop () private view returns(uint256 res) {\r\n    \treturn totalSupply_.sub(promisedPop());\r\n    }\r\n    \r\n    function potentiallyCirculatingPop () public view returns(uint256 res) {\r\n    \treturn promisedPop().sub(supplyBurned_);\r\n    }\r\n    \r\n    function minePoP(address target, uint256 amountToMine) private {\r\n    \tif(supplyMined_ >= totalSupply_) { \r\n    \t\treturn;\r\n    \t}\r\n\r\n    \tuint256 remainingPop = unMinedPop();\r\n    \tif(amountToMine == 0 || remainingPop == 0) {\r\n    \t\treturn;\r\n    \t}\r\n\r\n    \tif(remainingPop < amountToMine) {\r\n    \t\tamountToMine = remainingPop;\r\n    \t}\r\n\r\n    \tuint256 developerMined = amountOfPopDeveloperShouldMine(amountToMine);\r\n    \tuint256 playerMined = amountToMine.sub(developerMined);\r\n\r\n    \tsupplyMined_ = supplyMined_.add(amountToMine);\r\n    \t\r\n        popBalances[target] = popBalances[target].add(playerMined);\r\n        popBalances[author] = popBalances[author].add(developerMined);\r\n\r\n        emit Mined(target, playerMined);\r\n        emit Transfer(0, target, playerMined);\r\n        emit Mined(author, developerMined);\r\n        emit Transfer(0, author, developerMined);\r\n    }\r\n\r\n    function redeemPop (uint256 popToRedeem) public returns(bool res) {\r\n    \trequire(popBalances[msg.sender] >= popToRedeem);\r\n    \trequire(popToRedeem != 0);\r\n\r\n    \tuint256 potentiallyAllocatedPop = potentiallyCirculatingPop();\r\n    \trequire(popToRedeem <= potentiallyAllocatedPop);\r\n\r\n    \tFixedPoint.Data memory redeemRatio = FixedPoint.fromFraction(Int256(popToRedeem), Int256(potentiallyAllocatedPop));\r\n    \tFixedPoint.Data memory ethPayoutAmount = redeemRatio.mul(FixedPoint.fromInt256(Int256(totalAmountRaked())));\r\n    \tuint256 payout = ethPayoutAmount.toUInt256Raw();\r\n    \trequire(payout<=totalAmountRaked());\r\n    \trequire(payout <= address(this).balance);\r\n    \t\r\n    \tburn(popToRedeem);\r\n    \tplayerInternalWallet[this] = playerInternalWallet[this].sub(payout);\r\n    \tplayerInternalWallet[msg.sender] = playerInternalWallet[msg.sender].add(payout);\r\n\r\n    \treturn true;\r\n    }\r\n\r\n    // Coin Functions\r\n    function totalSupply() public view returns (uint256) {\r\n\t    return promisedPop();\r\n\t}\r\n\r\n\tfunction balanceOf(address _owner) public view returns (uint256 balance) {\r\n\t\treturn popBalances[_owner];\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool) {\r\n\t    require(_to != address(0));\r\n\t    require(_value <= popBalances[msg.sender]);\r\n\r\n\t    // SafeMath.sub will throw if there is not enough balance.\r\n\t    popBalances[msg.sender] = popBalances[msg.sender].sub(_value);\r\n\t    popBalances[_to] = popBalances[_to].add(_value);\r\n\t    emit Transfer(msg.sender, _to, _value);\r\n\t    return true;\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n\t    require(_to != address(0));\r\n\t    require(_value <= popBalances[_from]);\r\n\t    require(_value <= allowed[_from][msg.sender]);\r\n\r\n\t    popBalances[_from] = popBalances[_from].sub(_value);\r\n\t    popBalances[_to] = popBalances[_to].add(_value);\r\n\t    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\t    emit Transfer(_from, _to, _value);\r\n\t    return true;\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool) {\r\n\t    allowed[msg.sender][_spender] = _value;\r\n\t    emit Approval(msg.sender, _spender, _value);\r\n\t    return true;\r\n\t}\r\n\r\n\tfunction allowance(address _owner, address _spender) public view returns (uint256) {\r\n\t    return allowed[_owner][_spender];\r\n\t}\r\n\r\n\tfunction increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n\t    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n\t    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t    return true;\r\n\t}\r\n\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n\t    uint oldValue = allowed[msg.sender][_spender];\r\n\t    if (_subtractedValue > oldValue) {\r\n\t      allowed[msg.sender][_spender] = 0;\r\n\t    } else {\r\n\t      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t    }\r\n\t    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t    return true;\r\n\t}\r\n\r\n\tfunction burn(uint256 _value) public {\r\n\t    require (popBalances[msg.sender] >= _value);\r\n\t    \r\n\t    address burner = msg.sender;\r\n\t    supplyBurned_ = supplyBurned_.add(_value);\r\n\t    popBalances[burner] = popBalances[burner].sub(_value);\r\n\t    emit Burn(burner, _value);\r\n\t}\r\n\r\n\tfunction getInitialSeedAsFixedPointForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\r\n\t\tif(gameId == currentGameNumber) {\r\n\t\t\treturn FixedPoint.fromInt256(Int256(initialSeed));\r\n\t\t} else {\r\n\t\t\tWrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\r\n\t\t\treturn FixedPoint.fromInt256(Int256(elem.seedAmount));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPotAsFixedPointForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\r\n\t\tif(gameId == currentGameNumber) {\r\n\t\t\treturn FixedPoint.fromInt256(Int256(currentPot));\r\n\t\t} else {\r\n\t\t\tWrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\r\n\t\t\treturn FixedPoint.fromInt256(Int256(elem.totalPotAmount));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getPopRemainingAsFixedPointForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\r\n\t\tif(gameId == currentGameNumber) {\r\n\t\t\treturn FixedPoint.fromInt256(Int256(unPromisedSupplyAtStartOfCurrentGame_));\r\n\t\t} else {\r\n\t\t\tWrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\r\n\t\t\treturn FixedPoint.fromInt256(Int256(elem.coinsRemaining));\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction getDifficultyAsFixedPointForGameId (uint256 gameId) private view returns(FixedPoint.Data res) {\r\n\t\tif(gameId == currentGameNumber) {\r\n\t\t\treturn currentMiningDifficulty;\r\n\t\t} else {\r\n\t\t\tWrappedArray.GameMetaDataElement memory elem = gameMetaData.itemAtIndex(gameId);\r\n\t\t\treturn elem.miningDifficulty;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction calcDifficulty() private view returns (FixedPoint.Data) {\r\n\t\tFixedPoint.Data memory total = FixedPoint.fromInt256(0);\r\n\t\tFixedPoint.Data memory count = FixedPoint.fromInt256(0);\r\n\t\tuint256 j = 0;\r\n\t\tfor(uint256 i=gameMetaData.length().sub(1) ; i>=0 && j<kDifficultyWindow; i = i.sub(1)){\r\n\t\t\tWrappedArray.GameMetaDataElement memory thisGame = gameMetaData.itemAtIndex(i);\r\n\t\t\tFixedPoint.Data memory thisGamePotSize = FixedPoint.fromInt256(Int256(thisGame.totalPotAmount));\r\n\t\t\tFixedPoint.Data memory thisCount = kDifficultyDropOffFactor.pow(FixedPoint.fromInt256(Int256(j)));\r\n\t\t\ttotal = total.add(thisCount.mul(thisGamePotSize));\r\n\t\t\tcount = count.add(thisCount);\r\n\t\t\tj = j.add(1);\r\n\t\t\tif(i == 0) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn total.div(count).div(kExpectedFirstGameSize);\r\n\t}\r\n\r\n\tfunction getBrAdj(FixedPoint.Data currentPotValue, FixedPoint.Data expectedGameSize) private pure returns (FixedPoint.Data) {\r\n\t\tif(currentPotValue.cmp(expectedGameSize) == -1) {\r\n\t\t    return expectedGameSize.div(currentPotValue).log10().neg();\r\n\t\t} else {\r\n\t\t    return currentPotValue.div(expectedGameSize).log10();\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getMiningRateAtPoint(FixedPoint.Data point, FixedPoint.Data difficulty, FixedPoint.Data currentPotValue, FixedPoint.Data coins_tbi) private view returns (FixedPoint.Data) {\r\n\t\tassert (point.cmp(currentPotValue) != 1);\r\n        FixedPoint.Data memory expectedGameSize = kExpectedFirstGameSize.mul(difficulty);\r\n\t\tFixedPoint.Data memory depositRatio = point.div(currentPotValue);\r\n\t\tFixedPoint.Data memory brAdj = getBrAdj(currentPotValue, expectedGameSize);\r\n\t\tif(brAdj.cmp(FixedPoint.fromInt256(0)) == -1) {\r\n\t\t\treturn coins_tbi.mul(FixedPoint.fromInt256(1).div(FixedPoint.fromInt256(2).pow(brAdj.neg()))).mul(FixedPoint.fromInt256(2).sub(depositRatio));\r\n\t\t} else {\r\n\t\t\treturn coins_tbi.mul(FixedPoint.fromInt256(2).pow(brAdj)).mul(FixedPoint.fromInt256(2).sub(depositRatio));\r\n\t\t}\r\n\t}\r\n\r\n    function getExpectedGameSize() external view returns (int256) {\r\n        return kExpectedFirstGameSize.toInt256();\r\n    }\r\n\r\n\tfunction totalTokenPayout(FixedPoint.Data currentPotValue, FixedPoint.Data difficulty, FixedPoint.Data unpromisedPopAtStartOfGame, uint256 wagerAmount, uint256 previousPotSize) private view returns (FixedPoint.Data) {\r\n\t\tFixedPoint.Data memory maxPotSize = kExpectedFirstGameSize.mul(difficulty).mul(kMaxPopMiningPotMultiple);\r\n\t\tFixedPoint.Data memory startPoint = FixedPoint.fromInt256(Int256(previousPotSize));\r\n\t\tif(startPoint.cmp(maxPotSize) != -1){ // startPoint >= maxPotSize\r\n\t\t\treturn FixedPoint.fromInt256(0);\r\n\t\t}\r\n\t\tFixedPoint.Data memory endPoint = FixedPoint.fromInt256(Int256(previousPotSize + wagerAmount));\r\n\t\tif(endPoint.cmp(maxPotSize) != -1){\r\n\t\t\tendPoint = maxPotSize;\r\n\t\t\twagerAmount = maxPotSize.sub(startPoint).toUInt256Raw();\r\n\t\t}\r\n\t\tif(currentPotValue.cmp(maxPotSize) != -1){\r\n\t\t\tcurrentPotValue = maxPotSize;\r\n\t\t}\r\n\r\n\t\tFixedPoint.Data memory betSizePercent = FixedPoint.fromInt256(Int256(wagerAmount)).div(kExpectedFirstGameSize.mul(difficulty));\r\n\t\tFixedPoint.Data memory expectedCoinsToBeIssuedTwoThirds = FixedPoint.fromFraction(2, 3).mul(unpromisedPopAtStartOfGame.mul(kExpectedPopCoinToBePromisedPercent));\r\n\t\treturn getMiningRateAtPoint(startPoint.add(endPoint).div(FixedPoint.fromInt256(2)), difficulty, currentPotValue, expectedCoinsToBeIssuedTwoThirds).mul(betSizePercent);\r\n\t}\r\n\r\n\tfunction calcNumberOfBlocksUntilGameEnds(FixedPoint.Data currentGameSize, FixedPoint.Data targetGameSize) internal view returns (FixedPoint.Data) {\r\n\t\treturn kLowerBoundBlocksTillGameEnd.add(kUpperBoundBlocksTillGameEnd.mul(FixedPoint.fromInt256(1).div(currentGameSize.div(targetGameSize).exp())));\r\n\t}\r\n\r\n\tfunction calcMinimumBetSize(FixedPoint.Data currentGameSize, FixedPoint.Data targetGameSize) internal view returns (FixedPoint.Data) {\r\n\t\treturn currentGameInitialMinBetSize.mul(FixedPoint.fromInt256(2).pow(FixedPoint.fromInt256(1).add(currentGameSize.div(targetGameSize)).log10()));\r\n\t}\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary SafeInt {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(int256 a, int256 b) internal pure returns (int256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    int256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(int256 a, int256 b) internal pure returns (int256) {\r\n   \t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    int256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(int256 a, int256 b) internal pure returns (int256) {\r\n    int256 c = a - b;\r\n    if(a>0 && b<0) {\r\n    \tassert (c > a);\t\r\n    } else if(a<0 && b>0) {\r\n    \tassert (c < a);\r\n    }\r\n   \treturn c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(int256 a, int256 b) internal pure returns (int256) {\r\n    int256 c = a + b;\r\n    if(a>0 && b>0) {\r\n    \tassert(c > a);\r\n    } else if (a < 0 && b < 0) {\r\n    \tassert(c < a);\r\n    }\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\nlibrary WrappedArray {\r\n\tusing SafeMath for uint256;\r\n\tusing FixedPoint for FixedPoint.Data;\r\n\r\n\tstruct GameMetaDataElement {\r\n\t\tuint256 totalPotAmount;\r\n\t\tuint256 seedAmount;\r\n\t\tuint256 initialBet;\r\n\t\tuint256 coinsRemaining;\r\n\t\tFixedPoint.Data miningDifficulty;\r\n\t\tbool isActive;\r\n\t}\r\n\r\n\tstruct Data {\r\n\t\tGameMetaDataElement[] array;\r\n\t}\r\n\t\r\n\t/* Push adds element as last item in array */\r\n\tfunction push (Data storage self, GameMetaDataElement element) internal  {\r\n\t\tself.array.length = self.array.length.add(1);\r\n\t\tself.array[self.array.length.sub(1)] = element;\r\n\t}\r\n\r\n\t/* ItemAtIndex returns the item at index */\r\n\tfunction itemAtIndex (Data storage self, uint256 index) internal view returns(GameMetaDataElement elem) {\r\n\t\t/* Can't access something outside of scope of array */\r\n\t\tassert(index < self.array.length); \r\n\t\treturn self.array[index];\r\n\t}\r\n\t\r\n\t/* Returns the length of the array */\r\n\tfunction length (Data storage self) internal view returns(uint256 len) {\r\n\t\treturn self.array.length;\r\n\t}\r\n}\r\n\r\n\r\nlibrary CompactArray {\r\n\tusing SafeMath for uint256;\r\n\r\n\tstruct Element {\r\n\t\tuint256 elem;\r\n\t}\r\n\t\r\n\tstruct Data {\r\n\t\tElement[] array;\r\n\t\tuint256 len;\r\n\t\tuint256 popNextIndex;\r\n\t}\r\n\r\n\t/* Push adds element as last item in array and returns the index it was inserted at */\r\n\tfunction push (Data storage self, Element element) internal returns(uint256 index)  {\r\n\t\tif(self.array.length == self.len) {\r\n\t\t\tself.array.length = self.array.length.add(1);\r\n\t\t}\r\n\t\tself.array[self.len] = element;\r\n\t\tself.len = self.len.add(1);\r\n\t\treturn self.len.sub(1);\r\n\t}\r\n\r\n\t/* Replaces item at index with last item in array and resizes array accordingly */\r\n\tfunction removeItemAtIndex (Data storage self, uint256 index) internal {\r\n\t\t/* Can't remove something outside of scope of array */\r\n\t\tassert(index < self.len);\r\n\r\n\t\t/* Deleting the last element in array is same as length - 1 */\r\n\t\tif(index == self.len.sub(1)) {\r\n\t\t\tself.len = self.len.sub(1);\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t/* Swap last element in array for this index */\r\n\t\tElement storage temp = self.array[self.len.sub(1)];\r\n\t\tself.array[index] = temp;\r\n\t\tself.len = self.len.sub(1);\r\n\t}\r\n\t\r\n\t/* Pop returns last element of array and deletes it from array */\r\n\tfunction pop (Data storage self) internal returns(Element elem) {\r\n\t\tassert(self.len > 0);\r\n\r\n\t\t// Decrement size \r\n\t\tself.len = self.len.sub(1);\r\n\r\n\t\t// return last item\r\n\t\treturn self.array[self.len];\r\n\t}\r\n\r\n\t/* PopNext keeps track of an index that loops through the array and pops the next item so that push pop doesn't necessarily return the item you pushed */\r\n\tfunction getNext (Data storage self) internal returns(Element elem) {\r\n\t\tassert(self.len > 0);\r\n\t\t\t\r\n\t\tif(self.popNextIndex >= self.len) {\r\n\t\t\t// If there were regular pops inbetween\r\n\t\t\tself.popNextIndex = self.len.sub(1);\r\n\t\t}\r\n\t\tElement memory nextElement = itemAtIndex(self, self.popNextIndex);\r\n\t\t\r\n\t\tif(self.popNextIndex == 0) {\r\n\t\t\tself.popNextIndex = self.len.sub(1);\r\n\t\t} else {\r\n\t\t\tself.popNextIndex = self.popNextIndex.sub(1);\r\n\t\t}\r\n\t\treturn nextElement;\r\n\t}\r\n\t\r\n\t/* ItemAtIndex returns the item at index */\r\n\tfunction itemAtIndex (Data storage self, uint256 index) internal view returns(Element elem) {\r\n\t\t/* Can't access something outside of scope of array */\r\n\t\tassert(index < self.len);\r\n\t\t\t\r\n\t\treturn self.array[index];\r\n\t}\r\n\t\r\n\t/* Returns the length of the array */\r\n\tfunction length (Data storage self) internal view returns(uint256 len) {\r\n\t\treturn self.len;\r\n\t}\r\n\t\r\n}\r\n\r\n\r\nlibrary UIntSet {\r\n\tusing CompactArray for CompactArray.Data;\r\n\r\n\tstruct SetEntry {\r\n\t\tuint256 index;\r\n\t\tbool active; // because the index can be zero we need another way to tell if we have the entry\r\n\t}\r\n\t\r\n\tstruct Data {\r\n\t\tCompactArray.Data compactArray;\r\n\t\tmapping (uint256 => SetEntry) storedValues;\r\n\t}\r\n\r\n\t/* Returns whether item is contained in dict */\r\n\tfunction contains (Data storage self, uint256 element) internal view returns(bool res) {\r\n\t\treturn self.storedValues[element].active;\r\n\t}\r\n\r\n\t/* Adds an item to the set */\r\n\tfunction insert (Data storage self, uint256 element) internal {\r\n\t\t// Don't need to insert element if entry already exists\r\n\t\tif(contains(self, element)) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\t// Create new entry for compact array\r\n\t\tCompactArray.Element memory newElem = CompactArray.Element(element);\r\n\r\n\t\t// Insert new entry into compact array and get where it was inserted\r\n\t\tuint256 index = self.compactArray.push(newElem);\r\n\r\n\t\t// Insert index of entry in compact array into our set\r\n\t\tSetEntry memory entry = SetEntry(index, true);\r\n\r\n\t\tself.storedValues[element] = entry;\r\n\t}\r\n\t\r\n\t\r\n\t/* Remove an item from the set */\r\n\tfunction removeElement (Data storage self, uint256 element) internal {\r\n\t\t// If nothing is stored can return\r\n\t\tif(contains(self, element) == false) {\r\n\t\t\treturn;\r\n\t\t}\r\n\r\n\t\t// Get index of where element entry is stored in array\r\n\t\tuint256 index = self.storedValues[element].index;\r\n\r\n\t\t// Delete entry from array\r\n\t\tself.compactArray.removeItemAtIndex(index);\r\n\r\n\t\t// Delete entry from mapping\r\n\t\tself.storedValues[element].active = false;\r\n\r\n\t\t// If array still has elements we need to update mapping with new index\r\n\t\tif(index < self.compactArray.length()) {\r\n\t\t\t// Get new element stored at deleted index\r\n\t\t\tCompactArray.Element memory swappedElem = self.compactArray.itemAtIndex(index);\r\n\t\t\t\r\n\t\t\t// Update mapping to reflect new index\r\n\t\t\tself.storedValues[swappedElem.elem] = SetEntry(index, true);\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\r\n\t/* This utilized compact arrays popnext function to have a rotating pop */\r\n\tfunction getNext (Data storage self) internal returns(CompactArray.Element) {\r\n\t\t// If nothing is stored can return\r\n\t\treturn self.compactArray.getNext();\r\n\t}\r\n\r\n\t/* Returns the current number of items in the set */\r\n\tfunction size (Data storage self) internal view returns(uint256 res) {\r\n\t\treturn self.compactArray.length();\r\n\t}\r\n\r\n\tfunction getItemAtIndex (Data storage self, uint256 index) internal view returns(CompactArray.Element) {\r\n\t\treturn self.compactArray.itemAtIndex(index);\r\n\t}\r\n\t\r\n}\r\n\r\n\r\n\r\nlibrary Player {\r\n\tusing UIntSet for UIntSet.Data;\r\n\tusing CompactArray for CompactArray.Data;\r\n\r\n\tstruct BettingRecord {\r\n\t\taddress playerAddress;\r\n\t\tuint256 gameId;\r\n\t\tuint256 wagerAmount;\r\n\t\tuint256 bettingRecordId;\r\n\t\tuint256 gamePotBeforeBet;\r\n\t\tuint256 withdrawnAmount;\r\n\t\tuint256 withdrawnPopAmount;\r\n\t\tbool isActive;\r\n\t}\r\n\t\r\n\tstruct Data {\r\n\t\tUIntSet.Data bettingRecordIds;\r\n\t\tmapping (uint256 => BettingRecord) bettingRecordMapping;\r\n\t}\r\n\t\r\n\t/* Contains betting record for a betting record id */\r\n\tfunction containsBettingRecordFromId (Data storage self, uint256 bettingRecordId) internal view returns(bool containsBettingRecord) {\r\n\t\treturn self.bettingRecordIds.contains(bettingRecordId);\r\n\t}\r\n\t\r\n\r\n\t/* Function that returns a betting record for a betting record id */\r\n\tfunction getBettingRecordForId (Data storage self, uint256 bettingRecordId) internal view returns(BettingRecord record) {\r\n\t\tif(containsBettingRecordFromId(self, bettingRecordId) == false) {\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\treturn self.bettingRecordMapping[bettingRecordId];\r\n\t}\r\n\t\r\n\r\n\t/* Insert Betting Record into storage */\r\n\tfunction insertBettingRecord (Data storage self, BettingRecord record) internal {\r\n\t\t// Inserting a record with the same id will override old record\r\n\t\tself.bettingRecordMapping[record.bettingRecordId] = record;\r\n\t\tself.bettingRecordIds.insert(record.bettingRecordId);\r\n\t}\r\n\t\r\n\t/* Retrieve the next betting record */\r\n\tfunction getNextRecord (Data storage self) internal returns(BettingRecord record) {\r\n\t\tif(self.bettingRecordIds.size() == 0) {\r\n\t\t\treturn ;\r\n\t\t}\r\n\t\tCompactArray.Element memory bettingRecordIdEntry = self.bettingRecordIds.getNext();\r\n\t\treturn self.bettingRecordMapping[bettingRecordIdEntry.elem];\r\n\t}\r\n\r\n    function getBettingRecordAtIndex (Data storage self, uint256 index) internal view returns(BettingRecord record) {\r\n    \treturn self.bettingRecordMapping[self.bettingRecordIds.getItemAtIndex(index).elem];\r\n    }\r\n    \r\n\r\n\t/* Delete Betting Record */\r\n\tfunction deleteBettingRecordForId (Data storage self, uint256 bettingRecordId) internal {\r\n\t\tself.bettingRecordIds.removeElement(bettingRecordId);\r\n\t}\r\n\r\n\t/* Returns the number of betting records left to be processed */\r\n\tfunction unprocessedBettingRecordCount (Data storage self) internal view returns(uint256 size) {\r\n\t\treturn self.bettingRecordIds.size();\r\n\t}\r\n}\r\n\r\nlibrary BettingRecordArray {\r\n\tusing Player for Player.Data;\r\n\tusing SafeMath for uint256;\r\n\r\n\tstruct Data {\r\n\t\tPlayer.BettingRecord[] array;\r\n\t\tuint256 len;\r\n\t}\r\n\r\n\tfunction resetIndex (Data storage self) internal {\r\n\t\tself.len = 0;\r\n\t}\r\n\t\r\n\tfunction pushRecord (Data storage self, Player.BettingRecord record) internal {\r\n\t\tif(self.array.length == self.len) {\r\n\t\t\tself.array.length = self.array.length.add(1);\r\n\t\t}\r\n\t\tself.array[self.len] = record;\r\n\t\tself.len = self.len.add(1);\r\n\t}\r\n\r\n\tfunction getNextRecord (Data storage self) internal view returns(Player.BettingRecord record) {\r\n\t\tif(self.array.length == self.len) {\r\n\t\t\treturn;\r\n\t\t}\r\n\t\treturn self.array[self.len];\r\n\t}\t\r\n}\r\n\r\nlibrary FixedPoint {\r\n\tusing SafeMath for uint256;\r\n\tusing SafeInt for int256;\r\n\r\n\tint256 constant fracBits = 32;\r\n\tint256 constant scale = 1 << 32;\r\n\tint256 constant halfScale = scale >> 1;\r\n    int256 constant precision = 1000000;\r\n\tint256 constant e = 11674931554;\r\n\tint256 constant pi = 13493037704;\r\n\tint256 constant _2pi = 26986075409;\r\n\r\n\tstruct Data {\r\n\t\tint256 val;\r\n\t}\r\n\r\n\tfunction fromInt256(int256 n) internal pure returns (Data) {\r\n\t\treturn Data({val: n.mul(scale)});\r\n\t}\r\n\r\n\tfunction fromFraction(int256 numerator, int256 denominator) internal pure returns (Data) {\r\n\t\treturn Data ({\r\n\t\t\tval: numerator.mul(scale).div(denominator)\r\n\t\t});\r\n\t}\r\n\r\n\tfunction toInt256(Data n) internal pure returns (int256) {\r\n\t\treturn (n.val * precision) >> fracBits;\r\n\t}\r\n\r\n\tfunction toUInt256Raw(Data a) internal pure returns (uint256) {\r\n\t\treturn uint256(a.val >> fracBits);\r\n\t}\r\n\r\n\tfunction add(Data a, Data b) internal pure returns (Data) {\r\n\t\treturn Data({val: a.val.add(b.val)});\r\n\t}\r\n\r\n\tfunction sub(Data a, Data b) internal pure returns (Data) {\r\n\t\treturn Data({val: a.val.sub(b.val)});\r\n\t}\r\n\r\n\tfunction mul(Data a, Data b) internal pure returns (Data) {\r\n\t\tint256 result = a.val.mul(b.val).div(scale);\r\n\t\treturn Data({val: result});\r\n\t}\r\n\r\n\tfunction div(Data a, Data b) internal pure returns (Data) {\r\n\t\tint256 num = a.val.mul(scale);\r\n\t\treturn Data({val: num.div(b.val)});\r\n\t}\r\n\r\n    function neg(Data a) internal pure returns (Data) {\r\n        return Data({val: -a.val});\r\n    }\r\n\r\n\tfunction mod(Data a, Data b) internal pure returns (Data) {\r\n\t\treturn Data({val: a.val % b.val});\r\n\t}\r\n\r\n\tfunction expBySquaring(Data x, Data n) internal pure returns (Data) {\r\n\t\tif(n.val == 0) { // exp == 0\r\n\t\t\treturn Data({val: scale});\r\n\t\t}\r\n\t\tData memory extra = Data({val: scale});\r\n\t\twhile(true) {\r\n\t\t\tif(n.val == scale) { // exp == 1\r\n\t\t\t\treturn mul(x, extra);\r\n\t\t\t} else if (n.val % (2*scale) != 0) {\r\n\t\t\t\textra = mul(extra, x);\r\n\t\t\t\tn = sub(n, fromInt256(1));\r\n\t\t\t}\r\n\t\t\tx = mul(x, x);\r\n\t\t\tn = div(n, fromInt256(2));\r\n\t\t}\r\n\t}\r\n\r\n\tfunction sin(Data x) internal pure returns (Data) {\r\n\t\tint256 val = x.val % _2pi;\r\n\r\n\t\tif(val < -pi) {\r\n\t\t\tval += _2pi;\r\n\t\t} else if (val > pi) {\r\n\t\t\tval -= _2pi;\r\n\t\t}\r\n        Data memory result;\r\n\t\tif(val < 0) {\r\n\t\t\tresult = add(mul(Data({val: 5468522184}), Data({val: val})), mul(Data({val: 1740684682}), mul(Data({val: val}), Data({val: val}))));\r\n\t\t\tif(result.val < 0) {\r\n\t\t\t\tresult = add(mul(Data({val: 966367641}), sub(mul(result, neg(result)), result)), result);\r\n\t\t\t} else {\r\n\t\t\t\tresult = add(mul(Data({val: 966367641}), sub(mul(result, result), result)), result);\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t} else {\r\n\t\t\tresult = sub(mul(Data({val: 5468522184}), Data({val: val})), mul(Data({val: 1740684682}), mul(Data({val: val}), Data({val: val})))); \r\n\t\t\tif(result.val < 0) {\r\n\t\t\t\tresult = add(mul(Data({val: 966367641}), sub(mul(result, neg(result)), result)), result);\r\n\t\t\t} else {\r\n\t\t\t\tresult = add(mul(Data({val: 966367641}), sub(mul(result, result), result)), result);\r\n\t\t\t}\r\n\t\t\treturn result;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction cmp(Data a, Data b) internal pure returns (int256) {\r\n\t\tif(a.val > b.val) {\r\n\t\t\treturn 1;\r\n\t\t} else if(a.val < b.val) {\r\n\t\t\treturn -1;\r\n\t\t} else {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction log10(Data a) internal pure returns (Data) {\r\n\t    return div(ln(a), ln(fromInt256(10)));\r\n\t}\r\n\r\n\tfunction ln(Data a) internal pure returns (Data) {\r\n\t\tint256 LOG = 0;\r\n\t\tint256 prec = 1000000;\r\n\t\tint256 x = a.val.mul(prec) >> fracBits;\r\n\r\n\t\twhile(x >= 1500000) {\r\n\t\t\tLOG = LOG.add(405465);\r\n\t\t\tx = x.mul(2).div(3);\r\n\t\t}\r\n\t\tx = x.sub(prec);\r\n        int256 y = x;\r\n        int256 i = 1;\r\n        while (i < 10){\r\n            LOG = LOG.add(y.div(i));\r\n            i = i.add(1);\r\n            y = x.mul(y).div(prec);\r\n            LOG = LOG.sub(y.div(i));\r\n            i = i.add(1);\r\n            y = x.mul(y).div(prec);\r\n        }\r\n        LOG = LOG.mul(scale);\r\n        LOG = LOG.div(prec);\r\n        return Data({val: LOG});\r\n\t}\r\n\r\n\tfunction expRaw(Data a) internal pure returns (Data) {\r\n\t\tint256 l1 = scale.add(a.val.div(4));\r\n\t\tint256 l2 = scale.add(a.val.div(3).mul(l1).div(scale));\r\n\t\tint256 l3 = scale.add(a.val.div(2).mul(l2).div(scale));\r\n\t\tint256 l4 = scale.add(a.val.mul(l3).div(scale));\r\n\r\n\t\treturn Data({val: l4});\r\n\t}\r\n\r\n\tfunction exp(Data a) internal pure returns (Data) {\r\n\t\tint256 pwr = a.val >> fracBits;\r\n\t\tint256 frac = a.val.sub(pwr << fracBits);\r\n\r\n\t\treturn mul(expRaw(Data({val: frac})), expBySquaring(Data({val: e}), fromInt256(pwr)));\r\n\t}\r\n\r\n\tfunction pow(Data base, Data power) internal pure returns (Data) {\r\n\t\tint256 intpwr = power.val >> 32;\r\n\t\tint256 frac = power.val.sub(intpwr << fracBits);\r\n\t\treturn mul(expRaw(mul(Data({val:frac}), ln(base))), expBySquaring(base, fromInt256(intpwr)));\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"popToRedeem\",\"type\":\"uint256\"}],\"name\":\"redeemPop\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addToBonusSeed\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potentiallyCirculatingPop\",\"outputs\":[{\"name\":\"res\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addToRakePool\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"bet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExpectedGameSize\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"recordIndex\",\"type\":\"uint256\"},{\"name\":\"onlyWithdrawable\",\"type\":\"bool\"},{\"name\":\"onlyCurrentGame\",\"type\":\"bool\"}],\"name\":\"getWinningsForRecordId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastBetBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"withdrawCount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxBlocks\",\"type\":\"uint256\"},{\"name\":\"minBlocks\",\"type\":\"uint256\"}],\"name\":\"updateNextGameMinAndMaxBlockUntilGameEnd\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumNumberOfBlocksToEndGame\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerInternalWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"recordIndex\",\"type\":\"uint256\"},{\"name\":\"onlyCurrentGame\",\"type\":\"bool\"}],\"name\":\"playerPopMining\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentMiningDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialBankrollGrowthAmount\",\"outputs\":[{\"name\":\"val\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentGameNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"recordIndex\",\"type\":\"uint256\"}],\"name\":\"getBetRecord\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalAmountRaked\",\"outputs\":[{\"name\":\"res\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyBetRecordCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"betAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gameNumber\",\"type\":\"uint256\"}],\"name\":\"Bet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numberOfRecordsProcessed\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentGameNumber\",\"type\":\"uint256\"}],\"name\":\"EndGame\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"miner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mined\",\"type\":\"event\"}]","ContractName":"PoP","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e4f6632666f159ad8476697c18be3daefc33b940a8b7ee3ed669a06265c97305"}]}