{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\nlibrary RLPEncode {\r\n    uint8 constant STRING_SHORT_PREFIX = 0x80;\r\n    uint8 constant STRING_LONG_PREFIX = 0xb7;\r\n    uint8 constant LIST_SHORT_PREFIX = 0xc0;\r\n    uint8 constant LIST_LONG_PREFIX = 0xf7;\r\n\r\n    /// @dev Rlp encodes a bytes\r\n    /// @param self The bytes to be encoded\r\n    /// @return The rlp encoded bytes\r\n    function encodeBytes(bytes memory self) internal constant returns (bytes) {\r\n        bytes memory encoded;\r\n        if(self.length == 1 && uint(self[0]) < 0x80) {\r\n            encoded = new bytes(1);\r\n            encoded = self;\r\n        } else {\r\n            encoded = encode(self, STRING_SHORT_PREFIX, STRING_LONG_PREFIX);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    /// @dev Rlp encodes a bytes[]. Note that the items in the bytes[] will not automatically be rlp encoded.\r\n    /// @param self The bytes[] to be encoded\r\n    /// @return The rlp encoded bytes[]\r\n    function encodeList(bytes[] memory self) internal constant returns (bytes) {\r\n        bytes memory list = flatten(self);\r\n        bytes memory encoded = encode(list, LIST_SHORT_PREFIX, LIST_LONG_PREFIX);\r\n        return encoded;\r\n    }\r\n\r\n    function encode(bytes memory self, uint8 prefix1, uint8 prefix2) private constant returns (bytes) {\r\n        uint selfPtr;\r\n        assembly { selfPtr := add(self, 0x20) }\r\n\r\n        bytes memory encoded;\r\n        uint encodedPtr;\r\n\r\n        uint len = self.length;\r\n        uint lenLen;\r\n        uint i = 0x1;\r\n        while(len/i != 0) {\r\n            lenLen++;\r\n            i *= 0x100;\r\n        }\r\n\r\n        if(len <= 55) {\r\n            encoded = new bytes(len+1);\r\n\r\n            // length encoding byte\r\n            encoded[0] = byte(prefix1+len);\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(encoded, 0x21) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        } else {\r\n            // 1 is the length of the length of the length\r\n            encoded = new bytes(1+lenLen+len);\r\n\r\n            // length of the length encoding byte\r\n            encoded[0] = byte(prefix2+lenLen);\r\n\r\n            // length bytes\r\n            for(i=1; i<=lenLen; i++) {\r\n                encoded[i] = byte((len/(0x100**(lenLen-i)))%0x100);\r\n            }\r\n\r\n            // string/list contents\r\n            assembly { encodedPtr := add(add(encoded, 0x21), lenLen) }\r\n            memcpy(encodedPtr, selfPtr, len);\r\n        }\r\n        return encoded;\r\n    }\r\n\r\n    function flatten(bytes[] memory self) private constant returns (bytes) {\r\n        if(self.length == 0) {\r\n            return new bytes(0);\r\n        }\r\n\r\n        uint len;\r\n        for(uint i=0; i<self.length; i++) {\r\n            len += self[i].length;\r\n        }\r\n\r\n        bytes memory flattened = new bytes(len);\r\n        uint flattenedPtr;\r\n        assembly { flattenedPtr := add(flattened, 0x20) }\r\n\r\n        for(i=0; i<self.length; i++) {\r\n            bytes memory item = self[i];\r\n\r\n            uint selfPtr;\r\n            assembly { selfPtr := add(item, 0x20)}\r\n\r\n            memcpy(flattenedPtr, selfPtr, item.length);\r\n            flattenedPtr += self[i].length;\r\n        }\r\n\r\n        return flattened;\r\n    }\r\n\r\n    /// This function is from Nick Johnson's string utils library\r\n    function memcpy(uint dest, uint src, uint len) private {\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    function strToBytes(string data)internal pure returns (bytes){\r\n        uint _ascii_0 = 48;\r\n        uint _ascii_A = 65;\r\n        uint _ascii_a = 97;\r\n\r\n        bytes memory a = bytes(data);\r\n        uint[] memory b = new uint[](a.length);\r\n\r\n        for (uint i = 0; i < a.length; i++) {\r\n            uint _a = uint(a[i]);\r\n\r\n            if (_a > 96) {\r\n                b[i] = _a - 97 + 10;\r\n            }\r\n            else if (_a > 66) {\r\n                b[i] = _a - 65 + 10;\r\n            }\r\n            else {\r\n                b[i] = _a - 48;\r\n            }\r\n        }\r\n\r\n        bytes memory c = new bytes(b.length / 2);\r\n        for (uint _i = 0; _i < b.length; _i += 2) {\r\n            c[_i / 2] = byte(b[_i] * 16 + b[_i + 1]);\r\n        }\r\n\r\n        return c;\r\n    }\r\n\r\n    function bytesToUint(bytes b) internal pure returns (uint256){\r\n        uint256 number;\r\n        for(uint i=0;i<b.length;i++){\r\n            number = number + uint(b[i])*(2**(8*(b.length-(i+1))));\r\n        }\r\n        return number;\r\n    }\r\n\r\n    function addressToBytes(address a) internal pure returns (bytes b){\r\n        assembly {\r\n            let m := mload(0x40)\r\n            mstore(add(m, 20), xor(0x140000000000000000000000000000000000000000, a))\r\n            mstore(0x40, add(m, 52))\r\n            b := m\r\n        }\r\n    }\r\n\r\n    function stringToUint(string s) internal pure returns (uint) {\r\n        bytes memory b = bytes(s);\r\n        uint result = 0;\r\n        for (uint i = 0; i < b.length; i++) {\r\n           if (b[i] >= 48 && b[i] <= 57){\r\n                result = result * 16 + (uint(b[i]) - 48); // bytes and int are not compatible with the operator -.\r\n            }\r\n            else if(b[i] >= 97 && b[i] <= 122)\r\n            {\r\n                result = result * 16 + (uint(b[i]) - 87);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function subString(string str, uint startIndex, uint endIndex) internal pure returns (string) {\r\n        bytes memory strBytes = bytes(str);\r\n        if(strBytes.length !=48){revert();}\r\n        bytes memory result = new bytes(endIndex-startIndex);\r\n        for(uint i = startIndex; i < endIndex; i++) {\r\n            result[i-startIndex] = strBytes[i];\r\n        }\r\n        return string(result);\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n            for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n                return string(bab);\r\n        }\r\n\r\n    function stringToAddr(string _input) internal pure returns (address){\r\n        string memory _a = strConcat(\"0x\",_input);\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n            return address(iaddr);\r\n    }\r\n}\r\n\r\ncontract IvtMultiSigWallet {\r\n    \r\n    event Deposit(address _sender, uint256 _value);\r\n    event Transacted(address _to, address _tokenContractAddress, uint256 _value);\r\n    event SafeModeActivated(address _sender);\r\n    event Kill(address _safeAddress, uint256 _value);\r\n    event Debuglog(address _address,bool _flag0,bool _flag1);\r\n\r\n    mapping (address => bool) private signers;\r\n    mapping (uint256 => bool) private transactions;\r\n    mapping (address => bool) private signedAddresses;\r\n\r\n    address private owner;\r\n    bool private safeMode;\r\n\r\n    uint8 private required;\r\n    uint8 private safeModeConfirmed;\r\n    address private safeAddress;\r\n\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    constructor(address[] _signers, uint8 _required) public{\r\n        require(_required <= _signers.length && _required > 0 && _signers.length > 0);\r\n\r\n        for (uint8 i = 0; i < _signers.length; i++){\r\n            require(_signers[i] != address(0));\r\n            signers[_signers[i]] = true;\r\n        }\r\n        required = _required;\r\n        owner = msg.sender;\r\n        safeMode = false;\r\n        safeModeConfirmed = 0;\r\n        safeAddress = 0;\r\n    }\r\n\r\n    function() payable public{\r\n        if (msg.value > 0)\r\n            emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function submitTransaction(address _destination, string _value, string _strTransactionData, uint8[] _v, bytes32[] _r, bytes32[] _s) onlyOwner public{\r\n        processAndCheckParam(_destination, _strTransactionData, _v, _r, _s);\r\n\r\n        uint256 transactionValue = RLPEncode.stringToUint(_value);\r\n        bytes32 _msgHash = getMsgHash(_destination, _value, _strTransactionData);\r\n        verifySignatures(_msgHash, _v, _r, _s);\r\n\r\n        _destination.transfer(transactionValue);\r\n\r\n        emit Transacted(_destination, 0, transactionValue);\r\n    }\r\n\r\n    function submitTransactionToken(address _destination, address _tokenContractAddress, string _value, string _strTransactionData, uint8[] _v, bytes32[] _r,bytes32[] _s) onlyOwner public{\r\n        processAndCheckParam(_destination, _strTransactionData, _v, _r, _s);\r\n\r\n        uint256 transactionValue = RLPEncode.stringToUint(_value);\r\n        bytes32 _msgHash = getMsgHash(_destination, _value, _strTransactionData);\r\n        verifySignatures(_msgHash, _v, _r, _s);\r\n\r\n        ERC20Interface instance = ERC20Interface(_tokenContractAddress);\r\n        require(instance.transfer(_destination, transactionValue));\r\n\r\n        emit Transacted(_destination, _tokenContractAddress, transactionValue);\r\n    }\r\n\r\n\r\n    function confirmTransaction(address _safeAddress) public{\r\n        require(safeMode && signers[msg.sender] && signers[_safeAddress]);\r\n        if (safeAddress == 0){\r\n            safeAddress = _safeAddress;\r\n        }\r\n        require(safeAddress == _safeAddress);\r\n        safeModeConfirmed++;\r\n\r\n        delete(signers[msg.sender]);\r\n\r\n        if(safeModeConfirmed >= required){\r\n            emit Kill(safeAddress, address(this).balance);\r\n            selfdestruct(safeAddress);\r\n        }\r\n    }\r\n\r\n    function activateSafeMode() onlyOwner public {\r\n        safeMode = true;\r\n        emit SafeModeActivated(msg.sender);\r\n    }\r\n\r\n    function getMsgHash(address _destination, string _value, string _strTransactionData) constant internal returns (bytes32){\r\n        bytes[] memory rawTx = new bytes[](9);\r\n        bytes[] memory bytesArray = new bytes[](9);\r\n\r\n        rawTx[0] = hex\"09\";\r\n        rawTx[1] = hex\"09502f9000\";\r\n        rawTx[2] = hex\"5208\";\r\n        rawTx[3] = RLPEncode.addressToBytes(_destination);\r\n        rawTx[4] = RLPEncode.strToBytes(_value);\r\n        rawTx[5] = RLPEncode.strToBytes(_strTransactionData);\r\n        rawTx[6] = hex\"01\"; //03=testnet,01=mainnet\r\n\r\n        for(uint8 i = 0; i < 9; i++){\r\n            bytesArray[i] = RLPEncode.encodeBytes(rawTx[i]);\r\n        }\r\n\r\n        bytes memory bytesList = RLPEncode.encodeList(bytesArray);\r\n\r\n        return keccak256(bytesList);\r\n    }\r\n\r\n    function processAndCheckParam(address _destination, string _strTransactionData, uint8[] _v, bytes32[] _r, bytes32[] _s)  internal{\r\n        require(!safeMode && _destination != 0 && _destination != address(this) && _v.length == _r.length && _v.length == _s.length && _v.length > 0);\r\n\r\n        string memory strTransactionTime = RLPEncode.subString(_strTransactionData, 40, 48);\r\n        uint256 transactionTime = RLPEncode.stringToUint(strTransactionTime);\r\n        require(!transactions[transactionTime]);\r\n\r\n        string memory strTransactionAddress = RLPEncode.subString(_strTransactionData, 0, 40);\r\n        address contractAddress = RLPEncode.stringToAddr(strTransactionAddress);\r\n        require(contractAddress == address(this));\r\n\r\n        transactions[transactionTime] = true;\r\n\r\n    }\r\n\r\n    function verifySignatures(bytes32 _msgHash, uint8[] _v, bytes32[] _r,bytes32[] _s)  internal{\r\n        uint8 hasConfirmed = 0;\r\n        address[] memory  tempAddresses = new address[](_v.length);\r\n        address tempAddress;\r\n        \r\n        for (uint8 i = 0; i < _v.length; i++){\r\n            tempAddress = ecrecover(_msgHash, _v[i], _r[i], _s[i]);\r\n            tempAddresses[i] = tempAddress;\r\n\r\n            require(signers[tempAddress] && (!signedAddresses[tempAddress]));\r\n            emit Debuglog(tempAddresses[i],signers[tempAddress],!signedAddresses[tempAddress]);\r\n            signedAddresses[tempAddress] = true;\r\n            hasConfirmed++;\r\n        }\r\n        for (uint8 j = 0; j < _v.length; j++){\r\n            delete signedAddresses[tempAddresses[j]];\r\n        }\r\n        require(hasConfirmed >= required);\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20Interface {\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_safeAddress\",\"type\":\"address\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"string\"},{\"name\":\"_strTransactionData\",\"type\":\"string\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"submitTransactionToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"string\"},{\"name\":\"_strTransactionData\",\"type\":\"string\"},{\"name\":\"_v\",\"type\":\"uint8[]\"},{\"name\":\"_r\",\"type\":\"bytes32[]\"},{\"name\":\"_s\",\"type\":\"bytes32[]\"}],\"name\":\"submitTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activateSafeMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_signers\",\"type\":\"address[]\"},{\"name\":\"_required\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenContractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transacted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"SafeModeActivated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_safeAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Kill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_flag0\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"_flag1\",\"type\":\"bool\"}],\"name\":\"Debuglog\",\"type\":\"event\"}]","ContractName":"IvtMultiSigWallet","CompilerVersion":"v0.4.24-nightly.2018.5.9+commit.1e953355","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000030000000000000000000000000000000000000000000000000000000000000003000000000000000000000000924e96721e4821b23a373eacc3ae112d8a20d5fe000000000000000000000000ef81d2741032b0bca64affe73773c999d977d82000000000000000000000000050f3ceda4d1fdc36e951bf0a9588236a4bc33565","Library":"","SwarmSource":"bzzr://62f203c9be28a50511f39febde6a79ce75ca48693b9b8a46086f9e3ffba3ad15"}]}