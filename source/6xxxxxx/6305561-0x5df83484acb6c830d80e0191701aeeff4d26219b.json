{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address addr, string roleName);\r\n  event RoleRemoved(address addr, string roleName);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address addr, string roleName)\r\n    view\r\n    public\r\n  {\r\n    roles[roleName].check(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address addr, string roleName)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[roleName].has(addr);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function addRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].add(addr);\r\n    emit RoleAdded(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param addr address\r\n   * @param roleName the name of the role\r\n   */\r\n  function removeRole(address addr, string roleName)\r\n    internal\r\n  {\r\n    roles[roleName].remove(addr);\r\n    emit RoleRemoved(addr, roleName);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param roleName the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string roleName)\r\n  {\r\n    checkRole(msg.sender, roleName);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param roleNames the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] roleNames) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < roleNames.length; i++) {\r\n  //         if (hasRole(msg.sender, roleNames[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\ncontract Staff is Ownable, RBAC {\r\n\r\n\tstring public constant ROLE_STAFF = \"staff\";\r\n\r\n\tfunction addStaff(address _staff) public onlyOwner {\r\n\t\taddRole(_staff, ROLE_STAFF);\r\n\t}\r\n\r\n\tfunction removeStaff(address _staff) public onlyOwner {\r\n\t\tremoveRole(_staff, ROLE_STAFF);\r\n\t}\r\n\r\n\tfunction isStaff(address _staff) view public returns (bool) {\r\n\t\treturn hasRole(_staff, ROLE_STAFF);\r\n\t}\r\n}\r\n\r\ncontract StaffUtil {\r\n\tStaff public staffContract;\r\n\r\n\tconstructor (Staff _staffContract) public {\r\n\t\trequire(msg.sender == _staffContract.owner());\r\n\t\tstaffContract = _staffContract;\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == staffContract.owner());\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier onlyOwnerOrStaff() {\r\n\t\trequire(msg.sender == staffContract.owner() || staffContract.isStaff(msg.sender));\r\n\t\t_;\r\n\t}\r\n}\r\n\r\ncontract Crowdsale is StaffUtil {\r\n\tusing SafeMath for uint256;\r\n\r\n\tToken tokenContract;\r\n\tPromoCodes promoCodesContract;\r\n\tDiscountPhases discountPhasesContract;\r\n\tDiscountStructs discountStructsContract;\r\n\r\n\taddress ethFundsWallet;\r\n\tuint256 referralBonusPercent;\r\n\tuint256 startDate;\r\n\r\n\tuint256 crowdsaleStartDate;\r\n\tuint256 endDate;\r\n\tuint256 tokenDecimals;\r\n\tuint256 tokenRate;\r\n\tuint256 tokensForSaleCap;\r\n\tuint256 minPurchaseInWei;\r\n\tuint256 maxInvestorContributionInWei;\r\n\tbool paused;\r\n\tbool finalized;\r\n\tuint256 weiRaised;\r\n\tuint256 soldTokens;\r\n\tuint256 bonusTokens;\r\n\tuint256 sentTokens;\r\n\tuint256 claimedSoldTokens;\r\n\tuint256 claimedBonusTokens;\r\n\tuint256 claimedSentTokens;\r\n\tuint256 purchasedTokensClaimDate;\r\n\tuint256 bonusTokensClaimDate;\r\n\tmapping(address => Investor) public investors;\r\n\r\n\tenum InvestorStatus {UNDEFINED, WHITELISTED, BLOCKED}\r\n\r\n\tstruct Investor {\r\n\t\tInvestorStatus status;\r\n\t\tuint256 contributionInWei;\r\n\t\tuint256 purchasedTokens;\r\n\t\tuint256 bonusTokens;\r\n\t\tuint256 referralTokens;\r\n\t\tuint256 receivedTokens;\r\n\t\tTokensPurchase[] tokensPurchases;\r\n\t\tbool isBlockpass;\r\n\t}\r\n\r\n\tstruct TokensPurchase {\r\n\t\tuint256 value;\r\n\t\tuint256 amount;\r\n\t\tuint256 bonus;\r\n\t\taddress referrer;\r\n\t\tuint256 referrerSentAmount;\r\n\t}\r\n\r\n\tevent InvestorWhitelisted(address indexed investor, uint timestamp, address byStaff);\r\n\tevent InvestorBlocked(address indexed investor, uint timestamp, address byStaff);\r\n\tevent TokensPurchased(\r\n\t\taddress indexed investor,\r\n\t\tuint indexed purchaseId,\r\n\t\tuint256 value,\r\n\t\tuint256 purchasedAmount,\r\n\t\tuint256 promoCodeAmount,\r\n\t\tuint256 discountPhaseAmount,\r\n\t\tuint256 discountStructAmount,\r\n\t\taddress indexed referrer,\r\n\t\tuint256 referrerSentAmount,\r\n\t\tuint timestamp\r\n\t);\r\n\tevent TokensPurchaseRefunded(\r\n\t\taddress indexed investor,\r\n\t\tuint indexed purchaseId,\r\n\t\tuint256 value,\r\n\t\tuint256 amount,\r\n\t\tuint256 bonus,\r\n\t\tuint timestamp,\r\n\t\taddress byStaff\r\n\t);\r\n\tevent Paused(uint timestamp, address byStaff);\r\n\tevent Resumed(uint timestamp, address byStaff);\r\n\tevent Finalized(uint timestamp, address byStaff);\r\n\tevent TokensSent(address indexed investor, uint256 amount, uint timestamp, address byStaff);\r\n\tevent PurchasedTokensClaimLocked(uint date, uint timestamp, address byStaff);\r\n\tevent PurchasedTokensClaimUnlocked(uint timestamp, address byStaff);\r\n\tevent BonusTokensClaimLocked(uint date, uint timestamp, address byStaff);\r\n\tevent BonusTokensClaimUnlocked(uint timestamp, address byStaff);\r\n\tevent CrowdsaleStartDateUpdated(uint date, uint timestamp, address byStaff);\r\n\tevent EndDateUpdated(uint date, uint timestamp, address byStaff);\r\n\tevent MinPurchaseChanged(uint256 minPurchaseInWei, uint timestamp, address byStaff);\r\n\tevent MaxInvestorContributionChanged(uint256 maxInvestorContributionInWei, uint timestamp, address byStaff);\r\n\tevent TokenRateChanged(uint newRate, uint timestamp, address byStaff);\r\n\tevent TokensClaimed(\r\n\t\taddress indexed investor,\r\n\t\tuint256 purchased,\r\n\t\tuint256 bonus,\r\n\t\tuint256 referral,\r\n\t\tuint256 received,\r\n\t\tuint timestamp,\r\n\t\taddress byStaff\r\n\t);\r\n\tevent TokensBurned(uint256 amount, uint timestamp, address byStaff);\r\n\r\n\tconstructor (\r\n\t\tuint256[11] uint256Args,\r\n\t\taddress[5] addressArgs\r\n\t) StaffUtil(Staff(addressArgs[4])) public {\r\n\r\n\t\t// uint256 args\r\n\t\tstartDate = uint256Args[0];\r\n\t\tcrowdsaleStartDate = uint256Args[1];\r\n\t\tendDate = uint256Args[2];\r\n\t\ttokenDecimals = uint256Args[3];\r\n\t\ttokenRate = uint256Args[4];\r\n\t\ttokensForSaleCap = uint256Args[5];\r\n\t\tminPurchaseInWei = uint256Args[6];\r\n\t\tmaxInvestorContributionInWei = uint256Args[7];\r\n\t\tpurchasedTokensClaimDate = uint256Args[8];\r\n\t\tbonusTokensClaimDate = uint256Args[9];\r\n\t\treferralBonusPercent = uint256Args[10];\r\n\r\n\t\t// address args\r\n\t\tethFundsWallet = addressArgs[0];\r\n\t\tpromoCodesContract = PromoCodes(addressArgs[1]);\r\n\t\tdiscountPhasesContract = DiscountPhases(addressArgs[2]);\r\n\t\tdiscountStructsContract = DiscountStructs(addressArgs[3]);\r\n\r\n\t\trequire(startDate < crowdsaleStartDate);\r\n\t\trequire(crowdsaleStartDate < endDate);\r\n\t\trequire(tokenRate > 0);\r\n\t\trequire(tokenRate > 0);\r\n\t\trequire(tokensForSaleCap > 0);\r\n\t\trequire(minPurchaseInWei <= maxInvestorContributionInWei);\r\n\t\trequire(ethFundsWallet != address(0));\r\n\t}\r\n\r\n\tfunction getState() external view returns (bool[2] boolArgs, uint256[18] uint256Args, address[6] addressArgs) {\r\n\t\tboolArgs[0] = paused;\r\n\t\tboolArgs[1] = finalized;\r\n\t\tuint256Args[0] = weiRaised;\r\n\t\tuint256Args[1] = soldTokens;\r\n\t\tuint256Args[2] = bonusTokens;\r\n\t\tuint256Args[3] = sentTokens;\r\n\t\tuint256Args[4] = claimedSoldTokens;\r\n\t\tuint256Args[5] = claimedBonusTokens;\r\n\t\tuint256Args[6] = claimedSentTokens;\r\n\t\tuint256Args[7] = purchasedTokensClaimDate;\r\n\t\tuint256Args[8] = bonusTokensClaimDate;\r\n\t\tuint256Args[9] = startDate;\r\n\t\tuint256Args[10] = crowdsaleStartDate;\r\n\t\tuint256Args[11] = endDate;\r\n\t\tuint256Args[12] = tokenRate;\r\n\t\tuint256Args[13] = tokenDecimals;\r\n\t\tuint256Args[14] = minPurchaseInWei;\r\n\t\tuint256Args[15] = maxInvestorContributionInWei;\r\n\t\tuint256Args[16] = referralBonusPercent;\r\n\t\tuint256Args[17] = getTokensForSaleCap();\r\n\t\taddressArgs[0] = staffContract;\r\n\t\taddressArgs[1] = ethFundsWallet;\r\n\t\taddressArgs[2] = promoCodesContract;\r\n\t\taddressArgs[3] = discountPhasesContract;\r\n\t\taddressArgs[4] = discountStructsContract;\r\n\t\taddressArgs[5] = tokenContract;\r\n\t}\r\n\r\n\tfunction fitsTokensForSaleCap(uint256 _amount) public view returns (bool) {\r\n\t\treturn getDistributedTokens().add(_amount) <= getTokensForSaleCap();\r\n\t}\r\n\r\n\tfunction getTokensForSaleCap() public view returns (uint256) {\r\n\t\tif (tokenContract != address(0)) {\r\n\t\t\treturn tokenContract.balanceOf(this);\r\n\t\t}\r\n\t\treturn tokensForSaleCap;\r\n\t}\r\n\r\n\tfunction getDistributedTokens() public view returns (uint256) {\r\n\t\treturn soldTokens.sub(claimedSoldTokens).add(bonusTokens.sub(claimedBonusTokens)).add(sentTokens.sub(claimedSentTokens));\r\n\t}\r\n\r\n\tfunction setTokenContract(Token token) external onlyOwner {\r\n\t\trequire(token.balanceOf(this) >= 0);\r\n\t\trequire(tokenContract == address(0));\r\n\t\trequire(token != address(0));\r\n\t\ttokenContract = token;\r\n\t}\r\n\r\n\tfunction getInvestorClaimedTokens(address _investor) external view returns (uint256) {\r\n\t\tif (tokenContract != address(0)) {\r\n\t\t\treturn tokenContract.balanceOf(_investor);\r\n\t\t}\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tfunction isBlockpassInvestor(address _investor) external constant returns (bool) {\r\n\t\treturn investors[_investor].status == InvestorStatus.WHITELISTED && investors[_investor].isBlockpass;\r\n\t}\r\n\r\n\tfunction whitelistInvestor(address _investor, bool _isBlockpass) external onlyOwnerOrStaff {\r\n\t\trequire(_investor != address(0));\r\n\t\trequire(investors[_investor].status != InvestorStatus.WHITELISTED);\r\n\r\n\t\tinvestors[_investor].status = InvestorStatus.WHITELISTED;\r\n\t\tinvestors[_investor].isBlockpass = _isBlockpass;\r\n\r\n\t\temit InvestorWhitelisted(_investor, now, msg.sender);\r\n\t}\r\n\r\n\tfunction bulkWhitelistInvestor(address[] _investors) external onlyOwnerOrStaff {\r\n\t\tfor (uint256 i = 0; i < _investors.length; i++) {\r\n\t\t\tif (_investors[i] != address(0) && investors[_investors[i]].status != InvestorStatus.WHITELISTED) {\r\n\t\t\t\tinvestors[_investors[i]].status = InvestorStatus.WHITELISTED;\r\n\t\t\t\temit InvestorWhitelisted(_investors[i], now, msg.sender);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction blockInvestor(address _investor) external onlyOwnerOrStaff {\r\n\t\trequire(_investor != address(0));\r\n\t\trequire(investors[_investor].status != InvestorStatus.BLOCKED);\r\n\r\n\t\tinvestors[_investor].status = InvestorStatus.BLOCKED;\r\n\r\n\t\temit InvestorBlocked(_investor, now, msg.sender);\r\n\t}\r\n\r\n\tfunction lockPurchasedTokensClaim(uint256 _date) external onlyOwner {\r\n\t\trequire(_date > now);\r\n\t\tpurchasedTokensClaimDate = _date;\r\n\t\temit PurchasedTokensClaimLocked(_date, now, msg.sender);\r\n\t}\r\n\r\n\tfunction unlockPurchasedTokensClaim() external onlyOwner {\r\n\t\tpurchasedTokensClaimDate = now;\r\n\t\temit PurchasedTokensClaimUnlocked(now, msg.sender);\r\n\t}\r\n\r\n\tfunction lockBonusTokensClaim(uint256 _date) external onlyOwner {\r\n\t\trequire(_date > now);\r\n\t\tbonusTokensClaimDate = _date;\r\n\t\temit BonusTokensClaimLocked(_date, now, msg.sender);\r\n\t}\r\n\r\n\tfunction unlockBonusTokensClaim() external onlyOwner {\r\n\t\tbonusTokensClaimDate = now;\r\n\t\temit BonusTokensClaimUnlocked(now, msg.sender);\r\n\t}\r\n\r\n\tfunction setCrowdsaleStartDate(uint256 _date) external onlyOwner {\r\n\t\tcrowdsaleStartDate = _date;\r\n\t\temit CrowdsaleStartDateUpdated(_date, now, msg.sender);\r\n\t}\r\n\r\n\tfunction setEndDate(uint256 _date) external onlyOwner {\r\n\t\tendDate = _date;\r\n\t\temit EndDateUpdated(_date, now, msg.sender);\r\n\t}\r\n\r\n\tfunction setMinPurchaseInWei(uint256 _minPurchaseInWei) external onlyOwner {\r\n\t\tminPurchaseInWei = _minPurchaseInWei;\r\n\t\temit MinPurchaseChanged(_minPurchaseInWei, now, msg.sender);\r\n\t}\r\n\r\n\tfunction setMaxInvestorContributionInWei(uint256 _maxInvestorContributionInWei) external onlyOwner {\r\n\t\trequire(minPurchaseInWei <= _maxInvestorContributionInWei);\r\n\t\tmaxInvestorContributionInWei = _maxInvestorContributionInWei;\r\n\t\temit MaxInvestorContributionChanged(_maxInvestorContributionInWei, now, msg.sender);\r\n\t}\r\n\r\n\tfunction changeTokenRate(uint256 _tokenRate) external onlyOwner {\r\n\t\trequire(_tokenRate > 0);\r\n\t\ttokenRate = _tokenRate;\r\n\t\temit TokenRateChanged(_tokenRate, now, msg.sender);\r\n\t}\r\n\r\n\tfunction buyTokens(bytes32 _promoCode, address _referrer) external payable {\r\n\t\trequire(!finalized);\r\n\t\trequire(!paused);\r\n\t\trequire(startDate < now);\r\n\t\trequire(investors[msg.sender].status == InvestorStatus.WHITELISTED);\r\n\t\trequire(msg.value > 0);\r\n\t\trequire(msg.value >= minPurchaseInWei);\r\n\t\trequire(investors[msg.sender].contributionInWei.add(msg.value) <= maxInvestorContributionInWei);\r\n\r\n\t\t// calculate purchased amount\r\n\t\tuint256 purchasedAmount;\r\n\t\tif (tokenDecimals > 18) {\r\n\t\t\tpurchasedAmount = msg.value.mul(tokenRate).mul(10 ** (tokenDecimals - 18));\r\n\t\t} else if (tokenDecimals < 18) {\r\n\t\t\tpurchasedAmount = msg.value.mul(tokenRate).div(10 ** (18 - tokenDecimals));\r\n\t\t} else {\r\n\t\t\tpurchasedAmount = msg.value.mul(tokenRate);\r\n\t\t}\r\n\r\n\t\t// calculate total amount, this includes promo code amount or discount phase amount\r\n\t\tuint256 promoCodeBonusAmount = promoCodesContract.applyBonusAmount(msg.sender, purchasedAmount, _promoCode);\r\n\t\tuint256 discountPhaseBonusAmount = discountPhasesContract.calculateBonusAmount(purchasedAmount);\r\n\t\tuint256 discountStructBonusAmount = discountStructsContract.getBonus(msg.sender, purchasedAmount, msg.value);\r\n\t\tuint256 bonusAmount = promoCodeBonusAmount.add(discountPhaseBonusAmount).add(discountStructBonusAmount);\r\n\r\n\t\t// update referrer's referral tokens\r\n\t\tuint256 referrerBonusAmount;\r\n\t\taddress referrerAddr;\r\n\t\tif (\r\n\t\t\t_referrer != address(0)\r\n\t\t\t&& msg.sender != _referrer\r\n\t\t\t&& investors[_referrer].status == InvestorStatus.WHITELISTED\r\n\t\t) {\r\n\t\t\treferrerBonusAmount = purchasedAmount * referralBonusPercent / 100;\r\n\t\t\treferrerAddr = _referrer;\r\n\t\t}\r\n\r\n\t\t// check that calculated tokens will not exceed tokens for sale cap\r\n\t\trequire(fitsTokensForSaleCap(purchasedAmount.add(bonusAmount).add(referrerBonusAmount)));\r\n\r\n\t\t// update crowdsale total amount of capital raised\r\n\t\tweiRaised = weiRaised.add(msg.value);\r\n\t\tsoldTokens = soldTokens.add(purchasedAmount);\r\n\t\tbonusTokens = bonusTokens.add(bonusAmount).add(referrerBonusAmount);\r\n\r\n\t\t// update referrer's bonus tokens\r\n\t\tinvestors[referrerAddr].referralTokens = investors[referrerAddr].referralTokens.add(referrerBonusAmount);\r\n\r\n\t\t// update investor's purchased tokens\r\n\t\tinvestors[msg.sender].purchasedTokens = investors[msg.sender].purchasedTokens.add(purchasedAmount);\r\n\r\n\t\t// update investor's bonus tokens\r\n\t\tinvestors[msg.sender].bonusTokens = investors[msg.sender].bonusTokens.add(bonusAmount);\r\n\r\n\t\t// update investor's tokens eth value\r\n\t\tinvestors[msg.sender].contributionInWei = investors[msg.sender].contributionInWei.add(msg.value);\r\n\r\n\t\t// update investor's tokens purchases\r\n\t\tuint tokensPurchasesLength = investors[msg.sender].tokensPurchases.push(TokensPurchase({\r\n\t\t\tvalue : msg.value,\r\n\t\t\tamount : purchasedAmount,\r\n\t\t\tbonus : bonusAmount,\r\n\t\t\treferrer : referrerAddr,\r\n\t\t\treferrerSentAmount : referrerBonusAmount\r\n\t\t\t})\r\n\t\t);\r\n\r\n\t\t// log investor's tokens purchase\r\n\t\temit TokensPurchased(\r\n\t\t\tmsg.sender,\r\n\t\t\ttokensPurchasesLength - 1,\r\n\t\t\tmsg.value,\r\n\t\t\tpurchasedAmount,\r\n\t\t\tpromoCodeBonusAmount,\r\n\t\t\tdiscountPhaseBonusAmount,\r\n\t\t\tdiscountStructBonusAmount,\r\n\t\t\treferrerAddr,\r\n\t\t\treferrerBonusAmount,\r\n\t\t\tnow\r\n\t\t);\r\n\r\n\t\t// forward eth to funds wallet\r\n\t\trequire(ethFundsWallet.call.gas(300000).value(msg.value)());\r\n\t}\r\n\r\n\tfunction sendTokens(address _investor, uint256 _amount) external onlyOwner {\r\n\t\trequire(investors[_investor].status == InvestorStatus.WHITELISTED);\r\n\t\trequire(_amount > 0);\r\n\t\trequire(fitsTokensForSaleCap(_amount));\r\n\r\n\t\t// update crowdsale total amount of capital raised\r\n\t\tsentTokens = sentTokens.add(_amount);\r\n\r\n\t\t// update investor's received tokens balance\r\n\t\tinvestors[_investor].receivedTokens = investors[_investor].receivedTokens.add(_amount);\r\n\r\n\t\t// log tokens sent action\r\n\t\temit TokensSent(\r\n\t\t\t_investor,\r\n\t\t\t_amount,\r\n\t\t\tnow,\r\n\t\t\tmsg.sender\r\n\t\t);\r\n\t}\r\n\r\n\tfunction burnUnsoldTokens() external onlyOwner {\r\n\t\trequire(tokenContract != address(0));\r\n\t\trequire(finalized);\r\n\r\n\t\tuint256 tokensToBurn = tokenContract.balanceOf(this).sub(getDistributedTokens());\r\n\t\trequire(tokensToBurn > 0);\r\n\r\n\t\ttokenContract.burn(tokensToBurn);\r\n\r\n\t\t// log tokens burned action\r\n\t\temit TokensBurned(tokensToBurn, now, msg.sender);\r\n\t}\r\n\r\n\tfunction claimTokens() external {\r\n\t\trequire(tokenContract != address(0));\r\n\t\trequire(!paused);\r\n\t\trequire(investors[msg.sender].status == InvestorStatus.WHITELISTED);\r\n\r\n\t\tuint256 clPurchasedTokens;\r\n\t\tuint256 clReceivedTokens;\r\n\t\tuint256 clBonusTokens_;\r\n\t\tuint256 clRefTokens;\r\n\r\n\t\trequire(purchasedTokensClaimDate < now || bonusTokensClaimDate < now);\r\n\r\n\t\t{\r\n\t\t\tuint256 purchasedTokens = investors[msg.sender].purchasedTokens;\r\n\t\t\tuint256 receivedTokens = investors[msg.sender].receivedTokens;\r\n\t\t\tif (purchasedTokensClaimDate < now && (purchasedTokens > 0 || receivedTokens > 0)) {\r\n\t\t\t\tinvestors[msg.sender].contributionInWei = 0;\r\n\t\t\t\tinvestors[msg.sender].purchasedTokens = 0;\r\n\t\t\t\tinvestors[msg.sender].receivedTokens = 0;\r\n\r\n\t\t\t\tclaimedSoldTokens = claimedSoldTokens.add(purchasedTokens);\r\n\t\t\t\tclaimedSentTokens = claimedSentTokens.add(receivedTokens);\r\n\r\n\t\t\t\t// free up storage used by transaction\r\n\t\t\t\tdelete (investors[msg.sender].tokensPurchases);\r\n\r\n\t\t\t\tclPurchasedTokens = purchasedTokens;\r\n\t\t\t\tclReceivedTokens = receivedTokens;\r\n\r\n\t\t\t\ttokenContract.transfer(msg.sender, purchasedTokens.add(receivedTokens));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\t{\r\n\t\t\tuint256 bonusTokens_ = investors[msg.sender].bonusTokens;\r\n\t\t\tuint256 refTokens = investors[msg.sender].referralTokens;\r\n\t\t\tif (bonusTokensClaimDate < now && (bonusTokens_ > 0 || refTokens > 0)) {\r\n\t\t\t\tinvestors[msg.sender].bonusTokens = 0;\r\n\t\t\t\tinvestors[msg.sender].referralTokens = 0;\r\n\r\n\t\t\t\tclaimedBonusTokens = claimedBonusTokens.add(bonusTokens_).add(refTokens);\r\n\r\n\t\t\t\tclBonusTokens_ = bonusTokens_;\r\n\t\t\t\tclRefTokens = refTokens;\r\n\r\n\t\t\t\ttokenContract.transfer(msg.sender, bonusTokens_.add(refTokens));\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\trequire(clPurchasedTokens > 0 || clBonusTokens_ > 0 || clRefTokens > 0 || clReceivedTokens > 0);\r\n\t\temit TokensClaimed(msg.sender, clPurchasedTokens, clBonusTokens_, clRefTokens, clReceivedTokens, now, msg.sender);\r\n\t}\r\n\r\n\tfunction refundTokensPurchase(address _investor, uint _purchaseId) external payable onlyOwner {\r\n\t\trequire(msg.value > 0);\r\n\t\trequire(investors[_investor].tokensPurchases[_purchaseId].value == msg.value);\r\n\r\n\t\t_refundTokensPurchase(_investor, _purchaseId);\r\n\r\n\t\t// forward eth to investor's wallet address\r\n\t\t_investor.transfer(msg.value);\r\n\t}\r\n\r\n\tfunction refundAllInvestorTokensPurchases(address _investor) external payable onlyOwner {\r\n\t\trequire(msg.value > 0);\r\n\t\trequire(investors[_investor].contributionInWei == msg.value);\r\n\r\n\t\tfor (uint i = 0; i < investors[_investor].tokensPurchases.length; i++) {\r\n\t\t\tif (investors[_investor].tokensPurchases[i].value == 0) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\r\n\t\t\t_refundTokensPurchase(_investor, i);\r\n\t\t}\r\n\r\n\t\t// forward eth to investor's wallet address\r\n\t\t_investor.transfer(msg.value);\r\n\t}\r\n\r\n\tfunction _refundTokensPurchase(address _investor, uint _purchaseId) private {\r\n\t\t// update referrer's referral tokens\r\n\t\taddress referrer = investors[_investor].tokensPurchases[_purchaseId].referrer;\r\n\t\tif (referrer != address(0)) {\r\n\t\t\tuint256 sentAmount = investors[_investor].tokensPurchases[_purchaseId].referrerSentAmount;\r\n\t\t\tinvestors[referrer].referralTokens = investors[referrer].referralTokens.sub(sentAmount);\r\n\t\t\tbonusTokens = bonusTokens.sub(sentAmount);\r\n\t\t}\r\n\r\n\t\t// update investor's eth amount\r\n\t\tuint256 purchaseValue = investors[_investor].tokensPurchases[_purchaseId].value;\r\n\t\tinvestors[_investor].contributionInWei = investors[_investor].contributionInWei.sub(purchaseValue);\r\n\r\n\t\t// update investor's purchased tokens\r\n\t\tuint256 purchaseAmount = investors[_investor].tokensPurchases[_purchaseId].amount;\r\n\t\tinvestors[_investor].purchasedTokens = investors[_investor].purchasedTokens.sub(purchaseAmount);\r\n\r\n\t\t// update investor's bonus tokens\r\n\t\tuint256 bonusAmount = investors[_investor].tokensPurchases[_purchaseId].bonus;\r\n\t\tinvestors[_investor].bonusTokens = investors[_investor].bonusTokens.sub(bonusAmount);\r\n\r\n\t\t// update crowdsale total amount of capital raised\r\n\t\tweiRaised = weiRaised.sub(purchaseValue);\r\n\t\tsoldTokens = soldTokens.sub(purchaseAmount);\r\n\t\tbonusTokens = bonusTokens.sub(bonusAmount);\r\n\r\n\t\t// free up storage used by transaction\r\n\t\tdelete (investors[_investor].tokensPurchases[_purchaseId]);\r\n\r\n\t\t// log investor's tokens purchase refund\r\n\t\temit TokensPurchaseRefunded(_investor, _purchaseId, purchaseValue, purchaseAmount, bonusAmount, now, msg.sender);\r\n\t}\r\n\r\n\tfunction getInvestorTokensPurchasesLength(address _investor) public constant returns (uint) {\r\n\t\treturn investors[_investor].tokensPurchases.length;\r\n\t}\r\n\r\n\tfunction getInvestorTokensPurchase(\r\n\t\taddress _investor,\r\n\t\tuint _purchaseId\r\n\t) external constant returns (\r\n\t\tuint256 value,\r\n\t\tuint256 amount,\r\n\t\tuint256 bonus,\r\n\t\taddress referrer,\r\n\t\tuint256 referrerSentAmount\r\n\t) {\r\n\t\tvalue = investors[_investor].tokensPurchases[_purchaseId].value;\r\n\t\tamount = investors[_investor].tokensPurchases[_purchaseId].amount;\r\n\t\tbonus = investors[_investor].tokensPurchases[_purchaseId].bonus;\r\n\t\treferrer = investors[_investor].tokensPurchases[_purchaseId].referrer;\r\n\t\treferrerSentAmount = investors[_investor].tokensPurchases[_purchaseId].referrerSentAmount;\r\n\t}\r\n\r\n\tfunction pause() external onlyOwner {\r\n\t\trequire(!paused);\r\n\r\n\t\tpaused = true;\r\n\r\n\t\temit Paused(now, msg.sender);\r\n\t}\r\n\r\n\tfunction resume() external onlyOwner {\r\n\t\trequire(paused);\r\n\r\n\t\tpaused = false;\r\n\r\n\t\temit Resumed(now, msg.sender);\r\n\t}\r\n\r\n\tfunction finalize() external onlyOwner {\r\n\t\trequire(!finalized);\r\n\r\n\t\tfinalized = true;\r\n\r\n\t\temit Finalized(now, msg.sender);\r\n\t}\r\n}\r\n\r\ncontract DiscountPhases is StaffUtil {\r\n\r\n\tevent DiscountPhaseAdded(uint index, string name, uint8 percent, uint fromDate, uint toDate, uint timestamp, address byStaff);\r\n\tevent DiscountPhaseRemoved(uint index, uint timestamp, address byStaff);\r\n\r\n\tstruct DiscountPhase {\r\n\t\tuint8 percent;\r\n\t\tuint fromDate;\r\n\t\tuint toDate;\r\n\t}\r\n\r\n\tDiscountPhase[] public discountPhases;\r\n\r\n\tconstructor(Staff _staffContract) StaffUtil(_staffContract) public {\r\n\t}\r\n\r\n\tfunction calculateBonusAmount(uint256 _purchasedAmount) public constant returns (uint256) {\r\n\t\tfor (uint i = 0; i < discountPhases.length; i++) {\r\n\t\t\tif (now >= discountPhases[i].fromDate && now <= discountPhases[i].toDate) {\r\n\t\t\t\treturn _purchasedAmount * discountPhases[i].percent / 100;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addDiscountPhase(string _name, uint8 _percent, uint _fromDate, uint _toDate) public onlyOwnerOrStaff {\r\n\t\trequire(bytes(_name).length > 0);\r\n\t\trequire(_percent > 0);\r\n\r\n\t\tif (now > _fromDate) {\r\n\t\t\t_fromDate = now;\r\n\t\t}\r\n\t\trequire(_fromDate < _toDate);\r\n\r\n\t\tfor (uint i = 0; i < discountPhases.length; i++) {\r\n\t\t\trequire(_fromDate > discountPhases[i].toDate || _toDate < discountPhases[i].fromDate);\r\n\t\t}\r\n\r\n\t\tuint index = discountPhases.push(DiscountPhase({percent : _percent, fromDate : _fromDate, toDate : _toDate})) - 1;\r\n\r\n\t\temit DiscountPhaseAdded(index, _name, _percent, _fromDate, _toDate, now, msg.sender);\r\n\t}\r\n\r\n\tfunction removeDiscountPhase(uint _index) public onlyOwnerOrStaff {\r\n\t\trequire(now < discountPhases[_index].toDate);\r\n\t\tdelete discountPhases[_index];\r\n\t\temit DiscountPhaseRemoved(_index, now, msg.sender);\r\n\t}\r\n}\r\n\r\ncontract DiscountStructs is StaffUtil {\r\n\tusing SafeMath for uint256;\r\n\r\n\taddress public crowdsale;\r\n\r\n\tevent DiscountStructAdded(\r\n\t\tuint index,\r\n\t\tbytes32 name,\r\n\t\tuint256 tokens,\r\n\t\tuint[2] dates,\r\n\t\tuint256[] fromWei,\r\n\t\tuint256[] toWei,\r\n\t\tuint256[] percent,\r\n\t\tuint timestamp,\r\n\t\taddress byStaff\r\n\t);\r\n\tevent DiscountStructRemoved(\r\n\t\tuint index,\r\n\t\tuint timestamp,\r\n\t\taddress byStaff\r\n\t);\r\n\tevent DiscountStructUsed(\r\n\t\tuint index,\r\n\t\tuint step,\r\n\t\taddress investor,\r\n\t\tuint256 tokens,\r\n\t\tuint timestamp\r\n\t);\r\n\r\n\tstruct DiscountStruct {\r\n\t\tuint256 availableTokens;\r\n\t\tuint256 distributedTokens;\r\n\t\tuint fromDate;\r\n\t\tuint toDate;\r\n\t}\r\n\r\n\tstruct DiscountStep {\r\n\t\tuint256 fromWei;\r\n\t\tuint256 toWei;\r\n\t\tuint256 percent;\r\n\t}\r\n\r\n\tDiscountStruct[] public discountStructs;\r\n\tmapping(uint => DiscountStep[]) public discountSteps;\r\n\r\n\tconstructor(Staff _staffContract) StaffUtil(_staffContract) public {\r\n\t}\r\n\r\n\tmodifier onlyCrowdsale() {\r\n\t\trequire(msg.sender == crowdsale);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction setCrowdsale(Crowdsale _crowdsale) external onlyOwner {\r\n\t\trequire(crowdsale == address(0));\r\n\t\trequire(_crowdsale.staffContract() == staffContract);\r\n\t\tcrowdsale = _crowdsale;\r\n\t}\r\n\r\n\tfunction getBonus(address _investor, uint256 _purchasedAmount, uint256 _purchasedValue) public onlyCrowdsale returns (uint256) {\r\n\t\tfor (uint i = 0; i < discountStructs.length; i++) {\r\n\t\t\tif (now >= discountStructs[i].fromDate && now <= discountStructs[i].toDate) {\r\n\r\n\t\t\t\tif (discountStructs[i].distributedTokens >= discountStructs[i].availableTokens) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (uint j = 0; j < discountSteps[i].length; j++) {\r\n\t\t\t\t\tif (_purchasedValue >= discountSteps[i][j].fromWei\r\n\t\t\t\t\t\t&& (_purchasedValue < discountSteps[i][j].toWei || discountSteps[i][j].toWei == 0)) {\r\n\t\t\t\t\t\tuint256 bonus = _purchasedAmount * discountSteps[i][j].percent / 100;\r\n\t\t\t\t\t\tif (discountStructs[i].distributedTokens.add(bonus) > discountStructs[i].availableTokens) {\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tdiscountStructs[i].distributedTokens = discountStructs[i].distributedTokens.add(bonus);\r\n\t\t\t\t\t\temit DiscountStructUsed(i, j, _investor, bonus, now);\r\n\t\t\t\t\t\treturn bonus;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction calculateBonus(uint256 _purchasedAmount, uint256 _purchasedValue) public constant returns (uint256) {\r\n\t\tfor (uint i = 0; i < discountStructs.length; i++) {\r\n\t\t\tif (now >= discountStructs[i].fromDate && now <= discountStructs[i].toDate) {\r\n\r\n\t\t\t\tif (discountStructs[i].distributedTokens >= discountStructs[i].availableTokens) {\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (uint j = 0; j < discountSteps[i].length; j++) {\r\n\t\t\t\t\tif (_purchasedValue >= discountSteps[i][j].fromWei\r\n\t\t\t\t\t\t&& (_purchasedValue < discountSteps[i][j].toWei || discountSteps[i][j].toWei == 0)) {\r\n\t\t\t\t\t\tuint256 bonus = _purchasedAmount * discountSteps[i][j].percent / 100;\r\n\t\t\t\t\t\tif (discountStructs[i].distributedTokens.add(bonus) > discountStructs[i].availableTokens) {\r\n\t\t\t\t\t\t\treturn;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn bonus;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction addDiscountStruct(bytes32 _name, uint256 _tokens, uint[2] _dates, uint256[] _fromWei, uint256[] _toWei, uint256[] _percent) external onlyOwnerOrStaff {\r\n\t\trequire(_name.length > 0);\r\n\t\trequire(_tokens > 0);\r\n\t\trequire(_dates[0] < _dates[1]);\r\n\t\trequire(_fromWei.length > 0 && _fromWei.length == _toWei.length && _fromWei.length == _percent.length);\r\n\r\n\t\tfor (uint j = 0; j < discountStructs.length; j++) {\r\n\t\t\trequire(_dates[0] > discountStructs[j].fromDate || _dates[1] < discountStructs[j].toDate);\r\n\t\t}\r\n\r\n\t\tDiscountStruct memory ds = DiscountStruct(_tokens, 0, _dates[0], _dates[1]);\r\n\t\tuint index = discountStructs.push(ds) - 1;\r\n\r\n\t\tfor (uint i = 0; i < _fromWei.length; i++) {\r\n\t\t\trequire(_fromWei[i] > 0 || _toWei[i] > 0);\r\n\t\t\trequire(_percent[i] > 0);\r\n\t\t\tdiscountSteps[index].push(DiscountStep(_fromWei[i], _toWei[i], _percent[i]));\r\n\t\t}\r\n\r\n\t\temit DiscountStructAdded(index, _name, _tokens, _dates, _fromWei, _toWei, _percent, now, msg.sender);\r\n\t}\r\n\r\n\tfunction removeDiscountStruct(uint _index) public onlyOwnerOrStaff {\r\n\t\trequire(now < discountStructs[_index].toDate);\r\n\t\tdelete discountStructs[_index];\r\n\t\tdelete discountSteps[_index];\r\n\t\temit DiscountStructRemoved(_index, now, msg.sender);\r\n\t}\r\n}\r\n\r\ncontract PromoCodes is StaffUtil {\r\n\taddress public crowdsale;\r\n\r\n\tevent PromoCodeAdded(bytes32 indexed code, string name, uint8 percent, uint256 maxUses, uint timestamp, address byStaff);\r\n\tevent PromoCodeRemoved(bytes32 indexed code, uint timestamp, address byStaff);\r\n\tevent PromoCodeUsed(bytes32 indexed code, address investor, uint timestamp);\r\n\r\n\tstruct PromoCode {\r\n\t\tuint8 percent;\r\n\t\tuint256 uses;\r\n\t\tuint256 maxUses;\r\n\t\tmapping(address => bool) investors;\r\n\t}\r\n\r\n\tmapping(bytes32 => PromoCode) public promoCodes;\r\n\r\n\tconstructor(Staff _staffContract) StaffUtil(_staffContract) public {\r\n\t}\r\n\r\n\tmodifier onlyCrowdsale() {\r\n\t\trequire(msg.sender == crowdsale);\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction setCrowdsale(Crowdsale _crowdsale) external onlyOwner {\r\n\t\trequire(crowdsale == address(0));\r\n\t\trequire(_crowdsale.staffContract() == staffContract);\r\n\t\tcrowdsale = _crowdsale;\r\n\t}\r\n\r\n\tfunction applyBonusAmount(address _investor, uint256 _purchasedAmount, bytes32 _promoCode) public onlyCrowdsale returns (uint256) {\r\n\t\tif (promoCodes[_promoCode].percent == 0\r\n\t\t|| promoCodes[_promoCode].investors[_investor]\r\n\t\t|| promoCodes[_promoCode].uses == promoCodes[_promoCode].maxUses) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\tpromoCodes[_promoCode].investors[_investor] = true;\r\n\t\tpromoCodes[_promoCode].uses = promoCodes[_promoCode].uses + 1;\r\n\t\temit PromoCodeUsed(_promoCode, _investor, now);\r\n\t\treturn _purchasedAmount * promoCodes[_promoCode].percent / 100;\r\n\t}\r\n\r\n\tfunction calculateBonusAmount(address _investor, uint256 _purchasedAmount, bytes32 _promoCode) public constant returns (uint256) {\r\n\t\tif (promoCodes[_promoCode].percent == 0\r\n\t\t|| promoCodes[_promoCode].investors[_investor]\r\n\t\t|| promoCodes[_promoCode].uses == promoCodes[_promoCode].maxUses) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\t\treturn _purchasedAmount * promoCodes[_promoCode].percent / 100;\r\n\t}\r\n\r\n\tfunction addPromoCode(string _name, bytes32 _code, uint256 _maxUses, uint8 _percent) public onlyOwnerOrStaff {\r\n\t\trequire(bytes(_name).length > 0);\r\n\t\trequire(_code[0] != 0);\r\n\t\trequire(_percent > 0);\r\n\t\trequire(_maxUses > 0);\r\n\t\trequire(promoCodes[_code].percent == 0);\r\n\r\n\t\tpromoCodes[_code].percent = _percent;\r\n\t\tpromoCodes[_code].maxUses = _maxUses;\r\n\r\n\t\temit PromoCodeAdded(_code, _name, _percent, _maxUses, now, msg.sender);\r\n\t}\r\n\r\n\tfunction removePromoCode(bytes32 _code) public onlyOwnerOrStaff {\r\n\t\tdelete promoCodes[_code];\r\n\t\temit PromoCodeRemoved(_code, now, msg.sender);\r\n\t}\r\n}\r\n\r\ncontract Token is BurnableToken {\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"discountStructs\",\"outputs\":[{\"name\":\"availableTokens\",\"type\":\"uint256\"},{\"name\":\"distributedTokens\",\"type\":\"uint256\"},{\"name\":\"fromDate\",\"type\":\"uint256\"},{\"name\":\"toDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"discountSteps\",\"outputs\":[{\"name\":\"fromWei\",\"type\":\"uint256\"},{\"name\":\"toWei\",\"type\":\"uint256\"},{\"name\":\"percent\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"name\":\"setCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_dates\",\"type\":\"uint256[2]\"},{\"name\":\"_fromWei\",\"type\":\"uint256[]\"},{\"name\":\"_toWei\",\"type\":\"uint256[]\"},{\"name\":\"_percent\",\"type\":\"uint256[]\"}],\"name\":\"addDiscountStruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_purchasedAmount\",\"type\":\"uint256\"},{\"name\":\"_purchasedValue\",\"type\":\"uint256\"}],\"name\":\"calculateBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_purchasedAmount\",\"type\":\"uint256\"},{\"name\":\"_purchasedValue\",\"type\":\"uint256\"}],\"name\":\"getBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"removeDiscountStruct\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"staffContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_staffContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dates\",\"type\":\"uint256[2]\"},{\"indexed\":false,\"name\":\"fromWei\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"toWei\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"percent\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"byStaff\",\"type\":\"address\"}],\"name\":\"DiscountStructAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"byStaff\",\"type\":\"address\"}],\"name\":\"DiscountStructRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"index\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"step\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DiscountStructUsed\",\"type\":\"event\"}]","ContractName":"DiscountStructs","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000001dbaddf4e9b51e7e66ef541b8a7fc900b0b2dcd","Library":"","SwarmSource":"bzzr://1abff68e4fb228ddc33803456eade372746601f9744fbf3f2d63b824a2ba1019"}]}