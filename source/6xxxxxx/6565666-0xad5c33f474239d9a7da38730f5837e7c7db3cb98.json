{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/// @title Proxied - indicates that a contract will be proxied. Also defines storage requirements for Proxy.\r\n/// @author Alan Lu - <alan@gnosis.pm>\r\ncontract Proxied {\r\n    address public masterCopy;\r\n}\r\n\r\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract Proxy is Proxied {\r\n    /// @dev Constructor function sets address of master copy contract.\r\n    /// @param _masterCopy Master copy address.\r\n    constructor(address _masterCopy)\r\n        public\r\n    {\r\n        require(_masterCopy != 0);\r\n        masterCopy = _masterCopy;\r\n    }\r\n\r\n    /// @dev Fallback function forwards all transactions and returns all received return data.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n        address _masterCopy = masterCopy;\r\n        assembly {\r\n            calldatacopy(0, 0, calldatasize())\r\n            let success := delegatecall(not(0), _masterCopy, 0, calldatasize(), 0, 0)\r\n            returndatacopy(0, 0, returndatasize())\r\n            switch success\r\n            case 0 { revert(0, returndatasize()) }\r\n            default { return(0, returndatasize()) }\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Fixed192x64Math library - Allows calculation of logarithmic and exponential functions\r\n/// @author Alan Lu - <alan.lu@gnosis.pm>\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\nlibrary Fixed192x64Math {\r\n\r\n    enum EstimationMode { LowerBound, UpperBound, Midpoint }\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    // This is equal to 1 in our calculations\r\n    uint public constant ONE =  0x10000000000000000;\r\n    uint public constant LN2 = 0xb17217f7d1cf79ac;\r\n    uint public constant LOG2_E = 0x171547652b82fe177;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Returns natural exponential function value of given x\r\n    /// @param x x\r\n    /// @return e**x\r\n    function exp(int x)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        // revert if x is > MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE) * ONE))\r\n        require(x <= 2454971259878909886679);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE) * ONE))\r\n        if (x <= -818323753292969962227)\r\n            return 0;\r\n\r\n        // Transform so that e^x -> 2^x\r\n        (uint lower, uint upper) = pow2Bounds(x * int(ONE) / int(LN2));\r\n        return (upper - lower) / 2 + lower;\r\n    }\r\n\r\n    /// @dev Returns estimate of 2**x given x\r\n    /// @param x exponent in fixed point\r\n    /// @param estimationMode whether to return a lower bound, upper bound, or a midpoint\r\n    /// @return estimate of 2**x in fixed point\r\n    function pow2(int x, EstimationMode estimationMode)\r\n        public\r\n        pure\r\n        returns (uint)\r\n    {\r\n        (uint lower, uint upper) = pow2Bounds(x);\r\n        if(estimationMode == EstimationMode.LowerBound) {\r\n            return lower;\r\n        }\r\n        if(estimationMode == EstimationMode.UpperBound) {\r\n            return upper;\r\n        }\r\n        if(estimationMode == EstimationMode.Midpoint) {\r\n            return (upper - lower) / 2 + lower;\r\n        }\r\n        revert();\r\n    }\r\n\r\n    /// @dev Returns bounds for value of 2**x given x\r\n    /// @param x exponent in fixed point\r\n    /// @return {\r\n    ///   \"lower\": \"lower bound of 2**x in fixed point\",\r\n    ///   \"upper\": \"upper bound of 2**x in fixed point\"\r\n    /// }\r\n    function pow2Bounds(int x)\r\n        public\r\n        pure\r\n        returns (uint lower, uint upper)\r\n    {\r\n        // revert if x is > MAX_POWER, where\r\n        // MAX_POWER = int(mp.floor(mp.log(mpf(2**256 - 1) / ONE, 2) * ONE))\r\n        require(x <= 3541774862152233910271);\r\n        // return 0 if exp(x) is tiny, using\r\n        // MIN_POWER = int(mp.floor(mp.log(mpf(1) / ONE, 2) * ONE))\r\n        if (x < -1180591620717411303424)\r\n            return (0, 1);\r\n\r\n        // 2^x = 2^(floor(x)) * 2^(x-floor(x))\r\n        //       ^^^^^^^^^^^^^^ is a bit shift of ceil(x)\r\n        // so Taylor expand on z = x-floor(x), z in [0, 1)\r\n        int shift;\r\n        int z;\r\n        if (x >= 0) {\r\n            shift = x / int(ONE);\r\n            z = x % int(ONE);\r\n        }\r\n        else {\r\n            shift = (x+1) / int(ONE) - 1;\r\n            z = x - (int(ONE) * shift);\r\n        }\r\n        assert(z >= 0);\r\n        // 2^x = 1 + (ln 2) x + (ln 2)^2/2! x^2 + ...\r\n        //\r\n        // Can generate the z coefficients using mpmath and the following lines\r\n        // >>> from mpmath import mp\r\n        // >>> mp.dps = 100\r\n        // >>> coeffs = [mp.log(2)**i / mp.factorial(i) for i in range(1, 21)]\r\n        // >>> shifts = [64 - int(mp.log(c, 2)) for c in coeffs]\r\n        // >>> print('\\n'.join(hex(int(c * (1 << s))) + ', ' + str(s) for c, s in zip(coeffs, shifts)))\r\n        int result = int(ONE) << 64;\r\n        int zpow = z;\r\n        result += 0xb17217f7d1cf79ab * zpow;\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xf5fdeffc162c7543 * zpow >> (66 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xe35846b82505fc59 * zpow >> (68 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0x9d955b7dd273b94e * zpow >> (70 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xaec3ff3c53398883 * zpow >> (73 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xa184897c363c3b7a * zpow >> (76 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xffe5fe2c45863435 * zpow >> (80 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xb160111d2e411fec * zpow >> (83 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xda929e9caf3e1ed2 * zpow >> (87 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xf267a8ac5c764fb7 * zpow >> (91 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xf465639a8dd92607 * zpow >> (95 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xe1deb287e14c2f15 * zpow >> (99 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xc0b0c98b3687cb14 * zpow >> (103 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0x98a4b26ac3c54b9f * zpow >> (107 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xe1b7421d82010f33 * zpow >> (112 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0x9c744d73cfc59c91 * zpow >> (116 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        result += 0xcc2225a0e12d3eab * zpow >> (121 - 64);\r\n        zpow = zpow * z / int(ONE);\r\n        zpow = 0xfb8bb5eda1b4aeb9 * zpow >> (126 - 64);\r\n        result += zpow;\r\n        zpow = int(8 * ONE);\r\n\r\n        shift -= 64;\r\n        if (shift >= 0) {\r\n            if (result >> (256-shift) == 0) {\r\n                lower = uint(result) << shift;\r\n                zpow <<= shift; // todo: is this safe?\r\n                if (lower + uint(zpow) >= lower)\r\n                    upper = lower + uint(zpow);\r\n                else\r\n                    upper = 2**256-1;\r\n                return;\r\n            }\r\n            else\r\n                return (2**256-1, 2**256-1);\r\n        }\r\n        zpow = (zpow >> (-shift)) + 1;\r\n        lower = uint(result) >> (-shift);\r\n        upper = lower + uint(zpow);\r\n        return;\r\n    }\r\n\r\n    /// @dev Returns natural logarithm value of given x\r\n    /// @param x x\r\n    /// @return ln(x)\r\n    function ln(uint x)\r\n        public\r\n        pure\r\n        returns (int)\r\n    {\r\n        (int lower, int upper) = log2Bounds(x);\r\n        return ((upper - lower) / 2 + lower) * int(ONE) / int(LOG2_E);\r\n    }\r\n\r\n    /// @dev Returns estimate of binaryLog(x) given x\r\n    /// @param x logarithm argument in fixed point\r\n    /// @param estimationMode whether to return a lower bound, upper bound, or a midpoint\r\n    /// @return estimate of binaryLog(x) in fixed point\r\n    function binaryLog(uint x, EstimationMode estimationMode)\r\n        public\r\n        pure\r\n        returns (int)\r\n    {\r\n        (int lower, int upper) = log2Bounds(x);\r\n        if(estimationMode == EstimationMode.LowerBound) {\r\n            return lower;\r\n        }\r\n        if(estimationMode == EstimationMode.UpperBound) {\r\n            return upper;\r\n        }\r\n        if(estimationMode == EstimationMode.Midpoint) {\r\n            return (upper - lower) / 2 + lower;\r\n        }\r\n        revert();\r\n    }\r\n\r\n    /// @dev Returns bounds for value of binaryLog(x) given x\r\n    /// @param x logarithm argument in fixed point\r\n    /// @return {\r\n    ///   \"lower\": \"lower bound of binaryLog(x) in fixed point\",\r\n    ///   \"upper\": \"upper bound of binaryLog(x) in fixed point\"\r\n    /// }\r\n    function log2Bounds(uint x)\r\n        public\r\n        pure\r\n        returns (int lower, int upper)\r\n    {\r\n        require(x > 0);\r\n        // compute ⌊log₂x⌋\r\n        lower = floorLog2(x);\r\n\r\n        uint y;\r\n        if (lower < 0)\r\n            y = x << uint(-lower);\r\n        else\r\n            y = x >> uint(lower);\r\n\r\n        lower *= int(ONE);\r\n\r\n        // y = x * 2^(-⌊log₂x⌋)\r\n        // so 1 <= y < 2\r\n        // and log₂x = ⌊log₂x⌋ + log₂y\r\n        for (int m = 1; m <= 64; m++) {\r\n            if(y == ONE) {\r\n                break;\r\n            }\r\n            y = y * y / ONE;\r\n            if(y >= 2 * ONE) {\r\n                lower += int(ONE >> m);\r\n                y /= 2;\r\n            }\r\n        }\r\n\r\n        return (lower, lower + 4);\r\n    }\r\n\r\n    /// @dev Returns base 2 logarithm value of given x\r\n    /// @param x x\r\n    /// @return logarithmic value\r\n    function floorLog2(uint x)\r\n        public\r\n        pure\r\n        returns (int lo)\r\n    {\r\n        lo = -64;\r\n        int hi = 193;\r\n        // I use a shift here instead of / 2 because it floors instead of rounding towards 0\r\n        int mid = (hi + lo) >> 1;\r\n        while((lo + 1) < hi) {\r\n            if (mid < 0 && x << uint(-mid) < ONE || mid >= 0 && x >> uint(mid) < ONE)\r\n                hi = mid;\r\n            else\r\n                lo = mid;\r\n            mid = (hi + lo) >> 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns maximum of an array\r\n    /// @param nums Numbers to look through\r\n    /// @return Maximum number\r\n    function max(int[] nums)\r\n        public\r\n        pure\r\n        returns (int maxNum)\r\n    {\r\n        require(nums.length > 0);\r\n        maxNum = -2**255;\r\n        for (uint i = 0; i < nums.length; i++)\r\n            if (nums[i] > maxNum)\r\n                maxNum = nums[i];\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  int256 constant INT256_MIN = int256((uint256(1) << 255));\r\n\r\n  /**\r\n  * @dev Multiplies two unsigned integers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Multiplies two signed integers, throws on overflow.\r\n  */\r\n  function mul(int256 a, int256 b) internal pure returns (int256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert((a != -1 || b != INT256_MIN) && c / a == b);\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two unsigned integers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two signed integers, truncating the quotient.\r\n  */\r\n  function div(int256 a, int256 b) internal pure returns (int256) {\r\n    // assert(b != 0); // Solidity automatically throws when dividing by 0\r\n    // Overflow only happens when the smallest negative int is multiplied by -1.\r\n    assert(a != INT256_MIN || b != -1);\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two unsigned integers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two signed integers, throws on overflow.\r\n  */\r\n  function sub(int256 a, int256 b) internal pure returns (int256 c) {\r\n    c = a - b;\r\n    assert((b >= 0 && c <= a) || (b < 0 && c > a));\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two unsigned integers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two signed integers, throws on overflow.\r\n  */\r\n  function add(int256 a, int256 b) internal pure returns (int256 c) {\r\n    c = a + b;\r\n    assert((b >= 0 && c >= a) || (b < 0 && c < a));\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract OutcomeTokenProxy is Proxy {\r\n    /*\r\n     *  Storage\r\n     */\r\n\r\n    // HACK: Lining up storage with StandardToken and OutcomeToken\r\n    mapping(address => uint256) balances;\r\n    uint256 totalSupply_;\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    address internal eventContract;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Constructor sets events contract address\r\n    constructor(address proxied)\r\n        public\r\n        Proxy(proxied)\r\n    {\r\n        eventContract = msg.sender;\r\n    }\r\n}\r\n\r\n/// @title Outcome token contract - Issuing and revoking outcome tokens\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract OutcomeToken is Proxied, StandardToken {\r\n    using SafeMath for *;\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event Issuance(address indexed owner, uint amount);\r\n    event Revocation(address indexed owner, uint amount);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public eventContract;\r\n\r\n    /*\r\n     *  Modifiers\r\n     */\r\n    modifier isEventContract () {\r\n        // Only event contract is allowed to proceed\r\n        require(msg.sender == eventContract);\r\n        _;\r\n    }\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Events contract issues new tokens for address. Returns success\r\n    /// @param _for Address of receiver\r\n    /// @param outcomeTokenCount Number of tokens to issue\r\n    function issue(address _for, uint outcomeTokenCount)\r\n        public\r\n        isEventContract\r\n    {\r\n        balances[_for] = balances[_for].add(outcomeTokenCount);\r\n        totalSupply_ = totalSupply_.add(outcomeTokenCount);\r\n        emit Issuance(_for, outcomeTokenCount);\r\n    }\r\n\r\n    /// @dev Events contract revokes tokens for address. Returns success\r\n    /// @param _for Address of token holder\r\n    /// @param outcomeTokenCount Number of tokens to revoke\r\n    function revoke(address _for, uint outcomeTokenCount)\r\n        public\r\n        isEventContract\r\n    {\r\n        balances[_for] = balances[_for].sub(outcomeTokenCount);\r\n        totalSupply_ = totalSupply_.sub(outcomeTokenCount);\r\n        emit Revocation(_for, outcomeTokenCount);\r\n    }\r\n}\r\n\r\n/// @title Abstract oracle contract - Functions to be implemented by oracles\r\ncontract Oracle {\r\n\r\n    function isOutcomeSet() public view returns (bool);\r\n    function getOutcome() public view returns (int);\r\n}\r\n\r\n\r\ncontract EventData {\r\n\r\n    /*\r\n     *  Events\r\n     */\r\n    event OutcomeTokenCreation(OutcomeToken outcomeToken, uint8 index);\r\n    event OutcomeTokenSetIssuance(address indexed buyer, uint collateralTokenCount);\r\n    event OutcomeTokenSetRevocation(address indexed seller, uint outcomeTokenCount);\r\n    event OutcomeAssignment(int outcome);\r\n    event WinningsRedemption(address indexed receiver, uint winnings);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    ERC20 public collateralToken;\r\n    Oracle public oracle;\r\n    bool public isOutcomeSet;\r\n    int public outcome;\r\n    OutcomeToken[] public outcomeTokens;\r\n}\r\n\r\n/// @title Event contract - Provide basic functionality required by different event types\r\n/// @author Stefan George - <stefan@gnosis.pm>\r\ncontract Event is EventData {\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Buys equal number of tokens of all outcomes, exchanging collateral tokens and sets of outcome tokens 1:1\r\n    /// @param collateralTokenCount Number of collateral tokens\r\n    function buyAllOutcomes(uint collateralTokenCount)\r\n        public\r\n    {\r\n        // Transfer collateral tokens to events contract\r\n        require(collateralToken.transferFrom(msg.sender, this, collateralTokenCount));\r\n        // Issue new outcome tokens to sender\r\n        for (uint8 i = 0; i < outcomeTokens.length; i++)\r\n            outcomeTokens[i].issue(msg.sender, collateralTokenCount);\r\n        emit OutcomeTokenSetIssuance(msg.sender, collateralTokenCount);\r\n    }\r\n\r\n    /// @dev Sells equal number of tokens of all outcomes, exchanging collateral tokens and sets of outcome tokens 1:1\r\n    /// @param outcomeTokenCount Number of outcome tokens\r\n    function sellAllOutcomes(uint outcomeTokenCount)\r\n        public\r\n    {\r\n        // Revoke sender's outcome tokens of all outcomes\r\n        for (uint8 i = 0; i < outcomeTokens.length; i++)\r\n            outcomeTokens[i].revoke(msg.sender, outcomeTokenCount);\r\n        // Transfer collateral tokens to sender\r\n        require(collateralToken.transfer(msg.sender, outcomeTokenCount));\r\n        emit OutcomeTokenSetRevocation(msg.sender, outcomeTokenCount);\r\n    }\r\n\r\n    /// @dev Sets winning event outcome\r\n    function setOutcome()\r\n        public\r\n    {\r\n        // Winning outcome is not set yet in event contract but in oracle contract\r\n        require(!isOutcomeSet && oracle.isOutcomeSet());\r\n        // Set winning outcome\r\n        outcome = oracle.getOutcome();\r\n        isOutcomeSet = true;\r\n        emit OutcomeAssignment(outcome);\r\n    }\r\n\r\n    /// @dev Returns outcome count\r\n    /// @return Outcome count\r\n    function getOutcomeCount()\r\n        public\r\n        view\r\n        returns (uint8)\r\n    {\r\n        return uint8(outcomeTokens.length);\r\n    }\r\n\r\n    /// @dev Returns outcome tokens array\r\n    /// @return Outcome tokens\r\n    function getOutcomeTokens()\r\n        public\r\n        view\r\n        returns (OutcomeToken[])\r\n    {\r\n        return outcomeTokens;\r\n    }\r\n\r\n    /// @dev Returns the amount of outcome tokens held by owner\r\n    /// @return Outcome token distribution\r\n    function getOutcomeTokenDistribution(address owner)\r\n        public\r\n        view\r\n        returns (uint[] outcomeTokenDistribution)\r\n    {\r\n        outcomeTokenDistribution = new uint[](outcomeTokens.length);\r\n        for (uint8 i = 0; i < outcomeTokenDistribution.length; i++)\r\n            outcomeTokenDistribution[i] = outcomeTokens[i].balanceOf(owner);\r\n    }\r\n\r\n    /// @dev Calculates and returns event hash\r\n    /// @return Event hash\r\n    function getEventHash() public view returns (bytes32);\r\n\r\n    /// @dev Exchanges sender's winning outcome tokens for collateral tokens\r\n    /// @return Sender's winnings\r\n    function redeemWinnings() public returns (uint);\r\n}\r\n\r\n\r\ncontract MarketData {\r\n    /*\r\n     *  Events\r\n     */\r\n    event MarketFunding(uint funding);\r\n    event MarketClosing();\r\n    event FeeWithdrawal(uint fees);\r\n    event OutcomeTokenPurchase(address indexed buyer, uint8 outcomeTokenIndex, uint outcomeTokenCount, uint outcomeTokenCost, uint marketFees);\r\n    event OutcomeTokenSale(address indexed seller, uint8 outcomeTokenIndex, uint outcomeTokenCount, uint outcomeTokenProfit, uint marketFees);\r\n    event OutcomeTokenShortSale(address indexed buyer, uint8 outcomeTokenIndex, uint outcomeTokenCount, uint cost);\r\n    event OutcomeTokenTrade(address indexed transactor, int[] outcomeTokenAmounts, int outcomeTokenNetCost, uint marketFees);\r\n\r\n    /*\r\n     *  Storage\r\n     */\r\n    address public creator;\r\n    uint public createdAtBlock;\r\n    Event public eventContract;\r\n    MarketMaker public marketMaker;\r\n    uint24 public fee;\r\n    uint public funding;\r\n    int[] public netOutcomeTokensSold;\r\n    Stages public stage;\r\n\r\n    enum Stages {\r\n        MarketCreated,\r\n        MarketFunded,\r\n        MarketClosed\r\n    }\r\n}\r\n\r\n/// @title Abstract market contract - Functions to be implemented by market contracts\r\ncontract Market is MarketData {\r\n    /*\r\n     *  Public functions\r\n     */\r\n    function fund(uint _funding) public;\r\n    function close() public;\r\n    function withdrawFees() public returns (uint);\r\n    function buy(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint maxCost) public returns (uint);\r\n    function sell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfit) public returns (uint);\r\n    function shortSell(uint8 outcomeTokenIndex, uint outcomeTokenCount, uint minProfit) public returns (uint);\r\n    function trade(int[] outcomeTokenAmounts, int costLimit) public returns (int);\r\n    function calcMarketFee(uint outcomeTokenCost) public view returns (uint);\r\n}\r\n\r\n\r\n/// @title Abstract market maker contract - Functions to be implemented by market maker contracts\r\ncontract MarketMaker {\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    function calcCost(Market market, uint8 outcomeTokenIndex, uint outcomeTokenCount) public view returns (uint);\r\n    function calcProfit(Market market, uint8 outcomeTokenIndex, uint outcomeTokenCount) public view returns (uint);\r\n    function calcNetCost(Market market, int[] outcomeTokenAmounts) public view returns (int);\r\n    function calcMarginalPrice(Market market, uint8 outcomeTokenIndex) public view returns (uint);\r\n}\r\n\r\n\r\n/// @title LMSR market maker contract - Calculates share prices based on share distribution and initial funding\r\n/// @author Alan Lu - <alan.lu@gnosis.pm>\r\ncontract LMSRMarketMaker is MarketMaker {\r\n    using SafeMath for *;\r\n\r\n    /*\r\n     *  Constants\r\n     */\r\n    uint constant ONE = 0x10000000000000000;\r\n    int constant EXP_LIMIT = 3394200909562557497344;\r\n\r\n    /*\r\n     *  Public functions\r\n     */\r\n    /// @dev Calculates the net cost for executing a given trade.\r\n    /// @param market Market contract\r\n    /// @param outcomeTokenAmounts Amounts of outcome tokens to buy from the market. If an amount is negative, represents an amount to sell to the market.\r\n    /// @return Net cost of trade. If positive, represents amount of collateral which would be paid to the market for the trade. If negative, represents amount of collateral which would be received from the market for the trade.\r\n    function calcNetCost(Market market, int[] outcomeTokenAmounts)\r\n        public\r\n        view\r\n        returns (int netCost)\r\n    {\r\n        require(market.eventContract().getOutcomeCount() > 1);\r\n        int[] memory netOutcomeTokensSold = getNetOutcomeTokensSold(market);\r\n\r\n        // Calculate cost level based on net outcome token balances\r\n        int log2N = Fixed192x64Math.binaryLog(netOutcomeTokensSold.length * ONE, Fixed192x64Math.EstimationMode.UpperBound);\r\n        uint funding = market.funding();\r\n        int costLevelBefore = calcCostLevel(log2N, netOutcomeTokensSold, funding, Fixed192x64Math.EstimationMode.LowerBound);\r\n\r\n        // Change amounts based on outcomeTokenAmounts passed in\r\n        require(netOutcomeTokensSold.length == outcomeTokenAmounts.length);\r\n        for (uint8 i = 0; i < netOutcomeTokensSold.length; i++) {\r\n            netOutcomeTokensSold[i] = netOutcomeTokensSold[i].add(outcomeTokenAmounts[i]);\r\n        }\r\n\r\n        // Calculate cost level after balance was updated\r\n        int costLevelAfter = calcCostLevel(log2N, netOutcomeTokensSold, funding, Fixed192x64Math.EstimationMode.UpperBound);\r\n\r\n        // Calculate net cost as cost level difference and use the ceil\r\n        netCost = costLevelAfter.sub(costLevelBefore);\r\n        // Integer division for negative numbers already uses ceiling,\r\n        // so only check boundary condition for positive numbers\r\n        if(netCost <= 0 || netCost / int(ONE) * int(ONE) == netCost) {\r\n            netCost /= int(ONE);\r\n        } else {\r\n            netCost = netCost / int(ONE) + 1;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns cost to buy given number of outcome tokens\r\n    /// @param market Market contract\r\n    /// @param outcomeTokenIndex Index of outcome to buy\r\n    /// @param outcomeTokenCount Number of outcome tokens to buy\r\n    /// @return Cost\r\n    function calcCost(Market market, uint8 outcomeTokenIndex, uint outcomeTokenCount)\r\n        public\r\n        view\r\n        returns (uint cost)\r\n    {\r\n        require(market.eventContract().getOutcomeCount() > 1);\r\n        int[] memory netOutcomeTokensSold = getNetOutcomeTokensSold(market);\r\n        // Calculate cost level based on net outcome token balances\r\n        int log2N = Fixed192x64Math.binaryLog(netOutcomeTokensSold.length * ONE, Fixed192x64Math.EstimationMode.UpperBound);\r\n        uint funding = market.funding();\r\n        int costLevelBefore = calcCostLevel(log2N, netOutcomeTokensSold, funding, Fixed192x64Math.EstimationMode.LowerBound);\r\n        // Add outcome token count to net outcome token balance\r\n        require(int(outcomeTokenCount) >= 0);\r\n        netOutcomeTokensSold[outcomeTokenIndex] = netOutcomeTokensSold[outcomeTokenIndex].add(int(outcomeTokenCount));\r\n        // Calculate cost level after balance was updated\r\n        int costLevelAfter = calcCostLevel(log2N, netOutcomeTokensSold, funding, Fixed192x64Math.EstimationMode.UpperBound);\r\n        // Calculate cost as cost level difference\r\n        if(costLevelAfter < costLevelBefore)\r\n            costLevelAfter = costLevelBefore;\r\n        cost = uint(costLevelAfter - costLevelBefore);\r\n        // Take the ceiling to account for rounding\r\n        if (cost / ONE * ONE == cost)\r\n            cost /= ONE;\r\n        else\r\n            // Integer division by ONE ensures there is room to (+ 1)\r\n            cost = cost / ONE + 1;\r\n        // Make sure cost is not bigger than 1 per share\r\n        if (cost > outcomeTokenCount)\r\n            cost = outcomeTokenCount;\r\n    }\r\n\r\n    /// @dev Returns profit for selling given number of outcome tokens\r\n    /// @param market Market contract\r\n    /// @param outcomeTokenIndex Index of outcome to sell\r\n    /// @param outcomeTokenCount Number of outcome tokens to sell\r\n    /// @return Profit\r\n    function calcProfit(Market market, uint8 outcomeTokenIndex, uint outcomeTokenCount)\r\n        public\r\n        view\r\n        returns (uint profit)\r\n    {\r\n        require(market.eventContract().getOutcomeCount() > 1);\r\n        int[] memory netOutcomeTokensSold = getNetOutcomeTokensSold(market);\r\n        // Calculate cost level based on net outcome token balances\r\n        int log2N = Fixed192x64Math.binaryLog(netOutcomeTokensSold.length * ONE, Fixed192x64Math.EstimationMode.UpperBound);\r\n        uint funding = market.funding();\r\n        int costLevelBefore = calcCostLevel(log2N, netOutcomeTokensSold, funding, Fixed192x64Math.EstimationMode.LowerBound);\r\n        // Subtract outcome token count from the net outcome token balance\r\n        require(int(outcomeTokenCount) >= 0);\r\n        netOutcomeTokensSold[outcomeTokenIndex] = netOutcomeTokensSold[outcomeTokenIndex].sub(int(outcomeTokenCount));\r\n        // Calculate cost level after balance was updated\r\n        int costLevelAfter = calcCostLevel(log2N, netOutcomeTokensSold, funding, Fixed192x64Math.EstimationMode.UpperBound);\r\n        // Calculate profit as cost level difference\r\n        if(costLevelBefore <= costLevelAfter)\r\n            costLevelBefore = costLevelAfter;\r\n        // Take the floor\r\n        profit = uint(costLevelBefore - costLevelAfter) / ONE;\r\n    }\r\n\r\n    /// @dev Returns marginal price of an outcome\r\n    /// @param market Market contract\r\n    /// @param outcomeTokenIndex Index of outcome to determine marginal price of\r\n    /// @return Marginal price of an outcome as a fixed point number\r\n    function calcMarginalPrice(Market market, uint8 outcomeTokenIndex)\r\n        public\r\n        view\r\n        returns (uint price)\r\n    {\r\n        require(market.eventContract().getOutcomeCount() > 1);\r\n        int[] memory netOutcomeTokensSold = getNetOutcomeTokensSold(market);\r\n        int logN = Fixed192x64Math.binaryLog(netOutcomeTokensSold.length * ONE, Fixed192x64Math.EstimationMode.Midpoint);\r\n        uint funding = market.funding();\r\n        // The price function is exp(quantities[i]/b) / sum(exp(q/b) for q in quantities)\r\n        // To avoid overflow, calculate with\r\n        // exp(quantities[i]/b - offset) / sum(exp(q/b - offset) for q in quantities)\r\n        (uint sum, , uint outcomeExpTerm) = sumExpOffset(logN, netOutcomeTokensSold, funding, outcomeTokenIndex, Fixed192x64Math.EstimationMode.Midpoint);\r\n        return outcomeExpTerm / (sum / ONE);\r\n    }\r\n\r\n    /*\r\n     *  Private functions\r\n     */\r\n    /// @dev Calculates the result of the LMSR cost function which is used to\r\n    ///      derive prices from the market state\r\n    /// @param logN Logarithm of the number of outcomes\r\n    /// @param netOutcomeTokensSold Net outcome tokens sold by market\r\n    /// @param funding Initial funding for market\r\n    /// @return Cost level\r\n    function calcCostLevel(int logN, int[] netOutcomeTokensSold, uint funding, Fixed192x64Math.EstimationMode estimationMode)\r\n        private\r\n        pure\r\n        returns(int costLevel)\r\n    {\r\n        // The cost function is C = b * log(sum(exp(q/b) for q in quantities)).\r\n        // To avoid overflow, we need to calc with an exponent offset:\r\n        // C = b * (offset + log(sum(exp(q/b - offset) for q in quantities)))\r\n        (uint sum, int offset, ) = sumExpOffset(logN, netOutcomeTokensSold, funding, 0, estimationMode);\r\n        costLevel = Fixed192x64Math.binaryLog(sum, estimationMode);\r\n        costLevel = costLevel.add(offset);\r\n        costLevel = (costLevel.mul(int(ONE)) / logN).mul(int(funding));\r\n    }\r\n\r\n    /// @dev Calculates sum(exp(q/b - offset) for q in quantities), where offset is set\r\n    ///      so that the sum fits in 248-256 bits\r\n    /// @param logN Logarithm of the number of outcomes\r\n    /// @param netOutcomeTokensSold Net outcome tokens sold by market\r\n    /// @param funding Initial funding for market\r\n    /// @param outcomeIndex Index of exponential term to extract (for use by marginal price function)\r\n    /// @return A result structure composed of the sum, the offset used, and the summand associated with the supplied index\r\n    function sumExpOffset(int logN, int[] netOutcomeTokensSold, uint funding, uint8 outcomeIndex, Fixed192x64Math.EstimationMode estimationMode)\r\n        private\r\n        pure\r\n        returns (uint sum, int offset, uint outcomeExpTerm)\r\n    {\r\n        // Naive calculation of this causes an overflow\r\n        // since anything above a bit over 133*ONE supplied to exp will explode\r\n        // as exp(133) just about fits into 192 bits of whole number data.\r\n\r\n        // The choice of this offset is subject to another limit:\r\n        // computing the inner sum successfully.\r\n        // Since the index is 8 bits, there has to be 8 bits of headroom for\r\n        // each summand, meaning q/b - offset <= exponential_limit,\r\n        // where that limit can be found with `mp.floor(mp.log((2**248 - 1) / ONE) * ONE)`\r\n        // That is what EXP_LIMIT is set to: it is about 127.5\r\n\r\n        // finally, if the distribution looks like [BIG, tiny, tiny...], using a\r\n        // BIG offset will cause the tiny quantities to go really negative\r\n        // causing the associated exponentials to vanish.\r\n\r\n        require(logN >= 0 && int(funding) >= 0);\r\n        offset = Fixed192x64Math.max(netOutcomeTokensSold);\r\n        offset = offset.mul(logN) / int(funding);\r\n        offset = offset.sub(EXP_LIMIT);\r\n        uint term;\r\n        for (uint8 i = 0; i < netOutcomeTokensSold.length; i++) {\r\n            term = Fixed192x64Math.pow2((netOutcomeTokensSold[i].mul(logN) / int(funding)).sub(offset), estimationMode);\r\n            if (i == outcomeIndex)\r\n                outcomeExpTerm = term;\r\n            sum = sum.add(term);\r\n        }\r\n    }\r\n\r\n    /// @dev Gets net outcome tokens sold by market. Since all sets of outcome tokens are backed by\r\n    ///      corresponding collateral tokens, the net quantity of a token sold by the market is the\r\n    ///      number of collateral tokens (which is the same as the number of outcome tokens the\r\n    ///      market created) subtracted by the quantity of that token held by the market.\r\n    /// @param market Market contract\r\n    /// @return Net outcome tokens sold by market\r\n    function getNetOutcomeTokensSold(Market market)\r\n        private\r\n        view\r\n        returns (int[] quantities)\r\n    {\r\n        quantities = new int[](market.eventContract().getOutcomeCount());\r\n        for (uint8 i = 0; i < quantities.length; i++)\r\n            quantities[i] = market.netOutcomeTokensSold(i);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"outcomeTokenAmounts\",\"type\":\"int256[]\"}],\"name\":\"calcNetCost\",\"outputs\":[{\"name\":\"netCost\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"outcomeTokenIndex\",\"type\":\"uint8\"},{\"name\":\"outcomeTokenCount\",\"type\":\"uint256\"}],\"name\":\"calcProfit\",\"outputs\":[{\"name\":\"profit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"outcomeTokenIndex\",\"type\":\"uint8\"},{\"name\":\"outcomeTokenCount\",\"type\":\"uint256\"}],\"name\":\"calcCost\",\"outputs\":[{\"name\":\"cost\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"outcomeTokenIndex\",\"type\":\"uint8\"}],\"name\":\"calcMarginalPrice\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"LMSRMarketMaker","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"Fixed192x64Math:11c59b10ebe450cf403e1a07255da5cd2aef2084","SwarmSource":"bzzr://5521dc6adb51ca623f401a25028efadbbda5cb3f9760a4a6ec21d75ed9b5b53b"}]}