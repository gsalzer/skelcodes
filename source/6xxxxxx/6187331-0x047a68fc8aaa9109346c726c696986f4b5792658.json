{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\ncontract BitrngDice {\r\n  // Ownership.\r\n  address public owner;\r\n  address private nextOwner;\r\n\r\n  // The address corresponding to a private key used to sign placeBet commits.\r\n  address public secretSigner;\r\n\r\n  // Minimum and maximum bets.\r\n  uint constant MIN_AMOUNT = 0.01 ether;\r\n  uint constant MAX_AMOUNT_BIG_SMALL = 1 ether;\r\n  uint constant MAX_AMOUNT_SAME = 0.05 ether;\r\n  uint constant MAX_AMOUNT_NUMBER = 0.1 ether;\r\n\r\n  // EVM `BLOCKHASH` opcode can query no further than 256 blocks into the\r\n  // past. Given that settleBet uses block hash of placeBet as one of\r\n  // complementary entropy sources, we cannot process bets older than this\r\n  // threshold. On rare occasions dice2.win croupier may fail to invoke\r\n  // settleBet in this timespan due to technical issues or extreme Ethereum\r\n  // congestion; such bets can be refunded via invoking refundBet.\r\n  uint constant BET_EXPIRATION_BLOCKS = 250;\r\n\r\n  // Max bets in one game.\r\n  uint8 constant MAX_BET = 5;\r\n\r\n  // Max bet types.\r\n  uint8 constant BET_MASK_COUNT = 22;\r\n\r\n  // Bet flags.\r\n  uint24 constant BET_BIG = uint24(1 << 21);\r\n  uint24 constant BET_SMALL = uint24(1 << 20);\r\n  uint24 constant BET_SAME_1 = uint24(1 << 19);\r\n  uint24 constant BET_SAME_2 = uint24(1 << 18);\r\n  uint24 constant BET_SAME_3 = uint24(1 << 17);\r\n  uint24 constant BET_SAME_4 = uint24(1 << 16);\r\n  uint24 constant BET_SAME_5 = uint24(1 << 15);\r\n  uint24 constant BET_SAME_6 = uint24(1 << 14);\r\n  uint24 constant BET_4 = uint24(1 << 13);\r\n  uint24 constant BET_5 = uint24(1 << 12);\r\n  uint24 constant BET_6 = uint24(1 << 11);\r\n  uint24 constant BET_7 = uint24(1 << 10);\r\n  uint24 constant BET_8 = uint24(1 << 9);\r\n  uint24 constant BET_9 = uint24(1 << 8);\r\n  uint24 constant BET_10 = uint24(1 << 7);\r\n  uint24 constant BET_11 = uint24(1 << 6);\r\n  uint24 constant BET_12 = uint24(1 << 5);\r\n  uint24 constant BET_13 = uint24(1 << 4);\r\n  uint24 constant BET_14 = uint24(1 << 3);\r\n  uint24 constant BET_15 = uint24(1 << 2);\r\n  uint24 constant BET_16 = uint24(1 << 1);\r\n  uint24 constant BET_17 = uint24(1);\r\n\r\n  // Funds that are locked in potentially winning bets. Prevents contract from\r\n  // committing to bets it cannot pay out.\r\n  uint public lockedInBets;\r\n\r\n  // Set false to disable betting.\r\n  bool public enabled = true;\r\n\r\n  // Some deliberately invalid address to initialize the secret signer with.\r\n  // Forces maintainers to invoke setSecretSigner before processing any bets.\r\n  address constant DUMMY_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n  // The game struct, only supports 5 bet.\r\n  struct Game{\r\n    address gambler;\r\n    uint40 placeBlockNumber; // block number contains place bet txn\r\n    uint bet1Amount;\r\n    uint bet2Amount;\r\n    uint bet3Amount;\r\n    uint bet4Amount;\r\n    uint bet5Amount;\r\n    uint24 mask; // bet flags ored together\r\n  }\r\n\r\n  // Mapping from commits to all currently active & processed bets.\r\n  mapping (uint => Game) games;\r\n\r\n  // Mapping for bet type to odds\r\n  mapping (uint24 => uint8) odds;\r\n\r\n  // Mapping for bet number results;\r\n  mapping (uint24 => uint8) betNumberResults;\r\n\r\n  // Mapdding for bet same number results\r\n  mapping (uint24 => uint8) betSameResults;\r\n\r\n  // Events that are issued to make statistic recovery easier.\r\n  event FailedPayment(address indexed beneficiary, uint amount);\r\n  event Payment(address indexed beneficiary, uint amount);\r\n\r\n  constructor () public {\r\n    owner = msg.sender;\r\n    secretSigner = DUMMY_ADDRESS;\r\n\r\n    // init odds\r\n    odds[BET_SMALL] = 2;\r\n    odds[BET_BIG] = 2;\r\n\r\n    odds[BET_SAME_1] = 150;\r\n    odds[BET_SAME_2] = 150;\r\n    odds[BET_SAME_3] = 150;\r\n    odds[BET_SAME_4] = 150;\r\n    odds[BET_SAME_5] = 150;\r\n    odds[BET_SAME_6] = 150;\r\n\r\n    odds[BET_9] = 6;\r\n    odds[BET_10] = 6;\r\n    odds[BET_11] = 6;\r\n    odds[BET_12] = 6;\r\n\r\n    odds[BET_8] = 8;\r\n    odds[BET_13] = 8;\r\n\r\n    odds[BET_7] = 12;\r\n    odds[BET_14] = 12;\r\n\r\n    odds[BET_6] = 14;\r\n    odds[BET_15] = 14;\r\n\r\n    odds[BET_5] = 18;\r\n    odds[BET_16] = 18;\r\n\r\n    odds[BET_4] = 50;\r\n    odds[BET_17] = 50;\r\n\r\n    // init results\r\n    betNumberResults[BET_9] = 9;\r\n    betNumberResults[BET_10] = 10;\r\n    betNumberResults[BET_11] = 11;\r\n    betNumberResults[BET_12] = 12;\r\n\r\n    betNumberResults[BET_8] = 8;\r\n    betNumberResults[BET_13] = 13;\r\n\r\n    betNumberResults[BET_7] = 7;\r\n    betNumberResults[BET_14] = 14;\r\n\r\n    betNumberResults[BET_6] = 6;\r\n    betNumberResults[BET_15] = 15;\r\n\r\n    betNumberResults[BET_5] = 5;\r\n    betNumberResults[BET_16] = 16;\r\n\r\n    betNumberResults[BET_4] = 4;\r\n    betNumberResults[BET_17] = 17;\r\n\r\n    betSameResults[BET_SAME_1] = 1;\r\n    betSameResults[BET_SAME_2] = 2;\r\n    betSameResults[BET_SAME_3] = 3;\r\n    betSameResults[BET_SAME_4] = 4;\r\n    betSameResults[BET_SAME_5] = 5;\r\n    betSameResults[BET_SAME_6] = 6;\r\n\r\n  }\r\n\r\n  // Place game\r\n  //\r\n  // Betmask - flags for each bet, total 22 bits.\r\n  // betAmount - 5 bet amounts in Wei\r\n  // commitLastBlock -  block number when `commit` expires\r\n  // commit -  sha3 of `reveal`\r\n  // r, s - components of ECDSA signature of (commitLastBlock, commit).\r\n  //        Used to check commit is generated by `secretSigner`\r\n  //\r\n  // Game states:\r\n  //  amount == 0 && gambler == 0 - 'clean' (can place a bet)\r\n  //  amount != 0 && gambler != 0 - 'active' (can be settled or refunded)\r\n  //  amount == 0 && gambler != 0 - 'processed' (can clean storage)\r\n  function placeGame(\r\n    uint24 betMask,\r\n    uint bet1Amount,\r\n    uint bet2Amount,\r\n    uint bet3Amount,\r\n    uint bet4Amount,\r\n    uint bet5Amount,\r\n    uint commitLastBlock,\r\n    uint commit,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) external payable\r\n  {\r\n    // Is game enabled ?\r\n    require (enabled, \"Game is closed\");\r\n    // Check payed amount and sum of place amount are equal.\r\n    require (bet1Amount + bet2Amount + bet3Amount + bet4Amount + bet5Amount == msg.value,\r\n      \"Place amount and payment should be equal.\");\r\n\r\n    // Check that the game is in 'clean' state.\r\n    Game storage game = games[commit];\r\n    require (game.gambler == address(0),\r\n      \"Game should be in a 'clean' state.\");\r\n\r\n    // Check that commit is valid. It has not expired and its signature is valid.\r\n    // r = signature[0:64]\r\n    // s = signature[64:128]\r\n    // v = signature[128:130], always 27\r\n    require (block.number <= commitLastBlock, \"Commit has expired.\");\r\n    bytes32 signatureHash = keccak256(abi.encodePacked(uint40(commitLastBlock), commit));\r\n    require (secretSigner == ecrecover(signatureHash, 27, r, s), \"ECDSA signature is not valid.\");\r\n\r\n    // Try to lock amount.\r\n    _lockOrUnlockAmount(\r\n      betMask,\r\n      bet1Amount,\r\n      bet2Amount,\r\n      bet3Amount,\r\n      bet4Amount,\r\n      bet5Amount,\r\n      1\r\n    );\r\n\r\n    // Store game parameters on blockchain.\r\n    game.placeBlockNumber = uint40(block.number);\r\n    game.mask = uint24(betMask);\r\n    game.gambler = msg.sender;\r\n    game.bet1Amount = bet1Amount;\r\n    game.bet2Amount = bet2Amount;\r\n    game.bet3Amount = bet3Amount;\r\n    game.bet4Amount = bet4Amount;\r\n    game.bet5Amount = bet5Amount;\r\n  }\r\n\r\n  function settleGame(uint reveal, uint cleanCommit) external {\r\n    // `commit` for bet settlement can only be obtained by hashing a `reveal`.\r\n    uint commit = uint(keccak256(abi.encodePacked(reveal)));\r\n    // Fetch bet parameters into local variables (to save gas).\r\n    Game storage game = games[commit];\r\n    uint bet1Amount = game.bet1Amount;\r\n    uint bet2Amount = game.bet2Amount;\r\n    uint bet3Amount = game.bet3Amount;\r\n    uint bet4Amount = game.bet4Amount;\r\n    uint bet5Amount = game.bet5Amount;\r\n    uint placeBlockNumber = game.placeBlockNumber;\r\n    address gambler = game.gambler;\r\n    uint24 betMask = game.mask;\r\n\r\n    // Check that bet is in 'active' state.\r\n    require (\r\n      bet1Amount != 0 ||\r\n      bet2Amount != 0 ||\r\n      bet3Amount != 0 ||\r\n      bet4Amount != 0 ||\r\n      bet5Amount != 0,\r\n      \"Bet should be in an 'active' state\");\r\n\r\n    // Check that bet has not expired yet (see comment to BET_EXPIRATION_BLOCKS).\r\n    require (block.number > placeBlockNumber, \"settleBet in the same block as placeBet, or before.\");\r\n    require (block.number <= placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n    // Move bet into 'processed' state already.\r\n    game.bet1Amount = 0;\r\n    game.bet2Amount = 0;\r\n    game.bet3Amount = 0;\r\n    game.bet4Amount = 0;\r\n    game.bet5Amount = 0;\r\n\r\n    // The RNG - combine \"reveal\" and blockhash of placeBet using Keccak256. Miners\r\n    // are not aware of \"reveal\" and cannot deduce it from \"commit\" (as Keccak256\r\n    // preimage is intractable), and house is unable to alter the \"reveal\" after\r\n    // placeBet have been mined (as Keccak256 collision finding is also intractable).\r\n    uint entropy = uint(\r\n      keccak256(abi.encodePacked(reveal, blockhash(placeBlockNumber)))\r\n    );\r\n\r\n    uint winAmount = _getWinAmount(\r\n      uint8((entropy % 6) + 1),\r\n      uint8(((entropy >> 10) % 6) + 1),\r\n      uint8(((entropy >> 20) % 6) + 1),\r\n      betMask,\r\n      bet1Amount,\r\n      bet2Amount,\r\n      bet3Amount,\r\n      bet4Amount,\r\n      bet5Amount\r\n    );\r\n\r\n    // Unlock the bet amount, regardless of the outcome.\r\n    _lockOrUnlockAmount(\r\n      betMask,\r\n      bet1Amount,\r\n      bet2Amount,\r\n      bet3Amount,\r\n      bet4Amount,\r\n      bet5Amount,\r\n      0\r\n    );\r\n\r\n    // Send the funds to gambler.\r\n    if(winAmount > 0){\r\n      sendFunds(gambler, winAmount);\r\n    }else{\r\n      sendFunds(gambler, 1 wei);\r\n    }\r\n\r\n    // Clear storage of some previous bet.\r\n    if (cleanCommit == 0) {\r\n        return;\r\n    }\r\n    clearProcessedBet(cleanCommit);\r\n  }\r\n\r\n  // Refund transaction - return the bet amount of a roll that was not processed in a\r\n  // due timeframe. Processing such blocks is not possible due to EVM limitations (see\r\n  // BET_EXPIRATION_BLOCKS comment above for details). In case you ever find yourself\r\n  // in a situation like this, just contact the dice2.win support, however nothing\r\n  // precludes you from invoking this method yourself.\r\n  function refundBet(uint commit) external {\r\n    // Check that bet is in 'active' state.\r\n    Game storage game = games[commit];\r\n    uint bet1Amount = game.bet1Amount;\r\n    uint bet2Amount = game.bet2Amount;\r\n    uint bet3Amount = game.bet3Amount;\r\n    uint bet4Amount = game.bet4Amount;\r\n    uint bet5Amount = game.bet5Amount;\r\n\r\n    // Check that bet is in 'active' state.\r\n    require (\r\n      bet1Amount != 0 ||\r\n      bet2Amount != 0 ||\r\n      bet3Amount != 0 ||\r\n      bet4Amount != 0 ||\r\n      bet5Amount != 0,\r\n      \"Bet should be in an 'active' state\");\r\n\r\n    // Check that bet has already expired.\r\n    require (block.number > game.placeBlockNumber + BET_EXPIRATION_BLOCKS, \"Blockhash can't be queried by EVM.\");\r\n\r\n    // Move bet into 'processed' state already.\r\n    game.bet1Amount = 0;\r\n    game.bet2Amount = 0;\r\n    game.bet3Amount = 0;\r\n    game.bet4Amount = 0;\r\n    game.bet5Amount = 0;\r\n\r\n    // Unlock the bet amount.\r\n    _lockOrUnlockAmount(\r\n      game.mask,\r\n      bet1Amount,\r\n      bet2Amount,\r\n      bet3Amount,\r\n      bet4Amount,\r\n      bet5Amount,\r\n      0\r\n    );\r\n\r\n    // Send the refund.\r\n    sendFunds(game.gambler, bet1Amount + bet2Amount + bet3Amount + bet4Amount + bet5Amount);\r\n  }\r\n\r\n  // Helper routine to move 'processed' bets into 'clean' state.\r\n  function clearProcessedBet(uint commit) private {\r\n      Game storage game = games[commit];\r\n\r\n      // Do not overwrite active bets with zeros; additionally prevent cleanup of bets\r\n      // for which commit signatures may have not expired yet (see whitepaper for details).\r\n      if (\r\n        game.bet1Amount != 0 ||\r\n        game.bet2Amount != 0 ||\r\n        game.bet3Amount != 0 ||\r\n        game.bet4Amount != 0 ||\r\n        game.bet5Amount != 0 ||\r\n        block.number <= game.placeBlockNumber + BET_EXPIRATION_BLOCKS\r\n      ) {\r\n          return;\r\n      }\r\n\r\n      // Zero out the remaining storage (amount was zeroed before, delete would consume 5k\r\n      // more gas).\r\n      game.placeBlockNumber = 0;\r\n      game.mask = 0;\r\n      game.gambler = address(0);\r\n  }\r\n\r\n  // A helper routine to bulk clean the storage.\r\n  function clearStorage(uint[] cleanCommits) external {\r\n      uint length = cleanCommits.length;\r\n\r\n      for (uint i = 0; i < length; i++) {\r\n          clearProcessedBet(cleanCommits[i]);\r\n      }\r\n  }\r\n\r\n  // Send funds.\r\n  function sendFunds(address beneficiary, uint amount) private {\r\n    if (beneficiary.send(amount)) {\r\n      emit Payment(beneficiary, amount);\r\n    } else {\r\n      emit FailedPayment(beneficiary, amount);\r\n    }\r\n  }\r\n\r\n  // Get actual win amount.\r\n  // dice1, dice2, dice3 - dice from 1 to 6\r\n  function _getWinAmount(\r\n    uint8 dice1,\r\n    uint8 dice2,\r\n    uint8 dice3,\r\n    uint24 betMask,\r\n    uint bet1Amount,\r\n    uint bet2Amount,\r\n    uint bet3Amount,\r\n    uint bet4Amount,\r\n    uint bet5Amount\r\n  )\r\n  private view returns (uint winAmount)\r\n  {\r\n    uint8 betCount = 0;\r\n    uint24 flag = 0;\r\n    uint8 sum = dice1 + dice2 + dice3;\r\n    uint8 i = 0;\r\n\r\n    for (i = 0; i < BET_MASK_COUNT; i++) {\r\n      flag = uint24(1) << i;\r\n      if(uint24(betMask & flag) == 0){\r\n        continue;\r\n      }else{\r\n        betCount += 1;\r\n      }\r\n      if(i < 14){\r\n        if(sum == betNumberResults[flag]){\r\n          winAmount += odds[flag] * _nextAmount(\r\n            betCount,\r\n            bet1Amount,\r\n            bet2Amount,\r\n            bet3Amount,\r\n            bet4Amount,\r\n            bet5Amount\r\n          );\r\n        }\r\n        continue;\r\n      }\r\n      if(i >= 14 && i < 20){\r\n        if(dice1 == betSameResults[flag] && dice1 == dice2 && dice1 == dice3){\r\n          winAmount += odds[flag] * _nextAmount(\r\n            betCount,\r\n            bet1Amount,\r\n            bet2Amount,\r\n            bet3Amount,\r\n            bet4Amount,\r\n            bet5Amount\r\n          );\r\n        }\r\n        continue;\r\n      }\r\n      if(\r\n        i == 20 &&\r\n        (sum >= 4 && sum <= 10)  &&\r\n        (dice1 != dice2 || dice1 != dice3 || dice2 != dice3)\r\n      ){\r\n        winAmount += odds[flag] * _nextAmount(\r\n          betCount,\r\n          bet1Amount,\r\n          bet2Amount,\r\n          bet3Amount,\r\n          bet4Amount,\r\n          bet5Amount\r\n        );\r\n      }\r\n      if(\r\n        i == 21 &&\r\n        (sum >= 11 && sum <= 17)  &&\r\n        (dice1 != dice2 || dice1 != dice3 || dice2 != dice3)\r\n      ){\r\n        winAmount += odds[flag] * _nextAmount(\r\n          betCount,\r\n          bet1Amount,\r\n          bet2Amount,\r\n          bet3Amount,\r\n          bet4Amount,\r\n          bet5Amount\r\n        );\r\n      }\r\n      if(betCount == MAX_BET){\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Choose next amount by bet count\r\n  function _nextAmount(\r\n    uint8 betCount,\r\n    uint bet1Amount,\r\n    uint bet2Amount,\r\n    uint bet3Amount,\r\n    uint bet4Amount,\r\n    uint bet5Amount\r\n  )\r\n  private pure returns (uint amount)\r\n  {\r\n    if(betCount == 1){\r\n      return bet1Amount;\r\n    }\r\n    if(betCount == 2){\r\n      return bet2Amount;\r\n    }\r\n    if(betCount == 3){\r\n      return bet3Amount;\r\n    }\r\n    if(betCount == 4){\r\n      return bet4Amount;\r\n    }\r\n    if(betCount == 5){\r\n      return bet5Amount;\r\n    }\r\n  }\r\n\r\n\r\n  // lock = 1, lock\r\n  // lock = 0, unlock\r\n  function _lockOrUnlockAmount(\r\n    uint24 betMask,\r\n    uint bet1Amount,\r\n    uint bet2Amount,\r\n    uint bet3Amount,\r\n    uint bet4Amount,\r\n    uint bet5Amount,\r\n    uint8 lock\r\n  )\r\n  private\r\n  {\r\n    uint8 betCount;\r\n    uint possibleWinAmount;\r\n    uint betBigSmallWinAmount = 0;\r\n    uint betNumberWinAmount = 0;\r\n    uint betSameWinAmount = 0;\r\n    uint24 flag = 0;\r\n    for (uint8 i = 0; i < BET_MASK_COUNT; i++) {\r\n      flag = uint24(1) << i;\r\n      if(uint24(betMask & flag) == 0){\r\n        continue;\r\n      }else{\r\n        betCount += 1;\r\n      }\r\n      if(i < 14 ){\r\n        betNumberWinAmount = _assertAmount(\r\n          betCount,\r\n          bet1Amount,\r\n          bet2Amount,\r\n          bet3Amount,\r\n          bet4Amount,\r\n          bet5Amount,\r\n          MAX_AMOUNT_NUMBER,\r\n          odds[flag],\r\n          betNumberWinAmount\r\n        );\r\n        continue;\r\n      }\r\n      if(i >= 14 && i < 20){\r\n        betSameWinAmount = _assertAmount(\r\n          betCount,\r\n          bet1Amount,\r\n          bet2Amount,\r\n          bet3Amount,\r\n          bet4Amount,\r\n          bet5Amount,\r\n          MAX_AMOUNT_SAME,\r\n          odds[flag],\r\n          betSameWinAmount\r\n        );\r\n        continue;\r\n      }\r\n      if(i >= 20){\r\n         betBigSmallWinAmount = _assertAmount(\r\n          betCount,\r\n          bet1Amount,\r\n          bet2Amount,\r\n          bet3Amount,\r\n          bet4Amount,\r\n          bet5Amount,\r\n          MAX_AMOUNT_BIG_SMALL,\r\n          odds[flag],\r\n          betBigSmallWinAmount\r\n        );\r\n        continue;\r\n      }\r\n      if(betCount == MAX_BET){\r\n        break;\r\n      }\r\n    }\r\n    if(betSameWinAmount >= betBigSmallWinAmount){\r\n      possibleWinAmount += betSameWinAmount;\r\n    }else{\r\n      possibleWinAmount += betBigSmallWinAmount;\r\n    }\r\n    possibleWinAmount += betNumberWinAmount;\r\n\r\n    // Check that game has valid number of bets\r\n    require (betCount > 0 && betCount <= MAX_BET,\r\n      \"Place bet count should be within range.\");\r\n\r\n    if(lock == 1){\r\n      // Lock funds.\r\n      lockedInBets += possibleWinAmount;\r\n      // Check whether contract has enough funds to process this bet.\r\n      require (lockedInBets <= address(this).balance,\r\n        \"Cannot afford to lose this bet.\");\r\n    }else{\r\n      // Unlock funds.\r\n      lockedInBets -= possibleWinAmount;\r\n      require (lockedInBets >= 0,\r\n        \"Not enough locked in amount.\");\r\n    }\r\n  }\r\n\r\n  function _max(uint amount, uint8 odd, uint possibleWinAmount)\r\n  private pure returns (uint newAmount)\r\n  {\r\n    uint winAmount = amount * odd;\r\n    if( winAmount > possibleWinAmount){\r\n      return winAmount;\r\n    }else{\r\n      return possibleWinAmount;\r\n    }\r\n  }\r\n\r\n  function _assertAmount(\r\n    uint8 betCount,\r\n    uint amount1,\r\n    uint amount2,\r\n    uint amount3,\r\n    uint amount4,\r\n    uint amount5,\r\n    uint maxAmount,\r\n    uint8 odd,\r\n    uint possibleWinAmount\r\n  )\r\n  private pure returns (uint amount)\r\n  {\r\n    string memory warnMsg = \"Place bet amount should be within range.\";\r\n    if(betCount == 1){\r\n      require (amount1 >= MIN_AMOUNT && amount1 <= maxAmount, warnMsg);\r\n      return _max(amount1, odd, possibleWinAmount);\r\n    }\r\n    if(betCount == 2){\r\n      require (amount2 >= MIN_AMOUNT && amount2 <= maxAmount, warnMsg);\r\n      return _max(amount2, odd, possibleWinAmount);\r\n    }\r\n    if(betCount == 3){\r\n      require (amount3 >= MIN_AMOUNT && amount3 <= maxAmount, warnMsg);\r\n      return _max(amount3, odd, possibleWinAmount);\r\n    }\r\n    if(betCount == 4){\r\n      require (amount4 >= MIN_AMOUNT && amount4 <= maxAmount, warnMsg);\r\n      return _max(amount4, odd, possibleWinAmount);\r\n    }\r\n    if(betCount == 5){\r\n      require (amount5 >= MIN_AMOUNT && amount5 <= maxAmount, warnMsg);\r\n      return _max(amount5, odd, possibleWinAmount);\r\n    }\r\n  }\r\n\r\n  // Standard modifier on methods invokable only by contract owner.\r\n  modifier onlyOwner {\r\n      require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n      _;\r\n  }\r\n\r\n  // Standard contract ownership transfer implementation,\r\n  function approveNextOwner(address _nextOwner) external onlyOwner {\r\n    require (_nextOwner != owner, \"Cannot approve current owner.\");\r\n    nextOwner = _nextOwner;\r\n  }\r\n\r\n  function acceptNextOwner() external {\r\n    require (msg.sender == nextOwner, \"Can only accept preapproved new owner.\");\r\n    owner = nextOwner;\r\n  }\r\n\r\n  // Fallback function deliberately left empty. It's primary use case\r\n  // is to top up the bank roll.\r\n  function () public payable {\r\n  }\r\n\r\n  // See comment for \"secretSigner\" variable.\r\n  function setSecretSigner(address newSecretSigner) external onlyOwner {\r\n    secretSigner = newSecretSigner;\r\n  }\r\n\r\n  // Funds withdrawal to cover team costs.\r\n  function withdrawFunds(address beneficiary, uint withdrawAmount) external onlyOwner {\r\n    require (withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n    require (lockedInBets + withdrawAmount <= address(this).balance, \"Not enough funds.\");\r\n    sendFunds(beneficiary, withdrawAmount);\r\n  }\r\n\r\n  // Contract may be destroyed only when there are no ongoing bets,\r\n  // either settled or refunded. All funds are transferred to contract owner.\r\n  function kill() external onlyOwner {\r\n      require (lockedInBets == 0, \"All bets should be processed (settled or refunded) before self-destruct.\");\r\n      selfdestruct(owner);\r\n  }\r\n\r\n  // Close or open the game.\r\n  function enable(bool _enabled) external onlyOwner{\r\n    enabled = _enabled;\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"enabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secretSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"enable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reveal\",\"type\":\"uint256\"},{\"name\":\"cleanCommit\",\"type\":\"uint256\"}],\"name\":\"settleGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"withdrawAmount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betMask\",\"type\":\"uint24\"},{\"name\":\"bet1Amount\",\"type\":\"uint256\"},{\"name\":\"bet2Amount\",\"type\":\"uint256\"},{\"name\":\"bet3Amount\",\"type\":\"uint256\"},{\"name\":\"bet4Amount\",\"type\":\"uint256\"},{\"name\":\"bet5Amount\",\"type\":\"uint256\"},{\"name\":\"commitLastBlock\",\"type\":\"uint256\"},{\"name\":\"commit\",\"type\":\"uint256\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"placeGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextOwner\",\"type\":\"address\"}],\"name\":\"approveNextOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newSecretSigner\",\"type\":\"address\"}],\"name\":\"setSecretSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"commit\",\"type\":\"uint256\"}],\"name\":\"refundBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"cleanCommits\",\"type\":\"uint256[]\"}],\"name\":\"clearStorage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payment\",\"type\":\"event\"}]","ContractName":"BitrngDice","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://644563a8ebe8a9c10af3ee09144a5d01616af6a11df193f5bc3a96cf084c77f1"}]}