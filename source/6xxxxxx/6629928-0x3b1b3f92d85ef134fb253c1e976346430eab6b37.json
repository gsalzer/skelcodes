{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ninterface ICaelumMiner {\r\n    function getMiningReward() external returns (uint) ;\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @dev Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract InterfaceContracts is Ownable {\r\n    InterfaceContracts public _internalMod;\r\n    \r\n    function setModifierContract (address _t) onlyOwner public {\r\n        _internalMod = InterfaceContracts(_t);\r\n    }\r\n\r\n    modifier onlyMiningContract() {\r\n      require(msg.sender == _internalMod._contract_miner(), \"Wrong sender\");\r\n          _;\r\n      }\r\n\r\n    modifier onlyTokenContract() {\r\n      require(msg.sender == _internalMod._contract_token(), \"Wrong sender\");\r\n      _;\r\n    }\r\n    \r\n    modifier onlyMasternodeContract() {\r\n      require(msg.sender == _internalMod._contract_masternode(), \"Wrong sender\");\r\n      _;\r\n    }\r\n    \r\n    modifier onlyVotingOrOwner() {\r\n      require(msg.sender == _internalMod._contract_voting() || msg.sender == owner, \"Wrong sender\");\r\n      _;\r\n    }\r\n    \r\n    modifier onlyVotingContract() {\r\n      require(msg.sender == _internalMod._contract_voting() || msg.sender == owner, \"Wrong sender\");\r\n      _;\r\n    }\r\n      \r\n    function _contract_voting () public view returns (address) {\r\n        return _internalMod._contract_voting();\r\n    }\r\n    \r\n    function _contract_masternode () public view returns (address) {\r\n        return _internalMod._contract_masternode();\r\n    }\r\n    \r\n    function _contract_token () public view returns (address) {\r\n        return _internalMod._contract_token();\r\n    }\r\n    \r\n    function _contract_miner () public view returns (address) {\r\n        return _internalMod._contract_miner();\r\n    }\r\n}\r\n\r\ncontract CaelumAbstractMasternode is Ownable {\r\n\r\n    struct MasterNode {\r\n        address accountOwner;\r\n        bool isActive;\r\n        bool isTeamMember;\r\n        uint storedIndex;\r\n        uint startingRound;\r\n        uint nodeCount;\r\n        uint[] indexcounter;\r\n\r\n    }\r\n\r\n    mapping(address => MasterNode) public userByAddress;\r\n    mapping(uint => MasterNode) public masternodeByIndex;\r\n\r\n    uint public userCounter = 0;\r\n    uint public masternodeIDcounter = 0;\r\n    uint public masternodeRound = 0;\r\n    uint public masternodeCandidate;\r\n\r\n    uint public MINING_PHASE_DURATION_BLOCKS = 4500;\r\n\r\n    uint public miningEpoch;\r\n    uint public rewardsProofOfWork;\r\n    uint public rewardsMasternode;\r\n\r\n    bool genesisAdded = false;\r\n\r\n    event NewMasternode(address candidateAddress, uint timeStamp);\r\n    event RemovedMasternode(address candidateAddress, uint timeStamp);\r\n\r\n\r\n    address [] public genesisList = [\r\n      0xdb93CE3cCA2444CE5DA5522a85758af79Af0092D,\r\n      0x375E97e59dE97BE46D332Ba17185620B81bdB7cc,\r\n      0x14dB686439Aad3C076B793335BC14D9039F32C54,\r\n      0x1Ba4b0280163889e7Ee4ab5269C442971F48d13e,\r\n      0xE4Ac657af0690E9437f36D3E96886DC880b24404,\r\n      0x08Fcf0027E1e91a12981fBc6371dE39A269C3a47,\r\n      0x3d664B7B0Eb158798f3E797e194FEe50dD748742,\r\n      0xB85aC167079020d93033a014efEaD75f14018522,\r\n      0xc6d00915CbcF9ABE9B27403F8d2338551f4ac43b,\r\n      0x5256fE3F8e50E0f7f701525e814A2767da2cca06,\r\n      0x2cf23c6610A70d58D61eFbdEfD6454960b200c2C\r\n    ];\r\n\r\n    function addGenesis() onlyOwner public {\r\n        require(!genesisAdded);\r\n\r\n        for (uint i=0; i<genesisList.length; i++) {\r\n          addMasternode(genesisList[i]);\r\n        }\r\n\r\n        genesisAdded = true; // Forever lock this.\r\n    }\r\n\r\n    function addOwner() onlyOwner public {\r\n        addMasternode(owner);\r\n        updateMasternodeAsTeamMember(owner);\r\n    }\r\n\r\n    function addMasternode(address _candidate) internal {\r\n        /**\r\n         * @dev userByAddress is used for general statistic data.\r\n         * All masternode interaction happens by masternodeByIndex!\r\n         */\r\n        userByAddress[_candidate].isActive = true;\r\n        userByAddress[_candidate].accountOwner = _candidate;\r\n        userByAddress[_candidate].storedIndex = masternodeIDcounter;\r\n        userByAddress[_candidate].startingRound = masternodeRound + 1;\r\n        userByAddress[_candidate].indexcounter.push(masternodeIDcounter);\r\n\r\n        masternodeByIndex[masternodeIDcounter].isActive = true;\r\n        masternodeByIndex[masternodeIDcounter].accountOwner = _candidate;\r\n        masternodeByIndex[masternodeIDcounter].storedIndex = masternodeIDcounter;\r\n        masternodeByIndex[masternodeIDcounter].startingRound = masternodeRound + 1;\r\n\r\n        masternodeIDcounter++;\r\n        userCounter++;\r\n    }\r\n\r\n    function updateMasternode(uint _index) internal returns(bool) {\r\n        masternodeByIndex[_index].startingRound++;\r\n        return true;\r\n    }\r\n\r\n    function updateMasternodeAsTeamMember(address _candidate) internal returns(bool) {\r\n        userByAddress[_candidate].isTeamMember = true;\r\n        return (true);\r\n    }\r\n\r\n    function deleteMasternode(uint _index) internal {\r\n        address getUserFrom = getUserFromID(_index);\r\n        userByAddress[getUserFrom].isActive = false;\r\n        masternodeByIndex[_index].isActive = false;\r\n        userCounter--;\r\n    }\r\n\r\n    function getLastActiveBy(address _candidate) public view returns(uint) {\r\n      uint lastFound;\r\n      for (uint i = 0; i < userByAddress[_candidate].indexcounter.length; i++) {\r\n          if (masternodeByIndex[userByAddress[_candidate].indexcounter[i]].isActive == true) {\r\n              lastFound = masternodeByIndex[userByAddress[_candidate].indexcounter[i]].storedIndex;\r\n          }\r\n      }\r\n      return lastFound;\r\n    }\r\n\r\n    function userHasActiveNodes(address _candidate) public view returns(bool) {\r\n\r\n        bool lastFound;\r\n\r\n        for (uint i = 0; i < userByAddress[_candidate].indexcounter.length; i++) {\r\n            if (masternodeByIndex[userByAddress[_candidate].indexcounter[i]].isActive == true) {\r\n                lastFound = true;\r\n            }\r\n        }\r\n        return lastFound;\r\n    }\r\n\r\n    function setMasternodeCandidate() internal returns(address) {\r\n\r\n        uint hardlimitCounter = 0;\r\n\r\n        while (getFollowingCandidate() == 0x0) {\r\n            // We must return a value not to break the contract. Require is a secondary killswitch now.\r\n            require(hardlimitCounter < 6, \"Failsafe switched on\");\r\n            // Choose if loop over revert/require to terminate the loop and return a 0 address.\r\n            if (hardlimitCounter == 5) return (0);\r\n            masternodeRound = masternodeRound + 1;\r\n            masternodeCandidate = 0;\r\n            hardlimitCounter++;\r\n        }\r\n\r\n        if (masternodeCandidate == masternodeIDcounter - 1) {\r\n            masternodeRound = masternodeRound + 1;\r\n            masternodeCandidate = 0;\r\n        }\r\n\r\n        for (uint i = masternodeCandidate; i < masternodeIDcounter; i++) {\r\n            if (masternodeByIndex[i].isActive) {\r\n                if (masternodeByIndex[i].startingRound == masternodeRound) {\r\n                    updateMasternode(i);\r\n                    masternodeCandidate = i;\r\n                    return (masternodeByIndex[i].accountOwner);\r\n                }\r\n            }\r\n        }\r\n\r\n        masternodeRound = masternodeRound + 1;\r\n        return (0);\r\n\r\n    }\r\n\r\n    function getFollowingCandidate() public view returns(address _address) {\r\n        uint tmpRound = masternodeRound;\r\n        uint tmpCandidate = masternodeCandidate;\r\n\r\n        if (tmpCandidate == masternodeIDcounter - 1) {\r\n            tmpRound = tmpRound + 1;\r\n            tmpCandidate = 0;\r\n        }\r\n\r\n        for (uint i = masternodeCandidate; i < masternodeIDcounter; i++) {\r\n            if (masternodeByIndex[i].isActive) {\r\n                if (masternodeByIndex[i].startingRound == tmpRound) {\r\n                    tmpCandidate = i;\r\n                    return (masternodeByIndex[i].accountOwner);\r\n                }\r\n            }\r\n        }\r\n\r\n        tmpRound = tmpRound + 1;\r\n        return (0);\r\n    }\r\n\r\n    function calculateRewardStructures() internal {\r\n        //ToDo: Set\r\n        uint _global_reward_amount = getMiningReward();\r\n        uint getStageOfMining = miningEpoch / MINING_PHASE_DURATION_BLOCKS * 10;\r\n\r\n        if (getStageOfMining < 10) {\r\n            rewardsProofOfWork = _global_reward_amount / 100 * 5;\r\n            rewardsMasternode = 0;\r\n            return;\r\n        }\r\n\r\n        if (getStageOfMining > 90) {\r\n            rewardsProofOfWork = _global_reward_amount / 100 * 2;\r\n            rewardsMasternode = _global_reward_amount / 100 * 98;\r\n            return;\r\n        }\r\n\r\n        uint _mnreward = (_global_reward_amount / 100) * getStageOfMining;\r\n        uint _powreward = (_global_reward_amount - _mnreward);\r\n\r\n        setBaseRewards(_powreward, _mnreward);\r\n    }\r\n\r\n    function setBaseRewards(uint _pow, uint _mn) internal {\r\n        rewardsMasternode = _mn;\r\n        rewardsProofOfWork = _pow;\r\n    }\r\n\r\n    function _arrangeMasternodeFlow() internal {\r\n        calculateRewardStructures();\r\n        setMasternodeCandidate();\r\n        miningEpoch++;\r\n    }\r\n\r\n    function isMasternodeOwner(address _candidate) public view returns(bool) {\r\n        if (userByAddress[_candidate].indexcounter.length <= 0) return false;\r\n        if (userByAddress[_candidate].accountOwner == _candidate)\r\n            return true;\r\n    }\r\n\r\n    function belongsToUser(address _candidate) public view returns(uint[]) {\r\n        return userByAddress[_candidate].indexcounter;\r\n    }\r\n\r\n    function getLastPerUser(address _candidate) public view returns(uint) {\r\n        return userByAddress[_candidate].indexcounter[userByAddress[_candidate].indexcounter.length - 1];\r\n    }\r\n\r\n    function getUserFromID(uint _index) public view returns(address) {\r\n        return masternodeByIndex[_index].accountOwner;\r\n    }\r\n\r\n    function getMiningReward() public view returns(uint) {\r\n        return 50 * 1e8;\r\n    }\r\n\r\n    function masternodeInfo(uint _index) public view returns\r\n        (\r\n            address,\r\n            bool,\r\n            uint,\r\n            uint\r\n        ) {\r\n            return (\r\n                masternodeByIndex[_index].accountOwner,\r\n                masternodeByIndex[_index].isActive,\r\n                masternodeByIndex[_index].storedIndex,\r\n                masternodeByIndex[_index].startingRound\r\n            );\r\n        }\r\n\r\n    function contractProgress() public view returns\r\n        (\r\n            uint epoch,\r\n            uint candidate,\r\n            uint round,\r\n            uint miningepoch,\r\n            uint globalreward,\r\n            uint powreward,\r\n            uint masternodereward,\r\n            uint usercount\r\n        ) {\r\n            return (\r\n                0,\r\n                masternodeCandidate,\r\n                masternodeRound,\r\n                miningEpoch,\r\n                getMiningReward(),\r\n                rewardsProofOfWork,\r\n                rewardsMasternode,\r\n                userCounter\r\n            );\r\n        }\r\n\r\n}\r\n\r\ncontract CaelumMasternode is InterfaceContracts, CaelumAbstractMasternode {\r\n\r\n    bool minerSet = false;\r\n    bool tokenSet = false;\r\n    uint swapStartedBlock = now;\r\n\r\n    address cloneDataFrom = 0x7600bF5112945F9F006c216d5d6db0df2806eDc6;\r\n\r\n\r\n    /**\r\n     * @dev Use this to externaly call the _arrangeMasternodeFlow function. ALWAYS set a modifier !\r\n     */\r\n\r\n    function _externalArrangeFlow() onlyMiningContract public {\r\n        _arrangeMasternodeFlow();\r\n    }\r\n\r\n    /**\r\n     * @dev Use this to externaly call the addMasternode function. ALWAYS set a modifier !\r\n     */\r\n    function _externalAddMasternode(address _received) onlyTokenContract public {\r\n        addMasternode(_received);\r\n    }\r\n\r\n    /**\r\n     * @dev Use this to externaly call the deleteMasternode function. ALWAYS set a modifier !\r\n     */\r\n    function _externalStopMasternode(address _received) onlyTokenContract public {\r\n        deleteMasternode(getLastActiveBy(_received));\r\n    }\r\n\r\n    function getMiningReward() public view returns(uint) {\r\n        return ICaelumMiner(_contract_miner()).getMiningReward();\r\n    }\r\n\r\n    /**\r\n    * @dev Move the voting away from token. All votes will be made from the voting\r\n    */\r\n    function VoteModifierContract (address _contract) onlyVotingContract external {\r\n        //_internalMod = CaelumModifierAbstract(_contract);\r\n        setModifierContract(_contract);\r\n    }\r\n\r\n    function getDataFromContract() onlyOwner public returns(uint) {\r\n\r\n        CaelumMasternode prev = CaelumMasternode(cloneDataFrom);\r\n        (\r\n          uint epoch,\r\n          uint candidate,\r\n          uint round,\r\n          uint miningepoch,\r\n          uint globalreward,\r\n          uint powreward,\r\n          uint masternodereward,\r\n          uint usercounter\r\n        ) = prev.contractProgress();\r\n\r\n        masternodeRound = round;\r\n        miningEpoch = miningepoch;\r\n        rewardsProofOfWork = powreward;\r\n        rewardsMasternode = masternodereward;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"_contract_miner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"VoteModifierContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsProofOfWork\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_t\",\"type\":\"address\"}],\"name\":\"setModifierContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserFromID\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masternodeCandidate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addGenesis\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningEpoch\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractProgress\",\"outputs\":[{\"name\":\"epoch\",\"type\":\"uint256\"},{\"name\":\"candidate\",\"type\":\"uint256\"},{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"miningepoch\",\"type\":\"uint256\"},{\"name\":\"globalreward\",\"type\":\"uint256\"},{\"name\":\"powreward\",\"type\":\"uint256\"},{\"name\":\"masternodereward\",\"type\":\"uint256\"},{\"name\":\"usercount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_contract_voting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"masternodeByIndex\",\"outputs\":[{\"name\":\"accountOwner\",\"type\":\"address\"},{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"isTeamMember\",\"type\":\"bool\"},{\"name\":\"storedIndex\",\"type\":\"uint256\"},{\"name\":\"startingRound\",\"type\":\"uint256\"},{\"name\":\"nodeCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masternodeRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userByAddress\",\"outputs\":[{\"name\":\"accountOwner\",\"type\":\"address\"},{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"isTeamMember\",\"type\":\"bool\"},{\"name\":\"storedIndex\",\"type\":\"uint256\"},{\"name\":\"startingRound\",\"type\":\"uint256\"},{\"name\":\"nodeCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"isMasternodeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_externalArrangeFlow\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"getLastPerUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_contract_masternode\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"getLastActiveBy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"userHasActiveNodes\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"genesisList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFollowingCandidate\",\"outputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_contract_token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_internalMod\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"belongsToUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_received\",\"type\":\"address\"}],\"name\":\"_externalStopMasternode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_received\",\"type\":\"address\"}],\"name\":\"_externalAddMasternode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINING_PHASE_DURATION_BLOCKS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardsMasternode\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"masternodeIDcounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getDataFromContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"masternodeInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"candidateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"NewMasternode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"candidateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"RemovedMasternode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CaelumMasternode","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3170db7279ef97a636ecb88cf77afb4dd0a95b2c007e292eaba5b0ad4f240fe0"}]}