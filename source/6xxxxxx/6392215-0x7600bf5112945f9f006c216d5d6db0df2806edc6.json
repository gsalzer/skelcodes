{"status":"1","message":"OK","result":[{"SourceCode":"//solium-disable linebreak-style\r\npragma solidity ^0.4.24;\r\n\r\nlibrary ExtendedMath {\r\n    function limitLessThan(uint a, uint b) internal pure returns(uint c) {\r\n        if (a > b) return b;\r\n        return a;\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, reverts on overflow.\r\n     */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n     */\r\n    function div(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, reverts on overflow.\r\n     */\r\n    function add(uint256 _a, uint256 _b) internal pure returns(uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n     * reverts when dividing by zero.\r\n     */\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns(uint256);\r\n\r\n    function balanceOf(address _who) public view returns(uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns(bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address _owner, address _spender) public view returns(uint256);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\r\n\r\n    function approve(address _spender, uint256 _value) public returns(bool);\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath\r\n    for uint256;\r\n\r\n    mapping(address => uint256) internal balances;\r\n\r\n    uint256 internal totalSupply_;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns(uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns(bool) {\r\n        require(_value <= balances[msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view returns(uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n    public\r\n    returns(bool) {\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns(bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n    public\r\n    view\r\n    returns(uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n    public\r\n    returns(bool) {\r\n        allowed[msg.sender][_spender] = (\r\n            allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n    public\r\n    returns(bool) {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ninterface IcaelumVoting {\r\n    function getTokenProposalDetails() external view returns(address, uint, uint, uint);\r\n    function getExpiry() external view returns (uint);\r\n    function getContractType () external view returns (uint);\r\n}\r\n\r\ncontract abstractCaelum {\r\n    function isMasternodeOwner(address _candidate) public view returns(bool);\r\n    function addToWhitelist(address _ad, uint _amount, uint daysAllowed) internal;\r\n    function addMasternode(address _candidate) internal returns(uint);\r\n    function deleteMasternode(uint entityAddress) internal returns(bool success);\r\n    function getLastPerUser(address _candidate) public view returns (uint);\r\n    function getMiningReward() public view returns(uint);\r\n}\r\n\r\ncontract NewTokenProposal is IcaelumVoting {\r\n\r\n    enum VOTE_TYPE {TOKEN, TEAM}\r\n\r\n    VOTE_TYPE public contractType = VOTE_TYPE.TOKEN;\r\n    address contractAddress;\r\n    uint requiredAmount;\r\n    uint validUntil;\r\n    uint votingDurationInDays;\r\n\r\n    /**\r\n     * @dev Create a new vote proposal for an ERC20 token.\r\n     * @param _contract ERC20 contract\r\n     * @param _amount How many tokens are required as collateral\r\n     * @param _valid How long do we accept these tokens on the contract (UNIX timestamp)\r\n     * @param _voteDuration How many days is this vote available\r\n     */\r\n    constructor(address _contract, uint _amount, uint _valid, uint _voteDuration) public {\r\n        require(_voteDuration >= 14 && _voteDuration <= 50, \"Proposed voting duration does not meet requirements\");\r\n\r\n        contractAddress = _contract;\r\n        requiredAmount = _amount;\r\n        validUntil = _valid;\r\n        votingDurationInDays = _voteDuration;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns all details about this proposal\r\n     */\r\n    function getTokenProposalDetails() public view returns(address, uint, uint, uint) {\r\n        return (contractAddress, requiredAmount, validUntil, uint(contractType));\r\n    }\r\n\r\n    /**\r\n     * @dev Displays the expiry date of contract\r\n     * @return uint Days valid\r\n     */\r\n    function getExpiry() external view returns (uint) {\r\n        return votingDurationInDays;\r\n    }\r\n\r\n    /**\r\n     * @dev Displays the type of contract\r\n     * @return uint Enum value {TOKEN, TEAM}\r\n     */\r\n    function getContractType () external view returns (uint){\r\n        return uint(contractType);\r\n    }\r\n}\r\n\r\ncontract NewMemberProposal is IcaelumVoting {\r\n\r\n    enum VOTE_TYPE {TOKEN, TEAM}\r\n    VOTE_TYPE public contractType = VOTE_TYPE.TEAM;\r\n\r\n    address memberAddress;\r\n    uint totalMasternodes;\r\n    uint votingDurationInDays;\r\n\r\n    /**\r\n     * @dev Create a new vote proposal for a team member.\r\n     * @param _contract Future team member's address\r\n     * @param _total How many masternodes do we want to give\r\n     * @param _voteDuration How many days is this vote available\r\n     */\r\n    constructor(address _contract, uint _total, uint _voteDuration) public {\r\n        require(_voteDuration >= 14 && _voteDuration <= 50, \"Proposed voting duration does not meet requirements\");\r\n        memberAddress = _contract;\r\n        totalMasternodes = _total;\r\n        votingDurationInDays = _voteDuration;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns all details about this proposal\r\n     */\r\n    function getTokenProposalDetails() public view returns(address, uint, uint, uint) {\r\n        return (memberAddress, totalMasternodes, 0, uint(contractType));\r\n    }\r\n\r\n    /**\r\n     * @dev Displays the expiry date of contract\r\n     * @return uint Days valid\r\n     */\r\n    function getExpiry() external view returns (uint) {\r\n        return votingDurationInDays;\r\n    }\r\n\r\n    /**\r\n     * @dev Displays the type of contract\r\n     * @return uint Enum value {TOKEN, TEAM}\r\n     */\r\n    function getContractType () external view returns (uint){\r\n        return uint(contractType);\r\n    }\r\n}\r\n\r\ncontract CaelumVotings is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    enum VOTE_TYPE {TOKEN, TEAM}\r\n\r\n    struct Proposals {\r\n        address tokenContract;\r\n        uint totalVotes;\r\n        uint proposedOn;\r\n        uint acceptedOn;\r\n        VOTE_TYPE proposalType;\r\n    }\r\n\r\n    struct Voters {\r\n        bool isVoter;\r\n        address owner;\r\n        uint[] votedFor;\r\n    }\r\n\r\n    uint MAJORITY_PERCENTAGE_NEEDED = 60;\r\n    uint MINIMUM_VOTERS_NEEDED = 10;\r\n    bool public proposalPending;\r\n\r\n    mapping(uint => Proposals) public proposalList;\r\n    mapping (address => Voters) public voterMap;\r\n    mapping(uint => address) public voterProposals;\r\n    uint public proposalCounter;\r\n    uint public votersCount;\r\n    uint public votersCountTeam;\r\n\r\n    /**\r\n     * @notice Define abstract functions for later user\r\n     */\r\n    function isMasternodeOwner(address _candidate) public view returns(bool);\r\n    function addToWhitelist(address _ad, uint _amount, uint daysAllowed) internal;\r\n    function addMasternode(address _candidate) internal returns(uint);\r\n    function updateMasternodeAsTeamMember(address _member) internal returns (bool);\r\n    function isTeamMember (address _candidate) public view returns (bool);\r\n    \r\n    event NewProposal(uint ProposalID);\r\n    event ProposalAccepted(uint ProposalID);\r\n\r\n    /**\r\n     * @dev Create a new proposal.\r\n     * @param _contract Proposal contract address\r\n     * @return uint ProposalID\r\n     */\r\n    function pushProposal(address _contract) onlyOwner public returns (uint) {\r\n        if(proposalCounter != 0)\r\n        require (pastProposalTimeRules (), \"You need to wait 90 days before submitting a new proposal.\");\r\n        require (!proposalPending, \"Another proposal is pending.\");\r\n\r\n        uint _contractType = IcaelumVoting(_contract).getContractType();\r\n        proposalList[proposalCounter] = Proposals(_contract, 0, now, 0, VOTE_TYPE(_contractType));\r\n\r\n        emit NewProposal(proposalCounter);\r\n        \r\n        proposalCounter++;\r\n        proposalPending = true;\r\n\r\n        return proposalCounter.sub(1);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that handles the proposal after it got accepted.\r\n     * This function determines if the proposal is a token or team member proposal and executes the corresponding functions.\r\n     * @return uint Returns the proposal ID.\r\n     */\r\n    function handleLastProposal () internal returns (uint) {\r\n        uint _ID = proposalCounter.sub(1);\r\n\r\n        proposalList[_ID].acceptedOn = now;\r\n        proposalPending = false;\r\n\r\n        address _address;\r\n        uint _required;\r\n        uint _valid;\r\n        uint _type;\r\n        (_address, _required, _valid, _type) = getTokenProposalDetails(_ID);\r\n\r\n        if(_type == uint(VOTE_TYPE.TOKEN)) {\r\n            addToWhitelist(_address,_required,_valid);\r\n        }\r\n\r\n        if(_type == uint(VOTE_TYPE.TEAM)) {\r\n            if(_required != 0) {\r\n                for (uint i = 0; i < _required; i++) {\r\n                    addMasternode(_address);\r\n                }\r\n            } else {\r\n                addMasternode(_address);\r\n            }\r\n            updateMasternodeAsTeamMember(_address);\r\n        }\r\n        \r\n        emit ProposalAccepted(_ID);\r\n        \r\n        return _ID;\r\n    }\r\n\r\n    /**\r\n     * @dev Rejects the last proposal after the allowed voting time has expired and it's not accepted.\r\n     */\r\n    function discardRejectedProposal() onlyOwner public returns (bool) {\r\n        require(proposalPending);\r\n        require (LastProposalCanDiscard());\r\n        proposalPending = false;\r\n        return (true);\r\n    }\r\n\r\n    /**\r\n     * @dev Checks if the last proposal allowed voting time has expired and it's not accepted.\r\n     * @return bool\r\n     */\r\n    function LastProposalCanDiscard () public view returns (bool) {\r\n        \r\n        uint daysBeforeDiscard = IcaelumVoting(proposalList[proposalCounter - 1].tokenContract).getExpiry();\r\n        uint entryDate = proposalList[proposalCounter - 1].proposedOn;\r\n        uint expiryDate = entryDate + (daysBeforeDiscard * 1 days);\r\n\r\n        if (now >= expiryDate)\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns all details about a proposal\r\n     */\r\n    function getTokenProposalDetails(uint proposalID) public view returns(address, uint, uint, uint) {\r\n        return IcaelumVoting(proposalList[proposalID].tokenContract).getTokenProposalDetails();\r\n    }\r\n\r\n    /**\r\n     * @dev Returns if our 90 day cooldown has passed\r\n     * @return bool\r\n     */\r\n    function pastProposalTimeRules() public view returns (bool) {\r\n        uint lastProposal = proposalList[proposalCounter - 1].proposedOn;\r\n        if (now >= lastProposal + 90 days)\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allow any masternode user to become a voter.\r\n     */\r\n    function becomeVoter() public  {\r\n        require (isMasternodeOwner(msg.sender), \"User has no masternodes\");\r\n        require (!voterMap[msg.sender].isVoter, \"User Already voted for this proposal\");\r\n\r\n        voterMap[msg.sender].owner = msg.sender;\r\n        voterMap[msg.sender].isVoter = true;\r\n        votersCount = votersCount + 1;\r\n\r\n        if (isTeamMember(msg.sender))\r\n        votersCountTeam = votersCountTeam + 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow voters to submit their vote on a proposal. Voters can only cast 1 vote per proposal.\r\n     * If the proposed vote is about adding Team members, only Team members are able to vote.\r\n     * A proposal can only be published if the total of votes is greater then MINIMUM_VOTERS_NEEDED.\r\n     * @param proposalID proposalID\r\n     */\r\n    function voteProposal(uint proposalID) public returns (bool success) {\r\n        require(voterMap[msg.sender].isVoter, \"Sender not listed as voter\");\r\n        require(proposalID >= 0, \"No proposal was selected.\");\r\n        require(proposalID <= proposalCounter, \"Proposal out of limits.\");\r\n        require(voterProposals[proposalID] != msg.sender, \"Already voted.\");\r\n\r\n\r\n        if(proposalList[proposalID].proposalType == VOTE_TYPE.TEAM) {\r\n            require (isTeamMember(msg.sender), \"Restricted for team members\");\r\n            voterProposals[proposalID] = msg.sender;\r\n            proposalList[proposalID].totalVotes++;\r\n\r\n            if(reachedMajorityForTeam(proposalID)) {\r\n                // This is the prefered way of handling vote results. It costs more gas but prevents tampering.\r\n                // If gas is an issue, you can comment handleLastProposal out and call it manually as onlyOwner.\r\n                handleLastProposal();\r\n                return true;\r\n            }\r\n        } else {\r\n            require(votersCount >= MINIMUM_VOTERS_NEEDED, \"Not enough voters in existence to push a proposal\");\r\n            voterProposals[proposalID] = msg.sender;\r\n            proposalList[proposalID].totalVotes++;\r\n\r\n            if(reachedMajority(proposalID)) {\r\n                // This is the prefered way of handling vote results. It costs more gas but prevents tampering.\r\n                // If gas is an issue, you can comment handleLastProposal out and call it manually as onlyOwner.\r\n                handleLastProposal();\r\n                return true;\r\n            }\r\n        }\r\n\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a proposal has reached the majority vote\r\n     * @param proposalID Token ID\r\n     * @return bool\r\n     */\r\n    function reachedMajority (uint proposalID) public view returns (bool) {\r\n        uint getProposalVotes = proposalList[proposalID].totalVotes;\r\n        if (getProposalVotes >= majority())\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that calculates the majority\r\n     * @return uint Total of votes needed for majority\r\n     */\r\n    function majority () internal view returns (uint) {\r\n        uint a = (votersCount * MAJORITY_PERCENTAGE_NEEDED );\r\n        return a / 100;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if a proposal has reached the majority vote for a team member\r\n     * @param proposalID Token ID\r\n     * @return bool\r\n     */\r\n    function reachedMajorityForTeam (uint proposalID) public view returns (bool) {\r\n        uint getProposalVotes = proposalList[proposalID].totalVotes;\r\n        if (getProposalVotes >= majorityForTeam())\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that calculates the majority\r\n     * @return uint Total of votes needed for majority\r\n     */\r\n    function majorityForTeam () internal view returns (uint) {\r\n        uint a = (votersCountTeam * MAJORITY_PERCENTAGE_NEEDED );\r\n        return a / 100;\r\n    }\r\n\r\n}\r\n\r\ncontract CaelumFundraise is Ownable, BasicToken, abstractCaelum {\r\n\r\n    /**\r\n     * In no way is Caelum intended to raise funds. We leave this code to demonstrate the potential and functionality.\r\n     * Should you decide to buy a masternode instead of mining, you can by using this function. Feel free to consider this a tipping jar for our dev team.\r\n     * We strongly advice to use the `buyMasternode`function, but simply sending Ether to the contract should work as well.\r\n     */\r\n\r\n    uint AMOUNT_FOR_MASTERNODE = 50 ether;\r\n    uint SPOTS_RESERVED = 10;\r\n    uint COUNTER;\r\n    bool fundraiseClosed = false;\r\n\r\n    /**\r\n     * @dev Not recommended way to accept Ether. Can be safely used if no storage operations are called\r\n     * The contract may revert all the gas because of the gas limitions on the fallback operator.\r\n     * We leave it in as template for other projects, however, for Caelum the function deposit should be adviced.\r\n     */\r\n    function() payable public {\r\n        require(msg.value == AMOUNT_FOR_MASTERNODE && msg.value != 0);\r\n        receivedFunds();\r\n    }\r\n\r\n    /** @dev This is the recommended way for users to deposit Ether in return of a masternode.\r\n     * Users should be encouraged to use this approach as there is not gas risk involved.\r\n     */\r\n    function buyMasternode () payable public {\r\n        require(msg.value == AMOUNT_FOR_MASTERNODE && msg.value != 0);\r\n        receivedFunds();\r\n    }\r\n\r\n    /**\r\n     * @dev Forward funds to owner before making any action. owner.transfer will revert if fail.\r\n     */\r\n    function receivedFunds() internal {\r\n        require(!fundraiseClosed);\r\n        require (COUNTER <= SPOTS_RESERVED);\r\n        owner.transfer(msg.value);\r\n        addMasternode(msg.sender);\r\n    }\r\n\r\n}\r\n\r\ncontract CaelumAcceptERC20 is Ownable, CaelumVotings, abstractCaelum { \r\n    using SafeMath for uint;\r\n\r\n    address[] public tokensList;\r\n    bool setOwnContract = true;\r\n\r\n    struct _whitelistTokens {\r\n        address tokenAddress;\r\n        bool active;\r\n        uint requiredAmount;\r\n        uint validUntil;\r\n        uint timestamp;\r\n    }\r\n\r\n    mapping(address => mapping(address => uint)) public tokens;\r\n    mapping(address => _whitelistTokens) acceptedTokens;\r\n\r\n    event Deposit(address token, address user, uint amount, uint balance);\r\n    event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n    /**\r\n     * @dev Return the base rewards. This should be overrided by the miner contract.\r\n     * Return a base value for standalone usage ONLY.\r\n     */\r\n    function getMiningReward() public view returns(uint) {\r\n        return 50 * 1e8;\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Allow the dev to set it's own token as accepted payment.\r\n     * @dev Can be hardcoded in the constructor. Given the contract size, we decided to separate it.\r\n     * @return bool\r\n     */\r\n    function addOwnToken() onlyOwner public returns (bool) {\r\n        require(setOwnContract);\r\n        addToWhitelist(this, 5000 * 1e8, 36500);\r\n        setOwnContract = false;\r\n        return true;\r\n    }\r\n\r\n    // TODO: Set visibility\r\n    /**\r\n     * @notice Add a new token as accepted payment method.\r\n     * @param _token Token contract address.\r\n     * @param _amount Required amount of this Token as collateral\r\n     * @param daysAllowed How many days will we accept this token?\r\n     */\r\n    function addToWhitelist(address _token, uint _amount, uint daysAllowed) internal {\r\n        _whitelistTokens storage newToken = acceptedTokens[_token];\r\n        newToken.tokenAddress = _token;\r\n        newToken.requiredAmount = _amount;\r\n        newToken.timestamp = now;\r\n        newToken.validUntil = now + (daysAllowed * 1 days);\r\n        newToken.active = true;\r\n\r\n        tokensList.push(_token);\r\n    }\r\n\r\n    /**\r\n     * @dev internal function to determine if we accept this token.\r\n     * @param _ad Token contract address\r\n     * @return bool\r\n     */\r\n    function isAcceptedToken(address _ad) internal view returns(bool) {\r\n        return acceptedTokens[_ad].active;\r\n    }\r\n\r\n    /**\r\n     * @dev internal function to determine the requiredAmount for a specific token.\r\n     * @param _ad Token contract address\r\n     * @return bool\r\n     */\r\n    function getAcceptedTokenAmount(address _ad) internal view returns(uint) {\r\n        return acceptedTokens[_ad].requiredAmount;\r\n    }\r\n\r\n    /**\r\n     * @dev internal function to determine if the token is still accepted timewise.\r\n     * @param _ad Token contract address\r\n     * @return bool\r\n     */\r\n    function isValid(address _ad) internal view returns(bool) {\r\n        uint endTime = acceptedTokens[_ad].validUntil;\r\n        if (block.timestamp < endTime) return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns an array of all accepted token. You can get more details by calling getTokenDetails function with this address.\r\n     * @return array Address\r\n     */\r\n    function listAcceptedTokens() public view returns(address[]) {\r\n        return tokensList;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns a full list of the token details\r\n     * @param token Token contract address\r\n     */\r\n    function getTokenDetails(address token) public view returns(address ad,uint required, bool active, uint valid) {\r\n        return (acceptedTokens[token].tokenAddress, acceptedTokens[token].requiredAmount,acceptedTokens[token].active, acceptedTokens[token].validUntil);\r\n    }\r\n\r\n    /**\r\n     * @notice Public function that allows any user to deposit accepted tokens as collateral to become a masternode.\r\n     * @param token Token contract address\r\n     * @param amount Amount to deposit\r\n     */\r\n    function depositCollateral(address token, uint amount) public {\r\n        require(isAcceptedToken(token), \"ERC20 not authorised\");  // Should be a token from our list\r\n        require(amount == getAcceptedTokenAmount(token));         // The amount needs to match our set amount\r\n        require(isValid(token));                                  // It should be called within the setup timeframe\r\n\r\n        tokens[token][msg.sender] = tokens[token][msg.sender].add(amount);\r\n\r\n        require(StandardToken(token).transferFrom(msg.sender, this, amount), \"error with token\");\r\n        emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]);\r\n\r\n        addMasternode(msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @notice Public function that allows any user to withdraw deposited tokens and stop as masternode\r\n     * @param token Token contract address\r\n     * @param amount Amount to withdraw\r\n     */\r\n    function withdrawCollateral(address token, uint amount) public {\r\n        require(token != 0); // token should be an actual address\r\n        require(isAcceptedToken(token), \"ERC20 not authorised\"); // Should be a token from our list\r\n        require(isMasternodeOwner(msg.sender)); // The sender must be a masternode prior to withdraw\r\n        require(tokens[token][msg.sender] == amount); // The amount must be exactly whatever is deposited\r\n\r\n        uint amountToWithdraw = tokens[token][msg.sender];\r\n        tokens[token][msg.sender] = 0;\r\n\r\n        deleteMasternode(getLastPerUser(msg.sender));\r\n\r\n        if (!StandardToken(token).transfer(msg.sender, amountToWithdraw)) revert();\r\n        emit Withdraw(token, msg.sender, amountToWithdraw, amountToWithdraw);\r\n    }\r\n\r\n}\r\n\r\ncontract CaelumMasternode is CaelumFundraise, CaelumAcceptERC20{\r\n    using SafeMath for uint;\r\n\r\n    bool onTestnet = false;\r\n    bool genesisAdded = false;\r\n\r\n    uint  masternodeRound;\r\n    uint  masternodeCandidate;\r\n    uint  masternodeCounter;\r\n    uint  masternodeEpoch;\r\n    uint  miningEpoch;\r\n\r\n    uint rewardsProofOfWork;\r\n    uint rewardsMasternode;\r\n    uint rewardsGlobal = 50 * 1e8;\r\n\r\n    uint MINING_PHASE_DURATION_BLOCKS = 4500;\r\n\r\n    struct MasterNode {\r\n        address accountOwner;\r\n        bool isActive;\r\n        bool isTeamMember;\r\n        uint storedIndex;\r\n        uint startingRound;\r\n        uint[] indexcounter;\r\n    }\r\n\r\n    uint[] userArray;\r\n    address[] userAddressArray;\r\n\r\n    mapping(uint => MasterNode) userByIndex; // UINT masterMapping\r\n    mapping(address => MasterNode) userByAddress; //masterMapping\r\n    mapping(address => uint) userAddressIndex;\r\n\r\n    event Deposit(address token, address user, uint amount, uint balance);\r\n    event Withdraw(address token, address user, uint amount, uint balance);\r\n\r\n    event NewMasternode(address candidateAddress, uint timeStamp);\r\n    event RemovedMasternode(address candidateAddress, uint timeStamp);\r\n\r\n    /**\r\n     * @dev Add the genesis accounts\r\n     */\r\n    function addGenesis(address _genesis, bool _team) onlyOwner public {\r\n        require(!genesisAdded);\r\n\r\n        addMasternode(_genesis);\r\n\r\n        if (_team) {\r\n            updateMasternodeAsTeamMember(msg.sender);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Close the genesis accounts\r\n     */\r\n    function closeGenesis() onlyOwner public {\r\n        genesisAdded = true; // Forever lock this.\r\n    }\r\n\r\n    /**\r\n     * @dev Add a user as masternode. Called as internal since we only add masternodes by depositing collateral or by voting.\r\n     * @param _candidate Candidate address\r\n     * @return uint Masternode index\r\n     */\r\n    function addMasternode(address _candidate) internal returns(uint) {\r\n        userByIndex[masternodeCounter].accountOwner = _candidate;\r\n        userByIndex[masternodeCounter].isActive = true;\r\n        userByIndex[masternodeCounter].startingRound = masternodeRound + 1;\r\n        userByIndex[masternodeCounter].storedIndex = masternodeCounter;\r\n\r\n        userByAddress[_candidate].accountOwner = _candidate;\r\n        userByAddress[_candidate].indexcounter.push(masternodeCounter);\r\n\r\n        userArray.push(userArray.length);\r\n        masternodeCounter++;\r\n\r\n        emit NewMasternode(_candidate, now);\r\n        return masternodeCounter - 1; //\r\n    }\r\n\r\n    /**\r\n     * @dev Allow us to update a masternode's round to keep progress\r\n     * @param _candidate ID of masternode\r\n     */\r\n    function updateMasternode(uint _candidate) internal returns(bool) {\r\n        userByIndex[_candidate].startingRound++;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow us to update a masternode to team member status\r\n     * @param _member address\r\n     */\r\n    function updateMasternodeAsTeamMember(address _member) internal returns (bool) {\r\n        userByAddress[_member].isTeamMember = true;\r\n        return (true);\r\n    }\r\n\r\n    /**\r\n     * @dev Let us know if an address is part of the team.\r\n     * @param _member address\r\n     */\r\n    function isTeamMember (address _member) public view returns (bool) {\r\n        if (userByAddress[_member].isTeamMember)\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a specific masternode\r\n     * @param _masternodeID ID of the masternode to remove\r\n     */\r\n    function deleteMasternode(uint _masternodeID) internal returns(bool success) {\r\n\r\n        uint rowToDelete = userByIndex[_masternodeID].storedIndex;\r\n        uint keyToMove = userArray[userArray.length - 1];\r\n\r\n        userByIndex[_masternodeID].isActive = userByIndex[_masternodeID].isActive = (false);\r\n        userArray[rowToDelete] = keyToMove;\r\n        userByIndex[keyToMove].storedIndex = rowToDelete;\r\n        userArray.length = userArray.length - 1;\r\n\r\n        removeFromUserCounter(_masternodeID);\r\n\r\n        emit RemovedMasternode(userByIndex[_masternodeID].accountOwner, now);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev returns what account belongs to a masternode\r\n     */\r\n    function isPartOf(uint mnid) public view returns (address) {\r\n        return userByIndex[mnid].accountOwner;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to remove a masternode from a user address if this address holds multpile masternodes\r\n     * @param index MasternodeID\r\n     */\r\n    function removeFromUserCounter(uint index)  internal returns(uint[]) {\r\n        address belong = isPartOf(index);\r\n\r\n        if (index >= userByAddress[belong].indexcounter.length) return;\r\n\r\n        for (uint i = index; i<userByAddress[belong].indexcounter.length-1; i++){\r\n            userByAddress[belong].indexcounter[i] = userByAddress[belong].indexcounter[i+1];\r\n        }\r\n\r\n        delete userByAddress[belong].indexcounter[userByAddress[belong].indexcounter.length-1];\r\n        userByAddress[belong].indexcounter.length--;\r\n        return userByAddress[belong].indexcounter;\r\n    }\r\n\r\n    /**\r\n     * @dev Primary contract function to update the current user and prepare the next one.\r\n     * A number of steps have been token to ensure the contract can never run out of gas when looping over our masternodes.\r\n     */\r\n    function setMasternodeCandidate() internal returns(address) {\r\n\r\n        uint hardlimitCounter = 0;\r\n\r\n        while (getFollowingCandidate() == 0x0) {\r\n            // We must return a value not to break the contract. Require is a secondary killswitch now.\r\n            require(hardlimitCounter < 6, \"Failsafe switched on\");\r\n            // Choose if loop over revert/require to terminate the loop and return a 0 address.\r\n            if (hardlimitCounter == 5) return (0);\r\n            masternodeRound = masternodeRound + 1;\r\n            masternodeCandidate = 0;\r\n            hardlimitCounter++;\r\n        }\r\n\r\n        if (masternodeCandidate == masternodeCounter - 1) {\r\n            masternodeRound = masternodeRound + 1;\r\n            masternodeCandidate = 0;\r\n        }\r\n\r\n        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\r\n            if (userByIndex[i].isActive) {\r\n                if (userByIndex[i].startingRound == masternodeRound) {\r\n                    updateMasternode(i);\r\n                    masternodeCandidate = i;\r\n                    return (userByIndex[i].accountOwner);\r\n                }\r\n            }\r\n        }\r\n\r\n        masternodeRound = masternodeRound + 1;\r\n        return (0);\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to loop through our masternodes at start and return the correct round\r\n     */\r\n    function getFollowingCandidate() internal view returns(address _address) {\r\n        uint tmpRound = masternodeRound;\r\n        uint tmpCandidate = masternodeCandidate;\r\n\r\n        if (tmpCandidate == masternodeCounter - 1) {\r\n            tmpRound = tmpRound + 1;\r\n            tmpCandidate = 0;\r\n        }\r\n\r\n        for (uint i = masternodeCandidate; i < masternodeCounter; i++) {\r\n            if (userByIndex[i].isActive) {\r\n                if (userByIndex[i].startingRound == tmpRound) {\r\n                    tmpCandidate = i;\r\n                    return (userByIndex[i].accountOwner);\r\n                }\r\n            }\r\n        }\r\n\r\n        tmpRound = tmpRound + 1;\r\n        return (0);\r\n    }\r\n\r\n    /**\r\n     * @dev Displays all masternodes belonging to a user address.\r\n     */\r\n    function belongsToUser(address userAddress) public view returns(uint[]) {\r\n        return (userByAddress[userAddress].indexcounter);\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to know if an address owns masternodes\r\n     */\r\n    function isMasternodeOwner(address _candidate) public view returns(bool) {\r\n        if(userByAddress[_candidate].indexcounter.length <= 0) return false;\r\n        if (userByAddress[_candidate].accountOwner == _candidate)\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Helper function to get the last masternode belonging to a user\r\n     */\r\n    function getLastPerUser(address _candidate) public view returns (uint) {\r\n        return userByAddress[_candidate].indexcounter[userByAddress[_candidate].indexcounter.length - 1];\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Calculate and set the reward schema for Caelum.\r\n     * Each mining phase is decided by multiplying the MINING_PHASE_DURATION_BLOCKS with factor 10.\r\n     * Depending on the outcome (solidity always rounds), we can detect the current stage of mining.\r\n     * First stage we cut the rewards to 5% to prevent instamining.\r\n     * Last stage we leave 2% for miners to incentivize keeping miners running.\r\n     */\r\n    function calculateRewardStructures() internal {\r\n        //ToDo: Set\r\n        uint _global_reward_amount = getMiningReward();\r\n        uint getStageOfMining = miningEpoch / MINING_PHASE_DURATION_BLOCKS * 10;\r\n\r\n        if (getStageOfMining < 10) {\r\n            rewardsProofOfWork = _global_reward_amount / 100 * 5;\r\n            rewardsMasternode = 0;\r\n            return;\r\n        }\r\n\r\n        if (getStageOfMining > 90) {\r\n            rewardsProofOfWork = _global_reward_amount / 100 * 2;\r\n            rewardsMasternode = _global_reward_amount / 100 * 98;\r\n            return;\r\n        }\r\n\r\n        uint _mnreward = (_global_reward_amount / 100) * getStageOfMining;\r\n        uint _powreward = (_global_reward_amount - _mnreward);\r\n\r\n        setBaseRewards(_powreward, _mnreward);\r\n    }\r\n\r\n    function setBaseRewards(uint _pow, uint _mn) internal {\r\n        rewardsMasternode = _mn;\r\n        rewardsProofOfWork = _pow;\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the masternode flow. Should be called after mining a block.\r\n     */\r\n    function _arrangeMasternodeFlow() internal {\r\n        calculateRewardStructures();\r\n        setMasternodeCandidate();\r\n        miningEpoch++;\r\n    }\r\n\r\n    /**\r\n     * @dev Executes the masternode flow. Should be called after mining a block.\r\n     * This is an emergency manual loop method.\r\n     */\r\n    function _emergencyLoop() onlyOwner public {\r\n        calculateRewardStructures();\r\n        setMasternodeCandidate();\r\n        miningEpoch++;\r\n    }\r\n\r\n    function masternodeInfo(uint index) public view returns\r\n    (\r\n        address,\r\n        bool,\r\n        uint,\r\n        uint\r\n    )\r\n    {\r\n        return (\r\n            userByIndex[index].accountOwner,\r\n            userByIndex[index].isActive,\r\n            userByIndex[index].storedIndex,\r\n            userByIndex[index].startingRound\r\n        );\r\n    }\r\n\r\n    function contractProgress() public view returns\r\n    (\r\n        uint epoch,\r\n        uint candidate,\r\n        uint round,\r\n        uint miningepoch,\r\n        uint globalreward,\r\n        uint powreward,\r\n        uint masternodereward,\r\n        uint usercounter\r\n    )\r\n    {\r\n        return (\r\n            masternodeEpoch,\r\n            masternodeCandidate,\r\n            masternodeRound,\r\n            miningEpoch,\r\n            getMiningReward(),\r\n            rewardsProofOfWork,\r\n            rewardsMasternode,\r\n            masternodeCounter\r\n        );\r\n    }\r\n\r\n}\r\n\r\ncontract CaelumMiner is StandardToken, CaelumMasternode {\r\n    using SafeMath for uint;\r\n    using ExtendedMath for uint;\r\n\r\n    string public symbol = \"CLM\";\r\n    string public name = \"Caelum Token\";\r\n    uint8 public decimals = 8;\r\n    uint256 public totalSupply = 2100000000000000;\r\n\r\n    uint public latestDifficultyPeriodStarted;\r\n    uint public epochCount;\r\n    uint public baseMiningReward = 50;\r\n    uint public blocksPerReadjustment = 512;\r\n    uint public _MINIMUM_TARGET = 2 ** 16;\r\n    uint public _MAXIMUM_TARGET = 2 ** 234;\r\n    uint public rewardEra = 0;\r\n\r\n    uint public maxSupplyForEra;\r\n    uint public MAX_REWARD_ERA = 39;\r\n    uint public MINING_RATE_FACTOR = 60; //mint the token 60 times less often than ether\r\n    //difficulty adjustment parameters- be careful modifying these\r\n    uint public MAX_ADJUSTMENT_PERCENT = 100;\r\n    uint public TARGET_DIVISOR = 2000;\r\n    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);\r\n    mapping(bytes32 => bytes32) solutionForChallenge;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    bytes32 public challengeNumber;\r\n    uint public difficulty;\r\n    uint public tokensMinted;\r\n\r\n\r\n    struct Statistics {\r\n        address lastRewardTo;\r\n        uint lastRewardAmount;\r\n        uint lastRewardEthBlockNumber;\r\n        uint lastRewardTimestamp;\r\n    }\r\n\r\n    Statistics public statistics;\r\n    \r\n    event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\r\n    event RewardMasternode(address candidate, uint amount);\r\n\r\n    constructor() public {\r\n        tokensMinted = 0;\r\n        maxSupplyForEra = totalSupply.div(2);\r\n        difficulty = _MAXIMUM_TARGET;\r\n        latestDifficultyPeriodStarted = block.number;\r\n        _newEpoch(0);\r\n\r\n        balances[msg.sender] = balances[msg.sender].add(420000 * 1e8); // 2% Premine as determined by the community meeting.\r\n        emit Transfer(this, msg.sender, 420000 * 1e8);\r\n    }\r\n\r\n    function mint(uint256 nonce, bytes32 challenge_digest) public returns(bool success) {\r\n        // perform the hash function validation\r\n        _hash(nonce, challenge_digest);\r\n\r\n        _arrangeMasternodeFlow();\r\n\r\n        uint rewardAmount = _reward();\r\n        uint rewardMasternode = _reward_masternode();\r\n\r\n        tokensMinted += rewardAmount.add(rewardMasternode);\r\n\r\n        uint epochCounter = _newEpoch(nonce);\r\n\r\n        _adjustDifficulty();\r\n\r\n        statistics = Statistics(msg.sender, rewardAmount, block.number, now);\r\n\r\n        emit Mint(msg.sender, rewardAmount, epochCounter, challengeNumber);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _newEpoch(uint256 nonce) internal returns(uint) {\r\n\r\n        if (tokensMinted.add(getMiningReward()) > maxSupplyForEra && rewardEra < MAX_REWARD_ERA) {\r\n            rewardEra = rewardEra + 1;\r\n        }\r\n        maxSupplyForEra = totalSupply - totalSupply.div(2 ** (rewardEra + 1));\r\n        epochCount = epochCount.add(1);\r\n        challengeNumber = blockhash(block.number - 1);\r\n        return (epochCount);\r\n    }\r\n\r\n    function _hash(uint256 nonce, bytes32 challenge_digest) internal returns(bytes32 digest) {\r\n        digest = keccak256(challengeNumber, msg.sender, nonce);\r\n        if (digest != challenge_digest) revert();\r\n        if (uint256(digest) > difficulty) revert();\r\n        bytes32 solution = solutionForChallenge[challengeNumber];\r\n        solutionForChallenge[challengeNumber] = digest;\r\n        if (solution != 0x0) revert(); //prevent the same answer from awarding twice\r\n    }\r\n\r\n    function _reward() internal returns(uint) {\r\n\r\n        uint _pow = rewardsProofOfWork;\r\n\r\n        balances[msg.sender] = balances[msg.sender].add(_pow);\r\n        emit Transfer(this, msg.sender, _pow);\r\n\r\n        return _pow;\r\n    }\r\n\r\n    function _reward_masternode() internal returns(uint) {\r\n\r\n        uint _mnReward = rewardsMasternode;\r\n        if (masternodeCounter == 0) return 0;\r\n\r\n        address _mnCandidate = userByIndex[masternodeCandidate].accountOwner;\r\n        if (_mnCandidate == 0x0) return 0;\r\n\r\n        balances[_mnCandidate] = balances[_mnCandidate].add(_mnReward);\r\n        emit Transfer(this, _mnCandidate, _mnReward);\r\n\r\n        emit RewardMasternode(_mnCandidate, _mnReward);\r\n\r\n        return _mnReward;\r\n    }\r\n\r\n\r\n    //DO NOT manually edit this method unless you know EXACTLY what you are doing\r\n    function _adjustDifficulty() internal returns(uint) {\r\n        //every so often, readjust difficulty. Dont readjust when deploying\r\n        if (epochCount % blocksPerReadjustment != 0) {\r\n            return difficulty;\r\n        }\r\n\r\n        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\r\n        //assume 360 ethereum blocks per hour\r\n        //we want miners to spend 10 minutes to mine each 'block', about 60 ethereum blocks = one 0xbitcoin epoch\r\n        uint epochsMined = blocksPerReadjustment;\r\n        uint targetEthBlocksPerDiffPeriod = epochsMined * MINING_RATE_FACTOR;\r\n        //if there were less eth blocks passed in time than expected\r\n        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {\r\n            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(ethBlocksSinceLastDifficultyPeriod);\r\n            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT);\r\n            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\r\n            //make it harder\r\n            difficulty = difficulty.sub(difficulty.div(TARGET_DIVISOR).mul(excess_block_pct_extra)); //by up to 50 %\r\n        } else {\r\n            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(targetEthBlocksPerDiffPeriod);\r\n            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT); //always between 0 and 1000\r\n            //make it easier\r\n            difficulty = difficulty.add(difficulty.div(TARGET_DIVISOR).mul(shortage_block_pct_extra)); //by up to 50 %\r\n        }\r\n        latestDifficultyPeriodStarted = block.number;\r\n        if (difficulty < _MINIMUM_TARGET) //very difficult\r\n        {\r\n            difficulty = _MINIMUM_TARGET;\r\n        }\r\n        if (difficulty > _MAXIMUM_TARGET) //very easy\r\n        {\r\n            difficulty = _MAXIMUM_TARGET;\r\n        }\r\n    }\r\n    //this is a recent ethereum block hash, used to prevent pre-mining future blocks\r\n    function getChallengeNumber() public view returns(bytes32) {\r\n        return challengeNumber;\r\n    }\r\n    //the number of zeroes the digest of the PoW solution requires.  Auto adjusts\r\n    function getMiningDifficulty() public view returns(uint) {\r\n        return _MAXIMUM_TARGET.div(difficulty);\r\n    }\r\n\r\n    function getMiningTarget() public view returns(uint) {\r\n        return difficulty;\r\n    }\r\n\r\n    function getMiningReward() public view returns(uint) {\r\n        return (baseMiningReward * 1e8).div(2 ** rewardEra);\r\n    }\r\n\r\n    //help debug mining software\r\n    function getMintDigest(\r\n        uint256 nonce,\r\n        bytes32 challenge_digest,\r\n        bytes32 challenge_number\r\n    )\r\n    public view returns(bytes32 digesttest) {\r\n        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\r\n        return digest;\r\n    }\r\n    //help debug mining software\r\n    function checkMintSolution(\r\n        uint256 nonce,\r\n        bytes32 challenge_digest,\r\n        bytes32 challenge_number,\r\n        uint testTarget\r\n    )\r\n    public view returns(bool success) {\r\n        bytes32 digest = keccak256(challenge_number, msg.sender, nonce);\r\n        if (uint256(digest) > testTarget) revert();\r\n        return (digest == challenge_digest);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TARGET_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalCounter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"discardRejectedProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"mnid\",\"type\":\"uint256\"}],\"name\":\"isPartOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"_emergencyLoop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyMasternode\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"difficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ADJUSTMENT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"voterMap\",\"outputs\":[{\"name\":\"isVoter\",\"type\":\"bool\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardEra\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINING_RATE_FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_genesis\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"bool\"}],\"name\":\"addGenesis\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"voterProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_REWARD_ERA\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addOwnToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokensList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChallengeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxSupplyForEra\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseMiningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeGenesis\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"getTokenProposalDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"becomeVoter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractProgress\",\"outputs\":[{\"name\":\"epoch\",\"type\":\"uint256\"},{\"name\":\"candidate\",\"type\":\"uint256\"},{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"miningepoch\",\"type\":\"uint256\"},{\"name\":\"globalreward\",\"type\":\"uint256\"},{\"name\":\"powreward\",\"type\":\"uint256\"},{\"name\":\"masternodereward\",\"type\":\"uint256\"},{\"name\":\"usercounter\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"voteProposal\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"name\":\"challenge_number\",\"type\":\"bytes32\"},{\"name\":\"testTarget\",\"type\":\"uint256\"}],\"name\":\"checkMintSolution\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_MAXIMUM_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listAcceptedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"getTokenDetails\",\"outputs\":[{\"name\":\"ad\",\"type\":\"address\"},{\"name\":\"required\",\"type\":\"uint256\"},{\"name\":\"active\",\"type\":\"bool\"},{\"name\":\"valid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"pushProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"reachedMajorityForTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"statistics\",\"outputs\":[{\"name\":\"lastRewardTo\",\"type\":\"address\"},{\"name\":\"lastRewardAmount\",\"type\":\"uint256\"},{\"name\":\"lastRewardEthBlockNumber\",\"type\":\"uint256\"},{\"name\":\"lastRewardTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proposalID\",\"type\":\"uint256\"}],\"name\":\"reachedMajority\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challenge_digest\",\"type\":\"bytes32\"},{\"name\":\"challenge_number\",\"type\":\"bytes32\"}],\"name\":\"getMintDigest\",\"outputs\":[{\"name\":\"digesttest\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pastProposalTimeRules\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"isMasternodeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"depositCollateral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_candidate\",\"type\":\"address\"}],\"name\":\"getLastPerUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUOTIENT_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_member\",\"type\":\"address\"}],\"name\":\"isTeamMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"belongsToUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proposalPending\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposalList\",\"outputs\":[{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"totalVotes\",\"type\":\"uint256\"},{\"name\":\"proposedOn\",\"type\":\"uint256\"},{\"name\":\"acceptedOn\",\"type\":\"uint256\"},{\"name\":\"proposalType\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestDifficultyPeriodStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LastProposalCanDiscard\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksPerReadjustment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_MINIMUM_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"masternodeInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"votersCountTeam\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newChallengeNumber\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"candidate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RewardMasternode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"candidateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"NewMasternode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"candidateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"RemovedMasternode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ProposalID\",\"type\":\"uint256\"}],\"name\":\"NewProposal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ProposalID\",\"type\":\"uint256\"}],\"name\":\"ProposalAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CaelumMiner","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2af7da4b6ff170da0b8322f123449c1a370434d9493db63c8bfed116faefe3c1"}]}