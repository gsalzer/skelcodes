{"status":"1","message":"OK","result":[{"SourceCode":"/*************************************************\r\n*                                                *\r\n*   AirDrop Dapp                                 *\r\n*   Developed by Phenom.Team \"www.phenom.team\"   *\r\n*                                                *\r\n*************************************************/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    \r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = tx.origin;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20\r\n * @dev Standard of ERC20.\r\n */\r\ncontract ERC20 is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  uint public totalSupply;\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n  bool public transferable;\r\n\r\n  mapping(address => uint) balances;\r\n  mapping(address => mapping (address => uint)) allowed;\r\n\r\n  /**\r\n  *   @dev Get balance of tokens holder\r\n  *   @param _holder        holder's address\r\n  *   @return               balance of investor\r\n  */\r\n  function balanceOf(address _holder) public view returns (uint) {\r\n       return balances[_holder];\r\n  }\r\n\r\n /**\r\n  *   @dev Send coins\r\n  *   throws on any error rather then return a false flag to minimize\r\n  *   user errors\r\n  *   @param _to           target address\r\n  *   @param _amount       transfer amount\r\n  *\r\n  *   @return true if the transfer was successful \r\n  */\r\n  function transfer(address _to, uint _amount) public returns (bool) {\r\n      require(_to != address(0) && _to != address(this));\r\n      if (!transferable) {\r\n        require(msg.sender == owner);\r\n      }\r\n      balances[msg.sender] = balances[msg.sender].sub(_amount);  \r\n      balances[_to] = balances[_to].add(_amount);\r\n      emit Transfer(msg.sender, _to, _amount);\r\n      return true;\r\n  }\r\n\r\n /**\r\n  *   @dev An account/contract attempts to get the coins\r\n  *   throws on any error rather then return a false flag to minimize user errors\r\n  *\r\n  *   @param _from         source address\r\n  *   @param _to           target address\r\n  *   @param _amount       transfer amount\r\n  *\r\n  *   @return true if the transfer was successful\r\n  */\r\n  function transferFrom(address _from, address _to, uint _amount) public returns (bool) {\r\n      require(_to != address(0) && _to != address(this));\r\n      balances[_from] = balances[_from].sub(_amount);\r\n      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n      balances[_to] = balances[_to].add(_amount);\r\n      emit Transfer(_from, _to, _amount);\r\n      return true;\r\n   }\r\n\r\n /**\r\n  *   @dev Allows another account/contract to spend some tokens on its behalf\r\n  *   throws on any error rather then return a false flag to minimize user errors\r\n  *\r\n  *   also, to minimize the risk of the approve/transferFrom attack vector\r\n  *   approve has to be called twice in 2 separate transactions - once to\r\n  *   change the allowance to 0 and secondly to change it to the new allowance\r\n  *   value\r\n  *\r\n  *   @param _spender      approved address\r\n  *   @param _amount       allowance amount\r\n  *\r\n  *   @return true if the approval was successful\r\n  */\r\n  function approve(address _spender, uint _amount) public returns (bool) {\r\n      require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n      allowed[msg.sender][_spender] = _amount;\r\n      emit Approval(msg.sender, _spender, _amount);\r\n      return true;\r\n  }\r\n\r\n /**\r\n  *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n  *\r\n  *   @param _owner        the address which owns the funds\r\n  *   @param _spender      the address which will spend the funds\r\n  *\r\n  *   @return              the amount of tokens still avaible for the spender\r\n  */\r\n  function allowance(address _owner, address _spender) public view returns (uint) {\r\n      return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n  *   @dev Function make token transferable.\r\n  *\r\n  *   @return the status of issue\r\n  */\r\n  function unfreeze() public onlyOwner {\r\n      transferable = true;\r\n      emit Unfreezed(now);\r\n  }\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n  event Unfreezed(uint indexed _timestamp);\r\n}\r\n\r\n/**\r\n * @title StandardToken\r\n * @dev Token without the ability to release new ones.\r\n */\r\ncontract StandardToken is ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  /**\r\n  * @dev The Standard token constructor determines the total supply of tokens.\r\n  */\r\n  constructor(string _name, string _symbol, uint8 _decimals, uint _totalSupply, bool _transferable) public {   \r\n      name = _name;\r\n      symbol = _symbol;\r\n      decimals = _decimals;\r\n      totalSupply = _totalSupply;\r\n      balances[tx.origin] = _totalSupply;\r\n      transferable = _transferable;\r\n      emit Transfer(address(0), tx.origin, _totalSupply);\r\n  }\r\n\r\n  /**\r\n  * @dev Sends the tokens to a list of addresses.\r\n  */\r\n  function airdrop(address[] _addresses, uint256[] _values) public onlyOwner returns (bool) {\r\n      require(_addresses.length == _values.length);\r\n      for (uint256 i = 0; i < _addresses.length; i++) {\r\n          require(transfer(_addresses[i], _values[i]));\r\n      }        \r\n      return true;\r\n  }\r\n}\r\n\r\n/**\r\n * @title MintableToken\r\n * @dev Token with the ability to release new ones.\r\n */\r\ncontract MintableToken is Ownable, ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  bool public mintingFinished = false;\r\n\r\n /**\r\n  * @dev The Standard token constructor determines the total supply of tokens.\r\n  */\r\n  constructor(string _name, string _symbol, uint8 _decimals, bool _transferable) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n    transferable = _transferable;\r\n  }\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n /**\r\n  *   @dev Function to mint tokens\r\n  *   @param _holder       beneficiary address the tokens will be issued to\r\n  *   @param _value        number of tokens to issue\r\n  */\r\n  function mintTokens(address _holder, uint _value) public canMint onlyOwner returns (bool) {\r\n     require(_value > 0);\r\n     require(_holder != address(0));\r\n     balances[_holder] = balances[_holder].add(_value);\r\n     totalSupply = totalSupply.add(_value);\r\n     emit Transfer(address(0), _holder, _value);\r\n     return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Sends the tokens to a list of addresses.\r\n  */\r\n  function airdrop(address[] _addresses, uint256[] _values) public onlyOwner returns (bool) {\r\n      require(_addresses.length == _values.length);\r\n      for (uint256 i = 0; i < _addresses.length; i++) {\r\n          require(mintTokens(_addresses[i], _values[i]));\r\n      }\r\n      return true;\r\n  }\r\n \r\n  /**\r\n  *   @dev Function finishes minting tokens.\r\n  *\r\n  *   @return the status of issue\r\n  */\r\n  function finishMinting() public onlyOwner {\r\n      mintingFinished = true;\r\n      emit MintFinished(now);\r\n  }\r\n\r\n  event MintFinished(uint indexed _timestamp);\r\n}\r\n\r\n/**\r\n * @title TokenCreator\r\n * @dev Create new token ERC20.\r\n */\r\ncontract TokenCreator {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => address[]) public mintableTokens;\r\n  mapping(address => address[]) public standardTokens;\r\n  mapping(address => uint256) public amountMintTokens;\r\n  mapping(address => uint256) public amountStandTokens;\r\n  \r\n  /**\r\n  *   @dev Function create standard token.\r\n  *\r\n  *   @return the address of new token.\r\n  */\r\n  function createStandardToken(string _name, string _symbol, uint8 _decimals, uint _totalSupply, bool _transferable) public returns (address) {\r\n    address token = new StandardToken(_name, _symbol, _decimals, _totalSupply, _transferable);\r\n    standardTokens[msg.sender].push(token);\r\n    amountStandTokens[msg.sender]++;\r\n    emit TokenCreated(msg.sender, token);\r\n    return token;\r\n  }\r\n\r\n  /**\r\n  *   @dev Function create mintable token.\r\n  *\r\n  *   @return the address of new token.\r\n  */\r\n  function createMintableToken(string _name, string _symbol, uint8 _decimals, bool _transferable) public returns (address) {\r\n    address token = new MintableToken(_name, _symbol, _decimals, _transferable);\r\n    mintableTokens[msg.sender].push(token);\r\n    amountMintTokens[msg.sender]++;\r\n    emit TokenCreated(msg.sender, token);\r\n    return token;\r\n  }\r\n\r\n  event TokenCreated(address indexed _creator, address indexed _token);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountStandTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mintableTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"amountMintTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"standardTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_transferable\",\"type\":\"bool\"}],\"name\":\"createStandardToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_transferable\",\"type\":\"bool\"}],\"name\":\"createMintableToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"TokenCreated\",\"type\":\"event\"}]","ContractName":"TokenCreator","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://08e14e98ab8394bee54b2129ddcc528339a9a8a5cb395a35fe42d9f43b9de39a"}]}