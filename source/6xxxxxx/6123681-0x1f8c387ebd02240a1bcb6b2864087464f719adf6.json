{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// (c) 2018 SecureVote (Exo One Pty Ltd)\r\n\r\ncontract BBFarmEvents {\r\n    event BallotCreatedWithID(uint ballotId);\r\n    event BBFarmInit(bytes4 namespace);\r\n    event Sponsorship(uint ballotId, uint value);\r\n    event Vote(uint indexed ballotId, bytes32 vote, address voter, bytes extra);\r\n    event BallotOnForeignNetwork(bytes32 networkId, uint ballotId);  // added 2018-06-25 for BBFarmForeign support\r\n}\r\n\r\nlibrary BBLibV7 {\r\n    using BytesLib for bytes;\r\n\r\n    // ballot meta\r\n    uint256 constant BB_VERSION = 7;\r\n    /* 4 deprecated due to insecure vote by proxy\r\n       5 deprecated to\r\n        - add `returns (address)` to submitProxyVote\r\n       7 - adds submitVoteAlways (does not check open/close time)\r\n           useful for remote bbfarms\r\n    */\r\n\r\n    // voting settings\r\n    uint16 constant USE_ETH = 1;          // 2^0\r\n    uint16 constant USE_SIGNED = 2;       // 2^1\r\n    uint16 constant USE_NO_ENC = 4;       // 2^2\r\n    uint16 constant USE_ENC = 8;          // 2^3\r\n\r\n    // ballot settings\r\n    uint16 constant IS_BINDING = 8192;    // 2^13\r\n    uint16 constant IS_OFFICIAL = 16384;  // 2^14\r\n    uint16 constant USE_TESTING = 32768;  // 2^15\r\n\r\n    // other consts\r\n    uint32 constant MAX_UINT32 = 0xFFFFFFFF;\r\n\r\n    //// ** Storage Variables\r\n\r\n    // struct for ballot\r\n    struct Vote {\r\n        bytes32 voteData;\r\n        bytes32 castTsAndSender;\r\n        bytes extra;\r\n    }\r\n\r\n    struct Sponsor {\r\n        address sender;\r\n        uint amount;\r\n    }\r\n\r\n    //// ** Events\r\n    event CreatedBallot(bytes32 _specHash, uint64 startTs, uint64 endTs, uint16 submissionBits);\r\n    event SuccessfulVote(address indexed voter, uint voteId);\r\n    event SeckeyRevealed(bytes32 secretKey);\r\n    event TestingEnabled();\r\n    event DeprecatedContract();\r\n\r\n\r\n    // The big database struct\r\n\r\n\r\n    struct DB {\r\n        // Maps to store ballots, along with corresponding log of voters.\r\n        // Should only be modified through internal functions\r\n        mapping (uint256 => Vote) votes;\r\n        uint256 nVotesCast;\r\n\r\n        // we need replay protection for proxy ballots - this will let us check against a sequence number\r\n        // note: votes directly from a user ALWAYS take priority b/c they do not have sequence numbers\r\n        // (sequencing is done by Ethereum itself via the tx nonce).\r\n        mapping (address => uint32) sequenceNumber;\r\n\r\n        // NOTE - We don't actually want to include the encryption PublicKey because _it's included in the ballotSpec_.\r\n        // It's better to ensure ppl actually have the ballot spec by not including it in the contract.\r\n        // Plus we're already storing the hash of the ballotSpec anyway...\r\n\r\n        // Private key to be set after ballot conclusion - curve25519\r\n        bytes32 ballotEncryptionSeckey;\r\n\r\n        // packed contains:\r\n        // 1. Timestamps for start and end of ballot (UTC)\r\n        // 2. bits used to decide which options are enabled or disabled for submission of ballots\r\n        uint256 packed;\r\n\r\n        // specHash by which to validate the ballots integrity\r\n        bytes32 specHash;\r\n        // extradata if we need it - allows us to upgrade spechash format, etc\r\n        bytes16 extraData;\r\n\r\n        // allow tracking of sponsorship for this ballot & connection to index\r\n        Sponsor[] sponsors;\r\n        IxIface index;\r\n\r\n        // deprecation flag - doesn't actually do anything besides signal that this contract is deprecated;\r\n        bool deprecated;\r\n\r\n        address ballotOwner;\r\n        uint256 creationTs;\r\n    }\r\n\r\n\r\n    // ** Modifiers -- note, these are functions here to allow use as a lib\r\n    function requireBallotClosed(DB storage db) internal view {\r\n        require(now > BPackedUtils.packedToEndTime(db.packed), \"!b-closed\");\r\n    }\r\n\r\n    function requireBallotOpen(DB storage db) internal view {\r\n        uint64 _n = uint64(now);\r\n        uint64 startTs;\r\n        uint64 endTs;\r\n        (, startTs, endTs) = BPackedUtils.unpackAll(db.packed);\r\n        require(_n >= startTs && _n < endTs, \"!b-open\");\r\n        require(db.deprecated == false, \"b-deprecated\");\r\n    }\r\n\r\n    function requireBallotOwner(DB storage db) internal view {\r\n        require(msg.sender == db.ballotOwner, \"!b-owner\");\r\n    }\r\n\r\n    function requireTesting(DB storage db) internal view {\r\n        require(isTesting(BPackedUtils.packedToSubmissionBits(db.packed)), \"!testing\");\r\n    }\r\n\r\n    /* Library meta */\r\n\r\n    function getVersion() external pure returns (uint) {\r\n        // even though this is constant we want to make sure that it's actually\r\n        // callable on Ethereum so we don't accidentally package the constant code\r\n        // in with an SC using BBLib. This function _must_ be external.\r\n        return BB_VERSION;\r\n    }\r\n\r\n    /* Functions */\r\n\r\n    // \"Constructor\" function - init core params on deploy\r\n    // timestampts are uint64s to give us plenty of room for millennia\r\n    function init(DB storage db, bytes32 _specHash, uint256 _packed, IxIface ix, address ballotOwner, bytes16 extraData) external {\r\n        require(db.specHash == bytes32(0), \"b-exists\");\r\n\r\n        db.index = ix;\r\n        db.ballotOwner = ballotOwner;\r\n\r\n        uint64 startTs;\r\n        uint64 endTs;\r\n        uint16 sb;\r\n        (sb, startTs, endTs) = BPackedUtils.unpackAll(_packed);\r\n\r\n        bool _testing = isTesting(sb);\r\n        if (_testing) {\r\n            emit TestingEnabled();\r\n        } else {\r\n            require(endTs > now, \"bad-end-time\");\r\n\r\n            // 0x1ff2 is 0001111111110010 in binary\r\n            // by ANDing with subBits we make sure that only bits in positions 0,2,3,13,14,15\r\n            // can be used. these correspond to the option flags at the top, and ETH ballots\r\n            // that are enc'd or plaintext.\r\n            require(sb & 0x1ff2 == 0, \"bad-sb\");\r\n\r\n            // if we give bad submission bits (e.g. all 0s) then refuse to deploy ballot\r\n            bool okaySubmissionBits = 1 == (isEthNoEnc(sb) ? 1 : 0) + (isEthWithEnc(sb) ? 1 : 0);\r\n            require(okaySubmissionBits, \"!valid-sb\");\r\n\r\n            // take the max of the start time provided and the blocks timestamp to avoid a DoS against recent token holders\r\n            // (which someone might be able to do if they could set the timestamp in the past)\r\n            startTs = startTs > now ? startTs : uint64(now);\r\n        }\r\n        require(_specHash != bytes32(0), \"null-specHash\");\r\n        db.specHash = _specHash;\r\n\r\n        db.packed = BPackedUtils.pack(sb, startTs, endTs);\r\n        db.creationTs = now;\r\n\r\n        if (extraData != bytes16(0)) {\r\n            db.extraData = extraData;\r\n        }\r\n\r\n        emit CreatedBallot(db.specHash, startTs, endTs, sb);\r\n    }\r\n\r\n    /* sponsorship */\r\n\r\n    function logSponsorship(DB storage db, uint value) internal {\r\n        db.sponsors.push(Sponsor(msg.sender, value));\r\n    }\r\n\r\n    /* getters */\r\n\r\n    function getVote(DB storage db, uint id) internal view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\r\n        return (db.votes[id].voteData, address(db.votes[id].castTsAndSender), db.votes[id].extra, uint(db.votes[id].castTsAndSender) >> 160);\r\n    }\r\n\r\n    function getSequenceNumber(DB storage db, address voter) internal view returns (uint32) {\r\n        return db.sequenceNumber[voter];\r\n    }\r\n\r\n    function getTotalSponsorship(DB storage db) internal view returns (uint total) {\r\n        for (uint i = 0; i < db.sponsors.length; i++) {\r\n            total += db.sponsors[i].amount;\r\n        }\r\n    }\r\n\r\n    function getSponsor(DB storage db, uint i) external view returns (address sender, uint amount) {\r\n        sender = db.sponsors[i].sender;\r\n        amount = db.sponsors[i].amount;\r\n    }\r\n\r\n    /* ETH BALLOTS */\r\n\r\n    function setSeqNumberMax(DB storage db) internal {\r\n        // set the sequence number to max uint32 to disable proxy submitted ballots\r\n        // after a voter submits a transaction personally - effectivley disables proxy\r\n        // ballots. You can _always_ submit a new vote _personally_ with this scheme.\r\n        if (db.sequenceNumber[msg.sender] != MAX_UINT32) {\r\n            // using an IF statement here let's us save 4800 gas on repeat votes at the cost of 20k extra gas initially\r\n            db.sequenceNumber[msg.sender] = MAX_UINT32;\r\n        }\r\n    }\r\n\r\n    // Ballot submission\r\n    // note: if USE_ENC then curve25519 keys should be generated by client for\r\n    // each ballot (then thrown away).\r\n    // the curve25519 PKs go in the extra param\r\n    function submitVote(DB storage db, bytes32 voteData, bytes extra) external {\r\n        _addVote(db, voteData, msg.sender, extra);\r\n        setSeqNumberMax(db);\r\n    }\r\n\r\n    // this skips the checks performed by _addVote\r\n    function submitVoteAlways(DB storage db, bytes32 voteData, bytes extra) external {\r\n        _addVoteAlways(db, voteData, msg.sender, extra);\r\n        setSeqNumberMax(db);\r\n    }\r\n\r\n    function submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra) external returns (address voter) {\r\n        return _submitProxyVote(db, proxyReq, extra, false);\r\n    }\r\n\r\n    function submitProxyVoteAlways(DB storage db, bytes32[5] proxyReq, bytes extra) external returns (address voter) {\r\n        return _submitProxyVote(db, proxyReq, extra, true);\r\n    }\r\n\r\n    // Boundaries for constructing the msg we'll validate the signature of\r\n    function _submitProxyVote(DB storage db, bytes32[5] proxyReq, bytes extra, bool submitAlways) internal returns (address voter) {\r\n        // a proxy vote (where the vote is submitted (i.e. tx fee paid by someone else)\r\n        // docs for datastructs: https://github.com/secure-vote/tokenvote/blob/master/Docs/DataStructs.md\r\n\r\n        bytes32 r = proxyReq[0];\r\n        bytes32 s = proxyReq[1];\r\n        uint8 v = uint8(proxyReq[2][0]);\r\n        // converting to uint248 will truncate the first byte, and we can then convert it to a bytes31.\r\n        // we truncate the first byte because it's the `v` parm used above\r\n        bytes31 proxyReq2 = bytes31(uint248(proxyReq[2]));\r\n        // proxyReq[3] is ballotId - required for verifying sig but not used for anything else\r\n        bytes32 ballotId = proxyReq[3];\r\n        bytes32 voteData = proxyReq[4];\r\n\r\n        // using abi.encodePacked is much cheaper than making bytes in other ways...\r\n        bytes memory signed = abi.encodePacked(proxyReq2, ballotId, voteData, extra);\r\n        bytes32 msgHash = keccak256(signed);\r\n        // need to be sure we are signing the entire ballot and any extra data that comes with it\r\n        voter = ecrecover(msgHash, v, r, s);\r\n\r\n        // we need to make sure that this is the most recent vote the voter made, and that it has\r\n        // not been seen before. NOTE: we've already validated the BBFarm namespace before this, so\r\n        // we know it's meant for _this_ ballot.\r\n        uint32 sequence = uint32(proxyReq2);  // last 4 bytes of proxyReq2 - the sequence number\r\n        _proxyReplayProtection(db, voter, sequence);\r\n\r\n        if (submitAlways) {\r\n            _addVoteAlways(db, voteData, voter, extra);\r\n        } else {\r\n            _addVote(db, voteData, voter, extra);\r\n        }\r\n    }\r\n\r\n    function _addVote(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\r\n        requireBallotOpen(db);\r\n        return _addVoteAlways(db, voteData, sender, extra);\r\n    }\r\n\r\n    function _addVoteAlways(DB storage db, bytes32 voteData, address sender, bytes extra) internal returns (uint256 id) {\r\n        id = db.nVotesCast;\r\n        db.votes[id].voteData = voteData;\r\n        // pack the casting ts right next to the sender\r\n        db.votes[id].castTsAndSender = bytes32(sender) ^ bytes32(now << 160);\r\n        if (extra.length > 0) {\r\n            db.votes[id].extra = extra;\r\n        }\r\n        db.nVotesCast += 1;\r\n        emit SuccessfulVote(sender, id);\r\n    }\r\n\r\n    function _proxyReplayProtection(DB storage db, address voter, uint32 sequence) internal {\r\n        // we want the replay protection sequence number to be STRICTLY MORE than what\r\n        // is stored in the mapping. This means we can set sequence to MAX_UINT32 to disable\r\n        // any future votes.\r\n        require(db.sequenceNumber[voter] < sequence, \"bad-sequence-n\");\r\n        db.sequenceNumber[voter] = sequence;\r\n    }\r\n\r\n    /* Admin */\r\n\r\n    function setEndTime(DB storage db, uint64 newEndTime) external {\r\n        uint16 sb;\r\n        uint64 sTs;\r\n        (sb, sTs,) = BPackedUtils.unpackAll(db.packed);\r\n        db.packed = BPackedUtils.pack(sb, sTs, newEndTime);\r\n    }\r\n\r\n    function revealSeckey(DB storage db, bytes32 sk) internal {\r\n        db.ballotEncryptionSeckey = sk;\r\n        emit SeckeyRevealed(sk);\r\n    }\r\n\r\n    /* Submission Bits (Ballot Classifications) */\r\n\r\n    // do (bits & SETTINGS_MASK) to get just operational bits (as opposed to testing or official flag)\r\n    uint16 constant SETTINGS_MASK = 0xFFFF ^ USE_TESTING ^ IS_OFFICIAL ^ IS_BINDING;\r\n\r\n    function isEthNoEnc(uint16 submissionBits) pure internal returns (bool) {\r\n        return checkFlags(submissionBits, USE_ETH | USE_NO_ENC);\r\n    }\r\n\r\n    function isEthWithEnc(uint16 submissionBits) pure internal returns (bool) {\r\n        return checkFlags(submissionBits, USE_ETH | USE_ENC);\r\n    }\r\n\r\n    function isOfficial(uint16 submissionBits) pure internal returns (bool) {\r\n        return (submissionBits & IS_OFFICIAL) == IS_OFFICIAL;\r\n    }\r\n\r\n    function isBinding(uint16 submissionBits) pure internal returns (bool) {\r\n        return (submissionBits & IS_BINDING) == IS_BINDING;\r\n    }\r\n\r\n    function isTesting(uint16 submissionBits) pure internal returns (bool) {\r\n        return (submissionBits & USE_TESTING) == USE_TESTING;\r\n    }\r\n\r\n    function qualifiesAsCommunityBallot(uint16 submissionBits) pure internal returns (bool) {\r\n        // if submissionBits AND any of the bits that make this _not_ a community\r\n        // ballot is equal to zero that means none of those bits were active, so\r\n        // it could be a community ballot\r\n        return (submissionBits & (IS_BINDING | IS_OFFICIAL | USE_ENC)) == 0;\r\n    }\r\n\r\n    function checkFlags(uint16 submissionBits, uint16 expected) pure internal returns (bool) {\r\n        // this should ignore ONLY the testing/flag bits - all other bits are significant\r\n        uint16 sBitsNoSettings = submissionBits & SETTINGS_MASK;\r\n        // then we want ONLY expected\r\n        return sBitsNoSettings == expected;\r\n    }\r\n}\r\n\r\nlibrary BPackedUtils {\r\n\r\n    // the uint16 ending at 128 bits should be 0s\r\n    uint256 constant sbMask        = 0xffffffffffffffffffffffffffff0000ffffffffffffffffffffffffffffffff;\r\n    uint256 constant startTimeMask = 0xffffffffffffffffffffffffffffffff0000000000000000ffffffffffffffff;\r\n    uint256 constant endTimeMask   = 0xffffffffffffffffffffffffffffffffffffffffffffffff0000000000000000;\r\n\r\n    function packedToSubmissionBits(uint256 packed) internal pure returns (uint16) {\r\n        return uint16(packed >> 128);\r\n    }\r\n\r\n    function packedToStartTime(uint256 packed) internal pure returns (uint64) {\r\n        return uint64(packed >> 64);\r\n    }\r\n\r\n    function packedToEndTime(uint256 packed) internal pure returns (uint64) {\r\n        return uint64(packed);\r\n    }\r\n\r\n    function unpackAll(uint256 packed) internal pure returns (uint16 submissionBits, uint64 startTime, uint64 endTime) {\r\n        submissionBits = uint16(packed >> 128);\r\n        startTime = uint64(packed >> 64);\r\n        endTime = uint64(packed);\r\n    }\r\n\r\n    function pack(uint16 sb, uint64 st, uint64 et) internal pure returns (uint256 packed) {\r\n        return uint256(sb) << 128 | uint256(st) << 64 | uint256(et);\r\n    }\r\n\r\n    function setSB(uint256 packed, uint16 newSB) internal pure returns (uint256) {\r\n        return (packed & sbMask) | uint256(newSB) << 128;\r\n    }\r\n\r\n    // function setStartTime(uint256 packed, uint64 startTime) internal pure returns (uint256) {\r\n    //     return (packed & startTimeMask) | uint256(startTime) << 64;\r\n    // }\r\n\r\n    function setEndTime(uint256 packed, uint64 endTime) internal pure returns (uint256) {\r\n        return (packed & endTimeMask) | uint256(endTime);\r\n    }\r\n}\r\n\r\ninterface CommAuctionIface {\r\n    function getNextPrice(bytes32 democHash) external view returns (uint);\r\n    function noteBallotDeployed(bytes32 democHash) external;\r\n\r\n    // add more when we need it\r\n\r\n    function upgradeMe(address newSC) external;\r\n}\r\n\r\nlibrary IxLib {\r\n    /**\r\n     * Usage: `using IxLib for IxIface`\r\n     * The idea is to (instead of adding methods that already use\r\n     * available public info to the index) we can create `internal`\r\n     * methods in the lib to do this instead (which means the code\r\n     * is inserted into other contracts inline, without a `delegatecall`.\r\n     *\r\n     * For this reason it's crucial to have no methods in IxLib with the\r\n     * same name as methods in IxIface\r\n     */\r\n\r\n    /* Global price and payments data */\r\n\r\n    function getPayTo(IxIface ix) internal view returns (address) {\r\n        return ix.getPayments().getPayTo();\r\n    }\r\n\r\n    /* Global Ix data */\r\n\r\n    function getBBFarmFromBallotID(IxIface ix, uint256 ballotId) internal view returns (BBFarmIface) {\r\n        bytes4 bbNamespace = bytes4(ballotId >> 48);\r\n        uint8 bbFarmId = ix.getBBFarmID(bbNamespace);\r\n        return ix.getBBFarm(bbFarmId);\r\n    }\r\n\r\n    /* Global backend data */\r\n\r\n    function getGDemocsN(IxIface ix) internal view returns (uint256) {\r\n        return ix.getBackend().getGDemocsN();\r\n    }\r\n\r\n    function getGDemoc(IxIface ix, uint256 n) internal view returns (bytes32) {\r\n        return ix.getBackend().getGDemoc(n);\r\n    }\r\n\r\n    function getGErc20ToDemocs(IxIface ix, address erc20) internal view returns (bytes32[] democHashes) {\r\n        return ix.getBackend().getGErc20ToDemocs(erc20);\r\n    }\r\n\r\n    /* Democ specific payment/account data */\r\n\r\n    function accountInGoodStanding(IxIface ix, bytes32 democHash) internal view returns (bool) {\r\n        return ix.getPayments().accountInGoodStanding(democHash);\r\n    }\r\n\r\n    function accountPremiumAndInGoodStanding(IxIface ix, bytes32 democHash) internal view returns (bool) {\r\n        IxPaymentsIface payments = ix.getPayments();\r\n        return payments.accountInGoodStanding(democHash) && payments.getPremiumStatus(democHash);\r\n    }\r\n\r\n    function payForDemocracy(IxIface ix, bytes32 democHash) internal {\r\n        ix.getPayments().payForDemocracy.value(msg.value)(democHash);\r\n    }\r\n\r\n    /* Democ getters */\r\n\r\n    function getDOwner(IxIface ix, bytes32 democHash) internal view returns (address) {\r\n        return ix.getBackend().getDOwner(democHash);\r\n    }\r\n\r\n    function isDEditor(IxIface ix, bytes32 democHash, address editor) internal view returns (bool) {\r\n        return ix.getBackend().isDEditor(democHash, editor);\r\n    }\r\n\r\n    function getDBallotsN(IxIface ix, bytes32 democHash) internal view returns (uint256) {\r\n        return ix.getBackend().getDBallotsN(democHash);\r\n    }\r\n\r\n    function getDBallotID(IxIface ix, bytes32 democHash, uint256 n) internal view returns (uint256) {\r\n        return ix.getBackend().getDBallotID(democHash, n);\r\n    }\r\n\r\n    function getDInfo(IxIface ix, bytes32 democHash) internal view returns (address erc20, address admin, uint256 _nBallots) {\r\n        return ix.getBackend().getDInfo(democHash);\r\n    }\r\n\r\n    function getDErc20(IxIface ix, bytes32 democHash) internal view returns (address erc20) {\r\n        return ix.getBackend().getDErc20(democHash);\r\n    }\r\n\r\n    function getDHash(IxIface ix, bytes13 prefix) internal view returns (bytes32) {\r\n        return ix.getBackend().getDHash(prefix);\r\n    }\r\n\r\n    function getDCategoriesN(IxIface ix, bytes32 democHash) internal view returns (uint) {\r\n        return ix.getBackend().getDCategoriesN(democHash);\r\n    }\r\n\r\n    function getDCategory(IxIface ix, bytes32 democHash, uint categoryId) internal view returns (bool, bytes32, bool, uint) {\r\n        return ix.getBackend().getDCategory(democHash, categoryId);\r\n    }\r\n\r\n    function getDArbitraryData(IxIface ix, bytes32 democHash, bytes key) external view returns (bytes) {\r\n        return ix.getBackend().getDArbitraryData(democHash, key);\r\n    }\r\n}\r\n\r\ncontract SVBallotConsts {\r\n    // voting settings\r\n    uint16 constant USE_ETH = 1;          // 2^0\r\n    uint16 constant USE_SIGNED = 2;       // 2^1\r\n    uint16 constant USE_NO_ENC = 4;       // 2^2\r\n    uint16 constant USE_ENC = 8;          // 2^3\r\n\r\n    // ballot settings\r\n    uint16 constant IS_BINDING = 8192;    // 2^13\r\n    uint16 constant IS_OFFICIAL = 16384;  // 2^14\r\n    uint16 constant USE_TESTING = 32768;  // 2^15\r\n}\r\n\r\ncontract safeSend {\r\n    bool private txMutex3847834;\r\n\r\n    // we want to be able to call outside contracts (e.g. the admin proxy contract)\r\n    // but reentrency is bad, so here's a mutex.\r\n    function doSafeSend(address toAddr, uint amount) internal {\r\n        doSafeSendWData(toAddr, \"\", amount);\r\n    }\r\n\r\n    function doSafeSendWData(address toAddr, bytes data, uint amount) internal {\r\n        require(txMutex3847834 == false, \"ss-guard\");\r\n        txMutex3847834 = true;\r\n        // we need to use address.call.value(v)() because we want\r\n        // to be able to send to other contracts, even with no data,\r\n        // which might use more than 2300 gas in their fallback function.\r\n        require(toAddr.call.value(amount)(data), \"ss-failed\");\r\n        txMutex3847834 = false;\r\n    }\r\n}\r\n\r\ncontract payoutAllC is safeSend {\r\n    address private _payTo;\r\n\r\n    event PayoutAll(address payTo, uint value);\r\n\r\n    constructor(address initPayTo) public {\r\n        // DEV NOTE: you can overwrite _getPayTo if you want to reuse other storage vars\r\n        assert(initPayTo != address(0));\r\n        _payTo = initPayTo;\r\n    }\r\n\r\n    function _getPayTo() internal view returns (address) {\r\n        return _payTo;\r\n    }\r\n\r\n    function _setPayTo(address newPayTo) internal {\r\n        _payTo = newPayTo;\r\n    }\r\n\r\n    function payoutAll() external {\r\n        address a = _getPayTo();\r\n        uint bal = address(this).balance;\r\n        doSafeSend(a, bal);\r\n        emit PayoutAll(a, bal);\r\n    }\r\n}\r\n\r\ncontract payoutAllCSettable is payoutAllC {\r\n    constructor (address initPayTo) payoutAllC(initPayTo) public {\r\n    }\r\n\r\n    function setPayTo(address) external;\r\n    function getPayTo() external view returns (address) {\r\n        return _getPayTo();\r\n    }\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    event OwnerChanged(address newOwner);\r\n\r\n    modifier only_owner() {\r\n        require(msg.sender == owner, \"only_owner: forbidden\");\r\n        _;\r\n    }\r\n\r\n    modifier owner_or(address addr) {\r\n        require(msg.sender == addr || msg.sender == owner, \"!owner-or\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function setOwner(address newOwner) only_owner() external {\r\n        owner = newOwner;\r\n        emit OwnerChanged(newOwner);\r\n    }\r\n}\r\n\r\ncontract CanReclaimToken is owned {\r\n\r\n    /**\r\n    * @dev Reclaim all ERC20Basic compatible tokens\r\n    * @param token ERC20Basic The address of the token contract\r\n    */\r\n    function reclaimToken(ERC20Interface token) external only_owner {\r\n        uint256 balance = token.balanceOf(this);\r\n        require(token.approve(owner, balance));\r\n    }\r\n\r\n}\r\n\r\ncontract CommunityAuctionSimple is owned, CommAuctionIface {\r\n    // about $1USD at $600usd/eth\r\n    uint public commBallotPriceWei = 1666666666000000;\r\n\r\n    struct Record {\r\n        bytes32 democHash;\r\n        uint ts;\r\n    }\r\n\r\n    mapping (address => Record[]) public ballotLog;\r\n    mapping (address => address) public upgrades;\r\n\r\n    function getNextPrice(bytes32) external view returns (uint) {\r\n        return commBallotPriceWei;\r\n    }\r\n\r\n    function noteBallotDeployed(bytes32 d) external {\r\n        require(upgrades[msg.sender] == address(0));\r\n        ballotLog[msg.sender].push(Record(d, now));\r\n    }\r\n\r\n    function upgradeMe(address newSC) external {\r\n        require(upgrades[msg.sender] == address(0));\r\n        upgrades[msg.sender] = newSC;\r\n    }\r\n\r\n    function getBallotLogN(address a) external view returns (uint) {\r\n        return ballotLog[a].length;\r\n    }\r\n\r\n    function setPriceWei(uint newPrice) only_owner() external {\r\n        commBallotPriceWei = newPrice;\r\n    }\r\n}\r\n\r\ncontract controlledIface {\r\n    function controller() external view returns (address);\r\n}\r\n\r\ncontract hasAdmins is owned {\r\n    mapping (uint => mapping (address => bool)) admins;\r\n    uint public currAdminEpoch = 0;\r\n    bool public adminsDisabledForever = false;\r\n    address[] adminLog;\r\n\r\n    event AdminAdded(address indexed newAdmin);\r\n    event AdminRemoved(address indexed oldAdmin);\r\n    event AdminEpochInc();\r\n    event AdminDisabledForever();\r\n\r\n    modifier only_admin() {\r\n        require(adminsDisabledForever == false, \"admins must not be disabled\");\r\n        require(isAdmin(msg.sender), \"only_admin: forbidden\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        _setAdmin(msg.sender, true);\r\n    }\r\n\r\n    function isAdmin(address a) view public returns (bool) {\r\n        return admins[currAdminEpoch][a];\r\n    }\r\n\r\n    function getAdminLogN() view external returns (uint) {\r\n        return adminLog.length;\r\n    }\r\n\r\n    function getAdminLog(uint n) view external returns (address) {\r\n        return adminLog[n];\r\n    }\r\n\r\n    function upgradeMeAdmin(address newAdmin) only_admin() external {\r\n        // note: already checked msg.sender has admin with `only_admin` modifier\r\n        require(msg.sender != owner, \"owner cannot upgrade self\");\r\n        _setAdmin(msg.sender, false);\r\n        _setAdmin(newAdmin, true);\r\n    }\r\n\r\n    function setAdmin(address a, bool _givePerms) only_admin() external {\r\n        require(a != msg.sender && a != owner, \"cannot change your own (or owner's) permissions\");\r\n        _setAdmin(a, _givePerms);\r\n    }\r\n\r\n    function _setAdmin(address a, bool _givePerms) internal {\r\n        admins[currAdminEpoch][a] = _givePerms;\r\n        if (_givePerms) {\r\n            emit AdminAdded(a);\r\n            adminLog.push(a);\r\n        } else {\r\n            emit AdminRemoved(a);\r\n        }\r\n    }\r\n\r\n    // safety feature if admins go bad or something\r\n    function incAdminEpoch() only_owner() external {\r\n        currAdminEpoch++;\r\n        admins[currAdminEpoch][msg.sender] = true;\r\n        emit AdminEpochInc();\r\n    }\r\n\r\n    // this is internal so contracts can all it, but not exposed anywhere in this\r\n    // contract.\r\n    function disableAdminForever() internal {\r\n        currAdminEpoch++;\r\n        adminsDisabledForever = true;\r\n        emit AdminDisabledForever();\r\n    }\r\n}\r\n\r\ncontract EnsOwnerProxy is hasAdmins {\r\n    bytes32 public ensNode;\r\n    ENSIface public ens;\r\n    PublicResolver public resolver;\r\n\r\n    /**\r\n     * @param _ensNode The node to administer\r\n     * @param _ens The ENS Registrar\r\n     * @param _resolver The ENS Resolver\r\n     */\r\n    constructor(bytes32 _ensNode, ENSIface _ens, PublicResolver _resolver) public {\r\n        ensNode = _ensNode;\r\n        ens = _ens;\r\n        resolver = _resolver;\r\n    }\r\n\r\n    function setAddr(address addr) only_admin() external {\r\n        _setAddr(addr);\r\n    }\r\n\r\n    function _setAddr(address addr) internal {\r\n        resolver.setAddr(ensNode, addr);\r\n    }\r\n\r\n    function returnToOwner() only_owner() external {\r\n        ens.setOwner(ensNode, owner);\r\n    }\r\n\r\n    function fwdToENS(bytes data) only_owner() external {\r\n        require(address(ens).call(data), \"fwding to ens failed\");\r\n    }\r\n\r\n    function fwdToResolver(bytes data) only_owner() external {\r\n        require(address(resolver).call(data), \"fwding to resolver failed\");\r\n    }\r\n}\r\n\r\ncontract permissioned is owned, hasAdmins {\r\n    mapping (address => bool) editAllowed;\r\n    bool public adminLockdown = false;\r\n\r\n    event PermissionError(address editAddr);\r\n    event PermissionGranted(address editAddr);\r\n    event PermissionRevoked(address editAddr);\r\n    event PermissionsUpgraded(address oldSC, address newSC);\r\n    event SelfUpgrade(address oldSC, address newSC);\r\n    event AdminLockdown();\r\n\r\n    modifier only_editors() {\r\n        require(editAllowed[msg.sender], \"only_editors: forbidden\");\r\n        _;\r\n    }\r\n\r\n    modifier no_lockdown() {\r\n        require(adminLockdown == false, \"no_lockdown: check failed\");\r\n        _;\r\n    }\r\n\r\n\r\n    constructor() owned() hasAdmins() public {\r\n    }\r\n\r\n\r\n    function setPermissions(address e, bool _editPerms) no_lockdown() only_admin() external {\r\n        editAllowed[e] = _editPerms;\r\n        if (_editPerms)\r\n            emit PermissionGranted(e);\r\n        else\r\n            emit PermissionRevoked(e);\r\n    }\r\n\r\n    function upgradePermissionedSC(address oldSC, address newSC) no_lockdown() only_admin() external {\r\n        editAllowed[oldSC] = false;\r\n        editAllowed[newSC] = true;\r\n        emit PermissionsUpgraded(oldSC, newSC);\r\n    }\r\n\r\n    // always allow SCs to upgrade themselves, even after lockdown\r\n    function upgradeMe(address newSC) only_editors() external {\r\n        editAllowed[msg.sender] = false;\r\n        editAllowed[newSC] = true;\r\n        emit SelfUpgrade(msg.sender, newSC);\r\n    }\r\n\r\n    function hasPermissions(address a) public view returns (bool) {\r\n        return editAllowed[a];\r\n    }\r\n\r\n    function doLockdown() external only_owner() no_lockdown() {\r\n        disableAdminForever();\r\n        adminLockdown = true;\r\n        emit AdminLockdown();\r\n    }\r\n}\r\n\r\ncontract upgradePtr {\r\n    address ptr = address(0);\r\n\r\n    modifier not_upgraded() {\r\n        require(ptr == address(0), \"upgrade pointer is non-zero\");\r\n        _;\r\n    }\r\n\r\n    function getUpgradePointer() view external returns (address) {\r\n        return ptr;\r\n    }\r\n\r\n    function doUpgradeInternal(address nextSC) internal {\r\n        ptr = nextSC;\r\n    }\r\n}\r\n\r\ninterface ERC20Interface {\r\n    // Get the total token supply\r\n    function totalSupply() constant external returns (uint256 _totalSupply);\r\n\r\n    // Get the account balance of another account with address _owner\r\n    function balanceOf(address _owner) constant external returns (uint256 balance);\r\n\r\n    // Send _value amount of tokens to address _to\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    // Send _value amount of tokens from address _from to address _to\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    // Allow _spender to withdraw from your account, multiple times, up to the _value amount.\r\n    // If this function is called again it overwrites the current allowance with _value.\r\n    // this function is required for some DEX functionality\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    // Returns the amount which _spender is still allowed to withdraw from _owner\r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining);\r\n\r\n    // Triggered when tokens are transferred.\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    // Triggered whenever approve(address _spender, uint256 _value) is called.\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ixEvents {\r\n    event PaymentMade(uint[2] valAndRemainder);\r\n    event AddedBBFarm(uint8 bbFarmId);\r\n    event SetBackend(bytes32 setWhat, address newSC);\r\n    event DeprecatedBBFarm(uint8 bbFarmId);\r\n    event CommunityBallot(bytes32 democHash, uint256 ballotId);\r\n    event ManuallyAddedBallot(bytes32 democHash, uint256 ballotId, uint256 packed);\r\n    // copied from BBFarm - unable to inherit from BBFarmEvents...\r\n    event BallotCreatedWithID(uint ballotId);\r\n    event BBFarmInit(bytes4 namespace);\r\n}\r\n\r\ncontract ixBackendEvents {\r\n    event NewDemoc(bytes32 democHash);\r\n    event ManuallyAddedDemoc(bytes32 democHash, address erc20);\r\n    event NewBallot(bytes32 indexed democHash, uint ballotN);\r\n    event DemocOwnerSet(bytes32 indexed democHash, address owner);\r\n    event DemocEditorSet(bytes32 indexed democHash, address editor, bool canEdit);\r\n    event DemocEditorsWiped(bytes32 indexed democHash);\r\n    event DemocErc20Set(bytes32 indexed democHash, address erc20);\r\n    event DemocDataSet(bytes32 indexed democHash, bytes32 keyHash);\r\n    event DemocCatAdded(bytes32 indexed democHash, uint catId);\r\n    event DemocCatDeprecated(bytes32 indexed democHash, uint catId);\r\n    event DemocCommunityBallotsEnabled(bytes32 indexed democHash, bool enabled);\r\n    event DemocErc20OwnerClaimDisabled(bytes32 indexed democHash);\r\n    event DemocClaimed(bytes32 indexed democHash);\r\n    event EmergencyDemocOwner(bytes32 indexed democHash, address newOwner);\r\n}\r\n\r\nlibrary SafeMath {\r\n    function subToZero(uint a, uint b) internal pure returns (uint) {\r\n        if (a < b) {  // then (a - b) would overflow\r\n            return 0;\r\n        }\r\n        return a - b;\r\n    }\r\n}\r\n\r\ncontract ixPaymentEvents {\r\n    event UpgradedToPremium(bytes32 indexed democHash);\r\n    event GrantedAccountTime(bytes32 indexed democHash, uint additionalSeconds, bytes32 ref);\r\n    event AccountPayment(bytes32 indexed democHash, uint additionalSeconds);\r\n    event SetCommunityBallotFee(uint amount);\r\n    event SetBasicCentsPricePer30Days(uint amount);\r\n    event SetPremiumMultiplier(uint8 multiplier);\r\n    event DowngradeToBasic(bytes32 indexed democHash);\r\n    event UpgradeToPremium(bytes32 indexed democHash);\r\n    event SetExchangeRate(uint weiPerCent);\r\n    event FreeExtension(bytes32 democHash);\r\n    event SetBallotsPer30Days(uint amount);\r\n    event SetFreeExtension(bytes32 democHash, bool hasFreeExt);\r\n    event SetDenyPremium(bytes32 democHash, bool isPremiumDenied);\r\n    event SetPayTo(address payTo);\r\n    event SetMinorEditsAddr(address minorEditsAddr);\r\n    event SetMinWeiForDInit(uint amount);\r\n}\r\n\r\ninterface hasVersion {\r\n    function getVersion() external pure returns (uint);\r\n}\r\n\r\ncontract BBFarmIface is BBFarmEvents, permissioned, hasVersion, payoutAllC {\r\n    /* global bbfarm getters */\r\n\r\n    function getNamespace() external view returns (bytes4);\r\n    function getBBLibVersion() external view returns (uint256);\r\n    function getNBallots() external view returns (uint256);\r\n\r\n    /* foreign network integration */\r\n\r\n    // requires version >= 3;\r\n    function getVotingNetworkDetails() external view returns (bytes32);\r\n\r\n    /* init a ballot */\r\n\r\n    // note that the ballotId returned INCLUDES the namespace.\r\n    function initBallot( bytes32 specHash\r\n                       , uint256 packed\r\n                       , IxIface ix\r\n                       , address bbAdmin\r\n                       , bytes24 extraData\r\n                       ) external returns (uint ballotId);\r\n    // requires v3+; also isn't supported on all networks\r\n    function initBallotProxy(uint8 v, bytes32 r, bytes32 s, bytes32[4] params) external returns (uint256 ballotId);\r\n\r\n    /* Sponsorship of ballots */\r\n\r\n    function sponsor(uint ballotId) external payable;\r\n\r\n    /* Voting functions */\r\n\r\n    function submitVote(uint ballotId, bytes32 vote, bytes extra) external;\r\n    function submitProxyVote(bytes32[5] proxyReq, bytes extra) external;\r\n\r\n    /* Ballot Getters */\r\n\r\n    function getDetails(uint ballotId, address voter) external view returns\r\n            ( bool hasVoted\r\n            , uint nVotesCast\r\n            , bytes32 secKey\r\n            , uint16 submissionBits\r\n            , uint64 startTime\r\n            , uint64 endTime\r\n            , bytes32 specHash\r\n            , bool deprecated\r\n            , address ballotOwner\r\n            , bytes16 extraData);\r\n\r\n    function getVote(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra);\r\n    // getVoteAndTime requires v3+\r\n    function getVoteAndTime(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra, uint castTs);\r\n    function getTotalSponsorship(uint ballotId) external view returns (uint);\r\n    function getSponsorsN(uint ballotId) external view returns (uint);\r\n    function getSponsor(uint ballotId, uint sponsorN) external view returns (address sender, uint amount);\r\n    function getCreationTs(uint ballotId) external view returns (uint);\r\n\r\n    /* Admin on ballots */\r\n    function revealSeckey(uint ballotId, bytes32 sk) external;\r\n    function setEndTime(uint ballotId, uint64 newEndTime) external;  // note: testing only\r\n    function setDeprecated(uint ballotId) external;\r\n    function setBallotOwner(uint ballotId, address newOwner) external;\r\n}\r\n\r\ncontract BBFarm is BBFarmIface {\r\n    using BBLibV7 for BBLibV7.DB;\r\n    using IxLib for IxIface;\r\n\r\n    // namespaces should be unique for each bbFarm\r\n    bytes4 constant NAMESPACE = 0x00000001;\r\n    // last 48 bits\r\n    uint256 constant BALLOT_ID_MASK = 0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    uint constant VERSION = 3;\r\n\r\n    mapping (uint224 => BBLibV7.DB) dbs;\r\n    // note - start at 100 to avoid any test for if 0 is a valid ballotId\r\n    // also gives us some space to play with low numbers if we want.\r\n    uint nBallots = 0;\r\n\r\n    /* modifiers */\r\n\r\n    modifier req_namespace(uint ballotId) {\r\n        // bytes4() will take the _first_ 4 bytes\r\n        require(bytes4(ballotId >> 224) == NAMESPACE, \"bad-namespace\");\r\n        _;\r\n    }\r\n\r\n    /* Constructor */\r\n\r\n    constructor() payoutAllC(msg.sender) public {\r\n        // this bbFarm requires v5 of BBLib (note: v4 deprecated immediately due to insecure submitProxyVote)\r\n        // note: even though we can't test for this in coverage, this has stopped me deploying to kovan with the wrong version tho, so I consider it tested :)\r\n        assert(BBLibV7.getVersion() == 7);\r\n        emit BBFarmInit(NAMESPACE);\r\n    }\r\n\r\n    /* base SCs */\r\n\r\n    function _getPayTo() internal view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function getVersion() external pure returns (uint) {\r\n        return VERSION;\r\n    }\r\n\r\n    /* global funcs */\r\n\r\n    function getNamespace() external view returns (bytes4) {\r\n        return NAMESPACE;\r\n    }\r\n\r\n    function getBBLibVersion() external view returns (uint256) {\r\n        return BBLibV7.getVersion();\r\n    }\r\n\r\n    function getNBallots() external view returns (uint256) {\r\n        return nBallots;\r\n    }\r\n\r\n    function getVotingNetworkDetails() external view returns (bytes32) {\r\n        // 0 in either chainId or networkId spot indicate the local chain\r\n        return bytes32(uint(0) << 192 | uint(0) << 160 | uint160(address(this)));\r\n    }\r\n\r\n    /* db lookup helper */\r\n\r\n    function getDb(uint ballotId) internal view returns (BBLibV7.DB storage) {\r\n        // cut off anything above 224 bits (where the namespace goes)\r\n        return dbs[uint224(ballotId)];\r\n    }\r\n\r\n    /* Init ballot */\r\n\r\n    function initBallot( bytes32 specHash\r\n                       , uint256 packed\r\n                       , IxIface ix\r\n                       , address bbAdmin\r\n                       , bytes24 extraData\r\n                ) only_editors() external returns (uint ballotId) {\r\n        // calculate the ballotId based on the last 224 bits of the specHash.\r\n        ballotId = uint224(specHash) ^ (uint256(NAMESPACE) << 224);\r\n        // we need to call the init functions on our libraries\r\n        getDb(ballotId).init(specHash, packed, ix, bbAdmin, bytes16(uint128(extraData)));\r\n        nBallots += 1;\r\n\r\n        emit BallotCreatedWithID(ballotId);\r\n    }\r\n\r\n    function initBallotProxy(uint8, bytes32, bytes32, bytes32[4]) external returns (uint256) {\r\n        // this isn't supported on the deployed BBFarm\r\n        revert(\"initBallotProxy not implemented\");\r\n    }\r\n\r\n    /* Sponsorship */\r\n\r\n    function sponsor(uint ballotId) external payable {\r\n        BBLibV7.DB storage db = getDb(ballotId);\r\n        db.logSponsorship(msg.value);\r\n        doSafeSend(db.index.getPayTo(), msg.value);\r\n        emit Sponsorship(ballotId, msg.value);\r\n    }\r\n\r\n    /* Voting */\r\n\r\n    function submitVote(uint ballotId, bytes32 vote, bytes extra) req_namespace(ballotId) external {\r\n        getDb(ballotId).submitVote(vote, extra);\r\n        emit Vote(ballotId, vote, msg.sender, extra);\r\n    }\r\n\r\n    function submitProxyVote(bytes32[5] proxyReq, bytes extra) req_namespace(uint256(proxyReq[3])) external {\r\n        // see https://github.com/secure-vote/tokenvote/blob/master/Docs/DataStructs.md for breakdown of params\r\n        // pr[3] is the ballotId, and pr[4] is the vote\r\n        uint ballotId = uint256(proxyReq[3]);\r\n        address voter = getDb(ballotId).submitProxyVote(proxyReq, extra);\r\n        bytes32 vote = proxyReq[4];\r\n        emit Vote(ballotId, vote, voter, extra);\r\n    }\r\n\r\n    /* Getters */\r\n\r\n    // note - this is the maxmimum number of vars we can return with one\r\n    // function call (taking 2 args)\r\n    function getDetails(uint ballotId, address voter) external view returns\r\n            ( bool hasVoted\r\n            , uint nVotesCast\r\n            , bytes32 secKey\r\n            , uint16 submissionBits\r\n            , uint64 startTime\r\n            , uint64 endTime\r\n            , bytes32 specHash\r\n            , bool deprecated\r\n            , address ballotOwner\r\n            , bytes16 extraData) {\r\n        BBLibV7.DB storage db = getDb(ballotId);\r\n        uint packed = db.packed;\r\n        return (\r\n            db.getSequenceNumber(voter) > 0,\r\n            db.nVotesCast,\r\n            db.ballotEncryptionSeckey,\r\n            BPackedUtils.packedToSubmissionBits(packed),\r\n            BPackedUtils.packedToStartTime(packed),\r\n            BPackedUtils.packedToEndTime(packed),\r\n            db.specHash,\r\n            db.deprecated,\r\n            db.ballotOwner,\r\n            db.extraData\r\n        );\r\n    }\r\n\r\n    function getVote(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra) {\r\n        (voteData, sender, extra, ) = getDb(ballotId).getVote(voteId);\r\n    }\r\n\r\n    function getVoteAndTime(uint ballotId, uint voteId) external view returns (bytes32 voteData, address sender, bytes extra, uint castTs) {\r\n        return getDb(ballotId).getVote(voteId);\r\n    }\r\n\r\n    function getSequenceNumber(uint ballotId, address voter) external view returns (uint32 sequence) {\r\n        return getDb(ballotId).getSequenceNumber(voter);\r\n    }\r\n\r\n    function getTotalSponsorship(uint ballotId) external view returns (uint) {\r\n        return getDb(ballotId).getTotalSponsorship();\r\n    }\r\n\r\n    function getSponsorsN(uint ballotId) external view returns (uint) {\r\n        return getDb(ballotId).sponsors.length;\r\n    }\r\n\r\n    function getSponsor(uint ballotId, uint sponsorN) external view returns (address sender, uint amount) {\r\n        return getDb(ballotId).getSponsor(sponsorN);\r\n    }\r\n\r\n    function getCreationTs(uint ballotId) external view returns (uint) {\r\n        return getDb(ballotId).creationTs;\r\n    }\r\n\r\n    /* ADMIN */\r\n\r\n    // Allow the owner to reveal the secret key after ballot conclusion\r\n    function revealSeckey(uint ballotId, bytes32 sk) external {\r\n        BBLibV7.DB storage db = getDb(ballotId);\r\n        db.requireBallotOwner();\r\n        db.requireBallotClosed();\r\n        db.revealSeckey(sk);\r\n    }\r\n\r\n    // note: testing only.\r\n    function setEndTime(uint ballotId, uint64 newEndTime) external {\r\n        BBLibV7.DB storage db = getDb(ballotId);\r\n        db.requireBallotOwner();\r\n        db.requireTesting();\r\n        db.setEndTime(newEndTime);\r\n    }\r\n\r\n    function setDeprecated(uint ballotId) external {\r\n        BBLibV7.DB storage db = getDb(ballotId);\r\n        db.requireBallotOwner();\r\n        db.deprecated = true;\r\n    }\r\n\r\n    function setBallotOwner(uint ballotId, address newOwner) external {\r\n        BBLibV7.DB storage db = getDb(ballotId);\r\n        db.requireBallotOwner();\r\n        db.ballotOwner = newOwner;\r\n    }\r\n}\r\n\r\ncontract IxIface is hasVersion,\r\n                    ixPaymentEvents,\r\n                    ixBackendEvents,\r\n                    ixEvents,\r\n                    SVBallotConsts,\r\n                    owned,\r\n                    CanReclaimToken,\r\n                    upgradePtr,\r\n                    payoutAllC {\r\n\r\n    /* owner functions */\r\n    function addBBFarm(BBFarmIface bbFarm) external returns (uint8 bbFarmId);\r\n    function setABackend(bytes32 toSet, address newSC) external;\r\n    function deprecateBBFarm(uint8 bbFarmId, BBFarmIface _bbFarm) external;\r\n\r\n    /* global getters */\r\n    function getPayments() external view returns (IxPaymentsIface);\r\n    function getBackend() external view returns (IxBackendIface);\r\n    function getBBFarm(uint8 bbFarmId) external view returns (BBFarmIface);\r\n    function getBBFarmID(bytes4 bbNamespace) external view returns (uint8 bbFarmId);\r\n    function getCommAuction() external view returns (CommAuctionIface);\r\n\r\n    /* init a democ */\r\n    function dInit(address defualtErc20, bool disableErc20OwnerClaim) external payable returns (bytes32);\r\n\r\n    /* democ owner / editor functions */\r\n    function setDEditor(bytes32 democHash, address editor, bool canEdit) external;\r\n    function setDNoEditors(bytes32 democHash) external;\r\n    function setDOwner(bytes32 democHash, address newOwner) external;\r\n    function dOwnerErc20Claim(bytes32 democHash) external;\r\n    function setDErc20(bytes32 democHash, address newErc20) external;\r\n    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external;\r\n    function dDeprecateCategory(bytes32 democHash, uint categoryId) external;\r\n    function dUpgradeToPremium(bytes32 democHash) external;\r\n    function dDowngradeToBasic(bytes32 democHash) external;\r\n    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\r\n    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) external;\r\n    function dDisableErc20OwnerClaim(bytes32 democHash) external;\r\n\r\n    /* democ getters (that used to be here) should be called on either backend or payments directly */\r\n    /* use IxLib for convenience functions from other SCs */\r\n\r\n    /* ballot deployment */\r\n    // only ix owner - used for adding past or special ballots\r\n    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed) external;\r\n    function dDeployCommunityBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint128 packedTimes) external payable;\r\n    function dDeployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint256 packed) external payable;\r\n}\r\n\r\ncontract SVIndex is IxIface {\r\n    uint256 constant VERSION = 2;\r\n\r\n    // generated from: `address public owner;`\r\n    bytes4 constant OWNER_SIG = 0x8da5cb5b;\r\n    // generated from: `address public controller;`\r\n    bytes4 constant CONTROLLER_SIG = 0xf77c4791;\r\n\r\n    /* backend & other SC storage */\r\n\r\n    IxBackendIface backend;\r\n    IxPaymentsIface payments;\r\n    EnsOwnerProxy public ensOwnerPx;\r\n    BBFarmIface[] bbFarms;\r\n    CommAuctionIface commAuction;\r\n    // mapping from bbFarm namespace to bbFarmId\r\n    mapping (bytes4 => uint8) bbFarmIdLookup;\r\n    mapping (uint8 => bool) deprecatedBBFarms;\r\n\r\n    //* MODIFIERS /\r\n\r\n    modifier onlyDemocOwner(bytes32 democHash) {\r\n        require(msg.sender == backend.getDOwner(democHash), \"!d-owner\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDemocEditor(bytes32 democHash) {\r\n        require(backend.isDEditor(democHash, msg.sender), \"!d-editor\");\r\n        _;\r\n    }\r\n\r\n    /* FUNCTIONS */\r\n\r\n    // constructor\r\n    constructor( IxBackendIface _b\r\n               , IxPaymentsIface _pay\r\n               , EnsOwnerProxy _ensOwnerPx\r\n               , BBFarmIface _bbFarm0\r\n               , CommAuctionIface _commAuction\r\n               ) payoutAllC(msg.sender) public {\r\n        backend = _b;\r\n        payments = _pay;\r\n        ensOwnerPx = _ensOwnerPx;\r\n        _addBBFarm(0x0, _bbFarm0);\r\n        commAuction = _commAuction;\r\n    }\r\n\r\n    /* payoutAllC */\r\n\r\n    function _getPayTo() internal view returns (address) {\r\n        return payments.getPayTo();\r\n    }\r\n\r\n    /* UPGRADE STUFF */\r\n\r\n    function doUpgrade(address nextSC) only_owner() not_upgraded() external {\r\n        doUpgradeInternal(nextSC);\r\n        backend.upgradeMe(nextSC);\r\n        payments.upgradeMe(nextSC);\r\n        ensOwnerPx.setAddr(nextSC);\r\n        ensOwnerPx.upgradeMeAdmin(nextSC);\r\n        commAuction.upgradeMe(nextSC);\r\n\r\n        for (uint i = 0; i < bbFarms.length; i++) {\r\n            bbFarms[i].upgradeMe(nextSC);\r\n        }\r\n    }\r\n\r\n    function _addBBFarm(bytes4 bbNamespace, BBFarmIface _bbFarm) internal returns (uint8 bbFarmId) {\r\n        uint256 bbFarmIdLong = bbFarms.length;\r\n        require(bbFarmIdLong < 2**8, \"too-many-farms\");\r\n        bbFarmId = uint8(bbFarmIdLong);\r\n\r\n        bbFarms.push(_bbFarm);\r\n        bbFarmIdLookup[bbNamespace] = bbFarmId;\r\n        emit AddedBBFarm(bbFarmId);\r\n    }\r\n\r\n    // adding a new BBFarm\r\n    function addBBFarm(BBFarmIface bbFarm) only_owner() external returns (uint8 bbFarmId) {\r\n        bytes4 bbNamespace = bbFarm.getNamespace();\r\n\r\n        require(bbNamespace != bytes4(0), \"bb-farm-namespace\");\r\n        require(bbFarmIdLookup[bbNamespace] == 0 && bbNamespace != bbFarms[0].getNamespace(), \"bb-namespace-used\");\r\n\r\n        bbFarmId = _addBBFarm(bbNamespace, bbFarm);\r\n    }\r\n\r\n    function setABackend(bytes32 toSet, address newSC) only_owner() external {\r\n        emit SetBackend(toSet, newSC);\r\n        if (toSet == bytes32(\"payments\")) {\r\n            payments = IxPaymentsIface(newSC);\r\n        } else if (toSet == bytes32(\"backend\")) {\r\n            backend = IxBackendIface(newSC);\r\n        } else if (toSet == bytes32(\"commAuction\")) {\r\n            commAuction = CommAuctionIface(newSC);\r\n        } else {\r\n            revert(\"404\");\r\n        }\r\n    }\r\n\r\n    function deprecateBBFarm(uint8 bbFarmId, BBFarmIface _bbFarm) only_owner() external {\r\n        require(address(_bbFarm) != address(0));\r\n        require(bbFarms[bbFarmId] == _bbFarm);\r\n        deprecatedBBFarms[bbFarmId] = true;\r\n        emit DeprecatedBBFarm(bbFarmId);\r\n    }\r\n\r\n    /* Getters for backends */\r\n\r\n    function getPayments() external view returns (IxPaymentsIface) {\r\n        return payments;\r\n    }\r\n\r\n    function getBackend() external view returns (IxBackendIface) {\r\n        return backend;\r\n    }\r\n\r\n    function getBBFarm(uint8 bbFarmId) external view returns (BBFarmIface) {\r\n        return bbFarms[bbFarmId];\r\n    }\r\n\r\n    function getBBFarmID(bytes4 bbNamespace) external view returns (uint8 bbFarmId) {\r\n        return bbFarmIdLookup[bbNamespace];\r\n    }\r\n\r\n    function getCommAuction() external view returns (CommAuctionIface) {\r\n        return commAuction;\r\n    }\r\n\r\n    //* GLOBAL INFO */\r\n\r\n    function getVersion() external pure returns (uint256) {\r\n        return VERSION;\r\n    }\r\n\r\n    //* DEMOCRACY FUNCTIONS - INDIVIDUAL */\r\n\r\n    function dInit(address defaultErc20, bool disableErc20OwnerClaim) not_upgraded() external payable returns (bytes32) {\r\n        require(msg.value >= payments.getMinWeiForDInit());\r\n        bytes32 democHash = backend.dInit(defaultErc20, msg.sender, disableErc20OwnerClaim);\r\n        payments.payForDemocracy.value(msg.value)(democHash);\r\n        return democHash;\r\n    }\r\n\r\n    // admin methods\r\n\r\n    function setDEditor(bytes32 democHash, address editor, bool canEdit) onlyDemocOwner(democHash) external {\r\n        backend.setDEditor(democHash, editor, canEdit);\r\n    }\r\n\r\n    function setDNoEditors(bytes32 democHash) onlyDemocOwner(democHash) external {\r\n        backend.setDNoEditors(democHash);\r\n    }\r\n\r\n    function setDOwner(bytes32 democHash, address newOwner) onlyDemocOwner(democHash) external {\r\n        backend.setDOwner(democHash, newOwner);\r\n    }\r\n\r\n    function dOwnerErc20Claim(bytes32 democHash) external {\r\n        address erc20 = backend.getDErc20(democHash);\r\n        // test if we can call the erc20.owner() method, etc\r\n        // also limit gas use to 3000 because we don't know what they'll do with it\r\n        // during testing both owned and controlled could be called from other contracts for 2525 gas.\r\n        if (erc20.call.gas(3000)(OWNER_SIG)) {\r\n            require(msg.sender == owned(erc20).owner.gas(3000)(), \"!erc20-owner\");\r\n        } else if (erc20.call.gas(3000)(CONTROLLER_SIG)) {\r\n            require(msg.sender == controlledIface(erc20).controller.gas(3000)(), \"!erc20-controller\");\r\n        } else {\r\n            revert();\r\n        }\r\n        // now we are certain the sender deployed or controls the erc20\r\n        backend.setDOwnerFromClaim(democHash, msg.sender);\r\n    }\r\n\r\n    function setDErc20(bytes32 democHash, address newErc20) onlyDemocOwner(democHash) external {\r\n        backend.setDErc20(democHash, newErc20);\r\n    }\r\n\r\n    function dAddCategory(bytes32 democHash, bytes32 catName, bool hasParent, uint parent) onlyDemocEditor(democHash) external {\r\n        backend.dAddCategory(democHash, catName, hasParent, parent);\r\n    }\r\n\r\n    function dDeprecateCategory(bytes32 democHash, uint catId) onlyDemocEditor(democHash) external {\r\n        backend.dDeprecateCategory(democHash, catId);\r\n    }\r\n\r\n    function dUpgradeToPremium(bytes32 democHash) onlyDemocOwner(democHash) external {\r\n        payments.upgradeToPremium(democHash);\r\n    }\r\n\r\n    function dDowngradeToBasic(bytes32 democHash) onlyDemocOwner(democHash) external {\r\n        payments.downgradeToBasic(democHash);\r\n    }\r\n\r\n    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external {\r\n        if (msg.sender == backend.getDOwner(democHash)) {\r\n            backend.dSetArbitraryData(democHash, key, value);\r\n        } else if (backend.isDEditor(democHash, msg.sender)) {\r\n            backend.dSetEditorArbitraryData(democHash, key, value);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) onlyDemocOwner(democHash) external {\r\n        backend.dSetCommunityBallotsEnabled(democHash, enabled);\r\n    }\r\n\r\n    // this is one way only!\r\n    function dDisableErc20OwnerClaim(bytes32 democHash) onlyDemocOwner(democHash) external {\r\n        backend.dDisableErc20OwnerClaim(democHash);\r\n    }\r\n\r\n    /* Democ Getters - deprecated */\r\n    // NOTE: the getters that used to live here just proxied to the backend.\r\n    // this has been removed to reduce gas costs + size of Ix contract\r\n    // For SCs you should use IxLib for convenience.\r\n    // For Offchain use you should query the backend directly (via ix.getBackend())\r\n\r\n    /* Add and Deploy Ballots */\r\n\r\n    // manually add a ballot - only the owner can call this\r\n    // WARNING - it's required that we make ABSOLUTELY SURE that\r\n    // ballotId is valid and can resolve via the appropriate BBFarm.\r\n    // this function _DOES NOT_ validate that everything else is done.\r\n    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed)\r\n                      only_owner()\r\n                      external {\r\n\r\n        _addBallot(democHash, ballotId, packed, false);\r\n        emit ManuallyAddedBallot(democHash, ballotId, packed);\r\n    }\r\n\r\n\r\n    function _deployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint packed, bool checkLimit, bool alreadySentTx) internal returns (uint ballotId) {\r\n        require(BBLibV7.isTesting(BPackedUtils.packedToSubmissionBits(packed)) == false, \"b-testing\");\r\n\r\n        // the most significant byte of extraData signals the bbFarm to use.\r\n        uint8 bbFarmId = uint8(extraData[0]);\r\n        require(deprecatedBBFarms[bbFarmId] == false, \"bb-dep\");\r\n        BBFarmIface _bbFarm = bbFarms[bbFarmId];\r\n\r\n        // anything that isn't a community ballot counts towards the basic limit.\r\n        // we want to check in cases where\r\n        // the ballot doesn't qualify as a community ballot\r\n        // OR (the ballot qualifies as a community ballot\r\n        //     AND the admins have _disabled_ community ballots).\r\n        bool countTowardsLimit = checkLimit;\r\n        bool performedSend;\r\n        if (checkLimit) {\r\n            uint64 endTime = BPackedUtils.packedToEndTime(packed);\r\n            (countTowardsLimit, performedSend) = _basicBallotLimitOperations(democHash, _bbFarm);\r\n            _accountOkayChecks(democHash, endTime);\r\n        }\r\n\r\n        if (!performedSend && msg.value > 0 && alreadySentTx == false) {\r\n            // refund if we haven't send value anywhere (which might happen if someone accidentally pays us)\r\n            doSafeSend(msg.sender, msg.value);\r\n        }\r\n\r\n        ballotId = _bbFarm.initBallot(\r\n            specHash,\r\n            packed,\r\n            this,\r\n            msg.sender,\r\n            // we are certain that the first 8 bytes are for index use only.\r\n            // truncating extraData like this means we can occasionally\r\n            // save on gas. we need to use uint192 first because that will take\r\n            // the _last_ 24 bytes of extraData.\r\n            bytes24(uint192(extraData)));\r\n\r\n        _addBallot(democHash, ballotId, packed, countTowardsLimit);\r\n    }\r\n\r\n    function dDeployCommunityBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint128 packedTimes) external payable {\r\n        uint price = commAuction.getNextPrice(democHash);\r\n        require(msg.value >= price, \"!cb-fee\");\r\n\r\n        doSafeSend(payments.getPayTo(), price);\r\n        doSafeSend(msg.sender, msg.value - price);\r\n\r\n        bool canProceed = backend.getDCommBallotsEnabled(democHash) || !payments.accountInGoodStanding(democHash);\r\n        require(canProceed, \"!cb-enabled\");\r\n\r\n        uint256 packed = BPackedUtils.setSB(uint256(packedTimes), (USE_ETH | USE_NO_ENC));\r\n\r\n        uint ballotId = _deployBallot(democHash, specHash, extraData, packed, false, true);\r\n        commAuction.noteBallotDeployed(democHash);\r\n\r\n        emit CommunityBallot(democHash, ballotId);\r\n    }\r\n\r\n    // only way a democ admin can deploy a ballot\r\n    function dDeployBallot(bytes32 democHash, bytes32 specHash, bytes32 extraData, uint256 packed)\r\n                          onlyDemocEditor(democHash)\r\n                          external payable {\r\n\r\n        _deployBallot(democHash, specHash, extraData, packed, true, false);\r\n    }\r\n\r\n    // internal logic around adding a ballot\r\n    function _addBallot(bytes32 democHash, uint256 ballotId, uint256 packed, bool countTowardsLimit) internal {\r\n        // backend handles events\r\n        backend.dAddBallot(democHash, ballotId, packed, countTowardsLimit);\r\n    }\r\n\r\n    // check an account has paid up enough for this ballot\r\n    function _accountOkayChecks(bytes32 democHash, uint64 endTime) internal view {\r\n        // if the ballot is marked as official require the democracy is paid up to\r\n        // some relative amount - exclude NFP accounts from this check\r\n        uint secsLeft = payments.getSecondsRemaining(democHash);\r\n        // must be positive due to ending in future check\r\n        uint256 secsToEndTime = endTime - now;\r\n        // require ballots end no more than twice the time left on the democracy\r\n        require(secsLeft * 2 > secsToEndTime, \"unpaid\");\r\n    }\r\n\r\n    function _basicBallotLimitOperations(bytes32 democHash, BBFarmIface _bbFarm) internal returns (bool shouldCount, bool performedSend) {\r\n        // if we're an official ballot and the democ is basic, ensure the democ\r\n        // isn't over the ballots/mo limit\r\n        if (payments.getPremiumStatus(democHash) == false) {\r\n            uint nBallotsAllowed = payments.getBasicBallotsPer30Days();\r\n            uint nBallotsBasicCounted = backend.getDCountedBasicBallotsN(democHash);\r\n\r\n            // if the democ has less than nBallotsAllowed then it's guarenteed to be okay\r\n            if (nBallotsAllowed > nBallotsBasicCounted) {\r\n                // and we should count this ballot\r\n                return (true, false);\r\n            }\r\n\r\n            // we want to check the creation timestamp of the nth most recent ballot\r\n            // where n is the # of ballots allowed per month. Note: there isn't an off\r\n            // by 1 error here because if 1 ballots were allowed per month then we'd want\r\n            // to look at the most recent ballot, so nBallotsBasicCounted-1 in this case.\r\n            // similarly, if X ballots were allowed per month we want to look at\r\n            // nBallotsBasicCounted-X. There would thus be (X-1) ballots that are _more_\r\n            // recent than the one we're looking for.\r\n            uint earlyBallotId = backend.getDCountedBasicBallotID(democHash, nBallotsBasicCounted - nBallotsAllowed);\r\n            uint earlyBallotTs = _bbFarm.getCreationTs(earlyBallotId);\r\n\r\n            // if the earlyBallot was created more than 30 days in the past we should\r\n            // count the new ballot\r\n            if (earlyBallotTs < now - 30 days) {\r\n                return (true, false);\r\n            }\r\n\r\n            // at this point it may be the case that we shouldn't allow the ballot\r\n            // to be created. (It's an official ballot for a basic tier democracy\r\n            // where the Nth most recent ballot was created within the last 30 days.)\r\n            // We should now check for payment\r\n            uint extraBallotFee = payments.getBasicExtraBallotFeeWei();\r\n            require(msg.value >= extraBallotFee, \"!extra-b-fee\");\r\n\r\n            // now that we know they've paid the fee, we should send Eth to `payTo`\r\n            // and return the remainder.\r\n            uint remainder = msg.value - extraBallotFee;\r\n            doSafeSend(address(payments), extraBallotFee);\r\n            doSafeSend(msg.sender, remainder);\r\n            emit PaymentMade([extraBallotFee, remainder]);\r\n            // only in this case (for basic) do we want to return false - don't count towards the\r\n            // limit because it's been paid for here.\r\n            return (false, true);\r\n\r\n        } else {  // if we're premium we don't count ballots\r\n            return (false, false);\r\n        }\r\n    }\r\n}\r\n\r\ncontract IxBackendIface is hasVersion, ixBackendEvents, permissioned, payoutAllC {\r\n    /* global getters */\r\n    function getGDemocsN() external view returns (uint);\r\n    function getGDemoc(uint id) external view returns (bytes32);\r\n    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes);\r\n\r\n    /* owner functions */\r\n    function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) external;\r\n    function emergencySetDOwner(bytes32 democHash, address newOwner) external;\r\n\r\n    /* democ admin */\r\n    function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) external returns (bytes32 democHash);\r\n    function setDOwner(bytes32 democHash, address newOwner) external;\r\n    function setDOwnerFromClaim(bytes32 democHash, address newOwner) external;\r\n    function setDEditor(bytes32 democHash, address editor, bool canEdit) external;\r\n    function setDNoEditors(bytes32 democHash) external;\r\n    function setDErc20(bytes32 democHash, address newErc20) external;\r\n    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) external;\r\n    function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) external;\r\n    function dAddCategory(bytes32 democHash, bytes32 categoryName, bool hasParent, uint parent) external;\r\n    function dDeprecateCategory(bytes32 democHash, uint catId) external;\r\n    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) external;\r\n    function dDisableErc20OwnerClaim(bytes32 democHash) external;\r\n\r\n    /* actually add a ballot */\r\n    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) external;\r\n\r\n    /* global democ getters */\r\n    function getDOwner(bytes32 democHash) external view returns (address);\r\n    function isDEditor(bytes32 democHash, address editor) external view returns (bool);\r\n    function getDHash(bytes13 prefix) external view returns (bytes32);\r\n    function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots);\r\n    function getDErc20(bytes32 democHash) external view returns (address);\r\n    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\r\n    function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes value);\r\n    function getDBallotsN(bytes32 democHash) external view returns (uint256);\r\n    function getDBallotID(bytes32 democHash, uint n) external view returns (uint ballotId);\r\n    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256);\r\n    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256);\r\n    function getDCategoriesN(bytes32 democHash) external view returns (uint);\r\n    function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint parent);\r\n    function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool);\r\n    function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool);\r\n}\r\n\r\ncontract SVIndexBackend is IxBackendIface {\r\n    uint constant VERSION = 2;\r\n\r\n    struct Democ {\r\n        address erc20;\r\n        address owner;\r\n        bool communityBallotsDisabled;\r\n        bool erc20OwnerClaimDisabled;\r\n        uint editorEpoch;\r\n        mapping (uint => mapping (address => bool)) editors;\r\n        uint256[] allBallots;\r\n        uint256[] includedBasicBallots;  // the IDs of official ballots\r\n\r\n    }\r\n\r\n    struct BallotRef {\r\n        bytes32 democHash;\r\n        uint ballotId;\r\n    }\r\n\r\n    struct Category {\r\n        bool deprecated;\r\n        bytes32 name;\r\n        bool hasParent;\r\n        uint parent;\r\n    }\r\n\r\n    struct CategoriesIx {\r\n        uint nCategories;\r\n        mapping(uint => Category) categories;\r\n    }\r\n\r\n    mapping (bytes32 => Democ) democs;\r\n    mapping (bytes32 => CategoriesIx) democCategories;\r\n    mapping (bytes13 => bytes32) democPrefixToHash;\r\n    mapping (address => bytes32[]) erc20ToDemocs;\r\n    bytes32[] democList;\r\n\r\n    // allows democ admins to store arbitrary data\r\n    // this lets us (for example) set particular keys to signal cerain\r\n    // things to client apps s.t. the admin can turn them on and off.\r\n    // arbitraryData[democHash][key]\r\n    mapping (bytes32 => mapping (bytes32 => bytes)) arbitraryData;\r\n\r\n    /* constructor */\r\n\r\n    constructor() payoutAllC(msg.sender) public {\r\n        // do nothing\r\n    }\r\n\r\n    /* base contract overloads */\r\n\r\n    function _getPayTo() internal view returns (address) {\r\n        return owner;\r\n    }\r\n\r\n    function getVersion() external pure returns (uint) {\r\n        return VERSION;\r\n    }\r\n\r\n    /* GLOBAL INFO */\r\n\r\n    function getGDemocsN() external view returns (uint) {\r\n        return democList.length;\r\n    }\r\n\r\n    function getGDemoc(uint id) external view returns (bytes32) {\r\n        return democList[id];\r\n    }\r\n\r\n    function getGErc20ToDemocs(address erc20) external view returns (bytes32[] democHashes) {\r\n        return erc20ToDemocs[erc20];\r\n    }\r\n\r\n    /* DEMOCRACY ADMIN FUNCTIONS */\r\n\r\n    function _addDemoc(bytes32 democHash, address erc20, address initOwner, bool disableErc20OwnerClaim) internal {\r\n        democList.push(democHash);\r\n        Democ storage d = democs[democHash];\r\n        d.erc20 = erc20;\r\n        if (disableErc20OwnerClaim) {\r\n            d.erc20OwnerClaimDisabled = true;\r\n        }\r\n        // this should never trigger if we have a good security model - entropy for 13 bytes ~ 2^(8*13) ~ 10^31\r\n        assert(democPrefixToHash[bytes13(democHash)] == bytes32(0));\r\n        democPrefixToHash[bytes13(democHash)] = democHash;\r\n        erc20ToDemocs[erc20].push(democHash);\r\n        _setDOwner(democHash, initOwner);\r\n        emit NewDemoc(democHash);\r\n    }\r\n\r\n    /* owner democ admin functions */\r\n\r\n    function dAdd(bytes32 democHash, address erc20, bool disableErc20OwnerClaim) only_owner() external {\r\n        _addDemoc(democHash, erc20, msg.sender, disableErc20OwnerClaim);\r\n        emit ManuallyAddedDemoc(democHash, erc20);\r\n    }\r\n\r\n    /* Preferably for emergencies only */\r\n\r\n    function emergencySetDOwner(bytes32 democHash, address newOwner) only_owner() external {\r\n        _setDOwner(democHash, newOwner);\r\n        emit EmergencyDemocOwner(democHash, newOwner);\r\n    }\r\n\r\n    /* user democ admin functions */\r\n\r\n    function dInit(address defaultErc20, address initOwner, bool disableErc20OwnerClaim) only_editors() external returns (bytes32 democHash) {\r\n        // generating the democHash in this way guarentees it'll be unique/hard-to-brute-force\r\n        // (particularly because prevBlockHash and now are part of the hash)\r\n        democHash = keccak256(abi.encodePacked(democList.length, blockhash(block.number-1), defaultErc20, now));\r\n        _addDemoc(democHash, defaultErc20, initOwner, disableErc20OwnerClaim);\r\n    }\r\n\r\n    function _setDOwner(bytes32 democHash, address newOwner) internal {\r\n        Democ storage d = democs[democHash];\r\n        uint epoch = d.editorEpoch;\r\n        d.owner = newOwner;\r\n        // unset prev owner as editor - does little if one was not set\r\n        d.editors[epoch][d.owner] = false;\r\n        // make new owner an editor too\r\n        d.editors[epoch][newOwner] = true;\r\n        emit DemocOwnerSet(democHash, newOwner);\r\n    }\r\n\r\n    function setDOwner(bytes32 democHash, address newOwner) only_editors() external {\r\n        _setDOwner(democHash, newOwner);\r\n    }\r\n\r\n    function setDOwnerFromClaim(bytes32 democHash, address newOwner) only_editors() external {\r\n        Democ storage d = democs[democHash];\r\n        // make sure that the owner claim is enabled (i.e. the disabled flag is false)\r\n        require(d.erc20OwnerClaimDisabled == false, \"!erc20-claim\");\r\n        // set owner and editor\r\n        d.owner = newOwner;\r\n        d.editors[d.editorEpoch][newOwner] = true;\r\n        // disable the ability to claim now that it's done\r\n        d.erc20OwnerClaimDisabled = true;\r\n        emit DemocOwnerSet(democHash, newOwner);\r\n        emit DemocClaimed(democHash);\r\n    }\r\n\r\n    function setDEditor(bytes32 democHash, address editor, bool canEdit) only_editors() external {\r\n        Democ storage d = democs[democHash];\r\n        d.editors[d.editorEpoch][editor] = canEdit;\r\n        emit DemocEditorSet(democHash, editor, canEdit);\r\n    }\r\n\r\n    function setDNoEditors(bytes32 democHash) only_editors() external {\r\n        democs[democHash].editorEpoch += 1;\r\n        emit DemocEditorsWiped(democHash);\r\n    }\r\n\r\n    function setDErc20(bytes32 democHash, address newErc20) only_editors() external {\r\n        democs[democHash].erc20 = newErc20;\r\n        erc20ToDemocs[newErc20].push(democHash);\r\n        emit DemocErc20Set(democHash, newErc20);\r\n    }\r\n\r\n    function dSetArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\r\n        bytes32 k = keccak256(key);\r\n        arbitraryData[democHash][k] = value;\r\n        emit DemocDataSet(democHash, k);\r\n    }\r\n\r\n    function dSetEditorArbitraryData(bytes32 democHash, bytes key, bytes value) only_editors() external {\r\n        bytes32 k = keccak256(_calcEditorKey(key));\r\n        arbitraryData[democHash][k] = value;\r\n        emit DemocDataSet(democHash, k);\r\n    }\r\n\r\n    function dAddCategory(bytes32 democHash, bytes32 name, bool hasParent, uint parent) only_editors() external {\r\n        uint catId = democCategories[democHash].nCategories;\r\n        democCategories[democHash].categories[catId].name = name;\r\n        if (hasParent) {\r\n            democCategories[democHash].categories[catId].hasParent = true;\r\n            democCategories[democHash].categories[catId].parent = parent;\r\n        }\r\n        democCategories[democHash].nCategories += 1;\r\n        emit DemocCatAdded(democHash, catId);\r\n    }\r\n\r\n    function dDeprecateCategory(bytes32 democHash, uint catId) only_editors() external {\r\n        democCategories[democHash].categories[catId].deprecated = true;\r\n        emit DemocCatDeprecated(democHash, catId);\r\n    }\r\n\r\n    function dSetCommunityBallotsEnabled(bytes32 democHash, bool enabled) only_editors() external {\r\n        democs[democHash].communityBallotsDisabled = !enabled;\r\n        emit DemocCommunityBallotsEnabled(democHash, enabled);\r\n    }\r\n\r\n    function dDisableErc20OwnerClaim(bytes32 democHash) only_editors() external {\r\n        democs[democHash].erc20OwnerClaimDisabled = true;\r\n        emit DemocErc20OwnerClaimDisabled(democHash);\r\n    }\r\n\r\n    //* ADD BALLOT TO RECORD */\r\n\r\n    function _commitBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) internal {\r\n        uint16 subBits;\r\n        subBits = BPackedUtils.packedToSubmissionBits(packed);\r\n\r\n        uint localBallotId = democs[democHash].allBallots.length;\r\n        democs[democHash].allBallots.push(ballotId);\r\n\r\n        // do this for anything that doesn't qualify as a community ballot\r\n        if (countTowardsLimit) {\r\n            democs[democHash].includedBasicBallots.push(ballotId);\r\n        }\r\n\r\n        emit NewBallot(democHash, localBallotId);\r\n    }\r\n\r\n    // what SVIndex uses to add a ballot\r\n    function dAddBallot(bytes32 democHash, uint ballotId, uint256 packed, bool countTowardsLimit) only_editors() external {\r\n        _commitBallot(democHash, ballotId, packed, countTowardsLimit);\r\n    }\r\n\r\n    /* democ getters */\r\n\r\n    function getDOwner(bytes32 democHash) external view returns (address) {\r\n        return democs[democHash].owner;\r\n    }\r\n\r\n    function isDEditor(bytes32 democHash, address editor) external view returns (bool) {\r\n        Democ storage d = democs[democHash];\r\n        // allow either an editor or always the owner\r\n        return d.editors[d.editorEpoch][editor] || editor == d.owner;\r\n    }\r\n\r\n    function getDHash(bytes13 prefix) external view returns (bytes32) {\r\n        return democPrefixToHash[prefix];\r\n    }\r\n\r\n    function getDInfo(bytes32 democHash) external view returns (address erc20, address owner, uint256 nBallots) {\r\n        return (democs[democHash].erc20, democs[democHash].owner, democs[democHash].allBallots.length);\r\n    }\r\n\r\n    function getDErc20(bytes32 democHash) external view returns (address) {\r\n        return democs[democHash].erc20;\r\n    }\r\n\r\n    function getDArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\r\n        return arbitraryData[democHash][keccak256(key)];\r\n    }\r\n\r\n    function getDEditorArbitraryData(bytes32 democHash, bytes key) external view returns (bytes) {\r\n        return arbitraryData[democHash][keccak256(_calcEditorKey(key))];\r\n    }\r\n\r\n    function getDBallotsN(bytes32 democHash) external view returns (uint256) {\r\n        return democs[democHash].allBallots.length;\r\n    }\r\n\r\n    function getDBallotID(bytes32 democHash, uint256 n) external view returns (uint ballotId) {\r\n        return democs[democHash].allBallots[n];\r\n    }\r\n\r\n    function getDCountedBasicBallotsN(bytes32 democHash) external view returns (uint256) {\r\n        return democs[democHash].includedBasicBallots.length;\r\n    }\r\n\r\n    function getDCountedBasicBallotID(bytes32 democHash, uint256 n) external view returns (uint256) {\r\n        return democs[democHash].includedBasicBallots[n];\r\n    }\r\n\r\n    function getDCategoriesN(bytes32 democHash) external view returns (uint) {\r\n        return democCategories[democHash].nCategories;\r\n    }\r\n\r\n    function getDCategory(bytes32 democHash, uint catId) external view returns (bool deprecated, bytes32 name, bool hasParent, uint256 parent) {\r\n        deprecated = democCategories[democHash].categories[catId].deprecated;\r\n        name = democCategories[democHash].categories[catId].name;\r\n        hasParent = democCategories[democHash].categories[catId].hasParent;\r\n        parent = democCategories[democHash].categories[catId].parent;\r\n    }\r\n\r\n    function getDCommBallotsEnabled(bytes32 democHash) external view returns (bool) {\r\n        return !democs[democHash].communityBallotsDisabled;\r\n    }\r\n\r\n    function getDErc20OwnerClaimEnabled(bytes32 democHash) external view returns (bool) {\r\n        return !democs[democHash].erc20OwnerClaimDisabled;\r\n    }\r\n\r\n    /* util for calculating editor key */\r\n\r\n    function _calcEditorKey(bytes key) internal pure returns (bytes) {\r\n        return abi.encodePacked(\"editor.\", key);\r\n    }\r\n}\r\n\r\ncontract IxPaymentsIface is hasVersion, ixPaymentEvents, permissioned, CanReclaimToken, payoutAllCSettable {\r\n    /* in emergency break glass */\r\n    function emergencySetOwner(address newOwner) external;\r\n\r\n    /* financial calcluations */\r\n    function weiBuysHowManySeconds(uint amount) public view returns (uint secs);\r\n    function weiToCents(uint w) public view returns (uint);\r\n    function centsToWei(uint c) public view returns (uint);\r\n\r\n    /* account management */\r\n    function payForDemocracy(bytes32 democHash) external payable;\r\n    function doFreeExtension(bytes32 democHash) external;\r\n    function downgradeToBasic(bytes32 democHash) external;\r\n    function upgradeToPremium(bytes32 democHash) external;\r\n\r\n    /* account status - getters */\r\n    function accountInGoodStanding(bytes32 democHash) external view returns (bool);\r\n    function getSecondsRemaining(bytes32 democHash) external view returns (uint);\r\n    function getPremiumStatus(bytes32 democHash) external view returns (bool);\r\n    function getFreeExtension(bytes32 democHash) external view returns (bool);\r\n    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension);\r\n    function getDenyPremium(bytes32 democHash) external view returns (bool);\r\n\r\n    /* admin utils for accounts */\r\n    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) external;\r\n\r\n    /* admin setters global */\r\n    function setPayTo(address) external;\r\n    function setMinorEditsAddr(address) external;\r\n    function setBasicCentsPricePer30Days(uint amount) external;\r\n    function setBasicBallotsPer30Days(uint amount) external;\r\n    function setPremiumMultiplier(uint8 amount) external;\r\n    function setWeiPerCent(uint) external;\r\n    function setFreeExtension(bytes32 democHash, bool hasFreeExt) external;\r\n    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) external;\r\n    function setMinWeiForDInit(uint amount) external;\r\n\r\n    /* global getters */\r\n    function getBasicCentsPricePer30Days() external view returns(uint);\r\n    function getBasicExtraBallotFeeWei() external view returns (uint);\r\n    function getBasicBallotsPer30Days() external view returns (uint);\r\n    function getPremiumMultiplier() external view returns (uint8);\r\n    function getPremiumCentsPricePer30Days() external view returns (uint);\r\n    function getWeiPerCent() external view returns (uint weiPerCent);\r\n    function getUsdEthExchangeRate() external view returns (uint centsPerEth);\r\n    function getMinWeiForDInit() external view returns (uint);\r\n\r\n    /* payments stuff */\r\n    function getPaymentLogN() external view returns (uint);\r\n    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue);\r\n}\r\n\r\ncontract SVPayments is IxPaymentsIface {\r\n    uint constant VERSION = 2;\r\n\r\n    struct Account {\r\n        bool isPremium;\r\n        uint lastPaymentTs;\r\n        uint paidUpTill;\r\n        uint lastUpgradeTs;  // timestamp of the last time it was upgraded to premium\r\n    }\r\n\r\n    struct PaymentLog {\r\n        bool _external;\r\n        bytes32 _democHash;\r\n        uint _seconds;\r\n        uint _ethValue;\r\n    }\r\n\r\n    // this is an address that's only allowed to make minor edits\r\n    // e.g. setExchangeRate, setDenyPremium, giveTimeToDemoc\r\n    address public minorEditsAddr;\r\n\r\n    // payment details\r\n    uint basicCentsPricePer30Days = 125000; // $1250/mo\r\n    uint basicBallotsPer30Days = 10;\r\n    uint8 premiumMultiplier = 5;\r\n    uint weiPerCent = 0.000016583747 ether;  // $603, 4th June 2018\r\n\r\n    uint minWeiForDInit = 1;  // minimum 1 wei - match existing behaviour in SVIndex\r\n\r\n    mapping (bytes32 => Account) accounts;\r\n    PaymentLog[] payments;\r\n\r\n    // can set this on freeExtension democs to deny them premium upgrades\r\n    mapping (bytes32 => bool) denyPremium;\r\n    // this is used for non-profits or organisations that have perpetual licenses, etc\r\n    mapping (bytes32 => bool) freeExtension;\r\n\r\n\r\n    /* BREAK GLASS IN CASE OF EMERGENCY */\r\n    // this is included here because something going wrong with payments is possibly\r\n    // the absolute worst case. Note: does this have negligable benefit if the other\r\n    // contracts are compromised? (e.g. by a leaked privkey)\r\n    address public emergencyAdmin;\r\n    function emergencySetOwner(address newOwner) external {\r\n        require(msg.sender == emergencyAdmin, \"!emergency-owner\");\r\n        owner = newOwner;\r\n    }\r\n    /* END BREAK GLASS */\r\n\r\n\r\n    constructor(address _emergencyAdmin) payoutAllCSettable(msg.sender) public {\r\n        emergencyAdmin = _emergencyAdmin;\r\n        assert(_emergencyAdmin != address(0));\r\n    }\r\n\r\n    /* base SCs */\r\n\r\n    function getVersion() external pure returns (uint) {\r\n        return VERSION;\r\n    }\r\n\r\n    function() payable public {\r\n        _getPayTo().transfer(msg.value);\r\n    }\r\n\r\n    function _modAccountBalance(bytes32 democHash, uint additionalSeconds) internal {\r\n        uint prevPaidTill = accounts[democHash].paidUpTill;\r\n        if (prevPaidTill < now) {\r\n            prevPaidTill = now;\r\n        }\r\n\r\n        accounts[democHash].paidUpTill = prevPaidTill + additionalSeconds;\r\n        accounts[democHash].lastPaymentTs = now;\r\n    }\r\n\r\n    /* Financial Calculations */\r\n\r\n    function weiBuysHowManySeconds(uint amount) public view returns (uint) {\r\n        uint centsPaid = weiToCents(amount);\r\n        // multiply by 10**18 to ensure we make rounding errors insignificant\r\n        uint monthsOffsetPaid = ((10 ** 18) * centsPaid) / basicCentsPricePer30Days;\r\n        uint secondsOffsetPaid = monthsOffsetPaid * (30 days);\r\n        uint additionalSeconds = secondsOffsetPaid / (10 ** 18);\r\n        return additionalSeconds;\r\n    }\r\n\r\n    function weiToCents(uint w) public view returns (uint) {\r\n        return w / weiPerCent;\r\n    }\r\n\r\n    function centsToWei(uint c) public view returns (uint) {\r\n        return c * weiPerCent;\r\n    }\r\n\r\n    /* account management */\r\n\r\n    function payForDemocracy(bytes32 democHash) external payable {\r\n        require(msg.value > 0, \"need to send some ether to make payment\");\r\n\r\n        uint additionalSeconds = weiBuysHowManySeconds(msg.value);\r\n\r\n        if (accounts[democHash].isPremium) {\r\n            additionalSeconds /= premiumMultiplier;\r\n        }\r\n\r\n        if (additionalSeconds >= 1) {\r\n            _modAccountBalance(democHash, additionalSeconds);\r\n        }\r\n        payments.push(PaymentLog(false, democHash, additionalSeconds, msg.value));\r\n        emit AccountPayment(democHash, additionalSeconds);\r\n\r\n        _getPayTo().transfer(msg.value);\r\n    }\r\n\r\n    function doFreeExtension(bytes32 democHash) external {\r\n        require(freeExtension[democHash], \"!free\");\r\n        uint newPaidUpTill = now + 60 days;\r\n        accounts[democHash].paidUpTill = newPaidUpTill;\r\n        emit FreeExtension(democHash);\r\n    }\r\n\r\n    function downgradeToBasic(bytes32 democHash) only_editors() external {\r\n        require(accounts[democHash].isPremium, \"!premium\");\r\n        accounts[democHash].isPremium = false;\r\n        // convert premium minutes to basic\r\n        uint paidTill = accounts[democHash].paidUpTill;\r\n        uint timeRemaining = SafeMath.subToZero(paidTill, now);\r\n        // if we have time remaining: convert it\r\n        if (timeRemaining > 0) {\r\n            // prevent accounts from downgrading if they have time remaining\r\n            // and upgraded less than 24hrs ago\r\n            require(accounts[democHash].lastUpgradeTs < (now - 24 hours), \"downgrade-too-soon\");\r\n            timeRemaining *= premiumMultiplier;\r\n            accounts[democHash].paidUpTill = now + timeRemaining;\r\n        }\r\n        emit DowngradeToBasic(democHash);\r\n    }\r\n\r\n    function upgradeToPremium(bytes32 democHash) only_editors() external {\r\n        require(denyPremium[democHash] == false, \"upgrade-denied\");\r\n        require(!accounts[democHash].isPremium, \"!basic\");\r\n        accounts[democHash].isPremium = true;\r\n        // convert basic minutes to premium minutes\r\n        uint paidTill = accounts[democHash].paidUpTill;\r\n        uint timeRemaining = SafeMath.subToZero(paidTill, now);\r\n        // if we have time remaning then convert it - otherwise don't need to do anything\r\n        if (timeRemaining > 0) {\r\n            timeRemaining /= premiumMultiplier;\r\n            accounts[democHash].paidUpTill = now + timeRemaining;\r\n        }\r\n        accounts[democHash].lastUpgradeTs = now;\r\n        emit UpgradedToPremium(democHash);\r\n    }\r\n\r\n    /* account status - getters */\r\n\r\n    function accountInGoodStanding(bytes32 democHash) external view returns (bool) {\r\n        return accounts[democHash].paidUpTill >= now;\r\n    }\r\n\r\n    function getSecondsRemaining(bytes32 democHash) external view returns (uint) {\r\n        return SafeMath.subToZero(accounts[democHash].paidUpTill, now);\r\n    }\r\n\r\n    function getPremiumStatus(bytes32 democHash) external view returns (bool) {\r\n        return accounts[democHash].isPremium;\r\n    }\r\n\r\n    function getFreeExtension(bytes32 democHash) external view returns (bool) {\r\n        return freeExtension[democHash];\r\n    }\r\n\r\n    function getAccount(bytes32 democHash) external view returns (bool isPremium, uint lastPaymentTs, uint paidUpTill, bool hasFreeExtension) {\r\n        isPremium = accounts[democHash].isPremium;\r\n        lastPaymentTs = accounts[democHash].lastPaymentTs;\r\n        paidUpTill = accounts[democHash].paidUpTill;\r\n        hasFreeExtension = freeExtension[democHash];\r\n    }\r\n\r\n    function getDenyPremium(bytes32 democHash) external view returns (bool) {\r\n        return denyPremium[democHash];\r\n    }\r\n\r\n    /* admin utils for accounts */\r\n\r\n    function giveTimeToDemoc(bytes32 democHash, uint additionalSeconds, bytes32 ref) owner_or(minorEditsAddr) external {\r\n        _modAccountBalance(democHash, additionalSeconds);\r\n        payments.push(PaymentLog(true, democHash, additionalSeconds, 0));\r\n        emit GrantedAccountTime(democHash, additionalSeconds, ref);\r\n    }\r\n\r\n    /* admin setters global */\r\n\r\n    function setPayTo(address newPayTo) only_owner() external {\r\n        _setPayTo(newPayTo);\r\n        emit SetPayTo(newPayTo);\r\n    }\r\n\r\n    function setMinorEditsAddr(address a) only_owner() external {\r\n        minorEditsAddr = a;\r\n        emit SetMinorEditsAddr(a);\r\n    }\r\n\r\n    function setBasicCentsPricePer30Days(uint amount) only_owner() external {\r\n        basicCentsPricePer30Days = amount;\r\n        emit SetBasicCentsPricePer30Days(amount);\r\n    }\r\n\r\n    function setBasicBallotsPer30Days(uint amount) only_owner() external {\r\n        basicBallotsPer30Days = amount;\r\n        emit SetBallotsPer30Days(amount);\r\n    }\r\n\r\n    function setPremiumMultiplier(uint8 m) only_owner() external {\r\n        premiumMultiplier = m;\r\n        emit SetPremiumMultiplier(m);\r\n    }\r\n\r\n    function setWeiPerCent(uint wpc) owner_or(minorEditsAddr) external {\r\n        weiPerCent = wpc;\r\n        emit SetExchangeRate(wpc);\r\n    }\r\n\r\n    function setFreeExtension(bytes32 democHash, bool hasFreeExt) owner_or(minorEditsAddr) external {\r\n        freeExtension[democHash] = hasFreeExt;\r\n        emit SetFreeExtension(democHash, hasFreeExt);\r\n    }\r\n\r\n    function setDenyPremium(bytes32 democHash, bool isPremiumDenied) owner_or(minorEditsAddr) external {\r\n        denyPremium[democHash] = isPremiumDenied;\r\n        emit SetDenyPremium(democHash, isPremiumDenied);\r\n    }\r\n\r\n    function setMinWeiForDInit(uint amount) owner_or(minorEditsAddr) external {\r\n        minWeiForDInit = amount;\r\n        emit SetMinWeiForDInit(amount);\r\n    }\r\n\r\n    /* global getters */\r\n\r\n    function getBasicCentsPricePer30Days() external view returns (uint) {\r\n        return basicCentsPricePer30Days;\r\n    }\r\n\r\n    function getBasicExtraBallotFeeWei() external view returns (uint) {\r\n        return centsToWei(basicCentsPricePer30Days / basicBallotsPer30Days);\r\n    }\r\n\r\n    function getBasicBallotsPer30Days() external view returns (uint) {\r\n        return basicBallotsPer30Days;\r\n    }\r\n\r\n    function getPremiumMultiplier() external view returns (uint8) {\r\n        return premiumMultiplier;\r\n    }\r\n\r\n    function getPremiumCentsPricePer30Days() external view returns (uint) {\r\n        return _premiumPricePer30Days();\r\n    }\r\n\r\n    function _premiumPricePer30Days() internal view returns (uint) {\r\n        return uint(premiumMultiplier) * basicCentsPricePer30Days;\r\n    }\r\n\r\n    function getWeiPerCent() external view returns (uint) {\r\n        return weiPerCent;\r\n    }\r\n\r\n    function getUsdEthExchangeRate() external view returns (uint) {\r\n        // this returns cents per ether\r\n        return 1 ether / weiPerCent;\r\n    }\r\n\r\n    function getMinWeiForDInit() external view returns (uint) {\r\n        return minWeiForDInit;\r\n    }\r\n\r\n    /* payments stuff */\r\n\r\n    function getPaymentLogN() external view returns (uint) {\r\n        return payments.length;\r\n    }\r\n\r\n    function getPaymentLog(uint n) external view returns (bool _external, bytes32 _democHash, uint _seconds, uint _ethValue) {\r\n        _external = payments[n]._external;\r\n        _democHash = payments[n]._democHash;\r\n        _seconds = payments[n]._seconds;\r\n        _ethValue = payments[n]._ethValue;\r\n    }\r\n}\r\n\r\ninterface SvEnsIface {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external returns (bytes32);\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\ninterface ENSIface {\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed node, address owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n    function setSubnodeOwner(bytes32 node, bytes32 label, address owner) external;\r\n    function setResolver(bytes32 node, address resolver) external;\r\n    function setOwner(bytes32 node, address owner) external;\r\n    function setTTL(bytes32 node, uint64 ttl) external;\r\n    function owner(bytes32 node) external view returns (address);\r\n    function resolver(bytes32 node) external view returns (address);\r\n    function ttl(bytes32 node) external view returns (uint64);\r\n}\r\n\r\ncontract PublicResolver {\r\n\r\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\r\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\r\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\r\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\r\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    struct Record {\r\n        address addr;\r\n        bytes32 content;\r\n        string name;\r\n        PublicKey pubkey;\r\n        mapping(string=>string) text;\r\n        mapping(uint256=>bytes) abis;\r\n    }\r\n\r\n    ENSIface ens;\r\n\r\n    mapping (bytes32 => Record) records;\r\n\r\n    modifier only_owner(bytes32 node) {\r\n        require(ens.owner(node) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The ENS registrar contract.\r\n     */\r\n    constructor(ENSIface ensAddr) public {\r\n        ens = ensAddr;\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) public only_owner(node) {\r\n        records[node].addr = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Sets the content hash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The node to update.\r\n     * @param hash The content hash to set\r\n     */\r\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\r\n        records[node].content = hash;\r\n        emit ContentChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string name) public only_owner(node) {\r\n        records[node].name = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n\r\n        records[node].abis[contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n\r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\r\n        records[node].pubkey = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string key, string value) public only_owner(node) {\r\n        records[node].text[key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string key) public view returns (string) {\r\n        return records[node].text[key];\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\r\n        return (records[node].pubkey.x, records[node].pubkey.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\r\n        Record storage record = records[node];\r\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\r\n                data = record.abis[contentType];\r\n                return;\r\n            }\r\n        }\r\n        contentType = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) public view returns (string) {\r\n        return records[node].name;\r\n    }\r\n\r\n    /**\r\n     * Returns the content hash associated with an ENS node.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The ENS node to query.\r\n     * @return The associated content hash.\r\n     */\r\n    function content(bytes32 node) public view returns (bytes32) {\r\n        return records[node].content;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return records[node].addr;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID ||\r\n        interfaceID == CONTENT_INTERFACE_ID ||\r\n        interfaceID == NAME_INTERFACE_ID ||\r\n        interfaceID == ABI_INTERFACE_ID ||\r\n        interfaceID == PUBKEY_INTERFACE_ID ||\r\n        interfaceID == TEXT_INTERFACE_ID ||\r\n        interfaceID == INTERFACE_META_ID;\r\n    }\r\n}\r\n\r\nlibrary BytesLib {\r\n    function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) {\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            // Get a location of some free memory and store it in tempBytes as\r\n            // Solidity does for memory variables.\r\n            tempBytes := mload(0x40)\r\n\r\n            // Store the length of the first bytes array at the beginning of\r\n            // the memory for tempBytes.\r\n            let length := mload(_preBytes)\r\n            mstore(tempBytes, length)\r\n\r\n            // Maintain a memory counter for the current write location in the\r\n            // temp bytes array by adding the 32 bytes for the array length to\r\n            // the starting location.\r\n            let mc := add(tempBytes, 0x20)\r\n            // Stop copying when the memory counter reaches the length of the\r\n            // first bytes array.\r\n            let end := add(mc, length)\r\n\r\n            for {\r\n                // Initialize a copy counter to the start of the _preBytes data,\r\n                // 32 bytes into its memory.\r\n                let cc := add(_preBytes, 0x20)\r\n            } lt(mc, end) {\r\n                // Increase both counters by 32 bytes each iteration.\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                // Write the _preBytes data into the tempBytes memory 32 bytes\r\n                // at a time.\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Add the length of _postBytes to the current length of tempBytes\r\n            // and store it as the new length in the first 32 bytes of the\r\n            // tempBytes memory.\r\n            length := mload(_postBytes)\r\n            mstore(tempBytes, add(length, mload(tempBytes)))\r\n\r\n            // Move the memory counter back from a multiple of 0x20 to the\r\n            // actual end of the _preBytes data.\r\n            mc := end\r\n            // Stop copying when the memory counter reaches the new combined\r\n            // length of the arrays.\r\n            end := add(mc, length)\r\n\r\n            for {\r\n                let cc := add(_postBytes, 0x20)\r\n            } lt(mc, end) {\r\n                mc := add(mc, 0x20)\r\n                cc := add(cc, 0x20)\r\n            } {\r\n                mstore(mc, mload(cc))\r\n            }\r\n\r\n            // Update the free-memory pointer by padding our last write location\r\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\r\n            // next 32 byte block, then round down to the nearest multiple of\r\n            // 32. If the sum of the length of the two arrays is zero then add\r\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\r\n            mstore(0x40, and(\r\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\r\n              not(31) // Round down to the nearest 32 bytes.\r\n            ))\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\r\n        assembly {\r\n            // Read the first 32 bytes of _preBytes storage, which is the length\r\n            // of the array. (We don't need to use the offset into the slot\r\n            // because arrays use the entire slot.)\r\n            let fslot := sload(_preBytes_slot)\r\n            // Arrays of 31 bytes or less have an even value in their slot,\r\n            // while longer arrays have an odd value. The actual length is\r\n            // the slot divided by two for odd values, and the lowest order\r\n            // byte divided by two for even values.\r\n            // If the slot is even, bitwise and the slot with 255 and divide by\r\n            // two to get the length. If the slot is odd, bitwise and the slot\r\n            // with -1 and divide by two.\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n            let newlength := add(slength, mlength)\r\n            // slength can contain both the length and contents of the array\r\n            // if length < 32 bytes so let's prepare for that\r\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n            switch add(lt(slength, 32), lt(newlength, 32))\r\n            case 2 {\r\n                // Since the new array still fits in the slot, we just need to\r\n                // update the contents of the slot.\r\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\r\n                sstore(\r\n                    _preBytes_slot,\r\n                    // all the modifications to the slot are inside this\r\n                    // next block\r\n                    add(\r\n                        // we can just add to the slot contents because the\r\n                        // bytes we want to change are the LSBs\r\n                        fslot,\r\n                        add(\r\n                            mul(\r\n                                div(\r\n                                    // load the bytes from memory\r\n                                    mload(add(_postBytes, 0x20)),\r\n                                    // zero all bytes to the right\r\n                                    exp(0x100, sub(32, mlength))\r\n                                ),\r\n                                // and now shift left the number of bytes to\r\n                                // leave space for the length in the slot\r\n                                exp(0x100, sub(32, newlength))\r\n                            ),\r\n                            // increase length by the double of the memory\r\n                            // bytes length\r\n                            mul(mlength, 2)\r\n                        )\r\n                    )\r\n                )\r\n            }\r\n            case 1 {\r\n                // The stored value fits in the slot, but the combined value\r\n                // will exceed it.\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // The contents of the _postBytes array start 32 bytes into\r\n                // the structure. Our first read should obtain the `submod`\r\n                // bytes that can fit into the unused space in the last word\r\n                // of the stored array. To get this, we read 32 bytes starting\r\n                // from `submod`, so the data we read overlaps with the array\r\n                // contents by `submod` bytes. Masking the lowest-order\r\n                // `submod` bytes allows us to add that value directly to the\r\n                // stored value.\r\n\r\n                let submod := sub(32, slength)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(\r\n                    sc,\r\n                    add(\r\n                        and(\r\n                            fslot,\r\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\r\n                        ),\r\n                        and(mload(mc), mask)\r\n                    )\r\n                )\r\n\r\n                for {\r\n                    mc := add(mc, 0x20)\r\n                    sc := add(sc, 1)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n            default {\r\n                // get the keccak hash to get the contents of the array\r\n                mstore(0x0, _preBytes_slot)\r\n                // Start copying to the last used word of the stored array.\r\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\r\n\r\n                // save new length\r\n                sstore(_preBytes_slot, add(mul(newlength, 2), 1))\r\n\r\n                // Copy over the first `submod` bytes of the new data as in\r\n                // case 1 above.\r\n                let slengthmod := mod(slength, 32)\r\n                let mlengthmod := mod(mlength, 32)\r\n                let submod := sub(32, slengthmod)\r\n                let mc := add(_postBytes, submod)\r\n                let end := add(_postBytes, mlength)\r\n                let mask := sub(exp(0x100, submod), 1)\r\n\r\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\r\n\r\n                for {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } lt(mc, end) {\r\n                    sc := add(sc, 1)\r\n                    mc := add(mc, 0x20)\r\n                } {\r\n                    sstore(sc, mload(mc))\r\n                }\r\n\r\n                mask := exp(0x100, sub(mc, end))\r\n\r\n                sstore(sc, mul(div(mload(mc), mask), mask))\r\n            }\r\n        }\r\n    }\r\n\r\n    function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) {\r\n        require(_bytes.length >= (_start + _length));\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes _bytes, uint _start) internal  pure returns (address) {\r\n        require(_bytes.length >= (_start + 20));\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n\r\n    function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) {\r\n        require(_bytes.length >= (_start + 32));\r\n        uint256 tempUint;\r\n\r\n        assembly {\r\n            tempUint := mload(add(add(_bytes, 0x20), _start))\r\n        }\r\n\r\n        return tempUint;\r\n    }\r\n\r\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            let length := mload(_preBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(length, mload(_postBytes))\r\n            case 1 {\r\n                // cb is a circuit breaker in the for loop since there's\r\n                //  no said feature for inline assembly loops\r\n                // cb = 1 - don't breaker\r\n                // cb = 0 - break\r\n                let cb := 1\r\n\r\n                let mc := add(_preBytes, 0x20)\r\n                let end := add(mc, length)\r\n\r\n                for {\r\n                    let cc := add(_postBytes, 0x20)\r\n                // the next line is the loop condition:\r\n                // while(uint(mc < end) + cb == 2)\r\n                } eq(add(lt(mc, end), cb), 2) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    // if any of these checks fails then arrays are not equal\r\n                    if iszero(eq(mload(mc), mload(cc))) {\r\n                        // unsuccess:\r\n                        success := 0\r\n                        cb := 0\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n\r\n    function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) {\r\n        bool success = true;\r\n\r\n        assembly {\r\n            // we know _preBytes_offset is 0\r\n            let fslot := sload(_preBytes_slot)\r\n            // Decode the length of the stored array like in concatStorage().\r\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\r\n            let mlength := mload(_postBytes)\r\n\r\n            // if lengths don't match the arrays are not equal\r\n            switch eq(slength, mlength)\r\n            case 1 {\r\n                // slength can contain both the length and contents of the array\r\n                // if length < 32 bytes so let's prepare for that\r\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\r\n                if iszero(iszero(slength)) {\r\n                    switch lt(slength, 32)\r\n                    case 1 {\r\n                        // blank the last byte which is the length\r\n                        fslot := mul(div(fslot, 0x100), 0x100)\r\n\r\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\r\n                            // unsuccess:\r\n                            success := 0\r\n                        }\r\n                    }\r\n                    default {\r\n                        // cb is a circuit breaker in the for loop since there's\r\n                        //  no said feature for inline assembly loops\r\n                        // cb = 1 - don't breaker\r\n                        // cb = 0 - break\r\n                        let cb := 1\r\n\r\n                        // get the keccak hash to get the contents of the array\r\n                        mstore(0x0, _preBytes_slot)\r\n                        let sc := keccak256(0x0, 0x20)\r\n\r\n                        let mc := add(_postBytes, 0x20)\r\n                        let end := add(mc, mlength)\r\n\r\n                        // the next line is the loop condition:\r\n                        // while(uint(mc < end) + cb == 2)\r\n                        for {} eq(add(lt(mc, end), cb), 2) {\r\n                            sc := add(sc, 1)\r\n                            mc := add(mc, 0x20)\r\n                        } {\r\n                            if iszero(eq(sload(sc), mload(mc))) {\r\n                                // unsuccess:\r\n                                success := 0\r\n                                cb := 0\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            default {\r\n                // unsuccess:\r\n                success := 0\r\n            }\r\n        }\r\n\r\n        return success;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLibV7.DB storage\"},{\"name\":\"voteData\",\"type\":\"bytes32\"},{\"name\":\"extra\",\"type\":\"bytes\"}],\"name\":\"submitVoteAlways\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLibV7.DB storage\"},{\"name\":\"proxyReq\",\"type\":\"bytes32[5]\"},{\"name\":\"extra\",\"type\":\"bytes\"}],\"name\":\"submitProxyVote\",\"outputs\":[{\"name\":\"voter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLibV7.DB storage\"},{\"name\":\"i\",\"type\":\"uint256\"}],\"name\":\"getSponsor\",\"outputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLibV7.DB storage\"},{\"name\":\"_specHash\",\"type\":\"bytes32\"},{\"name\":\"_packed\",\"type\":\"uint256\"},{\"name\":\"ix\",\"type\":\"IxIface\"},{\"name\":\"ballotOwner\",\"type\":\"address\"},{\"name\":\"extraData\",\"type\":\"bytes16\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLibV7.DB storage\"},{\"name\":\"newEndTime\",\"type\":\"uint64\"}],\"name\":\"setEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLibV7.DB storage\"},{\"name\":\"proxyReq\",\"type\":\"bytes32[5]\"},{\"name\":\"extra\",\"type\":\"bytes\"}],\"name\":\"submitProxyVoteAlways\",\"outputs\":[{\"name\":\"voter\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"BBLibV7.DB storage\"},{\"name\":\"voteData\",\"type\":\"bytes32\"},{\"name\":\"extra\",\"type\":\"bytes\"}],\"name\":\"submitVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_specHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"startTs\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"endTs\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"submissionBits\",\"type\":\"uint16\"}],\"name\":\"CreatedBallot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"voteId\",\"type\":\"uint256\"}],\"name\":\"SuccessfulVote\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"secretKey\",\"type\":\"bytes32\"}],\"name\":\"SeckeyRevealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TestingEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"DeprecatedContract\",\"type\":\"event\"}]","ContractName":"BBLibV7","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5fc81011f2902f0434d17a9ac4d8b19f026214d421b124e58939ac92be192b5c"}]}