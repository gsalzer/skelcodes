{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n}\r\n\r\n/* Controls game play state and access rights for game functions\r\n * @title Operational Control\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n * Inspired and adapted from contract created by OpenZeppelin\r\n * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\r\n */\r\ncontract OperationalControl {\r\n    // Facilitates access & control for the game.\r\n    // Roles:\r\n    //  -The Game Managers (Primary/Secondary): Has universal control of all game elements (No ability to withdraw)\r\n    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\r\n\r\n    /// @dev Emited when contract is upgraded\r\n    event ContractUpgrade(address newContract);\r\n\r\n    mapping (address => bool) allowedAddressList;\r\n    \r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public gameManagerPrimary;\r\n    address public gameManagerSecondary;\r\n    address public bankManager;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Operation modifiers for limiting access\r\n    modifier onlyGameManager() {\r\n        require(msg.sender == gameManagerPrimary || msg.sender == gameManagerSecondary);\r\n        _;\r\n    }\r\n\r\n    /// @dev Operation modifiers for limiting access to only Banker\r\n    modifier onlyBanker() {\r\n        require(msg.sender == bankManager);\r\n        _;\r\n    }\r\n\r\n    /// @dev Operation modifiers for access to any Manager\r\n    modifier anyOperator() {\r\n        require(\r\n            msg.sender == gameManagerPrimary ||\r\n            msg.sender == gameManagerSecondary ||\r\n            msg.sender == bankManager\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the GM.\r\n    function setPrimaryGameManager(address _newGM) external onlyGameManager {\r\n        require(_newGM != address(0));\r\n\r\n        gameManagerPrimary = _newGM;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the GM.\r\n    function setSecondaryGameManager(address _newGM) external onlyGameManager {\r\n        require(_newGM != address(0));\r\n\r\n        gameManagerSecondary = _newGM;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Banker.\r\n    function setBanker(address _newBK) external onlyBanker {\r\n        require(_newBK != address(0));\r\n\r\n        bankManager = _newBK;\r\n    }\r\n\r\n    function updateAllowedAddressesList (address _newAddress, bool _value) external onlyGameManager {\r\n\r\n        require (_newAddress != address(0));\r\n\r\n        allowedAddressList[_newAddress] = _value;\r\n        \r\n    }\r\n\r\n    modifier canTransact() { \r\n        require (msg.sender == gameManagerPrimary\r\n            || msg.sender == gameManagerSecondary\r\n            || allowedAddressList[msg.sender]); \r\n        _; \r\n    }\r\n    \r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any Operator role to pause the contract.\r\n    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)\r\n    function pause() external onlyGameManager whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\r\n    /// @notice This is public rather than external so it can be called by derived contracts. \r\n    function unpause() public onlyGameManager whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n}\r\n\r\n/* @title Interface for MLBNFT Contract\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n */\r\ncontract MLBNFT {\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function setApprovalForAll(address _to, bool _approved) public;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function createPromoCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) external returns (uint256);\r\n    function createSeedCollectible(uint8 _teamId, uint8 _posId, uint256 _attributes, address _owner, uint256 _gameId, uint256 _playerOverrideId, uint256 _mlbPlayerId) public returns (uint256);\r\n    function checkIsAttached(uint256 _tokenId) public view returns (uint256);\r\n    function getTeamId(uint256 _tokenId) external view returns (uint256);\r\n    function getPlayerId(uint256 _tokenId) external view returns (uint256 playerId);\r\n    function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n}\r\n\r\n/* @title Interface for ETH Escrow Contract\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n */\r\ncontract LSEscrow {\r\n    function escrowTransfer(address seller, address buyer, uint256 currentPrice, uint256 marketsCut) public returns(bool);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n    /**\r\n    * @dev Magic value to be returned upon successful reception of an NFT\r\n    *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`,\r\n    *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    */\r\n    bytes4 public constant ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    /**\r\n    * @notice Handle the receipt of an NFT\r\n    * @dev The ERC721 smart contract calls this function on the recipient\r\n    *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n    *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    *  than the magic value MUST result in the transaction being reverted.\r\n    *  Note: the contract address is always the message sender.\r\n    * @param _from The sending address\r\n    * @param _tokenId The NFT identifier which is being transfered\r\n    * @param _data Additional data with no specified format\r\n    * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    */\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        returns(bytes4);\r\n}\r\n\r\ncontract ERC721Holder is ERC721Receiver {\r\n    function onERC721Received(address,address, uint256, bytes) public returns(bytes4) {\r\n        return ERC721_RECEIVED;\r\n    }\r\n}\r\n\r\n/* Contains models, variables, and internal methods for the ERC-721 sales.\r\n * @title Sale Base\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n */\r\ncontract SaleBase is OperationalControl, ERC721Holder {\r\n    using SafeMath for uint256;\r\n    \r\n    /// EVENTS \r\n\r\n    event SaleCreated(uint256 tokenID, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt);\r\n    event TeamSaleCreated(uint256[9] tokenIDs, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt);\r\n    event SaleWinner(uint256 tokenID, uint256 totalPrice, address winner);\r\n    event TeamSaleWinner(uint256[9] tokenIDs, uint256 totalPrice, address winner);\r\n    event SaleCancelled(uint256 tokenID, address sellerAddress);\r\n    event EtherWithdrawed(uint256 value);\r\n\r\n    /// STORAGE\r\n\r\n    /**\r\n     * @dev        Represents an Sale on MLB CryptoBaseball (ERC721)\r\n     */\r\n    struct Sale {\r\n        // Current owner of NFT (ERC721)\r\n        address seller;\r\n        // Price (in wei) at beginning of sale\r\n        uint256 startingPrice;\r\n        // Price (in wei) at end of sale\r\n        uint256 endingPrice;\r\n        // Duration (in seconds) of sale\r\n        uint256 duration;\r\n        // Time when sale started\r\n        // NOTE: 0 if this sale has been concluded\r\n        uint256 startedAt;\r\n        // ERC721 AssetID\r\n        uint256[9] tokenIds;\r\n    }\r\n\r\n    /**\r\n     * @dev        Reference to contract tracking ownership & asset details\r\n     */\r\n    MLBNFT public nonFungibleContract;\r\n\r\n    /**\r\n     * @dev        Reference to contract tracking ownership & asset details\r\n     */\r\n    LSEscrow public LSEscrowContract;\r\n\r\n    /**\r\n     * @dev   Defining a GLOBAL delay time for the auctions to start accepting bidExcess\r\n     * @notice This variable is made to delay the bid process.\r\n     */\r\n    uint256 public BID_DELAY_TIME = 0;\r\n\r\n    // Cut owner takes on each sale, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut = 500; //5%\r\n\r\n    // Map from token to their corresponding sale.\r\n    mapping (uint256 => Sale) tokenIdToSale;\r\n\r\n    /**\r\n     * @dev        Returns true if the claimant owns the token.\r\n     * @param      _claimant  The claimant\r\n     * @param      _tokenId   The token identifier\r\n     */\r\n    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);\r\n    }\r\n\r\n    /**\r\n     * @dev        Internal function to ESCROW\r\n     * @notice     Escrows the ERC721 Token, assigning ownership to this contract. Throws if the escrow fails.\r\n     * @param      _owner    The owner\r\n     * @param      _tokenId  The token identifier\r\n     */\r\n    function _escrow(address _owner, uint256 _tokenId) internal {\r\n        nonFungibleContract.safeTransferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev        Internal Transfer function\r\n     * @notice     Transfers an ERC721 Token owned by this contract to another address. Returns true if the transfer succeeds.\r\n     * @param      _owner     The owner\r\n     * @param      _receiver  The receiver\r\n     * @param      _tokenId   The token identifier\r\n     */\r\n    function _transfer(address _owner, address _receiver, uint256 _tokenId) internal {\r\n        nonFungibleContract.transferFrom(_owner, _receiver, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev        Internal Function to add Sale, which duration check (atleast 1 min duration required)\r\n     * @notice     Adds an sale to the list of open sales. Also fires the SaleCreated event.\r\n     * @param      _tokenId  The token identifier\r\n     * @param      _sale     The sale\r\n     */\r\n    function _addSale(uint256 _tokenId, Sale _sale) internal {\r\n        // Require that all sales have a duration of\r\n        // at least one minute.\r\n        require(_sale.duration >= 1 minutes);\r\n        \r\n        tokenIdToSale[_tokenId] = _sale;\r\n\r\n        emit SaleCreated(\r\n            uint256(_tokenId),\r\n            uint256(_sale.startingPrice),\r\n            uint256(_sale.endingPrice),\r\n            uint256(_sale.duration),\r\n            uint256(_sale.startedAt)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev        Internal Function to add Team Sale, which duration check (atleast 1 min duration required)\r\n     * @notice     Adds an sale to the list of open sales. Also fires the SaleCreated event.\r\n     * @param      _tokenIds  The token identifiers\r\n     * @param      _sale      The sale\r\n     */\r\n    function _addTeamSale(uint256[9] _tokenIds, Sale _sale) internal {\r\n        // Require that all sales have a duration of\r\n        // at least one minute.\r\n        require(_sale.duration >= 1 minutes);\r\n        \r\n        for(uint ii = 0; ii < 9; ii++) {\r\n            require(_tokenIds[ii] != 0);\r\n            require(nonFungibleContract.exists(_tokenIds[ii]));\r\n\r\n            tokenIdToSale[_tokenIds[ii]] = _sale;\r\n        }\r\n\r\n        emit TeamSaleCreated(\r\n            _tokenIds,\r\n            uint256(_sale.startingPrice),\r\n            uint256(_sale.endingPrice),\r\n            uint256(_sale.duration),\r\n            uint256(_sale.startedAt)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev        Facilites Sale cancellation. Also removed the Sale from the array\r\n     * @notice     Cancels an sale (given the collectibleID is not 0). SaleCancelled Event\r\n     * @param      _tokenId  The token identifier\r\n     * @param      _seller   The seller\r\n     */\r\n    function _cancelSale(uint256 _tokenId, address _seller) internal {\r\n        Sale memory saleItem = tokenIdToSale[_tokenId];\r\n\r\n        //Check for team sale\r\n        if(saleItem.tokenIds[1] != 0) {\r\n            for(uint ii = 0; ii < 9; ii++) {\r\n                _removeSale(saleItem.tokenIds[ii]);\r\n                _transfer(address(this), _seller, saleItem.tokenIds[ii]);\r\n            }\r\n            emit SaleCancelled(_tokenId, _seller);\r\n        } else {\r\n            _removeSale(_tokenId);\r\n            _transfer(address(this), _seller, _tokenId);\r\n            emit SaleCancelled(_tokenId, _seller);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Computes the price and transfers winnings. Does NOT transfer ownership of token.\r\n     * @notice     Internal function, helps in making the bid and transferring asset if successful\r\n     * @param      _tokenId    The token identifier\r\n     * @param      _bidAmount  The bid amount\r\n     */\r\n    function _bid(uint256 _tokenId, uint256 _bidAmount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        // Get a reference to the sale struct\r\n        Sale storage _sale = tokenIdToSale[_tokenId];\r\n        uint256[9] memory tokenIdsStore = tokenIdToSale[_tokenId].tokenIds;\r\n        \r\n        // Explicitly check that this sale is currently live.\r\n        require(_isOnSale(_sale));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(_sale);\r\n        require(_bidAmount >= price);\r\n\r\n        // Grab a reference to the seller before the sale struct\r\n        // gets deleted.\r\n        address seller = _sale.seller;\r\n\r\n        // The bid is good! Remove the sale before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        if(tokenIdsStore[1] > 0) {\r\n            for(uint ii = 0; ii < 9; ii++) {\r\n                _removeSale(tokenIdsStore[ii]);\r\n            }\r\n        } else {\r\n            _removeSale(_tokenId);\r\n        }\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the marketplace's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            // value <= price)\r\n            uint256 marketsCut = _computeCut(price);\r\n            uint256 sellerProceeds = price.sub(marketsCut);\r\n\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        uint256 bidExcess = _bidAmount.sub(price);\r\n\r\n        // Return the funds. Similar to the previous transfer.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        // uint256 assetID, uint256 totalPrice, address winner, uint16 generation\r\n        if(tokenIdsStore[1] > 0) {\r\n            emit TeamSaleWinner(tokenIdsStore, price, msg.sender);\r\n        } else {\r\n            emit SaleWinner(_tokenId, price, msg.sender);\r\n        }\r\n        \r\n        return price;\r\n    }\r\n\r\n    /**\r\n     * @dev        Removes an sale from the list of open sales.\r\n     * @notice     Internal Function to remove sales\r\n     * @param      _tokenId  The token identifier\r\n     */\r\n    function _removeSale(uint256 _tokenId) internal {\r\n        delete tokenIdToSale[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev        Returns true if the FT (ERC721) is on sale.\r\n     * @notice     Internal function to check if an\r\n     * @param      _sale  The sale\r\n     */\r\n    function _isOnSale(Sale memory _sale) internal pure returns (bool) {\r\n        return (_sale.startedAt > 0);\r\n    }\r\n\r\n    /** @dev Returns current price of an FT (ERC721) on sale. Broken into two\r\n     *  functions (this one, that computes the duration from the sale\r\n     *  structure, and the other that does the price computation) so we\r\n     *  can easily test that the price computation works correctly.\r\n     */\r\n    function _currentPrice(Sale memory _sale)\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarnatees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _sale.startedAt.add(BID_DELAY_TIME)) {\r\n            secondsPassed = now.sub(_sale.startedAt.add(BID_DELAY_TIME));\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _sale.startingPrice,\r\n            _sale.endingPrice,\r\n            _sale.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    /** @dev Computes the current price of an sale. Factored out\r\n     *  from _currentPrice so we can run extensive unit tests.\r\n     *  When testing, make this function public and turn on\r\n     *  `Current price computation` test suite.\r\n     */\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our public functions carefully cap the maximum values for\r\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\r\n        //  also known to be non-zero (see the require() statement in\r\n        //  _addSale())\r\n        if (_secondsPassed >= _duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the sale, just return the end price.\r\n            return _endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that _startingPrice. Thus, this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Computes owner's cut of a sale.\r\n     * @param      _price  The price\r\n     */\r\n    function _computeCut(uint256 _price) internal view returns (uint256) {\r\n        return _price.mul(ownerCut).div(10000);\r\n    }\r\n}\r\n\r\n/* Clock sales functions and interfaces\r\n * @title SaleManager\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n */\r\ncontract SaleManager is SaleBase {\r\n\r\n    /// @dev MAPINGS\r\n    mapping (uint256 => uint256[3]) public lastTeamSalePrices;\r\n    mapping (uint256 => uint256) public lastSingleSalePrices;\r\n    mapping (uint256 => uint256) public seedTeamSaleCount;\r\n    uint256 public seedSingleSaleCount = 0;\r\n\r\n    /// @dev CONSTANTS\r\n    uint256 public constant SINGLE_SALE_MULTIPLIER = 35;\r\n    uint256 public constant TEAM_SALE_MULTIPLIER = 12;\r\n    uint256 public constant STARTING_PRICE = 10 finney;\r\n    uint256 public constant SALES_DURATION = 1 days;\r\n\r\n    bool public isBatchSupported = true;\r\n\r\n    /**\r\n     * @dev        Constructor creates a reference to the MLB_NFT Sale Manager contract\r\n     */\r\n    constructor() public {\r\n        require(ownerCut <= 10000); // You can't collect more than 100% silly ;)\r\n        require(msg.sender != address(0));\r\n        paused = true;\r\n        gameManagerPrimary = msg.sender;\r\n        gameManagerSecondary = msg.sender;\r\n        bankManager = msg.sender;\r\n    }\r\n\r\n    /// @dev Override unpause so it requires all external contract addresses\r\n    ///  to be set before contract can be unpaused. Also, we can't have\r\n    ///  newContractAddress set either, because then the contract was upgraded.\r\n    /// @notice This is public rather than external so we can call super.unpause\r\n    ///  without using an expensive CALL.\r\n    function unpause() public onlyGameManager whenPaused {\r\n        require(nonFungibleContract != address(0));\r\n\r\n        // Actually unpause the contract.\r\n        super.unpause();\r\n    }\r\n\r\n    /** @dev Remove all Ether from the contract, which is the owner's cuts\r\n     *  as well as any Ether sent directly to the contract address.\r\n     *  Always transfers to the NFT (ERC721) contract, but can be called either by\r\n     *  the owner or the NFT (ERC721) contract.\r\n     */\r\n    function _withdrawBalance() internal {\r\n        // We are using this boolean method to make sure that even if one fails it will still work\r\n        bankManager.transfer(address(this).balance);\r\n    }\r\n\r\n\r\n    /** @dev Reject all Ether from being sent here, unless it's from one of the\r\n     *  contracts. (Hopefully, we can prevent user accidents.)\r\n     *  @notice No tipping!\r\n     */\r\n    function() external payable {\r\n        address nftAddress = address(nonFungibleContract);\r\n        require(\r\n            msg.sender == address(this) || \r\n            msg.sender == gameManagerPrimary ||\r\n            msg.sender == gameManagerSecondary ||\r\n            msg.sender == bankManager ||\r\n            msg.sender == nftAddress ||\r\n            msg.sender == address(LSEscrowContract)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev        Creates and begins a new sale.\r\n     * @param      _tokenId        The token identifier\r\n     * @param      _startingPrice  The starting price\r\n     * @param      _endingPrice    The ending price\r\n     * @param      _duration       The duration\r\n     * @param      _seller         The seller\r\n     */\r\n    function _createSale(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n        internal\r\n    {\r\n        Sale memory sale = Sale(\r\n            _seller,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            now,\r\n            [_tokenId,0,0,0,0,0,0,0,0]\r\n        );\r\n        _addSale(_tokenId, sale);\r\n    }\r\n\r\n    /**\r\n     * @dev        Internal Function, helps in creating team sale\r\n     * @param      _tokenIds       The token identifiers\r\n     * @param      _startingPrice  The starting price\r\n     * @param      _endingPrice    The ending price\r\n     * @param      _duration       The duration\r\n     * @param      _seller         The seller\r\n     */\r\n    function _createTeamSale(\r\n        uint256[9] _tokenIds,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller)\r\n        internal {\r\n\r\n        Sale memory sale = Sale(\r\n            _seller,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            now,\r\n            _tokenIds\r\n        );\r\n\r\n        /// Add sale obj to all tokens\r\n        _addTeamSale(_tokenIds, sale);\r\n    }\r\n\r\n    /** @dev            Cancels an sale that hasn't been won yet. Returns the MLBNFT (ERC721) to original owner.\r\n     *  @notice         This is a state-modifying function that can be called while the contract is paused.\r\n     */\r\n    function cancelSale(uint256 _tokenId) external whenNotPaused {\r\n        Sale memory sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        address seller = sale.seller;\r\n        require(msg.sender == seller);\r\n        _cancelSale(_tokenId, seller);\r\n    }\r\n\r\n    /** @dev        Cancels an sale that hasn't been won yet. Returns the MLBNFT (ERC721) to original owner.\r\n     *  @notice     This is a state-modifying function that can be called while the contract is paused. Can be only called by the GameManagers\r\n     */\r\n    function cancelSaleWhenPaused(uint256 _tokenId) external whenPaused onlyGameManager {\r\n        Sale memory sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        address seller = sale.seller;\r\n        _cancelSale(_tokenId, seller);\r\n    }\r\n\r\n    /** \r\n     * @dev    Returns sales info for an CSLCollectibles (ERC721) on sale.\r\n     * @notice Fetches the details related to the Sale\r\n     * @param  _tokenId    ID of the token on sale\r\n     */\r\n    function getSale(uint256 _tokenId) external view returns (address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, uint256[9] tokenIds) {\r\n        Sale memory sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        return (\r\n            sale.seller,\r\n            sale.startingPrice,\r\n            sale.endingPrice,\r\n            sale.duration,\r\n            sale.startedAt,\r\n            sale.tokenIds\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev        Returns the current price of an sale.\r\n     * @param      _tokenId  The token identifier\r\n     */\r\n    function getCurrentPrice(uint256 _tokenId) external view returns (uint256) {\r\n        Sale memory sale = tokenIdToSale[_tokenId];\r\n        require(_isOnSale(sale));\r\n        return _currentPrice(sale);\r\n    }\r\n\r\n    /** @dev Calculates the new price for Sale Item\r\n     * @param   _saleType     Sale Type Identifier (0 - Single Sale, 1 - Team Sale)\r\n     * @param   _teamId       Team Identifier\r\n     */\r\n    function _averageSalePrice(uint256 _saleType, uint256 _teamId) internal view returns (uint256) {\r\n        uint256 _price = 0;\r\n        if(_saleType == 0) {\r\n            for(uint256 ii = 0; ii < 10; ii++) {\r\n                _price = _price.add(lastSingleSalePrices[ii]);\r\n            }\r\n            _price = _price.mul(SINGLE_SALE_MULTIPLIER).div(100);\r\n        } else {\r\n            for (uint256 i = 0; i < 3; i++) {\r\n                _price = _price.add(lastTeamSalePrices[_teamId][i]);\r\n            }\r\n        \r\n            _price = _price.mul(TEAM_SALE_MULTIPLIER).div(30);\r\n            _price = _price.mul(9);\r\n        }\r\n\r\n        return _price;\r\n    }\r\n    \r\n    /**\r\n     * @dev        Put a Collectible up for sale. Does some ownership trickery to create sale in one tx.\r\n     * @param      _tokenId        The token identifier\r\n     * @param      _startingPrice  The starting price\r\n     * @param      _endingPrice    The ending price\r\n     * @param      _duration       The duration\r\n     * @param      _owner          Owner of the token\r\n     */\r\n    function createSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration, address _owner) external whenNotPaused {\r\n        require(msg.sender == address(nonFungibleContract));\r\n\r\n        // Check whether the collectible is inPlay. If inPlay cant put it on Sale\r\n        require(nonFungibleContract.checkIsAttached(_tokenId) == 0);\r\n        \r\n        _escrow(_owner, _tokenId);\r\n\r\n        // Sale throws if inputs are invalid and clears\r\n        // transfer and sire approval after escrowing the CSLCollectible.\r\n        _createSale(\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            _owner\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev        Put a Collectible up for sale. Only callable, if user approved contract for 1/All Collectibles\r\n     * @param      _tokenId        The token identifier\r\n     * @param      _startingPrice  The starting price\r\n     * @param      _endingPrice    The ending price\r\n     * @param      _duration       The duration\r\n     */\r\n    function userCreateSaleIfApproved (uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint256 _duration) external whenNotPaused {\r\n        \r\n        require(nonFungibleContract.getApproved(_tokenId) == address(this) || nonFungibleContract.isApprovedForAll(msg.sender, address(this)));\r\n        \r\n        // Check whether the collectible is inPlay. If inPlay cant put it on Sale\r\n        require(nonFungibleContract.checkIsAttached(_tokenId) == 0);\r\n        \r\n        _escrow(msg.sender, _tokenId);\r\n\r\n        // Sale throws if inputs are invalid and clears\r\n        // transfer and sire approval after escrowing the CSLCollectible.\r\n        _createSale(\r\n            _tokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @dev        Transfers the balance of the sales manager contract to the CSLCollectible contract. We use two-step withdrawal to\r\n     *              prevent two transfer calls in the sale bid function.\r\n     */\r\n    function withdrawSaleManagerBalances() public onlyBanker {\r\n        _withdrawBalance();\r\n    }\r\n\r\n    /** \r\n     *  @dev Function to chnage the OwnerCut only accessible by the Owner of the contract\r\n     *  @param _newCut - Sets the ownerCut to new value\r\n     */\r\n    function setOwnerCut(uint256 _newCut) external onlyBanker {\r\n        require(_newCut <= 10000);\r\n        ownerCut = _newCut;\r\n    }\r\n    \r\n    /**\r\n     * @dev        Facilitates seed collectible auction creation. Enforces strict check on the data being passed\r\n     * @notice     Creates a new Collectible and creates an auction for it.\r\n     * @param      _teamId            The team identifier\r\n     * @param      _posId             The position identifier\r\n     * @param      _attributes        The attributes\r\n     * @param      _playerOverrideId  The player override identifier\r\n     * @param      _mlbPlayerId       The mlb player identifier\r\n     * @param      _startPrice        The start price\r\n     * @param      _endPrice          The end price\r\n     * @param      _saleDuration      The sale duration\r\n     */\r\n    function createSingleSeedAuction(\r\n        uint8 _teamId,\r\n        uint8 _posId,\r\n        uint256 _attributes,\r\n        uint256 _playerOverrideId,\r\n        uint256 _mlbPlayerId,\r\n        uint256 _startPrice,\r\n        uint256 _endPrice,\r\n        uint256 _saleDuration)\r\n        public\r\n        onlyGameManager\r\n        whenNotPaused {\r\n        // Check to see the NFT address is not 0\r\n        require(nonFungibleContract != address(0));\r\n        require(_teamId != 0);\r\n\r\n        uint256 nftId = nonFungibleContract.createSeedCollectible(_teamId,_posId,_attributes,address(this),0, _playerOverrideId, _mlbPlayerId);\r\n\r\n        uint256 startPrice = 0;\r\n        uint256 endPrice = 0;\r\n        uint256 duration = 0;\r\n        \r\n        if(_startPrice == 0) {\r\n            startPrice = _computeNextSeedPrice(0, _teamId);\r\n        } else {\r\n            startPrice = _startPrice;\r\n        }\r\n\r\n        if(_endPrice != 0) {\r\n            endPrice = _endPrice;\r\n        } else {\r\n            endPrice = 0;\r\n        }\r\n\r\n        if(_saleDuration == 0) {\r\n            duration = SALES_DURATION;\r\n        } else {\r\n            duration = _saleDuration;\r\n        }\r\n\r\n        _createSale(\r\n            nftId,\r\n            startPrice,\r\n            endPrice,\r\n            duration,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev        Facilitates promo collectible auction creation. Enforces strict check on the data being passed\r\n     * @notice     Creates a new Collectible and creates an auction for it.\r\n     * @param      _teamId            The team identifier\r\n     * @param      _posId             The position identifier\r\n     * @param      _attributes        The attributes\r\n     * @param      _playerOverrideId  The player override identifier\r\n     * @param      _mlbPlayerId       The mlb player identifier\r\n     * @param      _startPrice        The start price\r\n     * @param      _endPrice          The end price\r\n     * @param      _saleDuration      The sale duration\r\n     */\r\n    function createPromoSeedAuction(\r\n        uint8 _teamId,\r\n        uint8 _posId,\r\n        uint256 _attributes,\r\n        uint256 _playerOverrideId,\r\n        uint256 _mlbPlayerId,\r\n        uint256 _startPrice,\r\n        uint256 _endPrice,\r\n        uint256 _saleDuration)\r\n        public\r\n        onlyGameManager\r\n        whenNotPaused {\r\n        // Check to see the NFT address is not 0\r\n        require(nonFungibleContract != address(0));\r\n        require(_teamId != 0);\r\n\r\n        uint256 nftId = nonFungibleContract.createPromoCollectible(_teamId, _posId, _attributes, address(this), 0, _playerOverrideId, _mlbPlayerId);\r\n\r\n        uint256 startPrice = 0;\r\n        uint256 endPrice = 0;\r\n        uint256 duration = 0;\r\n        \r\n        if(_startPrice == 0) {\r\n            startPrice = _computeNextSeedPrice(0, _teamId);\r\n        } else {\r\n            startPrice = _startPrice;\r\n        }\r\n\r\n        if(_endPrice != 0) {\r\n            endPrice = _endPrice;\r\n        } else {\r\n            endPrice = 0;\r\n        }\r\n\r\n        if(_saleDuration == 0) {\r\n            duration = SALES_DURATION;\r\n        } else {\r\n            duration = _saleDuration;\r\n        }\r\n\r\n        _createSale(\r\n            nftId,\r\n            startPrice,\r\n            endPrice,\r\n            duration,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev        Creates Team Sale Auction\r\n     * @param      _teamId        The team identifier\r\n     * @param      _tokenIds      The token identifiers\r\n     * @param      _startPrice    The start price\r\n     * @param      _endPrice      The end price\r\n     * @param      _saleDuration  The sale duration\r\n     */\r\n    function createTeamSaleAuction(\r\n        uint8 _teamId,\r\n        uint256[9] _tokenIds,\r\n        uint256 _startPrice,\r\n        uint256 _endPrice,\r\n        uint256 _saleDuration)\r\n        public\r\n        onlyGameManager\r\n        whenNotPaused {\r\n\r\n        require(_teamId != 0);\r\n\r\n        // Helps in not creating sale with wrong team and player combination\r\n        for(uint ii = 0; ii < _tokenIds.length; ii++){\r\n            require(nonFungibleContract.getTeamId(_tokenIds[ii]) == _teamId);\r\n        }\r\n        \r\n        uint256 startPrice = 0;\r\n        uint256 endPrice = 0;\r\n        uint256 duration = 0;\r\n        \r\n        if(_startPrice == 0) {\r\n            startPrice = _computeNextSeedPrice(1, _teamId).mul(9);\r\n        } else {\r\n            startPrice = _startPrice;\r\n        }\r\n\r\n        if(_endPrice != 0) {\r\n            endPrice = _endPrice;\r\n        } else {\r\n            endPrice = 0;\r\n        }\r\n\r\n        if(_saleDuration == 0) {\r\n            duration = SALES_DURATION;\r\n        } else {\r\n            duration = _saleDuration;\r\n        }\r\n\r\n        _createTeamSale(\r\n            _tokenIds,\r\n            startPrice,\r\n            endPrice,\r\n            duration,\r\n            address(this)\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev        Computes the next auction starting price\r\n     * @param      _saleType     The sale type\r\n     * @param      _teamId       The team identifier\r\n     */\r\n    function _computeNextSeedPrice(uint256 _saleType, uint256 _teamId) internal view returns (uint256) {\r\n        uint256 nextPrice = _averageSalePrice(_saleType, _teamId);\r\n\r\n        // Sanity check to ensure we don't overflow arithmetic\r\n        require(nextPrice == nextPrice);\r\n\r\n        // We never auction for less than starting price\r\n        if (nextPrice < STARTING_PRICE) {\r\n            nextPrice = STARTING_PRICE;\r\n        }\r\n\r\n        return nextPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev        Sanity check that allows us to ensure that we are pointing to the right sale call.\r\n     */\r\n    bool public isSalesManager = true;\r\n\r\n    /**\r\n     * @dev        works the same as default bid method.\r\n     * @param      _tokenId  The token identifier\r\n     */\r\n    function bid(uint256 _tokenId) public whenNotPaused payable {\r\n        \r\n        Sale memory sale = tokenIdToSale[_tokenId];\r\n        address seller = sale.seller;\r\n\r\n        // This check is added to give all users a level playing field to think & bid on the player\r\n        require (now > sale.startedAt.add(BID_DELAY_TIME));\r\n        \r\n        uint256 price = _bid(_tokenId, msg.value);\r\n\r\n        //If multi token sale\r\n        if(sale.tokenIds[1] > 0) {\r\n            \r\n            for (uint256 i = 0; i < 9; i++) {\r\n                _transfer(address(this), msg.sender, sale.tokenIds[i]);\r\n            }\r\n\r\n            // Avg price\r\n            price = price.div(9);\r\n        } else {\r\n            \r\n            _transfer(address(this), msg.sender, _tokenId);\r\n        }\r\n        \r\n        // If not a seed, exit\r\n        if (seller == address(this)) {\r\n            if(sale.tokenIds[1] > 0){\r\n                uint256 _teamId = nonFungibleContract.getTeamId(_tokenId);\r\n\r\n                lastTeamSalePrices[_teamId][seedTeamSaleCount[_teamId] % 3] = price;\r\n\r\n                seedTeamSaleCount[_teamId]++;\r\n            } else {\r\n                lastSingleSalePrices[seedSingleSaleCount % 10] = price;\r\n                seedSingleSaleCount++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev        Sets the address for the NFT Contract\r\n     * @param      _nftAddress  The nft address\r\n     */\r\n    function setNFTContractAddress(address _nftAddress) public onlyGameManager {\r\n        require (_nftAddress != address(0));        \r\n        nonFungibleContract = MLBNFT(_nftAddress);\r\n    }\r\n\r\n    /**\r\n     * @dev        Added this module to allow retrieve of accidental asset transfer to contract\r\n     * @param      _to       { parameter_description }\r\n     * @param      _tokenId  The token identifier\r\n     */\r\n    function assetTransfer(address _to, uint256 _tokenId) public onlyGameManager {\r\n        require(_tokenId != 0);\r\n        nonFungibleContract.transferFrom(address(this), _to, _tokenId);\r\n    }\r\n\r\n     /**\r\n     * @dev        Added this module to allow retrieve of accidental asset transfer to contract\r\n     * @param      _to       { parameter_description }\r\n     * @param      _tokenIds  The token identifiers\r\n     */\r\n    function batchAssetTransfer(address _to, uint256[] _tokenIds) public onlyGameManager {\r\n        require(isBatchSupported);\r\n        require (_tokenIds.length > 0);\r\n        \r\n        for(uint i = 0; i < _tokenIds.length; i++){\r\n            require(_tokenIds[i] != 0);\r\n            nonFungibleContract.transferFrom(address(this), _to, _tokenIds[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Creates new Seed Team Collectibles\r\n     * @notice     Creates a team and transfers all minted assets to SaleManager\r\n     * @param      _teamId       The team identifier\r\n     * @param      _attributes   The attributes\r\n     * @param      _mlbPlayerId  The mlb player identifier\r\n     */\r\n    function createSeedTeam(uint8 _teamId, uint256[9] _attributes, uint256[9] _mlbPlayerId) public onlyGameManager whenNotPaused {\r\n        require(_teamId != 0);\r\n        \r\n        for(uint ii = 0; ii < 9; ii++) {\r\n            nonFungibleContract.createSeedCollectible(_teamId, uint8(ii.add(1)), _attributes[ii], address(this), 0, 0, _mlbPlayerId[ii]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev            Cancels an sale that hasn't been won yet. Returns the MLBNFT (ERC721) to original owner.\r\n     * @notice         This is a state-modifying function that can be called while the contract is paused.\r\n     */\r\n    function batchCancelSale(uint256[] _tokenIds) external whenNotPaused {\r\n        require(isBatchSupported);\r\n        require(_tokenIds.length > 0);\r\n\r\n        for(uint ii = 0; ii < _tokenIds.length; ii++){\r\n            Sale memory sale = tokenIdToSale[_tokenIds[ii]];\r\n            require(_isOnSale(sale));\r\n            \r\n            address seller = sale.seller;\r\n            require(msg.sender == seller);\r\n\r\n            _cancelSale(_tokenIds[ii], seller);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Helps to toggle batch supported flag\r\n     * @param      _flag  The flag\r\n     */\r\n    function updateBatchSupport(bool _flag) public onlyGameManager {\r\n        isBatchSupported = _flag;\r\n    }\r\n\r\n    /**\r\n     * @dev        Batching Operation: Creates a new Collectible and creates an auction for it.\r\n     * @notice     Helps in creating single seed auctions in batches\r\n     * @param      _teamIds            The team identifier\r\n     * @param      _posIds            The position identifier\r\n     * @param      _attributes        The attributes\r\n     * @param      _playerOverrideIds  The player override identifier\r\n     * @param      _mlbPlayerIds       The mlb player identifier\r\n     * @param      _startPrice         The start price\r\n     */\r\n    function batchCreateSingleSeedAuction(\r\n        uint8[] _teamIds,\r\n        uint8[] _posIds,\r\n        uint256[] _attributes,\r\n        uint256[] _playerOverrideIds,\r\n        uint256[] _mlbPlayerIds,\r\n        uint256 _startPrice)\r\n        public\r\n        onlyGameManager\r\n        whenNotPaused {\r\n\r\n        require (isBatchSupported);\r\n\r\n        require (_teamIds.length > 0 &&\r\n            _posIds.length > 0 &&\r\n            _attributes.length > 0 &&\r\n            _playerOverrideIds.length > 0 &&\r\n            _mlbPlayerIds.length > 0 );\r\n        \r\n        // Check to see the NFT address is not 0\r\n        require(nonFungibleContract != address(0));\r\n        \r\n        uint256 nftId;\r\n\r\n        require (_startPrice != 0);\r\n\r\n        for(uint ii = 0; ii < _mlbPlayerIds.length; ii++){\r\n            require(_teamIds[ii] != 0);\r\n\r\n            nftId = nonFungibleContract.createSeedCollectible(\r\n                        _teamIds[ii],\r\n                        _posIds[ii],\r\n                        _attributes[ii],\r\n                        address(this),\r\n                        0,\r\n                        _playerOverrideIds[ii],\r\n                        _mlbPlayerIds[ii]);\r\n\r\n            _createSale(\r\n                nftId,\r\n                _startPrice,\r\n                0,\r\n                SALES_DURATION,\r\n                address(this)\r\n            );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Helps in incrementing the delay time to start bidding for any auctions\r\n     * @notice     Function helps to update the delay time for bidding\r\n     * @param      _newDelay       The new Delay time\r\n     */\r\n    function updateDelayTime(uint256 _newDelay) public onlyGameManager whenNotPaused {\r\n\r\n        BID_DELAY_TIME = _newDelay;\r\n    }\r\n\r\n    function bidTransfer(uint256 _tokenId, address _buyer, uint256 _bidAmount) public canTransact {\r\n\r\n        Sale memory sale = tokenIdToSale[_tokenId];\r\n        address seller = sale.seller;\r\n\r\n        // This check is added to give all users a level playing field to think & bid on the player\r\n        require (now > sale.startedAt.add(BID_DELAY_TIME));\r\n        \r\n        uint256[9] memory tokenIdsStore = tokenIdToSale[_tokenId].tokenIds;\r\n        \r\n        // Explicitly check that this sale is currently live.\r\n        require(_isOnSale(sale));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(sale);\r\n        require(_bidAmount >= price);\r\n\r\n        // The bid is good! Remove the sale before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        if(tokenIdsStore[1] > 0) {\r\n            for(uint ii = 0; ii < 9; ii++) {\r\n                _removeSale(tokenIdsStore[ii]);\r\n            }\r\n        } else {\r\n            _removeSale(_tokenId);\r\n        }\r\n\r\n        uint256 marketsCut = 0;\r\n        uint256 sellerProceeds = 0;\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the marketplace's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            // value <= price)\r\n            marketsCut = _computeCut(price);\r\n            sellerProceeds = price.sub(marketsCut);\r\n        }\r\n\r\n        //escrowTransfer(address seller, address buyer, uint256 currentPrice) public returns(bool);\r\n        require (LSEscrowContract.escrowTransfer(seller, _buyer, sellerProceeds, marketsCut));\r\n        \r\n        // Tell the world!\r\n        // uint256 assetID, uint256 totalPrice, address winner, uint16 generation\r\n        if(tokenIdsStore[1] > 0) {\r\n            emit TeamSaleWinner(tokenIdsStore, price, _buyer);\r\n        } else {\r\n            emit SaleWinner(_tokenId, price, _buyer);\r\n        }\r\n\r\n        //If multi token sale\r\n        if(sale.tokenIds[1] > 0) {\r\n            \r\n            for (uint256 i = 0; i < 9; i++) {\r\n                _transfer(address(this), _buyer, sale.tokenIds[i]);\r\n            }\r\n\r\n            // Avg price\r\n            price = price.div(9);\r\n        } else {\r\n            \r\n            _transfer(address(this), _buyer, _tokenId);\r\n        }\r\n        \r\n        // If not a seed, exit\r\n        if (seller == address(this)) {\r\n            if(sale.tokenIds[1] > 0) {\r\n                uint256 _teamId = nonFungibleContract.getTeamId(_tokenId);\r\n\r\n                lastTeamSalePrices[_teamId][seedTeamSaleCount[_teamId] % 3] = price;\r\n\r\n                seedTeamSaleCount[_teamId]++;\r\n            } else {\r\n                lastSingleSalePrices[seedSingleSaleCount % 10] = price;\r\n                seedSingleSaleCount++;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev        Sets the address for the LS Escrow Contract\r\n     * @param      _lsEscrowAddress  The nft address\r\n     */\r\n    function setLSEscrowContractAddress(address _lsEscrowAddress) public onlyGameManager {\r\n        require (_lsEscrowAddress != address(0));        \r\n        LSEscrowContract = LSEscrow(_lsEscrowAddress);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_buyer\",\"type\":\"address\"},{\"name\":\"_bidAmount\",\"type\":\"uint256\"}],\"name\":\"bidTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameManagerSecondary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TEAM_SALE_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nftAddress\",\"type\":\"address\"}],\"name\":\"setNFTContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelSaleWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8\"},{\"name\":\"_posId\",\"type\":\"uint8\"},{\"name\":\"_attributes\",\"type\":\"uint256\"},{\"name\":\"_playerOverrideId\",\"type\":\"uint256\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_endPrice\",\"type\":\"uint256\"},{\"name\":\"_saleDuration\",\"type\":\"uint256\"}],\"name\":\"createPromoSeedAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_flag\",\"type\":\"bool\"}],\"name\":\"updateBatchSupport\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAddress\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"bool\"}],\"name\":\"updateAllowedAddressesList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"LSEscrowContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchCancelSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8\"},{\"name\":\"_attributes\",\"type\":\"uint256[9]\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256[9]\"}],\"name\":\"createSeedTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSalesManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"createSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawSaleManagerBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCut\",\"type\":\"uint256\"}],\"name\":\"setOwnerCut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gameManagerPrimary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setSecondaryGameManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"userCreateSaleIfApproved\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seedSingleSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8\"},{\"name\":\"_tokenIds\",\"type\":\"uint256[9]\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_endPrice\",\"type\":\"uint256\"},{\"name\":\"_saleDuration\",\"type\":\"uint256\"}],\"name\":\"createTeamSaleAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchAssetTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamId\",\"type\":\"uint8\"},{\"name\":\"_posId\",\"type\":\"uint8\"},{\"name\":\"_attributes\",\"type\":\"uint256\"},{\"name\":\"_playerOverrideId\",\"type\":\"uint256\"},{\"name\":\"_mlbPlayerId\",\"type\":\"uint256\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_endPrice\",\"type\":\"uint256\"},{\"name\":\"_saleDuration\",\"type\":\"uint256\"}],\"name\":\"createSingleSeedAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastTeamSalePrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lsEscrowAddress\",\"type\":\"address\"}],\"name\":\"setLSEscrowContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isBatchSupported\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setPrimaryGameManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_teamIds\",\"type\":\"uint8[]\"},{\"name\":\"_posIds\",\"type\":\"uint8[]\"},{\"name\":\"_attributes\",\"type\":\"uint256[]\"},{\"name\":\"_playerOverrideIds\",\"type\":\"uint256[]\"},{\"name\":\"_mlbPlayerIds\",\"type\":\"uint256[]\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"}],\"name\":\"batchCreateSingleSeedAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SINGLE_SALE_MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STARTING_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDelay\",\"type\":\"uint256\"}],\"name\":\"updateDelayTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lastSingleSalePrices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getSale\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"tokenIds\",\"type\":\"uint256[9]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nonFungibleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"assetTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BID_DELAY_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"seedTeamSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC721_RECEIVED\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBK\",\"type\":\"address\"}],\"name\":\"setBanker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SALES_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"SaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenIDs\",\"type\":\"uint256[9]\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startedAt\",\"type\":\"uint256\"}],\"name\":\"TeamSaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"SaleWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenIDs\",\"type\":\"uint256[9]\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"TeamSaleWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sellerAddress\",\"type\":\"address\"}],\"name\":\"SaleCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"EtherWithdrawed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"SaleManager","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3408577a17c8dea00c33371e52dbd014003d4cb6986631dcb591ca03e0c95308"}]}