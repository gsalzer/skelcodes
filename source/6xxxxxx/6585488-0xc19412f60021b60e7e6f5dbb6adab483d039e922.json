{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.24; \r\n\r\n/***\r\n *       ___     ___      _    \r\n *      /   \\   |_  )    / |   \r\n *      | - |    / /     | |   \r\n *      |_|_|   /___|   _|_|_  \r\n *    _|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"| \r\n *    \"`-0-0-'\"`-0-0-'\"`-0-0-' \r\n * \r\n * https://a21.app\r\n */\r\n \r\ncontract IGame {\r\n     \r\n    address public owner; \r\n    address public creator;\r\n    address public manager;\r\n\tuint256 public poolValue = 0;\r\n\tuint256 public round = 0;\r\n\tuint256 public totalBets = 0;\r\n\tuint256 public startTime = now;\r\n    bytes32 public name;\r\n    string public title;\r\n\tuint256 public price;\r\n\tuint256 public timespan;\r\n\tuint32 public gameType;\r\n\r\n    /* profit divisions */\r\n\tuint256 public profitOfSociety = 5;  \r\n\tuint256 public profitOfManager = 1; \r\n\tuint256 public profitOfFirstPlayer = 15;\r\n\tuint256 public profitOfWinner = 40;\r\n\t\r\n\tfunction getGame() view public returns(\r\n        address, uint256, address, uint256, \r\n        uint256, uint256, uint256, \r\n        uint256, uint256, uint256, uint256);\r\n} \r\n/***\r\n *       ___     ___      _    \r\n *      /   \\   |_  )    / |   \r\n *      | - |    / /     | |   \r\n *      |_|_|   /___|   _|_|_  \r\n *    _|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"| \r\n *    \"`-0-0-'\"`-0-0-'\"`-0-0-' \r\n */\r\ncontract Owned {\r\n    modifier isActivated {\r\n        require(activated == true, \"its not ready yet.\"); \r\n        _;\r\n    }\r\n    \r\n    modifier isHuman {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n \r\n    modifier limits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;    \r\n    }\r\n \r\n    modifier onlyOwner {\r\n        require (msg.sender == owner, \"OnlyOwner methods called by non-owner.\");\r\n        _;\r\n    }\r\n\r\n    address public owner;\r\n\tbool public activated = true;\r\n\r\n    constructor() public{\r\n        owner = msg.sender;\r\n    }\r\n\r\n\tfunction terminate() public onlyOwner {\r\n\t\tselfdestruct(owner);\r\n\t}\r\n\r\n\tfunction setIsActivated(bool _activated) public onlyOwner {\r\n\t\tactivated = _activated;\r\n\t}\r\n} \r\nlibrary List {\r\n  /** Removes the value at the given index in an array. */\r\n  function removeIndex(uint[] storage values, uint i) internal {      \r\n    if(i<values.length){ \r\n        while (i<values.length-1) {\r\n            values[i] = values[i+1];\r\n            i++;\r\n        }\r\n        values.length--;\r\n    }\r\n  }\r\n} \r\n \r\n \r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n \r\n/**\r\n * @title NameFilter\r\n * @dev filter string\r\n */\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n/***\r\n *       ___     ___      _    \r\n *      /   \\   |_  )    / |   \r\n *      | - |    / /     | |   \r\n *      |_|_|   /___|   _|_|_  \r\n *    _|\"\"\"\"\"|_|\"\"\"\"\"|_|\"\"\"\"\"| \r\n *    \"`-0-0-'\"`-0-0-'\"`-0-0-' \r\n * \r\n * https://a21.app\r\n */\r\n\r\n\r\ncontract A21 is IGame, Owned {\r\n  \tusing SafeMath for uint256;\r\n\tusing List for uint[];\r\n    using NameFilter for string;\r\n  \r\n\tstruct Bet {\r\n\t\taddress addr;\r\n\t\tuint8 value;\r\n\t\tuint8 c1;\r\n\t\tuint8 c2;\r\n\t\tuint256 round;\r\n\t\tuint256 date;\r\n\t\tuint256 eth;\r\n\t\tuint256 award;\r\n\t\tuint8 awardType; \r\n\t}\r\n\r\n\tstruct Player { \r\n\t\tmapping(uint256 => Bet) bets;\r\n\t\tuint256 numberOfBets;\r\n\t}\t\r\n\r\n\tstruct Result {\r\n\t\tuint256 round;\r\n\t\taddress addr;\r\n\t\tuint256 award;\r\n\t\tuint8 awardType; \r\n\t\tBet bet;\r\n\t}\r\n\r\n\tuint256 private constant MINIMUM_PRICE = 0.01 ether;\r\n\tuint256 private constant MAXIMUM_PRICE = 100 ether;\r\n\tuint8 private constant NUMBER_OF_CARDS_VALUE = 13;\r\n\tuint8 private constant NUMBER_OF_CARDS = NUMBER_OF_CARDS_VALUE * 4;\r\n\tuint8 private constant MAXIMUM_NUMBER_OF_BETS = 26;\r\n\tuint8 private constant BLACKJACK = 21;\r\n\tuint8 private constant ENDGAME = 128;\r\n\tuint256 private constant MINIMUM_TIMESPAN = 1 minutes;  \r\n\tuint256 private constant MAXIMUM_TIMESPAN = 24 hours;  \r\n\r\n\tuint256[] private _cards;\r\n    mapping(uint8 => Bet) private _bets;\r\n\tmapping(address => Player) private _players;  \r\n\tResult[] private _results;\r\n\r\n\tmapping(address => uint256) public balances;\r\n    address public creator;\r\n    address public manager;\r\n\tuint256 public poolValue = 0;\r\n\tuint256 public round = 0;\r\n\tuint256 public totalBets = 0;\r\n\tuint8 public numberOfBets = 0;\r\n\tuint256 public startTime = now;\r\n    bytes32 public name;\r\n    string public title;\r\n\tuint256 public price;\r\n\tuint256 public timespan;\r\n\tuint32 public gameType = BLACKJACK;\r\n\tuint8 public ace = 0;\r\n\r\n    /* profit divisions */\r\n\tuint256 public profitOfSociety = 5;  \r\n\tuint256 public profitOfManager = 1; \r\n\tuint256 public profitOfFirstPlayer = 15;\r\n\tuint256 public profitOfWinner = 40;\r\n\t\r\n\t/* events */\r\n\tevent OnBuy(uint256 indexed round, address indexed playerAddress, uint256 price, uint8 cardValue, uint8 c1, uint8 c2, uint256 timestamp); \r\n\tevent OnWin(uint256 indexed round, address indexed playerAddress, uint256 award, uint8 cardValue, uint8 c1, uint8 c2, uint256 timestamp); \r\n\tevent OnReward(uint256 indexed round, address indexed playerAddress, uint256 award, uint8 cardValue, uint8 c1, uint8 c2, uint256 timestamp); \r\n\tevent OnWithdraw(address indexed sender, uint256 value, uint256 timestamp); \r\n\tevent OnNewRound(uint256 indexed round, uint256 timestamp); \r\n\r\n\tconstructor(address _manager, string _name, string _title, uint256 _price, uint256 _timespan,\r\n\t\tuint256 _profitOfManager, uint256 _profitOfFirstPlayer, uint256 _profitOfWinner\r\n\t\t) public {\r\n\t\trequire(address(_manager)!=0x0, \"invaild address\");\r\n\t\trequire(_price >= MINIMUM_PRICE && _price <= MAXIMUM_PRICE, \"price not in range (MINIMUM_PRICE, MAXIMUM_PRICE)\");\r\n\t\trequire(_timespan >= MINIMUM_TIMESPAN && _timespan <= MAXIMUM_TIMESPAN, \"timespan not in range(MINIMUM_TIMESPAN, MAXIMUM_TIMESPAN)\");\r\n\t\tname = _name.nameFilter(); \r\n\t\trequire(name[0] != 0, \"invaild name\"); \r\n        require(_profitOfManager <=20, \"[profitOfManager] don't take too much commission :)\");\r\n        require(_profitOfFirstPlayer <=50, \"[profitOfFirstPlayer] don't take too much commission :)\");\r\n        require(_profitOfWinner <=100 && (_profitOfManager + _profitOfWinner + _profitOfFirstPlayer) <=100, \"[profitOfWinner] don't take too much commission :)\");\r\n        \r\n        creator = msg.sender;\r\n\t\towner = 0x56C4ECf7fBB1B828319d8ba6033f8F3836772FA9; \r\n\t\tmanager = _manager;\r\n\t\t//name = _name.nameFilter(); \r\n\t\ttitle = _title;\r\n\t\tprice = _price;\r\n\t\ttimespan = _timespan;\r\n\t\tprofitOfManager = _profitOfManager;\r\n\t\tprofitOfFirstPlayer = _profitOfFirstPlayer;\r\n\t\tprofitOfWinner = _profitOfWinner;\r\n\r\n\t\tnewRound();  \r\n\t}\r\n\r\n\tfunction() public payable isActivated isHuman limits(msg.value){\r\n\t\t// airdrop\r\n\t\tgoodluck();\r\n\t}\r\n\r\n\tfunction goodluck() public payable isActivated isHuman limits(msg.value) {\r\n\t\trequire(msg.value >= price, \"value < price\");\r\n\t\trequire(msg.value >= MINIMUM_PRICE && msg.value <= MAXIMUM_PRICE, \"value not in range (MINIMUM_PRICE, MAXIMUM_PRICE)\");\r\n\t\t\r\n\t\tif(getTimeLeft()<=0){\r\n\t\t\t// timeout, end.\r\n\t\t\tendRound();\r\n\t\t}\r\n\r\n\t\t// contribution\r\n\t\tuint256 awardOfSociety = msg.value.mul(profitOfSociety).div(100);\r\n\t\tpoolValue = poolValue.add(msg.value).sub(awardOfSociety);\r\n\t\tbalances[owner] = balances[owner].add(awardOfSociety);\r\n\r\n\t\tuint256 v = buyCore(); \r\n\r\n\t\tif(v == BLACKJACK || v == ENDGAME || _cards.length<=1){\r\n\t\t\t// someone wins or cards have been run out.\r\n\t\t\tendRound();\r\n\t\t}\t\t\r\n\t}\r\n\r\n\tfunction withdraw(uint256 amount) public isActivated isHuman returns(bool) {\r\n\t\tuint256 bal = balances[msg.sender];\r\n\t\trequire(bal> 0);\r\n\t\trequire(bal>= amount);\r\n\t\trequire(address(this).balance>= amount);\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(amount); \r\n\t\tmsg.sender.transfer(amount);\r\n\r\n\t\temit OnWithdraw(msg.sender, amount, now);\r\n\t\treturn true;\r\n\t}\r\n    \r\n\t/* for the reason of promotion, manager can increase the award pool   */\r\n\tfunction addAward() public payable isActivated isHuman limits(msg.value) {\r\n\t\trequire(msg.sender == manager, \"only manager can add award into pool\");  \r\n\t\t// thanks this smart manager \r\n\t\tpoolValue =  poolValue.add(msg.value);\r\n\t}\r\n\t\r\n\tfunction isPlayer(address addr) public view returns(bool){\r\n\t    return _players[addr].numberOfBets > 0 ;\r\n\t}\r\n\r\n    function getTimeLeft() public view returns(uint256) { \r\n        // grab time\r\n        uint256 _now = now;\r\n\t\tuint256 _endTime = startTime.add(timespan);\r\n        \r\n        if (_now >= _endTime){\r\n\t\t\treturn 0;\r\n\t\t}\r\n         \r\n\t\treturn (_endTime - _now);\r\n    }\r\n    \r\n\tfunction getBets() public view returns (address[], uint8[], uint8[], uint8[]){\r\n\t\tuint len = numberOfBets;\r\n\t\taddress[] memory ps = new address[](len);\r\n\t\tuint8[] memory vs = new uint8[](len);\r\n\t\tuint8[] memory c1s = new uint8[](len);\r\n\t\tuint8[] memory c2s = new uint8[](len);\r\n\t\tuint8 i = 0; \r\n\t\twhile (i< len) {\r\n\t\t\tps[i] = _bets[i].addr;\r\n\t\t\tvs[i] = _bets[i].value;\r\n\t\t\tc1s[i] = _bets[i].c1;\r\n\t\t\tc2s[i] = _bets[i].c2;\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn (ps, vs, c1s, c2s);\r\n\t} \r\n\r\n\tfunction getBetHistory(address player, uint32 v) public view returns (uint256[], uint256[], uint8[], uint8[]){\r\n\t\tPlayer storage p = _players[player];\r\n\t\tuint256 len = v;\r\n\t\tif(len == 0 || len > p.numberOfBets){\r\n\t\t    len = p.numberOfBets;\r\n\t\t}\r\n\t\t\r\n\t\tuint256[] memory rounds = new uint256[](len);\r\n\t\tuint256[] memory awards = new uint256[](len);  \r\n\t\tuint8[] memory c1s = new uint8[](len);\r\n\t\tuint8[] memory c2s = new uint8[](len);\r\n\t\tif(len == 0 ){\r\n\t\t\treturn (rounds, awards, c1s, c2s);\r\n\t\t}\r\n\t\t\t\r\n\t\tuint256 i = 0; \r\n\t\twhile (i< len) { \r\n\t\t\tBet memory r = p.bets[p.numberOfBets-1-i];\r\n\t\t\trounds[i] = r.round;\r\n\t\t\tawards[i] = r.award; \r\n\t\t\tc1s[i] = r.c1;\r\n\t\t\tc2s[i] = r.c2;\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn (rounds, awards, c1s, c2s);\r\n\t}\r\n\t\r\n    function getBetHistory2(address player, uint32 v) public view returns (uint256[], uint256[], uint8[], uint8[]){\r\n\t\tPlayer storage p = _players[player];\r\n\t\tuint256 len = v;\r\n\t\tif(len == 0 || len > p.numberOfBets){\r\n\t\t    len = p.numberOfBets;\r\n\t\t}\r\n\t\t\r\n\t\tuint256[] memory rounds = new uint256[](len);\r\n\t\tuint256[] memory awards = new uint256[](len);  \r\n\t\tuint8[] memory c1s = new uint8[](len);\r\n\t\tuint8[] memory c2s = new uint8[](len);\r\n\t\tif(len == 0 ){\r\n\t\t\treturn (rounds, awards, c1s, c2s);\r\n\t\t}\r\n\t\t\r\n\t\tuint256 i = 0; \r\n\t\twhile (i< len) { \r\n\t\t\tBet memory r = p.bets[i];\r\n\t\t\trounds[i] = r.round;\r\n\t\t\tawards[i] = r.award; \r\n\t\t\tc1s[i] = r.c1;\r\n\t\t\tc2s[i] = r.c2;\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn (rounds, awards, c1s, c2s);\r\n\t}\r\n\t\r\n\tfunction getResults(uint32 v) public view returns (uint256[], address[], uint256[], uint8[], uint8[], uint8[]){\r\n\t\tuint256 len = v;\r\n\t\tif(len == 0 || len >_results.length){\r\n\t\t    len = _results.length;\r\n\t\t}\r\n\t\t\r\n\t\tuint256[] memory rounds = new uint256[](len);\r\n\t\taddress[] memory addrs = new address[](len);\r\n\t\tuint256[] memory awards = new uint256[](len); \r\n\t\tuint8[] memory awardTypes = new uint8[](len);\r\n\t\tuint8[] memory c1s = new uint8[](len);\r\n\t\tuint8[] memory c2s = new uint8[](len);\r\n\t\t\r\n\t\tif(len == 0 ){\r\n\t\t\treturn (rounds, addrs, awards, awardTypes, c1s, c2s);\r\n\t\t}\r\n\t\t\r\n\t\tuint256 i = 0; \r\n\t\twhile (i<_results.length) { \r\n\t\t\tResult storage r = _results[_results.length-1-i];\r\n\t\t\trounds[i] = r.round;\r\n\t\t\taddrs[i] = r.addr;\r\n\t\t\tawards[i] = r.award;\r\n\t\t\tawardTypes[i] = r.awardType;\r\n\t\t\tc1s[i] = r.bet.c1;\r\n\t\t\tc2s[i] = r.bet.c2;\r\n\t\t\ti++;\r\n\t\t}\r\n\r\n\t\treturn (rounds, addrs, awards, awardTypes, c1s, c2s);\r\n\t}\r\n\t\r\n\t\r\n    function getGame() view public returns(\r\n        address, uint256, address, uint256, \r\n        uint256, uint256, uint256, \r\n        uint256, uint256, uint256, uint256) {\r\n        return (address(this), price, manager, timespan, \r\n            profitOfManager, profitOfFirstPlayer, profitOfWinner, \r\n            round, address(this).balance, poolValue, totalBets);\r\n    }\r\n\r\n/***\r\n *    .------..------..------.\r\n *    |A.--. ||2.--. ||1.--. |\r\n *    | (\\/) || (\\/) || :/\\: |\r\n *    | :\\/: || :\\/: || (__) |\r\n *    | '--'A|| '--'2|| '--'1|\r\n *    `------'`------'`------'\r\n *    === private functions ===\r\n */\r\n\r\n\tfunction buyCore() private returns (uint256){\r\n\t\ttotalBets++;\r\n\t\t// draw 2 cards \r\n\t\t(uint c1, uint c2) =  draw(); \r\n\r\n\t\tuint256 v = eval(c1, c2);\r\n\r\n\t\tBet storage bet =  _bets[numberOfBets++];\r\n\t\tbet.addr = msg.sender;\r\n\t\tbet.value =  uint8(v);\r\n\t\tbet.c1 = uint8(c1);\r\n\t\tbet.c2 = uint8(c2);\t\t\r\n\t\tbet.round = round;\r\n\t\tbet.date = now;\r\n\t\tbet.eth = msg.value; \r\n\t\t\r\n\t\t// push to hist\r\n\t\tPlayer storage player = _players[msg.sender];\r\n\t\tplayer.bets[player.numberOfBets++] = bet;\r\n\r\n\t\temit OnBuy(round, msg.sender, msg.value, bet.value, bet.c1, bet.c2, now);\r\n\r\n\t\tif(c1%13==0){\r\n\t\t    ace++;\r\n\t\t}\r\n\t\tif(c2%13==0){\r\n\t\t    ace++;\r\n\t\t} \r\n\t\t\r\n\t\treturn ace>=4? ENDGAME: v;\r\n\t}\r\n\r\n\tfunction newRound() private {\r\n\t\tnumberOfBets = 0;\r\n\t\tace = 0;\r\n\t\tfor(uint8 i =0; i < MAXIMUM_NUMBER_OF_BETS; i++){\r\n\t\t\tBet storage bet = _bets[i];\r\n\t\t\tbet.addr = address(0);\r\n\t\t}\r\n\r\n\t\t_cards = new uint[](NUMBER_OF_CARDS);\r\n\t\tfor(i=0; i< NUMBER_OF_CARDS; i++){\r\n\t\t\t_cards[i] = i;\r\n\t\t}\r\n\t\t_cards.length = NUMBER_OF_CARDS;\r\n\t\tround++; \r\n\t\tstartTime = now;\r\n\r\n\t\temit OnNewRound(round, now);\r\n\t}\r\n\r\n\tfunction endRound() private {\r\n\t\tuint256 awardOfManager = poolValue.mul(profitOfManager).div(100);\r\n\t\tuint256 awardOfFirstPlayer = poolValue.mul(profitOfFirstPlayer).div(100);\r\n\t\tuint256 awardOfWinner = poolValue.mul(profitOfWinner).div(100);\r\n\r\n\t\tif(numberOfBets>0 ){\r\n\t\t\t// check winner\r\n\t\t\tuint8 i = 0;\r\n\t\t\tint winner = -1;\r\n\t\t\twhile (i< numberOfBets) {\r\n\t\t\t\tif(_bets[i].value == BLACKJACK){\t\t\t\t\r\n\t\t\t\t\twinner = int(i);\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\r\n\t\t\taddress firstPlayerAddr = _bets[0].addr;\r\n\t\t\tbalances[firstPlayerAddr] = balances[firstPlayerAddr].add(awardOfFirstPlayer); \r\n\t\t\t\r\n            _results.push(Result(round, firstPlayerAddr, awardOfFirstPlayer, 1, _bets[0])); //Bet(_bets[0].addr, _bets[0].value, _bets[0].c1, _bets[0].c2, _bets[0].round, _bets[0].date, _bets[0].eth)\r\n\r\n            Player storage player = _players[firstPlayerAddr];\r\n\t        Bet storage _bet = player.bets[player.numberOfBets-1];\r\n\t        _bet.award = _bet.award.add(awardOfFirstPlayer);\r\n\t        _bet.awardType = 1;\r\n\t\t        \r\n\t\t\temit OnReward(round, firstPlayerAddr, awardOfFirstPlayer, _bets[0].value, _bets[0].c1, _bets[0].c2, now);\r\n\t\t\t\r\n\t\t\tif(winner>=0){\t\r\n\t\t\t\tBet memory bet = _bets[uint8(winner)];\t\t\t\r\n\t\t\t\taddress winAddr = bet.addr; \r\n\t\t\t\tbalances[winAddr] = balances[winAddr].add(awardOfWinner); \r\n                _results.push(Result(round,winAddr, awardOfWinner, BLACKJACK, bet));\r\n                \r\n                player = _players[winAddr];\r\n\t\t        _bet = player.bets[player.numberOfBets-1];\r\n\t\t        _bet.award = _bet.award.add(awardOfWinner);\r\n\t\t        _bet.awardType = BLACKJACK;\r\n\t\t        \r\n\t\t\t\temit OnWin(round, winAddr, awardOfWinner, bet.value, bet.c1, bet.c2, now);\r\n\t\t\t}else{\r\n\t\t\t    awardOfWinner = 0;\r\n\t\t\t}\r\n\r\n\t\t}else{\r\n\t\t    // no bets (!o!)\r\n\t\t\tawardOfWinner = 0;\r\n\t\t\tawardOfFirstPlayer = 0;\r\n\t\t\tawardOfManager = 0;\r\n\t\t} \r\n\r\n\t\tbalances[manager] = balances[manager].add(awardOfManager); \r\n\t\t\r\n\t\tpoolValue =  poolValue.sub(awardOfManager).sub(awardOfFirstPlayer).sub(awardOfWinner);\r\n\t\t\r\n\t\treleaseCommission();\r\n\r\n\t\tnewRound();\r\n\t}\r\n\r\n\tfunction releaseCommission() private {\r\n\t\t// 🙄 in case too busy in developing dapps and have no time to collect team commission \r\n\t\t// thanks everyone!\r\n\t\tuint256 commission = balances[owner];\r\n\t\tif(commission > 0){\r\n\t\t\towner.transfer(commission);\r\n\t\t\tbalances[owner] = 0;\r\n\t\t}\r\n\r\n\t\t// For the main reason of gas fee, we don't release all players' awards, so please withdraw it by yourself. \r\n\t}\r\n\r\n\tfunction eval(uint256 c1, uint256 c2)  private pure returns (uint256){\r\n\t\tc1 = cut((c1 % 13) + 1);\r\n\t\tc2 = cut((c2 % 13) + 1);\r\n\t\tif ((c1 == 1 && c2 == 10) || ((c2 == 1 && c1 == 10))) {\r\n\t\t\treturn BLACKJACK;\r\n\t\t}\r\n\r\n\t\tif (c1 + c2 > BLACKJACK) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n \r\n\t\treturn c1 + c2;\r\n\t}\r\n\r\n\tfunction cut(uint256 v) private pure returns (uint256){\r\n\t\treturn (v > 10 ? 10 : v);\r\n\t}\r\n\r\n\tfunction draw() private returns (uint, uint) {\r\n\t    uint256 max = _cards.length * (_cards.length - 1) /2;\r\n\t\tuint256 ind = rand(max);\r\n\t\t(uint256 i1, uint256 i2) = index2pair(ind);\r\n\t\tuint256 c1 = _cards[i1];\r\n\t\t_cards.removeIndex(i1); \r\n\t\tuint256 c2 = _cards[i2];\r\n\t\t_cards.removeIndex(i2);\r\n\t\treturn (c1, c2);\r\n\t}\r\n\r\n\tfunction rand(uint256 max) private view returns (uint256){\r\n\t\tuint256 _seed = uint256(keccak256(abi.encodePacked(\r\n                (block.timestamp) +\r\n                (block.difficulty) +\r\n                ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\r\n                (block.gaslimit) +\r\n                ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)) +\r\n                (block.number)\r\n        ))); \r\n\t\t\r\n\t\treturn _seed % max; \r\n\t}\r\n\r\n\tfunction index2pair(uint x) private pure returns (uint, uint) { \r\n\t\tuint c1 = ((sqrt(8*x+1) - 1)/2 +1);\r\n\t\tuint c2 = (x - c1*(c1-1)/2);\r\n\t\treturn (c1, c2);\r\n\t}\r\n\r\n\tfunction sqrt(uint x) private pure returns (uint) {\r\n\t\tuint z = (x + 1) / 2;\r\n\t\tuint y = x;\r\n\t\twhile (z < y) {\r\n\t\t\ty = z;\r\n\t\t\tz = (x / z + z) / 2;\r\n\t\t}\r\n\r\n\t\treturn y;\r\n\t}\r\n \r\n}\r\n\r\ncontract A21Builder{\r\n    function buildGame (address _manager, string _name, string _title, uint256 _price, uint256 _timespan,\r\n        uint8 _profitOfManager, uint8 _profitOfFirstPlayer, uint8 _profitOfWinner) payable external returns(address){\r\n       \r\n        address game = new A21(_manager, _name, _title, _price, _timespan, _profitOfManager, _profitOfFirstPlayer, _profitOfWinner);\r\n        return game;   \r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_title\",\"type\":\"string\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_timespan\",\"type\":\"uint256\"},{\"name\":\"_profitOfManager\",\"type\":\"uint8\"},{\"name\":\"_profitOfFirstPlayer\",\"type\":\"uint8\"},{\"name\":\"_profitOfWinner\",\"type\":\"uint8\"}],\"name\":\"buildGame\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"}]","ContractName":"A21Builder","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4bca6c9476a894dd7c3b428af8e5a92e57ecbfd4ae502b0cdf96f5766d8ca3f4"}]}