{"status":"1","message":"OK","result":[{"SourceCode":"// <ORACLIZE_API_LIB>\r\n/*\r\nCopyright (c) 2015-2016 Oraclize SRL\r\nCopyright (c) 2016 Oraclize LTD\r\n\r\n\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\n\r\n\r\nThe above copyright notice and this permission notice shall be included in\r\nall copies or substantial portions of the Software.\r\n\r\n\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\nTHE SOFTWARE.\r\n*/\r\n\r\npragma solidity ^0.4.21;\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) public view returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) public view returns (uint _dsprice);\r\n    function setProofType(byte _proofType) external;\r\n    function setCustomGasPrice(uint _gasPrice) external;\r\n    function randomDS_getSessionPubKeyHash() external view returns(bytes32);\r\n}\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() public view returns (address _addr);\r\n}\r\nlibrary oraclizeLib {\r\n\r\n    function proofType_NONE()\r\n    public\r\n    pure\r\n    returns (byte) {\r\n        return 0x00;\r\n    }\r\n\r\n    function proofType_TLSNotary()\r\n    public\r\n    pure\r\n    returns (byte) {\r\n        return 0x10;\r\n    }\r\n\r\n    function proofType_Android()\r\n    public\r\n    pure\r\n    returns (byte) {\r\n        return 0x20;\r\n    }\r\n\r\n    function proofType_Ledger()\r\n    public\r\n    pure\r\n    returns (byte) {\r\n        return 0x30;\r\n    }\r\n\r\n    function proofType_Native()\r\n    public\r\n    pure\r\n    returns (byte) {\r\n        return 0xF0;\r\n    }\r\n\r\n    function proofStorage_IPFS()\r\n    public\r\n    pure\r\n    returns (byte) {\r\n        return 0x01;\r\n    }\r\n\r\n    //OraclizeAddrResolverI constant public OAR = oraclize_setNetwork();\r\n\r\n    function OAR()\r\n    public\r\n    view\r\n    returns (OraclizeAddrResolverI) {\r\n        return oraclize_setNetwork();\r\n    }\r\n\r\n    //OraclizeI constant public oraclize = OraclizeI(OAR.getAddress());\r\n\r\n    function oraclize()\r\n    public\r\n    view\r\n    returns (OraclizeI) {\r\n        return OraclizeI(OAR().getAddress());\r\n    }\r\n\r\n    function oraclize_setNetwork()\r\n    public\r\n    view\r\n    returns(OraclizeAddrResolverI){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            return OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            return OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            return OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            return OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            return OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            return OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            return OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n        }\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource)\r\n    public\r\n    view\r\n    returns (uint){\r\n        return oraclize().getPrice(datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource, uint gaslimit)\r\n    public\r\n    view\r\n    returns (uint){\r\n        return oraclize().getPrice(datasource, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg)\r\n    public\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, arg);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg)\r\n    public\r\n    returns (bytes32 id){\r\n        OraclizeI oracle = oraclize();\r\n        uint price = oracle.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oracle.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg, uint gaslimit)\r\n    public\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, arg, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit)\r\n    public\r\n    returns (bytes32 id){\r\n        OraclizeI oracle = oraclize();\r\n        uint price = oracle.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oracle.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg1, string arg2)\r\n    public\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, arg1, arg2);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2)\r\n    public\r\n    returns (bytes32 id){\r\n        OraclizeI oracle = oraclize();\r\n        uint price = oracle.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oracle.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit)\r\n    public\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit)\r\n    public\r\n    returns (bytes32 id){\r\n        OraclizeI oracle = oraclize();\r\n        uint price = oracle.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oracle.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n\r\n    // internalize w/o experimental\r\n    function oraclize_query(string datasource, string[] argN)\r\n    internal\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, argN);\r\n    }\r\n\r\n    // internalize w/o experimental\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN)\r\n    internal\r\n    returns (bytes32 id){\r\n        OraclizeI oracle = oraclize();\r\n        uint price = oracle.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oracle.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n\r\n    // internalize w/o experimental\r\n    function oraclize_query(string datasource, string[] argN, uint gaslimit)\r\n    internal\r\n    returns (bytes32 id){\r\n        return oraclize_query(0, datasource, argN, gaslimit);\r\n    }\r\n\r\n    // internalize w/o experimental\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit)\r\n    internal\r\n    returns (bytes32 id){\r\n        OraclizeI oracle = oraclize();\r\n        uint price = oracle.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oracle.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n\r\n    function oraclize_cbAddress()\r\n    public\r\n    view\r\n    returns (address){\r\n        return oraclize().cbAddress();\r\n    }\r\n\r\n    function oraclize_setProof(byte proofP)\r\n    public {\r\n        return oraclize().setProofType(proofP);\r\n    }\r\n\r\n    function oraclize_setCustomGasPrice(uint gasPrice)\r\n    public {\r\n        return oraclize().setCustomGasPrice(gasPrice);\r\n    }\r\n\r\n    // setting to internal doesn't cause major increase in deployment and saves gas\r\n    // per use, for this tiny function\r\n    function getCodeSize(address _addr)\r\n    public\r\n    view\r\n    returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    // expects 0x prefix\r\n    function parseAddr(string _a)\r\n    public\r\n    pure\r\n    returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string _a, string _b)\r\n    public\r\n    pure\r\n    returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function indexOf(string _haystack, string _needle)\r\n    public\r\n    pure\r\n    returns (int) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e)\r\n    internal\r\n    pure\r\n    returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d)\r\n    internal\r\n    pure\r\n    returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c)\r\n    internal\r\n    pure\r\n    returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b)\r\n    internal\r\n    pure\r\n    returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a)\r\n    public\r\n    pure\r\n    returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b)\r\n    public\r\n    pure\r\n    returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint i)\r\n    internal\r\n    pure\r\n    returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    function stra2cbor(string[] arr)\r\n    internal\r\n    pure\r\n    returns (bytes) {\r\n        uint arrlen = arr.length;\r\n\r\n        // get correct cbor output length\r\n        uint outputlen = 0;\r\n        bytes[] memory elemArray = new bytes[](arrlen);\r\n        for (uint i = 0; i < arrlen; i++) {\r\n            elemArray[i] = (bytes(arr[i]));\r\n            outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types\r\n        }\r\n        uint ctr = 0;\r\n        uint cborlen = arrlen + 0x80;\r\n        outputlen += byte(cborlen).length;\r\n        bytes memory res = new bytes(outputlen);\r\n\r\n        while (byte(cborlen).length > ctr) {\r\n            res[ctr] = byte(cborlen)[ctr];\r\n            ctr++;\r\n        }\r\n        for (i = 0; i < arrlen; i++) {\r\n            res[ctr] = 0x5F;\r\n            ctr++;\r\n            for (uint x = 0; x < elemArray[i].length; x++) {\r\n                // if there's a bug with larger strings, this may be the culprit\r\n                if (x % 23 == 0) {\r\n                    uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x;\r\n                    elemcborlen += 0x40;\r\n                    uint lctr = ctr;\r\n                    while (byte(elemcborlen).length > ctr - lctr) {\r\n                        res[ctr] = byte(elemcborlen)[ctr - lctr];\r\n                        ctr++;\r\n                    }\r\n                }\r\n                res[ctr] = elemArray[i][x];\r\n                ctr++;\r\n            }\r\n            res[ctr] = 0xFF;\r\n            ctr++;\r\n        }\r\n        return res;\r\n    }    \r\n}\r\n// </ORACLIZE_API_LIB>","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"oraclize_setCustomGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"datasource\",\"type\":\"string\"}],\"name\":\"oraclize_getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"arg\",\"type\":\"string\"},{\"name\":\"gaslimit\",\"type\":\"uint256\"}],\"name\":\"oraclize_query\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"arg1\",\"type\":\"string\"},{\"name\":\"arg2\",\"type\":\"string\"},{\"name\":\"gaslimit\",\"type\":\"uint256\"}],\"name\":\"oraclize_query\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"arg1\",\"type\":\"string\"},{\"name\":\"arg2\",\"type\":\"string\"}],\"name\":\"oraclize_query\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclize\",\"outputs\":[{\"name\":\"\",\"type\":\"OraclizeI\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"}],\"name\":\"parseInt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proofType_NONE\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"arg\",\"type\":\"string\"}],\"name\":\"oraclize_query\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"arg1\",\"type\":\"string\"},{\"name\":\"arg2\",\"type\":\"string\"}],\"name\":\"oraclize_query\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"arg1\",\"type\":\"string\"},{\"name\":\"arg2\",\"type\":\"string\"},{\"name\":\"gaslimit\",\"type\":\"uint256\"}],\"name\":\"oraclize_query\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"},{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"arg\",\"type\":\"string\"}],\"name\":\"oraclize_query\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proofType_Native\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proofStorage_IPFS\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_haystack\",\"type\":\"string\"},{\"name\":\"_needle\",\"type\":\"string\"}],\"name\":\"indexOf\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proofType_TLSNotary\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"}],\"name\":\"parseAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"gaslimit\",\"type\":\"uint256\"}],\"name\":\"oraclize_getPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"datasource\",\"type\":\"string\"},{\"name\":\"arg\",\"type\":\"string\"},{\"name\":\"gaslimit\",\"type\":\"uint256\"}],\"name\":\"oraclize_query\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getCodeSize\",\"outputs\":[{\"name\":\"_size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclize_cbAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"},{\"name\":\"_b\",\"type\":\"uint256\"}],\"name\":\"parseInt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclize_setNetwork\",\"outputs\":[{\"name\":\"\",\"type\":\"OraclizeAddrResolverI\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OAR\",\"outputs\":[{\"name\":\"\",\"type\":\"OraclizeAddrResolverI\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proofType_Ledger\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proofP\",\"type\":\"bytes1\"}],\"name\":\"oraclize_setProof\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_a\",\"type\":\"string\"},{\"name\":\"_b\",\"type\":\"string\"}],\"name\":\"strCompare\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proofType_Android\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"}]","ContractName":"oraclizeLib","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cc780730e92b4b3897c1e12b9a9c80db142f8a4c324cbf51ee4a9541a16664e2"}]}