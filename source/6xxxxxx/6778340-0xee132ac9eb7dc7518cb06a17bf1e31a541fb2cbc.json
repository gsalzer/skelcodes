{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/IERC20Token.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public view returns (string) {}\r\n    function symbol() public view returns (string) {}\r\n    function decimals() public view returns (uint8) {}\r\n    function totalSupply() public view returns (uint256) {}\r\n    function balanceOf(address _owner) public view returns (uint256) { _owner; }\r\n    function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/Bancor.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\ncontract Bancor {\r\n  function claimAndConvert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public returns (uint256) {}\r\n  function convert(IERC20Token[] _path, uint256 _amount, uint256 _minReturn) public payable returns (uint256) {}\r\n}\r\n\r\n// File: contracts/EtherDelta.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract EtherDelta {\r\n  function deposit() payable {}\r\n  function depositToken(address token, uint amount) {}\r\n  function withdraw(uint amount) {}\r\n  function withdrawToken(address token, uint amount) {}\r\n  function trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s, uint amount) {}\r\n  function balanceOf(address token, address user) constant returns (uint) {}\r\n}\r\n\r\n// File: contracts/Token.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract Token {\r\n  /// @return total amount of tokens\r\n  function totalSupply() constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) returns (bool success) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\n// File: contracts/TokenNoBool.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract TokenNoBool {\r\n  /// @return total amount of tokens\r\n  function totalSupply() constant returns (uint256 supply) {}\r\n\r\n  /// @param _owner The address from which the balance will be retrieved\r\n  /// @return The balance\r\n  function balanceOf(address _owner) constant returns (uint256 balance) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `msg.sender`\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transfer(address _to, uint256 _value) {}\r\n\r\n  /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n  /// @param _from The address of the sender\r\n  /// @param _to The address of the recipient\r\n  /// @param _value The amount of token to be transferred\r\n  /// @return Whether the transfer was successful or not\r\n  function transferFrom(address _from, address _to, uint256 _value) {}\r\n\r\n  /// @notice `msg.sender` approves `_addr` to spend `_value` tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @param _value The amount of wei to be approved for transfer\r\n  /// @return Whether the approval was successful or not\r\n  function approve(address _spender, uint256 _value) {}\r\n\r\n  /// @param _owner The address of the account owning tokens\r\n  /// @param _spender The address of the account able to transfer the tokens\r\n  /// @return Amount of remaining tokens allowed to spent\r\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {}\r\n\r\n  event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n  event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n  uint public decimals;\r\n  string public name;\r\n}\r\n\r\n// File: contracts/GST2.sol\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract GST2 {\r\n  function mint(uint256 value) public {}\r\n  function freeUpTo(uint256 value) public returns (uint256 freed) {}\r\n  function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) {}\r\n}\r\n\r\n// File: contracts/Arbot.sol\r\n\r\npragma solidity ^0.4.24;\r\npragma experimental ABIEncoderV2;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Arbot {\r\n  enum Exchange { ETHERDELTA, BANCOR }\r\n  struct DeltaTrade {\r\n    DeltaOrder order;\r\n    // amountMinusFee (- 0.3% of delta fee)\r\n    uint256 amount;\r\n  }\r\n\r\n  struct DeltaOrder {\r\n    // 0 tokenGet\r\n    // 1 tokenGive\r\n    // 2 order user\r\n    address[3] addresses;\r\n    // 0 amountGet\r\n    // 1 amountGive\r\n    // 2 expires\r\n    // 3 nonce\r\n    uint256[4] values;\r\n    uint8 v;\r\n    bytes32 r;\r\n    bytes32 s;\r\n  }\r\n\r\n  EtherDelta etherDelta;\r\n  Bancor bancor;\r\n  address owner;\r\n  address executor;\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwnerAndExecutor() {\r\n    require(msg.sender == owner || msg.sender == executor);\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n    executor = 0xA21623FD5dd105F0d2d61327438F4C695aBA6dC3;\r\n  }\r\n\r\n  function setExecutor(address _newExecutor) public onlyOwner {\r\n    executor = _newExecutor;\r\n  }\r\n\r\n  function atomicTrade(\r\n    Exchange buyExchange,\r\n    IERC20Token[] _path,\r\n    // addresses:\r\n    // 0 etherdelta contract address\r\n    // 1 bancor contract address\r\n    // 2 token to trade contract address\r\n    address[3] addresses,\r\n    // values:\r\n    // 0 bancorAmount\r\n    // 1 bancorMinReturn\r\n    // 2 depositAmount\r\n    uint256[3] values,\r\n    DeltaTrade[] deltaTrades,\r\n    bool balanceCheck,\r\n    bool _isProperERC20\r\n  ) internal returns (uint256, uint256) {\r\n    require(addresses[0] != address(0));\r\n    require(addresses[1] != address(0));\r\n    require(addresses[2] != address(0));\r\n\r\n    etherDelta = EtherDelta(addresses[0]);\r\n    bancor = Bancor(addresses[1]);\r\n\r\n    uint256 balanceBefore = address(this).balance;\r\n    uint256 tokenBalance = 0;\r\n    uint256 ethReturned = 0;\r\n\r\n    if (buyExchange == Exchange.ETHERDELTA) {\r\n      tokenBalance = makeBuyTradeEtherDeltaTrade(deltaTrades, values[2]);\r\n      ensureAllowance(addresses[2], address(bancor), tokenBalance, _isProperERC20);\r\n      ethReturned = bancor.claimAndConvert(_path, tokenBalance, values[1]);\r\n    } else {\r\n      tokenBalance = bancor.convert.value(values[0])(_path, values[0], values[1]);\r\n      ensureAllowance(addresses[2], address(etherDelta), tokenBalance, _isProperERC20);\r\n      ethReturned = makeSellTradeEtherDeltaTrade(deltaTrades, tokenBalance);\r\n    }\r\n\r\n    if (balanceCheck) {\r\n      require(address(this).balance >= balanceBefore - 1); // 1 due to rounding errors\r\n    }\r\n    return (address(this).balance, ethReturned);\r\n  }\r\n\r\n  // we are filling sell orders in delta\r\n  function makeBuyTradeEtherDeltaTrade(DeltaTrade[] trades, uint256 depositValue) private returns (uint256) {\r\n    etherDelta.deposit.value(depositValue)(); // we deposit \"amount\" (which is in order.amountGet terms which is eth)\r\n\r\n    for (uint256 i = 0; i < trades.length; i++) {\r\n      etherDelta.trade(\r\n        trades[i].order.addresses[0], // tokenGet is 0x0\r\n        trades[i].order.values[0], // amountGet\r\n        trades[i].order.addresses[1], // tokenGive\r\n        trades[i].order.values[1], // amountGive\r\n\r\n        trades[i].order.values[2], // expires\r\n        trades[i].order.values[3], // nonce\r\n        trades[i].order.addresses[2], // trades[i].order user\r\n        trades[i].order.v, trades[i].order.r, trades[i].order.s, // signature\r\n        trades[i].amount // amountMinusFee (- 0.3% of delta fee)\r\n      );\r\n    }\r\n\r\n    // ALWAYS get back eth and tokens in surplus\r\n    deltaWithdrawAllEth();\r\n    return deltaWithdrawAllTokens(trades[0].order.addresses[1]); // tokenGive\r\n  }\r\n\r\n  // we are filling a buy order in delta\r\n  function makeSellTradeEtherDeltaTrade(DeltaTrade[] trades, uint256 tokenBalance) private returns (uint256) {\r\n    etherDelta.depositToken(\r\n      trades[0].order.addresses[0], // order.tokenGet\r\n      tokenBalance // which should always be <= tokenBalance\r\n    );\r\n\r\n    for (uint256 i = 0; i < trades.length; i++) {\r\n      etherDelta.trade(\r\n        trades[i].order.addresses[0], // tokenGet\r\n        trades[i].order.values[0], // amountGet\r\n        trades[i].order.addresses[1], // tokenGive is 0x0\r\n        trades[i].order.values[1], // amountGive\r\n        trades[i].order.values[2], // expires\r\n        trades[i].order.values[3], // nonce\r\n        trades[i].order.addresses[2], // trades[i].order user\r\n        trades[i].order.v, trades[i].order.r, trades[i].order.s, // signature\r\n        trades[i].amount // amount (- 0.3% of delta fee)\r\n      );\r\n    }\r\n\r\n    // ALWAYS get back tokens and eth in surplus\r\n    deltaWithdrawAllTokens(trades[0].order.addresses[0]); // tokenGet\r\n    return deltaWithdrawAllEth();\r\n  }\r\n\r\n  function deltaWithdrawAllEth() public onlyOwnerAndExecutor returns (uint256) {\r\n    uint256 ethBalance = etherDelta.balanceOf(0x0000000000000000000000000000000000000000, address(this));\r\n    if (ethBalance != 0) {\r\n      etherDelta.withdraw(ethBalance);\r\n    }\r\n    return ethBalance;\r\n  }\r\n\r\n  function deltaWithdrawAllTokens(address token) public onlyOwnerAndExecutor returns (uint256) {\r\n    uint256 tokenBalance = etherDelta.balanceOf(token, address(this));\r\n    if (tokenBalance != 0) {\r\n      etherDelta.withdrawToken(token, tokenBalance);\r\n    }\r\n    return tokenBalance;\r\n  }\r\n\r\n  /*\r\n   * Makes token tradeable by setting an allowance for etherDelta and BancorNetwork contract.\r\n   * Also sets an allowance for the owner of the contracts therefore allowing to withdraw tokens.\r\n   */\r\n  /* function setAllowances(address tokenAddr, uint256 amount) public onlyOwner { */\r\n    /* ensureAllowance(tokenAddr, address(etherDelta), amount); */\r\n    /* ensureAllowance(tokenAddr, address(bancor), amount); */\r\n    /* ensureAllowance(tokenAddr, address(this), amount); // This should not be needed */\r\n    /* ensureAllowance(tokenAddr, owner, amount); */\r\n  /* } */\r\n\r\n\r\n  function ensureAllowance(address tokenAddr, address _spender, uint256 _value, bool _isProperERC20) private {\r\n    // needed for tokens that do not return  book for approve\r\n    if (_isProperERC20) {\r\n      Token _token = Token(tokenAddr);\r\n      // check if allowance for the given amount already exists\r\n      if (_token.allowance(this, _spender) >= _value) {\r\n        return;\r\n      }\r\n\r\n      // if the allowance is nonzero, must reset it to 0 first\r\n      if (_token.allowance(this, _spender) != 0) {\r\n        _token.approve(_spender, 0);\r\n      }\r\n\r\n      // approve the new allowance\r\n      _token.approve(_spender, _value);\r\n    } else {\r\n      TokenNoBool _tokenNoBool = TokenNoBool(tokenAddr);\r\n      // check if allowance for the given amount already exists\r\n      if (_tokenNoBool.allowance(this, _spender) >= _value) {\r\n        return;\r\n      }\r\n\r\n      // if the allowance is nonzero, must reset it to 0 first\r\n      if (_tokenNoBool.allowance(this, _spender) != 0) {\r\n        _tokenNoBool.approve(_spender, 0);\r\n      }\r\n\r\n      // approve the new allowance\r\n      _tokenNoBool.approve(_spender, _value);\r\n    }\r\n  }\r\n\r\n  function withdraw() external onlyOwner {\r\n    owner.transfer(address(this).balance);\r\n  }\r\n\r\n  function withdrawToken(address _token, bool _isProperERC20) external onlyOwner {\r\n    // needed for tokens that do not return bool for transfer\r\n    if (_isProperERC20) {\r\n      Token token = Token(_token);\r\n      token.transfer(owner, token.balanceOf(address(this)));\r\n    } else {\r\n      TokenNoBool tokenNoBool = TokenNoBool(_token);\r\n      tokenNoBool.transfer(owner, tokenNoBool.balanceOf(address(this)));\r\n    }\r\n  }\r\n\r\n  function destroyContract() external onlyOwner {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  // fallback function for getting eth sent directly to the contract address\r\n  function() public payable {}\r\n\r\n  // ======== Gas Token functions\r\n  function storeGas(uint256 num_tokens) public onlyOwner {\r\n    GST2 gst2 = GST2(0x0000000000b3F879cb30FE243b4Dfee438691c04);\r\n    gst2.mint(num_tokens);\r\n  }\r\n  function useCheapGas(uint256 num_tokens) private returns (uint256 freed) {\r\n    // see here https://github.com/projectchicago/gastoken/blob/master/contract/gst2_free_example.sol\r\n    GST2 gst2 = GST2(0x0000000000b3F879cb30FE243b4Dfee438691c04);\r\n\r\n    uint256 safe_num_tokens = 0;\r\n    uint256 gas = msg.gas;\r\n\r\n    if (gas >= 27710) {\r\n      safe_num_tokens = (gas - 27710) / (1148 + 5722 + 150);\r\n    }\r\n\r\n    if (num_tokens > safe_num_tokens) {\r\n      num_tokens = safe_num_tokens;\r\n    }\r\n\r\n    if (num_tokens > 0) {\r\n      return gst2.freeUpTo(num_tokens);\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  //\r\n  function atomicTradeGST(\r\n    Exchange buyExchange,\r\n    IERC20Token[] _path,\r\n    address[3] addresses,\r\n    uint256[3] values,\r\n    DeltaTrade[] deltaTrades,\r\n    bool balanceCheck,\r\n    uint256 numTokens,\r\n    bool _isProperERC20\r\n  ) public onlyOwnerAndExecutor returns (uint256, uint256) {\r\n    // Free numTokens but always pass\r\n    require(useCheapGas(numTokens) >= 0);\r\n    return atomicTrade(\r\n      buyExchange,\r\n      _path,\r\n      addresses,\r\n      values,\r\n      deltaTrades,\r\n      balanceCheck,\r\n      _isProperERC20\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_isProperERC20\",\"type\":\"bool\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroyContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newExecutor\",\"type\":\"address\"}],\"name\":\"setExecutor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deltaWithdrawAllEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"num_tokens\",\"type\":\"uint256\"}],\"name\":\"storeGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyExchange\",\"type\":\"uint8\"},{\"name\":\"_path\",\"type\":\"address[]\"},{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"values\",\"type\":\"uint256[3]\"},{\"components\":[{\"components\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"values\",\"type\":\"uint256[4]\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"order\",\"type\":\"tuple\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deltaTrades\",\"type\":\"tuple[]\"},{\"name\":\"balanceCheck\",\"type\":\"bool\"},{\"name\":\"numTokens\",\"type\":\"uint256\"},{\"name\":\"_isProperERC20\",\"type\":\"bool\"}],\"name\":\"atomicTradeGST\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"deltaWithdrawAllTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Arbot","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","LicenseType":"MIT","SwarmSource":"bzzr://2fb704f8324a0451edad6e9021236eb4e8258769408ba0bc8be7915046ff8180"}]}