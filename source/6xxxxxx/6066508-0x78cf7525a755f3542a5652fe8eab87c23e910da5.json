{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\ninterface P3D {\r\n  function() payable external;\r\n  function buy(address _playerAddress) payable external returns(uint256);\r\n  function sell(uint256 _amountOfTokens) external;\r\n  function reinvest() external;\r\n  function withdraw() external;\r\n  function exit() external;\r\n  function dividendsOf(address _playerAddress) external view returns(uint256);\r\n  function balanceOf(address _playerAddress) external view returns(uint256);\r\n  function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n  function stakingRequirement() external view returns(uint256);\r\n  function myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n}\r\n\r\ncontract ProxyCrop {\r\n    address public owner;\r\n    bool public disabled;\r\n\r\n    constructor(address _owner, address _referrer) public payable {\r\n      owner = _owner;\r\n\r\n      // plant some seeds\r\n      if (msg.value > 0) {\r\n        P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe).buy.value(msg.value)(_referrer);\r\n      }\r\n    }\r\n\r\n    function() public payable {\r\n      assembly {\r\n        // Copy msg.data. We take full control of memory in this inline assembly\r\n        // block because it will not return to Solidity code. We overwrite the\r\n        // Solidity scratch pad at memory position 0.\r\n        calldatacopy(0, 0, calldatasize)\r\n\r\n        // Call the implementation.\r\n        // out and outsize are 0 because we don't know the size yet.\r\n        let result := delegatecall(gas, 0x0D6C969d0004B431189f834203CE0f5530e06259, 0, calldatasize, 0, 0)\r\n\r\n        // Copy the returned data.\r\n        returndatacopy(0, 0, returndatasize)\r\n\r\n        switch result\r\n        // delegatecall returns 0 on error.\r\n        case 0 { revert(0, returndatasize) }\r\n        default { return(0, returndatasize) }\r\n      }\r\n    }\r\n}\r\n\r\ncontract Farm {\r\n  // address mapping for owner => crop\r\n  mapping (address => address) public crops;\r\n\r\n  // event for creating a new crop\r\n  event CreateCrop(address indexed owner, address indexed crop);\r\n\r\n  /**\r\n   * @dev Create a crop contract that can hold P3D and auto-reinvest.\r\n   * @param _referrer referral address for buying P3D.\r\n   */\r\n  function create(address _referrer) external payable {\r\n    // sender must not own a crop\r\n    require(crops[msg.sender] == address(0));\r\n\r\n    // create a new crop\r\n    crops[msg.sender] = (new ProxyCrop).value(msg.value)(msg.sender, _referrer);\r\n\r\n    // fire event\r\n    emit CreateCrop(msg.sender, crops[msg.sender]);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"crops\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"create\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"crop\",\"type\":\"address\"}],\"name\":\"CreateCrop\",\"type\":\"event\"}]","ContractName":"Farm","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://598ad4ef9e43284808c6ce0a4eaf71b752223ed9a190982c8f2e5f614c12e384"}]}