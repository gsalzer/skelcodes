{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\n\r\n/**\r\n* @title SafeMath by OpenZeppelin (commit: 5daaf60)\r\n* @dev Math operations with safety checks that throw on error\r\n*/\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) \r\n            return 0;\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface Token {\r\n    function transfer(address to, uint256 value) external returns (bool success);\r\n    function burn(uint256 amount) external;\r\n    function balanceOf(address owner) external returns (uint256 balance);\r\n}\r\n\r\ncontract Crowdsale {\r\n    address public owner;                       // Address of the contract owner\r\n    address public fundRaiser;                  // Address which can withraw funds raised\r\n    uint256 public amountRaisedInWei;           // Total amount of ether raised in wei\r\n    uint256 public tokensSold;                  // Total number of tokens sold\r\n    uint256 public tokensClaimed;               // Total Number of tokens claimed by participants\r\n    uint256 public icoDeadline;                 // Duration this ICO will end\r\n    uint256 public tokensClaimableAfter;        // Duration after tokens will be claimable\r\n    uint256 public tokensPerWei;                // How many token a buyer gets per wei \r\n    Token public tokenReward;                   // Token being distributed \r\n\r\n    // Map of crowdsale participants, address as key and Participant structure as value\r\n    mapping(address => Participant) public participants;    \r\n\r\n    // This is a type for a single Participant\r\n    struct Participant {\r\n        bool whitelisted;\r\n        uint256 tokens;\r\n        bool tokensClaimed;\r\n    }\r\n\r\n    event FundTransfer(address to, uint amount);\r\n\r\n    modifier afterIcoDeadline() { if (now >= icoDeadline) _; }\r\n    modifier afterTokensClaimableDeadline() { if (now >= tokensClaimableAfter) _; }\r\n    modifier onlyOwner() { require(msg.sender == owner); _; }\r\n\r\n    /**\r\n     * Constructor function\r\n     */\r\n    function Crowdsale(\r\n        address fundRaiserAccount,\r\n        uint256 durationOfIcoInDays,\r\n        uint256 durationTokensClaimableAfterInDays,\r\n        uint256 tokensForOneWei,\r\n        address addressOfToken\r\n    ) \r\n        public\r\n    {\r\n        owner = msg.sender;\r\n        fundRaiser = fundRaiserAccount;\r\n        icoDeadline = now + durationOfIcoInDays * 1 days;\r\n        tokensClaimableAfter = now + durationTokensClaimableAfterInDays * 1 days;\r\n        tokensPerWei = tokensForOneWei;\r\n        tokenReward = Token(addressOfToken);\r\n    }\r\n\r\n    /**\r\n     * Fallback function: Buy token\r\n     * The function without name is the default function that is called whenever anyone sends funds to a contract.\r\n     * Reserves a number tokens per participant by multiplying tokensPerWei and sent ether in wei.\r\n     * This function is able to buy token when the following four cases are all met:\r\n     *      - Before ICO deadline\r\n     *      - Payer address is whitelisted in this contract\r\n     *      - Sent ether is equal or bigger than minimum transaction (0.05 ether) \r\n     *      - There are enough tokens to sell in this contract (tokens balance of contract minus tokensSold)\r\n     */\r\n    function() payable public {\r\n        require(now < icoDeadline);\r\n        require(participants[msg.sender].whitelisted);             \r\n        require(msg.value >= 0.01 ether); \r\n        uint256 tokensToBuy = SafeMath.mul(msg.value, tokensPerWei);\r\n        require(tokensToBuy <= SafeMath.sub(tokenReward.balanceOf(this), tokensSold));\r\n        participants[msg.sender].tokens = SafeMath.add(participants[msg.sender].tokens, tokensToBuy);      \r\n        amountRaisedInWei = SafeMath.add(amountRaisedInWei, msg.value);\r\n        tokensSold = SafeMath.add(tokensSold, tokensToBuy);\r\n    }\r\n    \r\n    /**\r\n    * Add single address into the whitelist. \r\n    * Note: Use this function for a single address to save transaction fee\r\n    */ \r\n    function addToWhitelist(address addr) onlyOwner public {\r\n        participants[addr].whitelisted = true;   \r\n    }\r\n\r\n    /**\r\n    * Remove single address from the whitelist. \r\n    * Note: Use this function for a single address to save transaction fee\r\n    */ \r\n    function removeFromWhitelist(address addr) onlyOwner public {\r\n        participants[addr].whitelisted = false;   \r\n    }\r\n\r\n    /**\r\n    * Add multiple addresses into the whitelist. \r\n    * Note: Use this function for more than one address to save transaction fee\r\n    */ \r\n    function addAddressesToWhitelist(address[] addresses) onlyOwner public {\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            participants[addresses[i]].whitelisted = true;   \r\n        }\r\n    }\r\n\r\n    /**\r\n    * Remove multiple addresses from the whitelist\r\n    * Note: Use this function for more than one address to save transaction fee\r\n    */ \r\n    function removeAddressesFromWhitelist(address[] addresses) onlyOwner public {\r\n        for (uint i = 0; i < addresses.length; i++) {\r\n            participants[addresses[i]].whitelisted = false;   \r\n        }\r\n    }\r\n\r\n    // ----------- After ICO Deadline ------------\r\n\r\n    /**\r\n    * Fundraiser address claims the raised funds after ICO deadline\r\n    */ \r\n    function withdrawFunds() afterIcoDeadline public {\r\n        require(fundRaiser == msg.sender);\r\n        fundRaiser.transfer(address(this).balance);\r\n        emit FundTransfer(fundRaiser, address(this).balance);        \r\n    }\r\n\r\n    /**\r\n    * Transfer unsold tokens after ICO deadline\r\n    * Note: This function is designed to transfer unsold Pre-ICO tokens into Final-ICO contract.\r\n    */ \r\n    function transferUnsoldTokens(address toAddress) onlyOwner afterIcoDeadline public {\r\n        uint256 tokensUnclaimed = SafeMath.sub(tokensSold, tokensClaimed);\r\n        uint256 unsoldTokens = SafeMath.sub(tokenReward.balanceOf(this), tokensUnclaimed);\r\n        tokenReward.transfer(toAddress, unsoldTokens);\r\n    }\r\n\r\n    // ----------- After Tokens Claimable Duration ------------\r\n\r\n    /**\r\n    * Each participant will be able to claim his tokens after duration tokensClaimableAfter\r\n    */ \r\n    function withdrawTokens() afterTokensClaimableDeadline public {\r\n        require(participants[msg.sender].whitelisted);                \r\n        require(!participants[msg.sender].tokensClaimed);        \r\n        participants[msg.sender].tokensClaimed = true;\r\n        uint256 tokens = participants[msg.sender].tokens;\r\n        tokenReward.transfer(msg.sender, tokens); \r\n        tokensClaimed = SafeMath.add(tokensClaimed, tokens);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"participants\",\"outputs\":[{\"name\":\"whitelisted\",\"type\":\"bool\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"tokensClaimed\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensPerWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoDeadline\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaisedInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddress\",\"type\":\"address\"}],\"name\":\"transferUnsoldTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensClaimableAfter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundRaiser\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"fundRaiserAccount\",\"type\":\"address\"},{\"name\":\"durationOfIcoInDays\",\"type\":\"uint256\"},{\"name\":\"durationTokensClaimableAfterInDays\",\"type\":\"uint256\"},{\"name\":\"tokensForOneWei\",\"type\":\"uint256\"},{\"name\":\"addressOfToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FundTransfer\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d2ce793c7d1799b0015386331eabb7731022885300000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000157c0000000000000000000000008ca7b491008aec118b5bb59124ecbda8fb12205d","Library":"","SwarmSource":"bzzr://0d1105601bf2cbd6dc849dea078b9715ba8938bd5b85b43bc7e5f59ac06346b4"}]}