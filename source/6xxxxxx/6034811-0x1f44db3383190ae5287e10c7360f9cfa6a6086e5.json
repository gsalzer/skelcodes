{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract WETH9 {\r\n    string public name     = \"Wrapped Ether\";\r\n    string public symbol   = \"WETH\";\r\n    uint8  public decimals = 18;\r\n\r\n    event  Approval(address indexed src, address indexed guy, uint wad);\r\n    event  Transfer(address indexed src, address indexed dst, uint wad);\r\n    event  Deposit(address indexed dst, uint wad);\r\n    event  Withdrawal(address indexed src, uint wad);\r\n\r\n    mapping (address => uint)                       public  balanceOf;\r\n    mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n    function() public payable {\r\n        deposit();\r\n    }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        Deposit(msg.sender, msg.value);\r\n    }\r\n    function withdraw(uint wad) public {\r\n        require(balanceOf[msg.sender] >= wad);\r\n        balanceOf[msg.sender] -= wad;\r\n        msg.sender.transfer(wad);\r\n        Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return this.balance;\r\n    }\r\n\r\n    function approve(address guy, uint wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint wad)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(balanceOf[src] >= wad);\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n            require(allowance[src][msg.sender] >= wad);\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ninterface Registry {\r\n    function isAffiliated(address _affiliate) external returns (bool);\r\n}\r\n\r\ncontract Affiliate {\r\n  struct Share {\r\n      address shareholder;\r\n      uint stake;\r\n  }\r\n\r\n  Share[] shares;\r\n  uint public totalShares;\r\n  string public relayerName;\r\n  address registry;\r\n  WETH9 weth;\r\n\r\n  event Payout(address indexed token, uint amount);\r\n\r\n  function init(address _registry, address[] shareholders, uint[] stakes, address _weth, string _name) public returns (bool) {\r\n    require(totalShares == 0);\r\n    require(shareholders.length == stakes.length);\r\n    weth = WETH9(_weth);\r\n    totalShares = 0;\r\n    for(uint i=0; i < shareholders.length; i++) {\r\n        shares.push(Share({shareholder: shareholders[i], stake: stakes[i]}));\r\n        totalShares += stakes[i];\r\n    }\r\n    relayerName = _name;\r\n    registry = _registry;\r\n    return true;\r\n  }\r\n  function payout(address[] tokens) public {\r\n      // Payout all stakes at once, so we don't have to do bookkeeping on who has\r\n      // claimed their shares and who hasn't. If the number of shareholders is large\r\n      // this could run into some gas limits. In most cases, I expect two\r\n      // shareholders, but it could be a small handful. This also means the caller\r\n      // must pay gas for everyone's payouts.\r\n      for(uint i=0; i < tokens.length; i++) {\r\n          ERC20 token = ERC20(tokens[i]);\r\n          uint balance = token.balanceOf(this);\r\n          for(uint j=0; j < shares.length; j++) {\r\n              token.transfer(shares[j].shareholder, SafeMath.mul(balance, shares[j].stake) / totalShares);\r\n          }\r\n          emit Payout(tokens[i], balance);\r\n      }\r\n  }\r\n  function isAffiliated(address _affiliate) public returns (bool)\r\n  {\r\n      return Registry(registry).isAffiliated(_affiliate);\r\n  }\r\n\r\n  function() public payable {\r\n    // If we get paid in ETH, convert to WETH so payouts work the same.\r\n    // Converting to WETH also makes payouts a bit safer, as we don't have to\r\n    // worry about code execution if the stakeholder is a contract.\r\n    weth.deposit.value(msg.value)();\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"shareholders\",\"type\":\"address[]\"},{\"name\":\"stakes\",\"type\":\"uint256[]\"},{\"name\":\"_weth\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"init\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affiliate\",\"type\":\"address\"}],\"name\":\"isAffiliated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayerName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"}]","ContractName":"Affiliate","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c69ee9abeb2f5ab540afbd322a0faabb5b5afec2e59cc693b14b86b52f84c50f"}]}