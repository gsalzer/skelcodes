{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n *\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n *\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * @dev and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      \"\\x19Ethereum Signed Message:\\n32\",\r\n      hash\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title TokenDestructible:\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev Base contract that can be destroyed by owner. All funds in contract including\r\n * listed tokens will be sent to the owner.\r\n */\r\ncontract TokenDestructible is Ownable {\r\n\r\n  constructor() public payable { }\r\n\r\n  /**\r\n   * @notice Terminate contract and refund to owner\r\n   * @param tokens List of addresses of ERC20 or ERC20Basic token contracts to\r\n   refund.\r\n   * @notice The called token contracts could try to re-enter this contract. Only\r\n   supply token contracts you trust.\r\n   */\r\n  function destroy(address[] tokens) onlyOwner public {\r\n\r\n    // Transfer tokens to owner\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      ERC20Basic token = ERC20Basic(tokens[i]);\r\n      uint256 balance = token.balanceOf(this);\r\n      token.transfer(owner, balance);\r\n    }\r\n\r\n    // Transfer Eth to owner and terminate contract\r\n    selfdestruct(owner);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title WIBToken\r\n * @author Wibson Development Team <developers@wibson.org>\r\n * @notice Wibson Oficial Token, this is an ERC20 standard compliant token.\r\n * @dev WIBToken token has an initial supply of 9 billion tokens with 9 decimals.\r\n */\r\ncontract WIBToken is StandardToken {\r\n  string public constant name = \"WIBSON\"; // solium-disable-line uppercase\r\n  string public constant symbol = \"WIB\"; // solium-disable-line uppercase\r\n  uint8 public constant decimals = 9; // solium-disable-line uppercase\r\n\r\n  // solium-disable-next-line zeppelin/no-arithmetic-operations\r\n  uint256 public constant INITIAL_SUPPLY = 9000000000 * (10 ** uint256(decimals));\r\n\r\n  constructor() public {\r\n    totalSupply_ = INITIAL_SUPPLY;\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\n    emit Transfer(address(0), msg.sender, INITIAL_SUPPLY);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title DataOrder\r\n * @author Wibson Development Team <developers@wibson.org>\r\n * @notice `DataOrder` is the contract between a given buyer and a set of sellers.\r\n *         This holds the information about the \"deal\" between them and how the\r\n *         transaction has evolved.\r\n */\r\ncontract DataOrder is Ownable {\r\n  modifier validAddress(address addr) {\r\n    require(addr != address(0));\r\n    require(addr != address(this));\r\n    _;\r\n  }\r\n\r\n  enum OrderStatus {\r\n    OrderCreated,\r\n    NotaryAdded,\r\n    TransactionCompleted\r\n  }\r\n\r\n  enum DataResponseStatus {\r\n    DataResponseAdded,\r\n    RefundedToBuyer,\r\n    TransactionCompleted\r\n  }\r\n\r\n  // --- Notary Information ---\r\n  struct NotaryInfo {\r\n    uint256 responsesPercentage;\r\n    uint256 notarizationFee;\r\n    string notarizationTermsOfService;\r\n    uint32 addedAt;\r\n  }\r\n\r\n  // --- Seller Information ---\r\n  struct SellerInfo {\r\n    address notary;\r\n    string dataHash;\r\n    uint32 createdAt;\r\n    uint32 closedAt;\r\n    DataResponseStatus status;\r\n  }\r\n\r\n  address public buyer;\r\n  string public filters;\r\n  string public dataRequest;\r\n  uint256 public price;\r\n  string public termsAndConditions;\r\n  string public buyerURL;\r\n  string public buyerPublicKey;\r\n  uint32 public createdAt;\r\n  uint32 public transactionCompletedAt;\r\n  OrderStatus public orderStatus;\r\n\r\n  mapping(address => SellerInfo) public sellerInfo;\r\n  mapping(address => NotaryInfo) internal notaryInfo;\r\n\r\n  address[] public sellers;\r\n  address[] public notaries;\r\n\r\n  /**\r\n   * @notice Contract's constructor.\r\n   * @param _buyer Buyer address\r\n   * @param _filters Target audience of the order.\r\n   * @param _dataRequest Requested data type (Geolocation, Facebook, etc).\r\n   * @param _price Price per added Data Response.\r\n   * @param _termsAndConditions Copy of the terms and conditions for the order.\r\n   * @param _buyerURL Public URL of the buyer where the data must be sent.\r\n   * @param _buyerPublicKey Public Key of the buyer, which will be used to encrypt the\r\n   *        data to be sent.\r\n   */\r\n  constructor(\r\n    address _buyer,\r\n    string _filters,\r\n    string _dataRequest,\r\n    uint256 _price,\r\n    string _termsAndConditions,\r\n    string _buyerURL,\r\n    string _buyerPublicKey\r\n  ) public validAddress(_buyer) {\r\n    require(bytes(_buyerURL).length > 0);\r\n    require(bytes(_buyerPublicKey).length > 0);\r\n\r\n    buyer = _buyer;\r\n    filters = _filters;\r\n    dataRequest = _dataRequest;\r\n    price = _price;\r\n    termsAndConditions = _termsAndConditions;\r\n    buyerURL = _buyerURL;\r\n    buyerPublicKey = _buyerPublicKey;\r\n    orderStatus = OrderStatus.OrderCreated;\r\n    createdAt = uint32(block.timestamp);\r\n    transactionCompletedAt = 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a notary to the Data Order.\r\n   * @param notary Notary's address.\r\n   * @param responsesPercentage Percentage of DataResponses to audit per DataOrder.\r\n            Value must be between 0 and 100.\r\n   * @param notarizationFee Fee to be charged per validation done.\r\n   * @param notarizationTermsOfService Notary's terms and conditions for the order.\r\n   * @return true if the Notary was added successfully, reverts otherwise.\r\n   */\r\n  function addNotary(\r\n    address notary,\r\n    uint256 responsesPercentage,\r\n    uint256 notarizationFee,\r\n    string notarizationTermsOfService\r\n  ) public onlyOwner validAddress(notary) returns (bool) {\r\n    require(transactionCompletedAt == 0);\r\n    require(responsesPercentage <= 100);\r\n    require(!hasNotaryBeenAdded(notary));\r\n\r\n    notaryInfo[notary] = NotaryInfo(\r\n      responsesPercentage,\r\n      notarizationFee,\r\n      notarizationTermsOfService,\r\n      uint32(block.timestamp)\r\n    );\r\n    notaries.push(notary);\r\n    orderStatus = OrderStatus.NotaryAdded;\r\n    return true;\r\n  }\r\n\r\n   /**\r\n    * @notice Adds a new DataResponse.\r\n    * @param seller Address of the Seller.\r\n    * @param notary Notary address that the Seller chooses to use as notary,\r\n    *        this must be one within the allowed notaries and within the\r\n    *         DataOrder's notaries.\r\n    * @param dataHash Hash of the data that must be sent, this is a SHA256.\r\n    * @return true if the DataResponse was added successfully, reverts otherwise.\r\n    */\r\n  function addDataResponse(\r\n    address seller,\r\n    address notary,\r\n    string dataHash\r\n  ) public onlyOwner validAddress(seller) validAddress(notary) returns (bool) {\r\n    require(orderStatus == OrderStatus.NotaryAdded);\r\n    require(transactionCompletedAt == 0);\r\n    require(!hasSellerBeenAccepted(seller));\r\n    require(hasNotaryBeenAdded(notary));\r\n\r\n    sellerInfo[seller] = SellerInfo(\r\n      notary,\r\n      dataHash,\r\n      uint32(block.timestamp),\r\n      0,\r\n      DataResponseStatus.DataResponseAdded\r\n    );\r\n\r\n    sellers.push(seller);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Closes a DataResponse.\r\n   * @dev Once the buyer receives the seller's data and checks that it is valid\r\n   *      or not, he must signal  DataResponse as completed.\r\n   * @param seller Seller address.\r\n   * @param transactionCompleted True, if the seller got paid for his/her data.\r\n   * @return true if DataResponse was successfully closed, reverts otherwise.\r\n   */\r\n  function closeDataResponse(\r\n    address seller,\r\n    bool transactionCompleted\r\n  ) public onlyOwner validAddress(seller) returns (bool) {\r\n    require(orderStatus != OrderStatus.TransactionCompleted);\r\n    require(transactionCompletedAt == 0);\r\n    require(hasSellerBeenAccepted(seller));\r\n    require(sellerInfo[seller].status == DataResponseStatus.DataResponseAdded);\r\n\r\n    sellerInfo[seller].status = transactionCompleted\r\n      ? DataResponseStatus.TransactionCompleted\r\n      : DataResponseStatus.RefundedToBuyer;\r\n    sellerInfo[seller].closedAt = uint32(block.timestamp);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Closes the Data order.\r\n   * @dev Once the DataOrder is closed it will no longer accept new DataResponses.\r\n   * @return true if the DataOrder was successfully closed, reverts otherwise.\r\n   */\r\n  function close() public onlyOwner returns (bool) {\r\n    require(orderStatus != OrderStatus.TransactionCompleted);\r\n    require(transactionCompletedAt == 0);\r\n    orderStatus = OrderStatus.TransactionCompleted;\r\n    transactionCompletedAt = uint32(block.timestamp);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if a DataResponse for a given seller has been accepted.\r\n   * @param seller Seller address.\r\n   * @return true if the DataResponse was accepted, false otherwise.\r\n   */\r\n  function hasSellerBeenAccepted(\r\n    address seller\r\n  ) public view validAddress(seller) returns (bool) {\r\n    return sellerInfo[seller].createdAt != 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the given notary was added to notarize this DataOrder.\r\n   * @param notary Notary address to check.\r\n   * @return true if the Notary was added, false otherwise.\r\n   */\r\n  function hasNotaryBeenAdded(\r\n    address notary\r\n  ) public view validAddress(notary) returns (bool) {\r\n    return notaryInfo[notary].addedAt != 0;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the notary information.\r\n   * @param notary Notary address to get info for.\r\n   * @return Notary information (address, responsesPercentage, notarizationFee,\r\n   *         notarizationTermsOfService, addedAt)\r\n   */\r\n  function getNotaryInfo(\r\n    address notary\r\n  ) public view validAddress(notary) returns (\r\n    address,\r\n    uint256,\r\n    uint256,\r\n    string,\r\n    uint32\r\n  ) {\r\n    require(hasNotaryBeenAdded(notary));\r\n    NotaryInfo memory info = notaryInfo[notary];\r\n    return (\r\n      notary,\r\n      info.responsesPercentage,\r\n      info.notarizationFee,\r\n      info.notarizationTermsOfService,\r\n      uint32(info.addedAt)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the seller information.\r\n   * @param seller Seller address to get info for.\r\n   * @return Seller information (address, notary, dataHash, createdAt, closedAt,\r\n   *         status)\r\n   */\r\n  function getSellerInfo(\r\n    address seller\r\n  ) public view validAddress(seller) returns (\r\n    address,\r\n    address,\r\n    string,\r\n    uint32,\r\n    uint32,\r\n    bytes32\r\n  ) {\r\n    require(hasSellerBeenAccepted(seller));\r\n    SellerInfo memory info = sellerInfo[seller];\r\n    return (\r\n      seller,\r\n      info.notary,\r\n      info.dataHash,\r\n      uint32(info.createdAt),\r\n      uint32(info.closedAt),\r\n      getDataResponseStatusAsString(info.status)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the selected notary for the given seller.\r\n   * @param seller Seller address.\r\n   * @return Address of the notary assigned to the given seller.\r\n   */\r\n  function getNotaryForSeller(\r\n    address seller\r\n  ) public view validAddress(seller) returns (address) {\r\n    require(hasSellerBeenAccepted(seller));\r\n    SellerInfo memory info = sellerInfo[seller];\r\n    return info.notary;\r\n  }\r\n\r\n  function getDataResponseStatusAsString(\r\n    DataResponseStatus drs\r\n  ) internal pure returns (bytes32) {\r\n    if (drs == DataResponseStatus.DataResponseAdded) {\r\n      return bytes32(\"DataResponseAdded\");\r\n    }\r\n\r\n    if (drs == DataResponseStatus.RefundedToBuyer) {\r\n      return bytes32(\"RefundedToBuyer\");\r\n    }\r\n\r\n    if (drs == DataResponseStatus.TransactionCompleted) {\r\n      return bytes32(\"TransactionCompleted\");\r\n    }\r\n\r\n    throw; // solium-disable-line security/no-throw\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title MultiMap\r\n * @author Wibson Development Team <developers@wibson.org>\r\n * @notice An address `MultiMap`.\r\n * @dev `MultiMap` is useful when you need to keep track of a set of addresses.\r\n */\r\nlibrary MultiMap {\r\n\r\n  struct MapStorage {\r\n    mapping(address => uint) addressToIndex;\r\n    address[] addresses;\r\n  }\r\n\r\n  /**\r\n   * @notice Retrieves a address from the given `MapStorage` using a index Key.\r\n   * @param self `MapStorage` where the index must be searched.\r\n   * @param index Index to find.\r\n   * @return Address of the given Index.\r\n   */\r\n  function get(\r\n    MapStorage storage self,\r\n    uint index\r\n  ) public view returns (address) {\r\n    require(index < self.addresses.length);\r\n    return self.addresses[index];\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the given address exists in the storage.\r\n   * @param self `MapStorage` where the key must be searched.\r\n   * @param _key Address to find.\r\n   * @return true if `_key` exists in the storage, false otherwise.\r\n   */\r\n  function exist(\r\n    MapStorage storage self,\r\n    address _key\r\n  ) public view returns (bool) {\r\n    if (_key != address(0)) {\r\n      uint targetIndex = self.addressToIndex[_key];\r\n      return targetIndex < self.addresses.length && self.addresses[targetIndex] == _key;\r\n    } else {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @notice Inserts a new address within the given storage.\r\n   * @param self `MapStorage` where the key must be inserted.\r\n   * @param _key Address to insert.\r\n   * @return true if `_key` was added, reverts otherwise.\r\n   */\r\n  function insert(\r\n    MapStorage storage self,\r\n    address _key\r\n  ) public returns (bool) {\r\n    require(_key != address(0));\r\n    if (exist(self, _key)) {\r\n      return true;\r\n    }\r\n\r\n    self.addressToIndex[_key] = self.addresses.length;\r\n    self.addresses.push(_key);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Removes the given index from the storage.\r\n   * @param self MapStorage` where the index lives.\r\n   * @param index Index to remove.\r\n   * @return true if address at `index` was removed, false otherwise.\r\n   */\r\n  function removeAt(MapStorage storage self, uint index) public returns (bool) {\r\n    return remove(self, self.addresses[index]);\r\n  }\r\n\r\n  /**\r\n   * @notice Removes the given address from the storage.\r\n   * @param self `MapStorage` where the address lives.\r\n   * @param _key Address to remove.\r\n   * @return true if `_key` was removed, false otherwise.\r\n   */\r\n  function remove(MapStorage storage self, address _key) public returns (bool) {\r\n    require(_key != address(0));\r\n    if (!exist(self, _key)) {\r\n      return false;\r\n    }\r\n\r\n    uint currentIndex = self.addressToIndex[_key];\r\n\r\n    uint lastIndex = SafeMath.sub(self.addresses.length, 1);\r\n    address lastAddress = self.addresses[lastIndex];\r\n    self.addressToIndex[lastAddress] = currentIndex;\r\n    self.addresses[currentIndex] = lastAddress;\r\n\r\n    delete self.addresses[lastIndex];\r\n    delete self.addressToIndex[_key];\r\n\r\n    self.addresses.length--;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets the current length of the Map.\r\n   * @param self `MapStorage` to get the length from.\r\n   * @return The length of the MultiMap.\r\n   */\r\n  function length(MapStorage storage self) public view returns (uint) {\r\n    return self.addresses.length;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title CryptoUtils\r\n * @author Wibson Development Team <developers@wibson.org>\r\n * @notice Cryptographic utilities used by the Wibson protocol.\r\n * @dev In order to get the same hashes using `Web3` upon which the signatures\r\n *      are checked, you must use `web3.utils.soliditySha3` in v1.0 (or the\r\n *      homonymous function in the `web3-utils` package)\r\n *      http://web3js.readthedocs.io/en/1.0/web3-utils.html#utils-soliditysha3\r\n */\r\nlibrary CryptoUtils {\r\n\r\n  /**\r\n   * @notice Checks if the signature was created by the signer.\r\n   * @param hash Hash of the data using the `keccak256` algorithm.\r\n   * @param signer Signer address.\r\n   * @param signature Signature over the hash.\r\n   * @return true if `signer` is the one who signed the `hash`, false otherwise.\r\n   */\r\n  function isSignedBy(\r\n    bytes32 hash,\r\n    address signer,\r\n    bytes signature\r\n  ) private pure returns (bool) {\r\n    require(signer != address(0));\r\n    bytes32 prefixedHash = ECRecovery.toEthSignedMessageHash(hash);\r\n    address recovered = ECRecovery.recover(prefixedHash, signature);\r\n    return recovered == signer;\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the notary's signature to be added to the DataOrder is valid.\r\n   * @param order Order address.\r\n   * @param notary Notary address.\r\n   * @param responsesPercentage Percentage of DataResponses to audit per DataOrder.\r\n   * @param notarizationFee Fee to be charged per validation done.\r\n   * @param notarizationTermsOfService Notary terms and conditions for the order.\r\n   * @param notarySignature Off-chain Notary signature.\r\n   * @return true if `notarySignature` is valid, false otherwise.\r\n   */\r\n  function isNotaryAdditionValid(\r\n    address order,\r\n    address notary,\r\n    uint256 responsesPercentage,\r\n    uint256 notarizationFee,\r\n    string notarizationTermsOfService,\r\n    bytes notarySignature\r\n  ) public pure returns (bool) {\r\n    require(order != address(0));\r\n    require(notary != address(0));\r\n    bytes32 hash = keccak256(\r\n      abi.encodePacked(\r\n        order,\r\n        responsesPercentage,\r\n        notarizationFee,\r\n        notarizationTermsOfService\r\n      )\r\n    );\r\n\r\n    return isSignedBy(hash, notary, notarySignature);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the parameters passed correspond to the seller's signature used.\r\n   * @param order Order address.\r\n   * @param seller Seller address.\r\n   * @param notary Notary address.\r\n   * @param dataHash Hash of the data that must be sent, this is a SHA256.\r\n   * @param signature Signature of DataResponse.\r\n   * @return true if arguments are signed by the `seller`, false otherwise.\r\n   */\r\n  function isDataResponseValid(\r\n    address order,\r\n    address seller,\r\n    address notary,\r\n    string dataHash,\r\n    bytes signature\r\n  ) public pure returns (bool) {\r\n    require(order != address(0));\r\n    require(seller != address(0));\r\n    require(notary != address(0));\r\n\r\n    bytes memory packed = bytes(dataHash).length > 0\r\n      ? abi.encodePacked(order, notary, dataHash)\r\n      : abi.encodePacked(order, notary);\r\n\r\n    bytes32 hash = keccak256(packed);\r\n    return isSignedBy(hash, seller, signature);\r\n  }\r\n\r\n  /**\r\n   * @notice Checks if the notary's signature to close the `DataResponse` is valid.\r\n   * @param order Order address.\r\n   * @param seller Seller address.\r\n   * @param notary Notary address.\r\n   * @param wasAudited Indicates whether the data was audited or not.\r\n   * @param isDataValid Indicates the result of the audit, if happened.\r\n   * @param notarySignature Off-chain Notary signature.\r\n   * @return true if `notarySignature` is valid, false otherwise.\r\n   */\r\n  function isNotaryVeredictValid(\r\n    address order,\r\n    address seller,\r\n    address notary,\r\n    bool wasAudited,\r\n    bool isDataValid,\r\n    bytes notarySignature\r\n  ) public pure returns (bool) {\r\n    require(order != address(0));\r\n    require(seller != address(0));\r\n    require(notary != address(0));\r\n    bytes32 hash = keccak256(\r\n      abi.encodePacked(\r\n        order,\r\n        seller,\r\n        wasAudited,\r\n        isDataValid\r\n      )\r\n    );\r\n\r\n    return isSignedBy(hash, notary, notarySignature);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title DataExchange\r\n * @author Wibson Development Team <developers@wibson.org>\r\n * @notice `DataExchange` is the core contract of the Wibson Protocol.\r\n *         This allows the creation, management, and tracking of DataOrders.\r\n * @dev This contract also contains some helper methods to access the data\r\n *      needed by the different parties involved in the Protocol.\r\n */\r\ncontract DataExchange is TokenDestructible, Pausable {\r\n  using SafeMath for uint256;\r\n  using MultiMap for MultiMap.MapStorage;\r\n\r\n  event NotaryRegistered(address indexed notary);\r\n  event NotaryUpdated(address indexed notary);\r\n  event NotaryUnregistered(address indexed notary);\r\n\r\n  event NewOrder(address indexed orderAddr);\r\n  event NotaryAddedToOrder(address indexed orderAddr, address indexed notary);\r\n  event DataAdded(address indexed orderAddr, address indexed seller);\r\n  event TransactionCompleted(address indexed orderAddr, address indexed seller);\r\n  event RefundedToBuyer(address indexed orderAddr, address indexed buyer);\r\n  event OrderClosed(address indexed orderAddr);\r\n\r\n  struct NotaryInfo {\r\n    address addr;\r\n    string name;\r\n    string notaryUrl;\r\n    string publicKey;\r\n  }\r\n\r\n  MultiMap.MapStorage openOrders;\r\n  MultiMap.MapStorage allowedNotaries;\r\n\r\n  mapping(address => address[]) public ordersBySeller;\r\n  mapping(address => address[]) public ordersByNotary;\r\n  mapping(address => address[]) public ordersByBuyer;\r\n  mapping(address => NotaryInfo) internal notaryInfo;\r\n  // Tracks the orders created by this contract.\r\n  mapping(address => bool) private orders;\r\n\r\n  // @dev buyerBalance Keeps track of the buyer's balance per order-seller.\r\n  // TODO: Is there a better way to do this?\r\n  mapping(\r\n    address => mapping(address => mapping(address => uint256))\r\n  ) public buyerBalance;\r\n\r\n  // @dev buyerRemainingBudgetForAudits Keeps track of the buyer's remaining\r\n  // budget from the initial one set on the `DataOrder`\r\n  mapping(address => mapping(address => uint256)) public buyerRemainingBudgetForAudits;\r\n\r\n  modifier validAddress(address addr) {\r\n    require(addr != address(0));\r\n    require(addr != address(this));\r\n    _;\r\n  }\r\n\r\n  modifier isOrderLegit(address order) {\r\n    require(orders[order]);\r\n    _;\r\n  }\r\n\r\n  // @dev token A WIBToken implementation of an ERC20 standard token.\r\n  WIBToken token;\r\n\r\n  // @dev The minimum for initial budget for audits per `DataOrder`.\r\n  uint256 public minimumInitialBudgetForAudits;\r\n\r\n  /**\r\n   * @notice Contract constructor.\r\n   * @param tokenAddress Address of the WIBToken token address.\r\n   * @param ownerAddress Address of the DataExchange owner.\r\n   */\r\n  constructor(\r\n    address tokenAddress,\r\n    address ownerAddress\r\n  ) public validAddress(tokenAddress) validAddress(ownerAddress) {\r\n    require(tokenAddress != ownerAddress);\r\n\r\n    token = WIBToken(tokenAddress);\r\n    minimumInitialBudgetForAudits = 0;\r\n    transferOwnership(ownerAddress);\r\n  }\r\n\r\n  /**\r\n   * @notice Registers a new notary or replaces an already existing one.\r\n   * @dev At least one notary is needed to enable `DataExchange` operation.\r\n   * @param notary Address of a Notary to add.\r\n   * @param name Name Of the Notary.\r\n   * @param notaryUrl Public URL of the notary where the data must be sent.\r\n   * @param publicKey PublicKey used by the Notary.\r\n   * @return true if the notary was successfully registered, reverts otherwise.\r\n   */\r\n  function registerNotary(\r\n    address notary,\r\n    string name,\r\n    string notaryUrl,\r\n    string publicKey\r\n  ) public onlyOwner whenNotPaused validAddress(notary) returns (bool) {\r\n    bool isNew = notaryInfo[notary].addr == address(0);\r\n\r\n    require(allowedNotaries.insert(notary));\r\n    notaryInfo[notary] = NotaryInfo(\r\n      notary,\r\n      name,\r\n      notaryUrl,\r\n      publicKey\r\n    );\r\n\r\n    if (isNew) {\r\n      emit NotaryRegistered(notary);\r\n    } else {\r\n      emit NotaryUpdated(notary);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Unregisters an existing notary.\r\n   * @param notary Address of a Notary to unregister.\r\n   * @return true if the notary was successfully unregistered, reverts otherwise.\r\n   */\r\n  function unregisterNotary(\r\n    address notary\r\n  ) public onlyOwner whenNotPaused validAddress(notary) returns (bool) {\r\n    require(allowedNotaries.remove(notary));\r\n\r\n    emit NotaryUnregistered(notary);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Sets the minimum initial budget for audits to be placed by a buyer\r\n   * on DataOrder creation.\r\n   * @dev The initial budget for audit is used as a preventive method to reduce\r\n   *      spam DataOrders in the network.\r\n   * @param _minimumInitialBudgetForAudits The new minimum for initial budget for\r\n   * audits per DataOrder.\r\n   * @return true if the value was successfully set, reverts otherwise.\r\n   */\r\n  function setMinimumInitialBudgetForAudits(\r\n    uint256 _minimumInitialBudgetForAudits\r\n  ) public onlyOwner whenNotPaused returns (bool) {\r\n    minimumInitialBudgetForAudits = _minimumInitialBudgetForAudits;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Creates a new DataOrder.\r\n   * @dev The `msg.sender` will become the buyer of the order.\r\n   * @param filters Target audience of the order.\r\n   * @param dataRequest Requested data type (Geolocation, Facebook, etc).\r\n   * @param price Price per added Data Response.\r\n   * @param initialBudgetForAudits The initial budget set for future audits.\r\n   * @param termsAndConditions Buyer's terms and conditions for the order.\r\n   * @param buyerURL Public URL of the buyer where the data must be sent.\r\n   * @param publicKey Public Key of the buyer, which will be used to encrypt the\r\n   *        data to be sent.\r\n   * @return The address of the newly created DataOrder. If the DataOrder could\r\n   *         not be created, reverts.\r\n   */\r\n  function newOrder(\r\n    string filters,\r\n    string dataRequest,\r\n    uint256 price,\r\n    uint256 initialBudgetForAudits,\r\n    string termsAndConditions,\r\n    string buyerURL,\r\n    string publicKey\r\n  ) public whenNotPaused returns (address) {\r\n    require(initialBudgetForAudits >= minimumInitialBudgetForAudits);\r\n    require(token.allowance(msg.sender, this) >= initialBudgetForAudits);\r\n\r\n    address newOrderAddr = new DataOrder(\r\n      msg.sender,\r\n      filters,\r\n      dataRequest,\r\n      price,\r\n      termsAndConditions,\r\n      buyerURL,\r\n      publicKey\r\n    );\r\n\r\n    token.transferFrom(msg.sender, this, initialBudgetForAudits);\r\n    buyerRemainingBudgetForAudits[msg.sender][newOrderAddr] = initialBudgetForAudits;\r\n\r\n    ordersByBuyer[msg.sender].push(newOrderAddr);\r\n    orders[newOrderAddr] = true;\r\n\r\n    emit NewOrder(newOrderAddr);\r\n    return newOrderAddr;\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a notary to the Data Order.\r\n   * @dev The `msg.sender` must be the buyer.\r\n   * @param orderAddr Order Address to accept notarize.\r\n   * @param notary Notary address.\r\n   * @param responsesPercentage Percentage of `DataResponses` to audit per DataOrder.\r\n   *        Value must be between 0 and 100.\r\n   * @param notarizationFee Fee to be charged per validation done.\r\n   * @param notarizationTermsOfService Notary's terms and conditions for the order.\r\n   * @param notarySignature Notary's signature over the other arguments.\r\n   * @return true if the Notary was added successfully, reverts otherwise.\r\n   */\r\n  function addNotaryToOrder(\r\n    address orderAddr,\r\n    address notary,\r\n    uint256 responsesPercentage,\r\n    uint256 notarizationFee,\r\n    string notarizationTermsOfService,\r\n    bytes notarySignature\r\n  ) public whenNotPaused isOrderLegit(orderAddr) validAddress(notary) returns (bool) {\r\n    DataOrder order = DataOrder(orderAddr);\r\n    address buyer = order.buyer();\r\n    require(msg.sender == buyer);\r\n\r\n    require(!order.hasNotaryBeenAdded(notary));\r\n    require(allowedNotaries.exist(notary));\r\n\r\n    require(\r\n      CryptoUtils.isNotaryAdditionValid(\r\n        orderAddr,\r\n        notary,\r\n        responsesPercentage,\r\n        notarizationFee,\r\n        notarizationTermsOfService,\r\n        notarySignature\r\n      )\r\n    );\r\n\r\n    bool okay = order.addNotary(\r\n      notary,\r\n      responsesPercentage,\r\n      notarizationFee,\r\n      notarizationTermsOfService\r\n    );\r\n\r\n    if (okay) {\r\n      openOrders.insert(orderAddr);\r\n      ordersByNotary[notary].push(orderAddr);\r\n      emit NotaryAddedToOrder(order, notary);\r\n    }\r\n    return okay;\r\n  }\r\n\r\n  /**\r\n   * @notice Adds a new DataResponse to the given order.\r\n   * @dev 1. The `msg.sender` must be the buyer of the order.\r\n   *      2. The buyer must allow the DataExchange to withdraw the price of the\r\n   *         order.\r\n   * @param orderAddr Order address where the DataResponse must be added.\r\n   * @param seller Address of the Seller.\r\n   * @param notary Notary address that the Seller chose to use as notarizer,\r\n   *        this must be one within the allowed notaries and within the\r\n   *        DataOrder's notaries.\r\n   * @param dataHash Hash of the data that must be sent, this is a SHA256.\r\n   * @param signature Signature of DataResponse.\r\n   * @return true if the DataResponse was set successfully, reverts otherwise.\r\n   */\r\n  function addDataResponseToOrder(\r\n    address orderAddr,\r\n    address seller,\r\n    address notary,\r\n    string dataHash,\r\n    bytes signature\r\n  ) public whenNotPaused isOrderLegit(orderAddr) returns (bool) {\r\n    DataOrder order = DataOrder(orderAddr);\r\n    address buyer = order.buyer();\r\n    require(msg.sender == buyer);\r\n    allDistinct(\r\n      [\r\n        orderAddr,\r\n        buyer,\r\n        seller,\r\n        notary,\r\n        address(this)\r\n      ]\r\n    );\r\n    require(order.hasNotaryBeenAdded(notary));\r\n\r\n    require(\r\n      CryptoUtils.isDataResponseValid(\r\n        orderAddr,\r\n        seller,\r\n        notary,\r\n        dataHash,\r\n        signature\r\n      )\r\n    );\r\n\r\n    bool okay = order.addDataResponse(\r\n      seller,\r\n      notary,\r\n      dataHash\r\n    );\r\n    require(okay);\r\n\r\n    chargeBuyer(order, seller);\r\n\r\n    ordersBySeller[seller].push(orderAddr);\r\n    emit DataAdded(order, seller);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Closes a DataResponse.\r\n   * @dev Once the buyer receives the seller's data and checks that it is valid\r\n   *      or not, he must close the DataResponse signaling the result.\r\n   *        1. This method requires an offline signature from the notary set in\r\n   *           the DataResponse, which will indicate the audit result or if\r\n   *           the data was not audited at all.\r\n   *             - If the notary did not audit the data or it verifies that it was\r\n   *               valid, funds will be sent to the Seller.\r\n   *             - If the notary signals the data as invalid, funds will be\r\n   *               handed back to the Buyer.\r\n   *             - Otherwise, funds will be locked at the `DataExchange` contract\r\n   *               until the issue is solved.\r\n   *        2. This also works as a pause mechanism in case the system is\r\n   *           working under abnormal scenarios while allowing the parties to keep\r\n   *           exchanging information without losing their funds until the system\r\n   *           is back up.\r\n   *        3. The `msg.sender` must be the buyer or the notary in case the\r\n   *           former does not show up. Only through the notary's signature it is\r\n   *           decided who must receive the funds.\r\n   * @param orderAddr Order address where the DataResponse belongs to.\r\n   * @param seller Seller address.\r\n   * @param wasAudited Indicates whether the data was audited or not.\r\n   * @param isDataValid Indicates the result of the audit, if happened.\r\n   * @param notarySignature Off-chain Notary signature\r\n   * @return true if the DataResponse was successfully closed, reverts otherwise.\r\n   */\r\n  function closeDataResponse(\r\n    address orderAddr,\r\n    address seller,\r\n    bool wasAudited,\r\n    bool isDataValid,\r\n    bytes notarySignature\r\n  ) public whenNotPaused isOrderLegit(orderAddr) returns (bool) {\r\n    DataOrder order = DataOrder(orderAddr);\r\n    address buyer = order.buyer();\r\n    require(order.hasSellerBeenAccepted(seller));\r\n\r\n    address notary = order.getNotaryForSeller(seller);\r\n    require(msg.sender == buyer || msg.sender == notary);\r\n    require(\r\n      CryptoUtils.isNotaryVeredictValid(\r\n        orderAddr,\r\n        seller,\r\n        notary,\r\n        wasAudited,\r\n        isDataValid,\r\n        notarySignature\r\n      )\r\n    );\r\n    bool transactionCompleted = !wasAudited || isDataValid;\r\n    require(order.closeDataResponse(seller, transactionCompleted));\r\n    payPlayers(\r\n      order,\r\n      buyer,\r\n      seller,\r\n      notary,\r\n      wasAudited,\r\n      isDataValid\r\n    );\r\n\r\n    if (transactionCompleted) {\r\n      emit TransactionCompleted(order, seller);\r\n    } else {\r\n      emit RefundedToBuyer(order, buyer);\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @notice Closes the DataOrder.\r\n   * @dev Onces the data is closed it will no longer accept new DataResponses.\r\n   *      The `msg.sender` must be the buyer of the order or the owner of the\r\n   *      contract in a emergency case.\r\n   * @param orderAddr Order address to close.\r\n   * @return true if the DataOrder was successfully closed, reverts otherwise.\r\n   */\r\n  function closeOrder(\r\n    address orderAddr\r\n  ) public whenNotPaused isOrderLegit(orderAddr) returns (bool) {\r\n    require(openOrders.exist(orderAddr));\r\n    DataOrder order = DataOrder(orderAddr);\r\n    address buyer = order.buyer();\r\n    require(msg.sender == buyer || msg.sender == owner);\r\n\r\n    bool okay = order.close();\r\n    if (okay) {\r\n      // remaining budget for audits go back to buyer.\r\n      uint256 remainingBudget = buyerRemainingBudgetForAudits[buyer][order];\r\n      buyerRemainingBudgetForAudits[buyer][order] = 0;\r\n      require(token.transfer(buyer, remainingBudget));\r\n\r\n      openOrders.remove(orderAddr);\r\n      emit OrderClosed(orderAddr);\r\n    }\r\n\r\n    return okay;\r\n  }\r\n\r\n  /**\r\n   * @notice Gets all the data orders associated with a notary.\r\n   * @param notary Notary address to get orders for.\r\n   * @return A list of DataOrder addresses.\r\n   */\r\n  function getOrdersForNotary(\r\n    address notary\r\n  ) public view validAddress(notary) returns (address[]) {\r\n    return ordersByNotary[notary];\r\n  }\r\n\r\n  /**\r\n   * @notice Gets all the data orders associated with a seller.\r\n   * @param seller Seller address to get orders for.\r\n   * @return List of DataOrder addresses.\r\n   */\r\n  function getOrdersForSeller(\r\n    address seller\r\n  ) public view validAddress(seller) returns (address[]) {\r\n    return ordersBySeller[seller];\r\n  }\r\n\r\n  /**\r\n   * @notice Gets all the data orders associated with a buyer.\r\n   * @param buyer Buyer address to get orders for.\r\n   * @return List of DataOrder addresses.\r\n   */\r\n  function getOrdersForBuyer(\r\n    address buyer\r\n  ) public view validAddress(buyer) returns (address[]) {\r\n    return ordersByBuyer[buyer];\r\n  }\r\n\r\n  /**\r\n   * @notice Gets all the open data orders, that is all the DataOrders that are\r\n   *         still receiving new DataResponses.\r\n   * @return List of DataOrder addresses.\r\n   */\r\n  function getOpenOrders() public view returns (address[]) {\r\n    return openOrders.addresses;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the list of allowed notaries.\r\n   * @return List of notary addresses.\r\n   */\r\n  function getAllowedNotaries() public view returns (address[]) {\r\n    return allowedNotaries.addresses;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets information about a give notary.\r\n   * @param notary Notary address to get info for.\r\n   * @return Notary information (address, name, notaryUrl, publicKey, isActive).\r\n   */\r\n  function getNotaryInfo(\r\n    address notary\r\n  ) public view validAddress(notary) returns (address, string, string, string, bool) {\r\n    NotaryInfo memory info = notaryInfo[notary];\r\n\r\n    return (\r\n      info.addr,\r\n      info.name,\r\n      info.notaryUrl,\r\n      info.publicKey,\r\n      allowedNotaries.exist(notary)\r\n    );\r\n  }\r\n\r\n  /**\r\n   * @dev Requires that five addresses are distinct between themselves and zero.\r\n   * @param addresses array of five addresses to explore.\r\n   */\r\n  function allDistinct(address[5] addresses) private pure {\r\n    for (uint i = 0; i < addresses.length; i++) {\r\n      require(addresses[i] != address(0));\r\n      for (uint j = i + 1; j < addresses.length; j++) { // solium-disable-line zeppelin/no-arithmetic-operations\r\n        require(addresses[i] != addresses[j]);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Charges a buyer the final charges for a given `DataResponse`.\r\n   * @notice 1. Tokens are held in the DataExchange contract until players are paid.\r\n   *         2. This function follows a basic invoice flow:\r\n   *\r\n   *               DataOrder price\r\n   *            + Notarization fee\r\n   *            ------------------\r\n   *                 Total charges\r\n   *            -  Prepaid charges (Minimum between Notarization fee and Buyer remaining budget)\r\n   *            ------------------\r\n   *                 Final charges\r\n   *\r\n   * @param order DataOrder to which the DataResponse applies.\r\n   * @param seller Address of the Seller.\r\n   */\r\n  function chargeBuyer(DataOrder order, address seller) private whenNotPaused {\r\n    address buyer = order.buyer();\r\n    address notary = order.getNotaryForSeller(seller);\r\n    uint256 remainingBudget = buyerRemainingBudgetForAudits[buyer][order];\r\n\r\n    uint256 orderPrice = order.price();\r\n    (,, uint256 notarizationFee,,) = order.getNotaryInfo(notary);\r\n    uint256 totalCharges = orderPrice.add(notarizationFee);\r\n\r\n    uint256 prePaid = Math.min256(notarizationFee, remainingBudget);\r\n    uint256 finalCharges = totalCharges.sub(prePaid);\r\n\r\n    buyerRemainingBudgetForAudits[buyer][order] = remainingBudget.sub(prePaid);\r\n    require(token.transferFrom(buyer, this, finalCharges));\r\n\r\n    // Bookkeeping of the available tokens paid by the Buyer and now in control\r\n    // of the DataExchange takes into account the total charges (final + pre-paid)\r\n    buyerBalance[buyer][order][seller] = buyerBalance[buyer][order][seller].add(totalCharges);\r\n  }\r\n\r\n  /**\r\n   * @dev Pays the seller, notary and/or buyer according to the notary's veredict.\r\n   * @param order DataOrder to which the payments apply.\r\n   * @param buyer Address of the Buyer.\r\n   * @param seller Address of the Seller.\r\n   * @param notary Address of the Notary.\r\n   * @param wasAudited Indicates whether the data was audited or not.\r\n   * @param isDataValid Indicates the result of the audit, if happened.\r\n   */\r\n  function payPlayers(\r\n    DataOrder order,\r\n    address buyer,\r\n    address seller,\r\n    address notary,\r\n    bool wasAudited,\r\n    bool isDataValid\r\n  ) private whenNotPaused {\r\n    uint256 orderPrice = order.price();\r\n    (,, uint256 notarizationFee,,) = order.getNotaryInfo(notary);\r\n    uint256 totalCharges = orderPrice.add(notarizationFee);\r\n\r\n    require(buyerBalance[buyer][order][seller] >= totalCharges);\r\n    buyerBalance[buyer][order][seller] = buyerBalance[buyer][order][seller].sub(totalCharges);\r\n\r\n    // if no notarization was done, notarization fee tokens go back to buyer.\r\n    address notarizationFeeReceiver = wasAudited ? notary : buyer;\r\n\r\n    // if no notarization was done or data is valid, tokens go to the seller\r\n    address orderPriceReceiver = (!wasAudited || isDataValid) ? seller : buyer;\r\n\r\n    require(token.transfer(notarizationFeeReceiver, notarizationFee));\r\n    require(token.transfer(orderPriceReceiver, orderPrice));\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"getOrdersForSeller\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ordersByBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyerRemainingBudgetForAudits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimumInitialBudgetForAudits\",\"type\":\"uint256\"}],\"name\":\"setMinimumInitialBudgetForAudits\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"getNotaryInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderAddr\",\"type\":\"address\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"dataHash\",\"type\":\"string\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"addDataResponseToOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"getOrdersForNotary\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderAddr\",\"type\":\"address\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"wasAudited\",\"type\":\"bool\"},{\"name\":\"isDataValid\",\"type\":\"bool\"},{\"name\":\"notarySignature\",\"type\":\"bytes\"}],\"name\":\"closeDataResponse\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderAddr\",\"type\":\"address\"}],\"name\":\"closeOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"orderAddr\",\"type\":\"address\"},{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"responsesPercentage\",\"type\":\"uint256\"},{\"name\":\"notarizationFee\",\"type\":\"uint256\"},{\"name\":\"notarizationTermsOfService\",\"type\":\"string\"},{\"name\":\"notarySignature\",\"type\":\"bytes\"}],\"name\":\"addNotaryToOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"getOrdersForBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllowedNotaries\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ordersByNotary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"notary\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"notaryUrl\",\"type\":\"string\"},{\"name\":\"publicKey\",\"type\":\"string\"}],\"name\":\"registerNotary\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ordersBySeller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOpenOrders\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"filters\",\"type\":\"string\"},{\"name\":\"dataRequest\",\"type\":\"string\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"initialBudgetForAudits\",\"type\":\"uint256\"},{\"name\":\"termsAndConditions\",\"type\":\"string\"},{\"name\":\"buyerURL\",\"type\":\"string\"},{\"name\":\"publicKey\",\"type\":\"string\"}],\"name\":\"newOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumInitialBudgetForAudits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"unregisterNotary\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"ownerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"NotaryRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"NotaryUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"NotaryUnregistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderAddr\",\"type\":\"address\"}],\"name\":\"NewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"notary\",\"type\":\"address\"}],\"name\":\"NotaryAddedToOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"DataAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"TransactionCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"RefundedToBuyer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderAddr\",\"type\":\"address\"}],\"name\":\"OrderClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DataExchange","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003f17dd476faf0a4855572f0b6ed5115d9bba22ad0000000000000000000000000183b6ffc017ac4f767e460886291d09229a848b","Library":"CryptoUtils:48819464877341cb7e0bbd91e0c268016ae5e6ad;MultiMap:72ae13d70f65c56e59eb63993605abef1ecb9c41","SwarmSource":"bzzr://8b119373d135bf2e3226c2a7685f7a2296b836fae440567bb8e62bb5532818d2"}]}