{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\ninterface ERC721TokenReceiver {\r\n\r\n  /**\r\n   * @dev Handle the receipt of a NFT. The ERC721 smart contract calls this function on the\r\n   * recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n   * of other than the magic value MUST result in the transaction being reverted.\r\n   * Returns `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` unless throwing.\r\n   * @notice The contract address is always the message sender. A wallet/broker/auction application\r\n   * MUST implement the wallet interface if it will accept safe transfers.\r\n   * @param _operator The address which called `safeTransferFrom` function.\r\n   * @param _from The address which previously owned the token.\r\n   * @param _tokenId The NFT identifier which is being transferred.\r\n   * @param _data Additional data with no specified format.\r\n   */\r\n    function onERC721Received(\r\n        address _operator,\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes calldata _data\r\n    ) external returns(bytes4);\r\n    \r\n}\r\n\r\ncontract ICOStickers {\r\n    using SafeMath for uint256;\r\n    using SafeMath for int256;\r\n    address constant internal NULL_ADDRESS = 0x0000000000000000000000000000000000000000;\r\n    \r\n    // ERC721 requires ERC165\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n    \r\n    // ERC721\r\n    address[] internal idToOwner;\r\n    address[] internal idToApprovals;\r\n    mapping (address => uint256) internal ownerToNFTokenCount;\r\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n    \r\n    // ERC721Metadata\r\n    string constant public name = \"0xchan ICO Stickers\";\r\n    string constant public symbol = \"ZCIS\";\r\n    \r\n    // Custom\r\n    string constant internal uriStart = \"https://0xchan.net/stickers/obj_properties/\";\r\n    uint256[] public tokenProperty;\r\n    address[] public originalTokenOwner;\r\n    address internal badgeGiver;\r\n    address internal owner;\r\n    address internal newOwner;\r\n    \r\n    \r\n    // ERC721 Events\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 indexed _tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n    \r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\r\n        _;\r\n    }\r\n    \r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(\r\n            tokenOwner == msg.sender\r\n            || getApproved(_tokenId) == msg.sender\r\n            || ownerToOperators[tokenOwner][msg.sender]\r\n        );\r\n        _;\r\n    }\r\n    \r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != NULL_ADDRESS);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyBadgeGiver {\r\n        require(msg.sender == badgeGiver);\r\n        _;\r\n    }\r\n    \r\n    constructor() public {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n        \r\n        owner = msg.sender;\r\n        badgeGiver = msg.sender;\r\n    }\r\n    \r\n    // Custom functions\r\n    function setNewOwner(address o) public onlyOwner {\r\n        newOwner = o;\r\n    }\r\n    \r\n    function acceptNewOwner() public {\r\n        require(msg.sender == newOwner);\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    function revokeOwnership() public onlyOwner {\r\n        owner = NULL_ADDRESS;\r\n        newOwner = NULL_ADDRESS;\r\n    }\r\n    \r\n\tfunction setBadgeGiver(address g) public onlyOwner {\r\n\t    badgeGiver = g;\r\n\t}\r\n    \r\n    function giveSticker(address _to, uint256 _property) public onlyBadgeGiver {\r\n        require(_to != NULL_ADDRESS);\r\n        uint256 _tokenId = tokenProperty.length;\r\n        \r\n        idToOwner.length ++;\r\n        idToApprovals.length ++;\r\n        tokenProperty.length ++;\r\n        originalTokenOwner.length ++;\r\n        \r\n        addNFToken(_to, _tokenId);\r\n        tokenProperty[_tokenId] = _property;\r\n        originalTokenOwner[_tokenId] = _to;\r\n    \r\n        emit Transfer(NULL_ADDRESS, _to, _tokenId);\r\n    }\r\n    \r\n    // ERC721Enumerable functions\r\n    \r\n    function totalSupply() external view returns(uint256) {\r\n        return tokenProperty.length;\r\n    }\r\n    \r\n    function tokenOfOwnerByIndex(uint256 _tokenId) external view returns(address _owner) {\r\n        _owner = idToOwner[_tokenId];\r\n        require(_owner != NULL_ADDRESS);\r\n    }\r\n    \r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        require(_index < tokenProperty.length);\r\n        return _index;\r\n    }\r\n    \r\n    // ERC721Metadata functions\r\n    \r\n    function tokenURI(uint256 _tokenId) validNFToken(_tokenId) public view returns (string memory)\r\n    {\r\n        return concatStrings(uriStart, uint256ToString(_tokenId));\r\n    }\r\n    \r\n    // ERC721 functions\r\n    \r\n    function balanceOf(address _owner) external view returns(uint256) {\r\n        require(_owner != NULL_ADDRESS);\r\n        return ownerToNFTokenCount[_owner];\r\n    }\r\n    \r\n    function ownerOf(uint256 _tokenId) external view returns(address _owner){\r\n        _owner = idToOwner[_tokenId];\r\n        require(_owner != NULL_ADDRESS);\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes calldata _data) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n    \r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n    \r\n    function supportsInterface(bytes4 _interfaceID) external view returns(bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != NULL_ADDRESS);\r\n        _transfer(_to, _tokenId);\r\n    }\r\n    \r\n    function approve(address _approved, uint256 _tokenId) external canOperate(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n        \r\n        idToApprovals[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n    \r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        require(_operator != NULL_ADDRESS);\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n    \r\n    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address){\r\n        return idToApprovals[_tokenId];\r\n    }\r\n    \r\n    function isApprovedForAll(address _owner, address _operator) external view returns(bool) {\r\n        require(_owner != NULL_ADDRESS);\r\n        require(_operator != NULL_ADDRESS);\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n    \r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes memory _data) internal canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != NULL_ADDRESS);\r\n        \r\n        _transfer(_to, _tokenId);\r\n        \r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n    \r\n    function _transfer(address _to, uint256 _tokenId) private {\r\n        address from = idToOwner[_tokenId];\r\n        clearApproval(_tokenId);\r\n        removeNFToken(from, _tokenId);\r\n        addNFToken(_to, _tokenId);\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n    \r\n    function clearApproval(uint256 _tokenId) private {\r\n        if(idToApprovals[_tokenId] != NULL_ADDRESS){\r\n            delete idToApprovals[_tokenId];\r\n        }\r\n    }\r\n\r\n    function removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from);\r\n        assert(ownerToNFTokenCount[_from] > 0);\r\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\r\n        delete idToOwner[_tokenId];\r\n    }\r\n\r\n    function addNFToken(address _to, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == NULL_ADDRESS);\r\n        idToOwner[_tokenId] = _to;\r\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\r\n    }\r\n    \r\n    //If bytecode exists at _addr then the _addr is a contract.\r\n    function isContract(address _addr) internal view returns(bool) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length>0);\r\n    }\r\n    \r\n    // Functions used for generating the URI\r\n    function amountOfZeros(uint256 num, uint256 base) public pure returns(uint256){\r\n        uint256 result = 0;\r\n        num /= base;\r\n        while (num > 0){\r\n            num /= base;\r\n            result += 1;\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    function uint256ToString(uint256 num) public pure returns(string memory){\r\n        if (num == 0){\r\n            return \"0\";\r\n        }\r\n        uint256 numLen = amountOfZeros(num, 10) + 1;\r\n        bytes memory result = new bytes(numLen);\r\n        while(num != 0){\r\n            numLen -= 1;\r\n            result[numLen] = byte(uint8((num - (num / 10 * 10)) + 48));\r\n            num /= 10;\r\n        }\r\n        return string(result);\r\n    }\r\n    \r\n    function concatStrings(string memory str1, string memory str2) public pure returns (string memory){\r\n        uint256 str1Len = bytes(str1).length;\r\n        uint256 str2Len = bytes(str2).length;\r\n        uint256 resultLen = str1Len + str1Len;\r\n        bytes memory result = new bytes(resultLen);\r\n        uint256 i;\r\n        \r\n        for (i = 0; i < str1Len; i += 1){\r\n            result[i] = bytes(str1)[i];\r\n        }\r\n        for (i = 0; i < str2Len; i += 1){\r\n            result[i + str1Len] = bytes(str2)[i];\r\n        }\r\n        return string(result);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns(uint256 c) {\r\n        if (a == 0 || b == 0) {\r\n           return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on underflow\r\n    */\r\n    function sub(int256 a, int256 b) internal pure returns(int256 c) {\r\n        c = a - b;\r\n        assert(c <= a);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(int256 a, int256 b) internal pure returns(int256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenProperty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"str1\",\"type\":\"string\"},{\"name\":\"str2\",\"type\":\"string\"}],\"name\":\"concatStrings\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"revokeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_property\",\"type\":\"uint256\"}],\"name\":\"giveSticker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"base\",\"type\":\"uint256\"}],\"name\":\"amountOfZeros\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"g\",\"type\":\"address\"}],\"name\":\"setBadgeGiver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"originalTokenOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"num\",\"type\":\"uint256\"}],\"name\":\"uint256ToString\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"o\",\"type\":\"address\"}],\"name\":\"setNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"ICOStickers","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://acca7d522f0235058ba072aced84d7fe478d05dca68b2ddfb2a9b0e03f502415"}]}