{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address _who) external view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b,\"Math error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0,\"Math error\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a,\"Math error\");\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a,\"Math error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0,\"Math error\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n * @dev Implementation of the basic standard token.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal balances_;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed_;\r\n\r\n    uint256 private totalSupply_;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances_[_owner];\r\n    }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n      public\r\n      view\r\n      returns (uint256)\r\n    {\r\n        return allowed_[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances_[msg.sender],\"Invalid value\");\r\n        require(_to != address(0),\"Invalid address\");\r\n\r\n        balances_[msg.sender] = balances_[msg.sender].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed_[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        require(_value <= balances_[_from],\"Value is more than balance\");\r\n        require(_value <= allowed_[_from][msg.sender],\"Value is more than alloved\");\r\n        require(_to != address(0),\"Invalid address\");\r\n\r\n        balances_[_from] = balances_[_from].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        allowed_[msg.sender][_spender] = (allowed_[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed_[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        uint256 oldValue = allowed_[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed_[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed_[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that mints an amount of the token and assigns it to\r\n    * an account. This encapsulates the modification of balances such that the\r\n    * proper events are emitted.\r\n    * @param _account The account that will receive the created tokens.\r\n    * @param _amount The amount that will be created.\r\n    */\r\n    function _mint(address _account, uint256 _amount) internal {\r\n        require(_account != 0,\"Invalid address\");\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances_[_account] = balances_[_account].add(_amount);\r\n        emit Transfer(address(0), _account, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account.\r\n    * @param _account The account whose tokens will be burnt.\r\n    * @param _amount The amount that will be burnt.\r\n    */\r\n    function _burn(address _account, uint256 _amount) internal {\r\n        require(_account != 0,\"Invalid address\");\r\n        require(_amount <= balances_[_account],\"Amount is more than balance\");\r\n\r\n        totalSupply_ = totalSupply_.sub(_amount);\r\n        balances_[_account] = balances_[_account].sub(_amount);\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    function safeTransfer(\r\n        IERC20 _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.transfer(_to, _value),\"Transfer error\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.transferFrom(_from, _to, _value),\"Tranfer error\");\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 _token,\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.approve(_spender, _value),\"Approve error\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable {\r\n    event Paused();\r\n    event Unpaused();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused,\"Contract is paused, sorry\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is running now\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev ERC20 modified with pausable transfers.\r\n **/\r\ncontract ERC20Pausable is ERC20, Pausable {\r\n\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Contract ATHLETICO token\r\n * @dev ERC20 compatible token contract\r\n */\r\ncontract ATHLETICOToken is ERC20Pausable {\r\n    string public constant name = \"ATHLETICO TOKEN\";\r\n    string public constant symbol = \"ATH\";\r\n    uint32 public constant decimals = 18;\r\n    uint256 public INITIAL_SUPPLY = 1000000000 * 1 ether; // 1 000 000 000\r\n    address public CrowdsaleAddress;\r\n    bool public ICOover;\r\n\r\n    mapping (address => bool) public kyc;\r\n    mapping (address => uint256) public sponsors;\r\n\r\n    event LogSponsor(\r\n        address indexed from,\r\n        uint256 value\r\n    );\r\n\r\n    constructor(address _CrowdsaleAddress) public {\r\n    \r\n        CrowdsaleAddress = _CrowdsaleAddress;\r\n        _mint(_CrowdsaleAddress, INITIAL_SUPPLY);\r\n    }\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == CrowdsaleAddress,\"Only CrowdSale contract can run this\");\r\n        _;\r\n    }\r\n    \r\n    modifier validDestination( address to ) {\r\n        require(to != address(0),\"Empty address\");\r\n        require(to != address(this),\"RESTO Token address\");\r\n        _;\r\n    }\r\n    \r\n    modifier isICOover {\r\n        if (msg.sender != CrowdsaleAddress){\r\n            require(ICOover == true,\"Transfer of tokens is prohibited until the end of the ICO\");\r\n        }\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Override for testing address destination\r\n     */\r\n    function transfer(address _to, uint256 _value) public validDestination(_to) isICOover returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Override for testing address destination\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) \r\n    public validDestination(_to) isICOover returns (bool) \r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    \r\n  /**\r\n   * @dev Function to mint tokens\r\n   * can run only from crowdsale contract\r\n   * @param to The address that will receive the minted tokens.\r\n   * @param _value The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n    function mint(address to, uint256 _value) public onlyOwner {\r\n        _mint(to, _value);\r\n    }\r\n\r\n\r\n   /**\r\n    * @dev Function to burn tokens\r\n    * Anyone can burn their tokens and in this way help the project.\r\n    * Information about sponsors is public.\r\n    * On the project website you can get a sponsor certificate.\r\n    */\r\n    function burn(uint256 _value) public {\r\n        _burn(msg.sender, _value);\r\n        sponsors[msg.sender] = sponsors[msg.sender].add(_value);\r\n        emit LogSponsor(msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev function set kyc bool to true\r\n    * can run only from crowdsale contract\r\n    * @param _investor The investor who passed the procedure KYC\r\n    */\r\n    function kycPass(address _investor) public onlyOwner {\r\n        kyc[_investor] = true;\r\n    }\r\n\r\n    /**\r\n    * @dev function set kyc bool to false\r\n    * can run only from crowdsale contract\r\n    * @param _investor The investor who not passed the procedure KYC (change after passing kyc - something wrong)\r\n    */\r\n    function kycNotPass(address _investor) public onlyOwner {\r\n        kyc[_investor] = false;\r\n    }\r\n\r\n    /**\r\n    * @dev function set ICOOver bool to true\r\n    * can run only from crowdsale contract\r\n    */\r\n    function setICOover() public onlyOwner {\r\n        ICOover = true;\r\n    }\r\n\r\n    /**\r\n     * @dev function transfer tokens from special address to users\r\n     * can run only from crowdsale contract\r\n     */\r\n    function transferTokensFromSpecialAddress(address _from, address _to, uint256 _value) public onlyOwner whenNotPaused returns (bool){\r\n        require (balances_[_from] >= _value,\"Decrease value\");\r\n        \r\n        balances_[_from] = balances_[_from].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        \r\n        emit Transfer(_from, _to, _value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev called from crowdsale contract to pause, triggers stopped state\r\n     * can run only from crowdsale contract\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    /**\r\n     * @dev called from crowdsale contract to unpause, returns to normal state\r\n     * can run only from crowdsale contract\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setICOover\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"kyc\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICOover\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"kycNotPass\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sponsors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CrowdsaleAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"kycPass\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromSpecialAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_CrowdsaleAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogSponsor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ATHLETICOToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000991f09f2e5dd6d1f3ff7f72d0dcab964d4c8cbbf","Library":"","SwarmSource":"bzzr://b3916c818717a11217741e005b3aa07a2a1abcf5dc49120a217cfdfb5b296abb"}]}