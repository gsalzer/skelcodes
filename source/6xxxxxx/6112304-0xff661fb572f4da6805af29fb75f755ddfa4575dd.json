{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\ncontract LotteryFactory {\r\n\r\n\t// contract profit\r\n\tuint public commissionSum;\r\n\t// default lottery params\r\n\tParams public defaultParams;\r\n\t// lotteries\r\n\tLottery[] public lotteries;\r\n\t// lotteries count\r\n\tuint public lotteryCount;\r\n\t// contract owner address\r\n\taddress public owner;\r\n\r\n\tstruct Lottery {\r\n\t\tmapping(address => uint) ownerTokenCount;\r\n\t\tmapping(address => uint) ownerTokenCountToSell;\r\n\t\tmapping(address => uint) sellerId;\r\n\t\taddress[] sellingAddresses;\r\n\t\tuint[] sellingAmounts;\r\n\t\tuint createdAt;\r\n\t\tuint tokenCount;\r\n\t\tuint tokenCountToSell;\r\n\t\tuint winnerSum;\r\n\t\tbool prizeRedeemed;\r\n\t\taddress winner;\r\n\t\taddress[] participants;\r\n\t\tParams params;\r\n\t}\r\n\r\n\t// lottery params\r\n\tstruct Params {\r\n\t\tuint gameDuration;\r\n\t\tuint initialTokenPrice; \r\n\t\tuint durationToTokenPriceUp; \r\n\t\tuint tokenPriceIncreasePercent; \r\n\t\tuint tradeCommission; \r\n\t\tuint winnerCommission;\r\n\t}\r\n\r\n\t// event fired on purchase error, when user tries to buy a token from a seller\r\n\tevent PurchaseError(address oldOwner, uint amount);\r\n\r\n\t/**\r\n\t * Throws if called by account different from the owner account\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Sets owner and default lottery params\r\n\t */\r\n\tconstructor() public {\r\n\t\t// set owner\r\n\t\towner = msg.sender;\r\n\t\t// set default params\r\n\t\tupdateParams(4 hours, 0.01 ether, 15 minutes, 10, 1, 10);\r\n\t\t// create a new lottery\r\n\t\t_createNewLottery();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Approves tokens for selling\r\n\t * @param _tokenCount amount of tokens to place for selling\r\n\t */\r\n\tfunction approveToSell(uint _tokenCount) public {\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\t// check that user has enough tokens to sell\r\n\t\trequire(lottery.ownerTokenCount[msg.sender] - lottery.ownerTokenCountToSell[msg.sender] >= _tokenCount);\r\n\t\t// if there are no sales or this is user's first sale\r\n\t\tif(lottery.sellingAddresses.length == 0 || lottery.sellerId[msg.sender] == 0 && lottery.sellingAddresses[0] != msg.sender) {\r\n\t\t\tuint sellingAddressesCount = lottery.sellingAddresses.push(msg.sender);\r\n\t\t\tuint sellingAmountsCount = lottery.sellingAmounts.push(_tokenCount);\r\n\t\t\tassert(sellingAddressesCount == sellingAmountsCount);\r\n\t\t\tlottery.sellerId[msg.sender] = sellingAddressesCount - 1;\r\n\t\t} else {\r\n\t\t\t// seller exists and placed at least 1 sale\r\n\t\t\tuint sellerIndex = lottery.sellerId[msg.sender];\r\n\t\t\tlottery.sellingAmounts[sellerIndex] += _tokenCount;\r\n\t\t}\r\n\t\t// update global lottery variables\r\n\t\tlottery.ownerTokenCountToSell[msg.sender] += _tokenCount;\r\n\t\tlottery.tokenCountToSell += _tokenCount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns token balance by user address\r\n\t * @param _user user address\r\n\t * @return token acount on the user balance\r\n\t */\r\n\tfunction balanceOf(address _user) public view returns(uint) {\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\treturn lottery.ownerTokenCount[_user];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns selling token balance by user address\r\n\t * @param _user user address\r\n\t * @return token acount selling by user\r\n\t */\r\n\tfunction balanceSellingOf(address _user) public view returns(uint) {\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\treturn lottery.ownerTokenCountToSell[_user];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buys tokens\r\n\t */\r\n\tfunction buyTokens() public payable {\r\n\t\tif(_isNeededNewLottery()) _createNewLottery();\r\n\t\t// get latest lottery\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\t// get token count to buy\r\n\t\tuint price = _getCurrentTokenPrice();\r\n\t\tuint tokenCountToBuy = msg.value / price;\r\n\t\t// any extra eth added to winner sum\r\n\t\tuint rest = msg.value - tokenCountToBuy * price;\r\n\t\tif( rest > 0 ){\r\n\t\t    lottery.winnerSum = lottery.winnerSum + rest;\r\n\t\t}\r\n\t\t// check that user wants to buy at least 1 token\r\n\t\trequire(tokenCountToBuy > 0);\r\n\t\t// buy tokens from sellers\r\n\t\tuint tokenCountToBuyFromSeller = _getTokenCountToBuyFromSeller(tokenCountToBuy);\r\n\t\tif(tokenCountToBuyFromSeller > 0) {\r\n\t\t \t_buyTokensFromSeller(tokenCountToBuyFromSeller);\r\n\t\t}\r\n\t\t// buy tokens from system\r\n\t\tuint tokenCountToBuyFromSystem = tokenCountToBuy - tokenCountToBuyFromSeller;\r\n\t\tif(tokenCountToBuyFromSystem > 0) {\r\n\t\t\t_buyTokensFromSystem(tokenCountToBuyFromSystem);\r\n\t\t}\r\n\t\t// add sender to participants\r\n\t\t_addToParticipants(msg.sender);\r\n\t\t// update winner values\r\n\t\tlottery.winnerSum += tokenCountToBuyFromSystem * price;\r\n\t\tlottery.winner = _getWinner();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Removes tokens from selling\r\n\t * @param _tokenCount amount of tokens to remove from selling\r\n\t */\r\n\tfunction disapproveToSell(uint _tokenCount) public {\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\t// check that user has enough tokens to cancel selling\r\n\t\trequire(lottery.ownerTokenCountToSell[msg.sender] >= _tokenCount);\r\n\t\t// remove tokens from selling\r\n\t\tuint sellerIndex = lottery.sellerId[msg.sender];\r\n\t\tlottery.sellingAmounts[sellerIndex] -= _tokenCount;\r\n\t\t// update global lottery variables\r\n\t\tlottery.ownerTokenCountToSell[msg.sender] -= _tokenCount;\r\n\t\tlottery.tokenCountToSell -= _tokenCount;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns lottery details by index\r\n\t * @param _index lottery index\r\n\t * @return lottery details\r\n\t */\r\n\tfunction getLotteryAtIndex(uint _index) public view returns(\r\n\t\tuint createdAt,\r\n\t\tuint tokenCount,\r\n\t\tuint tokenCountToSell,\r\n\t\tuint winnerSum,\r\n\t\taddress winner,\r\n\t\tbool prizeRedeemed,\r\n\t\taddress[] participants,\r\n\t\tuint paramGameDuration,\r\n\t\tuint paramInitialTokenPrice,\r\n\t\tuint paramDurationToTokenPriceUp,\r\n\t\tuint paramTokenPriceIncreasePercent,\r\n\t\tuint paramTradeCommission,\r\n\t\tuint paramWinnerCommission\r\n\t) {\r\n\t\t// check that lottery exists\r\n\t\trequire(_index < lotteryCount);\r\n\t\t// return lottery details\r\n\t\tLottery memory lottery = lotteries[_index];\r\n\t\tcreatedAt = lottery.createdAt;\r\n\t\ttokenCount = lottery.tokenCount;\r\n\t\ttokenCountToSell = lottery.tokenCountToSell;\r\n\t\twinnerSum = lottery.winnerSum;\r\n\t\twinner = lottery.winner;\r\n\t\tprizeRedeemed = lottery.prizeRedeemed;\r\n\t\tparticipants = lottery.participants;\r\n\t\tparamGameDuration = lottery.params.gameDuration;\r\n\t\tparamInitialTokenPrice = lottery.params.initialTokenPrice;\r\n\t\tparamDurationToTokenPriceUp = lottery.params.durationToTokenPriceUp;\r\n\t\tparamTokenPriceIncreasePercent = lottery.params.tokenPriceIncreasePercent;\r\n\t\tparamTradeCommission = lottery.params.tradeCommission;\r\n\t\tparamWinnerCommission = lottery.params.winnerCommission;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns arrays of addresses who sell tokens and corresponding amounts\r\n\t * @return array of addresses who sell tokens and array of amounts\r\n\t */\r\n\tfunction getSales() public view returns(address[], uint[]) {\r\n\t\t// get latest lottery\r\n\t\tLottery memory lottery = lotteries[lotteryCount - 1];\r\n\t\t// return array of addresses who sell tokens and amounts\r\n\t\treturn (lottery.sellingAddresses, lottery.sellingAmounts);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns top users by balances for current lottery\r\n\t * @param _n number of top users to find\r\n\t * @return array of addresses and array of balances sorted in balance descend\r\n\t */\r\n\tfunction getTop(uint _n) public view returns(address[], uint[]) {\r\n\t\t// check that n > 0\r\n\t\trequire(_n > 0);\r\n\t\t// get latest lottery\r\n\t\tLottery memory lottery = lotteries[lotteryCount - 1];\r\n\t\t// find top n users with highest token balances\r\n\t\taddress[] memory resultAddresses = new address[](_n);\r\n\t\tuint[] memory resultBalances = new uint[](_n);\r\n\t\tfor(uint i = 0; i < _n; i++) {\r\n\t\t\t// if current iteration is more than number of participants then continue\r\n\t\t\tif(i > lottery.participants.length - 1) continue;\r\n\t\t\t// if 1st iteration then set 0 values\r\n\t\t\tuint prevMaxBalance = i == 0 ? 0 : resultBalances[i-1];\r\n\t\t\taddress prevAddressWithMax = i == 0 ? address(0) : resultAddresses[i-1];\r\n\t\t\tuint currentMaxBalance = 0;\r\n\t\t\taddress currentAddressWithMax = address(0);\r\n\t\t\tfor(uint j = 0; j < lottery.participants.length; j++) {\r\n\t\t\t\tuint balance = balanceOf(lottery.participants[j]);\r\n\t\t\t\t// if first iteration then simply find max\r\n\t\t\t\tif(i == 0) {\r\n\t\t\t\t\tif(balance > currentMaxBalance) {\r\n\t\t\t\t\t\tcurrentMaxBalance = balance;\r\n\t\t\t\t\t\tcurrentAddressWithMax = lottery.participants[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// find balance that is less or equal to the prev max\r\n\t\t\t\t\tif(prevMaxBalance >= balance && balance > currentMaxBalance && lottery.participants[j] != prevAddressWithMax) {\r\n\t\t\t\t\t\tcurrentMaxBalance = balance;\r\n\t\t\t\t\t\tcurrentAddressWithMax = lottery.participants[j];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tresultAddresses[i] = currentAddressWithMax;\r\n\t\t\tresultBalances[i] = currentMaxBalance;\r\n\t\t}\r\n\t\treturn(resultAddresses, resultBalances);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns seller id by user address\r\n\t * @param _user user address\r\n\t * @return seller id/index\r\n\t */\r\n\tfunction sellerIdOf(address _user) public view returns(uint) {\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\treturn lottery.sellerId[_user];\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Updates lottery parameters\r\n\t * @param _gameDuration duration of the lottery in seconds\r\n\t * @param _initialTokenPrice initial price for 1 token in wei\r\n\t * @param _durationToTokenPriceUp how many seconds should pass to increase token price\r\n\t * @param _tokenPriceIncreasePercent percentage of token increase. ex: 2 will increase token price by 2% each time interval\r\n\t * @param _tradeCommission commission in percentage for trading tokens. When user1 sells token to user2 for 1.15 eth then commision applied\r\n\t * @param _winnerCommission commission in percentage for winning sum\r\n\t */\r\n\tfunction updateParams(\r\n\t\tuint _gameDuration,\r\n\t\tuint _initialTokenPrice,\r\n\t\tuint _durationToTokenPriceUp,\r\n\t\tuint _tokenPriceIncreasePercent,\r\n\t\tuint _tradeCommission,\r\n\t\tuint _winnerCommission\r\n\t) public onlyOwner {\r\n\t\tParams memory params;\r\n\t\tparams.gameDuration = _gameDuration;\r\n\t\tparams.initialTokenPrice = _initialTokenPrice;\r\n\t\tparams.durationToTokenPriceUp = _durationToTokenPriceUp;\r\n\t\tparams.tokenPriceIncreasePercent = _tokenPriceIncreasePercent;\r\n\t\tparams.tradeCommission = _tradeCommission;\r\n\t\tparams.winnerCommission = _winnerCommission;\r\n\t\tdefaultParams = params;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Withdraws commission sum to the owner\r\n\t */\r\n\tfunction withdraw() public onlyOwner {\r\n\t\t// check that commision > 0\r\n\t\trequire(commissionSum > 0);\r\n\t\t// save commission for later transfer and reset\r\n\t\tuint commissionSumToTransfer = commissionSum;\r\n\t\tcommissionSum = 0;\r\n\t\t// transfer commission to owner\r\n\t\towner.transfer(commissionSumToTransfer);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Withdraws ether for winner\r\n\t * @param _lotteryIndex lottery index\r\n\t */\r\n\tfunction withdrawForWinner(uint _lotteryIndex) public {\r\n\t\t// check that lottery exists\r\n\t\trequire(lotteries.length > _lotteryIndex);\r\n\t\t// check that sender is winner\r\n\t\tLottery storage lottery = lotteries[_lotteryIndex];\r\n\t\trequire(lottery.winner == msg.sender);\r\n\t\t// check that lottery is over\r\n\t\trequire(now > lottery.createdAt + lottery.params.gameDuration);\r\n\t\t// check that prize is not redeemed\r\n\t\trequire(!lottery.prizeRedeemed);\r\n\t\t// update contract commission sum and winner sum\r\n\t\tuint winnerCommissionSum = _getValuePartByPercent(lottery.winnerSum, lottery.params.winnerCommission);\r\n\t\tcommissionSum += winnerCommissionSum;\r\n\t\tuint winnerSum = lottery.winnerSum - winnerCommissionSum;\r\n\t\t// mark lottery as redeemed\r\n\t\tlottery.prizeRedeemed = true;\r\n\t\t// send winner his prize\r\n\t\tlottery.winner.transfer(winnerSum);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Disallow users to send ether directly to the contract\r\n\t */\r\n\tfunction() public payable {\r\n\t\trevert();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Adds user address to participants\r\n\t * @param _user user address\r\n\t */\r\n\tfunction _addToParticipants(address _user) internal {\r\n\t\t// check that user is not in participants\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\tbool isParticipant = false;\r\n\t\tfor(uint i = 0; i < lottery.participants.length; i++) {\r\n\t\t\tif(lottery.participants[i] == _user) {\r\n\t\t\t\tisParticipant = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(!isParticipant) {\r\n\t\t\tlottery.participants.push(_user);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buys tokens from sellers\r\n\t * @param _tokenCountToBuy amount of tokens to buy from sellers\r\n\t */\r\n\tfunction _buyTokensFromSeller(uint _tokenCountToBuy) internal {\r\n\t\t// check that token count is not 0\r\n\t\trequire(_tokenCountToBuy > 0);\r\n\t\t// get latest lottery\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\t// get current token price and commission sum\r\n\t\tuint currentTokenPrice = _getCurrentTokenPrice();\r\n\t\tuint currentCommissionSum = _getValuePartByPercent(currentTokenPrice, lottery.params.tradeCommission);\r\n\t\tuint purchasePrice = currentTokenPrice - currentCommissionSum;\r\n\t\t// foreach selling amount\r\n\t\tuint tokensLeftToBuy = _tokenCountToBuy;\r\n\t\tfor(uint i = 0; i < lottery.sellingAmounts.length; i++) {\r\n\t\t\t// if amount != 0 and buyer does not purchase his own tokens\r\n\t\t\tif(lottery.sellingAmounts[i] != 0 && lottery.sellingAddresses[i] != msg.sender) {\r\n\t\t\t\taddress oldOwner = lottery.sellingAddresses[i];\r\n\t\t\t\t// find how many tokens to substitute\r\n\t\t\t\tuint tokensToSubstitute;\r\n\t\t\t\tif(tokensLeftToBuy < lottery.sellingAmounts[i]) {\r\n\t\t\t\t\ttokensToSubstitute = tokensLeftToBuy;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokensToSubstitute = lottery.sellingAmounts[i];\r\n\t\t\t\t}\r\n\t\t\t\t// update old owner balance and send him ether\r\n\t\t\t\tlottery.sellingAmounts[i] -= tokensToSubstitute;\r\n\t\t\t\tlottery.ownerTokenCount[oldOwner] -= tokensToSubstitute;\r\n\t\t\t\tlottery.ownerTokenCountToSell[oldOwner] -= tokensToSubstitute;\r\n\t\t\t\tuint purchaseSum = purchasePrice * tokensToSubstitute;\r\n\t\t\t\tif(!oldOwner.send(purchaseSum)) {\r\n\t\t\t\t\temit PurchaseError(oldOwner, purchaseSum);\r\n\t\t\t\t}\r\n\t\t\t\t// check if user bought enough\r\n\t\t\t\ttokensLeftToBuy -= tokensToSubstitute;\r\n\t\t\t\tif(tokensLeftToBuy == 0) break;\r\n\t\t\t}\r\n\t\t}\r\n\t\t// update contract variables\r\n\t\tcommissionSum += _tokenCountToBuy * purchasePrice;\r\n\t\tlottery.ownerTokenCount[msg.sender] += _tokenCountToBuy;\r\n\t\tlottery.tokenCountToSell -= _tokenCountToBuy;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Buys tokens from system(mint) for sender\r\n\t * @param _tokenCountToBuy token count to buy\r\n\t */\r\n\tfunction _buyTokensFromSystem(uint _tokenCountToBuy) internal {\r\n\t\t// check that token count is not 0\r\n\t\trequire(_tokenCountToBuy > 0);\r\n\t\t// get latest lottery\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\t// mint tokens for buyer\r\n\t\tlottery.ownerTokenCount[msg.sender] += _tokenCountToBuy;\r\n\t\t// update lottery values\r\n\t\tlottery.tokenCount += _tokenCountToBuy;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Creates a new lottery\r\n\t */\r\n\tfunction _createNewLottery() internal {\r\n\t\tLottery memory lottery;\r\n\t\tlottery.createdAt = _getNewLotteryCreatedAt();\r\n\t\tlottery.params = defaultParams;\r\n\t\tlotteryCount = lotteries.push(lottery);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns current price for 1 token\r\n\t * @return token price\r\n\t */\r\n\tfunction _getCurrentTokenPrice() internal view returns(uint) {\r\n\t\tLottery memory lottery = lotteries[lotteryCount - 1];\r\n\t\tuint diffInSec = now - lottery.createdAt;\r\n\t\tuint stageCount = diffInSec / lottery.params.durationToTokenPriceUp;\r\n\t\tuint price = lottery.params.initialTokenPrice;\r\n\t\tfor(uint i = 0; i < stageCount; i++) {\r\n\t\t\tprice += _getValuePartByPercent(price, lottery.params.tokenPriceIncreasePercent);\r\n\t\t}\r\n\t\treturn price;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns new lottery created at. \r\n\t * Ex: latest lottery started at 0:00 and finished at 6:00. Now it is 7:00. User buys token. New lottery createdAt will be 06:00:01.\r\n\t * @return new lottery created at timestamp\r\n\t */\r\n\tfunction _getNewLotteryCreatedAt() internal view returns(uint) {\r\n\t\t// if there are no lotteries then return now\r\n\t\tif(lotteries.length == 0) return now;\r\n\t\t// else loop while new created at time is not found\r\n\t\t// get latest lottery end time\r\n\t\tuint latestEndAt = lotteries[lotteryCount - 1].createdAt + lotteries[lotteryCount - 1].params.gameDuration;\r\n\t\t// get next lottery end time\r\n\t\tuint nextEndAt = latestEndAt + defaultParams.gameDuration;\r\n\t\twhile(now > nextEndAt) {\r\n\t\t\tnextEndAt += defaultParams.gameDuration;\r\n\t\t}\r\n\t\treturn nextEndAt - defaultParams.gameDuration;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns number of tokens that can be bought from seller\r\n\t * @param _tokenCountToBuy token count to buy\r\n\t * @return number of tokens that can be bought from seller\r\n\t */\r\n\tfunction _getTokenCountToBuyFromSeller(uint _tokenCountToBuy) internal view returns(uint) {\r\n\t\t// check that token count is not 0\r\n\t\trequire(_tokenCountToBuy > 0);\r\n\t\t// get latest lottery\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\t// check that total token count on sale is more that user has\r\n\t\trequire(lottery.tokenCountToSell >= lottery.ownerTokenCountToSell[msg.sender]);\r\n\t\t// substitute user's token on sale count from total count\r\n\t\tuint tokenCountToSell = lottery.tokenCountToSell - lottery.ownerTokenCountToSell[msg.sender];\r\n\t\t// if there are no tokens to sell then return 0\r\n\t\tif(tokenCountToSell == 0) return 0;\r\n\t\t// if there are less tokens to sell than we need\r\n\t\tif(tokenCountToSell < _tokenCountToBuy) {\r\n\t\t\treturn tokenCountToSell;\r\n\t\t} else {\r\n\t\t\t// contract has all tokens to buy from sellers\r\n\t\t\treturn _tokenCountToBuy;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns part of number by percent. Ex: (200, 1) => 2\r\n\t * @param _initialValue initial number\r\n\t * @param _percent percentage\r\n\t * @return part of number by percent\r\n\t */\r\n\tfunction _getValuePartByPercent(uint _initialValue, uint _percent) internal pure returns(uint) {\r\n\t\tuint onePercentValue = _initialValue / 100;\r\n\t\treturn onePercentValue * _percent;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Returns winner address\r\n\t * @return winner address\r\n\t */\r\n\tfunction _getWinner() internal view returns(address) {\r\n\t\tLottery storage lottery = lotteries[lotteryCount - 1];\r\n\t\t// if there are no participants then return 0x00 address\r\n\t\tif(lottery.participants.length == 0) return address(0);\r\n\t\t// set the 1st participant as winner\r\n\t\taddress winner = lottery.participants[0];\r\n\t\tuint maxTokenCount = 0;\r\n\t\t// loop through all participants to find winner\r\n\t\tfor(uint i = 0; i < lottery.participants.length; i++) {\r\n\t\t\tuint currentTokenCount = lottery.ownerTokenCount[lottery.participants[i]];\r\n\t\t\tif(currentTokenCount > maxTokenCount) {\r\n\t\t\t\twinner = lottery.participants[i];\r\n\t\t\t\tmaxTokenCount = currentTokenCount; \r\n\t\t\t}\r\n\t\t}\r\n\t\treturn winner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Checks whether new lottery should be created\r\n\t * @return true if new lottery needs to be created false otherwise\r\n\t */\r\n\tfunction _isNeededNewLottery() internal view returns(bool) {\r\n\t\t// if there are no lotteries then return true\r\n\t\tif(lotteries.length == 0) return true;\r\n\t\t// if now is more than lottery end time then return true else false\r\n\t\tLottery memory lottery = lotteries[lotteries.length - 1];\r\n\t\treturn now > lottery.createdAt + defaultParams.gameDuration;\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceSellingOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getSales\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"lotteries\",\"outputs\":[{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"name\":\"tokenCountToSell\",\"type\":\"uint256\"},{\"name\":\"winnerSum\",\"type\":\"uint256\"},{\"name\":\"prizeRedeemed\",\"type\":\"bool\"},{\"name\":\"winner\",\"type\":\"address\"},{\"components\":[{\"name\":\"gameDuration\",\"type\":\"uint256\"},{\"name\":\"initialTokenPrice\",\"type\":\"uint256\"},{\"name\":\"durationToTokenPriceUp\",\"type\":\"uint256\"},{\"name\":\"tokenPriceIncreasePercent\",\"type\":\"uint256\"},{\"name\":\"tradeCommission\",\"type\":\"uint256\"},{\"name\":\"winnerCommission\",\"type\":\"uint256\"}],\"name\":\"params\",\"type\":\"tuple\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameDuration\",\"type\":\"uint256\"},{\"name\":\"_initialTokenPrice\",\"type\":\"uint256\"},{\"name\":\"_durationToTokenPriceUp\",\"type\":\"uint256\"},{\"name\":\"_tokenPriceIncreasePercent\",\"type\":\"uint256\"},{\"name\":\"_tradeCommission\",\"type\":\"uint256\"},{\"name\":\"_winnerCommission\",\"type\":\"uint256\"}],\"name\":\"updateParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_n\",\"type\":\"uint256\"}],\"name\":\"getTop\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenCount\",\"type\":\"uint256\"}],\"name\":\"disapproveToSell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLotteryAtIndex\",\"outputs\":[{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"tokenCount\",\"type\":\"uint256\"},{\"name\":\"tokenCountToSell\",\"type\":\"uint256\"},{\"name\":\"winnerSum\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"prizeRedeemed\",\"type\":\"bool\"},{\"name\":\"participants\",\"type\":\"address[]\"},{\"name\":\"paramGameDuration\",\"type\":\"uint256\"},{\"name\":\"paramInitialTokenPrice\",\"type\":\"uint256\"},{\"name\":\"paramDurationToTokenPriceUp\",\"type\":\"uint256\"},{\"name\":\"paramTokenPriceIncreasePercent\",\"type\":\"uint256\"},{\"name\":\"paramTradeCommission\",\"type\":\"uint256\"},{\"name\":\"paramWinnerCommission\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultParams\",\"outputs\":[{\"name\":\"gameDuration\",\"type\":\"uint256\"},{\"name\":\"initialTokenPrice\",\"type\":\"uint256\"},{\"name\":\"durationToTokenPriceUp\",\"type\":\"uint256\"},{\"name\":\"tokenPriceIncreasePercent\",\"type\":\"uint256\"},{\"name\":\"tradeCommission\",\"type\":\"uint256\"},{\"name\":\"winnerCommission\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"sellerIdOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenCount\",\"type\":\"uint256\"}],\"name\":\"approveToSell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lotteryIndex\",\"type\":\"uint256\"}],\"name\":\"withdrawForWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lotteryCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PurchaseError\",\"type\":\"event\"}]","ContractName":"LotteryFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4f7ddbc9c206b4be043aa38bc7ac72c7623e31d5f6577f8790548b840956f27a"}]}