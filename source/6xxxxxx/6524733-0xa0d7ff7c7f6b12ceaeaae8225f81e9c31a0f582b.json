{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25; // solium-disable-line linebreak-style\r\n\r\n/**\r\n * @author Anatolii Kucheruk (anatolii@platin.io)\r\n * @author Platin Limited, platin.io (platin@platin.io)\r\n */\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param _token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic _token) external onlyOwner {\r\n    uint256 balance = _token.balanceOf(this);\r\n    _token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this Ether.\r\n * @notice Ether can still be sent to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n */\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  constructor() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by setting a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    owner.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Contracts that should not own Tokens\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\r\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\r\n * owner to reclaim the tokens.\r\n */\r\ncontract HasNoTokens is CanReclaimToken {\r\n\r\n /**\r\n  * @dev Reject all ERC223 compatible tokens\r\n  * @param _from address The address that is transferring the tokens\r\n  * @param _value uint256 the amount of the specified token\r\n  * @param _data Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(\r\n    address _from,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    external\r\n    pure\r\n  {\r\n    _from;\r\n    _value;\r\n    _data;\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param _contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address _contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(_contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Base contract for contracts that should not own things.\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\r\n * Owned contracts. See respective base contracts for details.\r\n */\r\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Authorizable\r\n * @dev Authorizable contract holds a list of control addresses that authorized to do smth.\r\n */\r\ncontract Authorizable is Ownable {\r\n\r\n    // List of authorized (control) addresses\r\n    mapping (address => bool) public authorized;\r\n\r\n    // Authorize event logging\r\n    event Authorize(address indexed who);\r\n\r\n    // UnAuthorize event logging\r\n    event UnAuthorize(address indexed who);\r\n\r\n    // onlyAuthorized modifier, restrict to the owner and the list of authorized addresses\r\n    modifier onlyAuthorized() {\r\n        require(msg.sender == owner || authorized[msg.sender], \"Not Authorized.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Authorize given address\r\n     * @param _who address Address to authorize \r\n     */\r\n    function authorize(address _who) public onlyOwner {\r\n        require(_who != address(0), \"Address can't be zero.\");\r\n        require(!authorized[_who], \"Already authorized\");\r\n\r\n        authorized[_who] = true;\r\n        emit Authorize(_who);\r\n    }\r\n\r\n    /**\r\n     * @dev unAuthorize given address\r\n     * @param _who address Address to unauthorize \r\n     */\r\n    function unAuthorize(address _who) public onlyOwner {\r\n        require(_who != address(0), \"Address can't be zero.\");\r\n        require(authorized[_who], \"Address is not authorized\");\r\n\r\n        authorized[_who] = false;\r\n        emit UnAuthorize(_who);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Holders Token\r\n * @dev Extension to the OpenZepellin's StandardToken contract to track token holders.\r\n * Only holders with the non-zero balance are listed.\r\n */\r\ncontract HoldersToken is StandardToken {\r\n    using SafeMath for uint256;    \r\n\r\n    // holders list\r\n    address[] public holders;\r\n\r\n    // holder number in the list\r\n    mapping (address => uint256) public holderNumber;\r\n\r\n    /**\r\n     * @dev Get the holders count\r\n     * @return uint256 Holders count\r\n     */\r\n    function holdersCount() public view returns (uint256) {\r\n        return holders.length;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another preserving token holders\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @return bool Returns true if the transfer was succeeded\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        _preserveHolders(msg.sender, _to, _value);\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another preserving token holders\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @return bool Returns true if the transfer was succeeded\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        _preserveHolders(_from, _to, _value);\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove holder from the holders list\r\n     * @param _holder address Address of the holder to remove\r\n     */\r\n    function _removeHolder(address _holder) internal {\r\n        uint256 _number = holderNumber[_holder];\r\n\r\n        if (_number == 0 || holders.length == 0 || _number > holders.length)\r\n            return;\r\n\r\n        uint256 _index = _number.sub(1);\r\n        uint256 _lastIndex = holders.length.sub(1);\r\n        address _lastHolder = holders[_lastIndex];\r\n\r\n        if (_index != _lastIndex) {\r\n            holders[_index] = _lastHolder;\r\n            holderNumber[_lastHolder] = _number;\r\n        }\r\n\r\n        holderNumber[_holder] = 0;\r\n        holders.length = _lastIndex;\r\n    } \r\n\r\n    /**\r\n     * @dev Add holder to the holders list\r\n     * @param _holder address Address of the holder to add   \r\n     */\r\n    function _addHolder(address _holder) internal {\r\n        if (holderNumber[_holder] == 0) {\r\n            holders.push(_holder);\r\n            holderNumber[_holder] = holders.length;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Preserve holders during transfers\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function _preserveHolders(address _from, address _to, uint256 _value) internal {\r\n        _addHolder(_to);   \r\n        if (balanceOf(_from).sub(_value) == 0) \r\n            _removeHolder(_from);\r\n    }\r\n}\r\n\r\n/**\r\n * @title PlatinTGE\r\n * @dev Platin Token Generation Event contract. It holds token economic constants and makes initial token allocation.\r\n * Initial token allocation function should be called outside the blockchain at the TGE moment of time, \r\n * from here on out, Platin Token and other Platin contracts become functional.\r\n */\r\ncontract PlatinTGE {\r\n    using SafeMath for uint256;\r\n    \r\n    // Token decimals\r\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\r\n\r\n    // Total Tokens Supply\r\n    uint256 public constant TOTAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); // 1,000,000,000 PTNX\r\n\r\n    // SUPPLY\r\n    // TOTAL_SUPPLY = 1,000,000,000 PTNX, is distributed as follows:\r\n    uint256 public constant SALES_SUPPLY = 300000000 * (10 ** uint256(decimals)); // 300,000,000 PTNX - 30%\r\n    uint256 public constant MINING_POOL_SUPPLY = 200000000 * (10 ** uint256(decimals)); // 200,000,000 PTNX - 20%\r\n    uint256 public constant FOUNDERS_AND_EMPLOYEES_SUPPLY = 200000000 * (10 ** uint256(decimals)); // 200,000,000 PTNX - 20%\r\n    uint256 public constant AIRDROPS_POOL_SUPPLY = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX - 10%\r\n    uint256 public constant RESERVES_POOL_SUPPLY = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX - 10%\r\n    uint256 public constant ADVISORS_POOL_SUPPLY = 70000000 * (10 ** uint256(decimals)); // 70,000,000 PTNX - 7%\r\n    uint256 public constant ECOSYSTEM_POOL_SUPPLY = 30000000 * (10 ** uint256(decimals)); // 30,000,000 PTNX - 3%\r\n\r\n    // HOLDERS\r\n    address public PRE_ICO_POOL; // solium-disable-line mixedcase\r\n    address public LIQUID_POOL; // solium-disable-line mixedcase\r\n    address public ICO; // solium-disable-line mixedcase\r\n    address public MINING_POOL; // solium-disable-line mixedcase \r\n    address public FOUNDERS_POOL; // solium-disable-line mixedcase\r\n    address public EMPLOYEES_POOL; // solium-disable-line mixedcase \r\n    address public AIRDROPS_POOL; // solium-disable-line mixedcase \r\n    address public RESERVES_POOL; // solium-disable-line mixedcase \r\n    address public ADVISORS_POOL; // solium-disable-line mixedcase\r\n    address public ECOSYSTEM_POOL; // solium-disable-line mixedcase \r\n\r\n    // HOLDER AMOUNT AS PART OF SUPPLY\r\n    // SALES_SUPPLY = PRE_ICO_POOL_AMOUNT + LIQUID_POOL_AMOUNT + ICO_AMOUNT\r\n    uint256 public constant PRE_ICO_POOL_AMOUNT = 20000000 * (10 ** uint256(decimals)); // 20,000,000 PTNX\r\n    uint256 public constant LIQUID_POOL_AMOUNT = 100000000 * (10 ** uint256(decimals)); // 100,000,000 PTNX\r\n    uint256 public constant ICO_AMOUNT = 180000000 * (10 ** uint256(decimals)); // 180,000,000 PTNX\r\n    // FOUNDERS_AND_EMPLOYEES_SUPPLY = FOUNDERS_POOL_AMOUNT + EMPLOYEES_POOL_AMOUNT\r\n    uint256 public constant FOUNDERS_POOL_AMOUNT = 190000000 * (10 ** uint256(decimals)); // 190,000,000 PTNX\r\n    uint256 public constant EMPLOYEES_POOL_AMOUNT = 10000000 * (10 ** uint256(decimals)); // 10,000,000 PTNX\r\n\r\n    // Unsold tokens reserve address\r\n    address public UNSOLD_RESERVE; // solium-disable-line mixedcase\r\n\r\n    // Tokens ico sale with lockup period\r\n    uint256 public constant ICO_LOCKUP_PERIOD = 182 days;\r\n    \r\n    // Platin Token ICO rate, regular\r\n    uint256 public constant TOKEN_RATE = 1000; \r\n\r\n    // Platin Token ICO rate with lockup, 20% bonus\r\n    uint256 public constant TOKEN_RATE_LOCKUP = 1200;\r\n\r\n    // Platin ICO min purchase amount\r\n    uint256 public constant MIN_PURCHASE_AMOUNT = 1 ether;\r\n\r\n    // Platin Token contract\r\n    PlatinToken public token;\r\n\r\n    // TGE time\r\n    uint256 public tgeTime;\r\n\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _tgeTime uint256 TGE moment of time\r\n     * @param _token address Address of the Platin Token contract       \r\n     * @param _preIcoPool address Address of the Platin PreICO Pool\r\n     * @param _liquidPool address Address of the Platin Liquid Pool\r\n     * @param _ico address Address of the Platin ICO contract\r\n     * @param _miningPool address Address of the Platin Mining Pool\r\n     * @param _foundersPool address Address of the Platin Founders Pool\r\n     * @param _employeesPool address Address of the Platin Employees Pool\r\n     * @param _airdropsPool address Address of the Platin Airdrops Pool\r\n     * @param _reservesPool address Address of the Platin Reserves Pool\r\n     * @param _advisorsPool address Address of the Platin Advisors Pool\r\n     * @param _ecosystemPool address Address of the Platin Ecosystem Pool  \r\n     * @param _unsoldReserve address Address of the Platin Unsold Reserve                                 \r\n     */  \r\n    constructor(\r\n        uint256 _tgeTime,\r\n        PlatinToken _token, \r\n        address _preIcoPool,\r\n        address _liquidPool,\r\n        address _ico,\r\n        address _miningPool,\r\n        address _foundersPool,\r\n        address _employeesPool,\r\n        address _airdropsPool,\r\n        address _reservesPool,\r\n        address _advisorsPool,\r\n        address _ecosystemPool,\r\n        address _unsoldReserve\r\n    ) public {\r\n        require(_tgeTime >= block.timestamp, \"TGE time should be >= current time.\"); // solium-disable-line security/no-block-members\r\n        require(_token != address(0), \"Token address can't be zero.\");\r\n        require(_preIcoPool != address(0), \"PreICO Pool address can't be zero.\");\r\n        require(_liquidPool != address(0), \"Liquid Pool address can't be zero.\");\r\n        require(_ico != address(0), \"ICO address can't be zero.\");\r\n        require(_miningPool != address(0), \"Mining Pool address can't be zero.\");\r\n        require(_foundersPool != address(0), \"Founders Pool address can't be zero.\");\r\n        require(_employeesPool != address(0), \"Employees Pool address can't be zero.\");\r\n        require(_airdropsPool != address(0), \"Airdrops Pool address can't be zero.\");\r\n        require(_reservesPool != address(0), \"Reserves Pool address can't be zero.\");\r\n        require(_advisorsPool != address(0), \"Advisors Pool address can't be zero.\");\r\n        require(_ecosystemPool != address(0), \"Ecosystem Pool address can't be zero.\");\r\n        require(_unsoldReserve != address(0), \"Unsold reserve address can't be zero.\");\r\n\r\n        // Setup tge time\r\n        tgeTime = _tgeTime;\r\n\r\n        // Setup token address\r\n        token = _token;\r\n\r\n        // Setup holder addresses\r\n        PRE_ICO_POOL = _preIcoPool;\r\n        LIQUID_POOL = _liquidPool;\r\n        ICO = _ico;\r\n        MINING_POOL = _miningPool;\r\n        FOUNDERS_POOL = _foundersPool;\r\n        EMPLOYEES_POOL = _employeesPool;\r\n        AIRDROPS_POOL = _airdropsPool;\r\n        RESERVES_POOL = _reservesPool;\r\n        ADVISORS_POOL = _advisorsPool;\r\n        ECOSYSTEM_POOL = _ecosystemPool;\r\n\r\n        // Setup unsold reserve address\r\n        UNSOLD_RESERVE = _unsoldReserve; \r\n    }\r\n\r\n    /**\r\n     * @dev Allocate function. Token Generation Event entry point.\r\n     * It makes initial token allocation according to the initial token supply constants.\r\n     */\r\n    function allocate() public {\r\n\r\n        // Should be called just after tge time\r\n        require(block.timestamp >= tgeTime, \"Should be called just after tge time.\"); // solium-disable-line security/no-block-members\r\n\r\n        // Should not be allocated already\r\n        require(token.totalSupply() == 0, \"Allocation is already done.\");\r\n\r\n        // SALES          \r\n        token.allocate(PRE_ICO_POOL, PRE_ICO_POOL_AMOUNT);\r\n        token.allocate(LIQUID_POOL, LIQUID_POOL_AMOUNT);\r\n        token.allocate(ICO, ICO_AMOUNT);\r\n      \r\n        // MINING POOL\r\n        token.allocate(MINING_POOL, MINING_POOL_SUPPLY);\r\n\r\n        // FOUNDERS AND EMPLOYEES\r\n        token.allocate(FOUNDERS_POOL, FOUNDERS_POOL_AMOUNT);\r\n        token.allocate(EMPLOYEES_POOL, EMPLOYEES_POOL_AMOUNT);\r\n\r\n        // AIRDROPS POOL\r\n        token.allocate(AIRDROPS_POOL, AIRDROPS_POOL_SUPPLY);\r\n\r\n        // RESERVES POOL\r\n        token.allocate(RESERVES_POOL, RESERVES_POOL_SUPPLY);\r\n\r\n        // ADVISORS POOL\r\n        token.allocate(ADVISORS_POOL, ADVISORS_POOL_SUPPLY);\r\n\r\n        // ECOSYSTEM POOL\r\n        token.allocate(ECOSYSTEM_POOL, ECOSYSTEM_POOL_SUPPLY);\r\n\r\n        // Check Token Total Supply\r\n        require(token.totalSupply() == TOTAL_SUPPLY, \"Total supply check error.\");   \r\n    }\r\n}\r\n\r\n/**\r\n * @title PlatinToken\r\n * @dev Platin PTNX Token contract. Tokens are allocated during TGE.\r\n * Token contract is a standard ERC20 token with additional capabilities: TGE allocation, holders tracking and lockup.\r\n * Initial allocation should be invoked by the TGE contract at the TGE moment of time.\r\n * Token contract holds list of token holders, the list includes holders with positive balance only.\r\n * Authorized holders can transfer token with lockup(s). Lockups can be refundable. \r\n * Lockups is a list of releases dates and releases amounts.\r\n * In case of refund previous holder can get back locked up tokens. Only still locked up amounts can be transferred back.\r\n */\r\ncontract PlatinToken is HoldersToken, NoOwner, Authorizable, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name = \"Platin Token\"; // solium-disable-line uppercase\r\n    string public constant symbol = \"PTNX\"; // solium-disable-line uppercase\r\n    uint8 public constant decimals = 18; // solium-disable-line uppercase\r\n \r\n    // lockup sruct\r\n    struct Lockup {\r\n        uint256 release; // release timestamp\r\n        uint256 amount; // amount of tokens to release\r\n    }\r\n\r\n    // list of lockups\r\n    mapping (address => Lockup[]) public lockups;\r\n\r\n    // list of lockups that can be refunded\r\n    mapping (address => mapping (address => Lockup[])) public refundable;\r\n\r\n    // idexes mapping from refundable to lockups lists \r\n    mapping (address => mapping (address => mapping (uint256 => uint256))) public indexes;    \r\n\r\n    // Platin TGE contract\r\n    PlatinTGE public tge;\r\n\r\n    // allocation event logging\r\n    event Allocate(address indexed to, uint256 amount);\r\n\r\n    // lockup event logging\r\n    event SetLockups(address indexed to, uint256 amount, uint256 fromIdx, uint256 toIdx);\r\n\r\n    // refund event logging\r\n    event Refund(address indexed from, address indexed to, uint256 amount);\r\n\r\n    // spotTransfer modifier, check balance spot on transfer\r\n    modifier spotTransfer(address _from, uint256 _value) {\r\n        require(_value <= balanceSpot(_from), \"Attempt to transfer more than balance spot.\");\r\n        _;\r\n    }\r\n\r\n    // onlyTGE modifier, restrict to the TGE contract only\r\n    modifier onlyTGE() {\r\n        require(msg.sender == address(tge), \"Only TGE method.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Set TGE contract\r\n     * @param _tge address PlatinTGE contract address    \r\n     */\r\n    function setTGE(PlatinTGE _tge) external onlyOwner {\r\n        require(tge == address(0), \"TGE is already set.\");\r\n        require(_tge != address(0), \"TGE address can't be zero.\");\r\n        tge = _tge;\r\n        authorize(_tge);\r\n    }        \r\n\r\n    /**\r\n     * @dev Allocate tokens during TGE\r\n     * @param _to address Address gets the tokens\r\n     * @param _amount uint256 Amount to allocate\r\n     */ \r\n    function allocate(address _to, uint256 _amount) external onlyTGE {\r\n        require(_to != address(0), \"Allocate To address can't be zero\");\r\n        require(_amount > 0, \"Allocate amount should be > 0.\");\r\n       \r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n\r\n        _addHolder(_to);\r\n\r\n        require(totalSupply_ <= tge.TOTAL_SUPPLY(), \"Can't allocate more than TOTAL SUPPLY.\");\r\n\r\n        emit Allocate(_to, _amount);\r\n        emit Transfer(address(0), _to, _amount);\r\n    }  \r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @return bool Returns true if the transfer was succeeded\r\n     */\r\n    function transfer(address _to, uint256 _value) public whenNotPaused spotTransfer(msg.sender, _value) returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @return bool Returns true if the transfer was succeeded\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused spotTransfer(_from, _value) returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another with lockup\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @param _lockupReleases uint256[] List of lockup releases\r\n     * @param _lockupAmounts uint256[] List of lockup amounts\r\n     * @param _refundable bool Is locked up amount refundable\r\n     * @return bool Returns true if the transfer was succeeded     \r\n     */\r\n    function transferWithLockup(\r\n        address _to, \r\n        uint256 _value, \r\n        uint256[] _lockupReleases,\r\n        uint256[] _lockupAmounts,\r\n        bool _refundable\r\n    ) \r\n    public onlyAuthorized returns (bool)\r\n    {        \r\n        transfer(_to, _value);\r\n        _lockup(_to, _value, _lockupReleases, _lockupAmounts, _refundable); // solium-disable-line arg-overflow     \r\n    }       \r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another with lockup\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 The amount of tokens to be transferred\r\n     * @param _lockupReleases uint256[] List of lockup releases\r\n     * @param _lockupAmounts uint256[] List of lockup amounts\r\n     * @param _refundable bool Is locked up amount refundable      \r\n     * @return bool Returns true if the transfer was succeeded     \r\n     */\r\n    function transferFromWithLockup(\r\n        address _from, \r\n        address _to, \r\n        uint256 _value, \r\n        uint256[] _lockupReleases,\r\n        uint256[] _lockupAmounts,\r\n        bool _refundable\r\n    ) \r\n    public onlyAuthorized returns (bool)\r\n    {\r\n        transferFrom(_from, _to, _value);\r\n        _lockup(_to, _value, _lockupReleases, _lockupAmounts, _refundable); // solium-disable-line arg-overflow  \r\n    }     \r\n\r\n    /**\r\n     * @dev Refund refundable locked up amount\r\n     * @param _from address The address which you want to refund tokens from\r\n     * @return uint256 Returns amount of refunded tokens   \r\n     */\r\n    function refundLockedUp(\r\n        address _from\r\n    )\r\n    public onlyAuthorized returns (uint256)\r\n    {\r\n        address _sender = msg.sender;\r\n        uint256 _balanceRefundable = 0;\r\n        uint256 _refundableLength = refundable[_from][_sender].length;\r\n        if (_refundableLength > 0) {\r\n            uint256 _lockupIdx;\r\n            for (uint256 i = 0; i < _refundableLength; i++) {\r\n                if (refundable[_from][_sender][i].release > block.timestamp) { // solium-disable-line security/no-block-members\r\n                    _balanceRefundable = _balanceRefundable.add(refundable[_from][_sender][i].amount);\r\n                    refundable[_from][_sender][i].release = 0;\r\n                    refundable[_from][_sender][i].amount = 0;\r\n                    _lockupIdx = indexes[_from][_sender][i];\r\n                    lockups[_from][_lockupIdx].release = 0;\r\n                    lockups[_from][_lockupIdx].amount = 0;       \r\n                }    \r\n            }\r\n\r\n            if (_balanceRefundable > 0) {\r\n                _preserveHolders(_from, _sender, _balanceRefundable);\r\n                balances[_from] = balances[_from].sub(_balanceRefundable);\r\n                balances[_sender] = balances[_sender].add(_balanceRefundable);\r\n                emit Refund(_from, _sender, _balanceRefundable);\r\n                emit Transfer(_from, _sender, _balanceRefundable);\r\n            }\r\n        }\r\n        return _balanceRefundable;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the lockups list count\r\n     * @param _who address Address owns locked up list\r\n     * @return uint256 Lockups list count\r\n     */\r\n    function lockupsCount(address _who) public view returns (uint256) {\r\n        return lockups[_who].length;\r\n    }\r\n\r\n    /**\r\n     * @dev Find out if the address has lockups\r\n     * @param _who address Address checked for lockups\r\n     * @return bool Returns true if address has lockups\r\n     */\r\n    function hasLockups(address _who) public view returns (bool) {\r\n        return lockups[_who].length > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev Get balance locked up at the current moment of time\r\n     * @param _who address Address owns locked up amounts\r\n     * @return uint256 Balance locked up at the current moment of time\r\n     */\r\n    function balanceLockedUp(address _who) public view returns (uint256) {\r\n        uint256 _balanceLokedUp = 0;\r\n        uint256 _lockupsLength = lockups[_who].length;\r\n        for (uint256 i = 0; i < _lockupsLength; i++) {\r\n            if (lockups[_who][i].release > block.timestamp) // solium-disable-line security/no-block-members\r\n                _balanceLokedUp = _balanceLokedUp.add(lockups[_who][i].amount);\r\n        }\r\n        return _balanceLokedUp;\r\n    }\r\n\r\n    /**\r\n     * @dev Get refundable locked up balance at the current moment of time\r\n     * @param _who address Address owns locked up amounts\r\n     * @param _sender address Address owned locked up amounts\r\n     * @return uint256 Locked up refundable balance at the current moment of time\r\n     */\r\n    function balanceRefundable(address _who, address _sender) public view returns (uint256) {\r\n        uint256 _balanceRefundable = 0;\r\n        uint256 _refundableLength = refundable[_who][_sender].length;\r\n        if (_refundableLength > 0) {\r\n            for (uint256 i = 0; i < _refundableLength; i++) {\r\n                if (refundable[_who][_sender][i].release > block.timestamp) // solium-disable-line security/no-block-members\r\n                    _balanceRefundable = _balanceRefundable.add(refundable[_who][_sender][i].amount);\r\n            }\r\n        }\r\n        return _balanceRefundable;\r\n    }\r\n\r\n    /**\r\n     * @dev Get balance spot for the current moment of time\r\n     * @param _who address Address owns balance spot\r\n     * @return uint256 Balance spot for the current moment of time\r\n     */\r\n    function balanceSpot(address _who) public view returns (uint256) {\r\n        uint256 _balanceSpot = balanceOf(_who);\r\n        _balanceSpot = _balanceSpot.sub(balanceLockedUp(_who));\r\n        return _balanceSpot;\r\n    }\r\n\r\n    /**\r\n     * @dev Lockup amount till release time\r\n     * @param _who address Address gets the locked up amount\r\n     * @param _amount uint256 Amount to lockup\r\n     * @param _lockupReleases uint256[] List of lockup releases\r\n     * @param _lockupAmounts uint256[] List of lockup amounts\r\n     * @param _refundable bool Is locked up amount refundable     \r\n     */     \r\n    function _lockup(\r\n        address _who, \r\n        uint256 _amount, \r\n        uint256[] _lockupReleases,\r\n        uint256[] _lockupAmounts,\r\n        bool _refundable) \r\n    internal \r\n    {\r\n        require(_lockupReleases.length == _lockupAmounts.length, \"Length of lockup releases and amounts lists should be equal.\");\r\n        require(_lockupReleases.length.add(lockups[_who].length) <= 1000, \"Can't be more than 1000 lockups per address.\");\r\n        if (_lockupReleases.length > 0) {\r\n            uint256 _balanceLokedUp = 0;\r\n            address _sender = msg.sender;\r\n            uint256 _fromIdx = lockups[_who].length;\r\n            uint256 _toIdx = _fromIdx + _lockupReleases.length - 1;\r\n            uint256 _lockupIdx;\r\n            uint256 _refundIdx;\r\n            for (uint256 i = 0; i < _lockupReleases.length; i++) {\r\n                if (_lockupReleases[i] > block.timestamp) { // solium-disable-line security/no-block-members\r\n                    lockups[_who].push(Lockup(_lockupReleases[i], _lockupAmounts[i]));\r\n                    _balanceLokedUp = _balanceLokedUp.add(_lockupAmounts[i]);\r\n                    if (_refundable) {\r\n                        refundable[_who][_sender].push(Lockup(_lockupReleases[i], _lockupAmounts[i]));\r\n                        _lockupIdx = lockups[_who].length - 1;\r\n                        _refundIdx = refundable[_who][_sender].length - 1;\r\n                        indexes[_who][_sender][_refundIdx] = _lockupIdx;\r\n                    }\r\n                }\r\n            }\r\n\r\n            require(_balanceLokedUp <= _amount, \"Can't lockup more than transferred amount.\");\r\n            emit SetLockups(_who, _amount, _fromIdx, _toIdx); // solium-disable-line arg-overflow\r\n        }            \r\n    }      \r\n}\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(\r\n    address indexed purchaser,\r\n    address indexed beneficiary,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per wei\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n  constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(\r\n      msg.sender,\r\n      _beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(_beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method: \r\n   *   super._preValidatePurchase(_beneficiary, _weiAmount);\r\n   *   require(weiRaised.add(_weiAmount) <= cap);\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    token.safeTransfer(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _deliverTokens(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount)\r\n    internal view returns (uint256)\r\n  {\r\n    return _weiAmount.mul(rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyWhileOpen\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of Crowdsale where an owner can do extra work\r\n * after finishing.\r\n */\r\ncontract FinalizableCrowdsale is Ownable, TimedCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  bool public isFinalized = false;\r\n\r\n  event Finalized();\r\n\r\n  /**\r\n   * @dev Must be called after crowdsale ends, to do some extra finalization\r\n   * work. Calls the contract's finalization function.\r\n   */\r\n  function finalize() public onlyOwner {\r\n    require(!isFinalized);\r\n    require(hasClosed());\r\n\r\n    finalization();\r\n    emit Finalized();\r\n\r\n    isFinalized = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Can be overridden to add finalization logic. The overriding function\r\n   * should call super.finalization() to ensure the chain of finalization is\r\n   * executed entirely.\r\n   */\r\n  function finalization() internal {\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n * See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n  {\r\n    require(has(_role, _addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _role.bearer[_addr];\r\n  }\r\n}\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * Supports unlimited numbers of roles and addresses.\r\n * See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n * for you to write your own implementation of this interface using Enums or similar.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address indexed operator, string role);\r\n  event RoleRemoved(address indexed operator, string role);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address _operator, string _role)\r\n    public\r\n    view\r\n  {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address _operator, string _role)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function addRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function removeRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string _role)\r\n  {\r\n    checkRole(msg.sender, _role);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param _roles the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] _roles) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < _roles.length; i++) {\r\n  //         if (hasRole(msg.sender, _roles[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n/**\r\n * @title Whitelist\r\n * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions.\r\n * This simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Whitelist is Ownable, RBAC {\r\n  string public constant ROLE_WHITELISTED = \"whitelist\";\r\n\r\n  /**\r\n   * @dev Throws if operator is not whitelisted.\r\n   * @param _operator address\r\n   */\r\n  modifier onlyIfWhitelisted(address _operator) {\r\n    checkRole(_operator, ROLE_WHITELISTED);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev add an address to the whitelist\r\n   * @param _operator address\r\n   * @return true if the address was added to the whitelist, false if the address was already in the whitelist\r\n   */\r\n  function addAddressToWhitelist(address _operator)\r\n    public\r\n    onlyOwner\r\n  {\r\n    addRole(_operator, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address is in whitelist\r\n   */\r\n  function whitelist(address _operator)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return hasRole(_operator, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev add addresses to the whitelist\r\n   * @param _operators addresses\r\n   * @return true if at least one address was added to the whitelist,\r\n   * false if all addresses were already in the whitelist\r\n   */\r\n  function addAddressesToWhitelist(address[] _operators)\r\n    public\r\n    onlyOwner\r\n  {\r\n    for (uint256 i = 0; i < _operators.length; i++) {\r\n      addAddressToWhitelist(_operators[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address from the whitelist\r\n   * @param _operator address\r\n   * @return true if the address was removed from the whitelist,\r\n   * false if the address wasn't in the whitelist in the first place\r\n   */\r\n  function removeAddressFromWhitelist(address _operator)\r\n    public\r\n    onlyOwner\r\n  {\r\n    removeRole(_operator, ROLE_WHITELISTED);\r\n  }\r\n\r\n  /**\r\n   * @dev remove addresses from the whitelist\r\n   * @param _operators addresses\r\n   * @return true if at least one address was removed from the whitelist,\r\n   * false if all addresses weren't in the whitelist in the first place\r\n   */\r\n  function removeAddressesFromWhitelist(address[] _operators)\r\n    public\r\n    onlyOwner\r\n  {\r\n    for (uint256 i = 0; i < _operators.length; i++) {\r\n      removeAddressFromWhitelist(_operators[i]);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title WhitelistedCrowdsale\r\n * @dev Crowdsale in which only whitelisted users can contribute.\r\n */\r\ncontract WhitelistedCrowdsale is Whitelist, Crowdsale {\r\n  /**\r\n   * @dev Extend parent behavior requiring beneficiary to be in whitelist.\r\n   * @param _beneficiary Token beneficiary\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyIfWhitelisted(_beneficiary)\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title PlatinICO\r\n * @dev Platin public sales contract. Before purchase customers should be whitelisted\r\n * during KYC/AML procedure. Tokens can be purchased with and without lockup.\r\n * Locked up tokens purchase has special token rate. Locked up tokens purchase can be performed\r\n * not more than 1000 times due to the limitation of lockups per one address.\r\n * When ICO ends, unsold tokens are distributed to the unsold token reserve.\r\n * All constants for processing purchases and for finalization are stored in the TGE contract.\r\n */\r\ncontract PlatinICO is FinalizableCrowdsale, WhitelistedCrowdsale, Pausable {\r\n    using SafeMath for uint256;\r\n\r\n    // Lockup purchase\r\n    bool lockup;\r\n\r\n    // Amount of sold tokens \r\n    uint256 public sold;\r\n\r\n    // Platin TGE contract\r\n    PlatinTGE public tge;\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @param _rate uint256 Number of token units a buyer gets per wei\r\n     * @param _wallet address Address where collected funds will be forwarded to\r\n     * @param _token address Address of the token being sold  \r\n     * @param _openingTime uint256 Crowdsale opening time\r\n     * @param _closingTime uint256 Crowdsale closing time        \r\n     */  \r\n    constructor(\r\n        uint256 _rate, \r\n        address _wallet, \r\n        ERC20 _token, \r\n        uint256 _openingTime, \r\n        uint256 _closingTime\r\n    )\r\n    Crowdsale(_rate, _wallet, _token) \r\n    TimedCrowdsale(_openingTime, _closingTime)\r\n    public \r\n    {}\r\n\r\n    /**\r\n     * @dev Set TGE contract\r\n     * @param _tge address PlatinTGE contract address    \r\n     */\r\n    function setTGE(PlatinTGE _tge) external onlyOwner {\r\n        require(tge == address(0), \"TGE is already set.\");\r\n        require(_tge != address(0), \"TGE address can't be zero.\");\r\n        tge = _tge;\r\n        rate = tge.TOKEN_RATE();\r\n    }\r\n\r\n    /**\r\n     * @dev Purchase and lockup purchased tokens\r\n     */\r\n    function buyLockupTokens(address _beneficiary) external payable {\r\n        lockup = true;\r\n        if (_beneficiary == address(0x0))\r\n            buyTokens(msg.sender);\r\n        else\r\n            buyTokens(_beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @dev Extend parent behavior to deliver purchase\r\n     * @param _beneficiary address Address performing the token purchase\r\n     * @param _tokenAmount uint256 Number of tokens to be emitted\r\n     */\r\n    function _deliverTokens(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        if (lockup) {\r\n            uint256[] memory _lockupReleases = new uint256[](1);\r\n            uint256[] memory _lockupAmounts = new uint256[](1);\r\n            _lockupReleases[0] = block.timestamp + tge.ICO_LOCKUP_PERIOD(); // solium-disable-line security/no-block-members\r\n            _lockupAmounts[0] = _tokenAmount;\r\n            PlatinToken(token).transferWithLockup(\r\n                _beneficiary, \r\n                _tokenAmount,\r\n                _lockupReleases,\r\n                _lockupAmounts,\r\n                false);\r\n            lockup = false;   \r\n        } else {\r\n            PlatinToken(token).transfer(\r\n                _beneficiary, \r\n                _tokenAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Extend parent behavior to process purchase\r\n     * @param _beneficiary address Address receiving the tokens\r\n     * @param _tokenAmount uint256 Number of tokens to be purchased\r\n     */\r\n    function _processPurchase(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount\r\n    )\r\n        internal\r\n    {\r\n        require(sold.add(_tokenAmount) <= tge.ICO_AMOUNT(), \"Can't be sold more than ICO amount.\");\r\n        sold = sold.add(_tokenAmount);\r\n        super._processPurchase(_beneficiary, _tokenAmount);\r\n    }  \r\n\r\n    /**\r\n     * @dev Finalization, transfer unsold tokens to the reserve address with lockup\r\n     */    \r\n    function finalization() internal {\r\n        uint256 _unsold = token.balanceOf(this);\r\n        if (_unsold > 0) {         \r\n            PlatinToken(token).transfer(\r\n                tge.UNSOLD_RESERVE(),\r\n                _unsold);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Extend parent behavior requiring contract to be not paused and the min purchase amount is received.\r\n     * @param _beneficiary address Token beneficiary\r\n     * @param _weiAmount uint256 Amount of wei contributed\r\n     */\r\n    function _preValidatePurchase(\r\n        address _beneficiary,\r\n        uint256 _weiAmount\r\n    )\r\n        internal\r\n        whenNotPaused\r\n    {\r\n        require(_weiAmount >= tge.MIN_PURCHASE_AMOUNT(), \"Insufficient funds to make the purchase.\");\r\n        super._preValidatePurchase(_beneficiary, _weiAmount);\r\n    } \r\n\r\n    /**\r\n     * @dev Override parent behavior to process lockup purchase if needed\r\n     * @param _weiAmount uint256 Value in wei to be converted into tokens\r\n     * @return uint256 Number of tokens that can be purchased with the specified _weiAmount\r\n     */\r\n    function _getTokenAmount(uint256 _weiAmount)\r\n        internal view returns (uint256)\r\n    {\r\n        uint256 _rate = rate;\r\n        if (lockup)\r\n            _rate = tge.TOKEN_RATE_LOCKUP();\r\n        return _weiAmount.mul(_rate);\r\n    }    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"sold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_WHITELISTED\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"removeAddressesFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"removeAddressFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"addAddressToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tge\",\"type\":\"address\"}],\"name\":\"setTGE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tge\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyLockupTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operators\",\"type\":\"address[]\"}],\"name\":\"addAddressesToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PlatinICO","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000ea7f4839dee9801723349cf89a1a3cea21d1d9c40000000000000000000000008f9202a23237cb51aab7c955b39049a14d2c41be000000000000000000000000000000000000000000000000000000005bd5a4c0000000000000000000000000000000000000000000000000000000005c01cf00","Library":"","SwarmSource":"bzzr://a3a344904863b91fc901e672e7c857a2d1d108289a6c815bd53fbdaf014d6705"}]}