{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/interfaces/DisbursementHandlerI.sol\r\n\r\ninterface DisbursementHandlerI {\r\n    function withdraw(address _beneficiary, uint256 _index) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/DisbursementHandler.sol\r\n\r\n/// @title Disbursement handler - Manages time locked disbursements of ERC20 tokens\r\ncontract DisbursementHandler is DisbursementHandlerI, Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20;\r\n\r\n    struct Disbursement {\r\n        // Tokens cannot be withdrawn before this timestamp\r\n        uint256 timestamp;\r\n\r\n        // Amount of tokens to be disbursed\r\n        uint256 value;\r\n    }\r\n\r\n    event Setup(address indexed _beneficiary, uint256 _timestamp, uint256 _value);\r\n    event TokensWithdrawn(address indexed _to, uint256 _value);\r\n\r\n    ERC20 public token;\r\n    uint256 public totalAmount;\r\n    mapping(address => Disbursement[]) public disbursements;\r\n\r\n    bool public closed;\r\n\r\n    modifier isOpen {\r\n        require(!closed, \"Disbursement Handler is closed\");\r\n        _;\r\n    }\r\n\r\n    modifier isClosed {\r\n        require(closed, \"Disbursement Handler is open\");\r\n        _;\r\n    }\r\n\r\n\r\n    constructor(ERC20 _token) public {\r\n        require(_token != address(0), \"Token cannot have address 0\");\r\n        token = _token;\r\n    }\r\n\r\n    /// @dev Called to create disbursements.\r\n    /// @param _beneficiaries The addresses of the beneficiaries.\r\n    /// @param _values The number of tokens to be locked for each disbursement.\r\n    /// @param _timestamps Funds will be locked until this timestamp for each disbursement.\r\n    function setupDisbursements(\r\n        address[] _beneficiaries,\r\n        uint256[] _values,\r\n        uint256[] _timestamps\r\n    )\r\n        external\r\n        onlyOwner\r\n        isOpen\r\n    {\r\n        require((_beneficiaries.length == _values.length) && (_beneficiaries.length == _timestamps.length), \"Arrays not of equal length\");\r\n        require(_beneficiaries.length > 0, \"Arrays must have length > 0\");\r\n\r\n        for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n            setupDisbursement(_beneficiaries[i], _values[i], _timestamps[i]);\r\n        }\r\n    }\r\n\r\n    function close() external onlyOwner isOpen {\r\n        closed = true;\r\n    }\r\n\r\n    /// @dev Called by the sale contract to create a disbursement.\r\n    /// @param _beneficiary The address of the beneficiary.\r\n    /// @param _value Amount of tokens to be locked.\r\n    /// @param _timestamp Funds will be locked until this timestamp.\r\n    function setupDisbursement(\r\n        address _beneficiary,\r\n        uint256 _value,\r\n        uint256 _timestamp\r\n    )\r\n        internal\r\n    {\r\n        require(block.timestamp < _timestamp, \"Disbursement timestamp in the past\");\r\n        disbursements[_beneficiary].push(Disbursement(_timestamp, _value));\r\n        totalAmount = totalAmount.add(_value);\r\n        emit Setup(_beneficiary, _timestamp, _value);\r\n    }\r\n\r\n    /// @dev Transfers tokens to a beneficiary\r\n    /// @param _beneficiary The address to transfer tokens to\r\n    /// @param _index The index of the disbursement\r\n    function withdraw(address _beneficiary, uint256 _index)\r\n        external\r\n        isClosed\r\n    {\r\n        Disbursement[] storage beneficiaryDisbursements = disbursements[_beneficiary];\r\n        require(_index < beneficiaryDisbursements.length, \"Supplied index out of disbursement range\");\r\n\r\n        Disbursement memory disbursement = beneficiaryDisbursements[_index];\r\n        require(disbursement.timestamp < now && disbursement.value > 0, \"Disbursement timestamp not reached, or disbursement value of 0\");\r\n\r\n        // Remove the withdrawn disbursement\r\n        delete beneficiaryDisbursements[_index];\r\n\r\n        token.safeTransfer(_beneficiary, disbursement.value);\r\n        emit TokensWithdrawn(_beneficiary, disbursement.value);\r\n    }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/interfaces/VaultI.sol\r\n\r\ninterface VaultI {\r\n    function deposit(address contributor) external payable;\r\n    function saleSuccessful() external;\r\n    function enableRefunds() external;\r\n    function refund(address contributor) external;\r\n    function close() external;\r\n    function sendFundsToWallet() external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/Math.sol\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/Vault.sol\r\n\r\n// Adapted from Open Zeppelin's RefundVault\r\n\r\n/**\r\n * @title Vault\r\n * @dev This contract is used for storing funds while a crowdsale\r\n * is in progress. Supports refunding the money if crowdsale fails,\r\n * and forwarding it if crowdsale is successful.\r\n */\r\ncontract Vault is VaultI, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    enum State { Active, Success, Refunding, Closed }\r\n\r\n    // The timestamp of the first deposit\r\n    uint256 public firstDepositTimestamp; \r\n\r\n    mapping (address => uint256) public deposited;\r\n\r\n    // The amount to be disbursed to the wallet every month\r\n    uint256 public disbursementWei;\r\n    uint256 public disbursementDuration;\r\n\r\n    // Wallet from the project team\r\n    address public trustedWallet;\r\n\r\n    // The eth amount the team will get initially if the sale is successful\r\n    uint256 public initialWei;\r\n\r\n    // Timestamp that has to pass before sending funds to the wallet\r\n    uint256 public nextDisbursement;\r\n    \r\n    // Total amount that was deposited\r\n    uint256 public totalDeposited;\r\n\r\n    // Amount that can be refunded\r\n    uint256 public refundable;\r\n\r\n    State public state;\r\n\r\n    event Closed();\r\n    event RefundsEnabled();\r\n    event Refunded(address indexed contributor, uint256 amount);\r\n\r\n    modifier atState(State _state) {\r\n        require(state == _state, \"This function cannot be called in the current vault state.\");\r\n        _;\r\n    }\r\n\r\n    constructor (\r\n        address _wallet,\r\n        uint256 _initialWei,\r\n        uint256 _disbursementWei,\r\n        uint256 _disbursementDuration\r\n    ) \r\n        public \r\n    {\r\n        require(_wallet != address(0), \"Wallet address should not be 0.\");\r\n        require(_disbursementWei != 0, \"Disbursement Wei should be greater than 0.\");\r\n        trustedWallet = _wallet;\r\n        initialWei = _initialWei;\r\n        disbursementWei = _disbursementWei;\r\n        disbursementDuration = _disbursementDuration;\r\n        state = State.Active;\r\n    }\r\n\r\n    /// @dev Called by the sale contract to deposit ether for a contributor.\r\n    function deposit(address _contributor) onlyOwner external payable {\r\n        require(state == State.Active || state == State.Success , \"Vault state must be Active or Success.\");\r\n        if (firstDepositTimestamp == 0) {\r\n            firstDepositTimestamp = now;\r\n        }\r\n        totalDeposited = totalDeposited.add(msg.value);\r\n        deposited[_contributor] = deposited[_contributor].add(msg.value);\r\n    }\r\n\r\n    /// @dev Sends initial funds to the wallet.\r\n    function saleSuccessful()\r\n        onlyOwner \r\n        external \r\n        atState(State.Active)\r\n    {\r\n        state = State.Success;\r\n        transferToWallet(initialWei);\r\n    }\r\n\r\n    /// @dev Called by the owner if the project didn't deliver the testnet contracts or if we need to stop disbursements for any reasone.\r\n    function enableRefunds() onlyOwner external {\r\n        require(state != State.Refunding, \"Vault state is not Refunding\");\r\n        state = State.Refunding;\r\n        uint256 currentBalance = address(this).balance;\r\n        refundable = currentBalance <= totalDeposited ? currentBalance : totalDeposited;\r\n        emit RefundsEnabled();\r\n    }\r\n\r\n    /// @dev Refunds ether to the contributors if in the Refunding state.\r\n    function refund(address _contributor) external atState(State.Refunding) {\r\n        require(deposited[_contributor] > 0, \"Refund not allowed if contributor deposit is 0.\");\r\n        uint256 refundAmount = deposited[_contributor].mul(refundable).div(totalDeposited);\r\n        deposited[_contributor] = 0;\r\n        _contributor.transfer(refundAmount);\r\n        emit Refunded(_contributor, refundAmount);\r\n    }\r\n\r\n    /// @dev Called by the owner if the sale has ended.\r\n    function close() external atState(State.Success) onlyOwner {\r\n        state = State.Closed;\r\n        nextDisbursement = now;\r\n        emit Closed();\r\n    }\r\n\r\n    /// @dev Sends the disbursement amount to the wallet after the disbursement period has passed. Can be called by anyone.\r\n    function sendFundsToWallet() external atState(State.Closed) {\r\n        require(firstDepositTimestamp.add(4 weeks) <= now, \"First contributor\\ń0027s deposit was less than 28 days ago\");\r\n        require(nextDisbursement <= now, \"Next disbursement period timestamp has not yet passed, too early to withdraw.\");\r\n\r\n        if (disbursementDuration == 0) {\r\n            trustedWallet.transfer(address(this).balance);\r\n            return;\r\n        }\r\n\r\n        uint256 numberOfDisbursements = now.sub(nextDisbursement).div(disbursementDuration).add(1);\r\n\r\n        nextDisbursement = nextDisbursement.add(disbursementDuration.mul(numberOfDisbursements));\r\n\r\n        transferToWallet(disbursementWei.mul(numberOfDisbursements));\r\n    }\r\n\r\n    function transferToWallet(uint256 _amount) internal {\r\n        uint256 amountToSend = Math.min256(_amount, address(this).balance);\r\n        trustedWallet.transfer(amountToSend);\r\n    }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/interfaces/WhitelistableI.sol\r\n\r\ninterface WhitelistableI {\r\n    function changeAdmin(address _admin) external;\r\n    function invalidateHash(bytes32 _hash) external;\r\n    function invalidateHashes(bytes32[] _hashes) external;\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ECRecovery.sol\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n *\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n *\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * @dev and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      \"\\x19Ethereum Signed Message:\\n32\",\r\n      hash\r\n    );\r\n  }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/Whitelistable.sol\r\n\r\n/**\r\n * @title Whitelistable\r\n * @dev This contract is used to implement a signature based whitelisting mechanism\r\n */\r\ncontract Whitelistable is WhitelistableI, Ownable {\r\n    using ECRecovery for bytes32;\r\n\r\n    address public whitelistAdmin;\r\n\r\n    // True if the hash has been invalidated\r\n    mapping(bytes32 => bool) public invalidHash;\r\n\r\n    event AdminUpdated(address indexed newAdmin);\r\n\r\n    modifier validAdmin(address _admin) {\r\n        require(_admin != 0, \"Admin address cannot be 0\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == whitelistAdmin, \"Only the whitelist admin may call this function\");\r\n        _;\r\n    }\r\n\r\n    modifier isWhitelisted(bytes32 _hash, bytes _sig) {\r\n        require(checkWhitelisted(_hash, _sig), \"The provided hash is not whitelisted\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Constructor for Whitelistable contract\r\n    /// @param _admin the address of the admin that will generate the signatures\r\n    constructor(address _admin) public validAdmin(_admin) {\r\n        whitelistAdmin = _admin;        \r\n    }\r\n\r\n    /// @dev Updates whitelistAdmin address \r\n    /// @dev Can only be called by the current owner\r\n    /// @param _admin the new admin address\r\n    function changeAdmin(address _admin)\r\n        external\r\n        onlyOwner\r\n        validAdmin(_admin)\r\n    {\r\n        emit AdminUpdated(_admin);\r\n        whitelistAdmin = _admin;\r\n    }\r\n\r\n    // @dev blacklists the given address to ban them from contributing\r\n    // @param _contributor Address of the contributor to blacklist \r\n    function invalidateHash(bytes32 _hash) external onlyAdmin {\r\n        invalidHash[_hash] = true;\r\n    }\r\n\r\n    function invalidateHashes(bytes32[] _hashes) external onlyAdmin {\r\n        for (uint i = 0; i < _hashes.length; i++) {\r\n            invalidHash[_hashes[i]] = true;\r\n        }\r\n    }\r\n\r\n    /// @dev Checks if a hash has been signed by the whitelistAdmin\r\n    /// @param _rawHash The hash that was used to generate the signature\r\n    /// @param _sig The EC signature generated by the whitelistAdmin\r\n    /// @return Was the signature generated by the admin for the hash?\r\n    function checkWhitelisted(\r\n        bytes32 _rawHash,\r\n        bytes _sig\r\n    )\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        bytes32 hash = _rawHash.toEthSignedMessageHash();\r\n        return !invalidHash[_rawHash] && whitelistAdmin == hash.recover(_sig);\r\n    }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/interfaces/EthPriceFeedI.sol\r\n\r\ninterface EthPriceFeedI {\r\n    function getUnit() external view returns(string);\r\n    function getRate() external view returns(uint256);\r\n    function getLastTimeUpdated() external view returns(uint256); \r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/interfaces/SaleI.sol\r\n\r\ninterface SaleI {\r\n    function setup() external;  \r\n    function changeEthPriceFeed(EthPriceFeedI newPriceFeed) external;\r\n    function contribute(address _contributor, uint256 _limit, uint256 _expiration, bytes _sig) external payable; \r\n    function allocateExtraTokens(address _contributor) external;\r\n    function setEndTime(uint256 _endTime) external;\r\n    function endSale() external;\r\n}\r\n\r\n// File: @tokenfoundry/state-machine/contracts/StateMachine.sol\r\n\r\ncontract StateMachine {\r\n\r\n    struct State { \r\n        bytes32 nextStateId;\r\n        mapping(bytes4 => bool) allowedFunctions;\r\n        function() internal[] transitionCallbacks;\r\n        function(bytes32) internal returns(bool)[] startConditions;\r\n    }\r\n\r\n    mapping(bytes32 => State) states;\r\n\r\n    // The current state id\r\n    bytes32 private currentStateId;\r\n\r\n    event Transition(bytes32 stateId, uint256 blockNumber);\r\n\r\n    /* This modifier performs the conditional transitions and checks that the function \r\n     * to be executed is allowed in the current State\r\n     */\r\n    modifier checkAllowed {\r\n        conditionalTransitions();\r\n        require(states[currentStateId].allowedFunctions[msg.sig]);\r\n        _;\r\n    }\r\n\r\n    ///@dev transitions the state machine into the state it should currently be in\r\n    ///@dev by taking into account the current conditions and how many further transitions can occur \r\n    function conditionalTransitions() public {\r\n        bool checkNextState; \r\n        do {\r\n            checkNextState = false;\r\n\r\n            bytes32 next = states[currentStateId].nextStateId;\r\n            // If one of the next state's conditions is met, go to this state and continue\r\n\r\n            for (uint256 i = 0; i < states[next].startConditions.length; i++) {\r\n                if (states[next].startConditions[i](next)) {\r\n                    goToNextState();\r\n                    checkNextState = true;\r\n                    break;\r\n                }\r\n            } \r\n        } while (checkNextState);\r\n    }\r\n\r\n    function getCurrentStateId() view public returns(bytes32) {\r\n        return currentStateId;\r\n    }\r\n\r\n    /// @dev Setup the state machine with the given states.\r\n    /// @param _stateIds Array of state ids.\r\n    function setStates(bytes32[] _stateIds) internal {\r\n        require(_stateIds.length > 0);\r\n        require(currentStateId == 0);\r\n\r\n        require(_stateIds[0] != 0);\r\n\r\n        currentStateId = _stateIds[0];\r\n\r\n        for (uint256 i = 1; i < _stateIds.length; i++) {\r\n            require(_stateIds[i] != 0);\r\n\r\n            states[_stateIds[i - 1]].nextStateId = _stateIds[i];\r\n\r\n            // Check that the state appears only once in the array\r\n            require(states[_stateIds[i]].nextStateId == 0);\r\n        }\r\n    }\r\n\r\n    /// @dev Allow a function in the given state.\r\n    /// @param _stateId The id of the state\r\n    /// @param _functionSelector A function selector (bytes4[keccak256(functionSignature)])\r\n    function allowFunction(bytes32 _stateId, bytes4 _functionSelector) \r\n        internal \r\n    {\r\n        states[_stateId].allowedFunctions[_functionSelector] = true;\r\n    }\r\n\r\n    /// @dev Goes to the next state if possible (if the next state is valid)\r\n    function goToNextState() internal {\r\n        bytes32 next = states[currentStateId].nextStateId;\r\n        require(next != 0);\r\n\r\n        currentStateId = next;\r\n        for (uint256 i = 0; i < states[next].transitionCallbacks.length; i++) {\r\n            states[next].transitionCallbacks[i]();\r\n        }\r\n\r\n        emit Transition(next, block.number);\r\n    }\r\n\r\n    ///@dev Add a function returning a boolean as a start condition for a state. \r\n    /// If any condition returns true, the StateMachine will transition to the next state.\r\n    /// If s.startConditions is empty, the StateMachine will need to enter state s through invoking\r\n    /// the goToNextState() function. \r\n    /// A start condition should never throw. (Otherwise, the StateMachine may fail to enter into the\r\n    /// correct state, and succeeding start conditions may return true.)\r\n    /// A start condition should be gas-inexpensive since every one of them is invoked in the same call to \r\n    /// transition the state. \r\n    ///@param _stateId The ID of the state to add the condition for\r\n    ///@param _condition Start condition function - returns true if a start condition (for a given state ID) is met\r\n    function addStartCondition(\r\n        bytes32 _stateId,\r\n        function(bytes32) internal returns(bool) _condition\r\n    ) \r\n        internal \r\n    {\r\n        states[_stateId].startConditions.push(_condition);\r\n    }\r\n\r\n    ///@dev Add a callback function for a state. All callbacks are invoked immediately after entering the state. \r\n    /// Callback functions should never throw. (Otherwise, the StateMachine may fail to enter a state.)\r\n    /// Callback functions should also be gas-inexpensive as all callbacks are invoked in the same call to enter the state.\r\n    ///@param _stateId The ID of the state to add a callback function for\r\n    ///@param _callback The callback function to add\r\n    function addCallback(bytes32 _stateId, function() internal _callback)\r\n        internal \r\n    {\r\n        states[_stateId].transitionCallbacks.push(_callback);\r\n    }\r\n}\r\n\r\n// File: @tokenfoundry/state-machine/contracts/TimedStateMachine.sol\r\n\r\n/// @title A contract that implements the state machine pattern and adds time dependant transitions.\r\ncontract TimedStateMachine is StateMachine {\r\n\r\n    event StateStartTimeSet(bytes32 indexed _stateId, uint256 _startTime);\r\n\r\n    // Stores the start timestamp for each state (the value is 0 if the state doesn't have a start timestamp).\r\n    mapping(bytes32 => uint256) private startTime;\r\n\r\n    /// @dev Returns the timestamp for the given state id.\r\n    /// @param _stateId The id of the state for which we want to set the start timestamp.\r\n    function getStateStartTime(bytes32 _stateId) public view returns(uint256) {\r\n        return startTime[_stateId];\r\n    }\r\n\r\n    /// @dev Sets the starting timestamp for a state as a startCondition. If other start conditions exist and are \r\n    /// met earlier, then the state may be entered into earlier than the specified start time. \r\n    /// @param _stateId The id of the state for which we want to set the start timestamp.\r\n    /// @param _timestamp The start timestamp for the given state. It should be bigger than the current one.\r\n    function setStateStartTime(bytes32 _stateId, uint256 _timestamp) internal {\r\n        require(block.timestamp < _timestamp);\r\n\r\n        if (startTime[_stateId] == 0) {\r\n            addStartCondition(_stateId, hasStartTimePassed);\r\n        }\r\n\r\n        startTime[_stateId] = _timestamp;\r\n\r\n        emit StateStartTimeSet(_stateId, _timestamp);\r\n    }\r\n\r\n    function hasStartTimePassed(bytes32 _stateId) internal returns(bool) {\r\n        return startTime[_stateId] <= block.timestamp;\r\n    }\r\n\r\n}\r\n\r\n// File: @tokenfoundry/token-contracts/contracts/TokenControllerI.sol\r\n\r\n/// @title Interface for token controllers. The controller specifies whether a transfer can be done.\r\ncontract TokenControllerI {\r\n\r\n    /// @dev Specifies whether a transfer is allowed or not.\r\n    /// @return True if the transfer is allowed\r\n    function transferAllowed(address _from, address _to)\r\n        external\r\n        view \r\n        returns (bool);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: @tokenfoundry/token-contracts/contracts/ControllableToken.sol\r\n\r\n/**\r\n * @title Controllable ERC20 token\r\n *\r\n * @dev Token that queries a token controller contract to check if a transfer is allowed.\r\n * @dev controller state var is going to be set with the address of a TokenControllerI contract that has \r\n * implemented transferAllowed() function.\r\n */\r\ncontract ControllableToken is Ownable, StandardToken {\r\n    TokenControllerI public controller;\r\n\r\n    /// @dev Executes transferAllowed() function from the Controller. \r\n    modifier isAllowed(address _from, address _to) {\r\n        require(controller.transferAllowed(_from, _to), \"Token Controller does not permit transfer.\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Sets the controller that is going to be used by isAllowed modifier\r\n    function setController(TokenControllerI _controller) onlyOwner public {\r\n        require(_controller != address(0), \"Controller address should not be zero.\");\r\n        controller = _controller;\r\n    }\r\n\r\n    /// @dev It calls parent BasicToken.transfer() function. It will transfer an amount of tokens to an specific address\r\n    /// @return True if the token is transfered with success\r\n    function transfer(address _to, uint256 _value) \r\n        isAllowed(msg.sender, _to)\r\n        public\r\n        returns (bool)\r\n    {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /// @dev It calls parent StandardToken.transferFrom() function. It will transfer from an address a certain amount of tokens to another address \r\n    /// @return True if the token is transfered with success \r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        isAllowed(_from, _to) \r\n        public \r\n        returns (bool)\r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol\r\n\r\n/**\r\n * @title DetailedERC20 token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\n// File: @tokenfoundry/token-contracts/contracts/Token.sol\r\n\r\n/**\r\n * @title Token base contract - Defines basic structure for a token\r\n *\r\n * @dev ControllableToken is a StandardToken, an OpenZeppelin ERC20 implementation library. DetailedERC20 is also an OpenZeppelin contract.\r\n * More info about them is available here: https://github.com/OpenZeppelin/zeppelin-solidity/tree/master/contracts/token/ERC20\r\n */\r\ncontract Token is ControllableToken, DetailedERC20 {\r\n\r\n\t/**\r\n\t* @dev Transfer is an event inherited from ERC20Basic.sol interface (OpenZeppelin).\r\n\t* @param _supply Total supply of tokens.\r\n    * @param _name Is the long name by which the token contract should be known\r\n    * @param _symbol The set of capital letters used to represent the token e.g. DTH.\r\n    * @param _decimals The number of decimal places the tokens can be split up into. This should be between 0 and 18.\r\n\t*/\r\n    constructor(\r\n        uint256 _supply,\r\n        string _name,\r\n        string _symbol,\r\n        uint8 _decimals\r\n    ) DetailedERC20(_name, _symbol, _decimals) public {\r\n        require(_supply != 0, \"Supply should be greater than 0.\");\r\n        totalSupply_ = _supply;\r\n        balances[msg.sender] = _supply;\r\n        emit Transfer(address(0), msg.sender, _supply);  //event\r\n    }\r\n}\r\n\r\n// File: @tokenfoundry/sale-contracts/contracts/Sale.sol\r\n\r\n/// @title Sale base contract\r\ncontract Sale is SaleI, Ownable, Whitelistable, TimedStateMachine, TokenControllerI {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for Token;\r\n\r\n    // State machine states\r\n    bytes32 private constant SETUP = \"setup\";\r\n    bytes32 private constant FREEZE = \"freeze\";\r\n    bytes32 private constant SALE_IN_PROGRESS = \"saleInProgress\";\r\n    bytes32 private constant SALE_ENDED = \"saleEnded\";\r\n    // solium-disable-next-line arg-overflow\r\n    bytes32[] public states = [SETUP, FREEZE, SALE_IN_PROGRESS, SALE_ENDED];\r\n\r\n    // Stores the contribution for each user\r\n    mapping(address => uint256) public unitContributions;\r\n\r\n    // Records extra tokens were allocated\r\n    mapping(address => bool) public extraTokensAllocated;\r\n\r\n    DisbursementHandler public disbursementHandler;\r\n\r\n    uint256 public totalContributedUnits = 0; // Units\r\n    uint256 public totalSaleCapUnits; // Units\r\n    uint256 public minContributionUnits; // Units\r\n    uint256 public minThresholdUnits; // Units\r\n\r\n    // How many tokens a user will receive per each unit contributed\r\n    uint256 public saleTokensPerUnit;\r\n    // Rate that will be used to calculate extra tokens if Sale is not sold out\r\n    uint256 public extraTokensPerUnit;\r\n    // Total amount of tokens that the sale will distribute to contributors\r\n    uint256 public tokensForSale;\r\n\r\n    Token public trustedToken;\r\n    Vault public trustedVault;\r\n    EthPriceFeedI public ethPriceFeed; \r\n\r\n    event Contribution(\r\n        address indexed contributor,\r\n        address indexed sender,\r\n        uint256 valueUnit,\r\n        uint256 valueWei,\r\n        uint256 excessWei,\r\n        uint256 weiPerUnitRate\r\n    );\r\n\r\n    event EthPriceFeedChanged(address previousEthPriceFeed, address newEthPriceFeed);\r\n\r\n    event TokensAllocated(address indexed contributor, uint256 tokenAmount);\r\n\r\n    constructor (\r\n        uint256 _totalSaleCapUnits, // Units\r\n        uint256 _minContributionUnits, // Units\r\n        uint256 _minThresholdUnits, // Units\r\n        uint256 _maxTokens,\r\n        address _whitelistAdmin,\r\n        address _wallet,\r\n        uint256 _vaultInitialDisburseWei, // Wei\r\n        uint256 _vaultDisbursementWei, // Wei\r\n        uint256 _vaultDisbursementDuration,\r\n        uint256 _startTime,\r\n        string _tokenName,\r\n        string _tokenSymbol,\r\n        uint8 _tokenDecimals, \r\n        EthPriceFeedI _ethPriceFeed\r\n    ) \r\n        Whitelistable(_whitelistAdmin)\r\n        public \r\n    {\r\n        require(_totalSaleCapUnits != 0, \"Total sale cap units must be > 0\");\r\n        require(_maxTokens != 0, \"The maximum number of tokens must be > 0\");\r\n        require(_wallet != 0, \"The team's wallet address cannot be 0\");\r\n        require(_minThresholdUnits <= _totalSaleCapUnits, \"The minimum threshold (units) cannot be larger than the sale cap (units)\");\r\n        require(_ethPriceFeed != address(0), \"The ETH price feed cannot be the 0 address\");\r\n        require(now < _startTime, \"The start time must be in the future\");\r\n\r\n        totalSaleCapUnits = _totalSaleCapUnits;\r\n        minContributionUnits = _minContributionUnits;\r\n        minThresholdUnits = _minThresholdUnits;\r\n\r\n        // Setup the necessary contracts\r\n        trustedToken = new Token(\r\n            _maxTokens,\r\n            _tokenName,\r\n            _tokenSymbol,\r\n            _tokenDecimals\r\n        );\r\n\r\n        disbursementHandler = new DisbursementHandler(trustedToken);\r\n\r\n        disbursementHandler.transferOwnership(owner);\r\n\r\n        ethPriceFeed = _ethPriceFeed; \r\n\r\n        // The token will query the isTransferAllowed function contained in this contract\r\n        trustedToken.setController(this);\r\n\r\n        trustedVault = new Vault(\r\n            _wallet,\r\n            _vaultInitialDisburseWei,\r\n            _vaultDisbursementWei, // disbursement amount\r\n            _vaultDisbursementDuration\r\n        );\r\n\r\n        // Set the states\r\n        setStates(states);\r\n\r\n        // Specify which functions are allowed in each state\r\n        allowFunction(SETUP, this.setup.selector);\r\n        allowFunction(FREEZE, this.setEndTime.selector);\r\n        allowFunction(SALE_IN_PROGRESS, this.setEndTime.selector);\r\n        allowFunction(SALE_IN_PROGRESS, this.contribute.selector);\r\n        allowFunction(SALE_IN_PROGRESS, this.endSale.selector);\r\n        allowFunction(SALE_ENDED, this.allocateExtraTokens.selector);\r\n\r\n        // End the sale when the cap is reached\r\n        addStartCondition(SALE_ENDED, wasCapReached);\r\n\r\n        // Set the start time for the sale\r\n        setStateStartTime(SALE_IN_PROGRESS, _startTime);\r\n\r\n        // Set the onSaleEnded callback (will be called when the sale ends)\r\n        addCallback(SALE_ENDED, onSaleEnded);\r\n\r\n    }\r\n\r\n    /// @dev Setup the disbursements and the number of tokens for sale.\r\n    /// @dev This needs to be outside the constructor because the token needs to query the sale for allowed transfers.\r\n    function setup() external onlyOwner checkAllowed {\r\n        require(disbursementHandler.closed(), \"Disbursement handler not closed\");\r\n        trustedToken.safeTransfer(disbursementHandler, disbursementHandler.totalAmount());\r\n\r\n        tokensForSale = trustedToken.balanceOf(this);     \r\n        require(tokensForSale >= totalSaleCapUnits, \"Higher sale cap units than tokens for sale => tokens per unit would be 0\");\r\n\r\n        // Set the worst rate of tokens per unit\r\n        // If sale doesn't sell out, extra tokens will be disbursed after the sale ends.\r\n        saleTokensPerUnit = tokensForSale.div(totalSaleCapUnits);\r\n\r\n        // Go to freeze state\r\n        goToNextState();\r\n    }\r\n\r\n    /// @dev To change the EthPriceFeed contract if needed \r\n    function changeEthPriceFeed(EthPriceFeedI _ethPriceFeed) external onlyOwner {\r\n        require(_ethPriceFeed != address(0), \"ETH price feed address cannot be 0\");\r\n        emit EthPriceFeedChanged(ethPriceFeed, _ethPriceFeed);\r\n        ethPriceFeed = _ethPriceFeed;\r\n    }\r\n\r\n    /// @dev Called by users to contribute ETH to the sale.\r\n    function contribute(\r\n        address _contributor,\r\n        uint256 _contributionLimitUnits, \r\n        uint256 _payloadExpiration,\r\n        bytes _sig\r\n    ) \r\n        external \r\n        payable\r\n        checkAllowed \r\n        isWhitelisted(keccak256(\r\n            abi.encodePacked(\r\n                _contributor,\r\n                _contributionLimitUnits, \r\n                _payloadExpiration\r\n            )\r\n        ), _sig)\r\n    {\r\n        require(msg.sender == _contributor, \"Contributor address different from whitelisted address\");\r\n        require(now < _payloadExpiration, \"Payload has expired\"); \r\n\r\n        uint256 weiPerUnitRate = ethPriceFeed.getRate(); \r\n        require(weiPerUnitRate != 0, \"Wei per unit rate from feed is 0\");\r\n\r\n        uint256 previouslyContributedUnits = unitContributions[_contributor];\r\n\r\n        // Check that the contribution amount doesn't go over the sale cap or personal contributionLimitUnits \r\n        uint256 currentContributionUnits = min256(\r\n            _contributionLimitUnits.sub(previouslyContributedUnits),\r\n            totalSaleCapUnits.sub(totalContributedUnits),\r\n            msg.value.div(weiPerUnitRate)\r\n        );\r\n\r\n        require(currentContributionUnits != 0, \"No contribution permitted (contributor or sale has reached cap)\");\r\n\r\n        // Check that it is higher than minContributionUnits\r\n        require(currentContributionUnits >= minContributionUnits || previouslyContributedUnits != 0, \"Minimum contribution not reached\");\r\n\r\n        // Update the state\r\n        unitContributions[_contributor] = previouslyContributedUnits.add(currentContributionUnits);\r\n        totalContributedUnits = totalContributedUnits.add(currentContributionUnits);\r\n\r\n        uint256 currentContributionWei = currentContributionUnits.mul(weiPerUnitRate);\r\n        trustedVault.deposit.value(currentContributionWei)(msg.sender);\r\n\r\n        // If the minThresholdUnits is reached for the first time, notify the vault\r\n        if (totalContributedUnits >= minThresholdUnits &&\r\n            trustedVault.state() != Vault.State.Success) {\r\n            trustedVault.saleSuccessful();\r\n        }\r\n\r\n        // If there is an excess, return it to the sender\r\n        uint256 excessWei = msg.value.sub(currentContributionWei);\r\n        if (excessWei > 0) {\r\n            msg.sender.transfer(excessWei);\r\n        }\r\n\r\n        emit Contribution(\r\n            _contributor, \r\n            msg.sender,\r\n            currentContributionUnits, \r\n            currentContributionWei, \r\n            excessWei,\r\n            weiPerUnitRate\r\n        );\r\n\r\n        // Allocate tokens     \r\n        uint256 tokenAmount = currentContributionUnits.mul(saleTokensPerUnit);\r\n        trustedToken.safeTransfer(_contributor, tokenAmount);\r\n        emit TokensAllocated(_contributor, tokenAmount);\r\n    }\r\n\r\n    /// @dev Called to allocate the tokens depending on amount contributed by the end of the sale.\r\n    /// @param _contributor The address of the contributor.\r\n    function allocateExtraTokens(address _contributor)\r\n        external \r\n        checkAllowed\r\n    {    \r\n        require(!extraTokensAllocated[_contributor], \"Extra tokens already allocated to contributor\");\r\n        require(unitContributions[_contributor] != 0, \"Address didn't contribute to sale\");\r\n        // Allocate extra tokens only if total sale cap is not reached\r\n        require(totalContributedUnits < totalSaleCapUnits, \"The sale cap was reached, no extra tokens to allocate\");\r\n\r\n        // Transfer the respective tokens to the contributor\r\n        extraTokensAllocated[_contributor] = true;\r\n        uint256 tokenAmount = unitContributions[_contributor].mul(extraTokensPerUnit);\r\n        trustedToken.safeTransfer(_contributor, tokenAmount);\r\n\r\n        emit TokensAllocated(_contributor, tokenAmount);\r\n    }\r\n\r\n    /// @dev Sets the end time for the sale\r\n    /// @param _endTime The timestamp at which the sale will end.\r\n    function setEndTime(uint256 _endTime) external onlyOwner checkAllowed {\r\n        require(now < _endTime, \"Cannot set end time in the past\");\r\n        require(getStateStartTime(SALE_ENDED) == 0, \"End time already set\");\r\n        setStateStartTime(SALE_ENDED, _endTime);\r\n    }\r\n\r\n    /// @dev Called to enable refunds by the owner. Can only be called in any state (without triggering conditional transitions)\r\n    /// @dev This is only meant to be used if there is an emergency and the endSale() function can't be called\r\n    function enableRefunds() external onlyOwner {\r\n        trustedVault.enableRefunds();\r\n    }\r\n\r\n    /// @dev Called to end the sale by the owner. Can only be called in SALE_IN_PROGRESS state\r\n    function endSale() external onlyOwner checkAllowed {\r\n        goToNextState();\r\n    }\r\n\r\n    /// @dev Since Sale is TokenControllerI, it has to implement transferAllowed() function\r\n    /// @notice only the Sale and DisbursementHandler can disburse the initial tokens to their future owners\r\n    function transferAllowed(address _from, address)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        return _from == address(this) || _from == address(disbursementHandler);\r\n    }\r\n   \r\n    /// @dev Returns true if the cap was reached.\r\n    function wasCapReached(bytes32) internal returns (bool) {\r\n        return totalSaleCapUnits <= totalContributedUnits;\r\n    }\r\n\r\n    /// @dev Callback that gets called when entering the SALE_ENDED state.\r\n    function onSaleEnded() internal {\r\n\r\n        trustedToken.transferOwnership(owner); \r\n\r\n        if (totalContributedUnits == 0) {\r\n\r\n            // If no tokens were sold, transfer them back to the project team\r\n            trustedToken.safeTransfer(trustedVault.trustedWallet(), tokensForSale);\r\n\r\n        } else if (totalContributedUnits < minThresholdUnits) {\r\n\r\n            // If the minimum threshold wasn't reached, enable refunds\r\n            trustedVault.enableRefunds();\r\n\r\n        } else {\r\n\r\n            // Calculate the rate for the extra tokens (if the sale was sold out, it will be 0)\r\n            extraTokensPerUnit = tokensForSale.div(totalContributedUnits).sub(saleTokensPerUnit);\r\n\r\n            // Close the vault and transfer ownership to the owner of the sale\r\n            trustedVault.close();\r\n            trustedVault.transferOwnership(owner);\r\n\r\n        }\r\n    }\r\n\r\n    /// @dev a function to return the minimum of 3 values\r\n    function min256(uint256 x, uint256 y, uint256 z) internal pure returns (uint256) {\r\n        return Math.min256(x, Math.min256(y, z));\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/GamerTokenSale.sol\r\n\r\ncontract GamerTokenSale is Sale {\r\n\r\n    constructor() \r\n        Sale(\r\n            25000000, // Total sale cap (usd)\r\n            5, // Min contribution (usd)\r\n            2000000, // Min threshold (usd)\r\n            1000000000 * (10 ** 18), // Max tokens\r\n            0x38a61BDEbAa1f312d6a7765165EF2c05d4957152, // Whitelist Admin\r\n            0xEE8A84b3B964AfB5433ecd55F517c4D3F43049B5, // Wallet\r\n            10000 ether, // Vault initial Wei\r\n            90000 ether, // Vault disbursement Wei\r\n            0, // Vault disbursement duration (0 means transfer everything right away)\r\n            now + 10 minutes, // Start time\r\n            \"GamerToken\", // Token name\r\n            \"GTX\", // Token symbol\r\n            18, // Token decimals\r\n            EthPriceFeedI(0x54bF24e1070784D7F0760095932b47CE55eb3A91) // Eth price feed\r\n        )\r\n        public \r\n    {\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"states\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensForSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"transferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minContributionUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trustedVault\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"invalidHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalContributedUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stateId\",\"type\":\"bytes32\"}],\"name\":\"getStateStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSaleCapUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"invalidateHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"},{\"name\":\"_contributionLimitUnits\",\"type\":\"uint256\"},{\"name\":\"_payloadExpiration\",\"type\":\"uint256\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disbursementHandler\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minThresholdUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableRefunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"changeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethPriceFeed\",\"type\":\"address\"}],\"name\":\"changeEthPriceFeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"unitContributions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethPriceFeed\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"setEndTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"allocateExtraTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleTokensPerUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"extraTokensAllocated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"conditionalTransitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStateId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"trustedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rawHash\",\"type\":\"bytes32\"},{\"name\":\"_sig\",\"type\":\"bytes\"}],\"name\":\"checkWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraTokensPerUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_hashes\",\"type\":\"bytes32[]\"}],\"name\":\"invalidateHashes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"valueUnit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"valueWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"excessWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiPerUnitRate\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousEthPriceFeed\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newEthPriceFeed\",\"type\":\"address\"}],\"name\":\"EthPriceFeedChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"TokensAllocated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_stateId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"StateStartTimeSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stateId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"Transition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"GamerTokenSale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6aa2de656715867b8b586b35066ae0c6b0f68e41738cc56e4c891585eb197219"}]}