{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.19;\r\n\r\nlibrary OwnershipTypes{\r\n    using Serializer for Serializer.DataComponent;\r\n\r\n    struct Ownership\r\n    {\r\n        address m_Owner; // 0\r\n        uint32 m_OwnerInventoryIndex; // 20\r\n    }\r\n\r\n    function SerializeOwnership(Ownership ownership) internal pure returns (bytes32)\r\n    {\r\n        Serializer.DataComponent memory data;\r\n        data.WriteAddress(0, ownership.m_Owner);\r\n        data.WriteUint32(20, ownership.m_OwnerInventoryIndex);\r\n\r\n        return data.m_Raw;\r\n    }\r\n\r\n    function DeserializeOwnership(bytes32 raw) internal pure returns (Ownership)\r\n    {\r\n        Ownership memory ownership;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        ownership.m_Owner = data.ReadAddress(0);\r\n        ownership.m_OwnerInventoryIndex = data.ReadUint32(20);\r\n\r\n        return ownership;\r\n    }\r\n}\r\nlibrary LibStructs{\r\n    using Serializer for Serializer.DataComponent;\r\n    // HEROES\r\n\r\n    struct Hero {\r\n        uint16 stockID;\r\n        uint8 rarity;\r\n        uint16 hp;\r\n        uint16 atk;\r\n        uint16 def;\r\n        uint16 agi;\r\n        uint16 intel;\r\n        uint16 cHp;\r\n        //uint8 cenas;\r\n        // uint8 critic;\r\n        // uint8 healbonus;\r\n        // uint8 atackbonus;\r\n        // uint8 defensebonus;\r\n\r\n        uint8 isForSale;\r\n        uint8 lvl;\r\n        uint16 xp;\r\n    }\r\n    struct StockHero {uint16 price;uint8 stars;uint8 mainOnePosition;uint8 mainTwoPosition;uint16 stock;uint8 class;}\r\n\r\n    function SerializeHero(Hero hero) internal pure returns (bytes32){\r\n        Serializer.DataComponent memory data;\r\n        data.WriteUint16(0, hero.stockID);\r\n        data.WriteUint8(2, hero.rarity);\r\n        //data.WriteUint8(2, hero.m_IsForSale);\r\n        //data.WriteUint8(3, rocket.m_Unused3);\r\n        data.WriteUint16(4, hero.hp);\r\n        data.WriteUint16(6, hero.atk);\r\n        data.WriteUint16(8, hero.def);\r\n        data.WriteUint16(10, hero.agi);\r\n        data.WriteUint16(12, hero.intel);\r\n        data.WriteUint16(14, hero.cHp);\r\n\r\n        // data.WriteUint8(16, hero.class);\r\n        // data.WriteUint8(17, hero.healbonus);\r\n        // data.WriteUint8(18, hero.atackbonus);\r\n        // data.WriteUint8(19, hero.defensebonus);\r\n\r\n        data.WriteUint8(20, hero.isForSale);\r\n        data.WriteUint8(21, hero.lvl);\r\n        data.WriteUint16(23, hero.xp);\r\n\r\n        return data.m_Raw;\r\n    }\r\n    function DeserializeHero(bytes32 raw) internal pure returns (Hero){\r\n        Hero memory hero;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        hero.stockID = data.ReadUint16(0);\r\n        //hero.rarity = data.ReadUint8(1);\r\n        hero.rarity = data.ReadUint8(2);\r\n        //rocket.m_Unused3 = data.ReadUint8(3);\r\n        hero.hp = data.ReadUint16(4);\r\n        hero.atk = data.ReadUint16(6);\r\n        hero.def = data.ReadUint16(8);\r\n        hero.agi = data.ReadUint16(10);\r\n        hero.intel = data.ReadUint16(12);\r\n        hero.cHp = data.ReadUint16(14);\r\n\r\n        // hero.class = data.ReadUint8(16);\r\n        // hero.healbonus = data.ReadUint8(17);\r\n        // hero.atackbonus = data.ReadUint8(18);\r\n        // hero.defensebonus = data.ReadUint8(19);\r\n\r\n        hero.isForSale = data.ReadUint8(20);\r\n        hero.lvl = data.ReadUint8(21);\r\n        hero.xp = data.ReadUint16(23);\r\n\r\n        return hero;\r\n    }\r\n    function SerializeStockHero(StockHero stockhero) internal pure returns (bytes32){\r\n        // string name;uint64 price;uint8 stars;uint8 mainOnePosition;uint8 mainTwoPosition;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.WriteUint16(0, stockhero.price);\r\n        data.WriteUint8(2, stockhero.stars);\r\n        data.WriteUint8(3, stockhero.mainOnePosition);\r\n        data.WriteUint8(4, stockhero.mainTwoPosition);\r\n        data.WriteUint16(5, stockhero.stock);\r\n        data.WriteUint8(7, stockhero.class);\r\n\r\n\r\n        return data.m_Raw;\r\n    }\r\n    function DeserializeStockHero(bytes32 raw) internal pure returns (StockHero){\r\n        StockHero memory stockhero;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        stockhero.price = data.ReadUint16(0);\r\n        stockhero.stars = data.ReadUint8(2);\r\n        stockhero.mainOnePosition = data.ReadUint8(3);\r\n        stockhero.mainTwoPosition = data.ReadUint8(4);\r\n        stockhero.stock = data.ReadUint16(5);\r\n        stockhero.class = data.ReadUint8(7);\r\n\r\n        return stockhero;\r\n    }\r\n    // ITEMS\r\n    struct Item {\r\n        uint16 stockID;\r\n        uint8 lvl;\r\n        uint8 rarity;\r\n        uint16 hp;\r\n        uint16 atk;\r\n        uint16 def;\r\n        uint16 agi;\r\n        uint16 intel;\r\n\r\n        uint8 critic;\r\n        uint8 healbonus;\r\n        uint8 atackbonus;\r\n        uint8 defensebonus;\r\n\r\n        uint8 isForSale;\r\n        uint8 grade;\r\n    }\r\n    struct StockItem {uint16 price;uint8 stars;uint8 lvl;uint8 mainOnePosition;uint8 mainTwoPosition;uint16[5] stats;uint8[4] secstats;uint8 cat;uint8 subcat;} // 1 finney = 0.0001 ether\r\n\r\n    function SerializeItem(Item item) internal pure returns (bytes32){\r\n        Serializer.DataComponent memory data;\r\n\r\n        data.WriteUint16(0, item.stockID);\r\n        data.WriteUint8(4, item.lvl);\r\n        data.WriteUint8(5, item.rarity);\r\n        data.WriteUint16(6, item.hp);\r\n        data.WriteUint16(8, item.atk);\r\n        data.WriteUint16(10, item.def);\r\n        data.WriteUint16(12, item.agi);\r\n        data.WriteUint16(14, item.intel);\r\n        // data.WriteUint32(14, item.cHp);\r\n\r\n        data.WriteUint8(16, item.critic);\r\n        data.WriteUint8(17, item.healbonus);\r\n        data.WriteUint8(18, item.atackbonus);\r\n        data.WriteUint8(19, item.defensebonus);\r\n\r\n        data.WriteUint8(20, item.isForSale);\r\n        data.WriteUint8(21, item.grade);\r\n\r\n\r\n        return data.m_Raw;\r\n\r\n    }\r\n    function DeserializeItem(bytes32 raw) internal pure returns (Item){\r\n        Item memory item;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        item.stockID = data.ReadUint16(0);\r\n\r\n        item.lvl = data.ReadUint8(4);\r\n        item.rarity = data.ReadUint8(5);\r\n        item.hp = data.ReadUint16(6);\r\n        item.atk = data.ReadUint16(8);\r\n        item.def = data.ReadUint16(10);\r\n        item.agi = data.ReadUint16(12);\r\n        item.intel = data.ReadUint16(14);\r\n\r\n        item.critic = data.ReadUint8(16);\r\n        item.healbonus = data.ReadUint8(17);\r\n        item.atackbonus = data.ReadUint8(18);\r\n        item.defensebonus = data.ReadUint8(19);\r\n\r\n        item.isForSale = data.ReadUint8(20);\r\n        item.grade = data.ReadUint8(21);\r\n\r\n\r\n        return item;\r\n    }\r\n    function SerializeStockItem(StockItem stockitem) internal pure returns (bytes32){\r\n        // string name;uint64 price;uint8 stars;uint8 mainOnePosition;uint8 mainTwoPosition;uint8 mainThreePosition;\r\n        // uint16[] stats;uint8[] secstats;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.WriteUint16(0, stockitem.price);\r\n        data.WriteUint8(2, stockitem.stars);\r\n        data.WriteUint8(3, stockitem.lvl);\r\n        data.WriteUint8(4, stockitem.mainOnePosition);\r\n        data.WriteUint8(5, stockitem.mainTwoPosition);\r\n        //data.WriteUint8(12, stockitem.mainThreePosition);\r\n        //stats\r\n        data.WriteUint16(6, stockitem.stats[0]);\r\n        data.WriteUint16(8, stockitem.stats[1]);\r\n        data.WriteUint16(10, stockitem.stats[2]);\r\n        data.WriteUint16(12, stockitem.stats[3]);\r\n        data.WriteUint16(14, stockitem.stats[4]);\r\n        //secstats\r\n        data.WriteUint8(16, stockitem.secstats[0]);\r\n        data.WriteUint8(17, stockitem.secstats[1]);\r\n        data.WriteUint8(18, stockitem.secstats[2]);\r\n        data.WriteUint8(19, stockitem.secstats[3]);\r\n\r\n        data.WriteUint8(20, stockitem.cat);\r\n        data.WriteUint8(21, stockitem.subcat);\r\n\r\n\r\n        return data.m_Raw;\r\n    }\r\n    function DeserializeStockItem(bytes32 raw) internal pure returns (StockItem){\r\n        StockItem memory stockitem;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        stockitem.price = data.ReadUint16(0);\r\n        stockitem.stars = data.ReadUint8(2);\r\n        stockitem.lvl = data.ReadUint8(3);\r\n        stockitem.mainOnePosition = data.ReadUint8(4);\r\n        stockitem.mainTwoPosition = data.ReadUint8(5);\r\n        //stockitem.mainThreePosition = data.ReadUint8(12);\r\n\r\n        stockitem.stats[0] = data.ReadUint16(6);\r\n        stockitem.stats[1] = data.ReadUint16(8);\r\n        stockitem.stats[2] = data.ReadUint16(10);\r\n        stockitem.stats[3] = data.ReadUint16(12);\r\n        stockitem.stats[4] = data.ReadUint16(14);\r\n\r\n        stockitem.secstats[0] = data.ReadUint8(16);\r\n        stockitem.secstats[1] = data.ReadUint8(17);\r\n        stockitem.secstats[2] = data.ReadUint8(18);\r\n        stockitem.secstats[3] = data.ReadUint8(19);\r\n\r\n        stockitem.cat = data.ReadUint8(20);\r\n        stockitem.subcat = data.ReadUint8(21);\r\n\r\n        return stockitem;\r\n    }\r\n\r\n    struct Action {uint16 actionID;uint8 actionType;uint16 finneyCost;uint32 cooldown;uint8 lvl;uint8 looted;uint8 isDaily;}\r\n    function SerializeAction(Action action) internal pure returns (bytes32){\r\n        Serializer.DataComponent memory data;\r\n        data.WriteUint16(0, action.actionID);\r\n        data.WriteUint8(2, action.actionType);\r\n        data.WriteUint16(3, action.finneyCost);\r\n        data.WriteUint32(5, action.cooldown);\r\n        data.WriteUint8(9, action.lvl);\r\n        data.WriteUint8(10, action.looted);\r\n        data.WriteUint8(11, action.isDaily);\r\n\r\n        return data.m_Raw;\r\n    }\r\n    function DeserializeAction(bytes32 raw) internal pure returns (Action){\r\n        Action memory action;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        action.actionID = data.ReadUint16(0);\r\n        action.actionType = data.ReadUint8(2);\r\n        action.finneyCost = data.ReadUint16(3);\r\n        action.cooldown = data.ReadUint32(5);\r\n        action.lvl = data.ReadUint8(9);\r\n        action.looted = data.ReadUint8(10);\r\n        action.isDaily = data.ReadUint8(11);\r\n\r\n        return action;\r\n    }\r\n\r\n    struct Mission {uint8 dificulty;uint16[4] stockitemId_drops;uint16[5] statsrequired;uint16 count;}\r\n    function SerializeMission(Mission mission) internal pure returns (bytes32){\r\n        Serializer.DataComponent memory data;\r\n        data.WriteUint8(0, mission.dificulty);\r\n        data.WriteUint16(1, mission.stockitemId_drops[0]);\r\n        data.WriteUint16(5, mission.stockitemId_drops[1]);\r\n        data.WriteUint16(9, mission.stockitemId_drops[2]);\r\n        data.WriteUint16(13, mission.stockitemId_drops[3]);\r\n\r\n        data.WriteUint16(15, mission.statsrequired[0]);\r\n        data.WriteUint16(17, mission.statsrequired[1]);\r\n        data.WriteUint16(19, mission.statsrequired[2]);\r\n        data.WriteUint16(21, mission.statsrequired[3]);\r\n        data.WriteUint16(23, mission.statsrequired[4]);\r\n\r\n        data.WriteUint16(25, mission.count);\r\n\r\n        return data.m_Raw;\r\n    }\r\n    function DeserializeMission(bytes32 raw) internal pure returns (Mission){\r\n        Mission memory mission;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        mission.dificulty = data.ReadUint8(0);\r\n        mission.stockitemId_drops[0] = data.ReadUint16(1);\r\n        mission.stockitemId_drops[1] = data.ReadUint16(5);\r\n        mission.stockitemId_drops[2] = data.ReadUint16(9);\r\n        mission.stockitemId_drops[3] = data.ReadUint16(13);\r\n\r\n        mission.statsrequired[0] = data.ReadUint16(15);\r\n        mission.statsrequired[1] = data.ReadUint16(17);\r\n        mission.statsrequired[2] = data.ReadUint16(19);\r\n        mission.statsrequired[3] = data.ReadUint16(21);\r\n        mission.statsrequired[4] = data.ReadUint16(23);\r\n\r\n        mission.count = data.ReadUint16(25);\r\n\r\n        return mission;\r\n    }\r\n\r\n    function toWei(uint80 price) public returns(uint256 value){\r\n        value = price;\r\n        value = value * 1 finney;\r\n\r\n    }\r\n\r\n}\r\nlibrary GlobalTypes{\r\n    using Serializer for Serializer.DataComponent;\r\n\r\n    struct Global\r\n    {\r\n        uint32 m_LastHeroId; // 0\r\n        uint32 m_LastItem; // 4\r\n        uint8 m_Unused8; // 8\r\n        uint8 m_Unused9; // 9\r\n        uint8 m_Unused10; // 10\r\n        uint8 m_Unused11; // 11\r\n    }\r\n\r\n    function SerializeGlobal(Global global) internal pure returns (bytes32)\r\n    {\r\n        Serializer.DataComponent memory data;\r\n        data.WriteUint32(0, global.m_LastHeroId);\r\n        data.WriteUint32(4, global.m_LastItem);\r\n        data.WriteUint8(8, global.m_Unused8);\r\n        data.WriteUint8(9, global.m_Unused9);\r\n        data.WriteUint8(10, global.m_Unused10);\r\n        data.WriteUint8(11, global.m_Unused11);\r\n\r\n        return data.m_Raw;\r\n    }\r\n\r\n    function DeserializeGlobal(bytes32 raw) internal pure returns (Global)\r\n    {\r\n        Global memory global;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        global.m_LastHeroId = data.ReadUint32(0);\r\n        global.m_LastItem = data.ReadUint32(4);\r\n        global.m_Unused8 = data.ReadUint8(8);\r\n        global.m_Unused9 = data.ReadUint8(9);\r\n        global.m_Unused10 = data.ReadUint8(10);\r\n        global.m_Unused11 = data.ReadUint8(11);\r\n\r\n        return global;\r\n    }\r\n\r\n\r\n}\r\nlibrary MarketTypes{\r\n    using Serializer for Serializer.DataComponent;\r\n\r\n    struct MarketListing\r\n    {\r\n        uint128 m_Price; // 0\r\n    }\r\n\r\n    function SerializeMarketListing(MarketListing listing) internal pure returns (bytes32)\r\n    {\r\n        Serializer.DataComponent memory data;\r\n        data.WriteUint128(0, listing.m_Price);\r\n\r\n        return data.m_Raw;\r\n    }\r\n\r\n    function DeserializeMarketListing(bytes32 raw) internal pure returns (MarketListing)\r\n    {\r\n        MarketListing memory listing;\r\n\r\n        Serializer.DataComponent memory data;\r\n        data.m_Raw = raw;\r\n\r\n        listing.m_Price = data.ReadUint128(0);\r\n\r\n        return listing;\r\n    }\r\n}\r\nlibrary Serializer{\r\n    struct DataComponent\r\n    {\r\n        bytes32 m_Raw;\r\n    }\r\n\r\n    function ReadUint8(DataComponent memory self, uint32 offset) internal pure returns (uint8)\r\n    {\r\n        return uint8((self.m_Raw >> (offset * 8)) & 0xFF);\r\n    }\r\n\r\n    function WriteUint8(DataComponent memory self, uint32 offset, uint8 value) internal pure\r\n    {\r\n        self.m_Raw |= (bytes32(value) << (offset * 8));\r\n    }\r\n\r\n    function ReadUint16(DataComponent memory self, uint32 offset) internal pure returns (uint16)\r\n    {\r\n        return uint16((self.m_Raw >> (offset * 8)) & 0xFFFF);\r\n    }\r\n\r\n    function WriteUint16(DataComponent memory self, uint32 offset, uint16 value) internal pure\r\n    {\r\n        self.m_Raw |= (bytes32(value) << (offset * 8));\r\n    }\r\n\r\n    function ReadUint32(DataComponent memory self, uint32 offset) internal pure returns (uint32)\r\n    {\r\n        return uint32((self.m_Raw >> (offset * 8)) & 0xFFFFFFFF);\r\n    }\r\n\r\n    function WriteUint32(DataComponent memory self, uint32 offset, uint32 value) internal pure\r\n    {\r\n        self.m_Raw |= (bytes32(value) << (offset * 8));\r\n    }\r\n\r\n    function ReadUint64(DataComponent memory self, uint32 offset) internal pure returns (uint64)\r\n    {\r\n        return uint64((self.m_Raw >> (offset * 8)) & 0xFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function WriteUint64(DataComponent memory self, uint32 offset, uint64 value) internal pure\r\n    {\r\n        self.m_Raw |= (bytes32(value) << (offset * 8));\r\n    }\r\n\r\n    function ReadUint80(DataComponent memory self, uint32 offset) internal pure returns (uint80)\r\n    {\r\n        return uint80((self.m_Raw >> (offset * 8)) & 0xFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function WriteUint80(DataComponent memory self, uint32 offset, uint80 value) internal pure\r\n    {\r\n        self.m_Raw |= (bytes32(value) << (offset * 8));\r\n    }\r\n\r\n    function ReadUint128(DataComponent memory self, uint128 offset) internal pure returns (uint128)\r\n    {\r\n        return uint128((self.m_Raw >> (offset * 8)) & 0xFFFFFFFFFFFFFFFFFFFF);\r\n    }\r\n\r\n    function WriteUint128(DataComponent memory self, uint32 offset, uint128 value) internal pure\r\n    {\r\n        self.m_Raw |= (bytes32(value) << (offset * 8));\r\n    }\r\n\r\n    function ReadAddress(DataComponent memory self, uint32 offset) internal pure returns (address)\r\n    {\r\n        return address((self.m_Raw >> (offset * 8)) & (\r\n        (0xFFFFFFFF << 0)  |\r\n        (0xFFFFFFFF << 32) |\r\n        (0xFFFFFFFF << 64) |\r\n        (0xFFFFFFFF << 96) |\r\n        (0xFFFFFFFF << 128)\r\n        ));\r\n    }\r\n\r\n    function WriteAddress(DataComponent memory self, uint32 offset, address value) internal pure\r\n    {\r\n        self.m_Raw |= (bytes32(value) << (offset * 8));\r\n    }\r\n}\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\nlibrary SafeMath32 {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint32 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint32 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\nlibrary SafeMath16 {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint16 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint16 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        uint16 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\nlibrary SafeMath8 {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint8 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint8 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract HeroHelperBuy\r\n{\r\n    address public m_Owner;\r\n    address public partner1;\r\n    uint8 public percent1;\r\n    address public partner2;\r\n    uint8 public percent2;\r\n\r\n    bool public m_Paused;\r\n    AbstractDatabase m_Database= AbstractDatabase(0x400d188e1c21d592820df1f2f8cf33b3a13a377e);\r\n    BitGuildToken public tokenContract = BitGuildToken(0x7E43581b19ab509BCF9397a2eFd1ab10233f27dE); // Predefined PLAT token address\r\n    address public bitGuildAddress = 0x89a196a34B7820bC985B98096ED5EFc7c4DC8363;\r\n    mapping(address => bool)  public trustedContracts;\r\n    using SafeMath for uint256;\r\n    using SafeMath32 for uint32;\r\n    using SafeMath16 for uint16;\r\n    using SafeMath8 for uint8;\r\n\r\n    modifier OnlyOwner(){\r\n        require(msg.sender == m_Owner || trustedContracts[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOf(uint _hero_id) {\r\n        OwnershipTypes.Ownership memory ownership = OwnershipTypes.DeserializeOwnership(m_Database.Load(NullAddress, OwnershipHeroCategory, _hero_id));\r\n        require(ownership.m_Owner == msg.sender);\r\n        _;\r\n    }\r\n    \r\n    function ChangeAddressTrust(address contract_address,bool trust_flag) public OnlyOwner()\r\n    {\r\n        trustedContracts[contract_address] = trust_flag;\r\n    }\r\n\r\n    address constant NullAddress = 0;\r\n\r\n    uint256 constant GlobalCategory = 0;\r\n\r\n    //Hero\r\n    uint256 constant HeroCategory = 1;\r\n    uint256 constant HeroStockCategory = 2;\r\n    uint256 constant InventoryHeroCategory = 3;\r\n\r\n    uint256 constant OwnershipHeroCategory = 10;\r\n    uint256 constant OwnershipItemCategory = 11;\r\n    uint256 constant OwnershipAbilitiesCategory = 12;\r\n\r\n    //Market\r\n    uint256 constant ProfitFundsCategory = 14;\r\n    uint256 constant WithdrawalFundsCategory = 15;\r\n    uint256 constant HeroMarketCategory = 16;\r\n\r\n    //Action\r\n    uint256 constant ActionCategory = 20;\r\n    uint256 constant MissionCategory = 17;\r\n    uint256 constant ActionHeroCategory = 18;\r\n\r\n    //ReferalCategory\r\n    uint256 constant ReferalCategory = 237;\r\n\r\n    using Serializer for Serializer.DataComponent;\r\n\r\n    function ChangeOwner(address new_owner) public OnlyOwner(){\r\n        m_Owner = new_owner;\r\n    }\r\n\r\n    function ChangePartners(address _partner1,uint8 _percent1,address _partner2,uint8 _percent2) public OnlyOwner(){\r\n        partner1 = _partner1;\r\n        percent1 = _percent1;\r\n        partner2 = _partner2;\r\n        percent2 = _percent2;\r\n    }\r\n    function ChangeDatabase(address db) public OnlyOwner(){\r\n        m_Database = AbstractDatabase(db);\r\n    }\r\n    // function ChangeHeroHelperOraclize(address new_heroOraclize) public OnlyOwner(){\r\n    //     m_HeroHelperOraclize = AbstractHeroHelperOraclize(new_heroOraclize);\r\n    // }\r\n    function HeroHelperBuy() public{\r\n        m_Owner = msg.sender;\r\n        m_Paused = true;\r\n    }\r\n\r\n    \r\n    function GetHeroStock(uint16 stockhero_id)  private view returns (LibStructs.StockHero){\r\n        LibStructs.StockHero memory stockhero = LibStructs.DeserializeStockHero(m_Database.Load(NullAddress, HeroStockCategory, stockhero_id));\r\n        return stockhero;\r\n    }\r\n    \r\n    function GetHeroStockPrice(uint16 stockhero_id)  public view returns (uint){\r\n        LibStructs.StockHero memory stockhero = LibStructs.DeserializeStockHero(m_Database.Load(NullAddress, HeroStockCategory, stockhero_id));\r\n        return stockhero.price;\r\n    }\r\n\r\n    function GetHeroCount(address _owner) public view returns (uint32){\r\n        return uint32(m_Database.Load(_owner, HeroCategory, 0));\r\n    }\r\n    \r\n    function receiveApproval(address _sender, uint256 _value, BitGuildToken _tokenContract, bytes _extraData) public {\r\n        require(_tokenContract == tokenContract);\r\n        require(_tokenContract.transferFrom(_sender, address(m_Database), _value));\r\n        require(_extraData.length != 0);\r\n          \r\n        uint16 hero_id = uint16(_bytesToUint(_extraData));    \r\n        \r\n        BuyStockHeroP1(hero_id,_value,_sender);\r\n    }\r\n    \r\n    event BuyStockHeroEvent(address indexed buyer, uint32 stock_id, uint32 hero_id);\r\n    event showValues(uint256 _value,uint256 _price,uint256 _stock,uint256 hero_id);\r\n    function _bytesToUint(bytes _b) public pure returns(uint256) {\r\n        uint256 number;\r\n        for (uint i=0; i < _b.length; i++) {\r\n            number = number + uint(_b[i]) * (2**(8 * (_b.length - (i+1))));\r\n        }\r\n        return number;\r\n    }\r\n    function BuyStockHeroP1(uint16 stock_id,uint256 _value,address _sender) public {\r\n        \r\n        LibStructs.StockHero memory prehero = GetHeroStock(stock_id);\r\n        uint256 finneyPrice = prehero.price;\r\n        finneyPrice = finneyPrice.mul( 1000000000000000000 );\r\n        showValues(_value, finneyPrice,prehero.stock,stock_id);\r\n        \r\n        require(_value  == finneyPrice && prehero.stock > 0);\r\n        \r\n        \r\n        BuyStockHeroP2(_sender,stock_id,m_Database.getRandom(100,uint8(_sender)));\r\n        \r\n    }\r\n    function giveHeroRandomRarity(address target,uint16 stock_id,uint random) public OnlyOwner(){\r\n        BuyStockHeroP2(target,stock_id,random);\r\n    }\r\n    function BuyStockHeroP2(address target,uint16 stock_id,uint random) internal{\r\n        \r\n        uint256 inventory_count;\r\n        LibStructs.StockHero memory prehero = GetHeroStock(stock_id);\r\n        LibStructs.Hero memory hero = buyHero(prehero,stock_id,random);\r\n        GlobalTypes.Global memory global = GlobalTypes.DeserializeGlobal(m_Database.Load(NullAddress, GlobalCategory, 0));\r\n\r\n        uint256 finneyPrice = prehero.price*1000000000000000000;\r\n        prehero.stock = prehero.stock.sub(1);\r\n\r\n        global.m_LastHeroId = global.m_LastHeroId.add(1);\r\n        uint32 next_hero_id = global.m_LastHeroId;\r\n        inventory_count = GetInventoryHeroCount(target);\r\n\r\n        inventory_count = inventory_count.add(1);\r\n\r\n\r\n        OwnershipTypes.Ownership memory ownership;\r\n        ownership.m_Owner = target;\r\n        ownership.m_OwnerInventoryIndex = uint32(inventory_count.sub(1));\r\n\r\n        m_Database.Store(target, InventoryHeroCategory, inventory_count, bytes32(next_hero_id)); // coloca na posiçao nova o heroi\r\n        m_Database.Store(target, InventoryHeroCategory, 0, bytes32(inventory_count)); // coloco na posiçao zero o count do mapping :) admira te\r\n\r\n        m_Database.Store(NullAddress, HeroStockCategory, stock_id, LibStructs.SerializeStockHero(prehero));\r\n        m_Database.Store(NullAddress, HeroCategory, next_hero_id, LibStructs.SerializeHero(hero));\r\n        m_Database.Store(NullAddress, OwnershipHeroCategory, next_hero_id, OwnershipTypes.SerializeOwnership(ownership));\r\n        m_Database.Store(NullAddress, GlobalCategory, 0, GlobalTypes.SerializeGlobal(global));\r\n       \r\n        divProfit(finneyPrice);\r\n\r\n        BuyStockHeroEvent(target, stock_id, next_hero_id);\r\n\r\n        \r\n    }\r\n    \r\n    function divProfit(uint _value) internal{\r\n     \r\n         uint256 profit_funds = uint256(m_Database.Load(bitGuildAddress, WithdrawalFundsCategory, 0));\r\n         profit_funds = profit_funds.add(_value.div(10).mul(3));//30%\r\n         m_Database.Store(bitGuildAddress, WithdrawalFundsCategory, 0, bytes32(profit_funds));\r\n    \r\n         profit_funds = uint256(m_Database.Load(NullAddress, ProfitFundsCategory, 0));\r\n         profit_funds = profit_funds.add(_value.div(10).mul(7));//70%\r\n         m_Database.Store(NullAddress, ProfitFundsCategory, 0, bytes32(profit_funds));\r\n     \r\n    }\r\n\r\n    function GetInventoryHeroCount(address target) view public returns (uint256){\r\n        require(target != address(0));\r\n\r\n        uint256 inventory_count = uint256(m_Database.Load(target, InventoryHeroCategory, 0));\r\n\r\n        return inventory_count;\r\n    }\r\n    \r\n    function buyHero(LibStructs.StockHero prehero,uint16 stock_id,uint random) internal returns(LibStructs.Hero hero){\r\n        \r\n        uint8 rarity = 1;\r\n        if(random == 99){ // comum\r\n            rarity = 5;\r\n        }else if( random >= 54 && random <= 79  ){ // incomun\r\n            rarity = 2;\r\n        }else if(random >= 80 && random <= 92){ // raro\r\n            rarity = 3;\r\n        }else if(random >= 93 && random <= 98){ // epico\r\n            rarity = 4;\r\n        }else{\r\n            rarity = 1;\r\n        }\r\n        \r\n        uint16[5] memory mainStats = generateHeroStats(prehero,rarity);\r\n        hero = assembleHero(mainStats,rarity,stock_id);\r\n        return hero;\r\n\r\n    }\r\n    \r\n    function assembleHero(uint16[5] _mainStats,uint8 _rarity,uint16 stock_id) private pure returns(LibStructs.Hero){\r\n        uint16 stockID = stock_id;\r\n        uint8 rarity= _rarity;\r\n        uint16 hp= _mainStats[0]; // Max Hp\r\n        uint16 atk= _mainStats[1];\r\n        uint16 def= _mainStats[2];\r\n        uint16 agi= _mainStats[3];\r\n        uint16 intel= _mainStats[4];\r\n        uint16 cHp= _mainStats[0]; // Current Hp\r\n        //others\r\n        uint8 critic= 0;\r\n        uint8 healbonus= 0;\r\n        uint8 atackbonus= 0;\r\n        uint8 defensebonus= 0;\r\n\r\n        return LibStructs.Hero(stockID,rarity,hp,atk,def,agi,intel,cHp,0,1,0);\r\n    }\r\n\r\n    function generateHeroStats(LibStructs.StockHero prehero, uint8 rarity) private view returns(uint16[5] ){\r\n\r\n        uint32  goodPoints = 0;\r\n        uint32  normalPoints = 0;\r\n        uint8 i = 0;\r\n        uint16[5] memory arrayStartingStat;\r\n        i = i.add(1);\r\n        //uint8 rarity = getRarity(i);\r\n        uint32 points = prehero.stars.add(2).add(rarity);\r\n\r\n        uint8[2] memory mainStats = [prehero.mainOnePosition,prehero.mainTwoPosition];//[prehero.hpMain,prehero.atkMain,prehero.defMain,prehero.agiMain,prehero.intelMain]; //prehero.mainStats;// warrior [true,true,false,false,false];\r\n\r\n        goodPoints = points;\r\n        normalPoints = 8;\r\n        arrayStartingStat = spreadStats(mainStats,goodPoints,normalPoints,i);\r\n\r\n        return arrayStartingStat;\r\n\r\n    }\r\n   \r\n\r\n    function spreadStats(uint8[2] mainStats,uint32 mainPoints,uint32 restPoints,uint index) private view returns(uint16[5]){\r\n        uint32 i = 0;\r\n        uint16[5] memory arr = [uint16(1),uint16(1),uint16(1),uint16(1),uint16(1)]; // 5\r\n        bytes32 blockx = block.blockhash(block.number.sub(1));\r\n        uint256 _seed = uint256(sha3(blockx, m_Database.getRandom(100,uint8(i))));\r\n\r\n        while(i < mainPoints){ // goodppoints 4\r\n\r\n            uint8 position = uint8(( _seed / (10 ** index)) %10);\r\n            if(position < 5){\r\n                position = 0;\r\n            }\r\n            else{\r\n                position = 1;\r\n            }\r\n\r\n            arr[mainStats[position]] = arr[mainStats[position]].add(1);\r\n            i = i.add(1);\r\n            index = index.add(1);\r\n\r\n        }\r\n        i=0;\r\n        while(i < restPoints){ // outros  8\r\n\r\n            uint8 positionz = uint8(( _seed / (10 ** index)) %5);\r\n            arr[positionz] = arr[positionz].add(1);\r\n            i = i.add(1);\r\n            index = index.add(1);\r\n\r\n        }\r\n\r\n        return arr;\r\n    }\r\n\r\n}\r\n\r\ncontract BitGuildToken{\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success);\r\n}\r\n\r\ncontract AbstractDatabase\r\n{\r\n    function() public payable;\r\n    function ChangeOwner(address new_owner) public;\r\n    function ChangeOwner2(address new_owner) public;\r\n    function Store(address user, uint256 category, uint256 slot, bytes32 data) public;\r\n    function Load(address user, uint256 category, uint256 index) public view returns (bytes32);\r\n    function TransferFunds(address target, uint256 transfer_amount) public;\r\n    function getRandom(uint256 upper, uint8 seed) public returns (uint256 number);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"GetHeroCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"GetInventoryHeroCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"percent1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"stock_id\",\"type\":\"uint16\"},{\"name\":\"random\",\"type\":\"uint256\"}],\"name\":\"giveHeroRandomRarity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partner2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_b\",\"type\":\"bytes\"}],\"name\":\"_bytesToUint\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_tokenContract\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stock_id\",\"type\":\"uint16\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"BuyStockHeroP1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_partner1\",\"type\":\"address\"},{\"name\":\"_percent1\",\"type\":\"uint8\"},{\"name\":\"_partner2\",\"type\":\"address\"},{\"name\":\"_percent2\",\"type\":\"uint8\"}],\"name\":\"ChangePartners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partner1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_Paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"stockhero_id\",\"type\":\"uint16\"}],\"name\":\"GetHeroStockPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bitGuildAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"m_Owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contract_address\",\"type\":\"address\"},{\"name\":\"trust_flag\",\"type\":\"bool\"}],\"name\":\"ChangeAddressTrust\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"trustedContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"db\",\"type\":\"address\"}],\"name\":\"ChangeDatabase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_owner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stock_id\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"hero_id\",\"type\":\"uint32\"}],\"name\":\"BuyStockHeroEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_stock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hero_id\",\"type\":\"uint256\"}],\"name\":\"showValues\",\"type\":\"event\"}]","ContractName":"HeroHelperBuy","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://eac3860f516bb33ef4f44b060696004ad42a91daee228bd7a24c1aaa78d0dc34"}]}