{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/**\r\n* ETH CRYPTOCURRENCY DISTRIBUTION PROJECT\r\n* \r\n* Web              - https://333eth.io\r\n* \r\n* Twitter          - https://twitter.com/333eth_io\r\n* \r\n* Telegram_channel - https://t.me/Ethereum333\r\n* \r\n* EN  Telegram_chat: https://t.me/Ethereum333_chat_en\r\n* \r\n* RU  Telegram_chat: https://t.me/Ethereum333_chat_ru\r\n* \r\n* KOR Telegram_chat: https://t.me/Ethereum333_chat_kor\r\n* \r\n* Email:             mailto:support(at sign)333eth.io\r\n* \r\n* \r\n* \r\n* When the timer reaches zero then latest bettor takes the bank. Each bet restart a timer again.\r\n* \r\n* Bet in 1 ETH - the timer turns on for 3 minutes 33 seconds.\r\n* \r\n* Bet 0.1ETH - the timer turns on for 6 minutes 33 seconds.\r\n* \r\n* Bet 0.01 ETH - the timer turns on for 9 minutes 33 seconds.\r\n* You need to send such bet`s amounts. If more was sent, then contract will return the difference to the wallet. For example, sending 0.99 ETH system will perceive as a contribution to 0.1 ETH and difference 0.89\r\n* \r\n* The game does not have a fraudulent Ponzi scheme. No fraudulent referral programs.\r\n* \r\n* In the contract of the game realized the refusal of ownership. It is impossible to stop the flow of bets. Bet from smart contracts is prohibited.\r\n* \r\n* Eth distribution:\r\n* 50% paid to the winner.\r\n* 40% is transferred to the next level of the game with the same rules and so on.\r\n* 10% commission (7.5% of them to shareholders, 2.5% of the administration).\r\n* \r\n* RECOMMENDED GAS LIMIT: 100000\r\n* \r\n* RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n*/\r\n\r\n\r\nlibrary Zero {\r\n  function requireNotZero(address addr) internal pure {\r\n    require(addr != address(0), \"require not zero address\");\r\n  }\r\n\r\n  function requireNotZero(uint val) internal pure {\r\n    require(val != 0, \"require not zero value\");\r\n  }\r\n\r\n  function notZero(address addr) internal pure returns(bool) {\r\n    return !(addr == address(0));\r\n  }\r\n\r\n  function isZero(address addr) internal pure returns(bool) {\r\n    return addr == address(0);\r\n  }\r\n\r\n  function isZero(uint a) internal pure returns(bool) {\r\n    return a == 0;\r\n  }\r\n\r\n  function notZero(uint a) internal pure returns(bool) {\r\n    return a != 0;\r\n  }\r\n}\r\n\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  \r\n  // storage\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function div(percent storage p, uint a) internal view returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function sub(percent storage p, uint a) internal view returns (uint) {\r\n    uint b = mul(p, a);\r\n    if (b >= a) {\r\n      return 0;\r\n    }\r\n    return a - b;\r\n  }\r\n\r\n  function add(percent storage p, uint a) internal view returns (uint) {\r\n    return a + mul(p, a);\r\n  }\r\n\r\n  function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n    return Percent.percent(p.num, p.den);\r\n  }\r\n\r\n  // memory \r\n  function mmul(percent memory p, uint a) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n  function mdiv(percent memory p, uint a) internal pure returns (uint) {\r\n    return a/p.num*p.den;\r\n  }\r\n\r\n  function msub(percent memory p, uint a) internal pure returns (uint) {\r\n    uint b = mmul(p, a);\r\n    if (b >= a) {\r\n      return 0;\r\n    }\r\n    return a - b;\r\n  }\r\n\r\n  function madd(percent memory p, uint a) internal pure returns (uint) {\r\n    return a + mmul(p, a);\r\n  }\r\n}\r\n\r\nlibrary Address {\r\n  function toAddress(bytes source) internal pure returns(address addr) {\r\n    // solium-disable security/no-inline-assembly\r\n    assembly { addr := mload(add(source,0x14)) }\r\n    return addr;\r\n  }\r\n\r\n  function isNotContract(address addr) internal view returns(bool) {\r\n    // solium-disable security/no-inline-assembly\r\n    uint length;\r\n    assembly { length := extcodesize(addr) }\r\n    return length == 0;\r\n  }\r\n}\r\n\r\n\r\ncontract Accessibility {\r\n  address private owner;\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner, \"access denied\");\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function disown() internal {\r\n    delete owner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n\r\nlibrary Timer {\r\n  using SafeMath for uint;\r\n  struct timer {\r\n    uint duration;\r\n    uint startup;\r\n  }\r\n  function start(timer storage t, uint duration) internal {\r\n    t.startup = now;\r\n    t.duration = duration;\r\n  }\r\n\r\n  function timeLeft(timer storage t) internal view returns (uint) {\r\n    if (now >= t.startup.add(t.duration)) {\r\n      return 0;\r\n    }\r\n    return (t.startup+t.duration).sub(now);\r\n  }\r\n}\r\n\r\n\r\nlibrary Bet {\r\n  struct bet {\r\n    address bettor;\r\n    uint amount;\r\n    uint excess;\r\n    uint duration;\r\n  }\r\n\r\n  function New(address bettor, uint value) internal pure returns(bet memory b ) {\r\n    \r\n    (uint[3] memory vals, uint[3] memory durs) = bets();\r\n    if (value >= vals[0]) {\r\n      b.amount = vals[0];\r\n      b.duration = durs[0];\r\n    } else if (vals[1] <= value && value < vals[0]) {\r\n      b.amount = vals[1];\r\n      b.duration = durs[1];\r\n    } else if (vals[2] <= value && value < vals[1]) {\r\n      b.amount = vals[2];\r\n      b.duration = durs[2];\r\n    } else {\r\n      return b;\r\n    }\r\n\r\n    b.bettor = bettor;\r\n    b.excess = value - b.amount;\r\n  }\r\n\r\n  function bets() internal pure returns(uint[3] memory vals, uint[3] memory durs) {\r\n    (vals[0], vals[1], vals[2]) = (1 ether, 0.1 ether, 0.01 ether); \r\n    (durs[0], durs[1], durs[2]) = (3 minutes + 33 seconds, 6 minutes + 33 seconds, 9 minutes + 33 seconds);\r\n  }\r\n\r\n  function transferExcess(bet memory b) internal {\r\n    b.bettor.transfer(b.excess);\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract LastHero is Accessibility {\r\n  using Percent for Percent.percent;\r\n  using Timer for Timer.timer;\r\n  using Address for address;\r\n  using Bet for Bet.bet;\r\n  using Zero for *;\r\n  \r\n  Percent.percent private m_bankPercent = Percent.percent(50,100);\r\n  Percent.percent private m_nextLevelPercent = Percent.percent(40,100);\r\n  Percent.percent private m_adminsPercent = Percent.percent(10,100);\r\n  \r\n  uint public nextLevelBankAmount;\r\n  uint public bankAmount;\r\n  uint public level;\r\n  address public bettor;\r\n  address public adminsAddress;\r\n  Timer.timer private m_timer;\r\n\r\n  modifier notFromContract() {\r\n    require(msg.sender.isNotContract(), \"only externally accounts\");\r\n    _;\r\n  }\r\n\r\n  event LogSendExcessOfEther(address indexed addr, uint excess, uint when);\r\n  event LogNewWinner(address indexed addr, uint indexed level, uint amount, uint when);\r\n  event LogNewLevel(uint indexed level, uint bankAmount, uint when);\r\n  event LogNewBet(address indexed addr, uint indexed amount, uint duration, uint indexed level, uint when);\r\n  event LogDisown(uint when);\r\n\r\n\r\n  constructor() public {\r\n    level = 1;\r\n    emit LogNewLevel(level, address(this).balance, now);\r\n    adminsAddress = msg.sender;\r\n    m_timer.duration = uint(-1);\r\n  }\r\n\r\n  function() public payable {\r\n    doBet();\r\n  }\r\n\r\n  function doDisown() public onlyOwner {\r\n    disown();\r\n    emit LogDisown(now);\r\n  }\r\n\r\n  function setAdminsAddress(address addr) public onlyOwner {\r\n    addr.requireNotZero();\r\n    adminsAddress = addr;\r\n  }\r\n\r\n  function bankPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_bankPercent.num, m_bankPercent.den);\r\n  }\r\n\r\n  function nextLevelPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_nextLevelPercent.num, m_nextLevelPercent.den);\r\n  }\r\n\r\n  function adminsPercent() public view returns(uint numerator, uint denominator) {\r\n    (numerator, denominator) = (m_adminsPercent.num, m_adminsPercent.den);\r\n  }\r\n\r\n  function timeLeft() public view returns(uint duration) {\r\n    duration = m_timer.timeLeft();\r\n  }\r\n\r\n  function timerInfo() public view returns(uint startup, uint duration) {\r\n    (startup, duration) = (m_timer.startup, m_timer.duration);\r\n  }\r\n\r\n  function durationForBetAmount(uint betAmount) public view returns(uint duration) {\r\n    Bet.bet memory bet = Bet.New(msg.sender, betAmount);\r\n    duration = bet.duration;\r\n  }\r\n\r\n  function availableBets() public view returns(uint[3] memory vals, uint[3] memory durs) {\r\n    (vals, durs) = Bet.bets();\r\n  }\r\n\r\n  function doBet() public payable notFromContract {\r\n\r\n    // send ether to bettor if needed\r\n    if (m_timer.timeLeft().isZero()) {\r\n      bettor.transfer(bankAmount);\r\n      emit LogNewWinner(bettor, level, bankAmount, now);\r\n\r\n      bankAmount = nextLevelBankAmount;\r\n      nextLevelBankAmount = 0;\r\n      level++;\r\n      emit LogNewLevel(level, bankAmount, now);\r\n    }\r\n\r\n    Bet.bet memory bet = Bet.New(msg.sender, msg.value);\r\n    bet.amount.requireNotZero();\r\n\r\n    // send bet`s excess of ether if needed\r\n    if (bet.excess.notZero()) {\r\n      bet.transferExcess();\r\n      emit LogSendExcessOfEther(bet.bettor, bet.excess, now);\r\n    }\r\n\r\n    // commision\r\n    nextLevelBankAmount += m_nextLevelPercent.mul(bet.amount);\r\n    bankAmount += m_bankPercent.mul(bet.amount);\r\n    adminsAddress.send(m_adminsPercent.mul(bet.amount));\r\n  \r\n    m_timer.start(bet.duration);\r\n    bettor = bet.bettor;\r\n\r\n    emit LogNewBet(bet.bettor, bet.amount, bet.duration, level, now);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"bankPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLeft\",\"outputs\":[{\"name\":\"duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timerInfo\",\"outputs\":[{\"name\":\"startup\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableBets\",\"outputs\":[{\"name\":\"vals\",\"type\":\"uint256[3]\"},{\"name\":\"durs\",\"type\":\"uint256[3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"level\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextLevelPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextLevelBankAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsPercent\",\"outputs\":[{\"name\":\"numerator\",\"type\":\"uint256\"},{\"name\":\"denominator\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAdminsAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bettor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"betAmount\",\"type\":\"uint256\"}],\"name\":\"durationForBetAmount\",\"outputs\":[{\"name\":\"duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doDisown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"excess\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogSendExcessOfEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bankAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewLevel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"level\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogDisown\",\"type\":\"event\"}]","ContractName":"LastHero","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://412745eecfbc5fac5341bfff00826f6ef041063035f2f49d4587f55e52600c63"}]}