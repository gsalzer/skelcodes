{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\ncontract TokenContinuousDistribution is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for ERC20Basic;\r\n\r\n    event Released(ERC20Basic token, uint256 amount);\r\n\r\n    // beneficiary of tokens after they are released\r\n    address public beneficiary;\r\n\r\n    uint256 public cliff;\r\n    uint256 public start;\r\n    uint256 public endTime;\r\n    // 1 day = 86400 seconds\r\n    uint256 public secondsIn1Unit = 86400;\r\n    // 365 days * 5 = 1825 time units\r\n    uint256 public numberOfUnits = 1825;\r\n    // 86400 * 1825\r\n    uint256 public duration = 157680000;\r\n\r\n    //1st interval gets 5/15*total balance allowed, 2nd gets 4/15*TBA, 3rd gets 3*TBA, 4th gets 2*TBA, 5th gets 1*TBA\r\n    uint256 numberOfPhases = 5;\r\n    // 15=5+4+3+2+1\r\n    uint256 slice = 15;\r\n\r\n    mapping(address => uint256) public released;\r\n\r\n    /**\r\n     * @dev Creates a continuous distribution contract that distributes its balance of any ERC20 token to the\r\n     * _beneficiary, gradually in a linear fashion until _start + _duration,\r\n     * where _duration is the result of secondsIn1Unit*numberOfUnits\r\n     * By then all of the balance will have distributed.\r\n     * @param _beneficiary address of the beneficiary to whom distributed tokens are transferred\r\n     * @param _start the time (as Unix time) at which point continuous distribution starts\r\n     * @param _cliff duration in seconds of the cliff in which tokens will begin to continuous-distribute\r\n     */\r\n    constructor(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff\r\n    )\r\n    public\r\n    {\r\n        require(_beneficiary != address(0), \"Beneficiary address should NOT be null.\");\r\n        require(_cliff <= duration, \"Cliff should be less than or equal to duration (i.e. secondsIn1Unit.mul(numberOfUnits)).\");\r\n        require((numberOfUnits % 5) == 0, \"numberOfUnits should be a multiple of 5\");\r\n\r\n\r\n        beneficiary = _beneficiary;\r\n        cliff = _start.add(_cliff);\r\n        start = _start;\r\n        endTime = _start.add(duration);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers distributed tokens to beneficiary.\r\n     * @param token ERC20 token which is being distributed\r\n     */\r\n    function release(ERC20Basic token) public {\r\n        uint256 unreleased = releasableAmount(token);\r\n\r\n        require(unreleased > 0, \"Unreleased amount should be larger than 0.\");\r\n\r\n        released[token] = released[token].add(unreleased);\r\n\r\n        token.safeTransfer(beneficiary, unreleased);\r\n\r\n        emit Released(token, unreleased);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already distributed but hasn't been released yet.\r\n     * @param token ERC20 token which is being distributed\r\n     */\r\n    function releasableAmount(ERC20Basic token) public view returns (uint256) {\r\n        return distributedAmount(token).sub(released[token]);\r\n    }\r\n\r\n    /**\r\n     * @dev Calculates the amount that has already distributed.\r\n     * @param token ERC20 token which is being distributed\r\n     */\r\n    function distributedAmount(ERC20Basic token) public view returns (uint256) {\r\n        uint256 blockTimestamp = block.timestamp;\r\n        return distributedAmountWithBlockTimestamp(token, blockTimestamp);\r\n    }\r\n\r\n\r\n    function distributedAmountWithBlockTimestamp(ERC20Basic token, uint256 blockTimestamp) public view returns (uint256) {\r\n        uint256 currentBalance = token.balanceOf(this);\r\n        uint256 totalBalance = currentBalance.add(released[token]);\r\n\r\n        if (blockTimestamp < cliff) {\r\n            return 0;\r\n        } else if (blockTimestamp >= endTime) {\r\n            return totalBalance;\r\n        } else {\r\n            uint256 unitsPassed = blockTimestamp.sub(start).div(secondsIn1Unit); // number of time unit passed, remember unit is usually 'day'\r\n            uint256 unitsIn1Phase = numberOfUnits.div(numberOfPhases); // remember unit is usually 'day'\r\n            uint256 unitsInThisPhase;\r\n            uint256 weight;\r\n\r\n            if (unitsPassed < unitsIn1Phase) {\r\n                weight = 5;\r\n                unitsInThisPhase = unitsPassed;\r\n                // delay division to last step to keep precision\r\n                return unitsInThisPhase.mul(totalBalance).mul(weight).div(slice).div(unitsIn1Phase);\r\n            } else if (unitsPassed < unitsIn1Phase.mul(2)) {\r\n                weight = 4;\r\n                unitsInThisPhase = unitsPassed.sub(unitsIn1Phase);\r\n                // \"5\" because we have everything in the previous phase \r\n                // and note div(slice) is moved to the end, (x+y).div(slice) => x.div(slice).add(y.div(slice))\r\n                return totalBalance.mul(5).add(unitsInThisPhase.mul(totalBalance).mul(weight).div(unitsIn1Phase)).div(slice);\r\n            } else if (unitsPassed < unitsIn1Phase.mul(3)) {\r\n                weight = 3;\r\n                unitsInThisPhase = unitsPassed.sub(unitsIn1Phase.mul(2));\r\n                // \"9\" because we have everything in the previous phase = 5+4\r\n                // and note div(slice) is moved to the end, (x+y).div(slice) => x.div(slice).add(y.div(slice))\r\n                return totalBalance.mul(9).add(unitsInThisPhase.mul(totalBalance).mul(weight).div(unitsIn1Phase)).div(slice);\r\n            } else if (unitsPassed < unitsIn1Phase.mul(4)) {\r\n                weight = 2;\r\n                unitsInThisPhase = unitsPassed.sub(unitsIn1Phase.mul(3));\r\n                // \"12\" because we have everything in the previous phase = 5+4+3\r\n                // and note div(slice) is moved to the end, (x+y).div(slice) => x.div(slice).add(y.div(slice))\r\n                return totalBalance.mul(12).add(unitsInThisPhase.mul(totalBalance).mul(weight).div(unitsIn1Phase)).div(slice);\r\n            } else if (unitsPassed < unitsIn1Phase.mul(5)) {\r\n                weight = 1;\r\n                unitsInThisPhase = unitsPassed.sub(unitsIn1Phase.mul(4));\r\n                // \"14\" because we have everything in the previous phase = 5+4+3+2\r\n                // and note div(slice) is moved to the end, (x+y).div(slice) => x.div(slice).add(y.div(slice))\r\n                return totalBalance.mul(14).add(unitsInThisPhase.mul(totalBalance).mul(weight).div(unitsIn1Phase)).div(slice);\r\n            }\r\n            require(blockTimestamp < endTime, \"Block timestamp is expected to have not reached distribution endTime if the code even falls in here.\");\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"distributedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"duration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cliff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"releasableAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfUnits\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"blockTimestamp\",\"type\":\"uint256\"}],\"name\":\"distributedAmountWithBlockTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondsIn1Unit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenContinuousDistribution","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000020a0bee429d6907e556205ef9d48ab6fe6a55531000000000000000000000000000000000000000000000000000000005bebd600000000000000000000000000000000000000000000000000000000000000003c","Library":"","SwarmSource":"bzzr://31968b0814de964028a5d4ea5732f16afc3fec2114258ab7143c0094695ae09b"}]}