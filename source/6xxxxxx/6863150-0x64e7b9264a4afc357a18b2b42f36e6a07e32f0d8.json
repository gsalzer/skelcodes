{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n// File: contracts/MoonRaffleContract.sol\r\n\r\ncontract MoonRaffleContract {\r\n\r\n    address mainContractAddress;\r\n    address addressOne;\r\n    address burnAddress = 0x0;\r\n    bytes32[4] initialSecretHashArray;\r\n\r\n    uint256 seedAmount;\r\n    uint256 depositAmount;\r\n\r\n    struct MoonRaffleParams {\r\n\r\n        // ECONOMIC PARAMETERS\r\n        uint256 pricePerTicket;\r\n        uint256 maxTicketsPerTransaction;\r\n        uint256 prizePoolPercentage;\r\n        uint256 firstPrizePercentage;\r\n        uint256 secondPrizePercentage;\r\n        uint256 thirdPrizePercentage;\r\n        uint256 contractFeePercentage;\r\n        uint256 rolloverPercentage;\r\n        uint256 referralPercentage;\r\n        uint256 referralHurdle;\r\n        uint256 referralFloorTimePercentage;\r\n\r\n        // TIME PARAMETERS\r\n        uint256 moonRaffleLiveSecs;\r\n        uint256 winnerCalcSecs;\r\n        uint256 claimSecs;\r\n\r\n    }\r\n\r\n    MoonRaffleParams moonRaffleParameters;\r\n\r\n    // TIME SETTINGS\r\n    uint256 startTime;\r\n    uint256 moonRaffleEndTime;\r\n    uint256 winnerCalcDeadlineTime;\r\n    uint256 finishClaimTime;\r\n    uint256 referralFloorTime;\r\n    uint256 waitTime = 3600;\r\n    uint256 referralMultiplierInterval = 3600;\r\n\r\n    // STATE BOOLS\r\n    bool isSeeded = false;\r\n    bool isDepositReceived = false;\r\n    bool isNonceCalced = false;\r\n    bool isWinnerCalced = false;\r\n\r\n    address currentDefaultReferrerAddress;\r\n    address currentStarReferrer;\r\n    uint256 currentStarReferrerPoints;\r\n\r\n    // ITERATION VARIABLES\r\n    bytes32 randomNumber;\r\n    bool[256] binaryNonce;\r\n    uint256 nonceCalcTime = 0;\r\n    uint256 fee = 0;\r\n    uint256 rollover = 0;\r\n    uint256 ticketCounter = 0;\r\n    uint256 playerCounter = 0;\r\n    uint256 referralPointsCounter = 0;\r\n\r\n    mapping(address => uint256) entries;\r\n    mapping(address => uint256) referralPoints;\r\n    mapping(uint256 => address) tickets;\r\n    mapping(address => uint256) winnerClaims;\r\n\r\n    // FINAL STATE VARIABLES\r\n    address firstPrizeAddressFinal;\r\n    address secondPrizeAddressFinal;\r\n    address thirdPrizeAddressFinal;\r\n\r\n    uint256 firstPrizeAmountFinal;\r\n    uint256 secondPrizeAmountFinal;\r\n    uint256 thirdPrizeAmountFinal;\r\n    uint256 feeAmountFinal;\r\n    uint256 rolloverAmountFinal;\r\n    uint256 referralBonusAmountFinal;\r\n    uint256 totalTicketsFinal;\r\n    uint256 totalPlayersFinal;\r\n    uint256 seedAmountFinal;\r\n    uint256 depositAmountFinal;\r\n    uint256 referralPointsFinal;\r\n\r\n    // EVENTS\r\n    event logFallbackDonationTransaction(address _sender, uint256 _amount);\r\n    event logContractSeeded(uint256 _seedAmount);\r\n    event logContractDepositReceived(uint256 _depositAmount);\r\n    event logContractActive(uint256 _startTime, uint256 _moonRaffleEndTime, uint256 _referralFloorTime, uint256 _winnerCalcDeadlineTime, uint256 _finishClaimTime);\r\n    event logTicketPurchase(address _player, uint256 _numberOfTickets, bool _referrerValidity);\r\n    event logPrizeClaimed(address _winner, uint256 _prizeAmount);\r\n    event logReferralBonusClaimed(address _referrer, uint256 _bonusAmount);\r\n    event logDepositBurn(uint256 _depositAmount);\r\n    event logRefundClaimed(address _player, uint256 _refundAmount);\r\n    event logSecretsRevealed(string _initialSecret1, string _initialSecret2, string _initialSecret3, string _initialSecret4);\r\n    event logWinnersCalculated(address _first, uint256 _firstAmount, address _second, uint256 _secondAmount, address _third, uint256 _thirdAmount);\r\n\r\n\r\n\r\n    // ACCESS MODIFIERS\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAddressOne() {\r\n        require(msg.sender == addressOne);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMainContract() {\r\n        require(msg.sender == mainContractAddress);\r\n        _;\r\n    }\r\n\r\n    // TIME MODIFIERS\r\n    modifier retractContractPhase() {\r\n        require(isDepositReceived == false);\r\n        _;\r\n    }\r\n\r\n    modifier contractLive() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        _;\r\n    }\r\n\r\n    modifier entryTimeLive() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(now <= moonRaffleEndTime);\r\n        _;\r\n    }\r\n\r\n    modifier nonceWaitingPhaseLive() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(isNonceCalced == false);\r\n        require(isWinnerCalced == false);\r\n        require(now < moonRaffleEndTime + waitTime);\r\n        _;\r\n    }\r\n\r\n    modifier nonceCalculationPhaseLive() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(isNonceCalced == false);\r\n        require(isWinnerCalced == false);\r\n        require(now >= moonRaffleEndTime + waitTime);\r\n        require(now <= winnerCalcDeadlineTime);\r\n        _;\r\n    }\r\n\r\n    modifier winnerWaitingPhaseLive() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(isNonceCalced == true);\r\n        require(isWinnerCalced == false);\r\n        require(now < nonceCalcTime + waitTime);\r\n        _;\r\n    }\r\n\r\n    modifier winnerCalculationPhaseLive() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(isNonceCalced == true);\r\n        require(isWinnerCalced == false);\r\n        require(now >= nonceCalcTime + waitTime);\r\n        require(now <= winnerCalcDeadlineTime);\r\n        _;\r\n    }\r\n\r\n    modifier prizeClaimPhaseLive() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(isWinnerCalced == true);\r\n        require(now <= finishClaimTime);\r\n        _;\r\n    }\r\n\r\n    modifier moonRaffleContractCompleted() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(isWinnerCalced == true);\r\n        _;\r\n    }\r\n\r\n    modifier moonRaffleContractDead() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(isWinnerCalced == true);\r\n        require(now > finishClaimTime);\r\n        _;\r\n    }\r\n\r\n    modifier refundPhaseLive() {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == true);\r\n        require(isWinnerCalced == false);\r\n        require(now > winnerCalcDeadlineTime);\r\n        _;\r\n    }\r\n\r\n    // FALLBACK\r\n    function() public payable {\r\n        emit logFallbackDonationTransaction(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n    constructor(\r\n        address _mainContractAddress,\r\n        address _addressOne,\r\n        bytes32 _initialSecretHash1,\r\n        bytes32 _initialSecretHash2,\r\n        bytes32 _initialSecretHash3,\r\n        bytes32 _initialSecretHash4,\r\n        uint256[14] _moonRaffleParameters\r\n    )\r\n    public\r\n    payable\r\n    {\r\n        mainContractAddress = _mainContractAddress;\r\n        addressOne = _addressOne;\r\n        currentDefaultReferrerAddress = _addressOne;\r\n        currentStarReferrer = currentDefaultReferrerAddress;\r\n        currentStarReferrerPoints = 0;\r\n        initialSecretHashArray = [_initialSecretHash1, _initialSecretHash2, _initialSecretHash3, _initialSecretHash4];\r\n        moonRaffleParameters.pricePerTicket = _moonRaffleParameters[0];\r\n        moonRaffleParameters.maxTicketsPerTransaction = _moonRaffleParameters[1];\r\n        moonRaffleParameters.prizePoolPercentage = _moonRaffleParameters[2];\r\n        moonRaffleParameters.firstPrizePercentage = _moonRaffleParameters[3];\r\n        moonRaffleParameters.secondPrizePercentage = _moonRaffleParameters[4];\r\n        moonRaffleParameters.thirdPrizePercentage = _moonRaffleParameters[5];\r\n        moonRaffleParameters.contractFeePercentage = _moonRaffleParameters[6];\r\n        moonRaffleParameters.rolloverPercentage = _moonRaffleParameters[7];\r\n        moonRaffleParameters.referralPercentage = _moonRaffleParameters[8];\r\n        moonRaffleParameters.referralHurdle = _moonRaffleParameters[9];\r\n        moonRaffleParameters.referralFloorTimePercentage = _moonRaffleParameters[10];\r\n        moonRaffleParameters.moonRaffleLiveSecs = _moonRaffleParameters[11];\r\n        moonRaffleParameters.winnerCalcSecs = _moonRaffleParameters[12];\r\n        moonRaffleParameters.claimSecs = _moonRaffleParameters[13];\r\n\r\n        startTime = now;\r\n        moonRaffleEndTime = startTime + moonRaffleParameters.moonRaffleLiveSecs;\r\n        winnerCalcDeadlineTime = moonRaffleEndTime + moonRaffleParameters.winnerCalcSecs;\r\n        finishClaimTime = moonRaffleEndTime + moonRaffleParameters.claimSecs;\r\n        referralFloorTime = startTime + (moonRaffleParameters.moonRaffleLiveSecs * moonRaffleParameters.referralFloorTimePercentage / 100);\r\n\r\n        randomNumber = keccak256(abi.encodePacked(blockhash(block.number - 1)));\r\n    }\r\n\r\n\r\n\r\n    function sendContractSeed() onlyMainContract public payable {\r\n        require(isSeeded == false);\r\n        seedAmount = msg.value;\r\n        isSeeded = true;\r\n        emit logContractSeeded(seedAmount);\r\n    }\r\n\r\n    function sendContractDeposit() public payable {\r\n        require(isSeeded == true);\r\n        require(isDepositReceived == false);\r\n        require(msg.value >= (seedAmount * moonRaffleParameters.contractFeePercentage / 200));\r\n        depositAmount = msg.value;\r\n        isDepositReceived = true;\r\n        emit logContractDepositReceived(depositAmount);\r\n        emit logContractActive(startTime, moonRaffleEndTime, referralFloorTime, winnerCalcDeadlineTime, finishClaimTime);\r\n    }\r\n\r\n\r\n    function hasEntry() public view returns (bool) {\r\n        if (entries[msg.sender] > 0) {return true;}\r\n        return false;\r\n    }\r\n\r\n    function isValidReferrer(address _referrerAddress) public view returns (bool) {\r\n        if (entries[_referrerAddress] >= moonRaffleParameters.referralHurdle) {return true;}\r\n        else if (_referrerAddress == addressOne) {return true;}\r\n        else {return false;}\r\n    }\r\n\r\n\r\n    function play(address _referrerAddress) isHuman entryTimeLive external payable {\r\n        require(msg.value >= moonRaffleParameters.pricePerTicket);\r\n\r\n        uint256 numberOfEntries = (msg.value / moonRaffleParameters.pricePerTicket);\r\n        if (numberOfEntries > moonRaffleParameters.maxTicketsPerTransaction) { numberOfEntries = moonRaffleParameters.maxTicketsPerTransaction; }\r\n\r\n        uint256 numberOfEntriesTemp = (msg.value / moonRaffleParameters.pricePerTicket);\r\n        if (numberOfEntriesTemp > moonRaffleParameters.maxTicketsPerTransaction) { numberOfEntriesTemp = moonRaffleParameters.maxTicketsPerTransaction; }\r\n\r\n        uint256 tempReferralMultiplier = ( moonRaffleParameters.moonRaffleLiveSecs * (100 - moonRaffleParameters.referralFloorTimePercentage)) / (referralMultiplierInterval * 100);\r\n        if (now < referralFloorTime) {\r\n            tempReferralMultiplier = (moonRaffleEndTime - now) / referralMultiplierInterval;\r\n        }\r\n        uint256 tempReferralPoints = numberOfEntries * tempReferralMultiplier;\r\n        uint256 tempTotalReferralPoints = 0;\r\n\r\n\r\n        if (isValidReferrer(_referrerAddress)) {\r\n            referralPoints[_referrerAddress] += tempReferralPoints * 4;\r\n            referralPoints[msg.sender] += tempReferralPoints;\r\n            referralPoints[currentDefaultReferrerAddress] += tempReferralPoints;\r\n            tempTotalReferralPoints += tempReferralPoints * 6;\r\n            updateStarReferrer(_referrerAddress);\r\n            updateStarReferrer(msg.sender);\r\n            updateStarReferrer(currentDefaultReferrerAddress);\r\n        } else {\r\n            referralPoints[currentDefaultReferrerAddress] += tempReferralPoints;\r\n            tempTotalReferralPoints += tempReferralPoints;\r\n            updateStarReferrer(currentDefaultReferrerAddress);\r\n        }\r\n\r\n        referralPointsCounter += tempTotalReferralPoints;\r\n\r\n        if (!hasEntry()) {\r\n            playerCounter += 1;\r\n        }\r\n\r\n        entries[msg.sender] += numberOfEntriesTemp;\r\n\r\n        while (numberOfEntriesTemp > 0) {\r\n            tickets[ticketCounter] = msg.sender;\r\n            ticketCounter += 1;\r\n            numberOfEntriesTemp -= 1;\r\n        }\r\n\r\n        randomNumber = keccak256(abi.encodePacked(randomNumber, blockhash(block.number - 1), msg.sender));\r\n\r\n        if (isValidReferrer(msg.sender)) {\r\n            currentDefaultReferrerAddress = msg.sender;\r\n        }\r\n\r\n        emit logTicketPurchase(msg.sender, numberOfEntries, isValidReferrer(msg.sender));\r\n    }\r\n\r\n    function updateStarReferrer(address _referrer) internal {\r\n        if (referralPoints[_referrer] > currentStarReferrerPoints) {\r\n            currentStarReferrer = _referrer;\r\n            currentStarReferrerPoints = referralPoints[_referrer];\r\n        }\r\n    }\r\n\r\n\r\n    function claimPrize() isHuman prizeClaimPhaseLive external {\r\n        require(winnerClaims[msg.sender] > 0);\r\n        uint256 prizeAmount = winnerClaims[msg.sender];\r\n        winnerClaims[msg.sender] = 0;\r\n        emit logPrizeClaimed(msg.sender, prizeAmount);\r\n        msg.sender.transfer(prizeAmount);\r\n    }\r\n\r\n    function claimReferralBonus() isHuman prizeClaimPhaseLive external {\r\n        require(referralPoints[msg.sender] > 0);\r\n        uint256 tempReferralBonus = (referralBonusAmountFinal / referralPointsFinal) * referralPoints[msg.sender];\r\n        referralPoints[msg.sender] = 0;\r\n        emit logReferralBonusClaimed(msg.sender, tempReferralBonus);\r\n        msg.sender.transfer(tempReferralBonus);\r\n    }\r\n\r\n    function claimRefund() isHuman refundPhaseLive external {\r\n        require(hasEntry());\r\n        if (depositAmount > 0) {burnDeposit();}\r\n        uint256 refundAmount = (address(this).balance / ticketCounter) * entries[msg.sender];\r\n        ticketCounter -= entries[msg.sender];\r\n        entries[msg.sender] = 0;\r\n        emit logRefundClaimed(msg.sender, refundAmount);\r\n        msg.sender.transfer(refundAmount);\r\n    }\r\n\r\n    function calculateNonce() isHuman nonceCalculationPhaseLive external {\r\n        uint256 counter = 1;\r\n        while (counter <= 256) {\r\n            uint temp = uint256(blockhash(block.number - counter)) % 2;\r\n            if (temp == 0) {\r\n                binaryNonce[counter - 1] = false;\r\n            } else {\r\n                binaryNonce[counter - 1] = true;\r\n            }\r\n            counter += 1;\r\n        }\r\n        nonceCalcTime = now;\r\n        isNonceCalced = true;\r\n    }\r\n\r\n    function calculateFinalRandomNumber(string _initialSecret, uint _secretIndex) winnerCalculationPhaseLive internal {\r\n        require(keccak256(abi.encodePacked(_initialSecret)) == initialSecretHashArray[_secretIndex]);\r\n        randomNumber = keccak256(abi.encodePacked(randomNumber, binaryNonce, _initialSecret));\r\n    }\r\n\r\n    function calculateWinners() winnerCalculationPhaseLive internal {\r\n        firstPrizeAddressFinal = tickets[uint256(randomNumber) % ticketCounter];\r\n        secondPrizeAddressFinal = tickets[uint256(keccak256(abi.encodePacked(randomNumber))) % ticketCounter];\r\n        thirdPrizeAddressFinal = tickets[uint256(keccak256(abi.encodePacked(keccak256(abi.encodePacked(randomNumber))))) % ticketCounter];\r\n    }\r\n\r\n    function calculatePrizes() winnerCalculationPhaseLive internal {\r\n        fee = ((address(this).balance - depositAmount) / 100) * moonRaffleParameters.contractFeePercentage;\r\n        rollover = ((address(this).balance - depositAmount) / 100) * moonRaffleParameters.rolloverPercentage;\r\n        feeAmountFinal = fee;\r\n        rolloverAmountFinal = rollover;\r\n        referralBonusAmountFinal = ((address(this).balance - depositAmount) / 100) * moonRaffleParameters.referralPercentage;\r\n        totalTicketsFinal = ticketCounter;\r\n        totalPlayersFinal = playerCounter;\r\n        seedAmountFinal = seedAmount;\r\n        depositAmountFinal = depositAmount;\r\n        referralPointsFinal = referralPointsCounter;\r\n\r\n\r\n        firstPrizeAmountFinal = ((address(this).balance - depositAmount) / 100) * moonRaffleParameters.firstPrizePercentage;\r\n        winnerClaims[firstPrizeAddressFinal] += firstPrizeAmountFinal;\r\n\r\n        secondPrizeAmountFinal = ((address(this).balance - depositAmount) / 100) * moonRaffleParameters.secondPrizePercentage;\r\n        winnerClaims[secondPrizeAddressFinal] += secondPrizeAmountFinal;\r\n\r\n        thirdPrizeAmountFinal = ((address(this).balance - depositAmount) / 100) * moonRaffleParameters.thirdPrizePercentage;\r\n        winnerClaims[thirdPrizeAddressFinal] += thirdPrizeAmountFinal;\r\n    }\r\n\r\n    function finishMoonRaffle(\r\n        string _initialSecret1,\r\n        string _initialSecret2,\r\n        string _initialSecret3,\r\n        string _initialSecret4\r\n    ) winnerCalculationPhaseLive external {\r\n        require(keccak256(abi.encodePacked(_initialSecret1)) == initialSecretHashArray[0]);\r\n        require(keccak256(abi.encodePacked(_initialSecret2)) == initialSecretHashArray[1]);\r\n        require(keccak256(abi.encodePacked(_initialSecret3)) == initialSecretHashArray[2]);\r\n        require(keccak256(abi.encodePacked(_initialSecret4)) == initialSecretHashArray[3]);\r\n\r\n        emit logSecretsRevealed(_initialSecret1, _initialSecret2, _initialSecret3, _initialSecret4);\r\n\r\n        uint256 secretIndex = uint256(randomNumber) % 4;\r\n\r\n        if (secretIndex == 0) {\r\n            calculateFinalRandomNumber(_initialSecret1, secretIndex);\r\n        } else if (secretIndex == 1) {\r\n            calculateFinalRandomNumber(_initialSecret2, secretIndex);\r\n        } else if (secretIndex == 2) {\r\n            calculateFinalRandomNumber(_initialSecret3, secretIndex);\r\n        } else {\r\n            calculateFinalRandomNumber(_initialSecret4, secretIndex);\r\n        }\r\n\r\n        calculateWinners();\r\n        calculatePrizes();\r\n\r\n        isWinnerCalced = true;\r\n\r\n        emit logWinnersCalculated(\r\n            firstPrizeAddressFinal,\r\n            firstPrizeAmountFinal,\r\n            secondPrizeAddressFinal,\r\n            secondPrizeAmountFinal,\r\n            thirdPrizeAddressFinal,\r\n            thirdPrizeAmountFinal\r\n        );\r\n    }\r\n\r\n\r\n    function claimFeeAndDeposit() prizeClaimPhaseLive external {\r\n        require(fee > 0);\r\n        require(depositAmount > 0);\r\n        uint256 feeAndDeposit = fee + depositAmount;\r\n        fee = 0;\r\n        depositAmount = 0;\r\n        addressOne.transfer(feeAndDeposit);\r\n    }\r\n\r\n    function claimRollover() prizeClaimPhaseLive external {\r\n        require(rollover > 0);\r\n        uint256 tempRollover = rollover;\r\n        rollover = 0;\r\n        mainContractAddress.transfer(tempRollover);\r\n    }\r\n\r\n    function recoverUnclaimedBalance() moonRaffleContractDead external {\r\n        require(address(this).balance > 0);\r\n        mainContractAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function retractContract() onlyMainContract retractContractPhase external {\r\n        require(address(this).balance > 0);\r\n        mainContractAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    function burnDeposit() refundPhaseLive internal {\r\n        require(depositAmount > 0);\r\n        uint256 burnAmount = depositAmount;\r\n        depositAmount = 0;\r\n        emit logDepositBurn(burnAmount);\r\n        burnAddress.transfer(burnAmount);\r\n    }\r\n\r\n    function getRandomNumber() external view returns (bytes32) {\r\n        return randomNumber;\r\n    }\r\n\r\n    function getTime() external view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    function getSeedAmount() external view returns (uint256) {\r\n        require(isSeeded == true);\r\n        return seedAmount;\r\n    }\r\n\r\n    function getRequiredDepositAmount() external view returns (uint256) {\r\n        return seedAmount * moonRaffleParameters.contractFeePercentage / 200;\r\n    }\r\n\r\n    function getDepositAmount() contractLive external view returns (uint256) {\r\n        require(isDepositReceived == true);\r\n         if (isWinnerCalced == true) {\r\n            return depositAmountFinal;\r\n        }\r\n        else {\r\n            return depositAmount;\r\n        }\r\n    }\r\n\r\n    function getCurrentPrizeAmounts() contractLive external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        if (isWinnerCalced == true) {\r\n            uint256 tempPrizePool = firstPrizeAmountFinal + secondPrizeAmountFinal + thirdPrizeAmountFinal;\r\n            return (tempPrizePool, firstPrizeAmountFinal, secondPrizeAmountFinal, thirdPrizeAmountFinal, feeAmountFinal, rolloverAmountFinal, referralBonusAmountFinal);\r\n        }\r\n        else {\r\n            uint256 prizePool = (address(this).balance - depositAmount) / 100 * moonRaffleParameters.prizePoolPercentage;\r\n            uint256 tempFirstPrize = (address(this).balance - depositAmount) / 100 * moonRaffleParameters.firstPrizePercentage;\r\n            uint256 tempSecondPrize = (address(this).balance - depositAmount) / 100 * moonRaffleParameters.secondPrizePercentage;\r\n            uint256 tempThirdPrize = (address(this).balance - depositAmount) / 100 * moonRaffleParameters.thirdPrizePercentage;\r\n            uint256 currentFeeAmount = (address(this).balance - depositAmount) * moonRaffleParameters.contractFeePercentage / 100;\r\n            uint256 currentRolloverAmount = (address(this).balance - depositAmount) * moonRaffleParameters.rolloverPercentage / 100;\r\n            uint256 currentReferralAmount = (address(this).balance - depositAmount) * moonRaffleParameters.referralPercentage / 100;\r\n            return (prizePool, tempFirstPrize, tempSecondPrize, tempThirdPrize, currentFeeAmount, currentRolloverAmount, currentReferralAmount);\r\n        }\r\n    }\r\n\r\n    function getWinners() external view returns (address, address, address) {\r\n        require(isWinnerCalced == true);\r\n        return (firstPrizeAddressFinal, secondPrizeAddressFinal, thirdPrizeAddressFinal);\r\n    }\r\n\r\n    function getFirstPrizeAddress() external view returns (address) {\r\n        require(isWinnerCalced == true);\r\n        return firstPrizeAddressFinal;\r\n    }\r\n\r\n    function getSecondPrizeAddress() external view returns (address) {\r\n        require(isWinnerCalced == true);\r\n        return secondPrizeAddressFinal;\r\n    }\r\n\r\n    function getThirdPrizeAddress() external view returns (address) {\r\n        require(isWinnerCalced == true);\r\n        return thirdPrizeAddressFinal;\r\n    }\r\n\r\n    function getMyStatus() external view returns (uint256, bool, uint256, uint256) {\r\n        bool referralStatus = isValidReferrer(msg.sender);\r\n        uint256 tempReferralBonus;\r\n        if (isWinnerCalced == true) {\r\n            tempReferralBonus = (referralBonusAmountFinal / referralPointsFinal) * referralPoints[msg.sender];\r\n        } else {\r\n            if (referralPointsCounter == 0) {\r\n                tempReferralBonus = 0;\r\n            } else {\r\n                tempReferralBonus = ((address(this).balance - depositAmount) / 100 * moonRaffleParameters.referralPercentage) / referralPointsCounter * referralPoints[msg.sender];\r\n            }\r\n        }\r\n\r\n        return (entries[msg.sender], referralStatus, tempReferralBonus, referralPoints[msg.sender]);\r\n    }\r\n\r\n\r\n    function getCurrentPhase() external view returns (uint256, string) {\r\n        if (isSeeded == false) {return (0, \"unseeded\");}\r\n        if (isDepositReceived == false) {return (1, \"waiting for deposit\");}\r\n        if (now <= moonRaffleEndTime) {return (2, \"moonraffle is live\");}\r\n        if (\r\n            isNonceCalced == false &&\r\n            isWinnerCalced == false &&\r\n            now < moonRaffleEndTime + waitTime\r\n        ) {return (3, \"waiting for enough blocks to be mined before calculating 256 bit nonce\");}\r\n        if (\r\n            isNonceCalced == false &&\r\n            isWinnerCalced == false &&\r\n            now >= moonRaffleEndTime + waitTime &&\r\n            now <= winnerCalcDeadlineTime\r\n        ) {return (4, \"please go ahead and calculate the 256 bit nonce. anyone can do it!\");}\r\n        if (\r\n            isNonceCalced == true &&\r\n            isWinnerCalced == false &&\r\n            now < nonceCalcTime + waitTime\r\n        ) {return (5, \"waiting for enough blocks to be mined before calculating final winners\");}\r\n        if (\r\n            isNonceCalced == true &&\r\n            isWinnerCalced == false &&\r\n            now >= nonceCalcTime + waitTime &&\r\n            now <= winnerCalcDeadlineTime\r\n        ) {return (6, \"waiting for winners to be calculated\");}\r\n        if (\r\n            isWinnerCalced == false &&\r\n            now > winnerCalcDeadlineTime\r\n        ) {return (7, \"winners not calculated in time, please claim your refund plus a bonus\");}\r\n        if (\r\n            isWinnerCalced == true &&\r\n            now <= finishClaimTime\r\n        ) {return (8, \"winners have been calculated please claim your prizes & referral bonuses\");}\r\n        if (now > finishClaimTime) {return (9, \"contract complete, no more claims allowed\");}\r\n    }\r\n\r\n    function getAddresses() external view returns (address, address) {\r\n        return (mainContractAddress, addressOne);\r\n    }\r\n\r\n    function getMoonRaffleEntryParameters() external view returns (uint256, uint256) {\r\n        return (moonRaffleParameters.pricePerTicket, moonRaffleParameters.maxTicketsPerTransaction);\r\n    }\r\n\r\n    function getMoonRaffleTimes() external view returns (uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        return (startTime, moonRaffleEndTime, winnerCalcDeadlineTime, finishClaimTime, referralFloorTime, nonceCalcTime);\r\n    }\r\n\r\n    function getMoonRaffleStatus() external view returns (uint256, uint256, uint256) {\r\n        return (ticketCounter, playerCounter, referralPointsCounter);\r\n    }\r\n\r\n    function getCurrentDefaultReferrer() external view returns (address) {\r\n        return (currentDefaultReferrerAddress);\r\n    }\r\n\r\n    function getStarReferrerDetails() external view returns (address, uint256) {\r\n        return (currentStarReferrer, currentStarReferrerPoints);\r\n    }\r\n\r\n    function getCurrentReferralMultiplier() external view returns (uint256) {\r\n        uint256 tempReferralMultiplier = moonRaffleParameters.moonRaffleLiveSecs * (100 - moonRaffleParameters.referralFloorTimePercentage) / (referralMultiplierInterval * 100);\r\n        if (now < referralFloorTime) {\r\n            tempReferralMultiplier = (moonRaffleEndTime - now) / referralMultiplierInterval;\r\n        }\r\n        return tempReferralMultiplier;\r\n    }\r\n\r\n    function getBinaryNonce() external view returns (bool[256]) {\r\n        return binaryNonce;\r\n    }\r\n\r\n    function getMoonRaffleParamenters() external view returns (\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256,\r\n        uint256\r\n    ) {\r\n        return (\r\n        moonRaffleParameters.firstPrizePercentage,\r\n        moonRaffleParameters.secondPrizePercentage,\r\n        moonRaffleParameters.thirdPrizePercentage,\r\n        moonRaffleParameters.contractFeePercentage,\r\n        moonRaffleParameters.rolloverPercentage,\r\n        moonRaffleParameters.referralPercentage,\r\n        moonRaffleParameters.referralHurdle,\r\n        moonRaffleParameters.referralFloorTimePercentage,\r\n        seedAmount\r\n        );\r\n    }\r\n\r\n    function hasPlayerClaimedPrize() external view returns (bool) {\r\n        require(msg.sender == firstPrizeAddressFinal || msg.sender == secondPrizeAddressFinal || msg.sender == thirdPrizeAddressFinal);\r\n        return winnerClaims[msg.sender] == 0;\r\n    }\r\n\r\n    function hasPlayerClaimedReferralBonus() external view returns (bool){\r\n        return referralPoints[msg.sender] == 0 && entries[msg.sender] > 0 ;\r\n    }\r\n\r\n    function getContractBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function isRetractable() external view returns (bool) {\r\n        return isDepositReceived == false;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/MoonRaffleContractFactoryInterface.sol\r\n\r\ncontract MoonRaffleContractFactoryInterface {\r\n\r\n    function createMoonRaffleContract(\r\n        address _addressOne,\r\n        bytes32 _initialSecretHash1,\r\n        bytes32 _initialSecretHash2,\r\n        bytes32 _initialSecretHash3,\r\n        bytes32 _initialSecretHash4,\r\n        uint256[14] _moonRaffleParameters\r\n        )\r\n        public\r\n        payable\r\n        returns (address);\r\n\r\n}\r\n\r\n// File: contracts/MoonRaffleContractFactory.sol\r\n\r\ncontract MoonRaffleContractFactory is MoonRaffleContractFactoryInterface {\r\n\r\n    address mainContractAddress;\r\n\r\n    modifier onlyMainContract() {\r\n        require(msg.sender == mainContractAddress);\r\n        _;\r\n    }\r\n\r\n    constructor (address _mainContractAddress) public payable {\r\n        mainContractAddress = _mainContractAddress;\r\n    }\r\n\r\n    function createMoonRaffleContract(\r\n        address _addressOne,\r\n        bytes32 _initialSecretHash1,\r\n        bytes32 _initialSecretHash2,\r\n        bytes32 _initialSecretHash3,\r\n        bytes32 _initialSecretHash4,\r\n        uint256[14] _moonRaffleParameters\r\n        )\r\n        onlyMainContract\r\n        public\r\n        payable\r\n        returns (address)\r\n        {\r\n        address newContract = new MoonRaffleContract(\r\n            mainContractAddress,\r\n            _addressOne,\r\n            _initialSecretHash1,\r\n            _initialSecretHash2,\r\n            _initialSecretHash3,\r\n            _initialSecretHash4,\r\n            _moonRaffleParameters\r\n        );\r\n        return newContract;\r\n        }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addressOne\",\"type\":\"address\"},{\"name\":\"_initialSecretHash1\",\"type\":\"bytes32\"},{\"name\":\"_initialSecretHash2\",\"type\":\"bytes32\"},{\"name\":\"_initialSecretHash3\",\"type\":\"bytes32\"},{\"name\":\"_initialSecretHash4\",\"type\":\"bytes32\"},{\"name\":\"_moonRaffleParameters\",\"type\":\"uint256[14]\"}],\"name\":\"createMoonRaffleContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_mainContractAddress\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"}]","ContractName":"MoonRaffleContractFactory","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000007f85edccb8fa6252d4d485e643a9485d361d7a1e","Library":"","SwarmSource":"bzzr://9cb4dffa75c3cf7efa28e439fb544f0cd8cb3560bdd3742a068c18e3be91f979"}]}