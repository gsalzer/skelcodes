{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract AddressBook {\r\n\r\n    mapping(address => uint32) public uidOf;\r\n    mapping(uint32 => address) public addrOf;\r\n\r\n    uint32 public topUid;\r\n\r\n    function address_register(address _addr) internal {\r\n        require(uidOf[_addr] == 0, 'addr exsists');\r\n        uint32 uid = ++topUid;\r\n        uidOf[_addr] = uid;\r\n        addrOf[uid] = _addr;\r\n    }\r\n}\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        assert(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        assert(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        assert(c >= _a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param _newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract EthBox is Ownable, AddressBook {\r\n    using SafeMath for uint256;\r\n\r\n    event Deposited(uint indexed pid, uint indexed rid, uint number, address indexed payee, uint256 weiAmount, address inviter, RoundState state);\r\n    event RoundFinished(uint indexed pid, uint indexed rid, uint indexed number);\r\n\r\n    event NewRound(uint indexed pid, uint indexed rid, uint number, RoundState state);\r\n\r\n\r\n    // Events that are issued to make statistic recovery easier.\r\n    event FailedPayment(uint indexed pid, uint indexed rid, address indexed beneficiary, uint amount, uint count);\r\n    event Payment(uint indexed pid, uint indexed rid, address indexed beneficiary, uint amount, uint count, RoundState state);\r\n    event LogDepositReceived(address indexed sender);\r\n    event InviterRegistered(address indexed inviter, uint value);\r\n    event InviterWithDraw(address indexed inviter, uint value);\r\n\r\n    uint INVITER_FEE_PERCENT = 30; \r\n    uint constant INVITER_MIN_VALUE = 100 finney; \r\n\r\n    uint public lockedInBets;\r\n\r\n    enum RoundState{READY, RUNNING, REMOVED, FINISHED, WITHDRAWED}\r\n\r\n    struct Round {\r\n        uint32[] peoples; \r\n        uint price;\r\n        uint min_amount;\r\n        uint max_amount;\r\n        uint remainPrice;\r\n        uint HOUSE_EDGE_PERCENT;\r\n        RoundState state;\r\n        bool valid;\r\n        bool willremove;\r\n        bytes32 secretEncrypt;\r\n        uint count;\r\n    }\r\n\r\n    function() public payable {emit LogDepositReceived(msg.sender);}\r\n\r\n    constructor() public Ownable(){}\r\n\r\n    mapping(uint => mapping(uint => Round)) public bets;\r\n    mapping(address => uint) public inviters;\r\n\r\n    uint public inviterValues;\r\n\r\n    modifier onlyHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfRoundNotFinished(uint pid, uint rid){\r\n        require(bets[pid][rid].state != RoundState.FINISHED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfRoundFinished(uint pid, uint rid){\r\n        require(bets[pid][rid].state == RoundState.FINISHED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfRoundWithdrawed(uint pid, uint rid){\r\n        require(bets[pid][rid].state == RoundState.WITHDRAWED);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetExist(uint pid, uint rid){\r\n        require(bets[pid][rid].valid);\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfBetNotExist(uint pid, uint rid){\r\n        require(!bets[pid][rid].valid);\r\n        _;\r\n    }\r\n\r\n    function setHouseEdge(uint pid, uint rid, uint _edge) public onlyOwner {\r\n        if (bets[pid][rid].valid) {\r\n            bets[pid][rid].HOUSE_EDGE_PERCENT = _edge;\r\n        }\r\n    }\r\n\r\n    function setInviterEdge(uint _edge) public onlyOwner {\r\n        INVITER_FEE_PERCENT = _edge;\r\n    }\r\n\r\n    function inviterRegister() onlyHuman payable external {\r\n        require(msg.value == INVITER_MIN_VALUE, \"register value must greater than min value\");\r\n\r\n        inviters[msg.sender] = inviters[msg.sender].add(msg.value);\r\n        inviterValues = inviterValues.add(msg.value);\r\n        emit InviterRegistered(msg.sender, msg.value);\r\n\r\n    }\r\n\r\n    function newRound(uint pid, uint rid, uint _price, uint _min_amount, uint _edge, bytes32 _secretEncrypt, uint count) private {\r\n        Round storage r = bets[pid][rid];\r\n        require(!r.valid);\r\n        r.price = _price;\r\n        r.min_amount = _min_amount;\r\n        r.max_amount = _price;\r\n        r.HOUSE_EDGE_PERCENT = _edge;\r\n        r.state = RoundState.RUNNING;\r\n        r.remainPrice = _price;\r\n        r.valid = true;\r\n        r.secretEncrypt = _secretEncrypt;\r\n        // r.firstBlockNum = block.number;\r\n        r.count = count;\r\n\r\n    }\r\n\r\n\r\n    function buyTicket(uint pid, uint rid, address _inviter) public onlyHuman onlyIfBetExist(pid, rid) onlyIfRoundNotFinished(pid, rid) payable {\r\n        uint256 amount = msg.value;\r\n\r\n        require(msg.sender != address(0x0), \"invalid payee address\");\r\n\r\n        Round storage round = bets[pid][rid];\r\n\r\n        require(round.remainPrice > 0, \"remain price less then zero\");\r\n        require(amount >= round.min_amount && amount <= round.max_amount, \"Amount should be within range.\");\r\n        require(amount <= round.remainPrice, \"amount can not greater than remain price\");\r\n        require(amount % round.min_amount == 0, \"invalid amount\");\r\n\r\n        if (uidOf[msg.sender] == 0) {\r\n            address_register(msg.sender);\r\n        }\r\n\r\n        for (uint i = 0; i < amount.div(round.min_amount); i++) {\r\n            round.peoples.push(uidOf[msg.sender]);\r\n        }\r\n\r\n        // round.blockNum = block.number;\r\n        round.remainPrice = round.remainPrice.sub(amount);\r\n        lockedInBets = lockedInBets.add(amount);\r\n\r\n        addInviterValue(amount, round.HOUSE_EDGE_PERCENT, msg.sender, _inviter);\r\n\r\n        if (round.remainPrice == 0) {\r\n            round.state = RoundState.FINISHED;\r\n            emit RoundFinished(pid, rid, round.count);\r\n        }\r\n\r\n        emit Deposited(pid, rid, round.count, msg.sender, amount, _inviter, round.state);\r\n    }\r\n\r\n    function addInviterValue(uint amount, uint edge, address sender, address _inviter) private {\r\n        uint fee = amount.mul(edge).div(100);\r\n        //不计算同一帐号买入的抽成\r\n        if (sender != _inviter && inviters[_inviter] >= INVITER_MIN_VALUE) {\r\n            uint _ifee = fee.mul(INVITER_FEE_PERCENT).div(100);\r\n            inviters[_inviter] = inviters[_inviter].add(_ifee);\r\n            inviterValues = inviterValues.add(_ifee);\r\n        }\r\n    }\r\n\r\n    function payout(uint pid, uint rid, bytes32 _secret, bytes32 _nextSecretEncrypt) external onlyIfBetExist(pid, rid) onlyIfRoundFinished(pid, rid) {\r\n\r\n        Round storage round = bets[pid][rid];\r\n        require(round.secretEncrypt == keccak256(abi.encodePacked(_secret)), \"secret is not valid.\");\r\n\r\n        uint result = uint(keccak256(abi.encodePacked(_secret, blockhash(block.number)))) % (round.price.div(round.min_amount));\r\n        address luckGuy = addrOf[round.peoples[result]];\r\n        require(luckGuy != address(0x0));\r\n        uint256 bonus = round.price.sub(round.price.mul(round.HOUSE_EDGE_PERCENT).div(100));\r\n\r\n        if (bonus > 0) {\r\n            if (withdraw(pid, rid, luckGuy, bonus)) {\r\n                round.state = RoundState.WITHDRAWED;\r\n                lockedInBets = lockedInBets.sub(round.price);\r\n\r\n                clearRound(pid, rid, _nextSecretEncrypt, round.willremove, round.price, round.min_amount, round.HOUSE_EDGE_PERCENT, round.count);\r\n\r\n                emit Payment(pid, rid, luckGuy, bonus, round.count - 1, round.state);\r\n\r\n            } else {\r\n                emit FailedPayment(pid, rid, luckGuy, bonus, round.count);\r\n            }\r\n        }\r\n    }\r\n\r\n    function clearRound(uint pid, uint rid, bytes32 _secretEncrypt, bool willremove, uint price, uint min_amount, uint edge, uint count) private onlyIfBetExist(pid, rid) onlyIfRoundWithdrawed(pid, rid) {\r\n        delete bets[pid][rid];\r\n        if (!willremove) {\r\n            newRound(pid, rid, price, min_amount, edge, _secretEncrypt, count + 1);\r\n            emit NewRound(pid, rid, count + 1, RoundState.RUNNING);\r\n        } else {\r\n            emit NewRound(pid, rid, count + 1, RoundState.REMOVED);\r\n        }\r\n\r\n    }\r\n\r\n    function removeRound(uint pid, uint rid) external onlyOwner onlyIfBetExist(pid, rid) {\r\n        Round storage r = bets[pid][rid];\r\n        r.willremove = true;\r\n    }\r\n\r\n    function addRound(uint pid, uint rid, uint _price, uint _min_amount, uint _edge, bytes32 _secretEncrypt) external onlyOwner onlyIfBetNotExist(pid, rid) {\r\n        newRound(pid, rid, _price, _min_amount, _edge, _secretEncrypt, 1);\r\n    }\r\n\r\n\r\n    function withdraw(uint pid, uint rid, address beneficiary, uint withdrawAmount) private onlyIfBetExist(pid, rid) returns (bool){\r\n        Round storage r = bets[pid][rid];\r\n        require(withdrawAmount < r.price);\r\n        require(withdrawAmount <= address(this).balance, \"Increase amount larger than balance.\");\r\n\r\n        return beneficiary.send(withdrawAmount);\r\n    }\r\n\r\n    // Funds withdrawal to cover costs of operation.\r\n    function withdrawFunds(address payee) external onlyOwner {\r\n        uint costvalue = costFunds();\r\n        require(costvalue > 0, \"has no cost funds\");\r\n        payee.transfer(costvalue);\r\n    }\r\n\r\n    function costFunds() public view returns (uint){\r\n        return address(this).balance.sub(lockedInBets).sub(inviterValues);\r\n    }\r\n\r\n    function payToInviter(uint _value) onlyHuman external {\r\n        _payToInviter(msg.sender, _value);\r\n    }\r\n\r\n    function _payToInviter(address _inviter, uint _value) private {\r\n        require(_value > 0 && inviters[_inviter] >= _value, \"can not pay back greater then value\");\r\n        require(inviters[_inviter] <= address(this).balance);\r\n\r\n        inviters[_inviter] = inviters[_inviter].sub(_value);\r\n        inviterValues = inviterValues.sub(_value);\r\n        _inviter.transfer(_value);\r\n        emit InviterWithDraw(_inviter, _value);\r\n    }\r\n\r\n    function forceWithDrawToInviter(address _inviter, uint _value) onlyOwner external {\r\n        _payToInviter(_inviter, _value);\r\n    }\r\n\r\n\r\n    function kill() external onlyOwner {\r\n        require(lockedInBets == 0, \"All games should be processed settled before self-destruct.\");\r\n        require(inviterValues == 0, \"All inviter fee should be withdrawed before self-destruct.\");\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function lengthOfKeys(uint pid, uint rid) public onlyIfBetExist(pid, rid) view returns (uint){\r\n        Round storage r = bets[pid][rid];\r\n        return r.peoples.length;\r\n    }\r\n\r\n    function roundCount(uint pid, uint rid) public onlyIfBetExist(pid, rid) view returns (uint){\r\n        Round storage r = bets[pid][rid];\r\n        return r.count;\r\n    }\r\n\r\n    function roundState(uint pid, uint rid) public onlyIfBetExist(pid, rid) view returns (RoundState){\r\n        Round storage r = bets[pid][rid];\r\n        return r.state;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"rid\",\"type\":\"uint256\"},{\"name\":\"_inviter\",\"type\":\"address\"}],\"name\":\"buyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"uidOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"addrOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"inviterRegister\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"rid\",\"type\":\"uint256\"}],\"name\":\"roundCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"rid\",\"type\":\"uint256\"}],\"name\":\"roundState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_edge\",\"type\":\"uint256\"}],\"name\":\"setInviterEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"payToInviter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payee\",\"type\":\"address\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bets\",\"outputs\":[{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"min_amount\",\"type\":\"uint256\"},{\"name\":\"max_amount\",\"type\":\"uint256\"},{\"name\":\"remainPrice\",\"type\":\"uint256\"},{\"name\":\"HOUSE_EDGE_PERCENT\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint8\"},{\"name\":\"valid\",\"type\":\"bool\"},{\"name\":\"willremove\",\"type\":\"bool\"},{\"name\":\"secretEncrypt\",\"type\":\"bytes32\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"rid\",\"type\":\"uint256\"}],\"name\":\"removeRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"rid\",\"type\":\"uint256\"}],\"name\":\"lengthOfKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_inviter\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"forceWithDrawToInviter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inviterValues\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"rid\",\"type\":\"uint256\"},{\"name\":\"_secret\",\"type\":\"bytes32\"},{\"name\":\"_nextSecretEncrypt\",\"type\":\"bytes32\"}],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"rid\",\"type\":\"uint256\"},{\"name\":\"_edge\",\"type\":\"uint256\"}],\"name\":\"setHouseEdge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint256\"},{\"name\":\"rid\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_min_amount\",\"type\":\"uint256\"},{\"name\":\"_edge\",\"type\":\"uint256\"},{\"name\":\"_secretEncrypt\",\"type\":\"bytes32\"}],\"name\":\"addRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"costFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"topUid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedInBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"inviters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"payee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"Deposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"number\",\"type\":\"uint256\"}],\"name\":\"RoundFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"NewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"}],\"name\":\"FailedPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"pid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"LogDepositReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InviterRegistered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"inviter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"InviterWithDraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"EthBox","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4006581d82366d3d8e54fc1a0fd774a1953f16b199c624f9d47150825f11e812"}]}