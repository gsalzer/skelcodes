{"status":"1","message":"OK","result":[{"SourceCode":"/* ==================================================================== */\r\n/* Copyright (c) 2018 The CryptoRacing Project.  All rights reserved.\r\n/* \r\n/*   The first idle car race game of blockchain                 \r\n/* ==================================================================== */\r\npragma solidity ^0.4.20;\r\n\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// RaceCoin - Crypto Idle Raceing Game\r\n// https://cryptoracing.online\r\n\r\n\r\ncontract AccessAdmin {\r\n    bool public isPaused = false;\r\n    address public addrAdmin;  \r\n\r\n    event AdminTransferred(address indexed preAdmin, address indexed newAdmin);\r\n\r\n    function AccessAdmin() public {\r\n        addrAdmin = msg.sender;\r\n    }  \r\n\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == addrAdmin);\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!isPaused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(isPaused);\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address _newAdmin) external onlyAdmin {\r\n        require(_newAdmin != address(0));\r\n        emit AdminTransferred(addrAdmin, _newAdmin);\r\n        addrAdmin = _newAdmin;\r\n    }\r\n\r\n    function doPause() external onlyAdmin whenNotPaused {\r\n        isPaused = true;\r\n    }\r\n\r\n    function doUnpause() external onlyAdmin whenPaused {\r\n        isPaused = false;\r\n    }\r\n}\r\n\r\n\r\ninterface IRaceCoin {\r\n    function addTotalEtherPool(uint256 amount) external;\r\n    function addPlayerToList(address player) external;\r\n    function increasePlayersAttribute(address player, uint16[13] param) external;\r\n    function reducePlayersAttribute(address player, uint16[13] param) external;\r\n}\r\n\r\ncontract RaceCoin is ERC20, AccessAdmin, IRaceCoin {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    string public constant name  = \"Race Coin\";\r\n    string public constant symbol = \"Coin\";\r\n    uint8 public constant decimals = 0;\r\n    uint256 private roughSupply;\r\n    uint256 public totalRaceCoinProduction;\r\n   \r\n    //Daily dividend ratio\r\n    uint256 public bonusDivPercent = 20;\r\n\r\n    //Recommendation ratio\r\n    uint256 constant refererPercent = 5;\r\n\r\n    \r\n\r\n    address[] public playerList;\r\n    //Verifying whether duplication is repeated\r\n   // mapping(address => uint256) public isProduction;\r\n\r\n\r\n    uint256 public totalEtherPool; // Eth dividends to be split between players' race coin production\r\n    uint256[] private totalRaceCoinProductionSnapshots; // The total race coin production for each prior day past\r\n    uint256[] private allocatedRaceCoinSnapshots; // The amount of EHT that can be allocated daily\r\n    uint256[] private totalRaceCoinSnapshots; // The total race coin for each prior day past\r\n    uint256 public nextSnapshotTime;\r\n\r\n\r\n\r\n    // Balances for each player\r\n    mapping(address => uint256) private ethBalance;\r\n    mapping(address => uint256) private raceCoinBalance;\r\n    mapping(address => uint256) private refererDivsBalance;\r\n\r\n    mapping(address => uint256) private productionBaseValue; //Player production base value\r\n    mapping(address => uint256) private productionMultiplier; //Player production multiplier\r\n\r\n    mapping(address => uint256) private attackBaseValue; //Player attack base value\r\n    mapping(address => uint256) private attackMultiplier; //Player attack multiplier\r\n    mapping(address => uint256) private attackPower; //Player attack Power\r\n\r\n    mapping(address => uint256) private defendBaseValue; //Player defend base value\r\n    mapping(address => uint256) private defendMultiplier; //Player defend multiplier\r\n    mapping(address => uint256) private defendPower; //Player defend Power\r\n\r\n    mapping(address => uint256) private plunderBaseValue; //Player plunder base value\r\n    mapping(address => uint256) private plunderMultiplier; //Player plunder multiplier\r\n    mapping(address => uint256) private plunderPower; //Player plunder Power\r\n\r\n\r\n\r\n\r\n    mapping(address => mapping(uint256 => uint256)) private raceCoinProductionSnapshots; // Store player's race coin production for given day (snapshot)\r\n    mapping(address => mapping(uint256 => bool)) private raceCoinProductionZeroedSnapshots; // This isn't great but we need know difference between 0 production and an unused/inactive day.\r\n    mapping(address => mapping(uint256 => uint256)) private raceCoinSnapshots;// Store player's race coin for given day (snapshot)\r\n\r\n\r\n\r\n    mapping(address => uint256) private lastRaceCoinSaveTime; // Seconds (last time player claimed their produced race coin)\r\n    mapping(address => uint256) public lastRaceCoinProductionUpdate; // Days (last snapshot player updated their production)\r\n    mapping(address => uint256) private lastRaceCoinFundClaim; // Days (snapshot number)\r\n    mapping(address => uint256) private battleCooldown; // If user attacks they cannot attack again for short time\r\n\r\n\r\n    // Computational correlation\r\n\r\n\r\n    // Mapping of approved ERC20 transfers (by player)\r\n    mapping(address => mapping(address => uint256)) private allowed;\r\n\r\n\r\n    event ReferalGain(address referal, address player, uint256 amount);\r\n    event PlayerAttacked(address attacker, address target, bool success, uint256 raceCoinPlunder);\r\n\r\n\r\n     /// @dev Trust contract\r\n    mapping (address => bool) actionContracts;\r\n\r\n    function setActionContract(address _actionAddr, bool _useful) external onlyAdmin {\r\n        actionContracts[_actionAddr] = _useful;\r\n    }\r\n\r\n    function getActionContract(address _actionAddr) external view onlyAdmin returns(bool) {\r\n        return actionContracts[_actionAddr];\r\n    }\r\n    \r\n   \r\n\r\n\r\n    function RaceCoin() public {\r\n        addrAdmin = msg.sender;\r\n    }\r\n    \r\n\r\n    function() external payable {\r\n\r\n    }\r\n\r\n\r\n    function beginWork(uint256 firstDivsTime) external onlyAdmin {\r\n\r\n        nextSnapshotTime = firstDivsTime;\r\n    }\r\n\r\n\r\n     // We will adjust to achieve a balance.\r\n    function adjustDailyDividends(uint256 newBonusPercent) external onlyAdmin whenNotPaused {\r\n\r\n        require(newBonusPercent > 0 && newBonusPercent <= 80);\r\n       \r\n        bonusDivPercent = newBonusPercent;\r\n\r\n    }\r\n\r\n    // Stored race coin (rough supply as it ignores earned/unclaimed RaceCoin)\r\n    function totalSupply() public view returns(uint256) {\r\n        return roughSupply; \r\n    }\r\n\r\n\r\n    function balanceOf(address player) public view returns(uint256) {\r\n        return raceCoinBalance[player] + balanceOfUnclaimedRaceCoin(player);\r\n    }\r\n\r\n\r\n    function balanceOfUnclaimedRaceCoin(address player) internal view returns (uint256) {\r\n        uint256 lastSave = lastRaceCoinSaveTime[player];\r\n        if (lastSave > 0 && lastSave < block.timestamp) {\r\n            return (getRaceCoinProduction(player) * (block.timestamp - lastSave)) / 100;\r\n        }\r\n        return 0;\r\n    }\r\n\r\n\r\n    function getRaceCoinProduction(address player) public view returns (uint256){\r\n        return raceCoinProductionSnapshots[player][lastRaceCoinProductionUpdate[player]];\r\n    }\r\n\r\n\r\n    function etherBalanceOf(address player) public view returns(uint256) {\r\n        return ethBalance[player];\r\n    }\r\n\r\n\r\n    function transfer(address recipient, uint256 amount) public returns (bool) {\r\n        updatePlayersRaceCoin(msg.sender);\r\n        require(amount <= raceCoinBalance[msg.sender]);\r\n        \r\n        raceCoinBalance[msg.sender] -= amount;\r\n        raceCoinBalance[recipient] += amount;\r\n        \r\n        emit Transfer(msg.sender, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address player, address recipient, uint256 amount) public returns (bool) {\r\n        updatePlayersRaceCoin(player);\r\n        require(amount <= allowed[player][msg.sender] && amount <= raceCoinBalance[player]);\r\n        \r\n        raceCoinBalance[player] -= amount;\r\n        raceCoinBalance[recipient] += amount;\r\n        allowed[player][msg.sender] -= amount;\r\n        \r\n        emit Transfer(player, recipient, amount);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address approvee, uint256 amount) public returns (bool){\r\n        allowed[msg.sender][approvee] = amount;\r\n        emit Approval(msg.sender, approvee, amount);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address player, address approvee) public view returns(uint256){\r\n        return allowed[player][approvee];\r\n    }\r\n\r\n\r\n    function addPlayerToList(address player) external{\r\n        \r\n        require(actionContracts[msg.sender]);\r\n        require(player != address(0));\r\n\r\n        bool b = false;\r\n\r\n        //Judge whether or not to repeat\r\n        for (uint256 i = 0; i < playerList.length; i++) {\r\n            if(playerList[i] == player){\r\n               b = true;\r\n               break;\r\n            }\r\n        } \r\n\r\n        if(!b){\r\n            playerList.push(player);\r\n        }   \r\n    }\r\n\r\n\r\n    function getPlayerList() external view returns ( address[] ){\r\n        return playerList;\r\n    }\r\n\r\n\r\n\r\n\r\n\r\n    function updatePlayersRaceCoin(address player) internal {\r\n        uint256 raceCoinGain = balanceOfUnclaimedRaceCoin(player);\r\n        lastRaceCoinSaveTime[player] = block.timestamp;\r\n        roughSupply += raceCoinGain;\r\n        raceCoinBalance[player] += raceCoinGain;\r\n    }\r\n\r\n    //Increase attribute\r\n    function increasePlayersAttribute(address player, uint16[13] param) external{\r\n\r\n\r\n        require(actionContracts[msg.sender]);\r\n        require(player != address(0));\r\n\r\n\r\n        //Production\r\n        updatePlayersRaceCoin(player);\r\n        uint256 increase;\r\n        uint256 newProduction;\r\n        uint256 previousProduction;\r\n\r\n        previousProduction = getRaceCoinProduction(player);\r\n\r\n        productionBaseValue[player] = productionBaseValue[player].add(param[3]);\r\n        productionMultiplier[player] = productionMultiplier[player].add(param[7]);\r\n\r\n        newProduction = productionBaseValue[player].mul(100 + productionMultiplier[player]).div(100);\r\n\r\n        increase = newProduction.sub(previousProduction);\r\n\r\n        raceCoinProductionSnapshots[player][allocatedRaceCoinSnapshots.length] = newProduction;\r\n        lastRaceCoinProductionUpdate[player] = allocatedRaceCoinSnapshots.length;\r\n        totalRaceCoinProduction += increase;\r\n\r\n\r\n\r\n\r\n        //Attack\r\n        attackBaseValue[player] = attackBaseValue[player].add(param[4]);\r\n        attackMultiplier[player] = attackMultiplier[player].add(param[8]);\r\n        attackPower[player] = attackBaseValue[player].mul(100 + attackMultiplier[player]).div(100);\r\n\r\n\r\n        //Defend\r\n        defendBaseValue[player] = defendBaseValue[player].add(param[5]);\r\n        defendMultiplier[player] = defendMultiplier[player].add(param[9]);\r\n        defendPower[player] = defendBaseValue[player].mul(100 + defendMultiplier[player]).div(100);\r\n\r\n\r\n        //Plunder\r\n        plunderBaseValue[player] = plunderBaseValue[player].add(param[6]);\r\n        plunderMultiplier[player] = plunderMultiplier[player].add(param[10]);\r\n\r\n        plunderPower[player] = plunderBaseValue[player].mul(100 + plunderMultiplier[player]).div(100);\r\n\r\n\r\n    }\r\n\r\n\r\n    //Reduce attribute\r\n    function reducePlayersAttribute(address player, uint16[13] param) external{\r\n\r\n        require(actionContracts[msg.sender]);\r\n        require(player != address(0));\r\n\r\n\r\n        //Production\r\n        updatePlayersRaceCoin(player);\r\n\r\n\r\n        uint256 decrease;\r\n        uint256 newProduction;\r\n        uint256 previousProduction;\r\n\r\n\r\n        previousProduction = getRaceCoinProduction(player);\r\n\r\n        productionBaseValue[player] = productionBaseValue[player].sub(param[3]);\r\n        productionMultiplier[player] = productionMultiplier[player].sub(param[7]);\r\n\r\n        newProduction = productionBaseValue[player].mul(100 + productionMultiplier[player]).div(100);\r\n\r\n        decrease = previousProduction.sub(newProduction);\r\n        \r\n        if (newProduction == 0) { // Special case which tangles with \"inactive day\" snapshots (claiming divs)\r\n            raceCoinProductionZeroedSnapshots[player][allocatedRaceCoinSnapshots.length] = true;\r\n            delete raceCoinProductionSnapshots[player][allocatedRaceCoinSnapshots.length]; // 0\r\n        } else {\r\n            raceCoinProductionSnapshots[player][allocatedRaceCoinSnapshots.length] = newProduction;\r\n        }\r\n        \r\n        lastRaceCoinProductionUpdate[player] = allocatedRaceCoinSnapshots.length;\r\n        totalRaceCoinProduction -= decrease;\r\n\r\n\r\n\r\n\r\n        //Attack\r\n        attackBaseValue[player] = attackBaseValue[player].sub(param[4]);\r\n        attackMultiplier[player] = attackMultiplier[player].sub(param[8]);\r\n        attackPower[player] = attackBaseValue[player].mul(100 + attackMultiplier[player]).div(100);\r\n\r\n\r\n        //Defend\r\n        defendBaseValue[player] = defendBaseValue[player].sub(param[5]);\r\n        defendMultiplier[player] = defendMultiplier[player].sub(param[9]);\r\n        defendPower[player] = defendBaseValue[player].mul(100 + defendMultiplier[player]).div(100);\r\n\r\n\r\n        //Plunder\r\n        plunderBaseValue[player] = plunderBaseValue[player].sub(param[6]);\r\n        plunderMultiplier[player] = plunderMultiplier[player].sub(param[10]);\r\n        plunderPower[player] = plunderBaseValue[player].mul(100 + plunderMultiplier[player]).div(100);\r\n\r\n\r\n    }\r\n\r\n\r\n    function attackPlayer(address player,address target) external {\r\n        require(battleCooldown[player] < block.timestamp);\r\n        require(target != player);\r\n\r\n        updatePlayersRaceCoin(target);\r\n        require(balanceOf(target) > 0);\r\n        \r\n        uint256 attackerAttackPower = attackPower[player];\r\n        uint256 attackerplunderPower = plunderPower[player];\r\n        uint256 defenderDefendPower = defendPower[target];\r\n        \r\n\r\n        if (battleCooldown[target] > block.timestamp) { // When on battle cooldown, the defense is reduced by 50%\r\n            defenderDefendPower = defenderDefendPower.div(2);\r\n        }\r\n        \r\n        if (attackerAttackPower > defenderDefendPower) {\r\n            battleCooldown[player] = block.timestamp + 30 minutes;\r\n            if (balanceOf(target) > attackerplunderPower) {\r\n               \r\n                uint256 unclaimedRaceCoin = balanceOfUnclaimedRaceCoin(target);\r\n                if (attackerplunderPower > unclaimedRaceCoin) {\r\n                    uint256 raceCoinDecrease = attackerplunderPower - unclaimedRaceCoin;\r\n                    raceCoinBalance[target] -= raceCoinDecrease;\r\n                    roughSupply -= raceCoinDecrease;\r\n                } else {\r\n                    uint256 raceCoinGain = unclaimedRaceCoin - attackerplunderPower;\r\n                    raceCoinBalance[target] += raceCoinGain;\r\n                    roughSupply += raceCoinGain;\r\n                }\r\n                raceCoinBalance[player] += attackerplunderPower;\r\n                emit PlayerAttacked(player, target, true, attackerplunderPower);\r\n            } else {\r\n                emit PlayerAttacked(player, target, true, balanceOf(target));\r\n                raceCoinBalance[player] += balanceOf(target);\r\n                raceCoinBalance[target] = 0;\r\n            }\r\n            \r\n            lastRaceCoinSaveTime[target] = block.timestamp;\r\n            lastRaceCoinSaveTime[player] = block.timestamp;\r\n           \r\n        } else {\r\n            battleCooldown[player] = block.timestamp + 10 minutes;\r\n            emit PlayerAttacked(player, target, false, 0);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function getPlayersBattleStats(address player) external view returns (uint256, uint256, uint256, uint256){\r\n\r\n        return (attackPower[player], defendPower[player], plunderPower[player], battleCooldown[player]);\r\n    }\r\n\r\n    \r\n    function getPlayersAttributesInt(address player) external view returns (uint256, uint256, uint256, uint256){\r\n        return (getRaceCoinProduction(player), attackPower[player], defendPower[player], plunderPower[player]); \r\n    }\r\n\r\n\r\n    function getPlayersAttributesMult(address player) external view returns (uint256, uint256, uint256, uint256){\r\n        return (productionMultiplier[player], attackMultiplier[player], defendMultiplier[player], plunderMultiplier[player]);\r\n    }\r\n    \r\n\r\n    function withdrawEther(uint256 amount) external {\r\n        require(amount <= ethBalance[msg.sender]);\r\n        ethBalance[msg.sender] -= amount;\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n\r\n    function getBalance() external view returns(uint256) {\r\n        return totalEtherPool;\r\n    }\r\n\r\n\r\n    function addTotalEtherPool(uint256 amount) external{\r\n        require(amount > 0);\r\n        totalEtherPool += amount;\r\n    }\r\n\r\n\r\n    // To display \r\n    function getGameInfo(address player) external view returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256){\r\n       \r\n        return (block.timestamp, totalEtherPool, totalRaceCoinProduction,nextSnapshotTime, balanceOf(player), ethBalance[player], getRaceCoinProduction(player));\r\n    }\r\n\r\n\r\n   \r\n\r\n\r\n\r\n    function claimRaceCoinDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external {\r\n        require(startSnapshot <= endSnapShot);\r\n        require(startSnapshot >= lastRaceCoinFundClaim[msg.sender]);\r\n        require(endSnapShot < allocatedRaceCoinSnapshots.length);\r\n        \r\n        uint256 dividendsShare;\r\n\r\n\r\n        for (uint256 i = startSnapshot; i <= endSnapShot; i++) {\r\n\r\n            uint256 raceCoinDuringSnapshot = raceCoinSnapshots[msg.sender][i];\r\n\r\n            dividendsShare += (allocatedRaceCoinSnapshots[i] * raceCoinDuringSnapshot) / totalRaceCoinSnapshots[i];\r\n        }\r\n\r\n        \r\n        lastRaceCoinFundClaim[msg.sender] = endSnapShot + 1;\r\n        \r\n        uint256 referalDivs;\r\n        if (referer != address(0) && referer != msg.sender) {\r\n            referalDivs = dividendsShare.mul(refererPercent).div(100); // 5%\r\n            ethBalance[referer] += referalDivs;\r\n            refererDivsBalance[referer] += referalDivs;\r\n            emit ReferalGain(referer, msg.sender, referalDivs);\r\n        }\r\n        \r\n        ethBalance[msg.sender] += dividendsShare - referalDivs;\r\n    }\r\n\r\n    // To display \r\n    function viewUnclaimedRaceCoinDividends(address player) external view returns (uint256, uint256, uint256) {\r\n        uint256 startSnapshot = lastRaceCoinFundClaim[player];\r\n        uint256 latestSnapshot = allocatedRaceCoinSnapshots.length - 1; // No snapshots to begin with\r\n        \r\n        uint256 dividendsShare;\r\n        \r\n        for (uint256 i = startSnapshot; i <= latestSnapshot; i++) {\r\n\r\n            uint256 raceCoinDuringSnapshot = raceCoinSnapshots[player][i];\r\n\r\n            dividendsShare += (allocatedRaceCoinSnapshots[i] * raceCoinDuringSnapshot) / totalRaceCoinSnapshots[i];\r\n        }\r\n\r\n        return (dividendsShare, startSnapshot, latestSnapshot);\r\n    }\r\n\r\n\r\n    function getRefererDivsBalance(address player)  external view returns (uint256){\r\n        return refererDivsBalance[player];\r\n    }\r\n\r\n\r\n\r\n    // Allocate  divs for the day (00:00 cron job)\r\n    function snapshotDailyRaceCoinFunding() external onlyAdmin whenNotPaused {\r\n       \r\n        uint256 todaysRaceCoinFund = (totalEtherPool * bonusDivPercent) / 100; // 20% of pool daily\r\n        totalEtherPool -= todaysRaceCoinFund;\r\n        \r\n        totalRaceCoinProductionSnapshots.push(totalRaceCoinProduction);\r\n        allocatedRaceCoinSnapshots.push(todaysRaceCoinFund);\r\n        nextSnapshotTime = block.timestamp + 24 hours;\r\n\r\n        \r\n        for (uint256 i = 0; i < playerList.length; i++) {\r\n            updatePlayersRaceCoin(playerList[i]);\r\n            raceCoinSnapshots[playerList[i]][lastRaceCoinProductionUpdate[playerList[i]]] = raceCoinBalance[playerList[i]];\r\n        } \r\n        totalRaceCoinSnapshots.push(roughSupply);\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalRaceCoinProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"approvee\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"attackPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getRaceCoinProduction\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"etherBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"addPlayerToList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"addTotalEtherPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doUnpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"param\",\"type\":\"uint16[13]\"}],\"name\":\"increasePlayersAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referer\",\"type\":\"address\"},{\"name\":\"startSnapshot\",\"type\":\"uint256\"},{\"name\":\"endSnapShot\",\"type\":\"uint256\"}],\"name\":\"claimRaceCoinDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newBonusPercent\",\"type\":\"uint256\"}],\"name\":\"adjustDailyDividends\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_actionAddr\",\"type\":\"address\"}],\"name\":\"getActionContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPlayerList\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getRefererDivsBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"doPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_actionAddr\",\"type\":\"address\"},{\"name\":\"_useful\",\"type\":\"bool\"}],\"name\":\"setActionContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayersBattleStats\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"viewUnclaimedRaceCoinDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusDivPercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"param\",\"type\":\"uint16[13]\"}],\"name\":\"reducePlayersAttribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"snapshotDailyRaceCoinFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextSnapshotTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayersAttributesInt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayersAttributesMult\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"addrAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"},{\"name\":\"approvee\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"firstDivsTime\",\"type\":\"uint256\"}],\"name\":\"beginWork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEtherPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lastRaceCoinProductionUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"referal\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReferalGain\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"attacker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"success\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"raceCoinPlunder\",\"type\":\"uint256\"}],\"name\":\"PlayerAttacked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"preAdmin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"AdminTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"RaceCoin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f5830cd93484b8ee7d6c842f4ae1fbfc8dcfbde47afa57706fad4fb4fcb0428f"}]}