{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\ncontract HOLDx3 {\r\n    using SafeMath for uint;\r\n    \r\n    mapping(address => uint[64]) public invest_amount;\r\n    mapping(address => uint[64]) public invest_time;\r\n    mapping(address => uint) public invest_count;\r\n\r\n    mapping(address => uint[64]) public withdraw_amount;\r\n    mapping(address => uint[64]) public withdraw_time;\r\n    mapping(address => uint) public withdraw_count;\r\n\r\n    mapping(address => uint) total_invest_amount;\r\n    mapping(address => uint) total_paid_amount;\r\n    mapping(address => uint) public last_withdraw_time;\r\n\r\n    uint public investors = 0;\r\n\r\n    uint stepTime = 1 hours;\r\n    address dev_addr = 0x703826fc8D2a5506EAAe7808ab3B090521B04eDc;\r\n    uint dev_fee= 10;\r\n\r\n    modifier userExist() {\r\n        require(total_invest_amount[msg.sender] > 0);\r\n        _;\r\n    }\r\n\r\n    modifier checkTime() {\r\n        require(now >= last_withdraw_time[msg.sender].add(stepTime));\r\n        _;\r\n    }\r\n\r\n    function deposit() private {\r\n        // invest\r\n        if (msg.value > 0) {\r\n            if (last_withdraw_time[msg.sender] == 0) last_withdraw_time[msg.sender] = now;\r\n            if (total_invest_amount[msg.sender] == 0) {\r\n                invest_count[msg.sender] = 0;\r\n                withdraw_count[msg.sender] = 0;\r\n                total_paid_amount[msg.sender] = 0;\r\n                investors++;\r\n            }\r\n            invest_amount[msg.sender][invest_count[msg.sender]] = msg.value;\r\n            invest_time[msg.sender][invest_count[msg.sender]] = now;\r\n            invest_count[msg.sender] = invest_count[msg.sender]+1;\r\n            total_invest_amount[msg.sender] = total_invest_amount[msg.sender].add(msg.value);\r\n            dev_addr.transfer(msg.value.mul(dev_fee).div(100));\r\n        }\r\n        // claim percents\r\n        else{\r\n            CalculateAllPayoutAmount();\r\n        }\r\n    }\r\n\r\n    function CalculateAllPayoutAmount() checkTime userExist internal {\r\n        uint payout_amount = CalculatePayoutAmount();\r\n        uint hold_payout_amount = CalculateHoldPayoutAmount();\r\n        payout_amount = payout_amount.add(hold_payout_amount);\r\n        SendPercent(payout_amount); \r\n    }\r\n\r\n    function SendPercent(uint _payout_amount) internal {\r\n        // checking that contract balance have an ether to pay dividents\r\n        if (_payout_amount > address(this).balance) _payout_amount = address(this).balance;\r\n        if (address(this).balance >= _payout_amount && _payout_amount > 0) {\r\n            //checking that user claimed not more then x3 of his total investitions\r\n            if ((_payout_amount.add(total_paid_amount[msg.sender])) > total_invest_amount[msg.sender].mul(3)) {\r\n                _payout_amount = total_invest_amount[msg.sender].mul(3).sub(total_paid_amount[msg.sender]);\r\n                for (uint16 i = 0; i < invest_count[msg.sender]; i++) {\r\n                    invest_amount[msg.sender][i] = 0;\r\n                }\r\n                invest_count[msg.sender] = 0;\r\n                total_invest_amount[msg.sender] = 0;\r\n                total_paid_amount[msg.sender] = 0;\r\n                last_withdraw_time[msg.sender] = 0;\r\n            }\r\n            else {\r\n                total_paid_amount[msg.sender] = total_paid_amount[msg.sender].add(_payout_amount);\r\n                last_withdraw_time[msg.sender] = now;\r\n            }\r\n            withdraw_amount[msg.sender][withdraw_count[msg.sender]] = _payout_amount;\r\n            withdraw_time[msg.sender][withdraw_count[msg.sender]] = now;\r\n            withdraw_count[msg.sender] = withdraw_count[msg.sender]+1;\r\n            msg.sender.transfer(_payout_amount);\r\n        }\r\n    }\r\n \r\n    function CalculatePayoutAmount() internal view returns (uint){\r\n        uint percent = DayliPercentRate();\r\n        uint _payout_amount = 0;\r\n        uint time_spent = 0;\r\n        // calculating all dividents for the current day percent rate\r\n        for (uint16 i = 0; i < invest_count[msg.sender]; i++) {\r\n            if (last_withdraw_time[msg.sender] > invest_time[msg.sender][i]) {\r\n                time_spent = (now.sub(last_withdraw_time[msg.sender])).div(stepTime);\r\n            }\r\n            else {\r\n                time_spent = (now.sub(invest_time[msg.sender][i])).div(stepTime);\r\n            }\r\n            uint current_payout_amount = (invest_amount[msg.sender][i].mul(time_spent).mul(percent).div(100)).div(24);\r\n            _payout_amount = _payout_amount.add(current_payout_amount);\r\n        }\r\n        return _payout_amount;\r\n    }\r\n\r\n    function CalculateHoldPayoutAmount() internal view returns (uint){\r\n        uint hold_payout_amount = 0;\r\n        uint time_spent = 0;\r\n        for (uint16 i = 0; i < invest_count[msg.sender]; i++) {\r\n            if (last_withdraw_time[msg.sender] > invest_time[msg.sender][i]) \r\n                time_spent = (now.sub(last_withdraw_time[msg.sender])).div(stepTime.mul(24));\r\n            else \r\n                time_spent = (now.sub(invest_time[msg.sender][i])).div(stepTime.mul(24));\r\n\r\n            if (time_spent > 30) time_spent = 30;\r\n            \r\n            if (time_spent > 0) {\r\n                uint hold_percent = 117**time_spent;\r\n                uint devider = 100**time_spent;\r\n                uint current_payout_amount = invest_amount[msg.sender][i].mul(hold_percent).div(devider).div(100);\r\n                hold_payout_amount = hold_payout_amount.add(current_payout_amount);\r\n            }\r\n        }\r\n        return hold_payout_amount;\r\n    }\r\n\r\n    function DayliPercentRate() internal view returns(uint) {\r\n        uint contractBalance = address(this).balance;\r\n        if (contractBalance >= 0 ether && contractBalance < 100 ether) {\r\n            return (3);\r\n        }\r\n        if (contractBalance >= 100 ether && contractBalance < 200 ether) {\r\n            return (4);\r\n        }\r\n        if (contractBalance >= 200 ether && contractBalance < 500 ether) {\r\n            return (5);\r\n        }\r\n        if (contractBalance >= 500 ether && contractBalance < 1000 ether) {\r\n            return (6);\r\n        }\r\n        if (contractBalance >= 1000 ether) {\r\n            return (7); \r\n        }\r\n    }\r\n\r\n    function() external payable {\r\n        deposit();\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdraw_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"last_withdraw_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdraw_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"invest_time\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"invest_count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"withdraw_amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"invest_amount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"HOLDx3","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c59d944b0cafd94cabb1305c219b71b28df6a2a541e2d3989c1ac80ba79cc7e4"}]}