{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/*\r\n *  @notice the token contract used as reward \r\n */\r\ninterface token {\r\n    /*\r\n     *  @notice exposes the transfer method of the token contract\r\n     *  @param _receiver address receiving tokens\r\n     *  @param _amount number of tokens being transferred       \r\n     */    \r\n    function transfer(address _receiver, uint _amount) returns (bool success);\r\n}\r\n\r\n/*\r\n * is owned\r\n */\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function owned() {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() { \r\n        require (msg.sender == owner); \r\n        _; \r\n    }\r\n\r\n    function ownerTransferOwnership(address newOwner) onlyOwner\r\n    {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\ncontract SafeMath {\r\n  function safeMul(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function safeDiv(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b > 0);\r\n    uint256 c = a / b;\r\n    assert(a == b * c + a % b);\r\n    return c;\r\n  }\r\n\r\n  function safeSub(uint256 a, uint256 b) internal returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function safeAdd(uint256 a, uint256 b) internal returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c>=a && c>=b);\r\n    return c;\r\n  }\r\n\r\n  function assert(bool assertion) internal {\r\n    if (!assertion) {\r\n      throw;\r\n    }\r\n  }\r\n}\r\n\r\n/* \r\n*  BOSTokenCrowdfund contract\r\n*  Funds sent to this address transfer a customized ERC20 token to msg.sender for the duration of the crowdfund\r\n*  Deployment order:\r\n*  1. BOSToken, BOSTokenCrowdfund\r\n*  2. Send tokens to this\r\n*  3. -- crowdfund is open --\r\n*/\r\ncontract BOSTokenCrowdfund is owned, SafeMath {\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n\r\n    /**\r\n     * check only allowPublicWithdraw\r\n     */\r\n    modifier onlyAllowPublicWithdraw() { \r\n        require (allowPublicWithdraw); \r\n        _; \r\n    }\r\n\r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    /* 0.000004 ETH per token base price */\r\n    uint public sellPrice = 0.000004 ether;\r\n    /* total amount of ether raised */\r\n    uint public amountRaised;\r\n    /* address of token used as reward */\r\n    token public tokenReward;\r\n    /* crowdsale is open */\r\n    bool public crowdsaleClosed = false;\r\n    /* map balance of address */\r\n    mapping (address => uint) public balanceOf;\r\n    /* allow public withdraw */\r\n    bool public allowPublicWithdraw = false;\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    /* log events */\r\n    event LogFundTransfer(address indexed Backer, uint indexed Amount, bool indexed IsContribution);\r\n\r\n    /*\r\n     *  @param _fundingGoalInEthers the funding goal of the crowdfund\r\n     *  @param _durationInMinutes the length of the crowdfund in minutes\r\n     *  @param _addressOfTokenUsedAsReward the token address   \r\n     */  \r\n    function BOSTokenCrowdfund(\r\n        /* token */\r\n        token _addressOfTokenUsedAsReward\r\n    ) {\r\n        tokenReward = token(_addressOfTokenUsedAsReward);\r\n    }\r\n\r\n    /*\r\n     *  @notice public function\r\n     *  default function is payable\r\n     *  responsible for transfer of tokens based on price, msg.sender and msg.value\r\n     *  tracks investment total of msg.sender\r\n     *  refunds any spare change\r\n     */      \r\n    function () payable\r\n    {\r\n        require (!crowdsaleClosed);\r\n        /* do not allow creating 0 */\r\n        require (msg.value > 0);\r\n\r\n        uint tokens = SafeMath.safeMul(SafeMath.safeDiv(msg.value, sellPrice), 1 ether);\r\n        if(tokenReward.transfer(msg.sender, tokens)) {\r\n            LogFundTransfer(msg.sender, msg.value, true); \r\n        } else {\r\n            throw;\r\n        }\r\n\r\n        /* add to amountRaised */\r\n        amountRaised = SafeMath.safeAdd(amountRaised, msg.value);\r\n        /* track ETH balanceOf address in case emergency refund is required */\r\n        balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], msg.value);\r\n    }\r\n\r\n    /*\r\n     *  @notice public function\r\n     *  emergency manual refunds\r\n     */     \r\n    function publicWithdraw() public\r\n        onlyAllowPublicWithdraw\r\n    {\r\n        /* manual refunds */\r\n        calcRefund(msg.sender);\r\n    }\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n    /*\r\n     *  @notice internal function\r\n     *  @param _addressToRefund the address being refunded\r\n     *  accessed via public functions publicWithdraw\r\n     *  calculates refund amount available for an address\r\n     */\r\n    function calcRefund(address _addressToRefund) internal\r\n    {\r\n        /* assigns var amount to balance of _addressToRefund */\r\n        uint amount = balanceOf[_addressToRefund];\r\n        /* sets balance to 0 */\r\n        balanceOf[_addressToRefund] = 0;\r\n        /* is there any balance? */\r\n        if (amount > 0) {\r\n            /* call to untrusted address */\r\n            _addressToRefund.transfer(amount);\r\n            /* log event */\r\n            LogFundTransfer(_addressToRefund, amount, false);\r\n        }\r\n    }\r\n\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    /*\r\n     *  @notice public function\r\n     *  onlyOwner\r\n     *  moves ether to _to address\r\n     */\r\n    function withdrawAmountTo (uint256 _amount, address _to) public\r\n        onlyOwner\r\n    {\r\n        _to.transfer(_amount);\r\n        LogFundTransfer(_to, _amount, false);\r\n    }\r\n\r\n    /**\r\n     *  @notice owner restricted function\r\n     *  @param status boolean\r\n     *  sets contract crowdsaleClosed\r\n     */\r\n    function ownerSetCrowdsaleClosed (bool status) public onlyOwner\r\n    {\r\n        crowdsaleClosed = status;\r\n    }\r\n\r\n    /**\r\n     *  @notice owner restricted function\r\n     *  @param status boolean\r\n     *  sets contract allowPublicWithdraw\r\n     */\r\n    function ownerSetAllowPublicWithdraw (bool status) public onlyOwner\r\n    {\r\n        allowPublicWithdraw = status;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowPublicWithdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"ownerSetCrowdsaleClosed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"ownerSetAllowPublicWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"ownerTransferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawAmountTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"publicWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_addressOfTokenUsedAsReward\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"Backer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"Amount\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"IsContribution\",\"type\":\"bool\"}],\"name\":\"LogFundTransfer\",\"type\":\"event\"}]","ContractName":"BOSTokenCrowdfund","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000dcf5b6b8569e2a7f5d74c8a44f9ec3fee0b23b42","Library":"","SwarmSource":"bzzr://0d8af37b2a4683db243f1d967e9b8fa9b72c5c633b2760fb0efd47508012f1f0"}]}