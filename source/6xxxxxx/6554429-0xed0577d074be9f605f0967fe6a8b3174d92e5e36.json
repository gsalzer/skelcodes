{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n *\r\n * @author Maciek Zielinski & Radek Ostrowski - https://startonchain.com\r\n * @author Alex George - https://dexbrokerage.com\r\n *\r\n*/\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // require(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev a to power of b, throws on overflow.\r\n  */\r\n  function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a ** b;\r\n    require(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract DexBrokerage is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  address public feeAccount;\r\n  uint256 public makerFee;\r\n  uint256 public takerFee;\r\n  uint256 public inactivityReleasePeriod;\r\n  mapping (address => bool) public approvedCurrencyTokens;\r\n  mapping (address => uint256) public invalidOrder;\r\n  mapping (address => mapping (address => uint256)) public tokens;\r\n  mapping (address => bool) public admins;\r\n  mapping (address => uint256) public lastActiveTransaction;\r\n  mapping (bytes32 => uint256) public orderFills;\r\n  mapping (bytes32 => bool) public withdrawn;\r\n\r\n  event Trade(address tokenBuy, uint256 amountBuy, address tokenSell, uint256 amountSell, address maker, address taker);\r\n  event Deposit(address token, address user, uint256 amount, uint256 balance);\r\n  event Withdraw(address token, address user, uint256 amount, uint256 balance);\r\n  event MakerFeeUpdated(uint256 oldFee, uint256 newFee);\r\n  event TakerFeeUpdated(uint256 oldFee, uint256 newFee);\r\n\r\n  modifier onlyAdmin {\r\n    require(msg.sender == owner || admins[msg.sender]);\r\n    _;\r\n  }\r\n\r\n  constructor(uint256 _makerFee, uint256 _takerFee , address _feeAccount, uint256 _inactivityReleasePeriod) public {\r\n    owner = msg.sender;\r\n    makerFee = _makerFee;\r\n    takerFee = _takerFee;\r\n    feeAccount = _feeAccount;\r\n    inactivityReleasePeriod = _inactivityReleasePeriod;\r\n  }\r\n\r\n  function approveCurrencyTokenAddress(address currencyTokenAddress, bool isApproved) onlyAdmin public {\r\n    approvedCurrencyTokens[currencyTokenAddress] = isApproved;\r\n  }\r\n\r\n  function invalidateOrdersBefore(address user, uint256 nonce) onlyAdmin public {\r\n    require(nonce >= invalidOrder[user]);\r\n    invalidOrder[user] = nonce;\r\n  }\r\n\r\n  function setMakerFee(uint256 _makerFee) onlyAdmin public {\r\n    //market maker fee will never be more than 1%\r\n    uint256 oldFee = makerFee;\r\n    if (_makerFee > 10 finney) {\r\n      _makerFee = 10 finney;\r\n    }\r\n    require(makerFee != _makerFee);\r\n    makerFee = _makerFee;\r\n    emit MakerFeeUpdated(oldFee, makerFee);\r\n  }\r\n\r\n  function setTakerFee(uint256 _takerFee) onlyAdmin public {\r\n    //market taker fee will never be more than 2%\r\n    uint256 oldFee = takerFee;\r\n    if (_takerFee > 20 finney) {\r\n      _takerFee = 20 finney;\r\n    }\r\n    require(takerFee != _takerFee);\r\n    takerFee = _takerFee;\r\n    emit TakerFeeUpdated(oldFee, takerFee);\r\n  }\r\n\r\n  function setInactivityReleasePeriod(uint256 expire) onlyAdmin public returns (bool) {\r\n    require(expire <= 50000);\r\n    inactivityReleasePeriod = expire;\r\n    return true;\r\n  }\r\n\r\n  function setAdmin(address admin, bool isAdmin) onlyOwner public {\r\n    admins[admin] = isAdmin;\r\n  }\r\n\r\n  function depositToken(address token, uint256 amount) public {\r\n    receiveTokenDeposit(token, msg.sender, amount);\r\n  }\r\n\r\n  function receiveTokenDeposit(address token, address from, uint256 amount) public {\r\n    tokens[token][from] = tokens[token][from].add(amount);\r\n    lastActiveTransaction[from] = block.number;\r\n    require(ERC20(token).transferFrom(from, address(this), amount));\r\n    emit Deposit(token, from, amount, tokens[token][from]);\r\n  }\r\n\r\n  function deposit() payable public {\r\n    tokens[address(0)][msg.sender] = tokens[address(0)][msg.sender].add(msg.value);\r\n    lastActiveTransaction[msg.sender] = block.number;\r\n    emit Deposit(address(0), msg.sender, msg.value, tokens[address(0)][msg.sender]);\r\n  }\r\n\r\n  function withdraw(address token, uint256 amount) public returns (bool) {\r\n    require(block.number.sub(lastActiveTransaction[msg.sender]) >= inactivityReleasePeriod);\r\n    require(tokens[token][msg.sender] >= amount);\r\n    tokens[token][msg.sender] = tokens[token][msg.sender].sub(amount);\r\n    if (token == address(0)) {\r\n      msg.sender.transfer(amount);\r\n    } else {\r\n      require(ERC20(token).transfer(msg.sender, amount));\r\n    }\r\n    emit Withdraw(token, msg.sender, amount, tokens[token][msg.sender]);\r\n    return true;\r\n  }\r\n\r\n  function adminWithdraw(address token, uint256 amount, address user, uint256 nonce, uint8 v, bytes32 r, bytes32 s, uint256 gasCost) onlyAdmin public returns (bool) {\r\n    //gasCost will never be more than 30 finney\r\n    if (gasCost > 30 finney) gasCost = 30 finney;\r\n\r\n    if(token == address(0)){\r\n      require(tokens[address(0)][user] >= gasCost.add(amount));\r\n    } else {\r\n      require(tokens[address(0)][user] >= gasCost);\r\n      require(tokens[token][user] >= amount);\r\n    }\r\n\r\n    bytes32 hash = keccak256(address(this), token, amount, user, nonce);\r\n    require(!withdrawn[hash]);\r\n    withdrawn[hash] = true;\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user);\r\n\r\n    if(token == address(0)){\r\n      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost.add(amount));\r\n      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\r\n      user.transfer(amount);\r\n    } else {\r\n      tokens[token][user] = tokens[token][user].sub(amount);\r\n      tokens[address(0)][user] = tokens[address(0)][user].sub(gasCost);\r\n      tokens[address(0)][feeAccount] = tokens[address(0)][feeAccount].add(gasCost);\r\n      require(ERC20(token).transfer(user, amount));\r\n    }\r\n    lastActiveTransaction[user] = block.number;\r\n    emit Withdraw(token, user, amount, tokens[token][user]);\r\n    return true;\r\n  }\r\n\r\n  function balanceOf(address token, address user) view public returns (uint256) {\r\n    return tokens[token][user];\r\n  }\r\n\r\n    /* tradeValues\r\n       [0] amountBuy\r\n       [1] amountSell\r\n       [2] makerNonce\r\n       [3] takerAmountBuy\r\n       [4] takerAmountSell\r\n       [5] takerExpires\r\n       [6] takerNonce\r\n       [7] makerAmountBuy\r\n       [8] makerAmountSell\r\n       [9] makerExpires\r\n       [10] gasCost\r\n     tradeAddressses\r\n       [0] tokenBuy\r\n       [1] tokenSell\r\n       [2] maker\r\n       [3] taker\r\n     */\r\n\r\n\r\n  function trade(uint256[11] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) onlyAdmin public returns (bool) {\r\n    uint256 price = tradeValues[0].mul(1 ether).div(tradeValues[1]);\r\n    require(price >= tradeValues[7].mul(1 ether).div(tradeValues[8]).sub(100000 wei));\r\n    require(price <= tradeValues[4].mul(1 ether).div(tradeValues[3]).add(100000 wei));\r\n    require(block.number < tradeValues[9]);\r\n    require(block.number < tradeValues[5]);\r\n    require(invalidOrder[tradeAddresses[2]] <= tradeValues[2]);\r\n    require(invalidOrder[tradeAddresses[3]] <= tradeValues[6]);\r\n    bytes32 orderHash = keccak256(address(this), tradeAddresses[0], tradeValues[7], tradeAddresses[1], tradeValues[8], tradeValues[9], tradeValues[2], tradeAddresses[2]);\r\n    bytes32 tradeHash = keccak256(address(this), tradeAddresses[1], tradeValues[3], tradeAddresses[0], tradeValues[4], tradeValues[5], tradeValues[6], tradeAddresses[3]);\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", orderHash), v[0], rs[0], rs[1]) == tradeAddresses[2]);\r\n    require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", tradeHash), v[1], rs[2], rs[3]) == tradeAddresses[3]);\r\n    require(tokens[tradeAddresses[0]][tradeAddresses[3]] >= tradeValues[0]);\r\n    require(tokens[tradeAddresses[1]][tradeAddresses[2]] >= tradeValues[1]);\r\n    if ((tradeAddresses[0] == address(0) || tradeAddresses[1] == address(0)) && tradeValues[10] > 30 finney) tradeValues[10] = 30 finney;\r\n    if ((approvedCurrencyTokens[tradeAddresses[0]] == true || approvedCurrencyTokens[tradeAddresses[1]] == true) && tradeValues[10] > 10 ether) tradeValues[10] = 10 ether;\r\n\r\n    if(tradeAddresses[0] == address(0) || approvedCurrencyTokens[tradeAddresses[0]] == true){\r\n\r\n      require(orderFills[orderHash].add(tradeValues[1]) <= tradeValues[8]);\r\n      require(orderFills[tradeHash].add(tradeValues[1]) <= tradeValues[3]);\r\n\r\n      //tradeAddresses[0] is ether\r\n      uint256 valueInTokens = tradeValues[1];\r\n\r\n      //move tokens\r\n      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(valueInTokens);\r\n      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].add(valueInTokens);\r\n\r\n      //from taker, take ether payment, fee and gasCost\r\n      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[0]);\r\n      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(takerFee.mul(tradeValues[0]).div(1 ether));\r\n      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[10]);\r\n\r\n      //to maker add ether payment, take fee\r\n      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].add(tradeValues[0]);\r\n      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].sub(makerFee.mul(tradeValues[0]).div(1 ether));\r\n\r\n      // take maker fee, taker fee and gasCost\r\n      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(makerFee.mul(tradeValues[0]).div(1 ether));\r\n      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(takerFee.mul(tradeValues[0]).div(1 ether));\r\n      tokens[tradeAddresses[0]][feeAccount] = tokens[tradeAddresses[0]][feeAccount].add(tradeValues[10]);\r\n\r\n      orderFills[orderHash] = orderFills[orderHash].add(tradeValues[1]);\r\n      orderFills[tradeHash] = orderFills[tradeHash].add(tradeValues[1]);\r\n\r\n    } else {\r\n\r\n      require(orderFills[orderHash].add(tradeValues[0]) <= tradeValues[7]);\r\n      require(orderFills[tradeHash].add(tradeValues[0]) <= tradeValues[4]);\r\n\r\n      //tradeAddresses[0] is token\r\n      uint256 valueInEth = tradeValues[1];\r\n\r\n      //move tokens //changed tradeValues to 0\r\n      tokens[tradeAddresses[0]][tradeAddresses[3]] = tokens[tradeAddresses[0]][tradeAddresses[3]].sub(tradeValues[0]);\r\n      tokens[tradeAddresses[0]][tradeAddresses[2]] = tokens[tradeAddresses[0]][tradeAddresses[2]].add(tradeValues[0]);\r\n\r\n      //from maker, take ether payment and fee\r\n      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(valueInEth);\r\n      tokens[tradeAddresses[1]][tradeAddresses[2]] = tokens[tradeAddresses[1]][tradeAddresses[2]].sub(makerFee.mul(valueInEth).div(1 ether));\r\n\r\n      //add ether payment to taker, take fee, take gasCost\r\n      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].add(valueInEth);\r\n      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].sub(takerFee.mul(valueInEth).div(1 ether));\r\n      tokens[tradeAddresses[1]][tradeAddresses[3]] = tokens[tradeAddresses[1]][tradeAddresses[3]].sub(tradeValues[10]);\r\n\r\n      //take maker fee, taker fee and gasCost\r\n      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(makerFee.mul(valueInEth).div(1 ether));\r\n      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(takerFee.mul(valueInEth).div(1 ether));\r\n      tokens[tradeAddresses[1]][feeAccount] = tokens[tradeAddresses[1]][feeAccount].add(tradeValues[10]);\r\n\r\n      orderFills[orderHash] = orderFills[orderHash].add(tradeValues[0]);\r\n      orderFills[tradeHash] = orderFills[tradeHash].add(tradeValues[0]);\r\n    }\r\n\r\n    lastActiveTransaction[tradeAddresses[2]] = block.number;\r\n    lastActiveTransaction[tradeAddresses[3]] = block.number;\r\n\r\n    emit Trade(tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeAddresses[2], tradeAddresses[3]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract OptionFactory is Ownable {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => bool) public admins;\r\n    mapping(uint \r\n        => mapping(address \r\n            => mapping(address \r\n                => mapping(uint\r\n                    => mapping(bool\r\n                        => mapping(uint8 \r\n                            => OptionToken)))))) register;\r\n\r\n    DexBrokerage public exchangeContract;\r\n    ERC20        public dexb;\r\n    uint         public dexbTreshold;\r\n    address      public dexbAddress;\r\n\r\n    // Fees for all.\r\n    uint public issueFee;\r\n    uint public executeFee;\r\n    uint public cancelFee;\r\n\r\n    // Fees for DEXB holders.\r\n    uint public dexbIssueFee;\r\n    uint public dexbExecuteFee;\r\n    uint public dexbCancelFee;\r\n\r\n    // Value represents 100%\r\n    uint public HUNDERED_PERCENT = 100000;\r\n\r\n    // Max fee is 1%\r\n    uint public MAX_FEE = HUNDERED_PERCENT.div(100);\r\n\r\n    constructor(address _dexbAddress, uint _dexbTreshold, address _dexBrokerageAddress) public {\r\n        dexbAddress      = _dexbAddress;\r\n        dexb             = ERC20(_dexbAddress);\r\n        dexbTreshold     = _dexbTreshold;\r\n        exchangeContract = DexBrokerage(_dexBrokerageAddress);\r\n\r\n        // Set fee for everyone to 0.3%\r\n        setIssueFee(300);\r\n        setExecuteFee(300);\r\n        setCancelFee(300);\r\n\r\n        // Set fee for DEXB holders to 0.2%\r\n        setDexbIssueFee(200);\r\n        setDexbExecuteFee(200);\r\n        setDexbCancelFee(200);\r\n    }\r\n\r\n\r\n    function getOptionAddress(\r\n        uint expiryDate, \r\n        address firstToken, \r\n        address secondToken, \r\n        uint strikePrice,\r\n        bool isCall,\r\n        uint8 decimals) public view returns (address) {\r\n        \r\n        return address(register[expiryDate][firstToken][secondToken][strikePrice][isCall][decimals]);\r\n    }\r\n\r\n    function createOption(\r\n        uint expiryDate, \r\n        address firstToken, \r\n        address secondToken, \r\n        uint minIssueAmount,\r\n        uint strikePrice,\r\n        bool isCall,\r\n        uint8 decimals,\r\n        string name) public {\r\n\r\n        require(address(0) == getOptionAddress(\r\n            expiryDate, firstToken, secondToken, strikePrice, isCall, decimals    \r\n        ));\r\n\r\n        OptionToken newOption = new OptionToken(\r\n            this,\r\n            firstToken,\r\n            secondToken,\r\n            minIssueAmount,\r\n            expiryDate,\r\n            strikePrice,\r\n            isCall,\r\n            name,\r\n            decimals\r\n        );\r\n\r\n        register[expiryDate][firstToken][secondToken]\r\n            [strikePrice][isCall][decimals] = newOption;\r\n    }\r\n\r\n    modifier validFeeOnly(uint fee) { \r\n        require (fee <= MAX_FEE); \r\n        _;\r\n    }\r\n    \r\n    modifier onlyAdmin {\r\n        require(msg.sender == owner || admins[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function setAdmin(address admin, bool isAdmin) onlyOwner public {\r\n        admins[admin] = isAdmin;\r\n    }\r\n\r\n    function setIssueFee(uint fee) public onlyAdmin validFeeOnly(fee) {\r\n        issueFee = fee;\r\n    }\r\n\r\n    function setExecuteFee(uint fee) public onlyAdmin validFeeOnly(fee) {\r\n        executeFee = fee;\r\n    }\r\n\r\n    function setCancelFee(uint fee) public onlyAdmin validFeeOnly(fee) {\r\n        cancelFee = fee;\r\n    }\r\n\r\n    function setDexbIssueFee(uint fee) public onlyAdmin validFeeOnly(fee) {\r\n        dexbIssueFee = fee;\r\n    }\r\n\r\n    function setDexbExecuteFee(uint fee) public onlyAdmin validFeeOnly(fee) {\r\n        dexbExecuteFee = fee;\r\n    }\r\n\r\n    function setDexbCancelFee(uint fee) public onlyAdmin validFeeOnly(fee) {\r\n        dexbCancelFee = fee;\r\n    }\r\n\r\n    function setDexbTreshold(uint treshold) public onlyAdmin {\r\n        dexbTreshold = treshold;\r\n    }\r\n\r\n    function calcIssueFeeAmount(address user, uint value) public view returns (uint) {\r\n        uint feeLevel = getFeeLevel(user, dexbIssueFee, issueFee);\r\n        return calcFee(feeLevel, value);\r\n    }\r\n\r\n    function calcExecuteFeeAmount(address user, uint value) public view returns (uint) {\r\n        uint feeLevel = getFeeLevel(user, dexbExecuteFee, executeFee);\r\n        return calcFee(feeLevel, value);\r\n    }\r\n\r\n    function calcCancelFeeAmount(address user, uint value) public view returns (uint) {\r\n        uint feeLevel = getFeeLevel(user, dexbCancelFee, cancelFee);\r\n        return calcFee(feeLevel, value);\r\n    }\r\n\r\n    function getFeeLevel(address user, uint aboveTresholdFee, uint belowTresholdFee) internal view returns (uint) {\r\n        if(dexb.balanceOf(user) + exchangeContract.balanceOf(dexbAddress, user) >= dexbTreshold){\r\n            return aboveTresholdFee;\r\n        } else {\r\n            return belowTresholdFee;\r\n        }\r\n    }\r\n\r\n    function calcFee(uint feeLevel, uint value) internal view returns (uint) {\r\n        return value.mul(feeLevel).div(HUNDERED_PERCENT);\r\n    }\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  // ------------------------------------------------------------------------\r\n  // Token owner can approve for `_exchange` to transferFrom(...) `_amount` of\r\n  // tokens from the owner's account. The `_exchange` contract function\r\n  // `receiveTokenDeposit(...)` is then executed\r\n  // ------------------------------------------------------------------------\r\n\r\n function approveAndDeposit(DexBrokerage _exchange, uint _amount) public returns (bool success) {\r\n    allowed[msg.sender][_exchange] = _amount;\r\n    emit Approval(msg.sender, _exchange, _amount);\r\n    _exchange.receiveTokenDeposit(address(this), msg.sender, _amount);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract OptionToken is StandardToken {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    OptionFactory public factory;\r\n    ERC20  public firstToken;\r\n    ERC20  public secondToken;\r\n    uint   public minIssueAmount;\r\n    uint   public expiry;\r\n    uint   public strikePrice;\r\n    bool   public isCall;\r\n    string public symbol;\r\n    uint  public decimals;\r\n\r\n    struct Issuer {\r\n        address addr;\r\n        uint amount;\r\n    }\r\n\r\n    Issuer[] internal issuers;\r\n\r\n    constructor(\r\n        address _factory,\r\n        address _firstToken,\r\n        address _secondToken,\r\n        uint    _minIssueAmount,\r\n        uint    _expiry,\r\n        uint    _strikePrice,\r\n        bool    _isCall,\r\n        string  _symbol,\r\n        uint8   _decimals) public {\r\n\r\n        require (_firstToken != _secondToken, 'Tokens should be different.');\r\n\r\n        factory        = OptionFactory(_factory);\r\n        firstToken     = ERC20(_firstToken);\r\n        secondToken    = ERC20(_secondToken);\r\n        minIssueAmount = _minIssueAmount;\r\n        expiry         = _expiry;\r\n        strikePrice    = _strikePrice;\r\n        isCall         = _isCall;\r\n        symbol         = _symbol;\r\n        decimals       = uint(_decimals);\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(factory.admins(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /** Public API */\r\n\r\n    function setMinIssueAmount(uint minAmount) onlyAdmin public  {\r\n        minIssueAmount = minAmount;\r\n    }\r\n\r\n    function issueWithToken(uint amount) public beforeExpiry canIssueWithToken returns (bool) {\r\n        require(amount >= minIssueAmount);\r\n        uint fee = factory.calcIssueFeeAmount(msg.sender, amount);\r\n        uint amountWithoutFee = amount - fee;\r\n        transferTokensInOnIssue(amountWithoutFee, fee);\r\n        issue(amountWithoutFee);\r\n        return true;\r\n    }\r\n\r\n    function issueWithWei() public payable beforeExpiry canIssueWithWei returns (bool) {\r\n        require(msg.value >= minIssueAmount);\r\n        uint fee = factory.calcIssueFeeAmount(msg.sender, msg.value);\r\n        uint amountWithoutFee = msg.value - fee;\r\n        factory.owner().transfer(fee);\r\n        if(isCall){\r\n            issue(amountWithoutFee);\r\n        } else {\r\n            uint amount = amountWithoutFee.mul(uint(10).pow(decimals)).div(strikePrice);\r\n            issue(amount);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function executeWithToken(uint amount) public beforeExpiry canExecuteWithToken returns (bool) {\r\n        transferTokensInOnExecute(amount);\r\n        execute(amount);\r\n        return true;\r\n    }\r\n\r\n    function executeWithWei() public payable beforeExpiry canExecuteWithWei {\r\n        if(isCall){\r\n            uint amount = msg.value.mul(uint(10).pow(decimals)).div(strikePrice);\r\n            execute(amount);\r\n        } else {\r\n            execute(msg.value);\r\n        }\r\n    }\r\n\r\n    function cancel(uint amount) public beforeExpiry {\r\n        burn(msg.sender, amount);\r\n        bool found = false;\r\n        for (uint i = 0; i < issuers.length; i++) {\r\n            if(issuers[i].addr == msg.sender) {\r\n                found = true;\r\n                issuers[i].amount = issuers[i].amount.sub(amount);\r\n                transferTokensOrWeiOutToIssuerOnCancel(amount);\r\n                break;\r\n            }\r\n        }\r\n        require(found);\r\n    }\r\n\r\n    function refund() public afterExpiry {\r\n        // Distribute tokens or wei to issuers.\r\n        for(uint i = 0; i < issuers.length; i++) {\r\n            if(issuers[i].amount > 0){\r\n                transferTokensOrWeiOutToIssuerOnRefund(issuers[i].addr, issuers[i].amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    /** Internal API */\r\n    function transferTokensInOnIssue(uint amountForContract, uint feeAmount) internal returns (bool) {\r\n        ERC20 token;\r\n        uint toTransferIntoContract;\r\n        uint toTransferFee;\r\n        if(isCall){\r\n            token = firstToken;\r\n            toTransferIntoContract = amountForContract;\r\n            toTransferFee = feeAmount;\r\n        } else {\r\n            token = secondToken;\r\n            toTransferIntoContract = strikePrice.mul(amountForContract).div(uint(10).pow(decimals));\r\n            toTransferFee = strikePrice.mul(feeAmount).div(uint(10).pow(decimals));\r\n        }\r\n        require(token != address(0));\r\n        require(transferTokensIn(token, toTransferIntoContract + toTransferFee));\r\n        require(transferTokensToOwner(token, toTransferFee));\r\n        return true;\r\n    }\r\n\r\n    function transferTokensInOnExecute(uint amount) internal returns (bool) {\r\n        ERC20 token;\r\n        uint toTransfer;\r\n        if(isCall){\r\n            token = secondToken;\r\n            toTransfer = strikePrice.mul(amount).div(uint(10).pow(decimals));\r\n        } else {\r\n            token = firstToken;\r\n            toTransfer = amount;\r\n        }\r\n        require(token != address(0));\r\n        require(transferTokensIn(token, toTransfer));\r\n        return true;\r\n    }\r\n\r\n    function transferTokensIn(ERC20 token, uint amount) internal returns (bool) {\r\n        require(token.transferFrom(msg.sender, this, amount));\r\n        return true;\r\n    }\r\n\r\n    function transferTokensToOwner(ERC20 token, uint amount) internal returns (bool) {\r\n        require(token.transfer(factory.owner(), amount));\r\n        return true;\r\n    }\r\n\r\n    function transfer(ERC20 token, uint amount) internal returns (bool) {\r\n        require(token.transferFrom(msg.sender, factory.owner(), amount));\r\n        return true;\r\n    }\r\n    function issue(uint amount) internal returns (bool){\r\n        mint(msg.sender, amount);\r\n        bool found = false;\r\n        for (uint i = 0; i < issuers.length; i++) {\r\n            if(issuers[i].addr == msg.sender) {\r\n                issuers[i].amount = issuers[i].amount.add(amount);\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        if(!found) {\r\n            issuers.push(Issuer(msg.sender, amount));\r\n        }\r\n    }\r\n\r\n    function mint(address to, uint amount) internal returns (bool) {\r\n        totalSupply_ = totalSupply_.add(amount);\r\n        balances[to] = balances[to].add(amount);\r\n        emit Transfer(address(0), to, amount);\r\n        return true;\r\n    }\r\n\r\n    function execute(uint amount) internal returns (bool) {\r\n        burn(msg.sender, amount);\r\n        transferTokensOrWeiOutToSenderOnExecute(amount);\r\n        // Distribute tokens to issuers.\r\n        uint amountToDistribute = amount;\r\n        uint i = issuers.length - 1;\r\n        while(amountToDistribute > 0){\r\n            if(issuers[i].amount > 0){\r\n                if(issuers[i].amount >= amountToDistribute){\r\n                    transferTokensOrWeiOutToIssuerOnExecute(issuers[i].addr, amountToDistribute);\r\n                    issuers[i].amount = issuers[i].amount.sub(amountToDistribute);\r\n                    amountToDistribute = 0;\r\n                } else {\r\n                    transferTokensOrWeiOutToIssuerOnExecute(issuers[i].addr, issuers[i].amount);\r\n                    amountToDistribute = amountToDistribute.sub(issuers[i].amount);\r\n                    issuers[i].amount = 0;\r\n                }\r\n            }\r\n            i = i - 1;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferTokensOrWeiOutToSenderOnExecute(uint amount) internal returns (bool) {\r\n        ERC20 token;\r\n        uint toTransfer = 0;\r\n        if(isCall){\r\n            token = firstToken;\r\n            toTransfer = amount;\r\n        } else {\r\n            token = secondToken;\r\n            toTransfer = strikePrice.mul(amount).div(uint(10).pow(decimals));\r\n        }\r\n        uint fee = factory.calcExecuteFeeAmount(msg.sender, toTransfer);\r\n        toTransfer = toTransfer - fee;\r\n        if(token == address(0)){\r\n            require(msg.sender.send(toTransfer));\r\n            if(fee > 0){\r\n                require(factory.owner().send(fee));\r\n            }\r\n        } else {\r\n            require(token.transfer(msg.sender, toTransfer));\r\n            if(fee > 0){\r\n                require(token.transfer(factory.owner(), fee));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function transferTokensOrWeiOutToIssuerOnExecute(address issuer, uint amount) internal returns (bool) {\r\n        ERC20 token;\r\n        uint toTransfer;\r\n        if(isCall){\r\n            token = secondToken;\r\n            toTransfer = strikePrice.mul(amount).div(uint(10).pow(decimals));\r\n        } else {\r\n            token = firstToken;\r\n            toTransfer = amount;\r\n        }\r\n        if(token == address(0)){\r\n            require(issuer.send(toTransfer));\r\n        } else {\r\n            require(token.transfer(issuer, toTransfer));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    function burn(address from, uint256 amount) internal returns (bool) {\r\n        require(amount <= balances[from]);\r\n        balances[from] = balances[from].sub(amount);\r\n        totalSupply_ = totalSupply_.sub(amount);\r\n        emit Transfer(from, address(0), amount);\r\n        return true;\r\n    }\r\n\r\n    function transferTokensOrWeiOutToIssuerOnCancel(uint amount) internal returns (bool){\r\n        ERC20 token;\r\n        uint toTransfer = 0;\r\n        if(isCall){\r\n            token = firstToken;\r\n            toTransfer = amount;\r\n        } else {\r\n            token = secondToken;\r\n            toTransfer = strikePrice.mul(amount).div(uint(10).pow(decimals));\r\n        }\r\n        uint fee = factory.calcCancelFeeAmount(msg.sender, toTransfer);\r\n        toTransfer = toTransfer - fee;\r\n        if(token == address(0)){\r\n            require(msg.sender.send(toTransfer));\r\n            if(fee > 0){\r\n                require(factory.owner().send(fee));\r\n            }\r\n        } else {\r\n            require(token.transfer(msg.sender, toTransfer));\r\n            if(fee > 0){\r\n                require(token.transfer(factory.owner(), fee));\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n\r\n    function transferTokensOrWeiOutToIssuerOnRefund(address issuer, uint amount) internal returns (bool){\r\n        ERC20 token;\r\n        uint toTransfer = 0;\r\n        if(isCall){\r\n            token = firstToken;\r\n            toTransfer = amount;\r\n        } else {\r\n            token = secondToken;\r\n            toTransfer = strikePrice.mul(amount).div(uint(10).pow(decimals));\r\n        }\r\n        if(token == address(0)){\r\n            issuer.transfer(toTransfer);\r\n        } else {\r\n            require(token.transfer(issuer, toTransfer));\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /** Modifiers */\r\n    modifier canIssueWithWei() {\r\n        require(\r\n            (isCall  && firstToken == address(0)) ||\r\n            (!isCall && secondToken == address(0))\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canIssueWithToken() {\r\n        require(\r\n            (isCall  && firstToken != address(0)) ||\r\n            (!isCall && secondToken != address(0))\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canExecuteWithWei() {\r\n        require(\r\n            (isCall  && secondToken == address(0)) ||\r\n            (!isCall && firstToken == address(0))\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canExecuteWithToken() {\r\n        require(\r\n            (isCall  && secondToken != address(0)) ||\r\n            (!isCall && firstToken != address(0))\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier beforeExpiry() {\r\n        require (now <= expiry);\r\n        _;\r\n    }\r\n\r\n    modifier afterExpiry() {\r\n        require (now > expiry);\r\n        _;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"dexbTreshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexbIssueFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexbExecuteFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cancelFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setIssueFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setExecuteFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calcExecuteFeeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setDexbCancelFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"name\":\"firstToken\",\"type\":\"address\"},{\"name\":\"secondToken\",\"type\":\"address\"},{\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"name\":\"isCall\",\"type\":\"bool\"},{\"name\":\"decimals\",\"type\":\"uint8\"}],\"name\":\"getOptionAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"admin\",\"type\":\"address\"},{\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calcIssueFeeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HUNDERED_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"treshold\",\"type\":\"uint256\"}],\"name\":\"setDexbTreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexbAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"calcCancelFeeAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setDexbIssueFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexbCancelFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setCancelFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"name\":\"setDexbExecuteFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"executeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dexb\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expiryDate\",\"type\":\"uint256\"},{\"name\":\"firstToken\",\"type\":\"address\"},{\"name\":\"secondToken\",\"type\":\"address\"},{\"name\":\"minIssueAmount\",\"type\":\"uint256\"},{\"name\":\"strikePrice\",\"type\":\"uint256\"},{\"name\":\"isCall\",\"type\":\"bool\"},{\"name\":\"decimals\",\"type\":\"uint8\"},{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"createOption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_dexbAddress\",\"type\":\"address\"},{\"name\":\"_dexbTreshold\",\"type\":\"uint256\"},{\"name\":\"_dexBrokerageAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OptionFactory","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000428c69d0a92474e2fca30f2d0a61c2ccf5ef815700000000000000000000000000000000000000000000003635c9adc5dea0000000000000000000000000000041a5b8aa081dcd69ace566061d5b6adcb92cae1c","Library":"","SwarmSource":"bzzr://1bb6890bee9832d1eb31f45846a466721c8e63134765e73f3e9f788e0904693b"}]}