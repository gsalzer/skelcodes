{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title -NFTs crowdsale\r\n * NFTsCrowdsale provides a marketplace for NFTs\r\n *\r\n *  ██████╗ ██████╗   ██████╗  ██╗    ██╗ ██████╗  ███████╗  █████╗  ██╗      ███████╗ ██╗\r\n * ██╔════╝ ██╔══██╗ ██╔═══██╗ ██║    ██║ ██╔══██╗ ██╔════╝ ██╔══██╗ ██║      ██╔════╝ ██║\r\n * ██║      ██████╔╝ ██║   ██║ ██║ █╗ ██║ ██║  ██║ ███████╗ ███████║ ██║      █████╗   ██║\r\n * ██║      ██╔══██╗ ██║   ██║ ██║███╗██║ ██║  ██║ ╚════██║ ██╔══██║ ██║      ██╔══╝   ╚═╝\r\n * ╚██████╗ ██║  ██║ ╚██████╔╝ ╚███╔███╔╝ ██████╔╝ ███████║ ██║  ██║ ███████╗ ███████╗ ██╗\r\n *  ╚═════╝ ╚═╝  ╚═╝  ╚═════╝   ╚══╝╚══╝  ╚═════╝  ╚══════╝ ╚═╝  ╚═╝ ╚══════╝ ╚══════╝ ╚═╝\r\n *\r\n * ---\r\n * POWERED BY\r\n * ╦   ╔═╗ ╦═╗ ╔╦╗ ╦   ╔═╗ ╔═╗ ╔═╗      ╔╦╗ ╔═╗ ╔═╗ ╔╦╗\r\n * ║   ║ ║ ╠╦╝  ║║ ║   ║╣  ╚═╗ ╚═╗       ║  ║╣  ╠═╣ ║║║\r\n * ╩═╝ ╚═╝ ╩╚═ ═╩╝ ╩═╝ ╚═╝ ╚═╝ ╚═╝       ╩  ╚═╝ ╩ ╩ ╩ ╩\r\n * game at https://lordless.io\r\n * code at https://github.com/lordlessio\r\n */\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/access/rbac/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @author Francisco Giordano (@frangio)\r\n * @dev Library for managing addresses assigned to a Role.\r\n * See RBAC.sol for example usage.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage _role, address _addr)\r\n    internal\r\n  {\r\n    _role.bearer[_addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n  {\r\n    require(has(_role, _addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage _role, address _addr)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    return _role.bearer[_addr];\r\n  }\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/access/rbac/RBAC.sol\r\n\r\n/**\r\n * @title RBAC (Role-Based Access Control)\r\n * @author Matt Condon (@Shrugs)\r\n * @dev Stores and provides setters and getters for roles and addresses.\r\n * Supports unlimited numbers of roles and addresses.\r\n * See //contracts/mocks/RBACMock.sol for an example of usage.\r\n * This RBAC method uses strings to key roles. It may be beneficial\r\n * for you to write your own implementation of this interface using Enums or similar.\r\n */\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address indexed operator, string role);\r\n  event RoleRemoved(address indexed operator, string role);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address _operator, string _role)\r\n    public\r\n    view\r\n  {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address _operator, string _role)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function addRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function removeRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string _role)\r\n  {\r\n    checkRole(msg.sender, _role);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param _roles the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] _roles) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < _roles.length; i++) {\r\n  //         if (hasRole(msg.sender, _roles[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/ownership/Superuser.sol\r\n\r\n/**\r\n * @title Superuser\r\n * @dev The Superuser contract defines a single superuser who can transfer the ownership\r\n * of a contract to a new address, even if he is not the owner.\r\n * A superuser can transfer his role to a new address.\r\n */\r\ncontract Superuser is Ownable, RBAC {\r\n  string public constant ROLE_SUPERUSER = \"superuser\";\r\n\r\n  constructor () public {\r\n    addRole(msg.sender, ROLE_SUPERUSER);\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account that's not a superuser.\r\n   */\r\n  modifier onlySuperuser() {\r\n    checkRole(msg.sender, ROLE_SUPERUSER);\r\n    _;\r\n  }\r\n\r\n  modifier onlyOwnerOrSuperuser() {\r\n    require(msg.sender == owner || isSuperuser(msg.sender));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev getter to determine if address has superuser role\r\n   */\r\n  function isSuperuser(address _addr)\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return hasRole(_addr, ROLE_SUPERUSER);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current superuser to transfer his role to a newSuperuser.\r\n   * @param _newSuperuser The address to transfer ownership to.\r\n   */\r\n  function transferSuperuser(address _newSuperuser) public onlySuperuser {\r\n    require(_newSuperuser != address(0));\r\n    removeRole(msg.sender, ROLE_SUPERUSER);\r\n    addRole(_newSuperuser, ROLE_SUPERUSER);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current superuser or owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwnerOrSuperuser {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/introspection/ERC165.sol\r\n\r\n/**\r\n * @title ERC165\r\n * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md\r\n */\r\ninterface ERC165 {\r\n\r\n  /**\r\n   * @notice Query if a contract implements an interface\r\n   * @param _interfaceId The interface identifier, as specified in ERC-165\r\n   * @dev Interface identification is specified in ERC-165. This function\r\n   * uses less than 30,000 gas.\r\n   */\r\n  function supportsInterface(bytes4 _interfaceId)\r\n    external\r\n    view\r\n    returns (bool);\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic is ERC165 {\r\n\r\n  bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd;\r\n  /*\r\n   * 0x80ac58cd ===\r\n   *   bytes4(keccak256('balanceOf(address)')) ^\r\n   *   bytes4(keccak256('ownerOf(uint256)')) ^\r\n   *   bytes4(keccak256('approve(address,uint256)')) ^\r\n   *   bytes4(keccak256('getApproved(uint256)')) ^\r\n   *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n   *   bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n   *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n   *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Exists = 0x4f558e79;\r\n  /*\r\n   * 0x4f558e79 ===\r\n   *   bytes4(keccak256('exists(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n  /**\r\n   * 0x780e9d63 ===\r\n   *   bytes4(keccak256('totalSupply()')) ^\r\n   *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n   *   bytes4(keccak256('tokenByIndex(uint256)'))\r\n   */\r\n\r\n  bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n  /**\r\n   * 0x5b5e139f ===\r\n   *   bytes4(keccak256('name()')) ^\r\n   *   bytes4(keccak256('symbol()')) ^\r\n   *   bytes4(keccak256('tokenURI(uint256)'))\r\n   */\r\n\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\n// File: node_modules/zeppelin-solidity/contracts/token/ERC721/ERC721.sol\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() external view returns (string _name);\r\n  function symbol() external view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) \r\n      internal \r\n      pure \r\n      returns (uint256 c) \r\n  {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    require(c / a == b, \"SafeMath mul failed\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b)\r\n      internal\r\n      pure\r\n      returns (uint256) \r\n  {\r\n    require(b <= a, \"SafeMath sub failed\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b)\r\n      internal\r\n      pure\r\n      returns (uint256 c) \r\n  {\r\n    c = a + b;\r\n    require(c >= a, \"SafeMath add failed\");\r\n    return c;\r\n  }\r\n  \r\n  /**\r\n    * @dev gives square root of given x.\r\n    */\r\n  function sqrt(uint256 x)\r\n      internal\r\n      pure\r\n      returns (uint256 y) \r\n  {\r\n    uint256 z = ((add(x,1)) / 2);\r\n    y = x;\r\n    while (z < y) \r\n    {\r\n      y = z;\r\n      z = ((add((x / z),z)) / 2);\r\n    }\r\n  }\r\n  \r\n  /**\r\n    * @dev gives square. batchplies x by x\r\n    */\r\n  function sq(uint256 x)\r\n      internal\r\n      pure\r\n      returns (uint256)\r\n  {\r\n    return (mul(x,x));\r\n  }\r\n  \r\n  /**\r\n    * @dev x to the power of y \r\n    */\r\n  function pwr(uint256 x, uint256 y)\r\n      internal \r\n      pure \r\n      returns (uint256)\r\n  {\r\n    if (x==0)\r\n        return (0);\r\n    else if (y==0)\r\n        return (1);\r\n    else \r\n    {\r\n      uint256 z = x;\r\n      for (uint256 i=1; i < y; i++)\r\n        z = mul(z,x);\r\n      return (z);\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/crowdsale/INFTsCrowdsale.sol\r\n\r\n/**\r\n * @title -NFTs crowdsale Interface\r\n */\r\n\r\ninterface INFTsCrowdsale {\r\n\r\n  function getAuction(uint256 tokenId) external view\r\n  returns (\r\n    bytes32,\r\n    address,\r\n    uint256,\r\n    uint256,\r\n    uint256,\r\n    uint256\r\n  );\r\n\r\n  function isOnAuction(uint256 tokenId) external view returns (bool);\r\n\r\n  function isOnPreAuction(uint256 tokenId) external view returns (bool);\r\n\r\n  function newAuction(uint128 price, uint256 tokenId, uint256 startAt, uint256 endAt) external;\r\n\r\n  function batchNewAuctions(uint128[] prices, uint256[] tokenIds, uint256[] startAts, uint256[] endAts) external;\r\n\r\n  function payByEth (uint256 tokenId) external payable; \r\n\r\n  function payByErc20 (uint256 tokenId) external;\r\n\r\n  function cancelAuction (uint256 tokenId) external;\r\n\r\n  function batchCancelAuctions (uint256[] tokenIds) external;\r\n  \r\n  /* Events */\r\n\r\n  event NewAuction (\r\n    bytes32 id,\r\n    address indexed seller,\r\n    uint256 price,\r\n    uint256 startAt,\r\n    uint256 endAt,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  event PayByEth (\r\n    bytes32 id,\r\n    address indexed seller,\r\n    address indexed buyer,\r\n    uint256 price,\r\n    uint256 endAt,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  event PayByErc20 (\r\n    bytes32 id,\r\n    address indexed seller,\r\n    address indexed buyer, \r\n    uint256 price,\r\n    uint256 endAt,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n  event CancelAuction (\r\n    bytes32 id,\r\n    address indexed seller,\r\n    uint256 indexed tokenId\r\n  );\r\n\r\n}\r\n\r\n// File: contracts/crowdsale/NFTsCrowdsaleBase.sol\r\n\r\ncontract NFTsCrowdsaleBase is Superuser, INFTsCrowdsale {\r\n\r\n  using SafeMath for uint256;\r\n\r\n  ERC20 public erc20Contract;\r\n  ERC721 public erc721Contract;\r\n  // eth(price)/erc20(price)\r\n  uint public eth2erc20;\r\n  // Represents a auction\r\n  struct Auction {\r\n    bytes32 id; // Auction id\r\n    address seller; // Seller\r\n    uint256 price; // eth in wei\r\n    uint256 startAt; //  Auction startAt\r\n    uint256 endAt; //  Auction endAt\r\n    uint256 tokenId; // ERC721 tokenId \r\n  }\r\n\r\n  mapping (uint256 => Auction) tokenIdToAuction;\r\n  \r\n  constructor(address _erc721Address,address _erc20Address, uint _eth2erc20) public {\r\n    erc721Contract = ERC721(_erc721Address);\r\n    erc20Contract = ERC20(_erc20Address);\r\n    eth2erc20 = _eth2erc20;\r\n  }\r\n\r\n  function getAuction(uint256 _tokenId) external view\r\n  returns (\r\n    bytes32,\r\n    address,\r\n    uint256,\r\n    uint256,\r\n    uint256,\r\n    uint256\r\n  ){\r\n    Auction storage auction = tokenIdToAuction[_tokenId];\r\n    return (auction.id, auction.seller, auction.price, auction.startAt, auction.endAt, auction.tokenId);\r\n  }\r\n\r\n  function isOnAuction(uint256 _tokenId) external view returns (bool) {\r\n    Auction storage _auction = tokenIdToAuction[_tokenId];\r\n    uint256 time = block.timestamp;\r\n    return (time < _auction.endAt && time > _auction.startAt);\r\n  }\r\n\r\n  function isOnPreAuction(uint256 _tokenId) external view returns (bool) {\r\n    Auction storage _auction = tokenIdToAuction[_tokenId];\r\n    return (block.timestamp < _auction.startAt);\r\n  }\r\n\r\n  function _isTokenOwner(address _seller, uint256 _tokenId) internal view returns (bool){\r\n    return (erc721Contract.ownerOf(_tokenId) == _seller);\r\n  }\r\n\r\n  function _isOnAuction(uint256 _tokenId) internal view returns (bool) {\r\n    Auction storage _auction = tokenIdToAuction[_tokenId];\r\n    uint256 time = block.timestamp;\r\n    return (time < _auction.endAt && time > _auction.startAt);\r\n  }\r\n  function _escrow(address _owner, uint256 _tokenId) internal {\r\n    erc721Contract.transferFrom(_owner, this, _tokenId);\r\n  }\r\n\r\n  function _cancelEscrow(address _owner, uint256 _tokenId) internal {\r\n    erc721Contract.transferFrom(this, _owner, _tokenId);\r\n  }\r\n\r\n  function _transfer(address _receiver, uint256 _tokenId) internal {\r\n    erc721Contract.safeTransferFrom(this, _receiver, _tokenId);\r\n  }\r\n\r\n  function _newAuction(uint256 _price, uint256 _tokenId, uint256 _startAt, uint256 _endAt) internal {\r\n    require(_price == uint256(_price));\r\n    address _seller = msg.sender;\r\n\r\n    require(_isTokenOwner(_seller, _tokenId));\r\n    _escrow(_seller, _tokenId);\r\n\r\n    bytes32 auctionId = keccak256(\r\n      abi.encodePacked(block.timestamp, _seller, _tokenId, _price)\r\n    );\r\n    \r\n    Auction memory _order = Auction(\r\n      auctionId,\r\n      _seller,\r\n      uint128(_price),\r\n      _startAt,\r\n      _endAt,\r\n      _tokenId\r\n    );\r\n\r\n    tokenIdToAuction[_tokenId] = _order;\r\n    emit NewAuction(auctionId, _seller, _price, _startAt, _endAt, _tokenId);\r\n  }\r\n\r\n  function _cancelAuction(uint256 _tokenId) internal {\r\n    Auction storage _auction = tokenIdToAuction[_tokenId];\r\n    require(_auction.seller == msg.sender || msg.sender == owner);\r\n    emit CancelAuction(_auction.id, _auction.seller, _tokenId);\r\n    _cancelEscrow(_auction.seller, _tokenId);\r\n    delete tokenIdToAuction[_tokenId];\r\n  }\r\n\r\n  function _payByEth(uint256 _tokenId) internal {\r\n    uint256 _ethAmount = msg.value;\r\n    Auction storage _auction = tokenIdToAuction[_tokenId];\r\n    uint256 price = _auction.price;\r\n    require(_isOnAuction(_auction.tokenId));\r\n    require(_ethAmount >= price);\r\n\r\n    uint256 payExcess = _ethAmount.sub(price);\r\n\r\n    if (price > 0) {\r\n      _auction.seller.transfer(price);\r\n    }\r\n    address buyer = msg.sender;\r\n    buyer.transfer(payExcess);\r\n    _transfer(buyer, _tokenId);\r\n    emit PayByEth(_auction.id, _auction.seller, msg.sender, _auction.price, _auction.endAt, _auction.tokenId);\r\n    delete tokenIdToAuction[_tokenId];\r\n  }\r\n\r\n  function _payByErc20(uint256 _tokenId) internal {\r\n\r\n    Auction storage _auction = tokenIdToAuction[_tokenId];\r\n    uint256 price = uint256(_auction.price);\r\n    uint256 computedErc20Price = price.mul(eth2erc20);\r\n    uint256 balance = erc20Contract.balanceOf(msg.sender);\r\n    require(balance >= computedErc20Price);\r\n    require(_isOnAuction(_auction.tokenId));\r\n\r\n    if (price > 0) {\r\n      erc20Contract.transferFrom(msg.sender, _auction.seller, computedErc20Price);\r\n    }\r\n    _transfer(msg.sender, _tokenId);\r\n    emit PayByErc20(_auction.id, _auction.seller, msg.sender, _auction.price, _auction.endAt, _auction.tokenId);\r\n    delete tokenIdToAuction[_tokenId];\r\n  }\r\n  \r\n}\r\n\r\n// File: contracts/crowdsale/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  event Pause2();\r\n  event Unpause2();\r\n\r\n  bool public paused = false;\r\n  bool public paused2 = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenNotPaused2() {\r\n    require(!paused2);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  modifier whenPaused2() {\r\n    require(paused2);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  function pause2() public onlyOwner whenNotPaused2 {\r\n    paused2 = true;\r\n    emit Pause2();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n\r\n  function unpause2() public onlyOwner whenPaused2 {\r\n    paused2 = false;\r\n    emit Unpause2();\r\n  }\r\n}\r\n\r\n// File: contracts/crowdsale/NFTsCrowdsale.sol\r\n\r\ncontract NFTsCrowdsale is NFTsCrowdsaleBase, Pausable {\r\n\r\n  constructor(address erc721Address, address erc20Address, uint eth2erc20) public \r\n  NFTsCrowdsaleBase(erc721Address, erc20Address, eth2erc20){}\r\n\r\n  /**\r\n   * @dev new a Auction\r\n   * @param price price in wei\r\n   * @param tokenId Tavern's tokenid\r\n   * @param endAt auction end time\r\n   */\r\n  function newAuction(uint128 price, uint256 tokenId, uint256 startAt, uint256 endAt) whenNotPaused external {\r\n    uint256 _startAt = startAt;\r\n    if (msg.sender != owner) {\r\n      _startAt = block.timestamp;\r\n    }\r\n    _newAuction(price, tokenId, _startAt, endAt);\r\n  }\r\n\r\n  /**\r\n   * @dev batch New Auctions \r\n   * @param prices Array price in wei\r\n   * @param tokenIds Array Tavern's tokenid\r\n   * @param endAts  Array auction end time\r\n   */\r\n  function batchNewAuctions(uint128[] prices, uint256[] tokenIds, uint256[] startAts, uint256[] endAts) whenNotPaused external {\r\n    uint256 i = 0;\r\n    while (i < tokenIds.length) {\r\n      _newAuction(prices[i], tokenIds[i], startAts[i], endAts[i]);\r\n      i += 1;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev pay a auction by eth\r\n   * @param tokenId tavern tokenid\r\n   */\r\n  function payByEth (uint256 tokenId) whenNotPaused external payable {\r\n    _payByEth(tokenId); \r\n  }\r\n\r\n  /**\r\n   * @dev pay a auction by erc20 Token\r\n   * @param tokenId Tavern's tokenid\r\n   */\r\n  function payByErc20 (uint256 tokenId) whenNotPaused2 external {\r\n    _payByErc20(tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev cancel a auction\r\n   * @param tokenId Tavern's tokenid\r\n   */\r\n  function cancelAuction (uint256 tokenId) external {\r\n    _cancelAuction(tokenId);\r\n  }\r\n\r\n  /**\r\n   * @dev batch cancel auctions\r\n   * @param tokenIds Array Tavern's tokenid\r\n   */\r\n  function batchCancelAuctions (uint256[] tokenIds) external {\r\n    uint256 i = 0;\r\n    while (i < tokenIds.length) {\r\n      _cancelAuction(tokenIds[i]);\r\n      i += 1;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"batchCancelAuctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isOnAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payByEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSuperuser\",\"type\":\"address\"}],\"name\":\"transferSuperuser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"isOnPreAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint128\"},{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"startAt\",\"type\":\"uint256\"},{\"name\":\"endAt\",\"type\":\"uint256\"}],\"name\":\"newAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eth2erc20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc20Contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"isSuperuser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"payByErc20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"erc721Contract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROLE_SUPERUSER\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prices\",\"type\":\"uint128[]\"},{\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"startAts\",\"type\":\"uint256[]\"},{\"name\":\"endAts\",\"type\":\"uint256[]\"}],\"name\":\"batchNewAuctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"erc721Address\",\"type\":\"address\"},{\"name\":\"erc20Address\",\"type\":\"address\"},{\"name\":\"eth2erc20\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause2\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endAt\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"NewAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endAt\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PayByEth\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endAt\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"PayByErc20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"CancelAuction\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"NFTsCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000015820072729d045ec5232ba3bd060ec5df38e09a0000000000000000000000007ca121b093e2fbd4bb9a894bd5ff487d16f1f83b000000000000000000000000000000000000000000000000000000000000a2c2","Library":"","SwarmSource":"bzzr://c37113afea96069020c5d0a24dedf6091e9fe1518cb477ca5d54f23b757d5d68"}]}