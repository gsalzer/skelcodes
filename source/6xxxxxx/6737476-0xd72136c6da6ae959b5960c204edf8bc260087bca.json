{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n\r\n/*\r\n\r\n    Copyright 2018 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/external/Maker/OasisV1/ISimpleMarketV1.sol\r\n\r\ncontract ISimpleMarketV1 {\r\n\r\n    // ============ Structs ================\r\n\r\n    struct OfferInfo {\r\n        uint256     pay_amt;\r\n        address  pay_gem;\r\n        uint256     buy_amt;\r\n        address  buy_gem;\r\n        address  owner;\r\n        uint64   timestamp;\r\n    }\r\n\r\n    // ============ Storage ================\r\n\r\n    uint256 public last_offer_id;\r\n\r\n    mapping (uint256 => OfferInfo) public offers;\r\n\r\n    // ============ Functions ================\r\n\r\n    function isActive(\r\n        uint256 id\r\n    )\r\n        public\r\n        view\r\n        returns (bool active );\r\n\r\n    function getOwner(\r\n        uint256 id\r\n    )\r\n        public\r\n        view\r\n        returns (address owner);\r\n\r\n    function getOffer(\r\n        uint256 id\r\n    )\r\n        public\r\n        view\r\n        returns (uint, address, uint, address);\r\n\r\n    function bump(\r\n        bytes32 id_\r\n    )\r\n        public;\r\n\r\n    function buy(\r\n        uint256 id,\r\n        uint256 quantity\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function cancel(\r\n        uint256 id\r\n    )\r\n        public\r\n        returns (bool success);\r\n\r\n    function kill(\r\n        bytes32 id\r\n    )\r\n        public;\r\n\r\n    function make(\r\n        address  pay_gem,\r\n        address  buy_gem,\r\n        uint128  pay_amt,\r\n        uint128  buy_amt\r\n    )\r\n        public\r\n        returns (bytes32 id);\r\n\r\n    function offer(\r\n        uint256 pay_amt,\r\n        address pay_gem,\r\n        uint256 buy_amt,\r\n        address buy_gem\r\n    )\r\n        public\r\n        returns (uint256 id);\r\n\r\n    function take(\r\n        bytes32 id,\r\n        uint128 maxTakeAmount\r\n    )\r\n        public;\r\n}\r\n\r\n// File: contracts/external/Maker/OasisV1/IMatchingMarketV1.sol\r\n\r\ncontract IMatchingMarketV1 is ISimpleMarketV1 {\r\n\r\n    // ============ Structs ================\r\n\r\n    struct sortInfo {\r\n        uint256 next;  //points to id of next higher offer\r\n        uint256 prev;  //points to id of previous lower offer\r\n        uint256 delb;  //the blocknumber where this entry was marked for delete\r\n    }\r\n\r\n    // ============ Storage ================\r\n\r\n    uint64 public close_time;\r\n\r\n    bool public stopped;\r\n\r\n    bool public buyEnabled;\r\n\r\n    bool public matchingEnabled;\r\n\r\n    mapping(uint256 => sortInfo) public _rank;\r\n\r\n    mapping(address => mapping(address => uint)) public _best;\r\n\r\n    mapping(address => mapping(address => uint)) public _span;\r\n\r\n    mapping(address => uint) public _dust;\r\n\r\n    mapping(uint256 => uint) public _near;\r\n\r\n    mapping(bytes32 => bool) public _menu;\r\n\r\n    // ============ Functions ================\r\n\r\n    function make(\r\n        address  pay_gem,\r\n        address  buy_gem,\r\n        uint128  pay_amt,\r\n        uint128  buy_amt\r\n    )\r\n        public\r\n        returns (bytes32);\r\n\r\n    function take(\r\n        bytes32 id,\r\n        uint128 maxTakeAmount\r\n    )\r\n        public;\r\n\r\n    function kill(\r\n        bytes32 id\r\n    )\r\n        public;\r\n\r\n    function offer(\r\n        uint256 pay_amt,\r\n        address pay_gem,\r\n        uint256 buy_amt,\r\n        address buy_gem\r\n    )\r\n        public\r\n        returns (uint);\r\n\r\n    function offer(\r\n        uint256 pay_amt,\r\n        address pay_gem,\r\n        uint256 buy_amt,\r\n        address buy_gem,\r\n        uint256 pos\r\n    )\r\n        public\r\n        returns (uint);\r\n\r\n    function offer(\r\n        uint256 pay_amt,\r\n        address pay_gem,\r\n        uint256 buy_amt,\r\n        address buy_gem,\r\n        uint256 pos,\r\n        bool rounding\r\n    )\r\n        public\r\n        returns (uint);\r\n\r\n    function buy(\r\n        uint256 id,\r\n        uint256 amount\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function cancel(\r\n        uint256 id\r\n    )\r\n        public\r\n        returns (bool success);\r\n\r\n    function insert(\r\n        uint256 id,\r\n        uint256 pos\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function del_rank(\r\n        uint256 id\r\n    )\r\n        public\r\n        returns (bool);\r\n\r\n    function sellAllAmount(\r\n        address pay_gem,\r\n        uint256 pay_amt,\r\n        address buy_gem,\r\n        uint256 min_fill_amount\r\n    )\r\n        public\r\n        returns (uint256 fill_amt);\r\n\r\n    function buyAllAmount(\r\n        address buy_gem,\r\n        uint256 buy_amt,\r\n        address pay_gem,\r\n        uint256 max_fill_amount\r\n    )\r\n        public\r\n        returns (uint256 fill_amt);\r\n\r\n    // ============ Constant Functions ================\r\n\r\n    function isTokenPairWhitelisted(\r\n        address baseToken,\r\n        address quoteToken\r\n    )\r\n        public\r\n        view\r\n        returns (bool);\r\n\r\n    function getMinSell(\r\n        address pay_gem\r\n    )\r\n        public\r\n        view\r\n        returns (uint);\r\n\r\n    function getBestOffer(\r\n        address sell_gem,\r\n        address buy_gem\r\n    )\r\n        public\r\n        view\r\n        returns(uint);\r\n\r\n    function getWorseOffer(\r\n        uint256 id\r\n    )\r\n        public\r\n        view\r\n        returns(uint);\r\n\r\n    function getBetterOffer(\r\n        uint256 id\r\n    )\r\n        public\r\n        view\r\n        returns(uint);\r\n\r\n    function getOfferCount(\r\n        address sell_gem,\r\n        address buy_gem\r\n    )\r\n        public\r\n        view\r\n        returns(uint);\r\n\r\n    function getFirstUnsortedOffer()\r\n        public\r\n        view\r\n        returns(uint);\r\n\r\n    function getNextUnsortedOffer(\r\n        uint256 id\r\n    )\r\n        public\r\n        view\r\n        returns(uint);\r\n\r\n    function isOfferSorted(\r\n        uint256 id\r\n    )\r\n        public\r\n        view\r\n        returns(bool);\r\n\r\n    function getBuyAmount(\r\n        address buy_gem,\r\n        address pay_gem,\r\n        uint256 pay_amt\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 fill_amt);\r\n\r\n    function getPayAmount(\r\n        address pay_gem,\r\n        address buy_gem,\r\n        uint256 buy_amt\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 fill_amt);\r\n\r\n    function isClosed()\r\n        public\r\n        view\r\n        returns (bool closed);\r\n\r\n    function getTime()\r\n        public\r\n        view\r\n        returns (uint64);\r\n}\r\n\r\n// File: contracts/lib/MathHelpers.sol\r\n\r\n/**\r\n * @title MathHelpers\r\n * @author dYdX\r\n *\r\n * This library helps with common math functions in Solidity\r\n */\r\nlibrary MathHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              target * numerator / denominator\r\n     */\r\n    function getPartialAmount(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return numerator.mul(target).div(denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              Rounded-up result of target * numerator / denominator\r\n     */\r\n    function getPartialAmountRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return divisionRoundedUp(numerator.mul(target), denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates division given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator.\r\n     * @param  denominator  Denominator.\r\n     * @return              Rounded-up result of numerator / denominator\r\n     */\r\n    function divisionRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(denominator != 0); // coverage-enable-line\r\n        if (numerator == 0) {\r\n            return 0;\r\n        }\r\n        return numerator.sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint256(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2 ** 256 - 1;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint32(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        return 2 ** 32 - 1;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\r\n     *\r\n     * @param  n  The uint256 to get the number of bits in\r\n     * @return    The number of bits in n\r\n     */\r\n    function getNumBits(\r\n        uint256 n\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 first = 0;\r\n        uint256 last = 256;\r\n        while (first < last) {\r\n            uint256 check = (first + last) / 2;\r\n            if ((n >> check) == 0) {\r\n                last = check;\r\n            } else {\r\n                first = check + 1;\r\n            }\r\n        }\r\n        assert(first <= 256);\r\n        return first;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/GeneralERC20.sol\r\n\r\n/**\r\n * @title GeneralERC20\r\n * @author dYdX\r\n *\r\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\r\n * that we dont automatically revert when calling non-compliant tokens that have no return value for\r\n * transfer(), transferFrom(), or approve().\r\n */\r\ninterface GeneralERC20 {\r\n    function totalSupply(\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address who\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/lib/TokenInteract.sol\r\n\r\n/**\r\n * @title TokenInteract\r\n * @author dYdX\r\n *\r\n * This library contains basic functions for interacting with ERC20 tokens\r\n */\r\nlibrary TokenInteract {\r\n    function balanceOf(\r\n        address token,\r\n        address owner\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GeneralERC20(token).balanceOf(owner);\r\n    }\r\n\r\n    function allowance(\r\n        address token,\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GeneralERC20(token).allowance(owner, spender);\r\n    }\r\n\r\n    function approve(\r\n        address token,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        GeneralERC20(token).approve(spender, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#approve: Approval failed\"\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        address from = address(this);\r\n        if (\r\n            amount == 0\r\n            || from == to\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        GeneralERC20(token).transfer(to, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#transfer: Transfer failed\"\r\n        );\r\n    }\r\n\r\n    function transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        if (\r\n            amount == 0\r\n            || from == to\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        GeneralERC20(token).transferFrom(from, to, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#transferFrom: TransferFrom failed\"\r\n        );\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\r\n     * function returned 0 bytes or 32 bytes that are not all-zero.\r\n     */\r\n    function checkSuccess(\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 returnValue = 0;\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            // check number of bytes returned from last function call\r\n            switch returndatasize\r\n\r\n            // no bytes returned: assume success\r\n            case 0x0 {\r\n                returnValue := 1\r\n            }\r\n\r\n            // 32 bytes returned: check if non-zero\r\n            case 0x20 {\r\n                // copy 32 bytes into scratch space\r\n                returndatacopy(0x0, 0x0, 0x20)\r\n\r\n                // load those bytes into returnValue\r\n                returnValue := mload(0x0)\r\n            }\r\n\r\n            // not sure what was returned: dont mark as success\r\n            default { }\r\n        }\r\n\r\n        return returnValue != 0;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/AdvancedTokenInteract.sol\r\n\r\n/**\r\n * @title AdvancedTokenInteract\r\n * @author dYdX\r\n *\r\n * This library contains advanced functions for interacting with ERC20 tokens\r\n */\r\nlibrary AdvancedTokenInteract {\r\n    using TokenInteract for address;\r\n\r\n    /**\r\n     * Checks if the spender has some amount of allowance. If it doesn't, then set allowance at\r\n     * the maximum value.\r\n     *\r\n     * @param  token    Address of the ERC20 token\r\n     * @param  spender  Argument of the allowance function\r\n     * @param  amount   The minimum amount of allownce the the spender should be guaranteed\r\n     */\r\n    function ensureAllowance(\r\n        address token,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        if (token.allowance(address(this), spender) < amount) {\r\n            token.approve(spender, MathHelpers.maxUint256());\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/margin/interfaces/ExchangeReader.sol\r\n\r\n/**\r\n * @title ExchangeReader\r\n * @author dYdX\r\n *\r\n * Contract interface that wraps an exchange and provides information about the current state of the\r\n * exchange or particular orders\r\n */\r\ninterface ExchangeReader {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Get the maxmimum amount of makerToken for some order\r\n     *\r\n     * @param  makerToken           Address of makerToken, the token to receive\r\n     * @param  takerToken           Address of takerToken, the token to pay\r\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                      Maximum amount of makerToken\r\n     */\r\n    function getMaxMakerAmount(\r\n        address makerToken,\r\n        address takerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/margin/interfaces/ExchangeWrapper.sol\r\n\r\n/**\r\n * @title ExchangeWrapper\r\n * @author dYdX\r\n *\r\n * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\r\n * with other smart contracts through a common interface.\r\n */\r\ninterface ExchangeWrapper {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Exchange some amount of takerToken for makerToken.\r\n     *\r\n     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\r\n     *                              cannot always be trusted as it is set at the discretion of the\r\n     *                              msg.sender)\r\n     * @param  receiver             Address to set allowance on once the trade has completed\r\n     * @param  makerToken           Address of makerToken, the token to receive\r\n     * @param  takerToken           Address of takerToken, the token to pay\r\n     * @param  requestedFillAmount  Amount of takerToken being paid\r\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                      The amount of makerToken received\r\n     */\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes orderData\r\n    )\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\r\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\r\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\r\n     * than desiredMakerToken\r\n     *\r\n     * @param  makerToken         Address of makerToken, the token to receive\r\n     * @param  takerToken         Address of takerToken, the token to pay\r\n     * @param  desiredMakerToken  Amount of makerToken requested\r\n     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                    Amount of takerToken the needed to complete the transaction\r\n     */\r\n    function getExchangeCost(\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 desiredMakerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/margin/external/exchangewrappers/OasisV1MatchingExchangeWrapper.sol\r\n\r\n/**\r\n * @title OasisV1MatchingExchangeWrapper\r\n * @author dYdX\r\n *\r\n * dYdX ExchangeWrapper to interface with Maker's MatchingMarket contract (Oasis exchange)\r\n */\r\ncontract OasisV1MatchingExchangeWrapper is\r\n    ExchangeWrapper,\r\n    ExchangeReader\r\n{\r\n    using SafeMath for uint256;\r\n    using TokenInteract for address;\r\n    using AdvancedTokenInteract for address;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Offer {\r\n        uint256 makerAmount;\r\n        address makerToken;\r\n        uint256 takerAmount;\r\n        address takerToken;\r\n    }\r\n\r\n    // ============ State Variables ============\r\n\r\n    address public MATCHING_MARKET;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address matchingMarket\r\n    )\r\n        public\r\n    {\r\n        MATCHING_MARKET = matchingMarket;\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    function exchange(\r\n        address /*tradeOriginator*/,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes orderData\r\n    )\r\n        external\r\n        returns (uint256)\r\n    {\r\n        IMatchingMarketV1 market = IMatchingMarketV1(MATCHING_MARKET);\r\n\r\n        // make sure that the exchange can take the tokens from this contract\r\n        takerToken.ensureAllowance(address(market), requestedFillAmount);\r\n\r\n        // do the exchange\r\n        uint256 receivedMakerAmount = market.sellAllAmount(\r\n            takerToken,\r\n            requestedFillAmount,\r\n            makerToken,\r\n            0\r\n        );\r\n\r\n        // validate results\r\n        requireBelowMaximumPrice(requestedFillAmount, receivedMakerAmount, orderData);\r\n\r\n        // set allowance for the receiver\r\n        makerToken.ensureAllowance(receiver, receivedMakerAmount);\r\n\r\n        return receivedMakerAmount;\r\n    }\r\n\r\n    function getExchangeCost(\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 desiredMakerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        IMatchingMarketV1 market = IMatchingMarketV1(MATCHING_MARKET);\r\n\r\n        uint256 costInTakerToken = market.getPayAmount(\r\n            takerToken,\r\n            makerToken,\r\n            desiredMakerToken\r\n        );\r\n\r\n        requireBelowMaximumPrice(costInTakerToken, desiredMakerToken, orderData);\r\n\r\n        return costInTakerToken;\r\n    }\r\n\r\n    function getMaxMakerAmount(\r\n        address makerToken,\r\n        address takerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        (uint256 takerAmountRatio, uint256 makerAmountRatio) = getMaximumPrice(orderData);\r\n        require(\r\n            makerAmountRatio > 0,\r\n            \"OasisV1MatchingExchangeWrapper#getMaxMakerAmount: No maximum price given\"\r\n        );\r\n\r\n        IMatchingMarketV1 market = IMatchingMarketV1(MATCHING_MARKET);\r\n        uint256 offerId = market.getBestOffer(makerToken, takerToken);\r\n        uint256 totalMakerAmount = 0;\r\n\r\n        while (offerId != 0) {\r\n            // get the offer info\r\n            Offer memory offer = getOffer(market, offerId);\r\n\r\n            assert(makerToken == offer.makerToken);\r\n            assert(takerToken == offer.takerToken);\r\n\r\n            // decide whether the offer satisfies the price ratio provided\r\n            if (offer.makerAmount.mul(takerAmountRatio) < offer.takerAmount.mul(makerAmountRatio)) {\r\n                break;\r\n            } else {\r\n                totalMakerAmount = totalMakerAmount.add(offer.makerAmount);\r\n            }\r\n            offerId = market.getWorseOffer(offerId);\r\n        }\r\n\r\n        return totalMakerAmount;\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function requireBelowMaximumPrice(\r\n        uint256 takerAmount,\r\n        uint256 makerAmount,\r\n        bytes orderData\r\n    )\r\n        private\r\n        pure\r\n    {\r\n        (uint256 takerAmountRatio, uint256 makerAmountRatio) = getMaximumPrice(orderData);\r\n        if (takerAmountRatio > 0 || makerAmountRatio > 0) {\r\n            // all amounts have previously been required to fit within 128 bits each\r\n            require(\r\n                takerAmount.mul(makerAmountRatio) <= makerAmount.mul(takerAmountRatio),\r\n                \"OasisV1MatchingExchangeWrapper:#requireBelowMaximumPrice: price is too high\"\r\n            );\r\n        }\r\n    }\r\n\r\n    function getOffer(\r\n        IMatchingMarketV1 market,\r\n        uint256 offerId\r\n    )\r\n        private\r\n        view\r\n        returns (Offer memory)\r\n    {\r\n        (\r\n            uint256 offerMakerAmount,\r\n            address offerMakerToken,\r\n            uint256 offerTakerAmount,\r\n            address offerTakerToken\r\n        ) = market.getOffer(offerId);\r\n\r\n        return Offer({\r\n            makerAmount: offerMakerAmount,\r\n            makerToken: offerMakerToken,\r\n            takerAmount: offerTakerAmount,\r\n            takerToken: offerTakerToken\r\n        });\r\n    }\r\n\r\n    // ============ Parsing Functions ============\r\n\r\n    function getMaximumPrice(\r\n        bytes orderData\r\n    )\r\n        private\r\n        pure\r\n        returns (uint256, uint256)\r\n    {\r\n        uint256 takerAmountRatio = 0;\r\n        uint256 makerAmountRatio = 0;\r\n\r\n        if (orderData.length > 0) {\r\n            require(\r\n                orderData.length == 64,\r\n                \"OasisV1MatchingExchangeWrapper:#getMaximumPrice: orderData is not the right length\"\r\n            );\r\n\r\n            /* solium-disable-next-line security/no-inline-assembly */\r\n            assembly {\r\n                takerAmountRatio := mload(add(orderData, 32))\r\n                makerAmountRatio := mload(add(orderData, 64))\r\n            }\r\n\r\n            // require numbers to fit within 128 bits to prevent overflow when checking bounds\r\n            require(\r\n                uint128(takerAmountRatio) == takerAmountRatio,\r\n                \"OasisV1MatchingExchangeWrapper:#getMaximumPrice: takerAmountRatio > 128 bits\"\r\n            );\r\n            require(\r\n                uint128(makerAmountRatio) == makerAmountRatio,\r\n                \"OasisV1MatchingExchangeWrapper:#getMaximumPrice: makerAmountRatio > 128 bits\"\r\n            );\r\n\r\n            // since this is a price ratio, the denominator cannot be zero\r\n            require(\r\n                makerAmountRatio > 0,\r\n                \"OasisV1MatchingExchangeWrapper:#getMaximumPrice: makerAmountRatio cannot be zero\"\r\n            );\r\n        }\r\n\r\n        return (takerAmountRatio, makerAmountRatio);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"desiredMakerToken\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"getExchangeCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"getMaxMakerAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"requestedFillAmount\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MATCHING_MARKET\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"matchingMarket\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"OasisV1MatchingExchangeWrapper","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"00000000000000000000000014fbca95be7e99c15cc2996c6c9d841e54b79425","Library":"","SwarmSource":"bzzr://707b02ff6a2f1903d246f813e768d20c8c4b618c66f4de2cd957e6b107932e27"}]}