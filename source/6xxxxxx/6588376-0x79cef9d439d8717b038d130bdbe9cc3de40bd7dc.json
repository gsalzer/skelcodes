{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract ERC721Basic {\r\n  event Transfer(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 _tokenId\r\n  );\r\n  event Approval(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 _tokenId\r\n  );\r\n  event ApprovalForAll(\r\n    address indexed _owner,\r\n    address indexed _operator,\r\n    bool _approved\r\n  );\r\n\r\n  function balanceOf(address _owner) public view returns (uint256 _balance);\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId)\r\n    public view returns (address _operator);\r\n\r\n  function setApprovalForAll(address _operator, bool _approved) public;\r\n  function isApprovedForAll(address _owner, address _operator)\r\n    public view returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId)\r\n    public;\r\n\r\n  function safeTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public;\r\n}\r\n\r\ncontract ERC721Enumerable is ERC721Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function tokenOfOwnerByIndex(\r\n    address _owner,\r\n    uint256 _index\r\n  )\r\n    public\r\n    view\r\n    returns (uint256 _tokenId);\r\n\r\n  function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\ncontract ERC721Metadata is ERC721Basic {\r\n  function name() public view returns (string _name);\r\n  function symbol() public view returns (string _symbol);\r\n  function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\ncontract ERC721Receiver {\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n  bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n  function onERC721Received(\r\n    address _from,\r\n    uint256 _tokenId,\r\n    bytes _data\r\n  )\r\n    public\r\n    returns(bytes4);\r\n}\r\n\r\nlibrary ChallengeLib {\r\n    struct Challenge {\r\n        address owner;\r\n        address challenger;\r\n        bytes32 txHash;\r\n        uint256 challengingBlockNumber;\r\n    }\r\n\r\n    function contains(Challenge[] storage _array, bytes32 txHash) internal view returns (bool) {\r\n        int index = indexOf(_array, txHash);\r\n        return index != -1;\r\n    }\r\n\r\n    function remove(Challenge[] storage _array, bytes32 txHash) internal returns (bool) {\r\n        int index = indexOf(_array, txHash);\r\n        if (index == -1) {\r\n            return false; // Tx not in challenge arraey\r\n        }\r\n        // Replace element with last element\r\n        Challenge memory lastChallenge = _array[_array.length - 1];\r\n        _array[uint(index)] = lastChallenge;\r\n\r\n        // Reduce array length\r\n        delete _array[_array.length - 1];\r\n        _array.length -= 1;\r\n        return true;\r\n    }\r\n\r\n    function indexOf(Challenge[] storage _array, bytes32 txHash) internal view returns (int) {\r\n        for (uint i = 0; i < _array.length; i++) {\r\n            if (_array[i].txHash == txHash) {\r\n                return int(i);\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n}\r\n\r\nlibrary ECVerify {\r\n\r\n    enum SignatureMode {\r\n        EIP712,\r\n        GETH,\r\n        TREZOR\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes signature) internal pure returns (address) {\r\n        require(signature.length == 66);\r\n        SignatureMode mode = SignatureMode(uint8(signature[0]));\r\n\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        assembly {\r\n            r := mload(add(signature, 33))\r\n            s := mload(add(signature, 65))\r\n            v := and(mload(add(signature, 66)), 255)\r\n        }\r\n\r\n        if (mode == SignatureMode.GETH) {\r\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\r\n        } else if (mode == SignatureMode.TREZOR) {\r\n            hash = keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\\x20\", hash));\r\n        }\r\n\r\n        return ecrecover(\r\n            hash,\r\n            v,\r\n            r,\r\n            s);\r\n    }\r\n\r\n    function ecverify(bytes32 hash, bytes sig, address signer) internal pure returns (bool) {\r\n        return signer == recover(hash, sig);\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20Receiver {\r\n    /**\r\n     * @dev Magic value to be returned upon successful reception of an amount of ERC20 tokens\r\n     *  Equals to `bytes4(keccak256(\"onERC20Received(address,uint256,bytes)\"))`,\r\n     *  which can be also obtained as `ERC20Receiver(0).onERC20Received.selector`\r\n     */\r\n    bytes4 constant ERC20_RECEIVED = 0x65d83056;\r\n\r\n    function onERC20Received(address _from, uint256 amount, bytes data) public returns(bytes4);\r\n\r\n}\r\n\r\nlibrary RLP {\r\n    uint constant DATA_SHORT_START = 0x80;\r\n    uint constant DATA_LONG_START = 0xB8;\r\n    uint constant LIST_SHORT_START = 0xC0;\r\n    uint constant LIST_LONG_START = 0xF8;\r\n\r\n    uint constant DATA_LONG_OFFSET = 0xB7;\r\n\r\n\r\n    struct RLPItem {\r\n        uint _unsafeMemPtr;    // Pointer to the RLP-encoded bytes.\r\n        uint _unsafeLength;    // Number of bytes. This is the full length of the string.\r\n    }\r\n\r\n    struct Iterator {\r\n        RLPItem _unsafeItem;   // Item that's being iterated over.\r\n        uint _unsafeNextPtr;   // Position of the next item in the list.\r\n    }\r\n\r\n    /* RLPItem */\r\n\r\n    /// @dev Creates an RLPItem from an array of RLP encoded bytes.\r\n    /// @param self The RLP encoded bytes.\r\n    /// @return An RLPItem\r\n    function toRLPItem(bytes memory self) internal pure returns (RLPItem memory) {\r\n        uint len = self.length;\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(self, 0x20)\r\n        }\r\n        return RLPItem(memPtr, len);\r\n    }\r\n\r\n    /// @dev Get the list of sub-items from an RLP encoded list.\r\n    /// Warning: This requires passing in the number of items.\r\n    /// @param self The RLP item.\r\n    /// @return Array of RLPItems.\r\n    function toList(RLPItem memory self, uint256 numItems) internal pure returns (RLPItem[] memory list) {\r\n        list = new RLPItem[](numItems);\r\n        Iterator memory it = iterator(self);\r\n        uint idx;\r\n        while (idx < numItems) {\r\n            list[idx] = next(it);\r\n            idx++;\r\n        }\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into a uint. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toUint(RLPItem memory self) internal pure returns (uint data) {\r\n        (uint rStartPos, uint len) = _decode(self);\r\n        assembly {\r\n            data := div(mload(rStartPos), exp(256, sub(32, len)))\r\n        }\r\n    }\r\n\r\n    /// @dev Decode an RLPItem into an address. This will not work if the\r\n    /// RLPItem is a list.\r\n    /// @param self The RLPItem.\r\n    /// @return The decoded string.\r\n    function toAddress(RLPItem memory self)\r\n        internal\r\n        pure\r\n        returns (address data)\r\n    {\r\n        (uint rStartPos,) = _decode(self);\r\n        assembly {\r\n            data := div(mload(rStartPos), exp(256, 12))\r\n        }\r\n    }\r\n\r\n    /// @dev Create an iterator.\r\n    /// @param self The RLP item.\r\n    /// @return An 'Iterator' over the item.\r\n    function iterator(RLPItem memory self) private pure returns (Iterator memory it) {\r\n        uint ptr = self._unsafeMemPtr + _payloadOffset(self);\r\n        it._unsafeItem = self;\r\n        it._unsafeNextPtr = ptr;\r\n    }\r\n\r\n    /* Iterator */\r\n    function next(Iterator memory self) private pure returns (RLPItem memory subItem) {\r\n        uint ptr = self._unsafeNextPtr;\r\n        uint itemLength = _itemLength(ptr);\r\n        subItem._unsafeMemPtr = ptr;\r\n        subItem._unsafeLength = itemLength;\r\n        self._unsafeNextPtr = ptr + itemLength;\r\n    }\r\n\r\n    function hasNext(Iterator memory self) private pure returns (bool) {\r\n        RLPItem memory item = self._unsafeItem;\r\n        return self._unsafeNextPtr < item._unsafeMemPtr + item._unsafeLength;\r\n    }\r\n\r\n    // Get the payload offset.\r\n    function _payloadOffset(RLPItem memory self)\r\n        private\r\n        pure\r\n        returns (uint)\r\n    {\r\n        uint b0;\r\n        uint memPtr = self._unsafeMemPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if (b0 < DATA_SHORT_START)\r\n            return 0;\r\n        if (b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START))\r\n            return 1;\r\n    }\r\n\r\n    // Get the full length of an RLP item.\r\n    function _itemLength(uint memPtr)\r\n        private\r\n        pure\r\n        returns (uint len)\r\n    {\r\n        uint b0;\r\n        assembly {\r\n            b0 := byte(0, mload(memPtr))\r\n        }\r\n        if (b0 < DATA_SHORT_START)\r\n            len = 1;\r\n        else if (b0 < DATA_LONG_START)\r\n            len = b0 - DATA_SHORT_START + 1;\r\n    }\r\n\r\n    // Get start position and length of the data.\r\n    function _decode(RLPItem memory self)\r\n        private\r\n        pure\r\n        returns (uint memPtr, uint len)\r\n    {\r\n        uint b0;\r\n        uint start = self._unsafeMemPtr;\r\n        assembly {\r\n            b0 := byte(0, mload(start))\r\n        }\r\n        if (b0 < DATA_SHORT_START) {\r\n            memPtr = start;\r\n            len = 1;\r\n            return;\r\n        }\r\n        if (b0 < DATA_LONG_START) {\r\n            len = self._unsafeLength - 1;\r\n            memPtr = start + 1;\r\n        } else {\r\n            uint bLen;\r\n            assembly {\r\n                bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET\r\n            }\r\n            len = self._unsafeLength - 1 - bLen;\r\n            memPtr = start + bLen + 1;\r\n        }\r\n        return;\r\n    }\r\n\r\n    /// @dev Return the RLP encoded bytes.\r\n    /// @param self The RLPItem.\r\n    /// @return The bytes.\r\n    function toBytes(RLPItem memory self)\r\n        internal\r\n        pure\r\n        returns (bytes memory bts)\r\n    {\r\n        uint len = self._unsafeLength;\r\n        if (len == 0)\r\n            return;\r\n        bts = new bytes(len);\r\n        _copyToBytes(self._unsafeMemPtr, bts, len);\r\n    }\r\n\r\n    // Assumes that enough memory has been allocated to store in target.\r\n    function _copyToBytes(uint btsPtr, bytes memory tgt, uint btsLen)\r\n        private\r\n        pure\r\n    {\r\n        // Exploiting the fact that 'tgt' was the last thing to be allocated,\r\n        // we can write entire words, and just overwrite any excess.\r\n        assembly {\r\n            {\r\n                // evm operations on words\r\n                let words := div(add(btsLen, 31), 32)\r\n                let rOffset := btsPtr\r\n                let wOffset := add(tgt, 0x20)\r\n                for\r\n                    { let i := 0 } // start at arr + 0x20 -> first byte corresponds to length\r\n                    lt(i, words)\r\n                    { i := add(i, 1) }\r\n                {\r\n                    let offset := mul(i, 0x20)\r\n                    mstore(add(wOffset, offset), mload(add(rOffset, offset)))\r\n                }\r\n                mstore(add(tgt, add(0x20, mload(tgt))), 0)\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n}\r\n\r\ncontract RootChain is ERC721Receiver, ERC20Receiver {\r\n\r\n    /**\r\n     * Event for coin deposit logging.\r\n     * @notice The Deposit event indicates that a deposit block has been added\r\n     *         to the Plasma chain\r\n     * @param slot Plasma slot, a unique identifier, assigned to the deposit\r\n     * @param blockNumber The index of the block in which a deposit transaction\r\n     *                    is included\r\n     * @param denomination Quantity of a particular coin deposited\r\n     * @param from The address of the depositor\r\n     * @param contractAddress The address of the contract making the deposit\r\n     */\r\n    event Deposit(uint64 indexed slot, uint256 blockNumber, uint256 denomination, \r\n                  address indexed from, address indexed contractAddress);\r\n\r\n    /**\r\n     * Event for block submission logging\r\n     * @notice The event indicates the addition of a new Plasma block\r\n     * @param blockNumber The block number of the submitted block\r\n     * @param root The root hash of the Merkle tree containing all of a block's\r\n     *             transactions.\r\n     * @param timestamp The time when a block was added to the Plasma chain\r\n     */\r\n    event SubmittedBlock(uint256 blockNumber, bytes32 root, uint256 timestamp);\r\n\r\n    /**\r\n     * Event for logging exit starts\r\n     * @param slot The slot of the coin being exited\r\n     * @param owner The user who claims to own the coin being exited\r\n     */\r\n    event StartedExit(uint64 indexed slot, address indexed owner);\r\n\r\n    /**\r\n     * Event for exit challenge logging\r\n     * @notice This event only fires if `challengeBefore` is called.\r\n     * @param slot The slot of the coin whose exit was challenged\r\n     * @param txHash The hash of the tx used for the challenge\r\n     */\r\n    event ChallengedExit(uint64 indexed slot, bytes32 txHash, uint256 challengingBlockNumber);\r\n\r\n    /**\r\n     * Event for exit response logging\r\n     * @notice This only logs responses to `challengeBefore`\r\n     * @param slot The slot of the coin whose challenge was responded to\r\n     */\r\n    event RespondedExitChallenge(uint64 indexed slot);\r\n\r\n    /**\r\n     * Event for logging when an exit was successfully challenged\r\n     * @param slot The slot of the coin being reset to DEPOSITED\r\n     * @param owner The owner of the coin\r\n     */\r\n    event CoinReset(uint64 indexed slot, address indexed owner);\r\n\r\n    /**\r\n     * Event for exit finalization logging\r\n     * @param slot The slot of the coin whose exit has been finalized\r\n     * @param owner The owner of the coin whose exit has been finalized\r\n     */\r\n    event FinalizedExit(uint64 indexed slot, address owner);\r\n\r\n    /**\r\n     * Event to log the freeing of a bond\r\n     * @param from The address of the user whose bonds have been freed\r\n     * @param amount The bond amount which can now be withdrawn\r\n     */\r\n    event FreedBond(address indexed from, uint256 amount);\r\n\r\n    /**\r\n     * Event to log the slashing of a bond\r\n     * @param from The address of the user whose bonds have been slashed\r\n     * @param to The recipient of the slashed bonds\r\n     * @param amount The bound amount which has been forfeited\r\n     */\r\n    event SlashedBond(address indexed from, address indexed to, uint256 amount);\r\n\r\n    /**\r\n     * Event to log the withdrawal of a bond\r\n     * @param from The address of the user who withdrew bonds\r\n     * @param amount The bond amount which has been withdrawn\r\n     */\r\n    event WithdrewBonds(address indexed from, uint256 amount);\r\n\r\n    /**\r\n     * Event to log the withdrawal of a coin\r\n     * @param owner The address of the user who withdrew bonds\r\n     * @param slot the slot of the coin that was exited\r\n     * @param mode The type of coin that is being withdrawn (ERC20/ERC721/ETH)\r\n     * @param contractAddress The contract address where the coin is being withdrawn from\r\n              is same as `from` when withdrawing a ETH coin\r\n     * @param uid The uid of the coin being withdrawn if ERC721, else 0\r\n     * @param denomination The denomination of the coin which has been withdrawn (=1 for ERC721)\r\n     */\r\n    event Withdrew(address indexed owner, uint64 indexed slot, Mode mode, address contractAddress, uint uid, uint denomination);\r\n\r\n    using SafeMath for uint256;\r\n    using Transaction for bytes;\r\n    using ECVerify for bytes32;\r\n    using ChallengeLib for ChallengeLib.Challenge[];\r\n\r\n    uint256 constant BOND_AMOUNT = 0.1 ether;\r\n    // An exit can be finalized after it has matured,\r\n    // after T2 = T0 + MATURITY_PERIOD\r\n    // An exit can be challenged in the first window\r\n    // between T0 and T1 ( T1 = T0 + CHALLENGE_WINDOW)\r\n    // A challenge can be responded to in the second window\r\n    // between T1 and T2\r\n    uint256 constant MATURITY_PERIOD = 7 days;\r\n    uint256 constant CHALLENGE_WINDOW = 3 days + 12 hours;\r\n\r\n    /*\r\n     * Modifiers\r\n     */\r\n    modifier isValidator() {\r\n        require(vmc.checkValidator(msg.sender));\r\n        _;\r\n    }\r\n\r\n    modifier isTokenApproved(address _address) {\r\n        require(vmc.allowedTokens(_address));\r\n        _;\r\n    }\r\n\r\n    modifier isBonded() {\r\n        require(msg.value == BOND_AMOUNT);\r\n\r\n        // Save challenger's bond\r\n        balances[msg.sender].bonded = balances[msg.sender].bonded.add(msg.value);\r\n        _;\r\n    }\r\n\r\n    modifier isState(uint64 slot, State state) {\r\n        require(coins[slot].state == state, \"Wrong state\");\r\n        _;\r\n    }\r\n\r\n    modifier cleanupExit(uint64 slot) {\r\n        _;\r\n        delete coins[slot].exit;\r\n        delete exitSlots[getExitIndex(slot)];\r\n    }\r\n\r\n    struct Balance {\r\n        uint256 bonded;\r\n        uint256 withdrawable;\r\n    }\r\n    mapping (address => Balance) public balances;\r\n\r\n    // exits\r\n    uint64[] public exitSlots;\r\n    // Each exit can only be challenged by a single challenger at a time\r\n    struct Exit {\r\n        address prevOwner; // previous owner of coin\r\n        address owner;\r\n        uint256 createdAt;\r\n        uint256 bond;\r\n        uint256 prevBlock;\r\n        uint256 exitBlock;\r\n    }\r\n    enum State {\r\n        DEPOSITED,\r\n        EXITING,\r\n        EXITED\r\n    }\r\n\r\n    // Track owners of txs that are pending a response\r\n    struct Challenge {\r\n        address owner;\r\n        uint256 blockNumber;\r\n    }\r\n    mapping (uint64 => ChallengeLib.Challenge[]) challenges;\r\n\r\n    // tracking of NFTs deposited in each slot\r\n    enum Mode {\r\n        ETH,\r\n        ERC20,\r\n        ERC721\r\n    }\r\n    uint64 public numCoins = 0;\r\n    mapping (uint64 => Coin) coins;\r\n    struct Coin {\r\n        Mode mode;\r\n        State state;\r\n        address owner; // who owns that nft\r\n        address contractAddress; // which contract does the coin belong to\r\n        Exit exit;\r\n        uint256 uid; \r\n        uint256 denomination;\r\n        uint256 depositBlock;\r\n    }\r\n\r\n    // child chain\r\n    uint256 public childBlockInterval = 1000;\r\n    uint256 public currentBlock = 0;\r\n    struct ChildBlock {\r\n        bytes32 root;\r\n        uint256 createdAt;\r\n    }\r\n\r\n    mapping(uint256 => ChildBlock) public childChain;\r\n    ValidatorManagerContract vmc;\r\n    SparseMerkleTree smt;\r\n\r\n    constructor (ValidatorManagerContract _vmc) public {\r\n        vmc = _vmc;\r\n        smt = new SparseMerkleTree();\r\n    }\r\n\r\n\r\n    /// @dev called by a Validator to append a Plasma block to the Plasma chain\r\n    /// @param root The transaction root hash of the Plasma block being added\r\n    function submitBlock(bytes32 root)\r\n        public\r\n        isValidator\r\n    {\r\n        // rounding to next whole `childBlockInterval`\r\n        currentBlock = currentBlock.add(childBlockInterval)\r\n            .div(childBlockInterval)\r\n            .mul(childBlockInterval);\r\n\r\n        childChain[currentBlock] = ChildBlock({\r\n            root: root,\r\n            createdAt: block.timestamp\r\n        });\r\n\r\n        emit SubmittedBlock(currentBlock, root, block.timestamp);\r\n    }\r\n\r\n    /// @dev Allows anyone to deposit funds into the Plasma chain, called when\r\n    //       contract receives ERC721\r\n    /// @notice Appends a deposit block to the Plasma chain\r\n    /// @param from The address of the user who is depositing a coin\r\n    /// @param uid The uid of the ERC721 coin being deposited. This is an\r\n    ///            identifier allocated by the ERC721 token contract; it is not\r\n    ///            related to `slot`. If the coin is ETH or ERC20 the uid is 0\r\n    /// @param denomination The quantity of a particular coin being deposited\r\n    /// @param mode The type of coin that is being deposited (ETH/ERC721/ERC20)\r\n    function deposit(\r\n        address from, \r\n        address contractAddress,\r\n        uint256 uid, \r\n        uint256 denomination, \r\n        Mode mode\r\n    )\r\n        private\r\n    {\r\n        currentBlock = currentBlock.add(1);\r\n        uint64 slot = uint64(bytes8(keccak256(abi.encodePacked(numCoins, msg.sender, from))));\r\n\r\n        // Update state. Leave `exit` empty\r\n        Coin storage coin = coins[slot];\r\n        coin.uid = uid;\r\n        coin.contractAddress = contractAddress;\r\n        coin.denomination = denomination;\r\n        coin.depositBlock = currentBlock;\r\n        coin.owner = from;\r\n        coin.state = State.DEPOSITED;\r\n        coin.mode = mode;\r\n\r\n        childChain[currentBlock] = ChildBlock({\r\n            // save signed transaction hash as root\r\n            // hash for deposit transactions is the hash of its slot\r\n            root: keccak256(abi.encodePacked(slot)),\r\n            createdAt: block.timestamp\r\n        });\r\n\r\n        // create a utxo at `slot`\r\n        emit Deposit(\r\n            slot,\r\n            currentBlock,\r\n            denomination,\r\n            from,\r\n            contractAddress\r\n        );\r\n\r\n        numCoins += 1;\r\n    }\r\n\r\n    /******************** EXIT RELATED ********************/\r\n\r\n    function startExit(\r\n        uint64 slot,\r\n        bytes prevTxBytes, bytes exitingTxBytes,\r\n        bytes prevTxInclusionProof, bytes exitingTxInclusionProof,\r\n        bytes signature,\r\n        uint256[2] blocks)\r\n        external\r\n        payable isBonded\r\n        isState(slot, State.DEPOSITED)\r\n    {\r\n        require(msg.sender == exitingTxBytes.getOwner());\r\n        doInclusionChecks(\r\n            prevTxBytes, exitingTxBytes,\r\n            prevTxInclusionProof, exitingTxInclusionProof,\r\n            signature,\r\n            blocks\r\n        );\r\n        pushExit(slot, prevTxBytes.getOwner(), blocks);\r\n    }\r\n\r\n    /// @dev Verifies that consecutive two transaction involving the same coin\r\n    ///      are valid\r\n    /// @notice If exitingTxBytes corresponds to a deposit transaction,\r\n    ///         prevTxBytes cannot have a meaningul value and thus it is ignored.\r\n    /// @param prevTxBytes The RLP-encoded transaction involving a particular\r\n    ///        coin which took place directly before exitingTxBytes\r\n    /// @param exitingTxBytes The RLP-encoded transaction involving a particular\r\n    ///        coin which an exiting owner of the coin claims to be the latest\r\n    /// @param prevTxInclusionProof An inclusion proof of prevTx\r\n    /// @param exitingTxInclusionProof An inclusion proof of exitingTx\r\n    /// @param signature The signature of the exitingTxBytes by the coin\r\n    ///        owner indicated in prevTx\r\n    /// @param blocks An array of two block numbers, at index 0, the block\r\n    ///        containing the prevTx and at index 1, the block containing\r\n    ///        the exitingTx\r\n    function doInclusionChecks(\r\n        bytes prevTxBytes, bytes exitingTxBytes,\r\n        bytes prevTxInclusionProof, bytes exitingTxInclusionProof,\r\n        bytes signature,\r\n        uint256[2] blocks)\r\n        private\r\n        view\r\n    {\r\n        if (blocks[1] % childBlockInterval != 0) {\r\n            checkIncludedAndSigned(\r\n                exitingTxBytes,\r\n                exitingTxInclusionProof,\r\n                signature,\r\n                blocks[1]\r\n            );\r\n        } else {\r\n            checkBothIncludedAndSigned(\r\n                prevTxBytes, exitingTxBytes, prevTxInclusionProof,\r\n                exitingTxInclusionProof, signature,\r\n                blocks\r\n            );\r\n        }\r\n    }\r\n\r\n    // Needed to bypass stack limit errors\r\n    function pushExit(\r\n        uint64 slot,\r\n        address prevOwner,\r\n        uint256[2] blocks)\r\n        private\r\n    {\r\n        // Push exit to list\r\n        exitSlots.push(slot);\r\n\r\n        // Create exit\r\n        Coin storage c = coins[slot];\r\n        c.exit = Exit({\r\n            prevOwner: prevOwner,\r\n            owner: msg.sender,\r\n            createdAt: block.timestamp,\r\n            bond: msg.value,\r\n            prevBlock: blocks[0],\r\n            exitBlock: blocks[1]\r\n        });\r\n\r\n        // Update coin state\r\n        c.state = State.EXITING;\r\n        emit StartedExit(slot, msg.sender);\r\n    }\r\n\r\n    /// @dev Finalizes an exit, i.e. puts the exiting coin into the EXITED\r\n    ///      state which will allow it to be withdrawn, provided the exit has\r\n    ///      matured and has not been successfully challenged\r\n    function finalizeExit(uint64 slot) public {\r\n        Coin storage coin = coins[slot];\r\n\r\n        // If a coin is not under exit/challenge, then ignore it\r\n        if (coin.state != State.EXITING)\r\n            return;\r\n\r\n        // If an exit is not matured, ignore it\r\n        if ((block.timestamp - coin.exit.createdAt) <= MATURITY_PERIOD)\r\n            return;\r\n\r\n        // Check if there are any pending challenges for the coin.\r\n        // `checkPendingChallenges` will also penalize\r\n        // for each challenge that has not been responded to\r\n        bool hasChallenges = checkPendingChallenges(slot);\r\n\r\n        if (!hasChallenges) {\r\n            // Update coin's owner\r\n            coin.owner = coin.exit.owner;\r\n            coin.state = State.EXITED;\r\n\r\n            // Allow the exitor to withdraw their bond\r\n            freeBond(coin.owner);\r\n\r\n            emit FinalizedExit(slot, coin.owner);\r\n        } else {\r\n            // Reset coin state since it was challenged\r\n            coin.state = State.DEPOSITED;\r\n            emit CoinReset(slot, coin.owner);\r\n        }\r\n\r\n        delete coins[slot].exit;\r\n        delete exitSlots[getExitIndex(slot)];\r\n    }\r\n\r\n    function checkPendingChallenges(uint64 slot) private returns (bool hasChallenges) {\r\n        uint256 length = challenges[slot].length;\r\n        bool slashed;\r\n        for (uint i = 0; i < length; i++) {\r\n            if (challenges[slot][i].txHash != 0x0) {\r\n                // Penalize the exitor and reward the first valid challenger. \r\n                if (!slashed) {\r\n                    slashBond(coins[slot].exit.owner, challenges[slot][i].challenger);\r\n                    slashed = true;\r\n                }\r\n                // Also free the bond of the challenger.\r\n                freeBond(challenges[slot][i].challenger);\r\n\r\n                // Challenge resolved, delete it\r\n                delete challenges[slot][i];\r\n                hasChallenges = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Iterates through all of the initiated exits and finalizes those\r\n    ///      which have matured without being successfully challenged\r\n    function finalizeExits() external {\r\n        uint256 exitSlotsLength = exitSlots.length;\r\n        for (uint256 i = 0; i < exitSlotsLength; i++) {\r\n            finalizeExit(exitSlots[i]);\r\n        }\r\n    }\r\n\r\n    /// @dev Withdraw a UTXO that has been exited\r\n    /// @param slot The slot of the coin being withdrawn\r\n    function withdraw(uint64 slot) external isState(slot, State.EXITED) {\r\n        require(coins[slot].owner == msg.sender, \"You do not own that UTXO\");\r\n        uint256 uid = coins[slot].uid;\r\n        uint256 denomination = coins[slot].denomination;\r\n\r\n        // Delete the coin that is being withdrawn\r\n        Coin memory c = coins[slot];\r\n        delete coins[slot];\r\n        if (c.mode == Mode.ETH) {\r\n            msg.sender.transfer(denomination);\r\n        } else if (c.mode == Mode.ERC20) {\r\n            require(ERC20(c.contractAddress).transfer(msg.sender, denomination), \"transfer failed\");\r\n        } else if (c.mode == Mode.ERC721) {\r\n            ERC721(c.contractAddress).safeTransferFrom(address(this), msg.sender, uid);\r\n        } else {\r\n            revert(\"Invalid coin mode\");\r\n        }\r\n\r\n        emit Withdrew(\r\n            msg.sender,\r\n            slot,\r\n            c.mode,\r\n            c.contractAddress,\r\n            uid,\r\n            denomination\r\n        );\r\n    }\r\n\r\n    /******************** CHALLENGES ********************/\r\n\r\n    /// @dev Submits proof of a transaction before prevTx as an exit challenge\r\n    /// @notice Exitor has to call respondChallengeBefore and submit a\r\n    ///         transaction before prevTx or prevTx itself.\r\n    /// @param slot The slot corresponding to the coin whose exit is being challenged\r\n    /// @param prevTxBytes The RLP-encoded transaction involving a particular\r\n    ///        coin which took place directly before exitingTxBytes\r\n    /// @param txBytes The RLP-encoded transaction involving a particular\r\n    ///        coin which an exiting owner of the coin claims to be the latest\r\n    /// @param prevTxInclusionProof An inclusion proof of prevTx\r\n    /// @param txInclusionProof An inclusion proof of exitingTx\r\n    /// @param signature The signature of the txBytes by the coin\r\n    ///        owner indicated in prevTx\r\n    /// @param blocks An array of two block numbers, at index 0, the block\r\n    ///        containing the prevTx and at index 1, the block containing\r\n    ///        the exitingTx\r\n    function challengeBefore(\r\n        uint64 slot,\r\n        bytes prevTxBytes, bytes txBytes,\r\n        bytes prevTxInclusionProof, bytes txInclusionProof,\r\n        bytes signature,\r\n        uint256[2] blocks)\r\n        external\r\n        payable isBonded\r\n        isState(slot, State.EXITING)\r\n    {\r\n        doInclusionChecks(\r\n            prevTxBytes, txBytes,\r\n            prevTxInclusionProof, txInclusionProof,\r\n            signature,\r\n            blocks\r\n        );\r\n        setChallenged(slot, txBytes.getOwner(), blocks[1], txBytes.getHash());\r\n    }\r\n\r\n    /// @dev Submits proof of a later transaction that corresponds to a challenge\r\n    /// @notice Can only be called in the second window of the exit period.\r\n    /// @param slot The slot corresponding to the coin whose exit is being challenged\r\n    /// @param challengingTxHash The hash of the transaction\r\n    ///        corresponding to the challenge we're responding to\r\n    /// @param respondingBlockNumber The block number which included the transaction\r\n    ///        we are responding with\r\n    /// @param respondingTransaction The RLP-encoded transaction involving a particular\r\n    ///        coin which took place directly after challengingTransaction\r\n    /// @param proof An inclusion proof of respondingTransaction\r\n    /// @param signature The signature which proves a direct spend from the challenger\r\n    function respondChallengeBefore(\r\n        uint64 slot,\r\n        bytes32 challengingTxHash,\r\n        uint256 respondingBlockNumber,\r\n        bytes respondingTransaction,\r\n        bytes proof,\r\n        bytes signature)\r\n        external\r\n    {\r\n        // Check that the transaction being challenged exists\r\n        require(challenges[slot].contains(challengingTxHash), \"Responding to non existing challenge\");\r\n\r\n        // Get index of challenge in the challenges array\r\n        uint256 index = uint256(challenges[slot].indexOf(challengingTxHash));\r\n\r\n        checkResponse(slot, index, respondingBlockNumber, respondingTransaction, signature, proof);\r\n\r\n        // If the exit was actually challenged and responded, penalize the challenger and award the responder\r\n        slashBond(challenges[slot][index].challenger, msg.sender);\r\n\r\n        // Put coin back to the exiting state\r\n        coins[slot].state = State.EXITING;\r\n\r\n        challenges[slot].remove(challengingTxHash);\r\n        emit RespondedExitChallenge(slot);\r\n    }\r\n\r\n    function checkResponse(\r\n        uint64 slot,\r\n        uint256 index,\r\n        uint256 blockNumber,\r\n        bytes txBytes,\r\n        bytes signature,\r\n        bytes proof\r\n    )\r\n        private\r\n        view\r\n    {\r\n        Transaction.TX memory txData = txBytes.getTx();\r\n        require(txData.hash.ecverify(signature, challenges[slot][index].owner), \"Invalid signature\");\r\n        require(txData.slot == slot, \"Tx is referencing another slot\");\r\n        require(blockNumber > challenges[slot][index].challengingBlockNumber);\r\n        checkTxIncluded(txData.slot, txData.hash, blockNumber, proof);\r\n    }\r\n\r\n    function challengeBetween(\r\n        uint64 slot,\r\n        uint256 challengingBlockNumber,\r\n        bytes challengingTransaction,\r\n        bytes proof,\r\n        bytes signature)\r\n        external isState(slot, State.EXITING) cleanupExit(slot)\r\n    {\r\n        checkBetween(slot, challengingTransaction, challengingBlockNumber, signature, proof);\r\n        applyPenalties(slot);\r\n    }\r\n\r\n    function challengeAfter(\r\n        uint64 slot,\r\n        uint256 challengingBlockNumber,\r\n        bytes challengingTransaction,\r\n        bytes proof,\r\n        bytes signature)\r\n        external\r\n        isState(slot, State.EXITING)\r\n        cleanupExit(slot)\r\n    {\r\n        checkAfter(slot, challengingTransaction, challengingBlockNumber, signature, proof);\r\n        applyPenalties(slot);\r\n    }\r\n\r\n\r\n    // Must challenge with a tx in between\r\n\r\n    // Check that the challenging transaction has been signed\r\n    // by the attested previous owner of the coin in the exit\r\n    function checkBetween(\r\n        uint64 slot,\r\n        bytes txBytes,\r\n        uint blockNumber, \r\n        bytes signature, \r\n        bytes proof\r\n    ) \r\n        private \r\n        view \r\n    {\r\n        require(\r\n            coins[slot].exit.exitBlock > blockNumber &&\r\n            coins[slot].exit.prevBlock < blockNumber,\r\n            \"Tx should be between the exit's blocks\"\r\n        );\r\n\r\n        Transaction.TX memory txData = txBytes.getTx();\r\n        require(txData.hash.ecverify(signature, coins[slot].exit.prevOwner), \"Invalid signature\");\r\n        require(txData.slot == slot, \"Tx is referencing another slot\");\r\n        checkTxIncluded(slot, txData.hash, blockNumber, proof);\r\n    }\r\n\r\n    function checkAfter(uint64 slot, bytes txBytes, uint blockNumber, bytes signature, bytes proof) private view {\r\n        Transaction.TX memory txData = txBytes.getTx();\r\n        require(txData.hash.ecverify(signature, coins[slot].exit.owner), \"Invalid signature\");\r\n        require(txData.slot == slot, \"Tx is referencing another slot\");\r\n        require(txData.prevBlock == coins[slot].exit.exitBlock, \"Not a direct spend\");\r\n        checkTxIncluded(slot, txData.hash, blockNumber, proof);\r\n    }\r\n\r\n    function applyPenalties(uint64 slot) private {\r\n        // Apply penalties and change state\r\n        slashBond(coins[slot].exit.owner, msg.sender);\r\n        coins[slot].state = State.DEPOSITED;\r\n        emit CoinReset(slot, coins[slot].owner);\r\n    }\r\n\r\n    /// @param slot The slot of the coin being challenged\r\n    /// @param owner The user claimed to be the true ower of the coin\r\n    function setChallenged(uint64 slot, address owner, uint256 challengingBlockNumber, bytes32 txHash) private {\r\n        // Require that the challenge is in the first half of the challenge window\r\n        require(block.timestamp <= coins[slot].exit.createdAt + CHALLENGE_WINDOW);\r\n\r\n        require(!challenges[slot].contains(txHash),\r\n                \"Transaction used for challenge already\");\r\n\r\n        // Need to save the exiting transaction's owner, to verify\r\n        // that the response is valid\r\n        challenges[slot].push(\r\n            ChallengeLib.Challenge({\r\n                owner: owner,\r\n                challenger: msg.sender,\r\n                txHash: txHash,\r\n                challengingBlockNumber: challengingBlockNumber\r\n            })\r\n        );\r\n\r\n        emit ChallengedExit(slot, txHash, challengingBlockNumber);\r\n    }\r\n\r\n    /******************** BOND RELATED ********************/\r\n\r\n    function freeBond(address from) private {\r\n        balances[from].bonded = balances[from].bonded.sub(BOND_AMOUNT);\r\n        balances[from].withdrawable = balances[from].withdrawable.add(BOND_AMOUNT);\r\n        emit FreedBond(from, BOND_AMOUNT);\r\n    }\r\n\r\n    function withdrawBonds() external {\r\n        // Can only withdraw bond if the msg.sender\r\n        uint256 amount = balances[msg.sender].withdrawable;\r\n        balances[msg.sender].withdrawable = 0; // no reentrancy!\r\n\r\n        msg.sender.transfer(amount);\r\n        emit WithdrewBonds(msg.sender, amount);\r\n    }\r\n\r\n    function slashBond(address from, address to) private {\r\n        balances[from].bonded = balances[from].bonded.sub(BOND_AMOUNT);\r\n        balances[to].withdrawable = balances[to].withdrawable.add(BOND_AMOUNT);\r\n        emit SlashedBond(from, to, BOND_AMOUNT);\r\n    }\r\n\r\n    /******************** PROOF CHECKING ********************/\r\n\r\n    function checkIncludedAndSigned(\r\n        bytes exitingTxBytes,\r\n        bytes exitingTxInclusionProof,\r\n        bytes signature,\r\n        uint256 blk)\r\n        private\r\n        view\r\n    {\r\n        Transaction.TX memory txData = exitingTxBytes.getTx();\r\n\r\n        // Deposit transactions need to be signed by their owners\r\n        // e.g. Alice signs a transaction to Alice\r\n        require(txData.hash.ecverify(signature, txData.owner), \"Invalid signature\");\r\n        checkTxIncluded(txData.slot, txData.hash, blk, exitingTxInclusionProof);\r\n    }\r\n\r\n    function checkBothIncludedAndSigned(\r\n        bytes prevTxBytes, bytes exitingTxBytes,\r\n        bytes prevTxInclusionProof, bytes exitingTxInclusionProof,\r\n        bytes signature,\r\n        uint256[2] blocks)\r\n        private\r\n        view\r\n    {\r\n        require(blocks[0] < blocks[1]);\r\n\r\n        Transaction.TX memory exitingTxData = exitingTxBytes.getTx();\r\n        Transaction.TX memory prevTxData = prevTxBytes.getTx();\r\n\r\n        // Both transactions need to be referring to the same slot\r\n        require(exitingTxData.slot == prevTxData.slot);\r\n\r\n        // The exiting transaction must be signed by the previous transaciton's owner\r\n        require(exitingTxData.hash.ecverify(signature, prevTxData.owner), \"Invalid signature\");\r\n\r\n        // Both transactions must be included in their respective blocks\r\n        checkTxIncluded(prevTxData.slot, prevTxData.hash, blocks[0], prevTxInclusionProof);\r\n        checkTxIncluded(exitingTxData.slot, exitingTxData.hash, blocks[1], exitingTxInclusionProof);\r\n    }\r\n\r\n    function checkTxIncluded(\r\n        uint64 slot, \r\n        bytes32 txHash, \r\n        uint256 blockNumber,\r\n        bytes proof\r\n    ) \r\n        private \r\n        view \r\n    {\r\n        bytes32 root = childChain[blockNumber].root;\r\n\r\n        if (blockNumber % childBlockInterval != 0) {\r\n            // Check against block root for deposit block numbers\r\n            require(txHash == root);\r\n        } else {\r\n            // Check against merkle tree for all other block numbers\r\n            require(\r\n                checkMembership(\r\n                    txHash,\r\n                    root,\r\n                    slot,\r\n                    proof\r\n            ),\r\n            \"Tx not included in claimed block\"\r\n            );\r\n        }\r\n    }\r\n\r\n    /******************** DEPOSIT FUNCTIONS ********************/\r\n\r\n    function() payable public {\r\n        deposit(msg.sender, msg.sender, 0, msg.value, Mode.ETH);\r\n    }\r\n\r\n    function onERC20Received(address _from, uint256 _amount, bytes)\r\n        public\r\n        isTokenApproved(msg.sender)\r\n        returns(bytes4)\r\n    {\r\n        deposit(_from, msg.sender, 0, _amount, Mode.ERC20);\r\n        return ERC20_RECEIVED;\r\n    }\r\n\r\n\r\n    function onERC721Received(address _from, uint256 _uid, bytes)\r\n        public\r\n        isTokenApproved(msg.sender)\r\n        returns(bytes4)\r\n    {\r\n        deposit(_from, msg.sender, _uid, 1, Mode.ERC721);\r\n        return ERC721_RECEIVED;\r\n    }\r\n\r\n    // Approve and Deposit function for 2-step deposits without having to approve the token by the validators\r\n    // Requires first to have called `approve` on the specified ERC20 contract\r\n    function depositERC20(uint256 amount, address contractAddress) external {\r\n        require(ERC20(contractAddress).transferFrom(msg.sender, address(this), amount), \"Transfer failed\");\r\n        deposit(msg.sender, contractAddress, 0, amount, Mode.ERC20);\r\n    }\r\n\r\n    // Approve and Deposit function for 2-step deposits without having to approve the token by the validators\r\n    // Requires first to have called `approve` on the specified ERC721 contract\r\n    function depositERC721(uint256 uid, address contractAddress) external {\r\n        ERC721(contractAddress).safeTransferFrom(msg.sender, address(this), uid);\r\n        deposit(msg.sender, contractAddress, uid, 1, Mode.ERC721);\r\n    }\r\n\r\n    /******************** HELPERS ********************/\r\n\r\n    /// @notice If the slot's exit is not found, a large number is returned to\r\n    ///         ensure the exit array access fails\r\n    /// @param slot The slot being exited\r\n    /// @return The index of the slot's exit in the exitSlots array\r\n    function getExitIndex(uint64 slot) private view returns (uint256) {\r\n        uint256 len = exitSlots.length;\r\n        for (uint256 i = 0; i < len; i++) {\r\n            if (exitSlots[i] == slot)\r\n                return i;\r\n        }\r\n        // a default value to return larger than the possible number of coins\r\n        return 2**65;\r\n    }\r\n\r\n    function checkMembership(\r\n        bytes32 txHash,\r\n        bytes32 root,\r\n        uint64 slot,\r\n        bytes proof) public view returns (bool)\r\n    {\r\n        return smt.checkMembership(\r\n            txHash,\r\n            root,\r\n            slot,\r\n            proof);\r\n    }\r\n\r\n    function getPlasmaCoin(uint64 slot) external view returns(uint256, uint256, uint256, address, State, Mode, address) {\r\n        Coin memory c = coins[slot];\r\n        return (c.uid, c.depositBlock, c.denomination, c.owner, c.state, c.mode, c.contractAddress);\r\n    }\r\n\r\n    function getChallenge(uint64 slot, bytes32 txHash) \r\n        external \r\n        view \r\n        returns(address, address, bytes32, uint256)\r\n    {\r\n        uint256 index = uint256(challenges[slot].indexOf(txHash));\r\n        ChallengeLib.Challenge memory c = challenges[slot][index];\r\n        return (c.owner, c.challenger, c.txHash, c.challengingBlockNumber);\r\n    }\r\n\r\n    function getExit(uint64 slot) external view returns(address, uint256, uint256, State) {\r\n        Exit memory e = coins[slot].exit;\r\n        return (e.owner, e.prevBlock, e.exitBlock, coins[slot].state);\r\n    }\r\n\r\n    function getBlockRoot(uint256 blockNumber) public view returns (bytes32 root) {\r\n        root = childChain[blockNumber].root;\r\n    }\r\n}\r\n\r\ncontract SparseMerkleTree {\r\n\r\n    uint8 constant DEPTH = 64;\r\n    bytes32[DEPTH + 1] public defaultHashes;\r\n\r\n    constructor() public {\r\n        // defaultHash[0] is being set to keccak256(uint256(0));\r\n        defaultHashes[0] = 0x290decd9548b62a8d60345a988386fc84ba6bc95484008f6362f93160ef3e563;\r\n        setDefaultHashes(1, DEPTH);\r\n    }\r\n\r\n    function checkMembership(\r\n        bytes32 leaf,\r\n        bytes32 root,\r\n        uint64 tokenID,\r\n        bytes proof) public view returns (bool)\r\n    {\r\n        bytes32 computedHash = getRoot(leaf, tokenID, proof);\r\n        return (computedHash == root);\r\n    }\r\n\r\n    // first 64 bits of the proof are the 0/1 bits\r\n    function getRoot(bytes32 leaf, uint64 index, bytes proof) public view returns (bytes32) {\r\n        require((proof.length - 8) % 32 == 0 && proof.length <= 2056);\r\n        bytes32 proofElement;\r\n        bytes32 computedHash = leaf;\r\n        uint16 p = 8;\r\n        uint64 proofBits;\r\n        assembly {proofBits := div(mload(add(proof, 32)), exp(256, 24))}\r\n\r\n        for (uint d = 0; d < DEPTH; d++ ) {\r\n            if (proofBits % 2 == 0) { // check if last bit of proofBits is 0\r\n                proofElement = defaultHashes[d];\r\n            } else {\r\n                p += 32;\r\n                require(proof.length >= p);\r\n                assembly { proofElement := mload(add(proof, p)) }\r\n            }\r\n            if (index % 2 == 0) {\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n            proofBits = proofBits / 2; // shift it right for next bit\r\n            index = index / 2;\r\n        }\r\n        return computedHash;\r\n    }\r\n\r\n    function setDefaultHashes(uint8 startIndex, uint8 endIndex) private {\r\n        for (uint8 i = startIndex; i <= endIndex; i ++) {\r\n            defaultHashes[i] = keccak256(abi.encodePacked(defaultHashes[i-1], defaultHashes[i-1]));\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Transaction {\r\n\r\n    using RLP for bytes;\r\n    using RLP for RLP.RLPItem;\r\n\r\n    struct TX {\r\n        uint64 slot;\r\n        address owner;\r\n        bytes32 hash;\r\n        uint256 prevBlock;\r\n        uint256 denomination; \r\n    }\r\n\r\n    function getTx(bytes memory txBytes) internal pure returns (TX memory) {\r\n        RLP.RLPItem[] memory rlpTx = txBytes.toRLPItem().toList(4);\r\n        TX memory transaction;\r\n\r\n        transaction.slot = uint64(rlpTx[0].toUint());\r\n        transaction.prevBlock = rlpTx[1].toUint();\r\n        transaction.denomination = rlpTx[2].toUint();\r\n        transaction.owner = rlpTx[3].toAddress();\r\n        if (transaction.prevBlock == 0) { // deposit transaction\r\n            transaction.hash = keccak256(abi.encodePacked(transaction.slot));\r\n        } else {\r\n            transaction.hash = keccak256(txBytes);\r\n        }\r\n        return transaction;\r\n    }\r\n\r\n    function getHash(bytes memory txBytes) internal pure returns (bytes32 hash) {\r\n        RLP.RLPItem[] memory rlpTx = txBytes.toRLPItem().toList(4);\r\n        uint64 slot = uint64(rlpTx[0].toUint());\r\n        uint256 prevBlock = uint256(rlpTx[1].toUint());\r\n\r\n        if (prevBlock == 0) { // deposit transaction\r\n            hash = keccak256(abi.encodePacked(slot));\r\n        } else {\r\n            hash = keccak256(txBytes);\r\n        }\r\n    }\r\n\r\n    function getOwner(bytes memory txBytes) internal pure returns (address owner) {\r\n        RLP.RLPItem[] memory rlpTx = txBytes.toRLPItem().toList(4);\r\n        owner = rlpTx[3].toAddress();\r\n    }\r\n}\r\n\r\ncontract ValidatorManagerContract is Ownable {\r\n\r\n    mapping (address => bool) public validators;\r\n    mapping (address => bool) public allowedTokens;\r\n\r\n    function checkValidator(address _address) public view returns (bool) {\r\n        // owner is a permanent validator\r\n        if (_address == owner)\r\n            return true;\r\n        return validators[_address];\r\n    }\r\n\r\n    function toggleValidator(address _address) public onlyOwner {\r\n        validators[_address] = !validators[_address];\r\n    }\r\n\r\n    function toggleToken(address _token) public {\r\n        require(checkValidator(msg.sender), \"not a validator\");\r\n        allowedTokens[_token] = !allowedTokens[_token];\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"},{\"name\":\"challengingBlockNumber\",\"type\":\"uint256\"},{\"name\":\"challengingTransaction\",\"type\":\"bytes\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"challengeAfter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBonds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"bonded\",\"type\":\"uint256\"},{\"name\":\"withdrawable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"childBlockInterval\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"depositERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"},{\"name\":\"challengingTxHash\",\"type\":\"bytes32\"},{\"name\":\"respondingBlockNumber\",\"type\":\"uint256\"},{\"name\":\"respondingTransaction\",\"type\":\"bytes\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"respondChallengeBefore\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC20Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"finalizeExit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"},{\"name\":\"txHash\",\"type\":\"bytes32\"}],\"name\":\"getChallenge\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"},{\"name\":\"prevTxBytes\",\"type\":\"bytes\"},{\"name\":\"txBytes\",\"type\":\"bytes\"},{\"name\":\"prevTxInclusionProof\",\"type\":\"bytes\"},{\"name\":\"txInclusionProof\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"blocks\",\"type\":\"uint256[2]\"}],\"name\":\"challengeBefore\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numCoins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"root\",\"type\":\"bytes32\"}],\"name\":\"submitBlock\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"exitSlots\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeExits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uid\",\"type\":\"uint256\"},{\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"depositERC721\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"getExit\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentBlock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"getBlockRoot\",\"outputs\":[{\"name\":\"root\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"},{\"name\":\"prevTxBytes\",\"type\":\"bytes\"},{\"name\":\"exitingTxBytes\",\"type\":\"bytes\"},{\"name\":\"prevTxInclusionProof\",\"type\":\"bytes\"},{\"name\":\"exitingTxInclusionProof\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"},{\"name\":\"blocks\",\"type\":\"uint256[2]\"}],\"name\":\"startExit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_uid\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"txHash\",\"type\":\"bytes32\"},{\"name\":\"root\",\"type\":\"bytes32\"},{\"name\":\"slot\",\"type\":\"uint64\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"checkMembership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"},{\"name\":\"challengingBlockNumber\",\"type\":\"uint256\"},{\"name\":\"challengingTransaction\",\"type\":\"bytes\"},{\"name\":\"proof\",\"type\":\"bytes\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"challengeBetween\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"getPlasmaCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"childChain\",\"outputs\":[{\"name\":\"root\",\"type\":\"bytes32\"},{\"name\":\"createdAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_vmc\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"denomination\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"root\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"SubmittedBlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint64\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"StartedExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"txHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"challengingBlockNumber\",\"type\":\"uint256\"}],\"name\":\"ChallengedExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint64\"}],\"name\":\"RespondedExitChallenge\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint64\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"CoinReset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"FinalizedExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"FreedBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"SlashedBond\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrewBonds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"slot\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"mode\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"uid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"denomination\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"}]","ContractName":"RootChain","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000f1ffd3f1598cd054f5031b2af219d85b0d443175","Library":"","SwarmSource":"bzzr://8e27bdac4a9adde91acf1e506e6dfd434bc13ac193910017a74a23a1a7ab7bd1"}]}