{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n/** title -LuckyETH- v0.1.0\r\n* ┌┬┐┌─┐┌─┐┌┬┐  ╦    ╦  ┌─┐┬─┐┌─┐┌─┐┌─┐┌┐┌┌┬┐┌─┐ \r\n*  │ ├┤ ├─┤│││   ║  ║   ├─┘├┬┘├┤ └─┐├┤ │││ │ └─┐\r\n*  ┴ └─┘┴ ┴┴ ┴    ╚╝    ┴  ┴└─└─┘└─┘└─┘┘└┘ ┴ └─┘  \r\n*/\r\n\r\n//==============================================================================\r\n//     _    _  _ _|_ _  .\r\n//    (/_\\/(/_| | | _\\  .\r\n//==============================================================================\r\ncontract LuckyEvents {\r\n    // fired at end of buy\r\n    event onEndTx\r\n    (\r\n        address player,\r\n        uint256 playerID,\r\n        uint256 ethIn,\r\n        address wonAddress,\r\n        uint256 wonAmount,          // amount won\r\n        uint256 genAmount,          // amount distributed to gen\r\n        uint256 airAmount          // amount added to airdrop\r\n    );\r\n    \r\n\t// fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n}\r\n\r\n//==============================================================================\r\n//   __|_ _    __|_ _  .\r\n//  _\\ | | |_|(_ | _\\  .\r\n//==============================================================================\r\nlibrary LuckyDatasets {\r\n    struct EventReturns {\r\n        address player;\r\n        uint256 playerID;\r\n        uint256 ethIn;\r\n        address wonAddress;         // address won\r\n        uint256 wonAmount;          // amount won\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 airAmount;          // amount added to airdrop\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n}\r\n\r\ncontract LuckyETH is LuckyEvents, Ownable  {\r\n    using SafeMath for *;\r\n    \r\n//==============================================================================\r\n//     _ _  _  |`. _     _ _ |_ | _  _  .\r\n//    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings)\r\n//=================_|===========================================================\r\n    string constant public name = \"Lucky ETH\";\r\n    string constant public symbol = \"L\";\r\n//****************\r\n// Pot DATA \r\n//****************\r\n    uint256 public pIndex; // the index for next player\r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store distributed info that changes)\r\n//=============================|================================================\r\n\tuint256 public genPot_;             // distributed pot for all players\r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store airdrop info that changes)\r\n//=============================|================================================\r\n\tuint256 public airDropPot_;             // person who gets the airdrop wins part of this pot\r\n    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop\r\n//****************\r\n// PLAYER DATA \r\n//****************\r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (address => address) public pAff_;              // (addr => affAddr)\r\n//****************\r\n// TEAM FEE DATA \r\n//****************\r\n    // TeamV act as player\r\n    address public teamV;\r\n//==============================================================================\r\n//     _ _  _  __|_ _    __|_ _  _  .\r\n//    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n//==============================================================================\r\n    constructor()\r\n        public\r\n    {\r\n        // player id start from 1\r\n        pIndex = 1;\r\n\t}\r\n\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================\r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        require (_addr == tx.origin);\r\n        \r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); /** 1Gwei **/\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");    /** 1 KEth **/\r\n\t\t_;    \r\n\t}\r\n\t\r\n//==============================================================================\r\n//     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n//====|=========================================================================\r\n\r\n    function ()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        address _affAddr = address(0);\r\n        if (pAff_[msg.sender] != address(0)) {\r\n            _affAddr = pAff_[msg.sender];\r\n        }\r\n        core(msg.sender, msg.value, _affAddr);\r\n    }\r\n    \r\n    /**\r\n     * @dev converts all incoming ethereum to keys.\r\n     * -functionhash- 0x98a0871d (using address for affiliate)\r\n     * @param _affAddr the address of the player who gets the affiliate fee\r\n     */\r\n    function buy(address _affAddr)\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        public\r\n        payable\r\n    {\r\n        if (_affAddr == address(0)) {\r\n            _affAddr = pAff_[msg.sender];\r\n        } else {\r\n            pAff_[msg.sender] = _affAddr;\r\n        }\r\n        core(msg.sender, msg.value, _affAddr);\r\n    }\r\n    \r\n    /**\r\n     * @dev withdraws all of your earnings.\r\n     * -functionhash- 0x3ccfd60b\r\n     */\r\n    function withdraw()\r\n        isHuman()\r\n        public\r\n    {\r\n       playerWithdraw(msg.sender);\r\n    }\r\n    \r\n    /**\r\n     * @dev updateTeamV withdraw and buy\r\n     */\r\n    function updateTeamV(address _team)\r\n        onlyOwner()\r\n        public\r\n    {\r\n        if (teamV != address(0)) {\r\n           playerWithdraw(teamV);\r\n        }\r\n        core(_team, 0, address(0));\r\n        teamV = _team;\r\n    }\r\n    \r\n    /**\r\n     * @dev this is the core logic for any buy\r\n     * is live.\r\n     */\r\n    function core(address _pAddr, uint256 _eth, address _affAddr)\r\n        private\r\n    {\r\n        // set up our tx event data\r\n        LuckyDatasets.EventReturns memory _eventData_;\r\n        _eventData_.player = _pAddr;\r\n        \r\n        uint256 _pID =  pIDxAddr_[_pAddr];\r\n        if (_pID == 0) {\r\n            _pID = pIndex;\r\n            pIndex = pIndex.add(1);\r\n            pIDxAddr_[_pAddr] = _pID;\r\n        }\r\n         _eventData_.playerID = _pID;\r\n         _eventData_.ethIn = _eth;\r\n        \r\n        // manage airdrops\r\n        if (_eth >= 100000000000000000)\r\n        {\r\n            airDropTracker_++;\r\n            if (airdrop() == true)\r\n            {\r\n                // gib muni\r\n                uint256 _prize = 0;\r\n                if (_eth >= 10000000000000000000)\r\n                {\r\n                    // calculate prize\r\n                    _prize = ((airDropPot_).mul(75)) / 100;\r\n                } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n                    // calculate prize\r\n                    _prize = ((airDropPot_).mul(50)) / 100;\r\n                } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\r\n                    // calculate prize\r\n                    _prize = ((airDropPot_).mul(25)) / 100;\r\n                }\r\n                \r\n                // adjust airDropPot \r\n                airDropPot_ = (airDropPot_).sub(_prize);\r\n                    \r\n                // give prize to winner\r\n                _pAddr.transfer(_prize);\r\n                    \r\n                // set airdrop happened bool to true\r\n                _eventData_.wonAddress = _pAddr;\r\n                // let event know how much was won \r\n                _eventData_.wonAmount = _prize;\r\n                \r\n                \r\n                // reset air drop tracker\r\n                airDropTracker_ = 0;\r\n            }\r\n        }\r\n        \r\n        // 20% for affiliate share fee\r\n        uint256 _aff = _eth / 5;\r\n        // 30% for _distributed rewards\r\n        uint256 _gen = _eth.mul(30) / 100;\r\n        // 50% for pot\r\n        uint256 _airDrop = _eth.sub(_aff.add(_gen));\r\n       \r\n        // distributeExternal\r\n        uint256 _affID = pIDxAddr_[_affAddr];\r\n        if (_affID != 0 && _affID != _pID) {\r\n            _affAddr.transfer(_aff);\r\n        } else {\r\n            _airDrop = _airDrop.add(_aff);\r\n        }\r\n\r\n        airDropPot_ = airDropPot_.add(_airDrop);\r\n        genPot_ = genPot_.add(_gen);\r\n\r\n        // set up event data\r\n        _eventData_.genAmount = _gen;\r\n        _eventData_.airAmount = _airDrop;\r\n\r\n        // call end tx function to fire end tx event.\r\n        endTx(_eventData_);\r\n    }\r\n    \r\n    function airdrop()\r\n        private \r\n        view \r\n        returns(bool)\r\n    {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            \r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) <= airDropTracker_)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n    \r\n    /**\r\n     * @dev prepares compression data and fires event for buy or reload tx's\r\n     */\r\n    function endTx(LuckyDatasets.EventReturns memory _eventData_)\r\n        private\r\n    {\r\n        emit LuckyEvents.onEndTx\r\n        (\r\n            _eventData_.player,\r\n            _eventData_.playerID,\r\n            _eventData_.ethIn,\r\n            _eventData_.wonAddress,\r\n            _eventData_.wonAmount,\r\n            _eventData_.genAmount,\r\n            _eventData_.airAmount\r\n        );\r\n    }\r\n    \r\n      /**\r\n     * @dev withdraws all of your earnings.\r\n     * -functionhash- 0x3ccfd60b\r\n     */\r\n    function playerWithdraw(address _pAddr)\r\n        private\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // player \r\n        uint256 _pID =  pIDxAddr_[_pAddr];\r\n        require(_pID != 0, \"no, no, no...\");\r\n        delete(pIDxAddr_[_pAddr]);\r\n        delete(pAff_[_pAddr]);\r\n        pIDxAddr_[_pAddr] = 0; // oh~~\r\n        \r\n         // set up our tx event data\r\n        LuckyDatasets.EventReturns memory _eventData_;\r\n        _eventData_.player = _pAddr;\r\n        \r\n        // setup local rID\r\n        uint256 _pIndex = pIndex;\r\n        uint256 _gen = genPot_;\r\n        uint256 _sum = _pIndex.mul(_pIndex.sub(1)) / 2;\r\n        uint256 _percent = _pIndex.sub(1).sub(_pID);\r\n        assert(_percent < _pIndex);\r\n        _percent = _gen.mul(_percent) / _sum;\r\n        \r\n        genPot_ = genPot_.sub(_percent);\r\n        _pAddr.transfer(_percent);\r\n        \r\n        \r\n        // fire withdraw event\r\n        emit LuckyEvents.onWithdraw(_pID, _pAddr, _percent, _now);\r\n        \r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pAff_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"genPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_team\",\"type\":\"address\"}],\"name\":\"updateTeamV\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamV\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affAddr\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"wonAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wonAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"airAmount\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"}]","ContractName":"LuckyETH","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b918ccf2d39d1fc16a746c58fb4ec145811c3c795adbe19279a4a1f05cc0c04d"}]}