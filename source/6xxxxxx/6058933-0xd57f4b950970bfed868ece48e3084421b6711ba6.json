{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// copyright vFloorplan Ltd 2018\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n*/\r\n \r\nlibrary SafeMath \r\n{\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n  {\r\n      if (a==0)\r\n      {\r\n          return 0;\r\n      }\r\n      \r\n    uint256 c = a * b;\r\n    assert(c / a == b); // assert on overflow\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n  {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n  {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256)\r\n  {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic\r\n{\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic\r\n{\r\n    // founder details\r\n    address public constant FOUNDER_ADDRESS1 = 0xcb8Fb8Bf927e748c0679375B26fb9f2F12f3D5eE;\r\n    address public constant FOUNDER_ADDRESS2 = 0x1Ebfe7c17a22E223965f7B80c02D3d2805DFbE5F;\r\n    address public constant FOUNDER_ADDRESS3 = 0x9C5076C3e95C0421699A6D9d66a219BF5Ba5D826;\r\n    \r\n    address public constant FOUNDER_FUND_1 = 9000000000;\r\n    address public constant FOUNDER_FUND_2 = 9000000000;\r\n    address public constant FOUNDER_FUND_3 = 7000000000;\r\n    \r\n    // deposit address for reserve / crowdsale\r\n    address public constant MEW_RESERVE_FUND = 0xD11ffBea1cE043a8d8dDDb85F258b1b164AF3da4; // multisig\r\n    address public constant MEW_CROWDSALE_FUND = 0x842C4EA879050742b42c8b2E43f1C558AD0d1741; // multisig\r\n    \r\n    uint256 public constant decimals = 18;\r\n    \r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n  \r\n  // all initialised to false - do we want multi-state? maybe... \r\n  mapping(address => uint256) public mCanSpend;\r\n  mapping(address => uint256) public mEtherSpent;\r\n  \r\n  int256 public mEtherValid;\r\n  int256 public mEtherInvalid;\r\n  \r\n  // real\r\n  // standard unlocked tokens will vest immediately on the prime vesting date\r\n  // founder tokens will vest at a rate per day\r\n  uint256 public constant TOTAL_RESERVE_FUND =  40 * (10**9) * 10**decimals;  // 40B reserve created before sale\r\n  uint256 public constant TOTAL_CROWDSALE_FUND =  60 * (10**9) * 10**decimals;  // 40B reserve created before sale\r\n  uint256 public PRIME_VESTING_DATE = 0xffffffffffffffff; // will set to rough dates then fix at end of sale\r\n  uint256 public FINAL_AML_DATE = 0xffffffffffffffff; // will set to rough date + 3 months then fix at end of sale\r\n  uint256 public constant FINAL_AML_DAYS = 90;\r\n  uint256 public constant DAYSECONDS = 24*60*60;//86400; // 1 day in seconds // 1 minute vesting\r\n  \r\n  mapping(address => uint256) public mVestingDays;  // number of days to fully vest\r\n  mapping(address => uint256) public mVestingBalance; // total balance which will vest\r\n  mapping(address => uint256) public mVestingSpent; // total spent\r\n  mapping(address => uint256) public mVestingBegins; // total spent\r\n  \r\n  mapping(address => uint256) public mVestingAllowed; // really just for checking\r\n  \r\n  // used to enquire about the ether spent to buy the tokens\r\n  function GetEtherSpent(address from) view public returns (uint256)\r\n  {\r\n      return mEtherSpent[from];\r\n  }\r\n  \r\n  // removes tokens and returns them to the main pool\r\n  // this is called if \r\n  function RevokeTokens(address target) internal\r\n  {\r\n      //require(mCanSpend[from]==0),\"Can only call this if AML hasn't been completed correctly\");\r\n      // block this address from further spending\r\n      require(mCanSpend[target]!=9);\r\n      mCanSpend[target]=9;\r\n      \r\n      uint256 _value = balances[target];\r\n      \r\n      balances[target] = 0;//just wipe the balance\r\n      \r\n      balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(_value);\r\n      \r\n      // let the blockchain know its been revoked\r\n      emit Transfer(target, MEW_RESERVE_FUND, _value);\r\n  }\r\n  \r\n  function LockedCrowdSale(address target) view internal returns (bool)\r\n  {\r\n      if (mCanSpend[target]==0 && mEtherSpent[target]>0)\r\n      {\r\n          return true;\r\n      }\r\n      return false;\r\n  }\r\n  \r\n  function CheckRevoke(address target) internal returns (bool)\r\n  {\r\n      // roll vesting / dates and AML in to a single function\r\n      // this will stop coins being spent on new addresses until after \r\n      // we know if they took part in the crowdsale by checking if they spent ether\r\n      if (LockedCrowdSale(target))\r\n      {\r\n         if (block.timestamp>FINAL_AML_DATE)\r\n         {\r\n             RevokeTokens(target);\r\n             return true;\r\n         }\r\n      }\r\n      \r\n      return false;\r\n  }\r\n  \r\n  function ComputeVestSpend(address target) public returns (uint256)\r\n  {\r\n      require(mCanSpend[target]==2); // only compute for vestable accounts\r\n      int256 vestingDays = int256(mVestingDays[target]);\r\n      int256 vestingProgress = (int256(block.timestamp)-int256(mVestingBegins[target]))/(int256(DAYSECONDS));\r\n      \r\n      // cap the vesting\r\n      if (vestingProgress>vestingDays)\r\n      {\r\n          vestingProgress=vestingDays;\r\n      }\r\n          \r\n      // whole day vesting e.g. day 0 nothing vested, day 1 = 1 day vested    \r\n      if (vestingProgress>0)\r\n      {\r\n              \r\n        int256 allowedVest = ((int256(mVestingBalance[target])*vestingProgress))/vestingDays;\r\n                  \r\n        int256 combined = allowedVest-int256(mVestingSpent[target]);\r\n        \r\n        // store the combined value so people can see their vesting (useful for debug too)\r\n        mVestingAllowed[target] = uint256(combined);\r\n        \r\n        return uint256(combined);\r\n      }\r\n      \r\n      // no vesting allowed\r\n      mVestingAllowed[target]=0;\r\n      \r\n      // cannot spend anything\r\n      return 0;\r\n  }\r\n  \r\n  // 0 locked \r\n  // 1 unlocked\r\n  // 2 vestable\r\n  function canSpend(address from, uint256 amount) internal returns (bool permitted)\r\n  {\r\n      uint256 currentTime = block.timestamp;\r\n      \r\n      // refunded / blocked\r\n      if (mCanSpend[from]==8)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      // revoked / blocked\r\n      if (mCanSpend[from]==9)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      // roll vesting / dates and AML in to a single function\r\n      // this will stop coins being spent on new addresses until after \r\n      if (LockedCrowdSale(from))\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      if (mCanSpend[from]==1)\r\n      {\r\n          // tokens can only move when sale is finished\r\n          if (currentTime>PRIME_VESTING_DATE)\r\n          {\r\n             return true;\r\n          }\r\n          return false;\r\n      }\r\n      \r\n      // special vestable tokens\r\n      if (mCanSpend[from]==2)\r\n      {\r\n              \r\n        if (ComputeVestSpend(from)>=amount)\r\n            {\r\n              return true;\r\n            }\r\n            else\r\n            {\r\n              return false;   \r\n            }\r\n      }\r\n      \r\n      return false;\r\n  }\r\n  \r\n   // 0 locked \r\n  // 1 unlocked\r\n  // 2 vestable\r\n  function canTake(address from) view public returns (bool permitted)\r\n  {\r\n      uint256 currentTime = block.timestamp;\r\n      \r\n      // refunded / blocked\r\n      if (mCanSpend[from]==8)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      // revoked / blocked\r\n      if (mCanSpend[from]==9)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      // roll vesting / dates and AML in to a single function\r\n      // this will stop coins being spent on new addresses until after \r\n      if (LockedCrowdSale(from))\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      if (mCanSpend[from]==1)\r\n      {\r\n          // tokens can only move when sale is finished\r\n          if (currentTime>PRIME_VESTING_DATE)\r\n          {\r\n             return true;\r\n          }\r\n          return false;\r\n      }\r\n      \r\n      // special vestable tokens\r\n      if (mCanSpend[from]==2)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      return true;\r\n  }\r\n  \r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool success) \r\n  {\r\n       // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender)||CheckRevoke(_to))\r\n      {\r\n          return false;\r\n      }\r\n     \r\n    require(canSpend(msg.sender, _value)==true);//, \"Cannot spend this amount - AML or not vested\")\r\n    require(canTake(_to)==true); // must be aml checked or unlocked wallet no vesting\r\n    \r\n    if (balances[msg.sender] >= _value) \r\n    {\r\n      // deduct the spend first (this is unlikely attack vector as only a few people will have vesting tokens)\r\n      // special tracker for vestable funds - if have a date up\r\n      if (mCanSpend[msg.sender]==2)\r\n      {\r\n        mVestingSpent[msg.sender] = mVestingSpent[msg.sender].add(_value);\r\n      }\r\n      \r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      balances[_to] = balances[_to].add(_value);\r\n      emit Transfer(msg.sender, _to, _value);\r\n      \r\n      \r\n      // set can spend on destination as it will be transferred from approved wallet\r\n      mCanSpend[_to]=1;\r\n      \r\n      return true;\r\n    } \r\n    else\r\n    {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // in the light of our sanity allow a utility to whole number of tokens and 1/10000 token transfer\r\n  function simpletransfer(address _to, uint256 _whole, uint256 _fraction) public returns (bool success) \r\n  {\r\n    require(_fraction<10000);//, \"Fractional part must be less than 10000\");\r\n    \r\n    uint256 main = _whole.mul(10**decimals); // works fine now i've removed the retarded divide by 0 assert in safemath\r\n    uint256 part = _fraction.mul(10**14);\r\n    uint256 value = main + part;\r\n    \r\n    // just call the transfer\r\n    return transfer(_to, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 returnbalance) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic \r\n{\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken \r\n{\r\n  // need to add\r\n  // also need\r\n  // invalidate - used to drop all unauthorised buyers, return their tokens to reserve\r\n  // freespend - all transactions now allowed - this could be used to vest tokens?\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) \r\n   {\r\n      // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender)||CheckRevoke(_to))\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      require(canSpend(_from, _value)== true);//, \"Cannot spend this amount - AML or not vested\")\r\n      require(canTake(_to)==true); // must be aml checked or unlocked wallet no vesting\r\n     \r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) \r\n    {\r\n      balances[_to] = balances[_to].add(_value);\r\n      balances[_from] = balances[_from].sub(_value);\r\n      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n      emit Transfer(_from, _to, _value);\r\n      \r\n      \r\n      // set can spend on destination as it will be transferred from approved wallet\r\n      mCanSpend[_to]=1;\r\n      \r\n      // special tracker for vestable funds - if have a date set\r\n      if (mCanSpend[msg.sender]==2)\r\n      {\r\n        mVestingSpent[msg.sender] = mVestingSpent[msg.sender].add(_value);\r\n      }\r\n      return true;\r\n    } \r\n    else \r\n    {\r\n     //   endsigning();\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool)\r\n  {\r\n      // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender))\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      require(canSpend(msg.sender, _value)==true);//, \"Cannot spend this amount - AML or not vested\");\r\n      \r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) \r\n  {\r\n      // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender))\r\n      {\r\n          return false;\r\n      }\r\n      require(canSpend(msg.sender, _addedValue)==true);//, \"Cannot spend this amount - AML or not vested\");\r\n      \r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success)\r\n  {\r\n      // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender))\r\n      {\r\n          return false;\r\n      }\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of 'user permissions'.\r\n */\r\ncontract Ownable\r\n{\r\n  address public owner;\r\n  address internal auxOwner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public\r\n  {\r\n      \r\n        address newOwner = msg.sender;\r\n        owner = 0;\r\n        owner = newOwner;\r\n    \r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() \r\n  {\r\n    require(msg.sender == owner || msg.sender==auxOwner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public \r\n  {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable\r\n{\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n  uint256 internal mCanPurchase = 1;\r\n  uint256 internal mSetupReserve = 0;\r\n  uint256 internal mSetupCrowd = 0;\r\n  \r\n  //test\r\n  uint256 public constant MINIMUM_ETHER_SPEND = (250 * 10**(decimals-3));\r\n  uint256 public constant MAXIMUM_ETHER_SPEND = 300 * 10**decimals;\r\n\r\n  //real\r\n  //uint256 public constant MINIMUM_ETHER_SPEND = (250 * 10**(decimals-3));\r\n  //uint256 public constant MAXIMUM_ETHER_SPEND = 300 * 10**decimals;\r\n\r\n\r\n  modifier canMint() \r\n  {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n  \r\n  function allocateVestable(address target, uint256 amount, uint256 vestdays, uint256 vestingdate) public onlyOwner\r\n  {\r\n      //require(msg.sender==CONTRACT_CREATOR, \"You are not authorised to create vestable token users\");\r\n      // check if we have permission to get in here\r\n      //checksigning();\r\n      \r\n      // prevent anyone except contract signatories from creating their own vestable\r\n      \r\n      // essentially set up a final vesting date\r\n      uint256 vestingAmount = amount * 10**decimals;\r\n    \r\n      // set up the vesting params\r\n      mCanSpend[target]=2;\r\n      mVestingBalance[target] = vestingAmount;\r\n      mVestingDays[target] = vestdays;\r\n      mVestingBegins[target] = vestingdate;\r\n      mVestingSpent[target] = 0;\r\n      \r\n      // load the balance of the actual token fund\r\n      balances[target] = vestingAmount;\r\n      \r\n      // if the tokensale is finalised then use the crowdsale fund which SHOULD be empty.\r\n      // this means we can create new vesting tokens if necessary but only if crowdsale fund has been preload with MEW using multisig wallet\r\n      if (mCanPurchase==0)\r\n      {\r\n        require(vestingAmount <= balances[MEW_CROWDSALE_FUND]);//, \"Not enough MEW to allocate vesting post crowdsale\");\r\n        balances[MEW_CROWDSALE_FUND] = balances[MEW_CROWDSALE_FUND].sub(vestingAmount); \r\n        // log transfer\r\n        emit Transfer(MEW_CROWDSALE_FUND, target, vestingAmount);\r\n      }\r\n      else\r\n      {\r\n        // deduct tokens from reserve before crowdsale\r\n        require(vestingAmount <= balances[MEW_RESERVE_FUND]);//, \"Not enough MEW to allocate vesting during setup\");\r\n        balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].sub(vestingAmount);\r\n        // log transfer\r\n        emit Transfer(MEW_RESERVE_FUND, target, vestingAmount);\r\n      }\r\n  }\r\n  \r\n  function SetAuxOwner(address aux) onlyOwner public\r\n  {\r\n      require(auxOwner == 0);//, \"Cannot replace aux owner once it has been set\");\r\n      // sets the auxilliary owner as the contract owns this address not the creator\r\n      auxOwner = aux;\r\n  }\r\n \r\n  function Purchase(address _to, uint256 _ether, uint256 _amount, uint256 exchange) onlyOwner public returns (bool) \r\n  {\r\n    require(mCanSpend[_to]==0); // cannot purchase to a validated or vesting wallet (probably works but more debug checks)\r\n    require(mSetupCrowd==1);//, \"Only purchase during crowdsale\");\r\n    require(mCanPurchase==1);//,\"Can only purchase during a sale\");\r\n      \r\n    require( _amount >= MINIMUM_ETHER_SPEND * exchange);//, \"Must spend at least minimum ether\");\r\n    require( (_amount+balances[_to]) <= MAXIMUM_ETHER_SPEND * exchange);//, \"Must not spend more than maximum ether\");\r\n   \r\n    // bail if we're out of tokens (will be amazing if this happens but hey!)\r\n    if (balances[MEW_CROWDSALE_FUND]<_amount)\r\n    {\r\n         return false;\r\n    }\r\n\r\n    // lock the tokens for AML - early to prevent transact hack\r\n    mCanSpend[_to] = 0;\r\n    \r\n    // add these ether to the invalid count unless checked\r\n    if (mCanSpend[_to]==0)\r\n    {\r\n        mEtherInvalid = mEtherInvalid + int256(_ether);\r\n    }\r\n    else\r\n    {\r\n        // valid AML checked ether\r\n        mEtherValid = mEtherValid + int256(_ether);\r\n    }\r\n    \r\n    // store how much ether was spent\r\n    mEtherSpent[_to] = _ether;\r\n      \r\n    // broken up to prevent recursive spend hacks (safemath probably does but just in case)\r\n    uint256 newBalance = balances[_to].add(_amount);\r\n    uint256 newCrowdBalance = balances[MEW_CROWDSALE_FUND].sub(_amount);\r\n    \r\n    balances[_to]=0;\r\n    balances[MEW_CROWDSALE_FUND] = 0;\r\n      \r\n    // add in to personal fund\r\n    balances[_to] = newBalance;\r\n    balances[MEW_CROWDSALE_FUND] = newCrowdBalance;\r\n   \r\n    emit Transfer(MEW_CROWDSALE_FUND, _to, _amount);\r\n    \r\n    return true;\r\n  }\r\n  \r\n  function Unlock_Tokens(address target) public onlyOwner\r\n  {\r\n      \r\n      require(mCanSpend[target]==0);//,\"Unlocking would fail\");\r\n      \r\n      // unlocks locked tokens - must be called on every token wallet after AML check\r\n      //unlocktokens(target);\r\n      \r\n      mCanSpend[target]=1;\r\n      \r\n      \r\n    // get how much ether this person spent on their tokens\r\n    uint256 etherToken = mEtherSpent[target];\r\n    \r\n    // if this is called the ether are now valid and can be spent\r\n    mEtherInvalid = mEtherInvalid - int256(etherToken);\r\n    mEtherValid = mEtherValid + int256(etherToken);\r\n    \r\n  }\r\n  \r\n  \r\n  function Revoke(address target) public onlyOwner\r\n  {\r\n      // revokes tokens and returns to the reserve\r\n      // designed to be used for refunds or to try to reverse theft via phishing etc\r\n      RevokeTokens(target);\r\n  }\r\n  \r\n  function BlockRefunded(address target) public onlyOwner\r\n  {\r\n      require(mCanSpend[target]!=8);\r\n      // clear the spent ether\r\n      //mEtherSpent[target]=0;\r\n      \r\n      // refund marker\r\n      mCanSpend[target]=8;\r\n      \r\n      // does not refund just blocks account from being used for tokens ever again\r\n      mEtherInvalid = mEtherInvalid-int256(mEtherSpent[target]);\r\n  }\r\n  \r\n  function SetupReserve(address multiSig) public onlyOwner\r\n  {\r\n      require(mSetupReserve==0);//, \"Reserve has already been initialised\");\r\n      require(multiSig>0);//, \"Wallet is not valid\");\r\n      \r\n      // address the mew reserve fund as the multisig wallet\r\n      //MEW_RESERVE_FUND = multiSig;\r\n      \r\n      // create the reserve\r\n      mint(MEW_RESERVE_FUND, TOTAL_RESERVE_FUND);\r\n     \r\n       // vesting allocates from the reserve fund\r\n      allocateVestable(FOUNDER_ADDRESS1, 9000000000, 365, PRIME_VESTING_DATE);\r\n      allocateVestable(FOUNDER_ADDRESS2, 9000000000, 365, PRIME_VESTING_DATE);\r\n      allocateVestable(FOUNDER_ADDRESS3, 7000000000, 365, PRIME_VESTING_DATE);\r\n  }\r\n  \r\n  function SetupCrowdSale() public onlyOwner\r\n  {\r\n      require(mSetupCrowd==0);//, \"Crowdsale has already been initalised\");\r\n      // create the reserve\r\n      mint(MEW_CROWDSALE_FUND, TOTAL_CROWDSALE_FUND);\r\n      \r\n      // crowd initialised\r\n      mSetupCrowd=1;\r\n  }\r\n  \r\n  function CloseSaleFund() public onlyOwner\r\n  {\r\n      uint256 remainingFund;\r\n      \r\n      remainingFund = balances[MEW_CROWDSALE_FUND];\r\n      \r\n      balances[MEW_CROWDSALE_FUND] = 0;\r\n      \r\n      balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(remainingFund);\r\n      \r\n      // notify the network\r\n      emit Transfer(MEW_CROWDSALE_FUND, MEW_RESERVE_FUND, remainingFund);\r\n      \r\n      // set up the prime vesting date - ie immediate\r\n      // set up the aml date\r\n      PRIME_VESTING_DATE = block.timestamp;\r\n      FINAL_AML_DATE = PRIME_VESTING_DATE + FINAL_AML_DAYS*DAYSECONDS;\r\n      \r\n      // update vesting date (sale end)\r\n      mVestingBegins[FOUNDER_ADDRESS1]=PRIME_VESTING_DATE;\r\n      mVestingBegins[FOUNDER_ADDRESS2]=PRIME_VESTING_DATE;\r\n      mVestingBegins[FOUNDER_ADDRESS3]=PRIME_VESTING_DATE;\r\n      \r\n      // block further token purchasing (forever)\r\n      mCanPurchase = 0;\r\n  }\r\n  \r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) \r\n  {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    \r\n    // allow this minted money to be spent immediately\r\n    mCanSpend[_to] = 1;\r\n    \r\n    emit Mint(_to, _amount);\r\n    emit Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner public returns (bool) \r\n  {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\ncontract MEWcoin is MintableToken \r\n{\r\n    string public constant name = \"MEWcoin (Official vFloorplan Ltd 30/07/18)\";\r\n    string public constant symbol = \"MEW\";\r\n    string public version = \"1.0\";\r\n}\r\n\r\n\r\ncontract Crowdsale \r\n{\r\n    function buyTokens(address _recipient) public payable;\r\n}\r\n\r\ncontract MultiSig\r\n{\r\n    function () public payable \r\n    {\r\n       \r\n    }\r\n}\r\n\r\n// i get the abstraction of crowdsale vs token but tbh I'd rather have most of this rolled up in a single contract\r\n// kind of makes sense that one function of a token is a crowdsale too but hey\r\n// - guess it could make the transactions lighter but then so does inheritance in the token... \r\n// tbd whether to do it or not.\r\ncontract MEWCrowdsale is Crowdsale \r\n{\r\n    using SafeMath for uint256;\r\n\r\n    // metadata\r\n    uint256 public constant decimals = 18;\r\n    uint256 public constant tenthousandths = 14;\r\n    \r\n    // crowdsale parameters\r\n    //bool public isFinalized;  // switched to true in operational state\r\n    \r\n    // stages of the sale - will not go backwards\r\n    uint8 internal constant STATE_UNINITIALISED       = 0xff;\r\n    uint8 internal constant STATE_FUND_INITIALISED    = 0;\r\n    uint8 internal constant STATE_PRESALE             = 1;\r\n    uint8 internal constant STATE_PHASEFIRST          = 2;\r\n    uint8 internal constant STATE_PHASESECOND         = 3;\r\n    uint8 internal constant STATE_PHASEFINAL          = 4;\r\n    uint8 internal constant STATE_EXTENSION           = 5;\r\n    uint8 internal constant STATE_SALE_PAUSE          = 99;\r\n    uint8 internal constant STATE_FINISHED            = 10;\r\n    \r\n    // initial state of state machine*/\r\n    uint8 public mCURRENT_STATE = STATE_UNINITIALISED;\r\n    \r\n    uint256 public mFUNDING_SALE_TIMESTAMP = 0;                                          // initialised to zero\r\n    uint256 public mFUNDING_CURRENT_DURATION = 0;                                        // used to change sale type\r\n    uint256 public mFUNDING_BONUS = 0;\r\n    \r\n    uint256 private constant CONST_DAY_SECONDS=60*60*24;\r\n    \r\n    uint256[6] public FUNDING_SALE_DURATION = [0,42,14,14,28,7];  // length of time of each stage in days\r\n    uint256[6] public FUNDING_SALE_BONUS = [0,150,125,110,100,100]; // in percent - exchange rate is divided by 100 to cancel it out\r\n    \r\n    uint256 private mTOKEN_EXCHANGE_RATE = 0;                                    // 0 before sale, after start we expect 500,000 MEW tokens per 1 ETH \r\n    uint256 public constant TOTAL_RESERVE_FUND = 40 * 1000000000 * 10**decimals; // 40B total in reserve/founder\r\n    uint256 public constant TOTAL_TOKEN_SUPPLY = 100 * (10**9) * 10**decimals;   // 100B total in the crowdsale\r\n    uint256 public constant GAS_PRICE_LIMIT = 200 * 10**9;                       // Gas limit 200 gwei\r\n    \r\n    // paused state\r\n    uint256 public mPausedTime = 0;\r\n    \r\n    address internal mOwner = 0;\r\n    \r\n    // wallet deposits and changing/signing code\r\n    uint256 internal constant SIGNING_TIME=900;\r\n    uint256[2] internal signatures;\r\n    address internal newAddress;\r\n    address public mDepositWallet;\r\n\r\n    // events\r\n    event CreateMEW(address indexed _to, uint256 _value);\r\n\r\n    MEWcoin public mToken; // expose the public ERC20 contract address\r\n    MultiSig public mMultiSigWallet; // expose the public multisig wallet address\r\n\r\n    // constructor\r\n    constructor() public \r\n    {\r\n        require(mCURRENT_STATE == STATE_UNINITIALISED);//, \"State machine is not in uninitialised state\");\r\n        // check we're the owner when calling the crowdsale (wouldn't really matter as eth goes in to our fund but would look weird having multiple crowdsales!)\r\n        if (mOwner!=0)\r\n        {\r\n            require (msg.sender == mOwner);//, \"Cannot create a crowdsale unless you own the contract\");\r\n        }\r\n        \r\n      // create the token\r\n      mToken = new MEWcoin();\r\n      mMultiSigWallet = MultiSig(mToken.MEW_RESERVE_FUND());\r\n      mDepositWallet = address(mMultiSigWallet);\r\n\r\n      // sanity checks\r\n      require(mOwner == 0);//, \"Already seems to be an owner\");\r\n      require(address(mToken.MEW_RESERVE_FUND) != 0x0);//, \"Invalid address for mew deposit\");\r\n      require(uint256(mToken.decimals()) == decimals);//, \"Mismatch between token and mew contract decimals\");\r\n      \r\n      // set up the sender as the owner\r\n      mOwner = msg.sender;\r\n      \r\n      // set the aux owner of the token - otherwise the contract owns it and we can't access owner functions\r\n      mToken.SetAuxOwner(mOwner);\r\n      \r\n      // create the reserve and allocate found tokens\r\n      mToken.SetupReserve(mMultiSigWallet);\r\n      mToken.SetupCrowdSale();\r\n      emit CreateMEW(address(mToken.MEW_RESERVE_FUND), mToken.TOTAL_RESERVE_FUND());\r\n      emit CreateMEW(address(mToken.MEW_CROWDSALE_FUND), mToken.TOTAL_CROWDSALE_FUND());\r\n      \r\n      // state machine has been initialised\r\n      mCURRENT_STATE = STATE_FUND_INITIALISED;\r\n      \r\n      // no more tokens\r\n      mToken.finishMinting();\r\n      \r\n    }\r\n\r\n    // utility\r\n    function startPRESALE() public \r\n    {\r\n        require (msg.sender == mOwner);//, \"Cannot call startPRESALE unless you own the contract\");\r\n        require (mCURRENT_STATE == STATE_FUND_INITIALISED); // can only be called initially\r\n        incSALESTATE();\r\n        \r\n        // deprecated\r\n        //require (mCURRENT_STATE==STATE_FUND_INITIALISED, \"Incorrect state to begin presale\");\r\n        \r\n        // set the sale params\r\n        //mCURRENT_STATE=STATE_PRESALE;\r\n        //mFUNDING_SALE_TIMESTAMP = block.timestamp;\r\n        //mFUNDING_CURRENT_DURATION = block.timestamp + FUNDING_SALE_DURATION[mCURRENT_STATE]*CONST_DAY_SECONDS;\r\n        \r\n        //mFUNDING_BONUS = FUNDING_SALE_BONUS[STATE_PRESALE];\r\n        //mTOKEN_EXCHANGE_RATE = 5000*mFUNDING_BONUS;                                          // set the rate as the sale begins - this will be multiplied up by bonus\r\n    }\r\n    \r\n    function incSALESTATE() public\r\n    {\r\n        require (msg.sender == mOwner);//, \"Cannot call incSALESTATE unless you own the contract\");\r\n        require (mCURRENT_STATE!=STATE_FINISHED);//, \"Cannot call on finalised sale\"); \r\n        require (mCURRENT_STATE!=STATE_EXTENSION);//, \"Cannot call on finalised sale\");  // emergency sale extention if required\r\n        \r\n        // increment state \r\n        if (mCURRENT_STATE >= STATE_FUND_INITIALISED)\r\n        {\r\n            // move to next sale state\r\n            mCURRENT_STATE++;\r\n            // set up the bonus\r\n            mFUNDING_BONUS = FUNDING_SALE_BONUS[mCURRENT_STATE];\r\n            \r\n            // set the start and end of sale (timestamp + duration)\r\n            mFUNDING_SALE_TIMESTAMP = block.timestamp;\r\n            mFUNDING_CURRENT_DURATION = block.timestamp + FUNDING_SALE_DURATION[mCURRENT_STATE]*CONST_DAY_SECONDS;\r\n            \r\n            // add the token <> eth exchange rate\r\n            mTOKEN_EXCHANGE_RATE = 5000*mFUNDING_BONUS;\r\n        }\r\n    }\r\n    \r\n    // utility\r\n    function pauseSALE() public \r\n    {\r\n        require (msg.sender == mOwner);//, \"Cannot call pauseSALE unless you own the contract\");\r\n        require (mPausedTime == 0);//, \"Cannot pause a paused sale\");\r\n        mPausedTime = mFUNDING_CURRENT_DURATION.sub(block.timestamp);\r\n        mFUNDING_CURRENT_DURATION = 0;\r\n    }\r\n    \r\n    function unpauseSALE() public\r\n    {\r\n        require (mPausedTime !=0);//, \"Cannot unpause a sale which isn't paused\");\r\n        require (msg.sender == mOwner);//, \"Cannot call unpauseSALE unless you own the contract\");\r\n        mFUNDING_CURRENT_DURATION = block.timestamp.add(mPausedTime);\r\n        mPausedTime=0;\r\n    }\r\n    \r\n    function () public payable \r\n    {\r\n      require( mCURRENT_STATE>=STATE_PRESALE);//, \"Trying to buy tokens but sale has not yet started\");\r\n      buyTokens(msg.sender);\r\n     \r\n    }\r\n\r\n    // low level token purchase function\r\n    function buyTokens(address beneficiary) public payable\r\n    {\r\n        // a lot of stuff wouldn't work without optimisation on - out of gas - someone fix remix please   \r\n          require (mCURRENT_STATE>=STATE_PRESALE);//, \"STATE: Sale has not been started\");\r\n          //require (mCURRENT_STATE!=STATE_SALE_PAUSE, \"STATE: Sale is paused\");\r\n          require (block.timestamp >= mFUNDING_SALE_TIMESTAMP);//, \"STATE: Timestamp has not been initialised, did you start the sale?\");\r\n          require (block.timestamp <= mFUNDING_CURRENT_DURATION);\r\n          \r\n          require (beneficiary != 0x0);// \"No beneficiary address given with message\"\r\n          require (tx.gasprice <= GAS_PRICE_LIMIT);// \"tx.gas price exceeds limit\"\r\n    \r\n          uint256 tokens = msg.value.mul(mTOKEN_EXCHANGE_RATE);\r\n          \r\n          // take the eth and hand back tokens\r\n          forwardFunds();\r\n          \r\n          // assign the tokens from the crowdsale fund\r\n          require(mToken.Purchase(beneficiary, msg.value, tokens, mTOKEN_EXCHANGE_RATE) == true);//, \"Token purchase failed - is the crowdsale fund empty?!?\");\r\n    }\r\n\r\n    function finalize() public \r\n    {\r\n      require (msg.sender == mOwner);//, \"Calling finalize but not the owner\");\r\n      require (mCURRENT_STATE!=STATE_FINISHED);\r\n      \r\n      // force finalise\r\n      mCURRENT_STATE = STATE_FINISHED;\r\n      \r\n      mToken.CloseSaleFund();\r\n    }\r\n    \r\n    function changeWallet(address newWallet) public\r\n    {\r\n        address SIGN_ADDRESS1 = address(0xa5a5f62BfA22b1E42A98Ce00131eA658D5E29B37);\r\n        address SIGN_ADDRESS2 = address(0x9115a6162D6bC3663dC7f4Ea46ad87db6B9CB926);\r\n        \r\n        require (msg.sender == SIGN_ADDRESS1 || msg.sender == SIGN_ADDRESS2);//, \"Must be founders signing this - can't sign anyway but this will bomb\");\r\n        \r\n        // store the current block time\r\n        uint256 blocktime = block.timestamp;\r\n        \r\n        // sign with the current founder signature\r\n        if (msg.sender == SIGN_ADDRESS1)\r\n        {\r\n            signatures[0] = blocktime;\r\n        }\r\n        \r\n        if (msg.sender == SIGN_ADDRESS2)\r\n        {\r\n            signatures[1] = blocktime;\r\n            \r\n        }\r\n        \r\n        // if we're the first person with the address then set it and bail\r\n        if (newAddress==0)\r\n        {\r\n            newAddress = newWallet;\r\n            return;\r\n        }\r\n        \r\n        uint256 time1=blocktime - signatures[0];\r\n        uint256 time2=blocktime - signatures[1];\r\n        \r\n        // check both times are within signing time\r\n        if ((time1<SIGNING_TIME) && (time2<SIGNING_TIME))\r\n        {\r\n            require(newAddress==newWallet);//,\"Addresses do no match\");\r\n            {\r\n                // set new wallet and clear signatures\r\n                mDepositWallet = newWallet;\r\n                signatures[0]=0;\r\n                signatures[1]=0;\r\n                newAddress=0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // send ether to the fund collection wallet\r\n    function forwardFunds() internal\r\n    {\r\n        require(mDepositWallet!=0);//,\"Wallet is unset\");\r\n        \r\n        mDepositWallet.transfer(msg.value);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"pauseSALE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mCURRENT_STATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"incSALESTATE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startPRESALE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FUNDING_SALE_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"FUNDING_SALE_BONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mFUNDING_BONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mFUNDING_SALE_TIMESTAMP\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mPausedTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newWallet\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mDepositWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseSALE\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mFUNDING_CURRENT_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_RESERVE_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_TOKEN_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tenthousandths\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GAS_PRICE_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mMultiSigWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"CreateMEW\",\"type\":\"event\"}]","ContractName":"MEWCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://efceca4f2b8923d44e71c144e2217d981dd24f96851a87700bf5b07f98fb990c"}]}