{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n// File: contracts/ERC20Token.sol\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure  returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address newOwner;\r\n\r\n    modifier only(address _allowed) {\r\n        require(msg.sender == _allowed);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) only(owner) public {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() only(newOwner) public {\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n}\r\n\r\ncontract ERC20 is Owned {\r\n    using SafeMath for uint;\r\n\r\n    uint public totalSupply;\r\n    bool public isStarted = false;\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    modifier isStartedOnly() {\r\n        require(isStarted);\r\n        _;\r\n    }\r\n\r\n    modifier isNotStartedOnly() {\r\n        require(!isStarted);\r\n        _;\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function transfer(address _to, uint _value) isStartedOnly public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) isStartedOnly public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve_fixed(address _spender, uint _currentValue, uint _value) isStartedOnly public returns (bool success) {\r\n        if(allowed[msg.sender][_spender] == _currentValue){\r\n            allowed[msg.sender][_spender] = _value;\r\n            emit Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint _value) isStartedOnly public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract Token is ERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    constructor(string _name, string _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function start() public only(owner) isNotStartedOnly {\r\n        isStarted = true;\r\n    }\r\n\r\n    //================= Crowdsale Only =================\r\n    function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function multimint(address[] dests, uint[] values) public only(owner) isNotStartedOnly returns (uint) {\r\n        uint i = 0;\r\n        while (i < dests.length) {\r\n           mint(dests[i], values[i]);\r\n           i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n}\r\n\r\ncontract TokenWithoutStart is Owned {\r\n    using SafeMath for uint;\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint public totalSupply;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    constructor(string _name, string _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve_fixed(address _spender, uint _currentValue, uint _value) public returns (bool success) {\r\n        if(allowed[msg.sender][_spender] == _currentValue){\r\n            allowed[msg.sender][_spender] = _value;\r\n            emit Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function mint(address _to, uint _amount) public only(owner) returns(bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function multimint(address[] dests, uint[] values) public only(owner) returns (uint) {\r\n        uint i = 0;\r\n        while (i < dests.length) {\r\n           mint(dests[i], values[i]);\r\n           i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/AgileSet.sol\r\n\r\n// REMEMER TO UNCOMMENT TIME CHECKS!!!!!\r\ncontract AgileICO {\r\n\r\n    using SafeMath for uint;\r\n\r\n    address public operator; // ICO operator\r\n    address public juryOperator; // Jury.Online operator\r\n    address public projectWallet; // Wallet where project funds are sent\r\n    address public arbitrationAddress; // address of contract that handles arbitration\r\n    address public juryOnlineWallet; // Wallet for Jury.Online commission\r\n\r\n    bool public requireTokens; // if true, token balance needed before accept offer\r\n\r\n    uint public promisedTokens;\r\n    uint public etherAllowance;\r\n    uint public jotAllowance;\r\n    uint public commissionOnInvestmentJot; // commission paid in ETH when operator accepts offer\r\n    uint public commissionOnInvestmentEth; // commission paid in JOT when operator accepts offer\r\n    uint public percentForFuture; // percent of investment offer that is not sent to Cycle and kept for future\r\n    uint public rate = 1; // amount of token for each wei in investment offer\r\n    address public currentCycleAddress; // address of current AgileCycle contract\r\n    uint public currentCycleNumber; // indicates current cycle\r\n\r\n    uint public currentFundingRound; // indicates current funding round (should be removed)\r\n    uint public minimumInvestment;\r\n\r\n    uint public lastRateChange; // used to prevent changing rates more than once a day\r\n\r\n    Token public token; // proxy or real token\r\n    // Offer struct stores information about all offers and deals\r\n    // a deal is an accepted offer\r\n    struct Offer {\r\n        uint etherAmount; // etherAmount of investment offer\r\n        uint tokenAmount; // tokenAmount of investment offer\r\n        bool accepted; // true if offer has been accepted\r\n        uint numberOfDeals; // indicates number of deals an investor has\r\n    }\r\n    // below mapping maps an investor address to a deal number to the details\r\n    // of that deal (etherAmount, tokenAmount, accepted, numberOfDeals)\r\n    mapping(address => mapping(uint => Offer)) public offers;\r\n\r\n    address[] public cycles; // stores the addresses of cycles\r\n\r\n    // Stores the amount stored for future cycles\r\n    struct FutureDeal {\r\n        uint etherAmount; // etherAmount for future\r\n        uint tokenAmount; // tokenAmount for future\r\n    }\r\n    // below mapping maps investor address to a futureDeal, that is, an amount\r\n    // which will be used in future cycles.\r\n    mapping(address => FutureDeal) public futureDeals;\r\n\r\n    address[] public investorList; // list of investor\r\n\r\n    // FundingRound struct stores information about each FundingRound\r\n    struct FundingRound {\r\n        uint startTime;\r\n        uint endTime;\r\n        uint rate;\r\n        bool hasWhitelist;\r\n    }\r\n    FundingRound[] public roundPrices;  // stores list of funding rounds\r\n    mapping(uint => mapping(address => bool)) public whitelist; // stores whitelists (if any) for funding round\r\n\r\n    bool public saveMe;\r\n\r\n    modifier only(address _sender) {\r\n        require(msg.sender == _sender);\r\n        _;\r\n    }\r\n\r\n    constructor(\r\n            address _operator,\r\n            uint _commissionOnInvestmentJot,\r\n            uint _commissionOnInvestmentEth,\r\n            uint _percentForFuture,\r\n            address _projectWallet,\r\n            address _arbitrationAddress,\r\n\t    address _tokenAddress,\r\n            address _juryOperator,\r\n            address _juryOnlineWallet,\r\n\t    uint _minimumInvestment\r\n        ) public {\r\n        percentForFuture = _percentForFuture;\r\n        operator = _operator;\r\n        commissionOnInvestmentJot = _commissionOnInvestmentJot;\r\n        commissionOnInvestmentEth = _commissionOnInvestmentEth;\r\n        percentForFuture = _percentForFuture;\r\n        projectWallet = _projectWallet;\r\n        arbitrationAddress = _arbitrationAddress;\r\n\ttoken = Token(_tokenAddress);\r\n        juryOperator = _juryOperator;\r\n        juryOnlineWallet = _juryOnlineWallet;\r\n\tminimumInvestment = _minimumInvestment;\r\n    }\r\n\r\n    // PUBLIC ------------------------------------------------------------------\r\n    // payable function recieves ETH and creates an 'offer'\r\n    // wont succeed with 2300 stipend for send, must add more gas\r\n    function () public payable {\r\n        // INVESTOR SENDS OFFER BY SENDING ETH TO CONTRACT\r\n        require(msg.value > minimumInvestment);\r\n    \tfor (uint i = 0; i < roundPrices.length; i++ ) {\r\n\t\tif (now > roundPrices[i].startTime && now < roundPrices[i].endTime) {\r\n\t\t\trate = roundPrices[i].rate;\r\n\t\t\tif (roundPrices[i].hasWhitelist == true) {\r\n\t\t\t\trequire(whitelist[i][msg.sender] == true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/*\r\n\tif (roundPrices.length > 0) {\r\n                if (roundPrices[currentFundingRound].hasWhitelist == true) {\r\n                    require(whitelist[currentFundingRound][msg.sender] == true);\r\n                }\r\n    \t}\r\n        */\r\n        uint dealNumber = offers[msg.sender][0].numberOfDeals;\r\n        // uint dealNumber = 0;\r\n\toffers[msg.sender][dealNumber].etherAmount = msg.value;\r\n        offers[msg.sender][dealNumber].tokenAmount = msg.value*rate;\r\n        offers[msg.sender][0].numberOfDeals += 1;\r\n    }\r\n    // Investor can withdraw offer if it has not been accepted\r\n    function withdrawOffer(uint _offerNumber) public {\r\n        // INVESTOR CAN WITHDRAW OFFER\r\n        require(offers[msg.sender][_offerNumber].accepted == false);\r\n        require(msg.sender.send(offers[msg.sender][_offerNumber].etherAmount));\r\n        offers[msg.sender][_offerNumber].etherAmount = 0;\r\n    }\r\n    // Calles by Jury.Online to retrieve commission\r\n    function withdrawEther() public {\r\n        if (msg.sender == juryOperator) {\r\n            require(juryOnlineWallet.send(etherAllowance));\r\n            //require(jotter.call.value(jotAllowance)(abi.encodeWithSignature(\"swapMe()\")));\r\n            etherAllowance = 0;\r\n            jotAllowance = 0;\r\n        }\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // ICO OPERATOR ------------------------------------------------------------\r\n    // operator can acept offer, it keeps certain amount in futureDeals, and sends\r\n    // rest to Cycle contract by calling offerAccepted() in Cycle\r\n    function setToken(address _tokenAddress) public only(operator) {\r\n    \trequire(token == 0x0000000000000000000000000000000000000000);\r\n\t    token = Token(_tokenAddress);\r\n    }\r\n    function acceptOffer(address _investor, uint _offerNumber) public only(operator) {\r\n        require(offers[_investor][_offerNumber].etherAmount > 0);\r\n        require(offers[_investor][_offerNumber].accepted != true);\r\n\r\n        AgileCycle cycle = AgileCycle(currentCycleAddress);\r\n\r\n\t    require(cycle.sealTimestamp() > 0);\r\n\r\n        offers[_investor][_offerNumber].accepted = true;\r\n        uint _etherAmount = offers[_investor][_offerNumber].etherAmount;\r\n        uint _tokenAmount = offers[_investor][_offerNumber].tokenAmount;\r\n\r\n        require(token.balanceOf(currentCycleAddress) >= promisedTokens + _tokenAmount);\r\n        uint _etherForFuture = _etherAmount.mul(percentForFuture).div(100);\r\n        uint _tokenForFuture =  _tokenAmount.mul(percentForFuture).div(100);\r\n\r\n        if (_offerNumber == 0) {\r\n            futureDeals[_investor].etherAmount += _etherForFuture;\r\n            futureDeals[_investor].tokenAmount += _tokenForFuture;\r\n        } else {\r\n            futureDeals[_investor] = FutureDeal(_etherForFuture,_tokenForFuture);\r\n        }\r\n\r\n        _etherAmount = _etherAmount.sub(_etherForFuture);\r\n        _tokenAmount = _tokenAmount.sub(_tokenForFuture);\r\n\r\n        if (commissionOnInvestmentEth > 0 || commissionOnInvestmentJot > 0) {\r\n            uint etherCommission = _etherAmount.mul(commissionOnInvestmentEth).div(100);\r\n            uint jotCommission = _etherAmount.mul(commissionOnInvestmentJot).div(100);\r\n\t        _etherAmount = _etherAmount.sub(etherCommission).sub(jotCommission);\r\n            offers[_investor][_offerNumber].etherAmount = _etherAmount;\r\n            etherAllowance += etherCommission;\r\n            jotAllowance += jotCommission;\r\n        }\r\n        investorList.push(_investor);\r\n        cycle.offerAccepted.value(_etherAmount)(_investor, _tokenAmount);\r\n    }\r\n    // after deploying Cycle, operator adds cycle address\r\n    function addCycleAddress(address _cycleAddress) public only(operator) {\r\n        cycles.push(_cycleAddress);\r\n    }\r\n    // Sets the active cycle. If not first one, previous one has to be finished.\r\n    function setNextCycle() public only(operator) {\r\n        require(cycles.length > 0);\r\n        if (currentCycleNumber > 0) {\r\n            AgileCycle cycle = AgileCycle(currentCycleAddress);\r\n            uint finishedTimeStamp = cycle.finishedTimeStamp();\r\n            require(now > finishedTimeStamp);\r\n            uint interval = now - finishedTimeStamp;\r\n            //require(interval > 3 days);\r\n        }\r\n        currentCycleAddress = cycles[currentCycleNumber];\r\n        currentCycleNumber += 1;\r\n    }\r\n    // to add FundingRounds\r\n    function addFundingRound(uint _startTime,uint _endTime, uint _rate, address[] _whitelist) public only(operator) {\r\n        if (_whitelist.length == 0) {\r\n            roundPrices.push(FundingRound(_startTime, _endTime,_rate,false));\r\n        } else {\r\n            for (uint i=0 ; i < _whitelist.length ; i++ ) {\r\n                whitelist[roundPrices.length][_whitelist[i]] = true;\r\n            }\r\n            roundPrices.push(FundingRound(_startTime, _endTime,_rate,true));\r\n        }\r\n    }\r\n    // to set rate directly\r\n    function setRate(uint _rate) only(operator) public {\r\n        uint interval = now - lastRateChange;\r\n        //require(interval < 1 days);\r\n        rate = _rate;\r\n    }\r\n    // to activate a fundingRound\r\n    function setCurrentFundingRound(uint _fundingRound) public only(operator) {\r\n        require(roundPrices.length > _fundingRound);\r\n        currentFundingRound = _fundingRound;\r\n        rate = roundPrices[_fundingRound].rate;\r\n    }\r\n    // sends futureDeal funds to next cycle\r\n    // it has loop control in case of lack of gas\r\n    function sendFundsToNextCycle(uint _startLoop, uint _endLoop) public only(operator) {\r\n        AgileCycle cycle = AgileCycle(currentCycleAddress);\r\n        require(cycle.sealTimestamp() > 0);\r\n\r\n        uint _promisedTokens = cycle.promisedTokens();\r\n        uint _balanceTokens = token.balanceOf(currentCycleAddress);\r\n\r\n        if (_endLoop == 0) _endLoop = investorList.length;\r\n        require(_endLoop <= investorList.length);\r\n\r\n        require(token.balanceOf(currentCycleAddress) >= promisedTokens + _tokenAmount);\r\n\r\n        for ( uint i=_startLoop; i < _endLoop; i++ ) {\r\n    \t    address _investor = investorList[i];\r\n    \t    uint _etherAmount = futureDeals[_investor].etherAmount;\r\n    \t    uint _tokenAmount = futureDeals[_investor].tokenAmount;\r\n            _promisedTokens += _tokenAmount;\r\n            if (requireTokens) require(_balanceTokens >= _promisedTokens);\r\n    \t    cycle.offerAccepted.value(_etherAmount)(_investor, _tokenAmount);\r\n    \t    futureDeals[_investor].etherAmount = 0;\r\n    \t    futureDeals[_investor].tokenAmount = 0;\r\n    \t    //futureDeals[_investor].sent = true;\r\n        }\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // HELPERS -----------------------------------------------------------------\r\n    function failSafe() public {\r\n        if (msg.sender == operator) {\r\n            saveMe = true;\r\n        }\r\n        if (msg.sender == juryOperator) {\r\n            require(saveMe == true);\r\n            require(juryOperator.send(address(this).balance));\r\n            uint allTheLockedTokens = token.balanceOf(this);\r\n            require(token.transfer(juryOperator,allTheLockedTokens));\r\n        }\r\n    }\r\n\r\n}\r\n\r\ncontract AgileCycle {\r\n    using SafeMath for uint;\r\n    //VARIABLES\r\n    address public operator; // should be same as ICO (no check for this yet)\r\n    address public juryOperator; // for failsafe\r\n    uint public promisedTokens; // the number of tokens owed to investor by accepting offer\r\n    uint public raisedEther; // amount of ether raised by accepting offers\r\n\r\n    bool public tokenReleaseAtStart; // whether tokens released at start or by milestones\r\n\r\n    address public icoAddress; // ICO address\r\n    address public arbitrationAddress;\r\n\r\n    bool public roundFailedToStart;\r\n    address public projectWallet;\r\n    address public juryOnlineWallet;\r\n\r\n    struct Milestone {\r\n        uint etherAmount; //how many Ether is needed for this milestone\r\n        uint tokenAmount; //how many tokens releases this milestone\r\n        uint startTime; //real time when milestone has started, set upon start\r\n        uint finishTime; //real time when milestone has finished, set upon finish\r\n        uint duration; //assumed duration for milestone implementation, set upon milestone creation\r\n        string description;\r\n        string result;\r\n    }\r\n    Milestone[] public milestones; // list of milestones\r\n\r\n    uint[] public commissionEth; // each element corresponds to amount of commission paid in each milestone\r\n    uint[] public commissionJot; // same as above, but in JOT. Both amount stored in percentages\r\n    uint public currentMilestone; // stores index of current milestone\r\n    uint public etherAllowance; // amount allowed for Jury.Online in commission ETH\r\n    uint public jotAllowance; // amount allowed for Jury.Online in commission JOT\r\n    uint public ethForMilestone; // amomunt allowed for project to withdraw in milestone\r\n    Token public token; // Real or Proxy token\r\n    uint public totalToken; // sum of Tokens in all milestones\r\n    uint public totalEther; // sum of ETH in all milstones\r\n    uint public sealTimestamp; // timestamp when Cycle is sealed\r\n\r\n    mapping(address => uint[]) public etherPartition;\r\n    mapping(address => uint[]) public tokenPartition;\r\n\r\n    struct Deal {\r\n        uint etherAmount; // amount of ETH in deal\r\n        uint tokenAmount; // amount of Tokens in deal\r\n        bool disputing; // true if disputing, funds are frozen\r\n        uint tokenAllowance; // amount allowed for investor to withdraw\r\n        uint etherUsed; // ETH already used and not available for refund\r\n        bool verdictForProject; // verdict for project\r\n        bool verdictForInvestor; // verdict for investor\r\n    }\r\n    mapping(address => Deal) public deals; // mapping of investor to deal\r\n    address[] public dealsList; // list of addresses of investor deals, used for iteration in startMilestone()\r\n\r\n    uint public finishedTimeStamp; // when all milestones are finished. Checked by ICO.\r\n\r\n    uint public postDisputeEth; // for debugging\r\n    bool public saveMe; //for failsafe\r\n    bool public cycleApproved; // Jury must approve the start of an ICO\r\n\r\n    modifier only(address _allowed) {\r\n        require(msg.sender == _allowed);\r\n        _;\r\n    }\r\n    modifier sealed() {\r\n    \trequire(sealTimestamp > 0);\r\n    \t_;\r\n    }\r\n    modifier notSealed() {\r\n    \trequire(sealTimestamp == 0);\r\n    \t_;\r\n    }\r\n\r\n    constructor(\r\n            bool _tokenReleaseAtStart,\r\n            address _icoAddress,\r\n            uint[] _commissionEth,\r\n            uint[] _commissionJot,\r\n            address _operator,\r\n            address _juryOperator,\r\n            address _arbitrationAddress,\r\n            address _projectWallet,\r\n            address _juryOnlineWallet\r\n        ) public {\r\n            tokenReleaseAtStart = _tokenReleaseAtStart;\r\n            icoAddress = _icoAddress;\r\n            commissionEth = _commissionEth;\r\n            commissionJot = _commissionJot;\r\n            operator = _operator;\r\n            juryOperator = _juryOperator;\r\n            arbitrationAddress = _arbitrationAddress;\r\n            projectWallet = _projectWallet;\r\n            juryOnlineWallet = _juryOnlineWallet;\r\n    }\r\n\r\n    function setToken(address _tokenAddress) public only(operator) {\r\n    \trequire(token == 0x0000000000000000000000000000000000000000);\r\n\t    token = Token(_tokenAddress);\r\n    }\r\n    // CALLED BY JURY.ONLINE TO RETRIEVE COMMISSION\r\n    // CALLED BY ICO OPERATOR TO RETRIEVE FUNDS\r\n    // CALLED BY INVESTOR TO RETRIEVE FUNDS AFTER DISPUTE\r\n    function withdrawEther() public {\r\n        if (roundFailedToStart == true) {\r\n            require(msg.sender.send(deals[msg.sender].etherAmount));\r\n        }\r\n        if (msg.sender == operator) {\r\n            require(projectWallet.send(ethForMilestone+postDisputeEth));\r\n            ethForMilestone = 0;\r\n            postDisputeEth = 0;\r\n        }\r\n        if (msg.sender == juryOperator) {\r\n            require(juryOnlineWallet.send(etherAllowance));\r\n            //require(jotter.call.value(jotAllowance)(abi.encodeWithSignature(\"swapMe()\")));\r\n            etherAllowance = 0;\r\n            jotAllowance = 0;\r\n        }\r\n        if (deals[msg.sender].verdictForInvestor == true) {\r\n            require(msg.sender.send(deals[msg.sender].etherAmount - deals[msg.sender].etherUsed));\r\n        }\r\n    }\r\n    // CALLED BY INVESTOR TO RETRIEVE TOKENS\r\n    function withdrawToken() public {\r\n        require(token.transfer(msg.sender,deals[msg.sender].tokenAllowance));\r\n        deals[msg.sender].tokenAllowance = 0;\r\n    }\r\n\r\n\r\n    // OPERATOR ----------------------------------------------------------------\r\n    function addMilestonesAndSeal(uint[] _etherAmounts, uint[] _tokenAmounts, uint[] _startTimes, uint[] _durations) public notSealed only(operator) {\r\n    \trequire(_etherAmounts.length == _tokenAmounts.length);\r\n\trequire(_startTimes.length == _durations.length);\r\n\trequire(_durations.length == _etherAmounts.length);\r\n\tfor (uint i = 0; i < _etherAmounts.length; i++) {\r\n\t\ttotalEther = totalEther.add(_etherAmounts[i]);\r\n\t\ttotalToken = totalToken.add(_tokenAmounts[i]);\r\n\t\tmilestones.push(Milestone(_etherAmounts[i], _tokenAmounts[i], _startTimes[i],0,_durations[i],\"\",\"\"));\r\n\t}\r\n\tsealTimestamp = now;\r\n    }\r\n    function addMilestone(uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed only(operator) returns(uint) {\r\n        totalEther = totalEther.add(_etherAmount);\r\n        totalToken = totalToken.add(_tokenAmount);\r\n        return milestones.push(Milestone(_etherAmount, _tokenAmount, _startTime, 0, _duration, _description, \"\"));\r\n    }\r\n    function approveCycle(bool _approved) public {\r\n        require(cycleApproved != true && roundFailedToStart != true);\r\n        require(msg.sender == juryOperator);\r\n        if (_approved == true) {\r\n            cycleApproved = true;\r\n        } else {\r\n            roundFailedToStart = true;\r\n        }\r\n    }\r\n    function startMilestone() public sealed only(operator) {\r\n        require(cycleApproved);\r\n        // UNCOMMENT 2 LINES BELOW FOR PROJECT FAILS START IF totalEther < raisedEther\r\n        // if (currentMilestone == 0 && totalEther < raisedEther) { roundFailedToStart = true; }\r\n        // require(!roundFailedToStart);\r\n        if (currentMilestone != 0 ) {\r\n            require(milestones[currentMilestone-1].finishTime > 0);\r\n            uint interval = now - milestones[currentMilestone-1].finishTime;\r\n            require(interval > 3 days);\r\n        }\r\n        for (uint i=0; i < dealsList.length ; i++) {\r\n            address investor = dealsList[i];\r\n            if (deals[investor].disputing == false) {\r\n                if (deals[investor].verdictForInvestor != true) {\r\n                    ethForMilestone += etherPartition[investor][currentMilestone];\r\n                    deals[investor].etherUsed += etherPartition[investor][currentMilestone];\r\n                    if (tokenReleaseAtStart == false) {\r\n                        deals[investor].tokenAllowance += tokenPartition[investor][currentMilestone];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        milestones[currentMilestone].startTime = now;\r\n        currentMilestone +=1;\r\n        ethForMilestone = payCommission();\r\n    }\r\n    function finishMilestone(string _result) public only(operator) {\r\n        require(milestones[currentMilestone-1].finishTime == 0);\r\n        // UNCOMMENT LINES BELOW FOR PRODUCTION!!!!\r\n\t    uint interval = now - milestones[currentMilestone-1].startTime;\r\n        require(interval > 1 weeks);\r\n        milestones[currentMilestone-1].finishTime = now;\r\n        milestones[currentMilestone-1].result = _result;\r\n        if (currentMilestone == milestones.length) {\r\n            finishedTimeStamp = now;\r\n        }\r\n    }\r\n    function editMilestone(uint _id, uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed only(operator) {\r\n        assert(_id < milestones.length);\r\n        totalEther = (totalEther - milestones[_id].etherAmount).add(_etherAmount); //previous addition\r\n        totalToken = (totalToken - milestones[_id].tokenAmount).add(_tokenAmount);\r\n        milestones[_id].etherAmount = _etherAmount;\r\n        milestones[_id].tokenAmount = _tokenAmount;\r\n        milestones[_id].startTime = _startTime;\r\n        milestones[_id].duration = _duration;\r\n        milestones[_id].description = _description;\r\n    }\r\n\r\n    function seal() public notSealed only(operator) {\r\n        require(milestones.length > 0);\r\n        // Uncomment bottom line to require balance when sealing contract\r\n        // currently balance is required only when accepting offer\r\n        //require(token.balanceOf(address(this)) >= promisedTokens);\r\n        sealTimestamp = now;\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // ONLY(ICO) ---------------------------------------------------------------\r\n    // when operator accepts offer in ICO contract, it calls this function to add deal\r\n    function offerAccepted(address _investor, uint _tokenAmount) public payable only(icoAddress) {\r\n\t    require(sealTimestamp > 0);\r\n        uint _etherAmount = msg.value;\r\n        assignPartition(_investor, _etherAmount, _tokenAmount);\r\n        if (!(deals[_investor].etherAmount > 0)) dealsList.push(_investor);\r\n        if (tokenReleaseAtStart == true) {\r\n            deals[_investor].tokenAllowance = _tokenAmount;\r\n        }\r\n        deals[_investor].etherAmount += _etherAmount;\r\n        deals[_investor].tokenAmount += _tokenAmount;\r\n    \t// ADDS TO TOTALS\r\n    \tpromisedTokens += _tokenAmount;\r\n    \traisedEther += _etherAmount;\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // ONLY(ARBITRATION) -------------------------------------------------------\r\n    function disputeOpened(address _investor) public only(arbitrationAddress) {\r\n        deals[_investor].disputing = true;\r\n    }\r\n    function verdictExecuted(address _investor, bool _verdictForInvestor,uint _milestoneDispute) public only(arbitrationAddress) {\r\n        require(deals[_investor].disputing == true);\r\n        if (_verdictForInvestor) {\r\n            deals[_investor].verdictForInvestor = true;\r\n        } else {\r\n            deals[_investor].verdictForProject = true;\r\n            for (uint i = _milestoneDispute; i < currentMilestone; i++) {\r\n                postDisputeEth += etherPartition[_investor][i];\r\n                deals[_investor].etherUsed += etherPartition[_investor][i];\r\n            }\r\n        }\r\n        deals[_investor].disputing = false;\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // INTERNAL ----------------------------------------------------------------\r\n    function assignPartition(address _investor, uint _etherAmount, uint _tokenAmount) internal {\r\n        uint milestoneEtherAmount; //How much Ether does investor send for a milestone\r\n        uint milestoneTokenAmount; //How many Tokens does investor receive for a milestone\r\n        uint milestoneEtherTarget; //How much TOTAL Ether a milestone needs\r\n        uint milestoneTokenTarget; //How many TOTAL tokens a milestone releases\r\n        uint totalEtherInvestment;\r\n        uint totalTokenInvestment;\r\n        for(uint i=currentMilestone; i<milestones.length; i++) {\r\n            milestoneEtherTarget = milestones[i].etherAmount;\r\n            milestoneTokenTarget = milestones[i].tokenAmount;\r\n            milestoneEtherAmount = _etherAmount.mul(milestoneEtherTarget).div(totalEther);\r\n            milestoneTokenAmount = _tokenAmount.mul(milestoneTokenTarget).div(totalToken);\r\n            totalEtherInvestment = totalEtherInvestment.add(milestoneEtherAmount); //used to prevent rounding errors\r\n            totalTokenInvestment = totalTokenInvestment.add(milestoneTokenAmount); //used to prevent rounding errors\r\n            if (deals[_investor].etherAmount > 0) {\r\n                etherPartition[_investor][i] += milestoneEtherAmount;\r\n                tokenPartition[_investor][i] += milestoneTokenAmount;\r\n            } else {\r\n                etherPartition[_investor].push(milestoneEtherAmount);\r\n                tokenPartition[_investor].push(milestoneTokenAmount);\r\n            }\r\n\r\n        }\r\n        /* roundingErrors += _etherAmount - totalEtherInvestment; */\r\n        etherPartition[_investor][currentMilestone] += _etherAmount - totalEtherInvestment; //rounding error is added to the first milestone\r\n        tokenPartition[_investor][currentMilestone] += _tokenAmount - totalTokenInvestment; //rounding error is added to the first milestone\r\n    }\r\n    function payCommission() internal returns(uint) {\r\n        if (commissionEth.length >= currentMilestone) {\r\n            uint ethCommission = raisedEther.mul(commissionEth[currentMilestone-1]).div(100);\r\n            uint jotCommission = raisedEther.mul(commissionJot[currentMilestone-1]).div(100);\r\n            etherAllowance += ethCommission;\r\n            jotAllowance += jotCommission;\r\n            return ethForMilestone.sub(ethCommission).sub(jotCommission);\r\n        } else {\r\n            return ethForMilestone;\r\n        }\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // HELPERS -----------------------------------------------------------------\r\n    function milestonesLength() public view returns(uint) {\r\n        return milestones.length;\r\n    }\r\n    function investorExists(address _investor) public view returns(bool) {\r\n        if (deals[_investor].etherAmount > 0) return true;\r\n        else return false;\r\n    }\r\n    function failSafe() public {\r\n        if (msg.sender == operator) {\r\n            saveMe = true;\r\n        }\r\n        if (msg.sender == juryOperator) {\r\n            require(saveMe == true);\r\n            require(juryOperator.send(address(this).balance));\r\n            uint allTheLockedTokens = token.balanceOf(this);\r\n            require(token.transfer(juryOperator,allTheLockedTokens));\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract AgileArbitration is Owned {\r\n\r\n    address public operator;\r\n\r\n    uint public quorum = 3;\r\n\r\n    struct Dispute {\r\n        address icoRoundAddress;\r\n        address investorAddress;\r\n        bool pending;\r\n        uint timestamp;\r\n        uint milestone;\r\n        string reason;\r\n        uint votesForProject;\r\n        uint votesForInvestor;\r\n        // bool verdictForProject;\r\n        // bool verdictForInvestor;\r\n        mapping(address => bool) voters;\r\n    }\r\n    mapping(uint => Dispute) public disputes;\r\n\r\n    uint public disputeLength;\r\n\r\n    mapping(address => mapping(address => bool)) public arbiterPool;\r\n\r\n    modifier only(address _allowed) {\r\n        require(msg.sender == _allowed);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        operator = msg.sender;\r\n    }\r\n\r\n    // OPERATOR\r\n    function setArbiters(address _icoRoundAddress, address[] _arbiters) only(owner) public {\r\n        for (uint i = 0; i < _arbiters.length ; i++) {\r\n            arbiterPool[_icoRoundAddress][_arbiters[i]] = true;\r\n        }\r\n    }\r\n\r\n    // ARBITER\r\n    function vote(uint _disputeId, bool _voteForInvestor) public {\r\n        require(disputes[_disputeId].pending == true);\r\n        require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true);\r\n        require(disputes[_disputeId].voters[msg.sender] != true);\r\n        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }\r\n        else { disputes[_disputeId].votesForProject += 1; }\r\n        if (disputes[_disputeId].votesForInvestor == quorum) {\r\n            executeVerdict(_disputeId,true);\r\n        }\r\n        if (disputes[_disputeId].votesForProject == quorum) {\r\n            executeVerdict(_disputeId,false);\r\n        }\r\n        disputes[_disputeId].voters[msg.sender] == true;\r\n    }\r\n\r\n    // INVESTOR\r\n    function openDispute(address _icoRoundAddress, string _reason) public {\r\n        AgileCycle cycle = AgileCycle(_icoRoundAddress);\r\n        uint milestoneDispute = cycle.currentMilestone();\r\n        require(milestoneDispute > 0);\r\n        require(cycle.investorExists(msg.sender) == true);\r\n        disputes[disputeLength].milestone = milestoneDispute;\r\n\r\n        disputes[disputeLength].icoRoundAddress = _icoRoundAddress;\r\n        disputes[disputeLength].investorAddress = msg.sender;\r\n        disputes[disputeLength].timestamp = now;\r\n        disputes[disputeLength].reason = _reason;\r\n        disputes[disputeLength].pending = true;\r\n\r\n        cycle.disputeOpened(msg.sender);\r\n        disputeLength +=1;\r\n    }\r\n\r\n    // INTERNAL\r\n    function executeVerdict(uint _disputeId, bool _verdictForInvestor) internal {\r\n        disputes[_disputeId].pending = false;\r\n        uint milestoneDispute = disputes[_disputeId].milestone;\r\n        AgileCycle cycle = AgileCycle(disputes[_disputeId].icoRoundAddress);\r\n        cycle.verdictExecuted(disputes[_disputeId].investorAddress,_verdictForInvestor,milestoneDispute);\r\n        //counter +=1;\r\n    }\r\n\r\n    function isPending(uint _disputedId) public view returns(bool) {\r\n        return disputes[_disputedId].pending;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"startMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_result\",\"type\":\"string\"}],\"name\":\"finishMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReleaseAtStart\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"failSafe\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_verdictForInvestor\",\"type\":\"bool\"},{\"name\":\"_milestoneDispute\",\"type\":\"uint256\"}],\"name\":\"verdictExecuted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"etherPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherAmounts\",\"type\":\"uint256[]\"},{\"name\":\"_tokenAmounts\",\"type\":\"uint256[]\"},{\"name\":\"_startTimes\",\"type\":\"uint256[]\"},{\"name\":\"_durations\",\"type\":\"uint256[]\"}],\"name\":\"addMilestonesAndSeal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"deals\",\"outputs\":[{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"disputing\",\"type\":\"bool\"},{\"name\":\"tokenAllowance\",\"type\":\"uint256\"},{\"name\":\"etherUsed\",\"type\":\"uint256\"},{\"name\":\"verdictForProject\",\"type\":\"bool\"},{\"name\":\"verdictForInvestor\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"milestonesLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"seal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finishedTimeStamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sealTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"investorExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"promisedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commissionJot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"postDisputeEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"disputeOpened\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbitrationAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"dealsList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"addMilestone\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"juryOnlineWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cycleApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"offerAccepted\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"raisedEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jotAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenPartition\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethForMilestone\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEther\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentMilestone\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"approveCycle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundFailedToStart\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"juryOperator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_etherAmount\",\"type\":\"uint256\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_description\",\"type\":\"string\"}],\"name\":\"editMilestone\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"milestones\",\"outputs\":[{\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"finishTime\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"description\",\"type\":\"string\"},{\"name\":\"result\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saveMe\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"commissionEth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenReleaseAtStart\",\"type\":\"bool\"},{\"name\":\"_icoAddress\",\"type\":\"address\"},{\"name\":\"_commissionEth\",\"type\":\"uint256[]\"},{\"name\":\"_commissionJot\",\"type\":\"uint256[]\"},{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_juryOperator\",\"type\":\"address\"},{\"name\":\"_arbitrationAddress\",\"type\":\"address\"},{\"name\":\"_projectWallet\",\"type\":\"address\"},{\"name\":\"_juryOnlineWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"AgileCycle","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000000100000000000000000000000086861e04263af5e9ac29cf14eea64db6f98e321f000000000000000000000000000000000000000000000000000000000000012000000000000000000000000000000000000000000000000000000000000001600000000000000000000000006a5fee685bd0a74f64a922cc03987ec0bab91324000000000000000000000000ff26720636f2f1fd855bfedefbfbd6e175633d740000000000000000000000007f812651ec9a6edb53cbfa6b6709f1f61faae4000000000000000000000000003d60fb60c9649067161099219da89bd47cd20b7b000000000000000000000000ff26720636f2f1fd855bfedefbfbd6e175633d740000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://4f3e7cd4b61f537043ee0908965478730991539f041f645bb783d0dc44e21145"}]}