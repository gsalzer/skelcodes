{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract erc20_indivisible {\r\n\r\n    uint256 constant MAX_UINT256 = 2**256 - 1;\r\n    uint256 public totalSupply;\r\n    string public name;\r\n    uint8 public decimals;\r\n    string public symbol;\r\n    string public version = 'smartmachine_erc20_indivisible';\r\n    address public creator;\r\n    uint public init;\r\n    address public Factory;\r\n    mapping (address => uint256) balances;\r\n    mapping (address => mapping (address => uint256)) allowed;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    constructor() public {}\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success) {\r\n        require(balances[msg.sender] >= _value);\r\n        balances[msg.sender] -= _value;\r\n        balances[_to] += _value;\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public  returns (bool success) {\r\n        uint256 allowance = allowed[_from][msg.sender];\r\n        require(balances[_from] >= _value && allowance >= _value);\r\n        balances[_to] += _value;\r\n        balances[_from] -= _value;\r\n        if (allowance < MAX_UINT256) {\r\n            allowed[_from][msg.sender] -= _value;\r\n        }\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public constant returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\r\n      return allowed[_owner][_spender];\r\n    }\r\n\r\n    /* Approves and then calls the receiving contract */\r\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData));\r\n        return true;\r\n    }\r\n\r\n\r\n    function init(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        address _owner\r\n        ) public returns (bool){\r\n        if(init>0)revert();\r\n        balances[_owner] = _initialAmount;\r\n        totalSupply = _initialAmount;\r\n        name = _tokenName; \r\n        decimals = _decimalUnits;\r\n        symbol = _tokenSymbol;   \r\n        creator=_owner;\r\n        Factory=msg.sender;\r\n        init=1;\r\n        return true;\r\n    }\r\n\r\n    function init2(\r\n        uint256 _initialAmount,\r\n        string _tokenName,\r\n        uint8 _decimalUnits,\r\n        string _tokenSymbol,\r\n        address _owner,\r\n        address _freebie\r\n        ) public returns (bool){\r\n        if(init>0)revert();\r\n        FloodNameSys flood= FloodNameSys(address(0x63030f02d4B18acB558750db1Dc9A2F3961531eE));\r\n        uint256 p=flood.freebiePercentage();\r\n        if(_initialAmount>1000){\r\n            balances[_owner] = _initialAmount-((_initialAmount/1000)*p);\r\n            balances[_freebie] = (_initialAmount/1000)*p;\r\n        }else{\r\n            balances[_owner] = _initialAmount;\r\n        }\r\n        totalSupply = _initialAmount;\r\n        name = _tokenName;\r\n        decimals = _decimalUnits;\r\n        symbol = _tokenSymbol;   \r\n        creator=_owner;\r\n        Factory=msg.sender;\r\n        init=1;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract FloodNameSys{\r\n\r\n\taddress public owner;\r\n\tbool public gift;\r\n\tuint256 public giftAmount;\r\n\taddress[] public list;\r\n\terc20_indivisible public flood;\r\n\tuint256 public cost;\r\n\tuint256 public freebiePercentage;\r\n\tuint256 public totalCoins;\r\n\tuint256 public totalFreeCoins;\r\n\tmapping(address => address[]) public created;\r\n\tmapping(address => address[]) public generated;\r\n\tmapping(address => address) public generator;\r\n\tmapping(address => bool) public permission;\r\n\tmapping(string => bool) names;\r\n\tmapping(string => bool) symbols;\r\n\tmapping(string => address) namesAddress;\r\n\tmapping(string => address) symbolsAddress;\r\n\tmapping(address => string)public tokenNames;\r\n\tmapping(address => string)public tokenSymbols;\r\n\r\n\r\n\tconstructor() public{\r\n\t\towner=msg.sender;\r\n\t\tpermission[msg.sender]=true;\r\n\t}\r\n\r\n\tfunction setCost(uint256 c) public{\r\n       \t\tif(msg.sender!=owner)revert();\r\n       \t\tcost=c;\r\n\t}\r\n\r\n\tfunction setFreePerc(uint256 p) public{\r\n       \t\tif(msg.sender!=owner)revert();\r\n       \t\tfreebiePercentage=p;\r\n\t}\r\n\r\n\r\n\tfunction setGiftToken(address _flood)public{\r\n\t\tif(msg.sender!=owner)revert();\r\n\t\tflood=erc20_indivisible(_flood);\r\n\t}\r\n\r\n\tfunction enableGift(bool b) public{\r\n\t\tif(msg.sender!=owner)revert();\r\n\t\tgift=b;\r\n\t}\r\n\r\n\tfunction setGiftAmount(uint256 u) public{\r\n\t\tif(msg.sender!=owner)revert();\r\n\tgiftAmount=u;\r\n\t}\r\n\r\n\tfunction lockName(string _name,string _symbol,bool b) public{\r\n\t\tif(!permission[msg.sender])revert();\r\n\t\tnames[_name]=b;\r\n\t\tsymbols[_symbol]=b;\r\n\t}\r\n\r\n\tfunction deleteToken(address a)public{\r\n\t\tif(!permission[msg.sender])revert();\r\n\t\tnames[tokenNames[a]]=false;\r\n\t\tnamesAddress[tokenNames[a]]=address(0x0);\r\n\t\ttokenNames[a]=\"\";\r\n\t\tsymbols[tokenSymbols[a]]=false;\r\n\t\tsymbolsAddress[tokenSymbols[a]]=address(0x0);\r\n\t\ttokenSymbols[a]=\"\";\r\n\t}\r\n\r\n\tfunction add(address token,address own,string _name,string _symbol,bool free) public returns (bool){\r\n\t\tif((!permission[msg.sender])||(names[_name])||(symbols[_symbol]))revert();\r\n\t\tif(free){\r\n\t\t\tcreated[own].push(address(token));\r\n\t\t\ttotalFreeCoins++;\r\n\t\t}else{\r\n\t\t\tcreated[own].push(address(token));\r\n\t\t\tlist.push(address(token));\r\n\t\t\tnames[_name]=true;\r\n\t\t\ttokenNames[token]=_name;\r\n\t\t\tnamesAddress[_name]=token;\r\n\t\t\tsymbols[_symbol]=true;\r\n\t\t\ttokenSymbols[token]=_symbol;\r\n\t\t\tsymbolsAddress[_symbol]=token;\r\n\t\t\tif(gift)flood.transfer(own,giftAmount);\r\n\t\t}\r\n\t\tgenerator[token]=msg.sender;\r\n\t\tgenerated[msg.sender].push(token);\r\n\t\ttotalCoins++;\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction setOwner(address o)public{\r\n\t\tif(msg.sender!=owner)revert();\r\n\t\towner=o;\r\n\t}\r\n\r\n\tfunction setPermission(address a,bool b)public{\r\n\t\tif(msg.sender!=owner)revert();\r\n\t\tpermission[a]=b;\r\n\t}\r\n\r\n\tfunction getMyTokens(address own,uint i)public constant returns(address,uint){\r\n\t\treturn (created[own][i],created[own].length);\r\n\t}\r\n\r\n\tfunction getGeneratorTokens(address gen,uint i)public constant returns(address,uint){\r\n\t\treturn (generated[gen][i],generated[gen].length);\r\n\t}\r\n\r\n\tfunction getTokenIndex(uint i)public constant returns(address,uint){\r\n\t\treturn (list[i],list.length);\r\n\t}\r\n\r\n\tfunction getToken(address _token)public constant returns(string,string){\r\n\t\treturn (tokenNames[_token],tokenSymbols[_token]);\r\n\t}\r\n\r\n\tfunction checkName(string _name)public constant returns(bool){return names[_name];}\r\n\r\n\tfunction checkSymbol(string _symbol)public constant returns(bool){return symbols[_symbol];}\r\n\r\n\tfunction findName(string _name)public constant returns(address){return namesAddress[_name];}\r\n\r\n\tfunction findSymbol(string _symbol)public constant returns(address){return symbolsAddress[_symbol];}\r\n}\r\n\r\n\r\ncontract erc20_indivisible_factory {\r\n\r\n    address public owner;\r\n    FloodNameSys public nsys;\r\n    address public wallet;\r\n\r\n    constructor() public{\r\n      owner=msg.sender;\r\n    }\r\n\r\n    function setOwner(address a) public{\r\n       if(msg.sender!=owner)revert();\r\n       owner=a;\r\n    }\r\n    \r\n    function setWallet(address a) public{\r\n       if(msg.sender!=owner)revert();\r\n       wallet=a;\r\n    }\r\n\r\n\r\n    function setNameSys(address l) public{\r\n        if(msg.sender!=owner)revert();\r\n        nsys=FloodNameSys(l);\r\n    }\r\n\r\n\r\n    function createToken(uint256 _initialAmount, string _name, uint8 _decimals, string _symbol)public payable{\r\n        erc20_indivisible newToken = new erc20_indivisible();\r\n        uint256 c=nsys.cost();\r\n        if(msg.value>=c){\r\n            wallet.transfer(msg.value);\r\n            if(!newToken.init(_initialAmount, _name, _decimals, _symbol,msg.sender))revert();\r\n            if(!nsys.add(address(newToken),msg.sender,_name,_symbol,false))revert();\r\n        }else{\r\n            if(!newToken.init2(_initialAmount, _name, _decimals, _symbol,msg.sender,wallet))revert();\r\n            if(!nsys.add(address(newToken),msg.sender,_name,_symbol,true))revert();\r\n            \r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"l\",\"type\":\"address\"}],\"name\":\"setNameSys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nsys\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_initialAmount\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_decimals\",\"type\":\"uint8\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"createToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"name\":\"setWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"erc20_indivisible_factory","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://39f6de8ace08f2710f01c9521d5c85053118207306029e722ce77d6f750d6d09"}]}