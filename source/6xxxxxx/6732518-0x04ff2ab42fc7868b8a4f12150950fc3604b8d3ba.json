{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright (C) 2017-2018 Hashfuture Inc. All rights reserved.\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ownable {\r\n    address public owner;\r\n\r\n    function ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * The signature mechanism to enhance the credibility of the token.\r\n * The sign process is asychronous.\r\n * After the creation of the contract, one who verifies the contract and\r\n * is willing to guarantee for it can sign the contract address.\r\n */\r\ncontract verifiable {\r\n\r\n    struct Signature {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    /**\r\n     * signatures\r\n     * Used to verify that if the contract is protected\r\n     * By hashworld or other publicly verifiable organizations\r\n     */\r\n    mapping(address => Signature) public signatures;\r\n\r\n    /**\r\n     * sign Token\r\n     */\r\n    function sign(uint8 v, bytes32 r, bytes32 s) public {\r\n        signatures[msg.sender] = Signature(v, r, s);\r\n    }\r\n\r\n    /**\r\n     * To verify whether a specific signer has signed this contract's address\r\n     * @param signer address to verify\r\n     */\r\n    function verify(address signer) public constant returns(bool) {\r\n        bytes32 hash = keccak256(abi.encodePacked(address(this)));\r\n        Signature storage sig = signatures[signer];\r\n        return ecrecover(hash, sig.v, sig.r, sig.s) == signer;\r\n    }\r\n}\r\n\r\ncontract AssetHashToken is ownable, verifiable{\r\n    using SafeMath for uint;\r\n\r\n    //Asset Struct\r\n    struct data {\r\n        // link URL of the original information for storing data; null means undisclosed\r\n        string link;\r\n        // The hash type of the original data, such as SHA-256\r\n        string hashType;\r\n        // Hash value of the agreed content.\r\n        string hashValue;\r\n    }\r\n\r\n    data public assetFile;\r\n    data public legalFile;\r\n\r\n    //The token id\r\n    uint id;\r\n\r\n    //The validity of the contract\r\n    bool public isValid;\r\n\r\n    //The splitting status of the asset\r\n    //Set to true if the asset has been splitted to small tokens\r\n    bool public isSplitted;\r\n\r\n    // The tradeable status of asset\r\n    // Leave (together with assetPrice) for auto buy and sell functionality (with Ether).\r\n    bool public isTradable;\r\n\r\n    /**\r\n     * The price of asset\r\n     * if the contract is valid and tradeable,\r\n     * others can get asset by transfer assetPrice ETH to contract\r\n     */\r\n    uint public assetPrice;\r\n\r\n    uint public pledgePrice;\r\n\r\n    //Some addtional notes\r\n    string public remark1;\r\n    string public remark2;\r\n\r\n    // Digital Asset Url\r\n    string private digitalAsset;\r\n\r\n    mapping (address => uint) pendingWithdrawals;\r\n\r\n    /**\r\n     * The asset update events\r\n     */\r\n    event TokenUpdateEvent (\r\n        uint id,\r\n        bool isValid,\r\n        bool isTradable,\r\n        address owner,\r\n        uint assetPrice,\r\n        string assetFileLink,\r\n        string legalFileLink\r\n    );\r\n\r\n    modifier onlyUnsplitted {\r\n        require(isSplitted == false, \"This function can be called only under unsplitted status\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyValid {\r\n        require(isValid == true, \"Contract is invaild!\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * constructor\r\n     * @param _id Token id\r\n     * @param _owner initial owner\r\n     * @param _assetPrice The price of asset\r\n     * @param _assetFileUrl The url of asset file\r\n     * @param _assetFileHashType The hash type of asset file\r\n     * @param _assetFileHashValue The hash value of asset file\r\n     * @param _legalFileUrl The url of legal file\r\n     * @param _legalFileHashType The hash type of legal file\r\n     * @param _legalFileHashValue The hash value of legal file\r\n     */\r\n    constructor(\r\n        uint _id,\r\n        address _owner,\r\n        uint _assetPrice,\r\n        uint _pledgePrice,\r\n        string _assetFileUrl,\r\n        string _assetFileHashType,\r\n        string _assetFileHashValue,\r\n        string _legalFileUrl,\r\n        string _legalFileHashType,\r\n        string _legalFileHashValue,\r\n        string _digitalAsset\r\n        ) public {\r\n\r\n        id = _id;\r\n        owner = _owner;\r\n\r\n        assetPrice = _assetPrice;\r\n        pledgePrice = _pledgePrice;\r\n        digitalAsset = _digitalAsset;\r\n\r\n        initAssetFile(\r\n            _assetFileUrl, _assetFileHashType, _assetFileHashValue, _legalFileUrl, _legalFileHashType, _legalFileHashValue);\r\n\r\n        isValid = true;\r\n        isSplitted = false;\r\n        isTradable = false;\r\n    }\r\n\r\n    /**\r\n     * Initialize asset file and legal file\r\n     * @param _assetFileUrl The url of asset file\r\n     * @param _assetFileHashType The hash type of asset file\r\n     * @param _assetFileHashValue The hash value of asset file\r\n     * @param _legalFileUrl The url of legal file\r\n     * @param _legalFileHashType The hash type of legal file\r\n     * @param _legalFileHashValue The hash value of legal file\r\n     */\r\n    function initAssetFile(\r\n        string _assetFileUrl,\r\n        string _assetFileHashType,\r\n        string _assetFileHashValue,\r\n        string _legalFileUrl,\r\n        string _legalFileHashType,\r\n        string _legalFileHashValue\r\n        ) internal {\r\n        assetFile = data(\r\n            _assetFileUrl, _assetFileHashType, _assetFileHashValue);\r\n        legalFile = data(\r\n            _legalFileUrl, _legalFileHashType, _legalFileHashValue);\r\n    }\r\n\r\n     /**\r\n     * Get base asset info\r\n     */\r\n    function getAssetBaseInfo() public view onlyValid\r\n        returns (\r\n            uint _id,\r\n            uint _assetPrice,\r\n            bool _isTradable,\r\n            string _remark1,\r\n            string _remark2\r\n        )\r\n    {\r\n        _id = id;\r\n        _assetPrice = assetPrice;\r\n        _isTradable = isTradable;\r\n\r\n        _remark1 = remark1;\r\n        _remark2 = remark2;\r\n    }\r\n\r\n    /**\r\n     * set the price of asset\r\n     * @param newAssetPrice new price of asset\r\n     * Only can be called by owner\r\n     */\r\n    function setassetPrice(uint newAssetPrice)\r\n        public\r\n        onlyOwner\r\n        onlyValid\r\n        onlyUnsplitted\r\n    {\r\n        assetPrice = newAssetPrice;\r\n        emit TokenUpdateEvent (\r\n            id,\r\n            isValid,\r\n            isTradable,\r\n            owner,\r\n            assetPrice,\r\n            assetFile.link,\r\n            legalFile.link\r\n        );\r\n    }\r\n\r\n    /**\r\n     * set the tradeable status of asset\r\n     * @param status status of isTradable\r\n     * Only can be called by owner\r\n     */\r\n    function setTradeable(bool status) public onlyOwner onlyValid onlyUnsplitted {\r\n        isTradable = status;\r\n        emit TokenUpdateEvent (\r\n            id,\r\n            isValid,\r\n            isTradable,\r\n            owner,\r\n            assetPrice,\r\n            assetFile.link,\r\n            legalFile.link\r\n        );\r\n    }\r\n\r\n    /**\r\n     * set the remark1\r\n     * @param content new content of remark1\r\n     * Only can be called by owner\r\n     */\r\n    function setRemark1(string content) public onlyOwner onlyValid onlyUnsplitted {\r\n        remark1 = content;\r\n    }\r\n\r\n    /**\r\n     * set the remark2\r\n     * @param content new content of remark2\r\n     * Only can be called by owner\r\n     */\r\n    function setRemark2(string content) public onlyOwner onlyValid onlyUnsplitted {\r\n        remark2 = content;\r\n    }\r\n\r\n    /**\r\n     * get the digitalAsset\r\n     * Only can be called by owner\r\n     */\r\n    function getDigitalAsset() public view onlyOwner onlyValid onlyUnsplitted\r\n        returns (string _digitalAsset)\r\n    {\r\n        _digitalAsset = digitalAsset;\r\n    }\r\n\r\n    /**\r\n     * Modify the link of the asset file\r\n     * @param url new link\r\n     * Only can be called by owner\r\n     */\r\n    function setAssetFileLink(string url) public\r\n        onlyOwner\r\n        onlyValid\r\n        onlyUnsplitted\r\n    {\r\n        assetFile.link = url;\r\n        emit TokenUpdateEvent (\r\n            id,\r\n            isValid,\r\n            isTradable,\r\n            owner,\r\n            assetPrice,\r\n            assetFile.link,\r\n            legalFile.link\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Modify the link of the legal file\r\n     * @param url new link\r\n     * Only can be called by owner\r\n     */\r\n    function setLegalFileLink(string url)\r\n        public\r\n        onlyOwner\r\n        onlyValid\r\n        onlyUnsplitted\r\n    {\r\n        legalFile.link = url;\r\n        emit TokenUpdateEvent (\r\n            id,\r\n            isValid,\r\n            isTradable,\r\n            owner,\r\n            assetPrice,\r\n            assetFile.link,\r\n            legalFile.link\r\n        );\r\n    }\r\n\r\n    /**\r\n     * cancel contract\r\n     * Only can be called by owner\r\n     */\r\n    function cancelContract() public onlyOwner onlyValid onlyUnsplitted {\r\n        isValid = false;\r\n        emit TokenUpdateEvent (\r\n            id,\r\n            isValid,\r\n            isTradable,\r\n            owner,\r\n            assetPrice,\r\n            assetFile.link,\r\n            legalFile.link\r\n        );\r\n    }\r\n\r\n    /**\r\n     * overwrite the transferOwnership interface in ownable.\r\n     * Only can transfer when the token is not splitted into small keys.\r\n     * After transfer, the token should be set in \"no trading\" status.\r\n     */\r\n    function transferOwnership(address newowner) public onlyOwner onlyValid onlyUnsplitted {\r\n        owner = newowner;\r\n        isTradable = false;  // set to false for new owner\r\n\r\n        emit TokenUpdateEvent (\r\n            id,\r\n            isValid,\r\n            isTradable,\r\n            owner,\r\n            assetPrice,\r\n            assetFile.link,\r\n            legalFile.link\r\n        );\r\n    }\r\n\r\n\r\n    /**\r\n     * Buy asset\r\n     */\r\n    function buy() public payable onlyValid onlyUnsplitted {\r\n        require(isTradable == true, \"contract is tradeable\");\r\n        require(msg.value >= assetPrice, \"assetPrice not match\");\r\n        address origin_owner = owner;\r\n\r\n        owner = msg.sender;\r\n        isTradable = false;  // set to false for new owner\r\n\r\n        emit TokenUpdateEvent (\r\n            id,\r\n            isValid,\r\n            isTradable,\r\n            owner,\r\n            assetPrice,\r\n            assetFile.link,\r\n            legalFile.link\r\n        );\r\n\r\n        uint priviousBalance = pendingWithdrawals[origin_owner];\r\n        pendingWithdrawals[origin_owner] = priviousBalance.add(assetPrice);\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint amount = pendingWithdrawals[msg.sender];\r\n\r\n        // Remember to zero the pending refund before sending to prevent re-entrancy attacks\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n}\r\n\r\n/**\r\n * Standard ERC 20 interface.\r\n */\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract DividableAsset is AssetHashToken, ERC20Interface {\r\n    using SafeMath for uint;\r\n\r\n    ERC20Interface stableToken;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint public _totalSupply;\r\n\r\n    address public operator;\r\n\r\n    uint collectPrice;\r\n\r\n    address[] internal allowners;\r\n    mapping (address => uint) public indexOfowner;\r\n\r\n    mapping (address => uint) public balances;\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n\r\n    modifier onlySplitted {\r\n        require(isSplitted == true, \"Splitted status required\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator {\r\n        require(operator == msg.sender, \"Operation only permited by operator\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * The force collect event\r\n     */\r\n    event ForceCollectEvent (\r\n        uint id,\r\n        uint price,\r\n        address operator\r\n    );\r\n\r\n    /**\r\n     * The token split event\r\n     */\r\n    event TokenSplitEvent (\r\n        uint id,\r\n        uint supply,\r\n        uint8 decim,\r\n        uint price,\r\n        address owner\r\n    );\r\n\r\n    constructor(\r\n        string _name,\r\n        string _symbol,\r\n        address _tokenAddress,\r\n        uint _id,\r\n        address _owner,\r\n        uint _assetPrice,\r\n        uint _pledgePrice,\r\n        string _assetFileUrl,\r\n        string _assetFileHashType,\r\n        string _assetFileHashValue,\r\n        string _legalFileUrl,\r\n        string _legalFileHashType,\r\n        string _legalFileHashValue,\r\n        string _digitalAsset\r\n        ) public\r\n        AssetHashToken(\r\n            _id,\r\n            _owner,\r\n            _assetPrice,\r\n            _pledgePrice,\r\n            _assetFileUrl,\r\n            _assetFileHashType,\r\n            _assetFileHashValue,\r\n            _legalFileUrl,\r\n            _legalFileHashType,\r\n            _legalFileHashValue,\r\n            _digitalAsset\r\n        )\r\n    {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        operator = msg.sender; // TODO set to HashFuture owned address\r\n        stableToken = ERC20Interface(_tokenAddress);\r\n    }\r\n\r\n    // ERC 20 Basic Functionality\r\n\r\n    /**\r\n     * Total supply\r\n     */\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply.sub(balances[address(0)]);\r\n    }\r\n\r\n    /**\r\n     * Get the token balance for account `tokenOwner`\r\n     */\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    /**\r\n     * Returns the amount of tokens approved by the owner that can be\r\n     * transferred to the spender's account\r\n     */\r\n    function allowance(address tokenOwner, address spender)\r\n        public view\r\n        returns (uint remaining)\r\n    {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    /**\r\n     * Transfer the balance from token owner's account to `to` account\r\n     * - Owner's account must have sufficient balance to transfer\r\n     * - 0 value transfers are allowed\r\n     */\r\n    function transfer(address to, uint tokens)\r\n        public\r\n        onlySplitted\r\n        returns (bool success)\r\n    {\r\n        require(tokens > 0);\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n\r\n\r\n        // ensure that each address appears only once in allowners list\r\n        // so that distribute divident or force collect only pays one time\r\n        if (indexOfowner[to] == 0) {\r\n            allowners.push(to);\r\n            indexOfowner[to] = allowners.length;\r\n        }\r\n        // could be removed? no\r\n        if (balances[msg.sender] == 0) {\r\n            uint index = indexOfowner[msg.sender].sub(1);\r\n            indexOfowner[msg.sender] = 0;\r\n\r\n            if (index != allowners.length.sub(1)) {\r\n                allowners[index] = allowners[allowners.length.sub(1)];\r\n                indexOfowner[allowners[index]] = index.add(1);\r\n            }\r\n\r\n            //delete allowners[allowners.length.sub(1)];\r\n            allowners.length = allowners.length.sub(1);\r\n        }\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n     * from the token owner's account\r\n     */\r\n    function approve(address spender, uint tokens)\r\n        public\r\n        onlySplitted\r\n        returns (bool success)\r\n    {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Transfer `tokens` from the `from` account to the `to` account\r\n     */\r\n    function transferFrom(address from, address to, uint tokens)\r\n        public\r\n        onlySplitted\r\n        returns (bool success)\r\n    {\r\n        require(tokens > 0);\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n\r\n        // ensure that each address appears only once in allowners list\r\n        // so that distribute divident or force collect only pays one time\r\n        if (indexOfowner[to] == 0) {\r\n            allowners.push(to);\r\n            indexOfowner[to] = allowners.length;\r\n        }\r\n\r\n        // could be removed? no\r\n        if (balances[from] == 0) {\r\n            uint index = indexOfowner[from].sub(1);\r\n            indexOfowner[from] = 0;\r\n\r\n            if (index != allowners.length.sub(1)) {\r\n                allowners[index] = allowners[allowners.length.sub(1)];\r\n                indexOfowner[allowners[index]] = index.add(1);\r\n            }\r\n            //delete allowners[allowners.length.sub(1)];\r\n            allowners.length = allowners.length.sub(1);\r\n        }\r\n\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * \r\n     * Warning: may fail when number of owners exceeds 100 due to gas limit of a block in Ethereum.\r\n     */\r\n    function distributeDivident(uint amount) public {\r\n        // stableToken.approve(address(this), amount)\r\n        // should be called by the caller to the token contract in previous\r\n        uint value = 0;\r\n        uint length = allowners.length;\r\n        require(stableToken.balanceOf(msg.sender) >= amount, \"Insufficient balance for sender\");\r\n        require(stableToken.allowance(msg.sender, address(this)) >= amount, \"Insufficient allowance for contract\");\r\n        for (uint i = 0; i < length; i++) {\r\n            //value = amount * balances[allowners[i]] / _totalSupply;\r\n            value = amount.mul(balances[allowners[i]]);\r\n            value = value.div(_totalSupply);\r\n\r\n            // Always use a require when doing token transfer!\r\n            // Do not think it works like the transfer method for ether,\r\n            // which handles failure and will throw for you.\r\n            require(stableToken.transferFrom(msg.sender, allowners[i], value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * partially distribute divident to given address list\r\n     */\r\n    function partialDistributeDivident(uint amount, address[] _address) public {\r\n        // stableToken.approve(address(this), amount)\r\n        // should be called by the caller to the token contract in previous\r\n        uint value = 0;\r\n        uint length = _address.length;\r\n        require(stableToken.balanceOf(msg.sender) >= amount, \"Insufficient balance for sender\");\r\n        require(stableToken.allowance(msg.sender, address(this)) >= amount, \"Insufficient allowance for contract\");\r\n\r\n        uint totalAmount = 0;\r\n        for (uint j = 0; j < length; j++) {\r\n            totalAmount = totalAmount.add(balances[_address[j]]);\r\n        }\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            value = amount.mul(balances[_address[i]]);\r\n            value = value.div(totalAmount);\r\n\r\n            // Always use a require when doing token transfer!\r\n            // Do not think it works like the transfer method for ether,\r\n            // which handles failure and will throw for you.\r\n            require(stableToken.transferFrom(msg.sender, _address[i], value));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Collect all small keys in batches.\r\n     * Anyone can force collect all keys if he provides with sufficient stable tokens.\r\n     * However, due to the gas limitation of Ethereum, he can not collect all keys\r\n     * with only one call. Hence an agent that can be trusted is need.\r\n     * The operator is such an agent who will first receive a request to collect all keys,\r\n     * and then collect them with the stable tokens provided by the claimer.\r\n     * @param _address each address in the array means a target address to be collected from.\r\n     */\r\n    function collectAllForce(address[] _address) public onlyOperator {\r\n        // stableToken.approve(address(this), amount)\r\n        // should be called by the caller to the token contract in previous\r\n        uint value = 0;\r\n        uint length = _address.length;\r\n\r\n        uint total_amount = 0;\r\n\r\n        for (uint j = 0; j < length; j++) {\r\n            if (indexOfowner[_address[j]] == 0) {\r\n                continue;\r\n            }\r\n\r\n            total_amount = total_amount.add(collectPrice.mul(balances[_address[j]]));\r\n        }\r\n\r\n        require(stableToken.balanceOf(msg.sender) >= total_amount, \"Insufficient balance for sender\");\r\n        require(stableToken.allowance(msg.sender, address(this)) >= total_amount, \"Insufficient allowance for contract\");\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            // Always use a require when doing token transfer!\r\n            // Do not think it works like the transfer method for ether,\r\n            // which handles failure and will throw for you.\r\n            if (indexOfowner[_address[i]] == 0) {\r\n                continue;\r\n            }\r\n\r\n            value = collectPrice.mul(balances[_address[i]]);\r\n\r\n            require(stableToken.transferFrom(msg.sender, _address[i], value));\r\n            balances[msg.sender] = balances[msg.sender].add(balances[_address[i]]);\r\n            emit Transfer(_address[i], msg.sender, balances[_address[i]]);\r\n\r\n            balances[_address[i]] = 0;\r\n\r\n            uint index = indexOfowner[_address[i]].sub(1);\r\n            indexOfowner[_address[i]] = 0;\r\n\r\n            if (index != allowners.length.sub(1)) {\r\n                allowners[index] = allowners[allowners.length.sub(1)];\r\n                indexOfowner[allowners[index]] = index.add(1);\r\n            }\r\n            allowners.length = allowners.length.sub(1);\r\n        }\r\n\r\n        emit ForceCollectEvent(id, collectPrice, operator);\r\n    }\r\n\r\n    /**\r\n     * key inssurance. Split the whole token into small keys.\r\n     * Only the owner can perform this when the token is still valid and unsplitted.\r\n     * @param _supply Totol supply in ERC20 standard\r\n     * @param _decim  Decimal parameter in ERC20 standard\r\n     * @param _price The force acquisition price. If a claimer is willing to pay more than this value, he can\r\n     * buy the keys forcibly. Notice: the claimer can only buy all keys at one time or buy nothing and the\r\n     * buying process is delegated into a trusted agent. i.e. the operator.\r\n     * @param _address The initial distribution plan for the keys. This parameter contains the addresses.\r\n     * @param _amount  The amount corresponding to the initial distribution addresses.\r\n     */\r\n    function split(uint _supply, uint8 _decim, uint _price, address[] _address, uint[] _amount)\r\n        public\r\n        onlyValid\r\n        onlyOperator\r\n        onlyUnsplitted\r\n    {\r\n        require(_address.length == _amount.length);\r\n\r\n        isSplitted = true;\r\n        _totalSupply = _supply * 10 ** uint(_decim);\r\n        decimals = _decim;\r\n        collectPrice = _price;\r\n\r\n        uint amount = 0;\r\n        uint length = _address.length;\r\n\r\n        balances[msg.sender] = _totalSupply;\r\n        if (indexOfowner[msg.sender] == 0) {\r\n            allowners.push(msg.sender);\r\n            indexOfowner[msg.sender] = allowners.length;\r\n        }\r\n        emit Transfer(address(0), msg.sender, _totalSupply);\r\n\r\n        for (uint i = 0; i < length; i++) {\r\n            amount = _amount[i]; // * 10 ** uint(_decim);\r\n            balances[_address[i]] = amount;\r\n            balances[msg.sender] = balances[msg.sender].sub(amount);\r\n\r\n            // ensure that each address appears only once in allowners list\r\n            // so that distribute divident or force collect only pays one time\r\n            if (indexOfowner[_address[i]] == 0) {\r\n                allowners.push(_address[i]);\r\n                indexOfowner[_address[i]] = allowners.length;\r\n            }\r\n            emit Transfer(msg.sender, _address[i], amount);\r\n        }\r\n\r\n        emit TokenSplitEvent(id, _supply, _decim, _price, owner);\r\n    }\r\n\r\n    /**\r\n     * Token conversion. Turn the keys to a whole token.\r\n     * Only the sender with all keys in hand can perform this and he will be the new owner.\r\n     */\r\n    function merge() public onlyValid onlySplitted {\r\n        require(balances[msg.sender] == _totalSupply);\r\n        _totalSupply = 0;\r\n        balances[msg.sender] = 0;\r\n        owner = msg.sender;\r\n        isTradable = false;\r\n        isSplitted = false;\r\n        emit Transfer(msg.sender, address(0), _totalSupply);\r\n        emit TokenSplitEvent(id, 0, 0, 0, msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getDigitalAsset\",\"outputs\":[{\"name\":\"_digitalAsset\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"merge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAssetPrice\",\"type\":\"uint256\"}],\"name\":\"setassetPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pledgePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"legalFile\",\"outputs\":[{\"name\":\"link\",\"type\":\"string\"},{\"name\":\"hashType\",\"type\":\"string\"},{\"name\":\"hashValue\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_supply\",\"type\":\"uint256\"},{\"name\":\"_decim\",\"type\":\"uint8\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address[]\"},{\"name\":\"_amount\",\"type\":\"uint256[]\"}],\"name\":\"split\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remark1\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTradable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAssetBaseInfo\",\"outputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_assetPrice\",\"type\":\"uint256\"},{\"name\":\"_isTradable\",\"type\":\"bool\"},{\"name\":\"_remark1\",\"type\":\"string\"},{\"name\":\"_remark2\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signer\",\"type\":\"address\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSplitted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"indexOfowner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remark2\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"setTradeable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"content\",\"type\":\"string\"}],\"name\":\"setRemark2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"url\",\"type\":\"string\"}],\"name\":\"setLegalFileLink\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_address\",\"type\":\"address[]\"}],\"name\":\"partialDistributeDivident\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"signatures\",\"outputs\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assetFile\",\"outputs\":[{\"name\":\"link\",\"type\":\"string\"},{\"name\":\"hashType\",\"type\":\"string\"},{\"name\":\"hashValue\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"assetPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"distributeDivident\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"sign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"url\",\"type\":\"string\"}],\"name\":\"setAssetFileLink\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address[]\"}],\"name\":\"collectAllForce\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"content\",\"type\":\"string\"}],\"name\":\"setRemark1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newowner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_assetPrice\",\"type\":\"uint256\"},{\"name\":\"_pledgePrice\",\"type\":\"uint256\"},{\"name\":\"_assetFileUrl\",\"type\":\"string\"},{\"name\":\"_assetFileHashType\",\"type\":\"string\"},{\"name\":\"_assetFileHashValue\",\"type\":\"string\"},{\"name\":\"_legalFileUrl\",\"type\":\"string\"},{\"name\":\"_legalFileHashType\",\"type\":\"string\"},{\"name\":\"_legalFileHashValue\",\"type\":\"string\"},{\"name\":\"_digitalAsset\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"operator\",\"type\":\"address\"}],\"name\":\"ForceCollectEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"supply\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"decim\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"TokenSplitEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isValid\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"isTradable\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"assetPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetFileLink\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"legalFileLink\",\"type\":\"string\"}],\"name\":\"TokenUpdateEvent\",\"type\":\"event\"}]","ContractName":"DividableAsset","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001c000000000000000000000000000000000000000000000000000000000000002000000000000000000000000008dd5fbce2f6a956c3022ba3663759011dd51e73e0000000000000000000000000000000000000000000000000000000000000001000000000000000000000000a2c1806ac4515225bcdd709a9366f3f848f7282e00000000000000000000000000000000000000000000000000000000000027100000000000000000000000000000000000000000000000000000000000002710000000000000000000000000000000000000000000000000000000000000024000000000000000000000000000000000000000000000000000000000000002c00000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000036000000000000000000000000000000000000000000000000000000000000003c0000000000000000000000000000000000000000000000000000000000000040000000000000000000000000000000000000000000000000000000000000004600000000000000000000000000000000000000000000000000000000000000014e5889be980a028546865204372656174696f6e29000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c546865204372656174696f6e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004368747470733a2f2f6f73732e686173686675747572652e746f702f3031496e666f726d6174696f6e2532306f662532304469676974616c25323041737365742e706466000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000065348413235360000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004030633033333336393364386662396535653631643338363739336538663034643764663033366430366465366235353532666435386166393836393865336664000000000000000000000000000000000000000000000000000000000000003568747470733a2f2f6f73732e686173686675747572652e746f702f30325465726d732532306f66253230536572766963652e706466000000000000000000000000000000000000000000000000000000000000000000000000000000000000065348413235360000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000004039643062643131613566373136653739626463376437373761373331353631396438396634313366636537363631303863326434303032346431356639616333000000000000000000000000000000000000000000000000000000000000003168747470733a2f2f6f73732e686173686675747572652e746f702f2545352538382539422545392538302541302e6d7034000000000000000000000000000000","Library":"","SwarmSource":"bzzr://6fcfa09de6c2d32fc1e0b3c41464af3e0f1952bc63fc15c18e6ab579c26673ae"}]}