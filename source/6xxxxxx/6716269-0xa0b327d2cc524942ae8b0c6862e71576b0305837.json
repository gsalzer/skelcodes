{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Config {\r\n    uint256 public constant jvySupply = 333333333333333;\r\n    uint256 public constant bonusSupply = 83333333333333;\r\n    uint256 public constant saleSupply =  250000000000000;\r\n    uint256 public constant hardCapUSD = 8000000;\r\n\r\n    uint256 public constant preIcoBonus = 25;\r\n    uint256 public constant minimalContributionAmount = 0.4 ether;\r\n\r\n    function getStartPreIco() public view returns (uint256) {\r\n        // solium-disable-next-line security/no-block-members\r\n        uint256 nowTime = block.timestamp;\r\n        uint256 _preIcoStartTime = nowTime + 1 minutes;\r\n        return _preIcoStartTime;\r\n    }\r\n\r\n    function getStartIco() public view returns (uint256) {\r\n        uint256 _icoStartTime = 1543554000;\r\n        return _icoStartTime;\r\n    }\r\n\r\n    function getEndIco() public view returns (uint256) {\r\n        uint256 _icoEndTime = 1551416400;\r\n        return _icoEndTime;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\ncontract DetailedERC20 is ERC20 {\r\n  string public name;\r\n  string public symbol;\r\n  uint8 public decimals;\r\n\r\n  constructor(string _name, string _symbol, uint8 _decimals) public {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    decimals = _decimals;\r\n  }\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract Escrow is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  event Deposited(address indexed payee, uint256 weiAmount);\r\n  event Withdrawn(address indexed payee, uint256 weiAmount);\r\n\r\n  mapping(address => uint256) private deposits;\r\n\r\n  function depositsOf(address _payee) public view returns (uint256) {\r\n    return deposits[_payee];\r\n  }\r\n\r\n  /**\r\n  * @dev Stores the sent amount as credit to be withdrawn.\r\n  * @param _payee The destination address of the funds.\r\n  */\r\n  function deposit(address _payee) public onlyOwner payable {\r\n    uint256 amount = msg.value;\r\n    deposits[_payee] = deposits[_payee].add(amount);\r\n\r\n    emit Deposited(_payee, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw accumulated balance for a payee.\r\n  * @param _payee The address whose funds will be withdrawn and transferred to.\r\n  */\r\n  function withdraw(address _payee) public onlyOwner {\r\n    uint256 payment = deposits[_payee];\r\n    assert(address(this).balance >= payment);\r\n\r\n    deposits[_payee] = 0;\r\n\r\n    _payee.transfer(payment);\r\n\r\n    emit Withdrawn(_payee, payment);\r\n  }\r\n}\r\n\r\n\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(\r\n    address indexed purchaser,\r\n    address indexed beneficiary,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per wei\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n  constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(\r\n      msg.sender,\r\n      _beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(_beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method: \r\n   *   super._preValidatePurchase(_beneficiary, _weiAmount);\r\n   *   require(weiRaised.add(_weiAmount) <= cap);\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    token.safeTransfer(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _deliverTokens(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount)\r\n    internal view returns (uint256)\r\n  {\r\n    return _weiAmount.mul(rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\ncontract ConditionalEscrow is Escrow {\r\n  /**\r\n  * @dev Returns whether an address is allowed to withdraw their funds. To be\r\n  * implemented by derived contracts.\r\n  * @param _payee The destination address of the funds.\r\n  */\r\n  function withdrawalAllowed(address _payee) public view returns (bool);\r\n\r\n  function withdraw(address _payee) public {\r\n    require(withdrawalAllowed(_payee));\r\n    super.withdraw(_payee);\r\n  }\r\n}\r\n\r\n\r\ncontract RefundEscrow is Ownable, ConditionalEscrow {\r\n  enum State { Active, Refunding, Closed }\r\n\r\n  event Closed();\r\n  event RefundsEnabled();\r\n\r\n  State public state;\r\n  address public beneficiary;\r\n\r\n  /**\r\n   * @dev Constructor.\r\n   * @param _beneficiary The beneficiary of the deposits.\r\n   */\r\n  constructor(address _beneficiary) public {\r\n    require(_beneficiary != address(0));\r\n    beneficiary = _beneficiary;\r\n    state = State.Active;\r\n  }\r\n\r\n  /**\r\n   * @dev Stores funds that may later be refunded.\r\n   * @param _refundee The address funds will be sent to if a refund occurs.\r\n   */\r\n  function deposit(address _refundee) public payable {\r\n    require(state == State.Active);\r\n    super.deposit(_refundee);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n   * further deposits.\r\n   */\r\n  function close() public onlyOwner {\r\n    require(state == State.Active);\r\n    state = State.Closed;\r\n    emit Closed();\r\n  }\r\n\r\n  /**\r\n   * @dev Allows for refunds to take place, rejecting further deposits.\r\n   */\r\n  function enableRefunds() public onlyOwner {\r\n    require(state == State.Active);\r\n    state = State.Refunding;\r\n    emit RefundsEnabled();\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraws the beneficiary's funds.\r\n   */\r\n  function beneficiaryWithdraw() public {\r\n    require(state == State.Closed);\r\n    beneficiary.transfer(address(this).balance);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether refundees can withdraw their deposits (be refunded).\r\n   */\r\n  function withdrawalAllowed(address _payee) public view returns (bool) {\r\n    return state == State.Refunding;\r\n  }\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\ncontract CappedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public cap;\r\n\r\n  /**\r\n   * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\r\n   * @param _cap Max amount of wei to be contributed\r\n   */\r\n  constructor(uint256 _cap) public {\r\n    require(_cap > 0);\r\n    cap = _cap;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the cap has been reached.\r\n   * @return Whether the cap was reached\r\n   */\r\n  function capReached() public view returns (bool) {\r\n    return weiRaised >= cap;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring purchase to respect the funding cap.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n    require(weiRaised.add(_weiAmount) <= cap);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyWhileOpen\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\ncontract FinalizableCrowdsale is Ownable, TimedCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  bool public isFinalized = false;\r\n\r\n  event Finalized();\r\n\r\n  /**\r\n   * @dev Must be called after crowdsale ends, to do some extra finalization\r\n   * work. Calls the contract's finalization function.\r\n   */\r\n  function finalize() public onlyOwner {\r\n    require(!isFinalized);\r\n    require(hasClosed());\r\n\r\n    finalization();\r\n    emit Finalized();\r\n\r\n    isFinalized = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Can be overridden to add finalization logic. The overriding function\r\n   * should call super.finalization() to ensure the chain of finalization is\r\n   * executed entirely.\r\n   */\r\n  function finalization() internal {\r\n  }\r\n\r\n}\r\n\r\ncontract RefundableCrowdsale is FinalizableCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // minimum amount of funds to be raised in weis\r\n  uint256 public goal;\r\n\r\n  // refund escrow used to hold funds while crowdsale is running\r\n  RefundEscrow private escrow;\r\n\r\n  /**\r\n   * @dev Constructor, creates RefundEscrow.\r\n   * @param _goal Funding goal\r\n   */\r\n  constructor(uint256 _goal) public {\r\n    require(_goal > 0);\r\n    escrow = new RefundEscrow(wallet);\r\n    goal = _goal;\r\n  }\r\n\r\n  /**\r\n   * @dev Investors can claim refunds here if crowdsale is unsuccessful\r\n   */\r\n  function claimRefund() public {\r\n    require(isFinalized);\r\n    require(!goalReached());\r\n\r\n    escrow.withdraw(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether funding goal was reached.\r\n   * @return Whether funding goal was reached\r\n   */\r\n  function goalReached() public view returns (bool) {\r\n    return weiRaised >= goal;\r\n  }\r\n\r\n  /**\r\n   * @dev escrow finalization task, called when owner calls finalize()\r\n   */\r\n  function finalization() internal {\r\n    if (goalReached()) {\r\n      escrow.close();\r\n      escrow.beneficiaryWithdraw();\r\n    } else {\r\n      escrow.enableRefunds();\r\n    }\r\n\r\n    super.finalization();\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides Crowdsale fund forwarding, sending funds to escrow.\r\n   */\r\n  function _forwardFunds() internal {\r\n    escrow.deposit.value(msg.value)(msg.sender);\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\ncontract MultiSigWallet {\r\n    uint constant public MAX_OWNER_COUNT = 50;\r\n\r\n    event Confirmation(address indexed sender, uint indexed transactionId);\r\n    event Revocation(address indexed sender, uint indexed transactionId);\r\n    event Submission(uint indexed transactionId);\r\n    event Execution(uint indexed transactionId);\r\n    event ExecutionFailure(uint indexed transactionId);\r\n    event Deposit(address indexed sender, uint value);\r\n    event OwnerAddition(address indexed owner);\r\n    event OwnerRemoval(address indexed owner);\r\n    event RequirementChange(uint required);\r\n\r\n    mapping (uint => Transaction) public transactions;\r\n    mapping (uint => mapping (address => bool)) public confirmations;\r\n    mapping (address => bool) public isOwner;\r\n\r\n    address[] public owners;\r\n    uint public required;\r\n    uint public transactionCount;\r\n\r\n    struct Transaction {\r\n        address destination;\r\n        uint value;\r\n        bytes data;\r\n        bool executed;\r\n    }\r\n\r\n    modifier onlyWallet() {\r\n        require(msg.sender == address(this));\r\n        _;\r\n    }\r\n\r\n    modifier ownerDoesNotExist(address owner) {\r\n        require(!isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier ownerExists(address owner) {\r\n        require(isOwner[owner]);\r\n        _;\r\n    }\r\n\r\n    modifier transactionExists(uint transactionId) {\r\n        require(transactions[transactionId].destination != 0);\r\n        _;\r\n    }\r\n\r\n    modifier confirmed(uint transactionId, address owner) {\r\n        require(confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notConfirmed(uint transactionId, address owner) {\r\n        require(!confirmations[transactionId][owner]);\r\n        _;\r\n    }\r\n\r\n    modifier notExecuted(uint transactionId) {\r\n        require(!transactions[transactionId].executed);\r\n        _;\r\n    }\r\n\r\n    modifier notNull(address _address) {\r\n        require(_address != address(0));\r\n        _;\r\n    }\r\n\r\n    modifier validRequirement(uint ownerCount, uint _required) {\r\n        bool ownerValid = ownerCount <= MAX_OWNER_COUNT;\r\n        bool ownerNotZero = ownerCount != 0;\r\n        bool requiredValid = _required <= ownerCount;\r\n        bool requiredNotZero = _required != 0;\r\n        require(ownerValid && ownerNotZero && requiredValid && requiredNotZero);\r\n        _;\r\n    }\r\n\r\n    /// @dev Fallback function allows to deposit ether.\r\n    function() payable public {\r\n        fallback();\r\n    }\r\n\r\n    function fallback() payable public {\r\n        if (msg.value > 0) {\r\n            emit Deposit(msg.sender, msg.value);\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Public functions\r\n     */\r\n    /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n    /// @param _owners List of initial owners.\r\n    /// @param _required Number of required confirmations.\r\n    constructor(\r\n        address[] _owners, \r\n        uint _required\r\n    ) public validRequirement(_owners.length, _required) \r\n    {\r\n        for (uint i = 0; i<_owners.length; i++) {\r\n            require(!isOwner[_owners[i]] && _owners[i] != 0);\r\n            isOwner[_owners[i]] = true;\r\n        }\r\n        owners = _owners;\r\n        required = _required;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of new owner.\r\n    function addOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerDoesNotExist(owner)\r\n        notNull(owner)\r\n        validRequirement(owners.length + 1, required)\r\n    {\r\n        isOwner[owner] = true;\r\n        owners.push(owner);\r\n        emit OwnerAddition(owner);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner.\r\n    function removeOwner(address owner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n    {\r\n        isOwner[owner] = false;\r\n        for (uint i = 0; i < owners.length - 1; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = owners[owners.length - 1];\r\n                break;\r\n            }\r\n        owners.length -= 1;\r\n        if (required > owners.length)\r\n            changeRequirement(owners.length);\r\n        emit OwnerRemoval(owner);\r\n    }\r\n\r\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n    /// @param owner Address of owner to be replaced.\r\n    /// @param newOwner Address of new owner.\r\n    function replaceOwner(address owner, address newOwner)\r\n        public\r\n        onlyWallet\r\n        ownerExists(owner)\r\n        ownerDoesNotExist(newOwner)\r\n    {\r\n        for (uint i = 0; i < owners.length; i++)\r\n            if (owners[i] == owner) {\r\n                owners[i] = newOwner;\r\n                break;\r\n            }\r\n        isOwner[owner] = false;\r\n        isOwner[newOwner] = true;\r\n        emit OwnerRemoval(owner);\r\n        emit OwnerAddition(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n    /// @param _required Number of required confirmations.\r\n    function changeRequirement(uint _required)\r\n        public\r\n        onlyWallet\r\n        validRequirement(owners.length, _required)\r\n    {\r\n        required = _required;\r\n        emit RequirementChange(_required);\r\n    }\r\n\r\n    /// @dev Allows an owner to submit and confirm a transaction.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function submitTransaction(address destination, uint value, bytes data)\r\n        public\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = addTransaction(destination, value, data);\r\n        confirmTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to confirm a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function confirmTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        transactionExists(transactionId)\r\n        notConfirmed(transactionId, msg.sender)\r\n    {\r\n        confirmations[transactionId][msg.sender] = true;\r\n        emit Confirmation(msg.sender, transactionId);\r\n        executeTransaction(transactionId);\r\n    }\r\n\r\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function revokeConfirmation(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        confirmations[transactionId][msg.sender] = false;\r\n        emit Revocation(msg.sender, transactionId);\r\n    }\r\n\r\n    /// @dev Allows anyone to execute a confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    function executeTransaction(uint transactionId)\r\n        public\r\n        ownerExists(msg.sender)\r\n        confirmed(transactionId, msg.sender)\r\n        notExecuted(transactionId)\r\n    {\r\n        if (isConfirmed(transactionId)) {\r\n            Transaction storage txn = transactions[transactionId];\r\n            txn.executed = true;\r\n            if (txn.destination.call.value(txn.value)(txn.data))\r\n                emit Execution(transactionId);\r\n            else {\r\n                emit ExecutionFailure(transactionId);\r\n                txn.executed = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns the confirmation status of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Confirmation status.\r\n    function isConfirmed(uint transactionId) public view returns (bool) {\r\n        uint count = 0;\r\n        for (uint i = 0; i < owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]])\r\n                count += 1;\r\n            if (count == required)\r\n                return true;\r\n        }\r\n    }\r\n\r\n    /*\r\n     * Internal functions\r\n     */\r\n    /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n    /// @param destination Transaction target address.\r\n    /// @param value Transaction ether value.\r\n    /// @param data Transaction data payload.\r\n    /// @return Returns transaction ID.\r\n    function addTransaction(address destination, uint value, bytes data)\r\n        internal\r\n        notNull(destination)\r\n        returns (uint transactionId)\r\n    {\r\n        transactionId = transactionCount;\r\n        transactions[transactionId] = Transaction({\r\n            destination: destination,\r\n            value: value,\r\n            data: data,\r\n            executed: false\r\n        });\r\n        transactionCount += 1;\r\n        emit Submission(transactionId);\r\n    }\r\n\r\n    /*\r\n     * Web3 call functions\r\n     */\r\n    /// @dev Returns number of confirmations of a transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Number of confirmations.\r\n    function getConfirmationCount(uint transactionId) public view returns (uint count) {\r\n        for (uint i = 0; i < owners.length; i++) {\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns total number of transactions after filers are applied.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Total number of transactions after filters are applied.\r\n    function getTransactionCount(\r\n        bool pending, \r\n        bool executed\r\n    ) public view returns (uint count) {\r\n        for (uint i = 0; i < transactionCount; i++) {\r\n            if (pending && \r\n                !transactions[i].executed || \r\n                executed && \r\n                transactions[i].executed\r\n            ) {\r\n                count += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @dev Returns list of owners.\r\n    /// @return List of owner addresses.\r\n    function getOwners() public view returns (address[]) {\r\n        return owners;\r\n    }\r\n\r\n    /// @dev Returns array with owner addresses, which confirmed transaction.\r\n    /// @param transactionId Transaction ID.\r\n    /// @return Returns array of owner addresses.\r\n    function getConfirmations(\r\n        uint transactionId\r\n    ) public view returns (address[] _confirmations) {\r\n        address[] memory confirmationsTemp = new address[](owners.length);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = 0; i < owners.length; i++)\r\n            if (confirmations[transactionId][owners[i]]) {\r\n                confirmationsTemp[count] = owners[i];\r\n                count += 1;\r\n            }\r\n        _confirmations = new address[](count);\r\n        for (i = 0; i < count; i++)\r\n            _confirmations[i] = confirmationsTemp[i];\r\n    }\r\n\r\n    /// @dev Returns list of transaction IDs in defined range.\r\n    /// @param from Index start position of transaction array.\r\n    /// @param to Index end position of transaction array.\r\n    /// @param pending Include pending transactions.\r\n    /// @param executed Include executed transactions.\r\n    /// @return Returns array of transaction IDs.\r\n    function getTransactionIds(\r\n        uint from, \r\n        uint to, \r\n        bool pending, \r\n        bool executed\r\n    ) public view returns (uint[] _transactionIds) {\r\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n        uint count = 0;\r\n        uint i;\r\n        for (i = 0; i < transactionCount; i++)\r\n            if (pending && \r\n                !transactions[i].executed || \r\n                executed && \r\n                transactions[i].executed\r\n            ) {\r\n                transactionIdsTemp[count] = i;\r\n                count += 1;\r\n            }\r\n        _transactionIds = new uint[](to - from);\r\n        for (i = from; i < to; i++)\r\n            _transactionIds[i - from] = transactionIdsTemp[i];\r\n    }\r\n}\r\n\r\ncontract JavvyMultiSig is MultiSigWallet {\r\n    constructor(\r\n        address[] _owners, \r\n        uint _required\r\n    )\r\n    MultiSigWallet(_owners, _required)\r\n    public {}\r\n}\r\n\r\ncontract JavvyToken is DetailedERC20, StandardToken, Ownable, Config {\r\n    address public crowdsaleAddress;\r\n    address public bonusAddress;\r\n    address public multiSigAddress;\r\n\r\n    constructor(\r\n        string _name, \r\n        string _symbol, \r\n        uint8 _decimals\r\n    ) public\r\n    DetailedERC20(_name, _symbol, _decimals) {\r\n        require(\r\n            jvySupply == saleSupply + bonusSupply,\r\n            \"Sum of provided supplies is not equal to declared total Javvy supply. Check config!\"\r\n        );\r\n        totalSupply_ = tokenToDecimals(jvySupply);\r\n    }\r\n\r\n    function initializeBalances(\r\n        address _crowdsaleAddress,\r\n        address _bonusAddress,\r\n        address _multiSigAddress\r\n    ) public \r\n    onlyOwner() {\r\n        crowdsaleAddress = _crowdsaleAddress;\r\n        bonusAddress = _bonusAddress;\r\n        multiSigAddress = _multiSigAddress;\r\n\r\n        _initializeBalance(_crowdsaleAddress, saleSupply);\r\n        _initializeBalance(_bonusAddress, bonusSupply);\r\n    }\r\n\r\n    function _initializeBalance(address _address, uint256 _supply) private {\r\n        require(_address != address(0), \"Address cannot be equal to 0x0!\");\r\n        require(_supply != 0, \"Supply cannot be equal to 0!\");\r\n        balances[_address] = tokenToDecimals(_supply);\r\n        emit Transfer(address(0), _address, _supply);\r\n    }\r\n\r\n    function tokenToDecimals(uint256 _amount) private view returns (uint256){\r\n        // NOTE for additional accuracy, we're using 6 decimal places in supply\r\n        return _amount * (10 ** 12);\r\n    }\r\n\r\n    function getRemainingSaleTokens() external view returns (uint256) {\r\n        return balanceOf(crowdsaleAddress);\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract JavvyCrowdsale is RefundableCrowdsale, CappedCrowdsale, Pausable, Config {\r\n    uint256 public icoStartTime;\r\n    address public transminingAddress;\r\n    address public bonusAddress;\r\n    uint256 private USDETHRate;\r\n\r\n    mapping (address => bool) public blacklisted;\r\n\r\n    JavvyToken token;\r\n    \r\n    enum Stage {\r\n        NotStarted,\r\n        PreICO,\r\n        ICO,\r\n        AfterICO\r\n    }\r\n\r\n    function getStage() public view returns (Stage) {\r\n        // solium-disable-next-line security/no-block-members\r\n        uint256 blockTime = block.timestamp;\r\n        if (blockTime < openingTime) return Stage.NotStarted;\r\n        if (blockTime < icoStartTime) return Stage.PreICO;\r\n        if (blockTime < closingTime) return Stage.ICO;\r\n        else return Stage.AfterICO;\r\n    }\r\n\r\n    constructor(\r\n        uint256 _rate,  \r\n        JavvyMultiSig _wallet,\r\n        JavvyToken _token,\r\n        uint256 _cap,  // Should be in USD!\r\n        uint256 _goal,\r\n        address _bonusAddress,\r\n        address[] _blacklistAddresses,\r\n        uint256 _USDETHRate\r\n    ) \r\n    Crowdsale(_rate, _wallet, _token)\r\n    CappedCrowdsale(_cap)\r\n    TimedCrowdsale(getStartPreIco(), getEndIco())\r\n    RefundableCrowdsale(_goal)\r\n    public {\r\n        require(getStartIco() > block.timestamp, \"ICO has to begin in the future\");\r\n        require(getEndIco() > block.timestamp, \"ICO has to end in the future\");\r\n        require(_goal <= _cap, \"Soft cap should be equal or smaller than hard cap\");\r\n        icoStartTime = getStartIco();\r\n        bonusAddress = _bonusAddress;\r\n        token = _token;\r\n        for (uint256 i = 0; i < _blacklistAddresses.length; i++) {\r\n            blacklisted[_blacklistAddresses[i]] = true;\r\n        }\r\n        setUSDETHRate(_USDETHRate);\r\n    }\r\n\r\n    function buyTokens(address _beneficiary) public payable {\r\n        bool preallocated = false;\r\n        uint256 preallocatedTokens = 0;\r\n\r\n        _buyTokens(\r\n            _beneficiary, \r\n            msg.sender, \r\n            msg.value,\r\n            preallocated,\r\n            preallocatedTokens\r\n        );\r\n    }\r\n\r\n    function bulkPreallocate(address[] _owners, uint256[] _tokens, uint256[] _paid)\r\n    public\r\n    onlyOwner() {\r\n        require(\r\n            _owners.length == _tokens.length,\r\n            \"Lengths of parameter lists have to be equal\"\r\n        );\r\n        require(\r\n            _owners.length == _paid.length,\r\n            \"Lengths of parameter lists have to be equal\"\r\n        );\r\n        for (uint256 i=0; i< _owners.length; i++) {\r\n            preallocate(_owners[i], _tokens[i], _paid[i]);\r\n        }\r\n    }\r\n\r\n    function preallocate(address _owner, uint256 _tokens, uint256 _paid)\r\n    public\r\n    onlyOwner() {\r\n        require(!blacklisted[_owner], \"Address where tokens will be sent is blacklisted\");\r\n        bool preallocated = true;\r\n        uint256 preallocatedTokens = _tokens;\r\n\r\n        _buyTokens(\r\n            _owner, \r\n            _owner, \r\n            _paid,\r\n            preallocated,\r\n            preallocatedTokens\r\n        );\r\n    }\r\n\r\n    function setTransminingAddress(address _transminingAddress) public\r\n    onlyOwner() {\r\n        transminingAddress = _transminingAddress;\r\n    }\r\n\r\n    // Created for moving funds later to transmining address\r\n    function moveTokensToTransmining(uint256 _amount) public\r\n    onlyOwner() {\r\n        uint256 remainingTokens = token.getRemainingSaleTokens();\r\n        require(\r\n            transminingAddress != address(0),\r\n            \"Transmining address must be set!\"\r\n        );\r\n        require(\r\n            remainingTokens >= _amount,\r\n            \"Balance of remaining tokens for sale is smaller than requested amount for trans-mining\"\r\n        );\r\n        uint256 weiNeeded = cap - weiRaised;\r\n        uint256 tokensNeeded = weiNeeded * rate;\r\n        \r\n        if (getStage() != Stage.AfterICO){\r\n            require(remainingTokens - _amount > tokensNeeded, \"You need to leave enough tokens to reach hard cap\");\r\n        }\r\n        _deliverTokens(transminingAddress, _amount, this);\r\n    }\r\n\r\n    function _buyTokens(\r\n        address _beneficiary, \r\n        address _sender, \r\n        uint256 _value,\r\n        bool _preallocated,\r\n        uint256 _tokens\r\n    ) internal\r\n    whenNotPaused() {\r\n        require(!blacklisted[_beneficiary], \"Beneficiary is blacklisted\");\r\n        uint256 tokens;\r\n        \r\n        if (!_preallocated) {\r\n            // pre validate params\r\n            require(\r\n                _value >= minimalContributionAmount, \r\n                \"Amount contributed should be greater than required minimal contribution\"\r\n            );\r\n            require(_tokens == 0, \"Not preallocated tokens should be zero\");\r\n            _preValidatePurchase(_beneficiary, _value);\r\n        } else {\r\n            require(_tokens != 0, \"Preallocated tokens should be greater than zero\");\r\n            require(weiRaised.add(_value) <= cap, \"Raised tokens should not exceed hard cap\");\r\n        }\r\n\r\n        // calculate tokens\r\n        if (!_preallocated) {\r\n            tokens = _getTokenAmount(_value);\r\n        } else {\r\n            tokens = _tokens;\r\n        }\r\n\r\n        // increase wei\r\n        weiRaised = weiRaised.add(_value);\r\n\r\n        _processPurchase(_beneficiary, tokens, this);\r\n        \r\n        emit TokenPurchase(\r\n            _sender,\r\n            _beneficiary,\r\n            _value,\r\n            tokens\r\n        );\r\n\r\n        // transfer payment\r\n        _updatePurchasingState(_beneficiary, _value);\r\n        _forwardFunds();\r\n\r\n        // post validate\r\n        if (!_preallocated) {\r\n            _postValidatePurchase(_beneficiary, _value);\r\n        }\r\n    }\r\n\r\n    function _getBaseTokens(uint256 _value) internal view returns (uint256) {\r\n        return _value.mul(rate);\r\n    }\r\n\r\n    function _getTokenAmount(uint256 _weiAmount)\r\n    internal view returns (uint256) {\r\n        uint256 baseTokens = _getBaseTokens(_weiAmount);\r\n        if (getStage() == Stage.PreICO) {\r\n            return baseTokens.mul(100 + preIcoBonus).div(100);\r\n        } else {\r\n            return baseTokens;\r\n        }\r\n    }\r\n\r\n    function _processPurchase(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount,\r\n        address _sourceAddress\r\n    ) internal {\r\n        _deliverTokens(_beneficiary, _tokenAmount, _sourceAddress);\r\n    }\r\n\r\n    function _deliverTokens(\r\n        address _beneficiary,\r\n        uint256 _tokenAmount,\r\n        address _sourceAddress\r\n    ) internal {\r\n        if (_sourceAddress == address(this)) {\r\n            token.transfer(_beneficiary, _tokenAmount);\r\n        } else {\r\n            token.transferFrom(_sourceAddress, _beneficiary, _tokenAmount);\r\n        }\r\n    }\r\n\r\n    function finalization() internal {\r\n        require(\r\n            transminingAddress != address(0),\r\n            \"Transmining address must be set!\"\r\n        );\r\n        super.finalization();\r\n        \r\n        _deliverTokens(transminingAddress, token.getRemainingSaleTokens(), this);\r\n    }\r\n\r\n    function setUSDETHRate(uint256 _USDETHRate) public \r\n    onlyOwner(){\r\n        require(_USDETHRate > 0, \"USDETH rate should not be zero\");\r\n        USDETHRate = _USDETHRate;\r\n        cap = hardCapUSD * USDETHRate;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getStartIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"},{\"name\":\"_paid\",\"type\":\"uint256[]\"}],\"name\":\"bulkPreallocate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"},{\"name\":\"_paid\",\"type\":\"uint256\"}],\"name\":\"preallocate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimalContributionAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"moveTokensToTransmining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preIcoBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_USDETHRate\",\"type\":\"uint256\"}],\"name\":\"setUSDETHRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transminingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEndIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jvySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transminingAddress\",\"type\":\"address\"}],\"name\":\"setTransminingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCapUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_goal\",\"type\":\"uint256\"},{\"name\":\"_bonusAddress\",\"type\":\"address\"},{\"name\":\"_blacklistAddresses\",\"type\":\"address[]\"},{\"name\":\"_USDETHRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"JavvyCrowdsale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000009c4000000000000000000000000112918a54e3ada863cf694970da0756f1eecc68d0000000000000000000000000d3d475f035705a662f5ab34e374e3c44bb5218700000000000000000000000000000000000000000000152d02c7e14af680000000000000000000000000000000000000000000000000003635c9adc5dea00000000000000000000000000000ea89108712f87282b33b246defc28990029532d000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000000000000000000011c37937e08000000000000000000000000000000000000000000000000000000000000000000d0000000000000000000000004da8d73e4aa7bbc323082c3998fc706063c203260000000000000000000000008c1642b08bcdd934ee312c6438253ff09aab76650000000000000000000000008520ec632233e3d413f8dbc9f75c82e2997f87cb0000000000000000000000008fd24f1ce2e346f13f4cc91e7261bcf445fb49cd0000000000000000000000001f543f769ac192fa72799e1ed10ab1bacda33ef800000000000000000000000059d44173b0a083534c7d542731dc86c48f6a045e000000000000000000000000fa6f4c34706a36ada0d985ef7e78939cd4e81fd1000000000000000000000000d02051cdbeeeec0b285a960b2940457b24f6189200000000000000000000000031d597c414249f181947c607ea1d9dc6cc33b97800000000000000000000000016f24c3b7f1e420bd924ff05e9700a096d83cdda000000000000000000000000703157d186619f5b8f3b189f8bde6c847ccffbdc0000000000000000000000002113f8fbc3c7a0754e954d2c8edde9a9e264f557000000000000000000000000d9cd9fbce23f6feea1d974c49d164d12ae7fc9b5","Library":"","SwarmSource":"bzzr://b917c1614efb173a42981326ce81c37b6da70726da504fcb3f1d8e85a2ed2647"}]}