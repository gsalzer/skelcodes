{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract WhitepaperVersioning {\r\n    mapping (address => Whitepaper[]) private whitepapers;\r\n    mapping (address => address) private authors;\r\n    event Post(address indexed _contract, uint256 indexed _version, string _ipfsHash, address _author);\r\n\r\n    struct Whitepaper {\r\n        uint256 version;\r\n        string ipfsHash;\r\n    }\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @dev Doing nothing.\r\n     */\r\n    constructor () public {}\r\n\r\n    /**\r\n     * @dev Function to post a new whitepaper\r\n     * @param _version uint256 Version number in integer\r\n     * @param _ipfsHash string IPFS hash of the posting whitepaper\r\n     * @return status bool\r\n     */\r\n    function pushWhitepaper (Ownable _contract, uint256 _version, string _ipfsHash) public returns (bool) {\r\n        uint256 num = whitepapers[_contract].length;\r\n        if(num == 0){\r\n            // If the posting whitepaper is the initial, only the target contract owner can post.\r\n            require(_contract.owner() == msg.sender);\r\n            authors[_contract] = msg.sender;\r\n        }else{\r\n            // Check if the initial version whitepaper's author is the msg.sender\r\n            require(authors[_contract] == msg.sender);\r\n            // Check if the version is greater than the previous version\r\n            require(whitepapers[_contract][num-1].version < _version);\r\n        }\r\n    \r\n        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));\r\n        emit Post(_contract, _version, _ipfsHash, msg.sender);\r\n        return true;\r\n    }\r\n  \r\n    /**\r\n     * @dev Look up whitepaper at the specified index\r\n     * @param _contract address Target contract address associated with a whitepaper\r\n     * @param _index uint256 Index number of whitepapers associated with the specified contract address\r\n     * @return version uint8 Version number in integer\r\n     * @return ipfsHash string IPFS hash of the whitepaper\r\n     * @return author address Address of an account who posted the whitepaper\r\n     */\r\n    function getWhitepaperAt (address _contract, uint256 _index) public view returns (\r\n        uint256 version,\r\n        string ipfsHash,\r\n        address author\r\n    ) {\r\n        return (\r\n            whitepapers[_contract][_index].version,\r\n            whitepapers[_contract][_index].ipfsHash,\r\n            authors[_contract]\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * @dev Look up whitepaper at the specified index\r\n     * @param _contract address Target contract address associated with a whitepaper\r\n     * @return version uint8 Version number in integer\r\n     * @return ipfsHash string IPFS hash of the whitepaper\r\n     * @return author address Address of an account who posted the whitepaper\r\n     */\r\n    function getLatestWhitepaper (address _contract) public view returns (\r\n        uint256 version,\r\n        string ipfsHash,\r\n        address author\r\n    ) {\r\n        uint256 latest = whitepapers[_contract].length - 1;\r\n        return getWhitepaperAt(_contract, latest);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_version\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"string\"}],\"name\":\"pushWhitepaper\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"}],\"name\":\"getLatestWhitepaper\",\"outputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"ipfsHash\",\"type\":\"string\"},{\"name\":\"author\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getWhitepaperAt\",\"outputs\":[{\"name\":\"version\",\"type\":\"uint256\"},{\"name\":\"ipfsHash\",\"type\":\"string\"},{\"name\":\"author\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ipfsHash\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_author\",\"type\":\"address\"}],\"name\":\"Post\",\"type\":\"event\"}]","ContractName":"WhitepaperVersioning","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e2c82261574f539c936bc8bec9a90781cd895c3ba5a0f7d5f83c66c763efe816"}]}