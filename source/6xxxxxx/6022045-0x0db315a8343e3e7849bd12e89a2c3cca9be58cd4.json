{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary F3DKeysCalcLong {\r\n    using SafeMath for *;\r\n\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\nlibrary NameFilter {\r\n\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\nlibrary F3Ddatasets {\r\n    //compressedData key\r\n    // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0]\r\n        // 0 - new player (bool)\r\n        // 1 - joined round (bool)\r\n        // 2 - new  leader (bool)\r\n        // 3-5 - air drop tracker (uint 0-999)\r\n        // 6-16 - round end time\r\n        // 17 - winnerTeam\r\n        // 18 - 28 timestamp \r\n        // 29 - team\r\n        // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico)\r\n        // 31 - airdrop happened bool\r\n        // 32 - airdrop tier \r\n        // 33 - airdrop amount won\r\n    //compressedIDs key\r\n    // [77-52][51-26][25-0]\r\n        // 0-25 - pID \r\n        // 26-51 - winPID\r\n        // 52-77 - rID\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 P3DAmount;          // amount distributed to p3d\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask \r\n        uint256 ico;    // ICO phase investment\r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 team;   // tID of team in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 ico;    // total eth sent in during ICO phase\r\n        uint256 icoGen; // total eth for gen during ICO phase\r\n        uint256 icoAvg; // average key price for ICO phase\r\n    }\r\n    struct TeamFee {\r\n        uint256 gen;    // % of buy in thats paid to key holders of current round\r\n        uint256 p3d;    // % of buy in thats paid to p3d holders\r\n    }\r\n    struct PotSplit {\r\n        uint256 gen;    // % of pot thats paid to key holders of current round\r\n        uint256 p3d;    // % of pot thats paid to p3d holders\r\n    }\r\n}\r\n\r\ncontract F3Devents {\r\n\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onEndTx\r\n    (\r\n        uint256 compressedData,     \r\n        uint256 compressedIDs,      \r\n        bytes32 playerName,\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount,\r\n        uint256 potAmount,\r\n        uint256 airDropPot\r\n    );\r\n\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onWithdrawAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onBuyAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethIn,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 P3DAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onPotSwapDeposit\r\n    (\r\n        uint256 roundID,\r\n        uint256 amountAddedToPot\r\n    );\r\n}\r\n\r\ncontract SuperFoMo3D is F3Devents {\r\n    using SafeMath for uint;\r\n    using NameFilter for string;\r\n    using F3DKeysCalcLong for uint256;\r\n    \r\n    string constant public name = \"SuperFoMo3D\";\r\n    string constant public symbol = \"SuperF3D\";\r\n    uint256 public airDropPot_;             \r\n    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.\r\n    uint256 public rID_;    // round id number / total rounds that have happened\r\n    address actor = 0x0;\r\n    bool public activated = false;\r\n    \r\n    mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping (uint256 => F3Ddatasets.Player) public plyr_;   // (pID => data) player data\r\n    mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;    // player round data by player id & round id\r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.\r\n    mapping (address => uint256) customerBalance;           // customer balance data\r\n    \r\n    mapping (uint256 => F3Ddatasets.Round) public round_;   // (rID => data) round data\r\n    mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // eth in per team, by round id and team id\r\n    \r\n    mapping (uint256 => F3Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team\r\n    mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team\r\n    \r\n    DiviesInterface constant private Divies = DiviesInterface(0xc7029Ed9EBa97A096e72607f4340c34049C7AF48);\r\n    JIincForwarderInterface constant private Jekyll_Island_Inc = JIincForwarderInterface(0xdd4950F977EE28D2C132f1353D1595035Db444EE);\r\n\tPlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xD60d353610D9a5Ca478769D371b53CEfAA7B6E4c);\r\n    F3DexternalSettingsInterface constant private extSettings = F3DexternalSettingsInterface(0x32967D6c142c2F38AB39235994e2DDF11c37d590);\r\n    \r\n    //==========================================================================\r\n    //  Modifier\r\n    //==========================================================================\r\n    modifier isActor\r\n    {\r\n        require(msg.sender == actor,'do not have permission');\r\n        _;\r\n    }\r\n    \r\n    modifier isActivated {\r\n        require(activated == true, \"F3DPlus is not activated yet\"); \r\n        _;\r\n    }\r\n    \r\n    modifier isInLimits(uint256 _value)\r\n    {\r\n        require(_value >= 1000000000,'value too low');\r\n        require(_value <= 100000000000000000000000,'over the maximum limit');\r\n        _;\r\n    }\r\n    \r\n    modifier isEther\r\n    {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"ether only\");\r\n        _;\r\n    }\r\n    //==========================================================================\r\n    //  Methods\r\n    //==========================================================================\r\n    \r\n    constructor()\r\n        public\r\n    {\r\n        actor = msg.sender;\r\n    }\r\n    \r\n    function activate()\r\n        public\r\n        isActor\r\n        isEther\r\n    {\r\n        require(activated == false,'is already activated');\r\n        activated = true;\r\n    }\r\n    \r\n    function deactivated()\r\n        public\r\n        isActor\r\n        isEther\r\n        isActivated\r\n    {\r\n        activated = false;\r\n    }\r\n    \r\n    function deposit() \r\n        payable\r\n        public\r\n        isEther\r\n        isInLimits(msg.value)\r\n        returns (uint256 balance)\r\n    {\r\n        customerBalance[msg.sender] = customerBalance[msg.sender].add(msg.value);\r\n        return customerBalance[msg.sender];\r\n    }\r\n    \r\n    function withdraw(uint256 _value)\r\n        public\r\n        isEther\r\n        isInLimits(_value)\r\n        returns(uint256)\r\n    {\r\n        require(customerBalance[msg.sender] >= _value,'please ensure you have enough balance');\r\n        msg.sender.transfer(_value);\r\n        customerBalance[msg.sender] = customerBalance[msg.sender].sub(_value);\r\n        return customerBalance[msg.sender];\r\n    }\r\n    \r\n    function withdrawEarnings(uint256 _pID)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        // from vaults \r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0)\r\n        {\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n    \r\n    //get the total balance of this contract\r\n    function getTotalBalance()\r\n        public\r\n        constant returns (uint)\r\n    {\r\n        return address(this).balance;\r\n    }\r\n        \r\n    //get the balance of customer\r\n    function getCustomerBalance(address _addr)\r\n        public\r\n        constant returns (uint)\r\n    {\r\n        return customerBalance[_addr];\r\n    }\r\n        \r\n    function potSwap()\r\n        public\r\n        isActivated\r\n        payable\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_ + 1;\r\n        \r\n        round_[_rID].pot = round_[_rID].pot.add(msg.value);\r\n        emit F3Devents.onPotSwapDeposit(_rID, msg.value);\r\n    }\r\n    \r\n    function registerName(string _nameString, address _affCode, bool _all)\r\n        isActivated\r\n        isEther\r\n        public\r\n        payable\r\n    {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        // fire event\r\n        emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now);\r\n    }\r\n    \r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        isActivated\r\n        returns(F3Ddatasets.EventReturns)\r\n    {\r\n        uint256 _com = _eth / 50;\r\n        uint256 _p3d;\r\n        if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))\r\n        {\r\n            _p3d = _com;\r\n            _com = 0;\r\n        }\r\n        uint256 _aff = _eth / 10;\r\n        if (_affID != _pID && plyr_[_affID].name != '') {\r\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\r\n            emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now);\r\n        } else {\r\n            _p3d = _aff;\r\n        }\r\n        \r\n        _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100));\r\n        if (_p3d > 0)\r\n        {\r\n            // set up event data\r\n            _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount);\r\n        }\r\n        \r\n        return(_eventData_);\r\n    }\r\n        \r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        isActivated\r\n        returns(F3Ddatasets.EventReturns)\r\n    {\r\n        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;\r\n\r\n        uint256 _air = (_eth / 100);\r\n        airDropPot_ = airDropPot_.add(_air);\r\n        \r\n        // update eth balance (eth = eth - (com share + pot swap share + aff share + p3d share + airdrop pot share))\r\n        _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100));\r\n\r\n        uint256 _pot = _eth.sub(_gen);\r\n\r\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n\r\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\r\n\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys)\r\n        private\r\n        isActivated\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\r\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\r\n\r\n        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\r\n    }\r\n    \r\n    function endRound(F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        isActivated\r\n        returns (F3Ddatasets.EventReturns)\r\n    {\r\n        // setup local rID\r\n        uint256 _rID = rID_;\r\n        \r\n        // grab our winning player and team id's\r\n        uint256 _winPID = round_[_rID].plyr;\r\n        uint256 _winTID = round_[_rID].team;\r\n        \r\n        // grab our pot amount\r\n        uint256 _pot = round_[_rID].pot;\r\n        \r\n        // calculate our winner share, community rewards, gen share, \r\n        // p3d share, and amount reserved for next pot \r\n        uint256 _win = (_pot.mul(48)) / 100;\r\n        uint256 _com = (_pot / 50);\r\n        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\r\n        uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100;\r\n        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d);\r\n        \r\n        // calculate ppt for round mask\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\r\n        if (_dust > 0)\r\n        {\r\n            _gen = _gen.sub(_dust);\r\n            _res = _res.add(_dust);\r\n        }\r\n        \r\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\r\n        \r\n        // community rewards\r\n        if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\"))))\r\n        {\r\n            _p3d = _p3d.add(_com);\r\n            _com = 0;\r\n        }\r\n        \r\n        // distribute gen portion to key holders\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n            \r\n        // prepare event data\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.winnerName = plyr_[_winPID].name;\r\n        _eventData_.amountWon = _win;\r\n        _eventData_.genAmount = _gen;\r\n        _eventData_.P3DAmount = _p3d;\r\n        _eventData_.newPot = _res;\r\n        \r\n        // start next round\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].pot = _res;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    function determinePID(F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        returns (F3Ddatasets.EventReturns)\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        // if player is new to this version of fomo3d\r\n        if (_pID == 0)\r\n        {\r\n            // grab their player ID, name and last aff ID, from player names contract \r\n            _pID = PlayerBook.getPlayerID(msg.sender);\r\n            bytes32 _name = PlayerBook.getPlayerName(_pID);\r\n            uint256 _laff = PlayerBook.getPlayerLAff(_pID);\r\n            \r\n            // set up player account \r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n            \r\n            if (_name != \"\")\r\n            {\r\n                pIDxName_[_name] = _pID;\r\n                plyr_[_pID].name = _name;\r\n                plyrNames_[_pID][_name] = true;\r\n            }\r\n            \r\n            if (_laff != 0 && _laff != _pID)\r\n                plyr_[_pID].laff = _laff;\r\n            \r\n            // set the new player bool to true\r\n            _eventData_.compressedData = _eventData_.compressedData + 1;\r\n        } \r\n        return (_eventData_);\r\n    }\r\n    \r\n    function sendBonus(address _addr,uint256 _bonus)\r\n        public\r\n        isActor\r\n        isEther\r\n        isInLimits(_bonus)\r\n        returns (bool)\r\n    {\r\n        //must have enough balance \r\n        require(address(this).balance >= _bonus,'out of balance');\r\n        _addr.transfer(_bonus);\r\n        \r\n        return true;\r\n    }\r\n    \r\n    function getKeys(uint256 _keys)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        \r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n    \r\n    function verifyTeam(uint256 _team)\r\n        private\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (_team < 0 || _team > 3)\r\n            return(2);\r\n        else\r\n            return(_team);\r\n    }\r\n    \r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );\r\n    }\r\n    \r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast)\r\n        private\r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in gen vault\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\r\n        }\r\n    }\r\n    \r\n    function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_)\r\n        private\r\n        isActor\r\n        returns (F3Ddatasets.EventReturns)\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd);\r\n            \r\n        // update player's last round played\r\n        plyr_[_pID].lrnd = rID_;\r\n            \r\n        // set the joined round bool to true\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n        \r\n        return(_eventData_);\r\n    }\r\n    \r\n    function()\r\n        public\r\n        payable\r\n    {\r\n        revert('do not send eth directly');\r\n    }\r\n    \r\n}\r\n\r\ninterface F3DexternalSettingsInterface {\r\n    function getFastGap() external returns(uint256);\r\n    function getLongGap() external returns(uint256);\r\n    function getFastExtra() external returns(uint256);\r\n    function getLongExtra() external returns(uint256);\r\n}\r\n\r\ninterface DiviesInterface {\r\n    function deposit() external payable;\r\n}\r\n\r\ninterface JIincForwarderInterface {\r\n    function deposit() external payable returns(bool);\r\n    function status() external view returns(address, address, bool);\r\n    function startMigration(address _newCorpBank) external returns(bool);\r\n    function cancelMigration() external returns(bool);\r\n    function finishMigration() external returns(bool);\r\n    function setup(address _firstCorpBank) external;\r\n}\r\n\r\ninterface PlayerBookInterface {\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"},{\"name\":\"icoGen\",\"type\":\"uint256\"},{\"name\":\"icoAvg\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fees_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"p3d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deactivated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndTmEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_bonus\",\"type\":\"uint256\"}],\"name\":\"sendBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"getKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getCustomerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potSplit_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"p3d\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"potSwap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"airDropPot\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"P3DAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountAddedToPot\",\"type\":\"uint256\"}],\"name\":\"onPotSwapDeposit\",\"type\":\"event\"}]","ContractName":"SuperFoMo3D","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6bcfeb91979b9fecf23506dfb7e0724b63015ee3e983c15d3cbb1e4d39609341"}]}