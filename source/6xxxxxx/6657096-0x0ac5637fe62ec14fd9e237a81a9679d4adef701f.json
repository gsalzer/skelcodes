{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n/******************************************************************************\\\r\n* Author: Nick Mudge, nick@mokens.io\r\n* Copyright (c) 2018\r\n* Mokens\r\n*\r\n* The MokenUpdates contract adds/updates/removes functions. This is how the\r\n* Mokens contract is updated\r\n*\r\n* Function changes emit the FunctionUpdate and CommitMessage events.\r\n* Monitor changes to the Mokens contract by watching/filtering the\r\n* FunctionUpdate and CommitMessage events.\r\n*\r\n* Functions and delegate contracts can be queried by using functions from the\r\n* QueryMokenDelegates contract.\r\n/******************************************************************************/\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Storage contracts\r\n////////////\r\n//Some delegate contracts are listed with storage contracts they inherit.\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Mokens\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage0 {\r\n    // funcId => delegate contract\r\n    mapping(bytes4 => address) internal delegates;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenUpdates\r\n//MokenOwner\r\n//QueryMokenDelegates\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage1 is Storage0 {\r\n    address internal contractOwner;\r\n    bytes[] internal funcSignatures;\r\n    // signature => index+1\r\n    mapping(bytes => uint256) internal funcSignatureToIndex;\r\n}\r\n\r\ninterface ERC1538 {\r\n    event CommitMessage(string message);\r\n    event FunctionUpdate(bytes4 indexed functionId, address indexed oldDelegate, address indexed newDelegate, string functionSignature);\r\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external;\r\n}\r\n\r\ncontract MokenUpdates is Storage1, ERC1538 {\r\n\r\n    function updateContract(address _delegate, string _functionSignatures, string commitMessage) external {\r\n        require(msg.sender == contractOwner, \"Must own the contract.\");\r\n        // pos is first used to check the size of the delegate contract.\r\n        // After that pos is the current memory location of _functionSignatures.\r\n        // It is used to move through the characters of _functionSignatures\r\n        uint256 pos;\r\n        if(_delegate != address(0)) {\r\n            assembly {\r\n                pos := extcodesize(_delegate)\r\n            }\r\n            require(pos > 0, \"_delegate address is not a contract and is not address(0)\");\r\n        }\r\n        // creates a bytes vesion of _functionSignatures\r\n        bytes memory signatures = bytes(_functionSignatures);\r\n        // stores the position in memory where _functionSignatures ends.\r\n        uint256 signaturesEnd;\r\n        // stores the starting position of a function signature in _functionSignatures\r\n        uint256 start;\r\n        assembly {\r\n            pos := add(signatures,32)\r\n            start := pos\r\n            signaturesEnd := add(pos,mload(signatures))\r\n        }\r\n        // the function id of the current function signature\r\n        bytes4 funcId;\r\n        // the delegate address that is being replaced or address(0) if removing functions\r\n        address oldDelegate;\r\n        // the length of the current function signature in _functionSignatures\r\n        uint256 num;\r\n        // the current character in _functionSignatures\r\n        uint256 char;\r\n        // the position of the current function signature in the funcSignatures array\r\n        uint256 index;\r\n        // the last position in the funcSignatures array\r\n        uint256 lastIndex;\r\n        // parse the _functionSignatures string and handle each function\r\n        for (; pos < signaturesEnd; pos++) {\r\n            assembly {char := byte(0,mload(pos))}\r\n            // 0x29 == )\r\n            if (char == 0x29) {\r\n                pos++;\r\n                num = (pos - start);\r\n                start = pos;\r\n                assembly {\r\n                    mstore(signatures,num)\r\n                }\r\n                funcId = bytes4(keccak256(signatures));\r\n                oldDelegate = delegates[funcId];\r\n                if(_delegate == address(0)) {\r\n                    index = funcSignatureToIndex[signatures];\r\n                    require(index != 0, \"Function does not exist.\");\r\n                    index--;\r\n                    lastIndex = funcSignatures.length - 1;\r\n                    if (index != lastIndex) {\r\n                        funcSignatures[index] = funcSignatures[lastIndex];\r\n                        funcSignatureToIndex[funcSignatures[lastIndex]] = index + 1;\r\n                    }\r\n                    funcSignatures.length--;\r\n                    delete funcSignatureToIndex[signatures];\r\n                    delete delegates[funcId];\r\n                    emit FunctionUpdate(funcId, oldDelegate, address(0), string(signatures));\r\n                }\r\n                else if (funcSignatureToIndex[signatures] == 0) {\r\n                    require(oldDelegate == address(0), \"FuncId clash.\");\r\n                    delegates[funcId] = _delegate;\r\n                    funcSignatures.push(signatures);\r\n                    funcSignatureToIndex[signatures] = funcSignatures.length;\r\n                    emit FunctionUpdate(funcId, address(0), _delegate, string(signatures));\r\n                }\r\n                else if (delegates[funcId] != _delegate) {\r\n                    delegates[funcId] = _delegate;\r\n                    emit FunctionUpdate(funcId, oldDelegate, _delegate, string(signatures));\r\n\r\n                }\r\n                assembly {signatures := add(signatures,num)}\r\n            }\r\n        }\r\n        emit CommitMessage(commitMessage);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_functionSignatures\",\"type\":\"string\"},{\"name\":\"commitMessage\",\"type\":\"string\"}],\"name\":\"updateContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"CommitMessage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"functionId\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"oldDelegate\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newDelegate\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"functionSignature\",\"type\":\"string\"}],\"name\":\"FunctionUpdate\",\"type\":\"event\"}]","ContractName":"MokenUpdates","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5764ad43155598fb4d7c7b0aafb22f610d5d0d26744821909f0b24b42898df02"}]}