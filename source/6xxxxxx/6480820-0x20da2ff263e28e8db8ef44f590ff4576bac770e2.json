{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface MilAuthInterface {\r\n    function requiredSignatures() external view returns(uint256);\r\n    function requiredDevSignatures() external view returns(uint256);\r\n    function adminCount() external view returns(uint256);\r\n    function devCount() external view returns(uint256);\r\n    function adminName(address _who) external view returns(bytes32);\r\n    function isAdmin(address _who) external view returns(bool);\r\n    function isDev(address _who) external view returns(bool);\r\n    function checkGameRegiester(address _gameAddr) external view returns(bool);\r\n    function checkGameClosed(address _gameAddr) external view returns(bool);\r\n}\r\ninterface MillionaireInterface {\r\n    function invest(address _addr, uint256 _affID, uint256 _mfCoin, uint256 _general) external payable;\r\n    function updateGenVaultAndMask(address _addr, uint256 _affID) external payable;\r\n    function clearGenVaultAndMask(address _addr, uint256 _affID, uint256 _eth, uint256 _milFee) external;\r\n    function assign(address _addr) external payable;\r\n    function splitPot() external payable;   \r\n}\r\ninterface MilFoldInterface {\r\n    function addPot() external payable;\r\n    function activate() external;    \r\n}\r\n\r\ncontract Milevents {\r\n\r\n    // fired whenever a player registers\r\n    event onNewPlayer\r\n    (\r\n        address indexed playerAddress,\r\n        uint256 playerID,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    // fired at end of buy or reload\r\n    event onEndTx\r\n    (\r\n        uint256 rid,                    //current round id\r\n        address indexed buyerAddress,   //buyer address\r\n        uint256 compressData,           //action << 96 | time << 64 | drawCode << 32 | txAction << 8 | roundState\r\n        uint256 eth,                    //buy amount\r\n        uint256 totalPot,               //current total pot\r\n        uint256 tickets,                //buy tickets\r\n        uint256 timeStamp               //buy time\r\n    );\r\n\r\n    // fired at end of buy or reload\r\n    event onGameClose\r\n    (\r\n        address indexed gameAddr,       //game address\r\n        uint256 amount,                 //split eth amount\r\n        uint256 timeStamp               //close time\r\n    );\r\n\r\n    // fired at time who satisfy the reward condition\r\n    event onReward\r\n    (\r\n        address indexed         rewardAddr,     //reward address\r\n        Mildatasets.RewardType  rewardType,     //rewardType\r\n        uint256 amount                          //reward amount\r\n    );\r\n\r\n\t// fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        address indexed playerAddress,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onAffiliatePayout\r\n    (\r\n        address indexed affiliateAddress,\r\n        address indexed buyerAddress,\r\n        uint256 eth,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    // fired at every ico\r\n    event onICO\r\n    (\r\n        address indexed buyerAddress,   //user address who buy ico\r\n        uint256 buyAmount,              //buy ico amount\r\n        uint256 buyMf,                  //eth exchange mfcoin amount\r\n        uint256 totalIco,               //now total ico amount\r\n        bool    ended                   //is ico ended\r\n    );\r\n\r\n    // fired whenever an player win the playround\r\n    event onPlayerWin(\r\n        address indexed addr,\r\n        uint256 roundID,\r\n        uint256 winAmount,\r\n        uint256 winNums\r\n    );\r\n\r\n    event onClaimWinner(\r\n        address indexed addr,\r\n        uint256 winnerNum,\r\n        uint256 totalNum\r\n    );\r\n\r\n    event onBuyMFCoins(\r\n        address indexed addr,\r\n        uint256 ethAmount,\r\n        uint256 mfAmount,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onSellMFCoins(\r\n        address indexed addr,\r\n        uint256 ethAmount,\r\n        uint256 mfAmount,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    event onUpdateGenVault(\r\n        address indexed addr,\r\n        uint256 mfAmount,\r\n        uint256 genAmount,\r\n        uint256 ethAmount\r\n    );\r\n}\r\n\r\ncontract MilFold is MilFoldInterface,Milevents {\r\n    using SafeMath for *;\r\n\r\n//==============================================================================\r\n//     _ _  _  |`. _     _ _ |_ | _  _  .\r\n//    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings)\r\n//=================_|===========================================================\r\n    uint256     constant private    rndMax_ = 90000;                                        // max length a round timer can be\r\n    uint256     constant private    claimMax_ = 43200;                                      // max limitation period to claim winned\r\n    address     constant private    fundAddr_ = 0xB0c7Dc00E8A74c9dEc8688EFb98CcB2e24584E3B; // foundation address\r\n    uint256     constant private    MIN_ETH_BUYIN = 0.002 ether;                            // min buy amount\r\n    uint256     constant private    COMMON_REWARD_AMOUNT = 0.01 ether;                      // reward who end round or draw the game\r\n    uint256     constant private    CLAIM_WINNER_REWARD_AMOUNT = 1 ether;                   // reward who claim an winner\r\n    uint256     constant private    MAX_WIN_AMOUNT = 5000 ether;                            // max win amount every round;\r\n\r\n    uint256     private             rID_;                                                   // current round;\r\n    uint256     private             lID_;                                                   // last round;\r\n    uint256     private             lBlockNumber_;                                          // last round end block number;\r\n    bool        private             activated_;                                             // mark contract is activated;\r\n    \r\n    MillionaireInterface constant private millionaire_ = MillionaireInterface(0x98BDbc858822415C626c13267594fbC205182A1F);\r\n    MilAuthInterface constant private milAuth_ = MilAuthInterface(0xf856f6a413f7756FfaF423aa2101b37E2B3aFFD9);\r\n\r\n    mapping (address => uint256) private playerTickets_;                                    // (addr => tickets) returns player tickets\r\n    mapping (uint256 => Mildatasets.Round) private round_;                                  // (rID => data) returns round data\r\n    mapping (uint256 => mapping(address => uint256[])) private playerTicketNumbers_;        // (rID => address => data) returns round data\r\n    mapping (address => uint256) private playerWinTotal_;                                   // (addr => eth) returns total winning eth\r\n\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================\r\n    /**\r\n     * @dev used to make sure no one can interact with contract until it has\r\n     * been activated.\r\n     */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"it's not ready yet\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting with milfold,except constructor\r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= MIN_ETH_BUYIN, \"can't be less anymore\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev check sender must be devs\r\n     */\r\n    modifier onlyDevs()\r\n    {\r\n        require(milAuth_.isDev(msg.sender) == true, \"msg sender is not a dev\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev used to make sure the paid is sufficient to buy tickets.\r\n     * @param _eth the eth you want pay for\r\n     * @param _num the numbers you want to buy\r\n     */\r\n    modifier inSufficient(uint256 _eth, uint256[] _num) {\r\n        uint256 totalTickets = _num.length;\r\n        require(_eth >= totalTickets.mul(500)/1 ether, \"insufficient to buy the very tickets\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev used to make sure the paid is sufficient to buy tickets.\r\n     * @param _eth the eth you want pay for\r\n     * @param _startNums the start numbers you want to buy\r\n     * @param _endNums the end numbers you want to to buy\r\n     */\r\n    modifier inSufficient2(uint256 _eth, uint256[] _startNums, uint256[] _endNums) {\r\n        uint256 totalTickets = calcSectionTickets(_startNums, _endNums);\r\n        require(_eth >= totalTickets.mul(500)/1 ether, \"insufficient to buy the very tickets\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev deposit to contract\r\n     */\r\n    function() public isActivated() payable {\r\n        addPot();\r\n    }\r\n\r\n    /**\r\n     * @dev buy tickets with pay eth\r\n     * @param _affID the id of the player who gets the affiliate fee\r\n     */\r\n    function buyTickets(uint256 _affID)\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        payable\r\n    {\r\n        uint256 compressData = checkRoundAndDraw(msg.sender);\r\n        buyCore(msg.sender, _affID, msg.value);\r\n\r\n        emit onEndTx(\r\n            rID_,\r\n            msg.sender,\r\n            compressData,\r\n            msg.value,\r\n            round_[rID_].pot,\r\n            playerTickets_[msg.sender],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev direct buy nums with pay eth in express way\r\n     * @param _affID the id of the player who gets the affiliate fee\r\n     * @param _nums which nums you buy, less than 10\r\n     */\r\n    function expressBuyNums(uint256 _affID, uint256[] _nums)\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        inSufficient(msg.value, _nums)\r\n        payable\r\n    {\r\n        uint256 compressData = checkRoundAndDraw(msg.sender);\r\n        buyCore(msg.sender, _affID, msg.value);\r\n        convertCore(msg.sender, _nums.length, TicketCompressor.encode(_nums));\r\n\r\n        emit onEndTx(\r\n            rID_,\r\n            msg.sender,\r\n            compressData,\r\n            msg.value,\r\n            round_[rID_].pot,\r\n            playerTickets_[msg.sender],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev direct buy section nums with pay eth in express way\r\n     * @param _affID the id of the player who gets the affiliate fee\r\n     * @param _startNums  section nums,start\r\n     * @param _endNums section nums,end\r\n     */\r\n    function expressBuyNumSec(uint256 _affID, uint256[] _startNums, uint256[] _endNums)\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        inSufficient2(msg.value, _startNums, _endNums)\r\n        payable\r\n    {\r\n        uint256 compressData = checkRoundAndDraw(msg.sender);\r\n        buyCore(msg.sender, _affID, msg.value);\r\n        convertCore(\r\n            msg.sender,\r\n            calcSectionTickets(_startNums, _endNums),\r\n            TicketCompressor.encode(_startNums, _endNums)\r\n        );\r\n\r\n        emit onEndTx(\r\n            rID_,\r\n            msg.sender,\r\n            compressData,\r\n            msg.value,\r\n            round_[rID_].pot,\r\n            playerTickets_[msg.sender],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev buy tickets with use your vaults\r\n     * @param _affID the id of the player who gets the affiliate fee\r\n     * @param _eth the vaults you want pay for\r\n     */\r\n    function reloadTickets(uint256 _affID, uint256 _eth)\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n    {\r\n        uint256 compressData = checkRoundAndDraw(msg.sender);\r\n        reloadCore(msg.sender, _affID, _eth);\r\n\r\n        emit onEndTx(\r\n            rID_,\r\n            msg.sender,\r\n            compressData,\r\n            _eth,\r\n            round_[rID_].pot,\r\n            playerTickets_[msg.sender],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev direct buy nums with use your vaults in express way\r\n     * @param _affID the id of the player who gets the affiliate fee\r\n     * @param _eth the vaults you want pay for\r\n     * @param _nums which nums you buy, no more than 10\r\n     */\r\n    function expressReloadNums(uint256 _affID, uint256 _eth, uint256[] _nums)\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        inSufficient(_eth, _nums)\r\n    {\r\n        uint256 compressData = checkRoundAndDraw(msg.sender);\r\n        reloadCore(msg.sender, _affID, _eth);\r\n        convertCore(msg.sender, _nums.length, TicketCompressor.encode(_nums));\r\n\r\n        emit onEndTx(\r\n            rID_,\r\n            msg.sender,\r\n            compressData,\r\n            _eth,\r\n            round_[rID_].pot,\r\n            playerTickets_[msg.sender],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev direct buy section nums with use your vaults in express way\r\n     * @param _affID the id of the player who gets the affiliate fee\r\n     * @param _eth the vaults you want pay for\r\n     * @param _startNums  section nums, start\r\n     * @param _endNums section nums, end\r\n     */\r\n    function expressReloadNumSec(uint256 _affID, uint256 _eth, uint256[] _startNums, uint256[] _endNums)\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(_eth)\r\n        inSufficient2(_eth, _startNums, _endNums)\r\n    {\r\n        uint256 compressData = checkRoundAndDraw(msg.sender);\r\n        reloadCore(msg.sender, _affID, _eth);\r\n        convertCore(msg.sender, calcSectionTickets(_startNums, _endNums), TicketCompressor.encode(_startNums, _endNums));\r\n\r\n        emit onEndTx(\r\n            rID_,\r\n            msg.sender,\r\n            compressData,\r\n            _eth,\r\n            round_[rID_].pot,\r\n            playerTickets_[msg.sender],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev convert to nums with you consume tickets\r\n     * @param nums which nums you buy, no more than 10\r\n     */\r\n    function convertNums(uint256[] nums) public {\r\n        uint256 compressData = checkRoundAndDraw(msg.sender);\r\n        convertCore(msg.sender, nums.length, TicketCompressor.encode(nums));\r\n\r\n        emit onEndTx(\r\n            rID_,\r\n            msg.sender,\r\n            compressData,\r\n            0,\r\n            round_[rID_].pot,\r\n            playerTickets_[msg.sender],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev convert to section nums with you consume tickets\r\n     * @param startNums  section nums, start\r\n     * @param endNums section nums, end\r\n     */\r\n    function convertNumSec(uint256[] startNums, uint256[] endNums) public {\r\n        uint256 compressData = checkRoundAndDraw(msg.sender);\r\n        convertCore(msg.sender, calcSectionTickets(startNums, endNums), TicketCompressor.encode(startNums, endNums));\r\n\r\n        emit onEndTx(\r\n            rID_,\r\n            msg.sender,\r\n            compressData,\r\n            0,\r\n            round_[rID_].pot,\r\n            playerTickets_[msg.sender],\r\n            block.timestamp\r\n        );\r\n    }\r\n\r\n    function buyCore(address _addr, uint256 _affID, uint256 _eth)\r\n        private\r\n    {\r\n        /**\r\n         * 2% transfer to foundation\r\n         * 18% transfer to pot\r\n         * 80% transfer to millionaire, 50% use to convert MFCoin and 30% use to genAndAff\r\n         */\r\n        // 1 ticket = 0.002 eth, i.e., tickets = eth * 500\r\n        playerTickets_[_addr] = playerTickets_[_addr].add(_eth.mul(500)/1 ether);\r\n\r\n        // transfer 2% to foundation\r\n        uint256 foundFee = _eth.div(50);\r\n        fundAddr_.transfer(foundFee);\r\n\r\n        // transfer 80%(50% use to convert MFCoin and 30% use to genAndAff) amount to millionaire\r\n        uint256 milFee = _eth.mul(80).div(100);\r\n\r\n        millionaire_.updateGenVaultAndMask.value(milFee)(_addr, _affID);\r\n\r\n        round_[rID_].pot = round_[rID_].pot.add(_eth.sub(milFee).sub(foundFee));\r\n    }\r\n\r\n    function reloadCore(address _addr, uint256 _affID, uint256 _eth)\r\n        private\r\n    {\r\n        /**\r\n         * 2% transfer to foundation\r\n         * 18% transfer to pot\r\n         * 80% transfer to millionaire, 50% use to convert MFCoin and 30% use to genAndAff\r\n         */\r\n        // transfer 80%(50% use to convert MFCoin and 30% use to genAndAff) amount to millionaire\r\n        uint256 milFee = _eth.mul(80).div(100);\r\n        \r\n        millionaire_.clearGenVaultAndMask(_addr, _affID, _eth, milFee);\r\n\r\n        // 1 ticket = 0.002 eth, i.e., tickets = eth * 500\r\n        playerTickets_[_addr] = playerTickets_[_addr].add(_eth.mul(500)/1 ether);\r\n\r\n        // transfer 2% to foundation\r\n        uint256 foundFee = _eth.div(50);\r\n        fundAddr_.transfer(foundFee);\r\n        \r\n        //game pot will add in default function\r\n        //round_[rID_].pot = round_[rID_].pot.add(_eth.sub(milFee).sub(foundFee));\r\n    }\r\n\r\n    function convertCore(address _addr, uint256 length, uint256 compressNumber)\r\n        private\r\n    {\r\n        playerTickets_[_addr] = playerTickets_[_addr].sub(length);\r\n        uint256[] storage plyTicNums = playerTicketNumbers_[rID_][_addr];\r\n        plyTicNums.push(compressNumber);\r\n    }\r\n\r\n    // in order to draw the MilFold, we have to do all as following\r\n    // 1. end current round\r\n    // 2. calculate the draw-code\r\n    // 3. claim winned\r\n    // 4. assign to foundation, winners, and migrate the rest to the next round\r\n\r\n    function checkRoundAndDraw(address _addr)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        if (lID_ > 0\r\n            && round_[lID_].state == Mildatasets.RoundState.STOPPED\r\n            && (block.number.sub(lBlockNumber_) >= 7)) {\r\n            // calculate the draw-code\r\n            round_[lID_].drawCode = calcDrawCode();\r\n            round_[lID_].claimDeadline = now + claimMax_;\r\n            round_[lID_].state = Mildatasets.RoundState.DRAWN;\r\n            round_[lID_].blockNumber = block.number;\r\n            \r\n            round_[rID_].roundDeadline = now + rndMax_;\r\n            \r\n            if (round_[rID_].pot > COMMON_REWARD_AMOUNT) {\r\n                round_[rID_].pot = round_[rID_].pot.sub(COMMON_REWARD_AMOUNT);\r\n                //reward who Draw Code 0.01 ether\r\n                _addr.transfer(COMMON_REWARD_AMOUNT);\r\n                \r\n                emit onReward(_addr, Mildatasets.RewardType.DRAW, COMMON_REWARD_AMOUNT);\r\n            }\r\n            return lID_ << 96 | round_[lID_].claimDeadline << 64 | round_[lID_].drawCode << 32 | uint256(Mildatasets.TxAction.DRAW) << 8 | uint256(Mildatasets.RoundState.DRAWN);\r\n        } else if (lID_ > 0\r\n            && round_[lID_].state == Mildatasets.RoundState.DRAWN\r\n            && now > round_[lID_].claimDeadline) {\r\n            // assign to foundation, winners, and migrate the rest to the next round\r\n            if (round_[lID_].totalNum > 0) {\r\n                assignCore();\r\n            }\r\n            round_[lID_].state = Mildatasets.RoundState.ASSIGNED;\r\n            \r\n            if (round_[rID_].pot > COMMON_REWARD_AMOUNT) {\r\n                round_[rID_].pot = round_[rID_].pot.sub(COMMON_REWARD_AMOUNT);\r\n                //reward who Draw Code 0.01 ether\r\n                _addr.transfer(COMMON_REWARD_AMOUNT);\r\n                \r\n                emit onReward(_addr, Mildatasets.RewardType.ASSIGN, COMMON_REWARD_AMOUNT);\r\n            }\r\n            return lID_ << 96 | uint256(Mildatasets.TxAction.ASSIGN) << 8 | uint256(Mildatasets.RoundState.ASSIGNED);\r\n        } else if ((rID_ == 1 || round_[lID_].state == Mildatasets.RoundState.ASSIGNED)\r\n            && now >= round_[rID_].roundDeadline) {\r\n            // end current round\r\n            lID_ = rID_;\r\n            lBlockNumber_ = block.number;\r\n            round_[lID_].state = Mildatasets.RoundState.STOPPED;\r\n\r\n            rID_ = rID_ + 1;\r\n\r\n            // migrate last round pot to this round util last round draw\r\n            round_[rID_].state = Mildatasets.RoundState.STARTED;\r\n            if (round_[lID_].pot > COMMON_REWARD_AMOUNT) {\r\n                round_[rID_].pot = round_[lID_].pot.sub(COMMON_REWARD_AMOUNT);\r\n                \r\n                //reward who end round 0.01 ether\r\n                _addr.transfer(COMMON_REWARD_AMOUNT);\r\n                \r\n                emit onReward(_addr, Mildatasets.RewardType.END, COMMON_REWARD_AMOUNT);\r\n            } else {\r\n                round_[rID_].pot = round_[lID_].pot;\r\n            }\r\n            \r\n\r\n            return rID_ << 96 | uint256(Mildatasets.TxAction.ENDROUND) << 8 | uint256(Mildatasets.RoundState.STARTED);\r\n        } \r\n        return rID_ << 96 | uint256(Mildatasets.TxAction.BUY) << 8 | uint256(round_[rID_].state);\r\n    }\r\n\r\n    /**\r\n     * @dev claim the winner identified by the given player's address\r\n     * @param _addr player's address\r\n     */\r\n    function claimWinner(address _addr)\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n    {\r\n        require(lID_ > 0 && round_[lID_].state == Mildatasets.RoundState.DRAWN && now <= round_[lID_].claimDeadline, \"it's not time for claiming\");\r\n        require(round_[lID_].winnerNum[_addr] == 0, \"the winner have been claimed already\");\r\n\r\n        uint winNum = 0;\r\n        uint256[] storage ptns = playerTicketNumbers_[lID_][_addr];\r\n        for (uint256 j = 0; j < ptns.length; j ++) {\r\n            (uint256 tType, uint256 tLength, uint256[] memory playCvtNums) = TicketCompressor.decode(ptns[j]);\r\n            for (uint256 k = 0; k < tLength; k ++) {\r\n                if ((tType == 1 && playCvtNums[k] == round_[lID_].drawCode) ||\r\n                    (tType == 2 && round_[lID_].drawCode >= playCvtNums[2 * k] && round_[lID_].drawCode <= playCvtNums[2 * k + 1])) {\r\n                    winNum++;\r\n                }\r\n            }\r\n        }\r\n        \r\n        if (winNum > 0) {\r\n            if (round_[lID_].winnerNum[_addr] == 0) {\r\n                round_[lID_].winners.push(_addr);\r\n            }\r\n            round_[lID_].totalNum = round_[lID_].totalNum.add(winNum);\r\n            round_[lID_].winnerNum[_addr] = winNum;\r\n            \r\n            uint256 rewardAmount = CLAIM_WINNER_REWARD_AMOUNT.min(round_[lID_].pot.div(200)); //reward who claim winner ,min 1 ether,no more than 1% reward\r\n            \r\n            round_[rID_].pot = round_[rID_].pot.sub(rewardAmount);\r\n            // reward who claim an winner\r\n            msg.sender.transfer(rewardAmount);\r\n            emit onReward(msg.sender, Mildatasets.RewardType.CLIAM, COMMON_REWARD_AMOUNT);\r\n            \r\n            emit onClaimWinner(\r\n                _addr,\r\n                winNum,\r\n                round_[lID_].totalNum\r\n            );\r\n        }\r\n    }\r\n\r\n    function assignCore() private {\r\n        /**\r\n         * 2% transfer to foundation\r\n         * 48% transfer to next round\r\n         * 50% all winner share 50% pot on condition singal share no more than MAX_WIN_AMOUNT\r\n         */\r\n        uint256 lPot = round_[lID_].pot;\r\n        uint256 totalWinNum = round_[lID_].totalNum;\r\n        uint256 winShareAmount = (MAX_WIN_AMOUNT.mul(totalWinNum)).min(lPot.div(2));\r\n        uint256 foundFee = lPot.div(50);\r\n\r\n        fundAddr_.transfer(foundFee);\r\n\r\n        uint256 avgShare = winShareAmount / totalWinNum;\r\n        for (uint256 idx = 0; idx < round_[lID_].winners.length; idx ++) {\r\n            address addr = round_[lID_].winners[idx];\r\n            uint256 num = round_[lID_].winnerNum[round_[lID_].winners[idx]];\r\n            uint256 amount = round_[lID_].winnerNum[round_[lID_].winners[idx]].mul(avgShare);\r\n\r\n            millionaire_.assign.value(amount)(addr);\r\n            playerWinTotal_[addr] = playerWinTotal_[addr].add(amount);\r\n\r\n            emit onPlayerWin(addr, lID_, amount, num);\r\n        }\r\n\r\n        round_[rID_].pot = round_[rID_].pot.sub(winShareAmount).sub(foundFee);\r\n    }\r\n\r\n    function calcSectionTickets(uint256[] startNums, uint256[] endNums)\r\n        private\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        require(startNums.length == endNums.length, \"tickets length invalid\");\r\n        uint256 totalTickets = 0;\r\n        uint256 tickets = 0;\r\n        for (uint256 i = 0; i < startNums.length; i ++) {\r\n            tickets = endNums[i].sub(startNums[i]).add(1);\r\n            totalTickets = totalTickets.add(tickets);\r\n        }\r\n        return totalTickets;\r\n    }\r\n\r\n    function calcDrawCode() private view returns(uint256) {\r\n        return uint256(keccak256(abi.encodePacked(\r\n\r\n            ((uint256(keccak256(abi.encodePacked(blockhash(block.number))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(blockhash(block.number - 1))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(blockhash(block.number - 2))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(blockhash(block.number - 3))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(blockhash(block.number - 4))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(blockhash(block.number - 5))))) / (block.timestamp)).add\r\n            ((uint256(keccak256(abi.encodePacked(blockhash(block.number - 6))))) / (block.timestamp))\r\n\r\n        ))) % 10000000;\r\n\r\n    }\r\n\r\n    function activate() public {\r\n        // only millionaire can activate\r\n        require(msg.sender == address(millionaire_), \"only contract millionaire can activate\");\r\n\r\n        // can only be ran once\r\n        require(activated_ == false, \"MilFold already activated\");\r\n\r\n        // activate the contract\r\n        activated_ = true;\r\n\r\n        // lets start first round\r\n        rID_ = 1;\r\n        round_[1].roundDeadline = now + rndMax_;\r\n        round_[1].state = Mildatasets.RoundState.STARTED;\r\n        // round_[0].pot refers to initial pot from ico phase\r\n        round_[1].pot = round_[0].pot;\r\n    }\r\n\r\n    function addPot()\r\n        public\r\n        payable {\r\n        require(milAuth_.checkGameClosed(address(this)) == false, \"game already closed\");\r\n        require(msg.value > 0, \"add pot failed\");\r\n        round_[rID_].pot = round_[rID_].pot.add(msg.value);\r\n    }\r\n\r\n    function close()\r\n        public\r\n        isActivated\r\n        onlyDevs {\r\n        require(milAuth_.checkGameClosed(address(this)), \"game no closed\");\r\n        activated_ = false;\r\n        millionaire_.splitPot.value(address(this).balance)();\r\n    }\r\n\r\n    /**\r\n     * @dev return players's total winning eth\r\n     * @param _addr player's address\r\n     * @return player's total tickets\r\n     * @return player's total winning eth\r\n     */\r\n    function getPlayerAccount(address _addr)\r\n        public\r\n        view\r\n        returns(uint256, uint256)\r\n    {\r\n        return (playerTickets_[_addr], playerWinTotal_[_addr]);\r\n    }\r\n\r\n    /**\r\n     * @dev return numbers in the round\r\n     * @param _rid round id\r\n     * @param _addr player's address\r\n     * @return player's numbers\r\n     */\r\n    function getPlayerRoundNums(uint256 _rid, address _addr)\r\n        public\r\n        view\r\n        returns(uint256[])\r\n    {\r\n        return playerTicketNumbers_[_rid][_addr];\r\n    }\r\n\r\n    /**\r\n     * @dev return player's winning information in the round\r\n     * @return winning numbers\r\n     * @param _rid round id\r\n     * @param _addr player's address\r\n     */\r\n    function getPlayerRoundWinningInfo(uint256 _rid, address _addr)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        Mildatasets.RoundState state = round_[_rid].state;\r\n        if (state >= Mildatasets.RoundState.UNKNOWN && state < Mildatasets.RoundState.DRAWN) {\r\n            return 0;\r\n        } else if (state == Mildatasets.RoundState.ASSIGNED) {\r\n            return round_[_rid].winnerNum[_addr];\r\n        } else {\r\n            // only drawn but not assigned, we need to query the player's winning numbers\r\n            uint256[] storage ptns = playerTicketNumbers_[_rid][_addr];\r\n            uint256 nums = 0;\r\n            for (uint256 j = 0; j < ptns.length; j ++) {\r\n                (uint256 tType, uint256 tLength, uint256[] memory playCvtNums) = TicketCompressor.decode(ptns[j]);\r\n                for (uint256 k = 0; k < tLength; k ++) {\r\n                    if ((tType == 1 && playCvtNums[k] == round_[_rid].drawCode) ||\r\n                        (tType == 2 && round_[_rid].drawCode >= playCvtNums[2 * k] && round_[lID_].drawCode <= playCvtNums[2 * k + 1])) {\r\n                        nums ++;\r\n                    }\r\n                }\r\n            }\r\n\r\n            return nums;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev check player is claim in round\r\n     * @param _rid round id\r\n     * @param _addr player address\r\n     * @return true is claimed else false\r\n     */\r\n    function checkPlayerClaimed(uint256 _rid, address _addr)\r\n        public\r\n        view\r\n        returns(bool) {\r\n        return round_[_rid].winnerNum[_addr] > 0;\r\n    }\r\n\r\n    /**\r\n     * @dev return current round information\r\n     * @return round id\r\n     * @return last round state\r\n     *      1. current round started\r\n     *      2. current round stopped(wait for drawing code)\r\n     *      3. drawn code(wait for claiming winners)\r\n     *      4. assigned to foundation, winners, and migrate the rest to the next round)\r\n     * @return round end time\r\n     * @return last round claiming time\r\n     * @return round pot\r\n     */\r\n    function getCurrentRoundInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        return (\r\n            rID_,\r\n            uint256(round_[lID_].state),\r\n            round_[rID_].roundDeadline,\r\n            round_[lID_].claimDeadline,\r\n            round_[rID_].pot\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev return history round information\r\n     * @param _rid round id\r\n     * @return items include as following\r\n     *  round state\r\n     *      1. current round started\r\n     *      2. current round stopped(wait for drawing code)\r\n     *      3. drawn code(wait for claiming winners)\r\n     *      4. assigned to foundation, winners, and migrate the rest to the next round)\r\n     *  round end time\r\n     *  winner claim end time\r\n     *  draw code\r\n     *  round pot\r\n     *  draw block number(last one)\r\n     * @return winners' address\r\n     * @return winning number\r\n     */\r\n    function getHistoryRoundInfo(uint256 _rid)\r\n        public\r\n        view\r\n        returns(uint256[], address[], uint256[])\r\n    {\r\n        uint256 length = round_[_rid].winners.length;\r\n        uint256[] memory numbers = new uint256[](length);\r\n        if (round_[_rid].winners.length > 0) {\r\n            for (uint256 idx = 0; idx < length; idx ++) {\r\n                numbers[idx] = round_[_rid].winnerNum[round_[_rid].winners[idx]];\r\n            }\r\n        }\r\n\r\n        uint256[] memory items = new uint256[](6);\r\n        items[0] = uint256(round_[_rid].state);\r\n        items[1] = round_[_rid].roundDeadline;\r\n        items[2] = round_[_rid].claimDeadline;\r\n        items[3] = round_[_rid].drawCode;\r\n        items[4] = round_[_rid].pot;\r\n        items[5] = round_[_rid].blockNumber;\r\n\r\n        return (items, round_[_rid].winners, numbers);\r\n    }\r\n\r\n}\r\n\r\n//==============================================================================\r\n//   __|_ _    __|_ _  .\r\n//  _\\ | | |_|(_ | _\\  .\r\n//==============================================================================\r\nlibrary Mildatasets {\r\n\r\n    // between `DRAWN' and `ASSIGNED', someone need to claim winners.\r\n    enum RoundState {\r\n        UNKNOWN,        // aim to differ from normal states\r\n        STARTED,        // start current round\r\n        STOPPED,        // stop current round\r\n        DRAWN,          // draw code\r\n        ASSIGNED        // assign to foundation, winners, and migrate the rest to the next round\r\n    }\r\n\r\n    // MilFold Transaction Action.\r\n    enum TxAction {\r\n        UNKNOWN,        // default\r\n        BUY,            // buy or reload tickets and so on \r\n        DRAW,           // draw code of game \r\n        ASSIGN,         // assign to winners\r\n        ENDROUND        // end game and start new round\r\n    }\r\n\r\n    // RewardType\r\n    enum RewardType {\r\n        UNKNOWN,        // default\r\n        DRAW,           // draw code\r\n        ASSIGN,         // assign winner\r\n        END,            // end game\r\n        CLIAM           // winner cliam\r\n    }\r\n\r\n    struct Player {\r\n        uint256 playerID;       // Player id(use to affiliate other player)\r\n        uint256 eth;            // player eth balance\r\n        uint256 mask;           // player mask\r\n        uint256 genTotal;       // general total vault\r\n        uint256 affTotal;       // affiliate total vault\r\n        uint256 laff;           // last affiliate id used\r\n    }\r\n\r\n    struct Round {\r\n        uint256                         roundDeadline;      // deadline to end round\r\n        uint256                         claimDeadline;      // deadline to claim winners\r\n        uint256                         pot;                // pot\r\n        uint256                         blockNumber;        // draw block number(last one)\r\n        RoundState                      state;              // round state\r\n        uint256                         drawCode;           // draw code\r\n        uint256                         totalNum;           // total number\r\n        mapping (address => uint256)    winnerNum;          // winners' number\r\n        address[]                       winners;            // winners\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr\r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n}\r\n\r\nlibrary TicketCompressor {\r\n\r\n    uint256 constant private mask = 16777215; //2 ** 24 - 1\r\n\r\n    function encode(uint256[] tickets)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        require((tickets.length > 0) && (tickets.length <= 10), \"tickets must > 0 and <= 10\");\r\n\r\n        uint256 value = tickets[0];\r\n        for (uint256 i = 1 ; i < tickets.length ; i++) {\r\n            require(tickets[i] < 10000000, \"ticket number must < 10000000\");\r\n            value = value << 24 | tickets[i];\r\n        }\r\n        return 1 << 248 | tickets.length << 240 | value;\r\n    }\r\n\r\n    function encode(uint256[] startTickets, uint256[] endTickets)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        require(startTickets.length > 0 && startTickets.length == endTickets.length && startTickets.length <= 5, \"section tickets must > 0 and <= 5\");\r\n\r\n        uint256 value = startTickets[0] << 24 | endTickets[0];\r\n        for (uint256 i = 1 ; i < startTickets.length ; i++) {\r\n            require(startTickets[i] <= endTickets[i] && endTickets[i] < 10000000, \"tickets number invalid\");\r\n            value = value << 48 | startTickets[i] << 24 | endTickets[i];\r\n        }\r\n        return 2 << 248 | startTickets.length << 240 | value;\r\n    }\r\n\r\n    function decode(uint256 _input)\r\n\t    internal\r\n\t    pure\r\n\t    returns(uint256,uint256,uint256[])\r\n    {\r\n        uint256 _type = _input >> 248;\r\n        uint256 _length = _input >> 240 & 127;\r\n        require(_type == 1 || _type == 2, \"decode type is incorrect!\");\r\n\r\n\r\n        if (_type == 1) {\r\n            uint256[] memory results = new uint256[](_length);\r\n            uint256 tempVal = _input;\r\n            for (uint256 i=0 ; i < _length ; i++) {\r\n                results[i] = tempVal & mask;\r\n                tempVal = tempVal >> 24;\r\n            }\r\n            return (_type,_length,results);\r\n        } else {\r\n            uint256[] memory result2 = new uint256[](_length * 2);\r\n            uint256 tempVal2 = _input;\r\n            for (uint256 j=0 ; j < _length ; j++) {\r\n                result2[2 * j + 1] = tempVal2 & mask;\r\n                tempVal2 = tempVal2 >> 24;\r\n                result2[2 * j] = tempVal2 & mask;\r\n                tempVal2 = tempVal2 >> 24;\r\n            }\r\n            return (_type,_length,result2);\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affID\",\"type\":\"uint256\"}],\"name\":\"buyTickets\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affID\",\"type\":\"uint256\"},{\"name\":\"_startNums\",\"type\":\"uint256[]\"},{\"name\":\"_endNums\",\"type\":\"uint256[]\"}],\"name\":\"expressBuyNumSec\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rid\",\"type\":\"uint256\"}],\"name\":\"getHistoryRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reloadTickets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nums\",\"type\":\"uint256[]\"}],\"name\":\"convertNums\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_nums\",\"type\":\"uint256[]\"}],\"name\":\"expressReloadNums\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"claimWinner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rid\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerRoundNums\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addPot\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startNums\",\"type\":\"uint256[]\"},{\"name\":\"endNums\",\"type\":\"uint256[]\"}],\"name\":\"convertNumSec\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"},{\"name\":\"_startNums\",\"type\":\"uint256[]\"},{\"name\":\"_endNums\",\"type\":\"uint256[]\"}],\"name\":\"expressReloadNumSec\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rid\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerRoundWinningInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affID\",\"type\":\"uint256\"},{\"name\":\"_nums\",\"type\":\"uint256[]\"}],\"name\":\"expressBuyNums\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rid\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkPlayerClaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewPlayer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"rid\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"compressData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tickets\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"gameAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onGameClose\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"rewardAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"onReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"eth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyMf\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalIco\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ended\",\"type\":\"bool\"}],\"name\":\"onICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winNums\",\"type\":\"uint256\"}],\"name\":\"onPlayerWin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerNum\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalNum\",\"type\":\"uint256\"}],\"name\":\"onClaimWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mfAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onBuyMFCoins\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mfAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onSellMFCoins\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"mfAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"}],\"name\":\"onUpdateGenVault\",\"type\":\"event\"}]","ContractName":"MilFold","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://486c202680e17dbe12d4cb3143d5866921a08091cda3dd348564f8acab770bb8"}]}