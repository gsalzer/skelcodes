{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ninterface HourglassInterface {\r\n    function() payable external;\r\n    function buy(address _investorAddress) payable external returns(uint256);\r\n    function reinvest() external;\r\n    function exit() payable external;\r\n    function withdraw() payable external;\r\n    function sell(uint256 _amountOfTokens) external;\r\n    function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool);\r\n    function totalEthereumBalance() external;\r\n    function totalSupply() external;\r\n    function myTokens() external returns(uint256);\r\n    function myDividends(bool _includeReferralBonus) external returns (uint256);\r\n    function balanceOf(address _investorAddress) external returns (uint256);\r\n    function dividendsOf(address _investorAddress) external returns (uint256);\r\n    function sellPrice() payable external returns (uint256);\r\n    function buyPrice() external;\r\n    function calculateTokensReceived(uint256 _ethereumToSpend) external;\r\n    function calculateEthereumReceived(uint256 _tokensToSell) external returns(uint256);\r\n    function purchaseTokens(uint256 _incomingEthereum, address _referredBy) external;\r\n}\r\n\r\ncontract FastEth {\r\n    \r\n    using SafeMath\r\n    for uint;\r\n    \r\n    /* Marketing private wallet*/\r\n    address constant _parojectMarketing = 0xaC780d067c52227ac7563FBe975eD9A8F235eb35;\r\n    address constant _wmtContractAddress = 0xB487283470C54d28Ed97453E8778d4250BA0F7d4;\r\n    /* Interface to main WMT contract */    \r\n    HourglassInterface constant WMTContract = HourglassInterface(_wmtContractAddress);\r\n    \r\n    /* % Fee that will be deducted from initial transfer and sent to CMT contract */\r\n    uint constant _masterTaxOnInvestment = 10;\r\n    \r\n\t//Address for promo expences\r\n    address constant private PROMO1 = 0xaC780d067c52227ac7563FBe975eD9A8F235eb35;\r\n\taddress constant private PROMO2 = 0x6dBFFf54E23Cf6DB1F72211e0683a5C6144E8F03;\r\n\taddress constant private PRIZE\t= 0xeE9B823ef62FfB79aFf2C861eDe7d632bbB5B653;\r\n\t\r\n\t//Percent for promo expences\r\n    uint constant public PERCENT = 5;\r\n    \r\n    //Bonus prize\r\n    uint constant public BONUS_PERCENT = 3;\r\n\t\r\n    // Start time\r\n    uint constant StartEpoc = 1541541570;                     \r\n                         \r\n    //The deposit structure holds all the info about the deposit made\r\n    struct Deposit {\r\n        address depositor; // The depositor address\r\n        uint deposit;   // The deposit amount\r\n        uint payout; // Amount already paid\r\n    }\r\n\r\n    Deposit[] public queue;  // The queue\r\n    mapping (address => uint) public depositNumber; // investor deposit index\r\n    uint public currentReceiverIndex; // The index of the depositor in the queue\r\n    uint public totalInvested; // Total invested amount\r\n\r\n    //This function receives all the deposits\r\n    //stores them and make immediate payouts\r\n    function () public payable {\r\n        \r\n        require(now >= StartEpoc);\r\n\r\n        if(msg.value > 0){\r\n\r\n            require(gasleft() >= 250000); // We need gas to process queue\r\n            require(msg.value >= 0.05 ether && msg.value <= 10 ether); // Too small and too big deposits are not accepted\r\n            \r\n            // Add the investor into the queue\r\n            queue.push( Deposit(msg.sender, msg.value, 0) );\r\n            depositNumber[msg.sender] = queue.length;\r\n\r\n            totalInvested += msg.value;\r\n\r\n            //Send some promo to enable queue contracts to leave long-long time\r\n            uint promo1 = msg.value*PERCENT/100;\r\n            PROMO1.transfer(promo1);\r\n\t\t\tuint promo2 = msg.value*PERCENT/100;\r\n            PROMO2.transfer(promo2);\r\n            \r\n            //Send to WMT contract\r\n            startDivDistribution();            \r\n            \r\n            uint prize = msg.value*BONUS_PERCENT/100;\r\n            PRIZE.transfer(prize);\r\n            \r\n            // Pay to first investors in line\r\n            pay();\r\n\r\n        }\r\n    }\r\n\r\n    // Used to pay to current investors\r\n    // Each new transaction processes 1 - 4+ investors in the head of queue\r\n    // depending on balance and gas left\r\n    function pay() internal {\r\n\r\n        uint money = address(this).balance;\r\n        uint multiplier = 118;\r\n\r\n        // We will do cycle on the queue\r\n        for (uint i = 0; i < queue.length; i++){\r\n\r\n            uint idx = currentReceiverIndex + i;  //get the index of the currently first investor\r\n\r\n            Deposit storage dep = queue[idx]; // get the info of the first investor\r\n\r\n            uint totalPayout = dep.deposit * multiplier / 100;\r\n            uint leftPayout;\r\n\r\n            if (totalPayout > dep.payout) {\r\n                leftPayout = totalPayout - dep.payout;\r\n            }\r\n\r\n            if (money >= leftPayout) { //If we have enough money on the contract to fully pay to investor\r\n\r\n                if (leftPayout > 0) {\r\n                    dep.depositor.transfer(leftPayout); // Send money to him\r\n                    money -= leftPayout;\r\n                }\r\n\r\n                // this investor is fully paid, so remove him\r\n                depositNumber[dep.depositor] = 0;\r\n                delete queue[idx];\r\n\r\n            } else{\r\n\r\n                // Here we don't have enough money so partially pay to investor\r\n                dep.depositor.transfer(money); // Send to him everything we have\r\n                dep.payout += money;       // Update the payout amount\r\n                break;                     // Exit cycle\r\n\r\n            }\r\n\r\n            if (gasleft() <= 55000) {         // Check the gas left. If it is low, exit the cycle\r\n                break;                       // The next investor will process the line further\r\n            }\r\n        }\r\n\r\n        currentReceiverIndex += i; //Update the index of the current first investor\r\n    }\r\n    \r\n    /* Internal function to distribute masterx tax fee into dividends to all CMT holders */\r\n    function startDivDistribution() internal{\r\n            /*#######################################  !  IMPORTANT  !  ##############################################\r\n            ## Here we buy WMT tokens with 10% from deposit and we intentionally use marketing wallet as masternode  ##\r\n            ## that results into 33% from 10% goes to marketing & server running  purposes by our team but the rest  ##\r\n            ## of 8% is distributet to all holder with selling WMT tokens & then reinvesting again (LOGIC FROM WMT) ##\r\n            ## This kindof functionality allows us to decrease the % tax on deposit since 1% from deposit is much   ##\r\n            ## more than 33% from 10%.                                                                               ##\r\n            ########################################################################################################*/\r\n            WMTContract.buy.value(msg.value.mul(_masterTaxOnInvestment).div(100))(_parojectMarketing);\r\n            uint _wmtBalance = getFundWMTBalance();\r\n            WMTContract.sell(_wmtBalance);\r\n            WMTContract.reinvest();\r\n    }\r\n\r\n    /* Returns contracts balance on WMT contract */\r\n    function getFundWMTBalance() internal returns (uint256){\r\n        return WMTContract.myTokens();\r\n    }\r\n    \r\n    //Returns your position in queue\r\n    function getDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=currentReceiverIndex; i<queue.length; ++i){\r\n            if(queue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    // Get current queue size\r\n    function getQueueLength() public view returns (uint) {\r\n        return queue.length - currentReceiverIndex;\r\n    }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n          return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n    \r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n    \r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depositNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvested\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"queue\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"payout\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"FastEth","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c0d417f88853fd8df4a9f10ec32ed774a74cf8937254eef090c9295291d1eaf7"}]}