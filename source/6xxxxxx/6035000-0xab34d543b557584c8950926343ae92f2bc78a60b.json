{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\n\r\n\r\n  /**\r\n   * @title SafeMath\r\n   * @dev Math operations with safety checks that throw on error\r\n   */\r\n  library SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n      if (a == 0) {\r\n        return 0;\r\n      }\r\n      c = a * b;\r\n      assert(c / a == b);\r\n      return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n      // uint256 c = a / b;\r\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n      return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n      assert(b <= a);\r\n      return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n      c = a + b;\r\n      assert(c >= a);\r\n      return c;\r\n    }\r\n  }\r\n\r\n  contract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n  }\r\n\r\n  contract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n  }\r\n\r\n  contract WETH9 {\r\n      string public name     = \"Wrapped Ether\";\r\n      string public symbol   = \"WETH\";\r\n      uint8  public decimals = 18;\r\n\r\n      event  Approval(address indexed src, address indexed guy, uint wad);\r\n      event  Transfer(address indexed src, address indexed dst, uint wad);\r\n      event  Deposit(address indexed dst, uint wad);\r\n      event  Withdrawal(address indexed src, uint wad);\r\n\r\n      mapping (address => uint)                       public  balanceOf;\r\n      mapping (address => mapping (address => uint))  public  allowance;\r\n\r\n      function() public payable {\r\n          deposit();\r\n      }\r\n      function deposit() public payable {\r\n          balanceOf[msg.sender] += msg.value;\r\n          Deposit(msg.sender, msg.value);\r\n      }\r\n      function withdraw(uint wad) public {\r\n          require(balanceOf[msg.sender] >= wad);\r\n          balanceOf[msg.sender] -= wad;\r\n          msg.sender.transfer(wad);\r\n          Withdrawal(msg.sender, wad);\r\n      }\r\n\r\n      function totalSupply() public view returns (uint) {\r\n          return this.balance;\r\n      }\r\n\r\n      function approve(address guy, uint wad) public returns (bool) {\r\n          allowance[msg.sender][guy] = wad;\r\n          Approval(msg.sender, guy, wad);\r\n          return true;\r\n      }\r\n\r\n      function transfer(address dst, uint wad) public returns (bool) {\r\n          return transferFrom(msg.sender, dst, wad);\r\n      }\r\n\r\n      function transferFrom(address src, address dst, uint wad)\r\n          public\r\n          returns (bool)\r\n      {\r\n          require(balanceOf[src] >= wad);\r\n\r\n          if (src != msg.sender && allowance[src][msg.sender] != uint(-1)) {\r\n              require(allowance[src][msg.sender] >= wad);\r\n              allowance[src][msg.sender] -= wad;\r\n          }\r\n\r\n          balanceOf[src] -= wad;\r\n          balanceOf[dst] += wad;\r\n\r\n          Transfer(src, dst, wad);\r\n\r\n          return true;\r\n      }\r\n  }\r\n\r\n\r\n  interface Registry {\r\n      function isAffiliated(address _affiliate) external returns (bool);\r\n  }\r\n\r\n  contract Affiliate {\r\n    struct Share {\r\n        address shareholder;\r\n        uint stake;\r\n    }\r\n\r\n    Share[] shares;\r\n    uint public totalShares;\r\n    string public relayerName;\r\n    address registry;\r\n    WETH9 weth;\r\n\r\n    event Payout(address indexed token, uint amount);\r\n\r\n    function init(address _registry, address[] shareholders, uint[] stakes, address _weth, string _name) public returns (bool) {\r\n      require(totalShares == 0);\r\n      require(shareholders.length == stakes.length);\r\n      weth = WETH9(_weth);\r\n      totalShares = 0;\r\n      for(uint i=0; i < shareholders.length; i++) {\r\n          shares.push(Share({shareholder: shareholders[i], stake: stakes[i]}));\r\n          totalShares += stakes[i];\r\n      }\r\n      relayerName = _name;\r\n      registry = _registry;\r\n      return true;\r\n    }\r\n    function payout(address[] tokens) public {\r\n        // Payout all stakes at once, so we don't have to do bookkeeping on who has\r\n        // claimed their shares and who hasn't. If the number of shareholders is large\r\n        // this could run into some gas limits. In most cases, I expect two\r\n        // shareholders, but it could be a small handful. This also means the caller\r\n        // must pay gas for everyone's payouts.\r\n        for(uint i=0; i < tokens.length; i++) {\r\n            ERC20 token = ERC20(tokens[i]);\r\n            uint balance = token.balanceOf(this);\r\n            for(uint j=0; j < shares.length; j++) {\r\n                token.transfer(shares[j].shareholder, SafeMath.mul(balance, shares[j].stake) / totalShares);\r\n            }\r\n            emit Payout(tokens[i], balance);\r\n        }\r\n    }\r\n    function isAffiliated(address _affiliate) public returns (bool)\r\n    {\r\n        return Registry(registry).isAffiliated(_affiliate);\r\n    }\r\n\r\n    function() public payable {\r\n      // If we get paid in ETH, convert to WETH so payouts work the same.\r\n      // Converting to WETH also makes payouts a bit safer, as we don't have to\r\n      // worry about code execution if the stakeholder is a contract.\r\n      weth.deposit.value(msg.value)();\r\n    }\r\n\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * @title Ownable\r\n   * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n   * functions, this simplifies the implementation of \"user permissions\".\r\n   */\r\n  contract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    function Ownable() public {\r\n      owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n      require(newOwner != address(0));\r\n      emit OwnershipTransferred(owner, newOwner);\r\n      owner = newOwner;\r\n    }\r\n\r\n  }\r\n\r\n  interface Downstream {\r\n      function registerAffiliate(address _affiliate, string _name) external returns (bool);\r\n  }\r\n\r\n  contract AffiliateFactory is Ownable {\r\n\r\n      event AffiliateDeployed(address affiliateAddress, address targetAddress, string affiliateName, address indexed sender);\r\n\r\n      address public target;\r\n      address public beneficiary;\r\n      address public WETH;\r\n      address public downstream;\r\n      uint public beneficiaryStake;\r\n      uint public senderStake;\r\n      mapping(address => string) affiliates;\r\n\r\n      constructor(address _target, address _weth, uint _beneficiaryStake, uint _senderStake, address _downstream) public Ownable() {\r\n         update(_target, msg.sender, _weth, _beneficiaryStake, _senderStake, _downstream);\r\n      }\r\n\r\n      function update(address _target, address _beneficiary, address _weth, uint _beneficiaryStake, uint _senderStake, address _downstream) public onlyOwner {\r\n          target = _target;\r\n          beneficiary = _beneficiary;\r\n          beneficiaryStake = _beneficiaryStake;\r\n          senderStake = _senderStake;\r\n          downstream = _downstream;\r\n          WETH = _weth;\r\n      }\r\n\r\n      function signUp(address[] _stakeHolders, uint256[] _stakes, string _name)\r\n          external\r\n          returns (address affiliateContract)\r\n      {\r\n          require(_stakeHolders.length > 0 && _stakeHolders.length == _stakes.length && bytes(_name).length > 0);\r\n          affiliateContract = createProxyImpl(target);\r\n          address[] memory stakeHolders = new address[](_stakeHolders.length + 1);\r\n          uint[] memory shares = new uint[](stakeHolders.length);\r\n          stakeHolders[0] = beneficiary;\r\n          shares[0] = beneficiaryStake;\r\n          uint256 stakesTotal = 0;\r\n\r\n          for(uint i=0; i < _stakeHolders.length; i++) {\r\n            require(_stakes[i] > 0);\r\n            stakesTotal = SafeMath.add(stakesTotal, _stakes[i]);\r\n          }\r\n          require(stakesTotal > 0);\r\n          for(i=0; i < _stakeHolders.length; i++) {\r\n            stakeHolders[i+1] = _stakeHolders[i];\r\n            // (user stake) / (total stake) * (available stake) ; but with integer math\r\n            shares[i+1] = SafeMath.mul(_stakes[i], senderStake) / stakesTotal ;\r\n          }\r\n          require(Affiliate(affiliateContract).init(this, stakeHolders, shares, WETH, _name));\r\n          affiliates[affiliateContract] = _name;\r\n          emit AffiliateDeployed(affiliateContract, target, _name, msg.sender);\r\n          if(downstream != address(0)) {\r\n            Downstream(downstream).registerAffiliate(affiliateContract, _name);\r\n          }\r\n      }\r\n\r\n      function registerAffiliate(address[] stakeHolders, uint[] shares, string _name)\r\n          external\r\n          onlyOwner\r\n          returns (address affiliateContract)\r\n      {\r\n          require(stakeHolders.length > 0 && stakeHolders.length == shares.length && bytes(_name).length > 0);\r\n          affiliateContract = createProxyImpl(target);\r\n          require(Affiliate(affiliateContract).init(this, stakeHolders, shares, WETH, _name));\r\n          affiliates[affiliateContract] = _name;\r\n          emit AffiliateDeployed(affiliateContract, target, _name, msg.sender);\r\n          if(downstream != address(0)) {\r\n            Downstream(downstream).registerAffiliate(affiliateContract, _name);\r\n          }\r\n      }\r\n\r\n      function isAffiliated(address _affiliate) external view returns (bool)\r\n      {\r\n        return bytes(affiliates[_affiliate]).length != 0;\r\n      }\r\n\r\n      function affiliateName(address _affiliate) external view returns (string)\r\n      {\r\n        return affiliates[_affiliate];\r\n      }\r\n\r\n      function createProxyImpl(address _target)\r\n          internal\r\n          returns (address proxyContract)\r\n      {\r\n          assembly {\r\n              let contractCode := mload(0x40) // Find empty storage location using \"free memory pointer\"\r\n\r\n              mstore(add(contractCode, 0x0b), _target) // Add target address, with a 11 bytes [i.e. 23 - (32 - 20)] offset to later accomodate first part of the bytecode\r\n              mstore(sub(contractCode, 0x09), 0x000000000000000000603160008181600b9039f3600080808080368092803773) // First part of the bytecode, shifted left by 9 bytes, overwrites left padding of target address\r\n              mstore(add(contractCode, 0x2b), 0x5af43d828181803e808314602f57f35bfd000000000000000000000000000000) // Final part of bytecode, offset by 43 bytes\r\n\r\n              proxyContract := create(0, contractCode, 60) // total length 60 bytes\r\n              if iszero(extcodesize(proxyContract)) {\r\n                  revert(0, 0)\r\n              }\r\n          }\r\n      }\r\n  }","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"downstream\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_affiliate\",\"type\":\"address\"}],\"name\":\"isAffiliated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WETH\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiaryStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stakeHolders\",\"type\":\"address[]\"},{\"name\":\"shares\",\"type\":\"uint256[]\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"registerAffiliate\",\"outputs\":[{\"name\":\"affiliateContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"target\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_affiliate\",\"type\":\"address\"}],\"name\":\"affiliateName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_weth\",\"type\":\"address\"},{\"name\":\"_beneficiaryStake\",\"type\":\"uint256\"},{\"name\":\"_senderStake\",\"type\":\"uint256\"},{\"name\":\"_downstream\",\"type\":\"address\"}],\"name\":\"update\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeHolders\",\"type\":\"address[]\"},{\"name\":\"_stakes\",\"type\":\"uint256[]\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"signUp\",\"outputs\":[{\"name\":\"affiliateContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"senderStake\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_weth\",\"type\":\"address\"},{\"name\":\"_beneficiaryStake\",\"type\":\"uint256\"},{\"name\":\"_senderStake\",\"type\":\"uint256\"},{\"name\":\"_downstream\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"targetAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"}],\"name\":\"AffiliateDeployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"AffiliateFactory","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://0f0d9e3b6965cdde5c34f9ac987644f1971bc8c9738ef63770392af5468be041"}]}