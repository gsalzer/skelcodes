{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\nПравила игр eSmart\r\n\r\n* Процентная ставка 120%\r\n* Фиксированный размер депозита; 0.05 eth, 0.1eth, 1eth\r\n* Ежедневные старты, 5 раундов для каждой категории депозитов\r\n* Распределение баланса\r\n- 90% на выплаты участникам\r\n- 7% делится поровну и распределяется между последними депозитами которые не прошли круг\r\n(возврат 20% от депозита)\r\n- 1% Джекпот\r\n- 2% маркетинг и техническая поддержка\r\n\r\n* Джекпот выигрывает участник который сделает больше всех транзакций с оборота за 5 раундов, в каждой категории отдельно.\r\n\r\n* Раунд заканчивается через 10 минут от последней входящей транзакции на смарт контракт.\r\n\r\n* eSmart предлагает самые эффективные умножители с высокой вероятностью прохождения круга!\r\n* В играх eSmart нет проигравших, так как в каждом раунде все транзакции получают выплаты\r\n- 77% первых транзакций 120% от депозита\r\n- 23% последних транзакций в очереди 20% от депозита\r\n\r\n* Играй в честные игры с eSmart\r\n\r\n*/\r\n\r\ncontract ESmart {\r\n    uint constant public INVESTMENT = 0.05 ether;\r\n    uint constant private START_TIME = 1541435400; // 2018-11-05 19:30 MSK (GMT+3)\r\n\r\n    //Address for tech expences\r\n    address constant private TECH = 0x9A5B6966379a61388068bb765c518E5bC4D9B509;\r\n    //Address for promo expences\r\n    address constant private PROMO = 0xD6104cEca65db37925541A800870aEe09C8Fd78D;\r\n    //Address for promo expences\r\n    address constant private LAST_FUND = 0x357b9046f99eEC7E705980F328F00BAab4b3b6Be;\r\n    //Percent for first multiplier donation\r\n    uint constant public JACKPOT_PERCENT = 1;\r\n    uint constant public TECH_PERCENT = 7; //0.7%\r\n    uint constant public PROMO_PERCENT = 13; //1.3%\r\n    uint constant public LAST_FUND_PERCENT = 10;\r\n    uint constant public MAX_IDLE_TIME = 10 minutes; //Maximum time the deposit should remain the last to receive prize\r\n    uint constant public NEXT_ROUND_TIME = 30 minutes; //Time to next round since the last deposit\r\n\r\n    //How many percent for your deposit to be multiplied\r\n    uint constant public MULTIPLIER = 120;\r\n\r\n    //The deposit structure holds all the info about the deposit made\r\n    struct Deposit {\r\n        address depositor; //The depositor address\r\n        uint128 deposit;   //The deposit amount\r\n        uint128 expect;    //How much we should pay out (initially it is 120% of deposit)\r\n    }\r\n\r\n    struct LastDepositInfo {\r\n        uint128 index;\r\n        uint128 time;\r\n    }\r\n\r\n    struct MaxDepositInfo {\r\n        address depositor;\r\n        uint count;\r\n    }\r\n\r\n    Deposit[] private queue;  //The queue\r\n    uint public currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!\r\n    uint public currentQueueSize = 0; //The current size of queue (may be less than queue.length)\r\n    LastDepositInfo public lastDepositInfo; //The time last deposit made at\r\n    MaxDepositInfo public maxDepositInfo; //The pretender for jackpot\r\n    uint private startTime = START_TIME;\r\n    mapping(address => uint) public depCount; //Number of deposits made\r\n\r\n    uint public jackpotAmount = 0; //Prize amount accumulated for the last depositor\r\n    int public stage = 0; //Number of contract runs\r\n\r\n    //This function receives all the deposits\r\n    //stores them and make immediate payouts\r\n    function () public payable {\r\n        //If money are from first multiplier, just add them to the balance\r\n        //All these money will be distributed to current investors\r\n        if(msg.value > 0){\r\n            require(gasleft() >= 220000, \"We require more gas!\"); //We need gas to process queue\r\n            require(msg.value >= INVESTMENT, \"The investment is too small!\");\r\n            require(stage < 5); //Only 5 rounds!!!\r\n\r\n            checkAndUpdateStage();\r\n\r\n            //Check that we can accept deposits\r\n            require(getStartTime() <= now, \"Deposits are not accepted before time\");\r\n\r\n            addDeposit(msg.sender, msg.value);\r\n\r\n            //Pay to first investors in line\r\n            pay();\r\n        }else if(msg.value == 0){\r\n            withdrawPrize();\r\n        }\r\n    }\r\n\r\n    //Used to pay to current investors\r\n    //Each new transaction processes 1 - 4+ investors in the head of queue\r\n    //depending on balance and gas left\r\n    function pay() private {\r\n        //Try to send all the money on contract to the first investors in line\r\n        uint balance = address(this).balance;\r\n        uint128 money = 0;\r\n        if(balance > (jackpotAmount)) //The opposite is impossible, however the check will not do any harm\r\n            money = uint128(balance - jackpotAmount);\r\n\r\n        //We will do cycle on the queue\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; i++){\r\n\r\n            Deposit storage dep = queue[i]; //get the info of the first investor\r\n\r\n            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor\r\n                dep.depositor.send(dep.expect); //Send money to him\r\n                money -= dep.expect;            //update money left\r\n\r\n                //this investor is fully paid, so remove him\r\n                delete queue[i];\r\n            }else{\r\n                //Here we don't have enough money so partially pay to investor\r\n                dep.depositor.send(money); //Send to him everything we have\r\n                dep.expect -= money;       //Update the expected amount\r\n                break;                     //Exit cycle\r\n            }\r\n\r\n            if(gasleft() <= 50000)         //Check the gas left. If it is low, exit the cycle\r\n                break;                     //The next investor will process the line further\r\n        }\r\n\r\n        currentReceiverIndex = i; //Update the index of the current first investor\r\n    }\r\n\r\n    function addDeposit(address depositor, uint value) private {\r\n        require(stage < 5); //Only 5 rounds!!!\r\n        //If you are applying for the prize you should invest more than minimal amount\r\n        //Otherwize it doesn't count\r\n        if(value > INVESTMENT){ //Fixed deposit\r\n            depositor.transfer(value - INVESTMENT);\r\n            value = INVESTMENT;\r\n        }\r\n\r\n        lastDepositInfo.index = uint128(currentQueueSize);\r\n        lastDepositInfo.time = uint128(now);\r\n\r\n        //Add the investor into the queue. Mark that he expects to receive 120% of deposit back\r\n        push(depositor, value, value*MULTIPLIER/100);\r\n\r\n        depCount[depositor]++;\r\n\r\n        //Check if candidate for jackpot changed\r\n        uint count = depCount[depositor];\r\n        if(maxDepositInfo.count < count){\r\n            maxDepositInfo.count = count;\r\n            maxDepositInfo.depositor = depositor;\r\n        }\r\n\r\n        //Save money for prize and father multiplier\r\n        jackpotAmount += value*(JACKPOT_PERCENT)/100;\r\n\r\n        uint lastFund = value*LAST_FUND_PERCENT/100;\r\n        LAST_FUND.send(lastFund);\r\n        //Send small part to tech support\r\n        uint support = value*TECH_PERCENT/1000;\r\n        TECH.send(support);\r\n        uint adv = value*PROMO_PERCENT/1000;\r\n        PROMO.send(adv);\r\n\r\n    }\r\n\r\n    function checkAndUpdateStage() private{\r\n        int _stage = getCurrentStageByTime();\r\n\r\n        require(_stage >= stage, \"We should only go forward in time\");\r\n\r\n        if(_stage != stage){\r\n            proceedToNewStage(_stage);\r\n        }\r\n    }\r\n\r\n    function proceedToNewStage(int _stage) private {\r\n        //Clean queue info\r\n        //The prize amount on the balance is left the same if not withdrawn\r\n        startTime = getStageStartTime(_stage);\r\n        assert(startTime > 0);\r\n        stage = _stage;\r\n        currentQueueSize = 0; //Instead of deleting queue just reset its length (gas economy)\r\n        currentReceiverIndex = 0;\r\n        delete lastDepositInfo;\r\n    }\r\n\r\n    function withdrawPrize() private {\r\n        require(getCurrentStageByTime() >= 5); //Only after 5 rounds!\r\n        require(maxDepositInfo.count > 0, \"The max depositor is not confirmed yet\");\r\n\r\n        uint balance = address(this).balance;\r\n        if(jackpotAmount > balance) //Impossible but better check it\r\n            jackpotAmount = balance;\r\n\r\n        maxDepositInfo.depositor.send(jackpotAmount);\r\n\r\n        selfdestruct(TECH); //5 rounds are over, so we can clean the contract\r\n    }\r\n\r\n    //Pushes investor to the queue\r\n    function push(address depositor, uint deposit, uint expect) private {\r\n        //Add the investor into the queue\r\n        Deposit memory dep = Deposit(depositor, uint128(deposit), uint128(expect));\r\n        assert(currentQueueSize <= queue.length); //Assert queue size is not corrupted\r\n        if(queue.length == currentQueueSize)\r\n            queue.push(dep);\r\n        else\r\n            queue[currentQueueSize] = dep;\r\n\r\n        currentQueueSize++;\r\n    }\r\n\r\n    //Get the deposit info by its index\r\n    //You can get deposit index from\r\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\r\n        Deposit storage dep = queue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expect);\r\n    }\r\n\r\n    //Get the count of deposits of specific investor\r\n    function getDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=currentReceiverIndex; i<currentQueueSize; ++i){\r\n            if(queue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    //Get all deposits (index, deposit, expect) of a specific investor\r\n    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {\r\n        uint c = getDepositsCount(depositor);\r\n\r\n        idxs = new uint[](c);\r\n        deposits = new uint128[](c);\r\n        expects = new uint128[](c);\r\n\r\n        if(c > 0) {\r\n            uint j = 0;\r\n            for(uint i=currentReceiverIndex; i<currentQueueSize; ++i){\r\n                Deposit storage dep = queue[i];\r\n                if(dep.depositor == depositor){\r\n                    idxs[j] = i;\r\n                    deposits[j] = dep.deposit;\r\n                    expects[j] = dep.expect;\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //Get current queue size\r\n    function getQueueLength() public view returns (uint) {\r\n        return currentQueueSize - currentReceiverIndex;\r\n    }\r\n\r\n    function getCurrentStageByTime() public view returns (int) {\r\n        if(lastDepositInfo.time > 0 && lastDepositInfo.time + MAX_IDLE_TIME <= now){\r\n            return stage + 1; //Move to next stage if last deposit is too old\r\n        }\r\n        return stage;\r\n    }\r\n\r\n    function getStageStartTime(int _stage) public view returns (uint) {\r\n        if(_stage >= 5)\r\n            return 0;\r\n        if(_stage == stage)\r\n            return startTime;\r\n        if(lastDepositInfo.time == 0)\r\n            return 0;\r\n        if(_stage == stage + 1)\r\n            return lastDepositInfo.time + NEXT_ROUND_TIME;\r\n        return 0;\r\n    }\r\n\r\n    function getStartTime() public view returns (uint) {\r\n        return getStageStartTime(getCurrentStageByTime());\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"LAST_FUND_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentQueueSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentStageByTime\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NEXT_ROUND_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxDepositInfo\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDeposits\",\"outputs\":[{\"name\":\"idxs\",\"type\":\"uint256[]\"},{\"name\":\"deposits\",\"type\":\"uint128[]\"},{\"name\":\"expects\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TECH_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getQueueLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stage\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PROMO_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_IDLE_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastDepositInfo\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint128\"},{\"name\":\"time\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"depCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"int256\"}],\"name\":\"getStageStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ESmart","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a26acd0b270a206df1fa7fd80d173043b9dd3ca211af07cd9a147ecc70c61143"}]}