{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    require(c / a == b, \"Overflow - Multiplication\");\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"Underflow - Subtraction\");\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    require(c >= a, \"Overflow - Addition\");\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary Contract {\r\n\r\n  using SafeMath for uint;\r\n\r\n  // Modifiers: //\r\n\r\n  // Runs two functions before and after a function -\r\n  modifier conditions(function () pure first, function () pure last) {\r\n    first();\r\n    _;\r\n    last();\r\n  }\r\n\r\n  bytes32 internal constant EXEC_PERMISSIONS = keccak256('script_exec_permissions');\r\n\r\n  // Sets up contract execution - reads execution id and sender from storage and\r\n  // places in memory, creating getters. Calling this function should be the first\r\n  // action an application does as part of execution, as it sets up memory for\r\n  // execution. Additionally, application functions in the main file should be\r\n  // external, so that memory is not touched prior to calling this function.\r\n  // The 3rd slot allocated will hold a pointer to a storage buffer, which will\r\n  // be reverted to abstract storage to store data, emit events, and forward\r\n  // wei on behalf of the application.\r\n  function authorize(address _script_exec) internal view {\r\n    // Initialize memory\r\n    initialize();\r\n\r\n    // Check that the sender is authorized as a script exec contract for this exec id\r\n    bytes32 perms = EXEC_PERMISSIONS;\r\n    bool authorized;\r\n    assembly {\r\n      // Place the script exec address at 0, and the exec permissions seed after it\r\n      mstore(0, _script_exec)\r\n      mstore(0x20, perms)\r\n      // Hash the resulting 0x34 bytes, and place back into memory at 0\r\n      mstore(0, keccak256(0x0c, 0x34))\r\n      // Place the exec id after the hash -\r\n      mstore(0x20, mload(0x80))\r\n      // Hash the previous hash with the execution id, and check the result\r\n      authorized := sload(keccak256(0, 0x40))\r\n    }\r\n    if (!authorized)\r\n      revert(\"Sender is not authorized as a script exec address\");\r\n  }\r\n\r\n  // Sets up contract execution when initializing an instance of the application\r\n  // First, reads execution id and sender from storage (execution id should be 0xDEAD),\r\n  // then places them in memory, creating getters. Calling this function should be the first\r\n  // action an application does as part of execution, as it sets up memory for\r\n  // execution. Additionally, application functions in the main file should be\r\n  // external, so that memory is not touched prior to calling this function.\r\n  // The 3rd slot allocated will hold a pointer to a storage buffer, which will\r\n  // be reverted to abstract storage to store data, emit events, and forward\r\n  // wei on behalf of the application.\r\n  function initialize() internal view {\r\n    // No memory should have been allocated yet - expect the free memory pointer\r\n    // to point to 0x80 - and throw if it does not\r\n    require(freeMem() == 0x80, \"Memory allocated prior to execution\");\r\n    // Next, set up memory for execution\r\n    assembly {\r\n      mstore(0x80, sload(0))     // Execution id, read from storage\r\n      mstore(0xa0, sload(1))     // Original sender address, read from storage\r\n      mstore(0xc0, 0)            // Pointer to storage buffer\r\n      mstore(0xe0, 0)            // Bytes4 value of the current action requestor being used\r\n      mstore(0x100, 0)           // Enum representing the next type of function to be called (when pushing to buffer)\r\n      mstore(0x120, 0)           // Number of storage slots written to in buffer\r\n      mstore(0x140, 0)           // Number of events pushed to buffer\r\n      mstore(0x160, 0)           // Number of payment destinations pushed to buffer\r\n\r\n      // Update free memory pointer -\r\n      mstore(0x40, 0x180)\r\n    }\r\n    // Ensure that the sender and execution id returned from storage are expected values -\r\n    assert(execID() != bytes32(0) && sender() != address(0));\r\n  }\r\n\r\n  // Calls the passed-in function, performing a memory state check before and after the check\r\n  // is executed.\r\n  function checks(function () view _check) conditions(validState, validState) internal view {\r\n    _check();\r\n  }\r\n\r\n  // Calls the passed-in function, performing a memory state check before and after the check\r\n  // is executed.\r\n  function checks(function () pure _check) conditions(validState, validState) internal pure {\r\n    _check();\r\n  }\r\n\r\n  // Ensures execution completed successfully, and reverts the created storage buffer\r\n  // back to the sender.\r\n  function commit() conditions(validState, none) internal pure {\r\n    // Check value of storage buffer pointer - should be at least 0x180\r\n    bytes32 ptr = buffPtr();\r\n    require(ptr >= 0x180, \"Invalid buffer pointer\");\r\n\r\n    assembly {\r\n      // Get the size of the buffer\r\n      let size := mload(add(0x20, ptr))\r\n      mstore(ptr, 0x20) // Place dynamic data offset before buffer\r\n      // Revert to storage\r\n      revert(ptr, add(0x40, size))\r\n    }\r\n  }\r\n\r\n  // Helpers: //\r\n\r\n  // Checks to ensure the application was correctly executed -\r\n  function validState() private pure {\r\n    if (freeMem() < 0x180)\r\n      revert('Expected Contract.execute()');\r\n\r\n    if (buffPtr() != 0 && buffPtr() < 0x180)\r\n      revert('Invalid buffer pointer');\r\n\r\n    assert(execID() != bytes32(0) && sender() != address(0));\r\n  }\r\n\r\n  // Returns a pointer to the execution storage buffer -\r\n  function buffPtr() private pure returns (bytes32 ptr) {\r\n    assembly { ptr := mload(0xc0) }\r\n  }\r\n\r\n  // Returns the location pointed to by the free memory pointer -\r\n  function freeMem() private pure returns (bytes32 ptr) {\r\n    assembly { ptr := mload(0x40) }\r\n  }\r\n\r\n  // Returns the current storage action\r\n  function currentAction() private pure returns (bytes4 action) {\r\n    if (buffPtr() == bytes32(0))\r\n      return bytes4(0);\r\n\r\n    assembly { action := mload(0xe0) }\r\n  }\r\n\r\n  // If the current action is not storing, reverts\r\n  function isStoring() private pure {\r\n    if (currentAction() != STORES)\r\n      revert('Invalid current action - expected STORES');\r\n  }\r\n\r\n  // If the current action is not emitting, reverts\r\n  function isEmitting() private pure {\r\n    if (currentAction() != EMITS)\r\n      revert('Invalid current action - expected EMITS');\r\n  }\r\n\r\n  // If the current action is not paying, reverts\r\n  function isPaying() private pure {\r\n    if (currentAction() != PAYS)\r\n      revert('Invalid current action - expected PAYS');\r\n  }\r\n\r\n  // Initializes a storage buffer in memory -\r\n  function startBuffer() private pure {\r\n    assembly {\r\n      // Get a pointer to free memory, and place at 0xc0 (storage buffer pointer)\r\n      let ptr := msize()\r\n      mstore(0xc0, ptr)\r\n      // Clear bytes at pointer -\r\n      mstore(ptr, 0)            // temp ptr\r\n      mstore(add(0x20, ptr), 0) // buffer length\r\n      // Update free memory pointer -\r\n      mstore(0x40, add(0x40, ptr))\r\n      // Set expected next function to 'NONE' -\r\n      mstore(0x100, 1)\r\n    }\r\n  }\r\n\r\n  // Checks whether or not it is valid to create a STORES action request -\r\n  function validStoreBuff() private pure {\r\n    // Get pointer to current buffer - if zero, create a new buffer -\r\n    if (buffPtr() == bytes32(0))\r\n      startBuffer();\r\n\r\n    // Ensure that the current action is not 'storing', and that the buffer has not already\r\n    // completed a STORES action -\r\n    if (stored() != 0 || currentAction() == STORES)\r\n      revert('Duplicate request - stores');\r\n  }\r\n\r\n  // Checks whether or not it is valid to create an EMITS action request -\r\n  function validEmitBuff() private pure {\r\n    // Get pointer to current buffer - if zero, create a new buffer -\r\n    if (buffPtr() == bytes32(0))\r\n      startBuffer();\r\n\r\n    // Ensure that the current action is not 'emitting', and that the buffer has not already\r\n    // completed an EMITS action -\r\n    if (emitted() != 0 || currentAction() == EMITS)\r\n      revert('Duplicate request - emits');\r\n  }\r\n\r\n  // Checks whether or not it is valid to create a PAYS action request -\r\n  function validPayBuff() private pure {\r\n    // Get pointer to current buffer - if zero, create a new buffer -\r\n    if (buffPtr() == bytes32(0))\r\n      startBuffer();\r\n\r\n    // Ensure that the current action is not 'paying', and that the buffer has not already\r\n    // completed an PAYS action -\r\n    if (paid() != 0 || currentAction() == PAYS)\r\n      revert('Duplicate request - pays');\r\n  }\r\n\r\n  // Placeholder function when no pre or post condition for a function is needed\r\n  function none() private pure { }\r\n\r\n  // Runtime getters: //\r\n\r\n  // Returns the execution id from memory -\r\n  function execID() internal pure returns (bytes32 exec_id) {\r\n    assembly { exec_id := mload(0x80) }\r\n    require(exec_id != bytes32(0), \"Execution id overwritten, or not read\");\r\n  }\r\n\r\n  // Returns the original sender from memory -\r\n  function sender() internal pure returns (address addr) {\r\n    assembly { addr := mload(0xa0) }\r\n    require(addr != address(0), \"Sender address overwritten, or not read\");\r\n  }\r\n\r\n  // Reading from storage: //\r\n\r\n  // Reads from storage, resolving the passed-in location to its true location in storage\r\n  // by hashing with the exec id. Returns the data read from that location\r\n  function read(bytes32 _location) internal view returns (bytes32 data) {\r\n    data = keccak256(_location, execID());\r\n    assembly { data := sload(data) }\r\n  }\r\n\r\n  // Storing data, emitting events, and forwarding payments: //\r\n\r\n  bytes4 internal constant EMITS = bytes4(keccak256('Emit((bytes32[],bytes)[])'));\r\n  bytes4 internal constant STORES = bytes4(keccak256('Store(bytes32[])'));\r\n  bytes4 internal constant PAYS = bytes4(keccak256('Pay(bytes32[])'));\r\n  bytes4 internal constant THROWS = bytes4(keccak256('Error(string)'));\r\n\r\n  // Function enums -\r\n  enum NextFunction {\r\n    INVALID, NONE, STORE_DEST, VAL_SET, VAL_INC, VAL_DEC, EMIT_LOG, PAY_DEST, PAY_AMT\r\n  }\r\n\r\n  // Checks that a call pushing a storage destination to the buffer is expected and valid\r\n  function validStoreDest() private pure {\r\n    // Ensure that the next function expected pushes a storage destination -\r\n    if (expected() != NextFunction.STORE_DEST)\r\n      revert('Unexpected function order - expected storage destination to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing STORES actions -\r\n    isStoring();\r\n  }\r\n\r\n  // Checks that a call pushing a storage value to the buffer is expected and valid\r\n  function validStoreVal() private pure {\r\n    // Ensure that the next function expected pushes a storage value -\r\n    if (\r\n      expected() != NextFunction.VAL_SET &&\r\n      expected() != NextFunction.VAL_INC &&\r\n      expected() != NextFunction.VAL_DEC\r\n    ) revert('Unexpected function order - expected storage value to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing STORES actions -\r\n    isStoring();\r\n  }\r\n\r\n  // Checks that a call pushing a payment destination to the buffer is expected and valid\r\n  function validPayDest() private pure {\r\n    // Ensure that the next function expected pushes a payment destination -\r\n    if (expected() != NextFunction.PAY_DEST)\r\n      revert('Unexpected function order - expected payment destination to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing PAYS actions -\r\n    isPaying();\r\n  }\r\n\r\n  // Checks that a call pushing a payment amount to the buffer is expected and valid\r\n  function validPayAmt() private pure {\r\n    // Ensure that the next function expected pushes a payment amount -\r\n    if (expected() != NextFunction.PAY_AMT)\r\n      revert('Unexpected function order - expected payment amount to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing PAYS actions -\r\n    isPaying();\r\n  }\r\n\r\n  // Checks that a call pushing an event to the buffer is expected and valid\r\n  function validEvent() private pure {\r\n    // Ensure that the next function expected pushes an event -\r\n    if (expected() != NextFunction.EMIT_LOG)\r\n      revert('Unexpected function order - expected event to be pushed');\r\n\r\n    // Ensure that the current buffer is pushing EMITS actions -\r\n    isEmitting();\r\n  }\r\n\r\n  // Begins creating a storage buffer - values and locations pushed will be committed\r\n  // to storage at the end of execution\r\n  function storing() conditions(validStoreBuff, isStoring) internal pure {\r\n    bytes4 action_req = STORES;\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\r\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the STORES action\r\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\r\n      // Increment buffer length - 0x24 plus the previous length\r\n      mstore(ptr, add(0x24, mload(ptr)))\r\n      // Set the current action being executed (STORES) -\r\n      mstore(0xe0, action_req)\r\n      // Set the expected next function - STORE_DEST\r\n      mstore(0x100, 2)\r\n      // Set a pointer to the length of the current request within the buffer\r\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Sets a passed in location to a value passed in via 'to'\r\n  function set(bytes32 _field) conditions(validStoreDest, validStoreVal) internal pure returns (bytes32) {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage destination to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - VAL_SET\r\n      mstore(0x100, 3)\r\n      // Increment STORES action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of storage slots pushed to -\r\n      mstore(0x120, add(1, mload(0x120)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n    return _field;\r\n  }\r\n\r\n  // Sets a previously-passed-in destination in storage to the value\r\n  function to(bytes32, bytes32 _val) conditions(validStoreVal, validStoreDest) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage value to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _val)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - STORE_DEST\r\n      mstore(0x100, 2)\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Sets a previously-passed-in destination in storage to the value\r\n  function to(bytes32 _field, uint _val) internal pure {\r\n    to(_field, bytes32(_val));\r\n  }\r\n\r\n  // Sets a previously-passed-in destination in storage to the value\r\n  function to(bytes32 _field, address _val) internal pure {\r\n    to(_field, bytes32(_val));\r\n  }\r\n\r\n  // Sets a previously-passed-in destination in storage to the value\r\n  function to(bytes32 _field, bool _val) internal pure {\r\n    to(\r\n      _field,\r\n      _val ? bytes32(1) : bytes32(0)\r\n    );\r\n  }\r\n\r\n  function increase(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\r\n    // Read value stored at the location in storage -\r\n    val = keccak256(_field, execID());\r\n    assembly {\r\n      val := sload(val)\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage destination to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - VAL_INC\r\n      mstore(0x100, 4)\r\n      // Increment STORES action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of storage slots pushed to -\r\n      mstore(0x120, add(1, mload(0x120)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n    return val;\r\n  }\r\n\r\n  function decrease(bytes32 _field) conditions(validStoreDest, validStoreVal) internal view returns (bytes32 val) {\r\n    // Read value stored at the location in storage -\r\n    val = keccak256(_field, execID());\r\n    assembly {\r\n      val := sload(val)\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage destination to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _field)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - VAL_DEC\r\n      mstore(0x100, 5)\r\n      // Increment STORES action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of storage slots pushed to -\r\n      mstore(0x120, add(1, mload(0x120)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n    return val;\r\n  }\r\n\r\n  function by(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\r\n    // Check the expected function type - if it is VAL_INC, perform safe-add on the value\r\n    // If it is VAL_DEC, perform safe-sub on the value\r\n    if (expected() == NextFunction.VAL_INC)\r\n      _amt = _amt.add(uint(_val));\r\n    else if (expected() == NextFunction.VAL_DEC)\r\n      _amt = uint(_val).sub(_amt);\r\n    else\r\n      revert('Expected VAL_INC or VAL_DEC');\r\n\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage value to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - STORE_DEST\r\n      mstore(0x100, 2)\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Decreases the value at some field by a maximum amount, and sets it to 0 if there will be underflow\r\n  function byMaximum(bytes32 _val, uint _amt) conditions(validStoreVal, validStoreDest) internal pure {\r\n    // Check the expected function type - if it is VAL_DEC, set the new amount to the difference of\r\n    // _val and _amt, to a minimum of 0\r\n    if (expected() == NextFunction.VAL_DEC) {\r\n      if (_amt >= uint(_val))\r\n        _amt = 0;\r\n      else\r\n        _amt = uint(_val).sub(_amt);\r\n    } else {\r\n      revert('Expected VAL_DEC');\r\n    }\r\n\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push storage value to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _amt)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - STORE_DEST\r\n      mstore(0x100, 2)\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Begins creating an event log buffer - topics and data pushed will be emitted by\r\n  // storage at the end of execution\r\n  function emitting() conditions(validEmitBuff, isEmitting) internal pure {\r\n    bytes4 action_req = EMITS;\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\r\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the EMITS action\r\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\r\n      // Increment buffer length - 0x24 plus the previous length\r\n      mstore(ptr, add(0x24, mload(ptr)))\r\n      // Set the current action being executed (EMITS) -\r\n      mstore(0xe0, action_req)\r\n      // Set the expected next function - EMIT_LOG\r\n      mstore(0x100, 6)\r\n      // Set a pointer to the length of the current request within the buffer\r\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 0 to the end of the buffer - event will have 0 topics\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 0)\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0x40, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0x40 plus the original length\r\n        mstore(ptr, add(0x40, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0x40, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0x60, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0x60 plus the original length\r\n        mstore(ptr, add(0x60, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32[1] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 1 to the end of the buffer - event will have 1 topic\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 1)\r\n      // Push topic to end of buffer\r\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0x60, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0x60 plus the original length\r\n        mstore(ptr, add(0x60, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0x60, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0x80, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0x80 plus the original length\r\n        mstore(ptr, add(0x80, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32[2] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 2 to the end of the buffer - event will have 2 topics\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 2)\r\n      // Push topics to end of buffer\r\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\r\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0x80, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0x80 plus the original length\r\n        mstore(ptr, add(0x80, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0x80, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0xa0, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0xa0 plus the original length\r\n        mstore(ptr, add(0xa0, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32[3] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 3 to the end of the buffer - event will have 3 topics\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 3)\r\n      // Push topics to end of buffer\r\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\r\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\r\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0xa0 plus the original length\r\n        mstore(ptr, add(0xa0, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0xa0, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0xc0, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0xc0 plus the original length\r\n        mstore(ptr, add(0xc0, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  function log(bytes32[4] memory _topics, bytes32 _data) conditions(validEvent, validEvent) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push 4 to the end of the buffer - event will have 4 topics\r\n      mstore(add(0x20, add(ptr, mload(ptr))), 4)\r\n      // Push topics to end of buffer\r\n      mstore(add(0x40, add(ptr, mload(ptr))), mload(_topics))\r\n      mstore(add(0x60, add(ptr, mload(ptr))), mload(add(0x20, _topics)))\r\n      mstore(add(0x80, add(ptr, mload(ptr))), mload(add(0x40, _topics)))\r\n      mstore(add(0xa0, add(ptr, mload(ptr))), mload(add(0x60, _topics)))\r\n      // If _data is zero, set data size to 0 in buffer and push -\r\n      if eq(_data, 0) {\r\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0)\r\n        // Increment buffer length - 0xc0 plus the original length\r\n        mstore(ptr, add(0xc0, mload(ptr)))\r\n      }\r\n      // If _data is not zero, set size to 0x20 and push to buffer -\r\n      if iszero(eq(_data, 0)) {\r\n        // Push data size (0x20) to the end of the buffer\r\n        mstore(add(0xc0, add(ptr, mload(ptr))), 0x20)\r\n        // Push data to the end of the buffer\r\n        mstore(add(0xe0, add(ptr, mload(ptr))), _data)\r\n        // Increment buffer length - 0xe0 plus the original length\r\n        mstore(ptr, add(0xe0, mload(ptr)))\r\n      }\r\n      // Increment EMITS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of events pushed to buffer -\r\n      mstore(0x140, add(1, mload(0x140)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Begins creating a storage buffer - destinations entered will be forwarded wei\r\n  // before the end of execution\r\n  function paying() conditions(validPayBuff, isPaying) internal pure {\r\n    bytes4 action_req = PAYS;\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push requestor to the end of buffer, as well as to the 'current action' slot -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), action_req)\r\n      // Push '0' to the end of the 4 bytes just pushed - this will be the length of the PAYS action\r\n      mstore(add(0x24, add(ptr, mload(ptr))), 0)\r\n      // Increment buffer length - 0x24 plus the previous length\r\n      mstore(ptr, add(0x24, mload(ptr)))\r\n      // Set the current action being executed (PAYS) -\r\n      mstore(0xe0, action_req)\r\n      // Set the expected next function - PAY_AMT\r\n      mstore(0x100, 8)\r\n      // Set a pointer to the length of the current request within the buffer\r\n      mstore(sub(ptr, 0x20), add(ptr, mload(ptr)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Pushes an amount of wei to forward to the buffer\r\n  function pay(uint _amount) conditions(validPayAmt, validPayDest) internal pure returns (uint) {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push payment amount to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _amount)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - PAY_DEST\r\n      mstore(0x100, 7)\r\n      // Increment PAYS action length -\r\n      mstore(\r\n        mload(sub(ptr, 0x20)),\r\n        add(1, mload(mload(sub(ptr, 0x20))))\r\n      )\r\n      // Update number of payment destinations to be pushed to -\r\n      mstore(0x160, add(1, mload(0x160)))\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n    return _amount;\r\n  }\r\n\r\n  // Push an address to forward wei to, to the buffer\r\n  function toAcc(uint, address _dest) conditions(validPayDest, validPayAmt) internal pure {\r\n    assembly {\r\n      // Get pointer to buffer length -\r\n      let ptr := add(0x20, mload(0xc0))\r\n      // Push payment destination to the end of the buffer -\r\n      mstore(add(0x20, add(ptr, mload(ptr))), _dest)\r\n      // Increment buffer length - 0x20 plus the previous length\r\n      mstore(ptr, add(0x20, mload(ptr)))\r\n      // Set the expected next function - PAY_AMT\r\n      mstore(0x100, 8)\r\n    }\r\n    // Update free memory pointer\r\n    setFreeMem();\r\n  }\r\n\r\n  // Sets the free memory pointer to point beyond all accessed memory\r\n  function setFreeMem() private pure {\r\n    assembly { mstore(0x40, msize) }\r\n  }\r\n\r\n  // Returns the enum representing the next expected function to be called -\r\n  function expected() private pure returns (NextFunction next) {\r\n    assembly { next := mload(0x100) }\r\n  }\r\n\r\n  // Returns the number of events pushed to the storage buffer -\r\n  function emitted() internal pure returns (uint num_emitted) {\r\n    if (buffPtr() == bytes32(0))\r\n      return 0;\r\n\r\n    // Load number emitted from buffer -\r\n    assembly { num_emitted := mload(0x140) }\r\n  }\r\n\r\n  // Returns the number of storage slots pushed to the storage buffer -\r\n  function stored() internal pure returns (uint num_stored) {\r\n    if (buffPtr() == bytes32(0))\r\n      return 0;\r\n\r\n    // Load number stored from buffer -\r\n    assembly { num_stored := mload(0x120) }\r\n  }\r\n\r\n  // Returns the number of payment destinations and amounts pushed to the storage buffer -\r\n  function paid() internal pure returns (uint num_paid) {\r\n    if (buffPtr() == bytes32(0))\r\n      return 0;\r\n\r\n    // Load number paid from buffer -\r\n    assembly { num_paid := mload(0x160) }\r\n  }\r\n}\r\n\r\nlibrary ArrayUtils {\r\n\r\n  function toBytes4Arr(bytes32[] memory _arr) internal pure returns (bytes4[] memory _conv) {\r\n    assembly { _conv := _arr }\r\n  }\r\n\r\n  function toAddressArr(bytes32[] memory _arr) internal pure returns (address[] memory _conv) {\r\n    assembly { _conv := _arr }\r\n  }\r\n\r\n  function toUintArr(bytes32[] memory _arr) internal pure returns (uint[] memory _conv) {\r\n    assembly { _conv := _arr }\r\n  }\r\n}\r\n\r\ninterface GetterInterface {\r\n  function read(bytes32 exec_id, bytes32 location) external view returns (bytes32 data);\r\n  function readMulti(bytes32 exec_id, bytes32[] locations) external view returns (bytes32[] data);\r\n}\r\n\r\nlibrary MintedCappedIdx {\r\n\r\n  using Contract for *;\r\n  using SafeMath for uint;\r\n  using ArrayUtils for bytes32[];\r\n\r\n  bytes32 internal constant EXEC_PERMISSIONS = keccak256('script_exec_permissions');\r\n\r\n  // Returns the storage location of a script execution address's permissions -\r\n  function execPermissions(address _exec) internal pure returns (bytes32)\r\n    { return keccak256(_exec, EXEC_PERMISSIONS); }\r\n\r\n  /// SALE ///\r\n\r\n  // Storage location of crowdsale admin address\r\n  function admin() internal pure returns (bytes32)\r\n    { return keccak256('sale_admin'); }\r\n\r\n  // Whether the crowdsale and token are configured, and the sale is ready to run\r\n  function isConfigured() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_is_configured\"); }\r\n\r\n  // Whether or not the crowdsale is post-purchase\r\n  function isFinished() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_is_completed\"); }\r\n\r\n  // Storage location of the crowdsale's start time\r\n  function startTime() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_start_time\"); }\r\n\r\n  // Storage location of the amount of time the crowdsale will take, accounting for all tiers\r\n  function totalDuration() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_total_duration\"); }\r\n\r\n  // Storage location of the amount of tokens sold in the crowdsale so far. Does not include reserved tokens\r\n  function tokensSold() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_tokens_sold\"); }\r\n\r\n  // Stores the amount of unique contributors so far in this crowdsale\r\n  function contributors() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_contributors\"); }\r\n\r\n  // Maps addresses to a boolean indicating whether or not this address has contributed\r\n  function hasContributed(address _purchaser) internal pure returns (bytes32)\r\n    { return keccak256(_purchaser, contributors()); }\r\n\r\n  /// TIERS ///\r\n\r\n  // Stores the number of tiers in the sale\r\n  function saleTierList() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_tier_list\"); }\r\n\r\n  // Stores the name of the tier\r\n  function tierName(uint _idx) internal pure returns (bytes32)\r\n    { return keccak256(_idx, \"name\", saleTierList()); }\r\n\r\n  // Stores the number of tokens that will be sold in the tier\r\n  function tierCap(uint _idx) internal pure returns (bytes32)\r\n    { return keccak256(_idx, \"cap\", saleTierList()); }\r\n\r\n  // Stores the price of a token (1 * 10^decimals units), in wei\r\n  function tierPrice(uint _idx) internal pure returns (bytes32)\r\n    { return keccak256(_idx, \"price\", saleTierList()); }\r\n\r\n  // Stores the minimum number of tokens a user must purchase for a given tier\r\n  function tierMin(uint _idx) internal pure returns (bytes32)\r\n    { return keccak256(_idx, \"minimum\", saleTierList()); }\r\n\r\n  // Stores the duration of a tier\r\n  function tierDuration(uint _idx) internal pure returns (bytes32)\r\n    { return keccak256(_idx, \"duration\", saleTierList()); }\r\n\r\n  // Whether or not the tier's duration is modifiable (before it has begin)\r\n  function tierModifiable(uint _idx) internal pure returns (bytes32)\r\n    { return keccak256(_idx, \"mod_stat\", saleTierList()); }\r\n\r\n  // Returns the storage location of the tier's whitelist status\r\n  function tierWhitelisted(uint _idx) internal pure returns (bytes32)\r\n    { return keccak256(_idx, \"wl_stat\", saleTierList()); }\r\n\r\n  // Storage location of the index of the current tier. If zero, no tier is currently active\r\n  function currentTier() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_current_tier\"); }\r\n\r\n  // Storage location of the end time of the current tier. Purchase attempts beyond this time will update the current tier (if another is available)\r\n  function currentEndsAt() internal pure returns (bytes32)\r\n    { return keccak256(\"current_tier_ends_at\"); }\r\n\r\n  // Storage location of the total number of tokens remaining for purchase in the current tier\r\n  function currentTokensRemaining() internal pure returns (bytes32)\r\n    { return keccak256(\"current_tier_tokens_remaining\"); }\r\n\r\n  /// FUNDS ///\r\n\r\n  // Storage location of team funds wallet\r\n  function wallet() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_destination_wallet\"); }\r\n\r\n  // Storage location of amount of wei raised during the crowdsale, total\r\n  function totalWeiRaised() internal pure returns (bytes32)\r\n    { return keccak256(\"sale_tot_wei_raised\"); }\r\n\r\n  /// WHITELIST ///\r\n\r\n  // Stores a tier's whitelist\r\n  function tierWhitelist(uint _idx) internal pure returns (bytes32)\r\n    { return keccak256(_idx, \"tier_whitelists\"); }\r\n\r\n  // Stores a spender's minimum token purchase amount for a given whitelisted tier\r\n  function whitelistMinTok(uint _idx, address _spender) internal pure returns (bytes32)\r\n    { return keccak256(_spender, \"min_tok\", tierWhitelist(_idx)); }\r\n\r\n  // Stores a spender's maximum number of tokens allowed to be purchased\r\n  function whitelistMaxTok(uint _idx, address _spender) internal pure returns (bytes32)\r\n    { return keccak256(_spender, \"max_tok\", tierWhitelist(_idx)); }\r\n\r\n  /// TOKEN ///\r\n\r\n  // Storage location for token name\r\n  function tokenName() internal pure returns (bytes32)\r\n    { return keccak256(\"token_name\"); }\r\n\r\n  // Storage location for token ticker symbol\r\n  function tokenSymbol() internal pure returns (bytes32)\r\n    { return keccak256(\"token_symbol\"); }\r\n\r\n  // Storage location for token decimals\r\n  function tokenDecimals() internal pure returns (bytes32)\r\n    { return keccak256(\"token_decimals\"); }\r\n\r\n  // Storage location for token totalSupply\r\n  function tokenTotalSupply() internal pure returns (bytes32)\r\n    { return keccak256(\"token_total_supply\"); }\r\n\r\n  // Storage seed for user balances mapping\r\n  bytes32 internal constant TOKEN_BALANCES = keccak256(\"token_balances\");\r\n\r\n  function balances(address _owner) internal pure returns (bytes32)\r\n    { return keccak256(_owner, TOKEN_BALANCES); }\r\n\r\n  // Storage seed for user allowances mapping\r\n  bytes32 internal constant TOKEN_ALLOWANCES = keccak256(\"token_allowances\");\r\n\r\n  function allowed(address _owner, address _spender) internal pure returns (bytes32)\r\n    { return keccak256(_spender, keccak256(_owner, TOKEN_ALLOWANCES)); }\r\n\r\n  // Storage seed for token 'transfer agent' status for any address\r\n  // Transfer agents can transfer tokens, even if the crowdsale has not yet been finalized\r\n  bytes32 internal constant TOKEN_TRANSFER_AGENTS = keccak256(\"token_transfer_agents\");\r\n\r\n  function transferAgents(address _agent) internal pure returns (bytes32)\r\n    { return keccak256(_agent, TOKEN_TRANSFER_AGENTS); }\r\n\r\n  // Whether or not the token is unlocked for transfers\r\n  function tokensUnlocked() internal pure returns (bytes32)\r\n    { return keccak256('sale_tokens_unlocked'); }\r\n\r\n  /// RESERVED TOKENS ///\r\n\r\n  // Stores the number of addresses for which tokens are reserved\r\n  function reservedDestinations() internal pure returns (bytes32)\r\n    { return keccak256(\"reserved_token_dest_list\"); }\r\n\r\n  // Stores the index of an address in the reservedDestinations list (1-indexed)\r\n  function destIndex(address _destination) internal pure returns (bytes32)\r\n    { return keccak256(_destination, \"index\", reservedDestinations()); }\r\n\r\n  // Stores the number of tokens reserved for a destination\r\n  function destTokens(address _destination) internal pure returns (bytes32)\r\n    { return keccak256(_destination, \"numtokens\", reservedDestinations()); }\r\n\r\n  // Stores the number of percent of tokens sold reserved for a destination\r\n  function destPercent(address _destination) internal pure returns (bytes32)\r\n    { return keccak256(_destination, \"numpercent\", reservedDestinations()); }\r\n\r\n  // Stores the number of decimals in the previous percentage (2 are added by default)\r\n  function destPrecision(address _destination) internal pure returns (bytes32)\r\n    { return keccak256(_destination, \"precision\", reservedDestinations()); }\r\n\r\n  /*\r\n  Creates a crowdsale with initial conditions. The admin should now initialize the crowdsale's token, as well\r\n  as any additional tiers of the crowdsale that will exist, followed by finalizing the initialization of the crowdsale.\r\n\r\n  @param _team_wallet: The team funds wallet, where crowdsale purchases are forwarded\r\n  @param _start_time: The start time of the initial tier of the crowdsale\r\n  @param _initial_tier_name: The name of the initial tier of the crowdsale\r\n  @param _initial_tier_price: The price of each token purchased in wei, for the initial crowdsale tier\r\n  @param _initial_tier_duration: The duration of the initial tier of the crowdsale\r\n  @param _initial_tier_token_sell_cap: The maximum number of tokens that can be sold during the initial tier\r\n  @param _initial_tier_min_purchase: The minimum number of tokens that must be purchased by a user in the initial tier\r\n  @param _initial_tier_is_whitelisted: Whether the initial tier of the crowdsale requires an address be whitelisted for successful purchase\r\n  @param _initial_tier_duration_is_modifiable: Whether the initial tier of the crowdsale has a modifiable duration\r\n  @param _admin: A privileged address which is able to complete the crowdsale initialization process\r\n  */\r\n  function init(\r\n    address _team_wallet,\r\n    uint _start_time,\r\n    bytes32 _initial_tier_name,\r\n    uint _initial_tier_price,\r\n    uint _initial_tier_duration,\r\n    uint _initial_tier_token_sell_cap,\r\n    uint _initial_tier_min_purchase,\r\n    bool _initial_tier_is_whitelisted,\r\n    bool _initial_tier_duration_is_modifiable,\r\n    address _admin\r\n  ) external view {\r\n    // Begin execution - we are initializing an instance of this application\r\n    Contract.initialize();\r\n\r\n    // Ensure valid input\r\n    if (\r\n      _team_wallet == 0\r\n      || _initial_tier_price == 0\r\n      || _start_time < now\r\n      || _start_time + _initial_tier_duration <= _start_time\r\n      || _initial_tier_token_sell_cap == 0\r\n      || _admin == address(0)\r\n    ) revert('improper initialization');\r\n\r\n    // Set up STORES action requests -\r\n    Contract.storing();\r\n    // Authorize sender as an executor for this instance -\r\n    Contract.set(execPermissions(msg.sender)).to(true);\r\n    // Store admin address, team wallet, initial tier duration, and sale start time\r\n    Contract.set(admin()).to(_admin);\r\n    Contract.set(wallet()).to(_team_wallet);\r\n    Contract.set(totalDuration()).to(_initial_tier_duration);\r\n    Contract.set(startTime()).to(_start_time);\r\n    // Store initial crowdsale tier list length and initial tier information\r\n    Contract.set(saleTierList()).to(uint(1));\r\n    // Tier name\r\n    Contract.set(tierName(uint(0))).to(_initial_tier_name);\r\n    // Tier token sell cap\r\n    Contract.set(tierCap(uint(0))).to(_initial_tier_token_sell_cap);\r\n    // Tier purchase price\r\n    Contract.set(tierPrice(uint(0))).to(_initial_tier_price);\r\n    // Tier active duration\r\n    Contract.set(tierDuration(uint(0))).to(_initial_tier_duration);\r\n    // Tier minimum purchase size\r\n    Contract.set(tierMin(uint(0))).to(_initial_tier_min_purchase);\r\n    // Whether this tier's duration is modifiable prior to its start time\r\n    Contract.set(tierModifiable(uint(0))).to(_initial_tier_duration_is_modifiable);\r\n    // Whether this tier requires an address be whitelisted to complete token purchase\r\n    Contract.set(tierWhitelisted(uint(0))).to(_initial_tier_is_whitelisted);\r\n\r\n    // Store current crowdsale tier (offset by 1)\r\n    Contract.set(currentTier()).to(uint(1));\r\n    // Store current tier end time\r\n    Contract.set(currentEndsAt()).to(_initial_tier_duration.add(_start_time));\r\n    // Store current tier tokens remaining\r\n    Contract.set(currentTokensRemaining()).to(_initial_tier_token_sell_cap);\r\n\r\n    Contract.commit();\r\n  }\r\n\r\n  /// CROWDSALE GETTERS ///\r\n\r\n  // Returns the address of the admin of the crowdsale\r\n  function getAdmin(address _storage, bytes32 _exec_id) external view returns (address)\r\n    { return address(GetterInterface(_storage).read(_exec_id, admin())); }\r\n\r\n  /*\r\n  Returns basic information on a sale\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return wei_raised: The amount of wei raised in the crowdsale so far\r\n  @return team_wallet: The address to which funds are forwarded during this crowdsale\r\n  @return is_initialized: Whether or not the crowdsale has been completely initialized by the admin\r\n  @return is_finalized: Whether or not the crowdsale has been completely finalized by the admin\r\n  */\r\n  function getCrowdsaleInfo(address _storage, bytes32 _exec_id) external view\r\n  returns (uint wei_raised, address team_wallet, bool is_initialized, bool is_finalized) {\r\n\r\n    GetterInterface target = GetterInterface(_storage);\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](4);\r\n\r\n    arr_indices[0] = totalWeiRaised();\r\n    arr_indices[1] = wallet();\r\n    arr_indices[2] = isConfigured();\r\n    arr_indices[3] = isFinished();\r\n\r\n    bytes32[] memory read_values = target.readMulti(_exec_id, arr_indices);\r\n\r\n    // Get returned data -\r\n    wei_raised = uint(read_values[0]);\r\n    team_wallet = address(read_values[1]);\r\n    is_initialized = (read_values[2] == 0 ? false : true);\r\n    is_finalized = (read_values[3] == 0 ? false : true);\r\n  }\r\n\r\n  /*\r\n  Returns true if all tiers have been completely sold out\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return is_crowdsale_full: Whether or not the total number of tokens to sell in the crowdsale has been reached\r\n  @return max_sellable: The total number of tokens that can be sold in the crowdsale\r\n  */\r\n  function isCrowdsaleFull(address _storage, bytes32 _exec_id) external view returns (bool is_crowdsale_full, uint max_sellable) {\r\n    GetterInterface target = GetterInterface(_storage);\r\n\r\n    bytes32[] memory initial_arr = new bytes32[](2);\r\n    // Push crowdsale tier list length and total tokens sold storage locations to buffer\r\n    initial_arr[0] = saleTierList();\r\n    initial_arr[1] = tokensSold();\r\n    // Read from storage\r\n    uint[] memory read_values = target.readMulti(_exec_id, initial_arr).toUintArr();\r\n\r\n    // Get number of tiers and tokens sold\r\n    uint num_tiers = read_values[0];\r\n    uint _tokens_sold = read_values[1];\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](num_tiers);\r\n    // Loop through tier cap locations, and add each to the calldata buffer\r\n    for (uint i = 0; i < num_tiers; i++)\r\n      arr_indices[i] = tierCap(i);\r\n\r\n    // Read from storage\r\n    read_values = target.readMulti(_exec_id, arr_indices).toUintArr();\r\n    // Ensure correct return length\r\n    assert(read_values.length == num_tiers);\r\n\r\n    // Loop through returned values, and get the sum of all tier token sell caps\r\n    for (i = 0; i < read_values.length; i++)\r\n      max_sellable += read_values[i];\r\n\r\n    // Get return value\r\n    is_crowdsale_full = (_tokens_sold >= max_sellable ? true : false);\r\n  }\r\n\r\n  // Returns the number of unique contributors to a crowdsale\r\n  function getCrowdsaleUniqueBuyers(address _storage, bytes32 _exec_id) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, contributors())); }\r\n\r\n  /*\r\n  Returns the start and end time of the crowdsale\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return start_time: The start time of the first tier of a crowdsale\r\n  @return end_time: The time at which the crowdsale ends\r\n  */\r\n  function getCrowdsaleStartAndEndTimes(address _storage, bytes32 _exec_id) external view returns (uint start_time, uint end_time) {\r\n    bytes32[] memory arr_indices = new bytes32[](2);\r\n    arr_indices[0] = startTime();\r\n    arr_indices[1] = totalDuration();\r\n\r\n    // Read from storage\r\n    uint[] memory read_values = GetterInterface(_storage).readMulti(_exec_id, arr_indices).toUintArr();\r\n\r\n    // Get return values\r\n    start_time = read_values[0];\r\n    end_time = start_time + read_values[1];\r\n  }\r\n\r\n  /*\r\n  Returns information on the current crowdsale tier\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return tier_name: The name of the current tier\r\n  @return tier_index: The current tier's index in the crowdsale_tiers() list\r\n  @return tier_ends_at: The time at which purcahses for the current tier are forcibly locked\r\n  @return tier_tokens_remaining: The amount of tokens remaining to be purchased in the current tier\r\n  @return tier_price: The price of each token purchased this tier, in wei\r\n  @return tier_min: The minimum amount of tokens that much be purchased by an investor this tier\r\n  @return duration_is_modifiable: Whether the crowdsale admin can update the duration of this tier before it starts\r\n  @return is_whitelisted: Whether an address must be whitelisted to participate in this tier\r\n  */\r\n  function getCurrentTierInfo(address _storage, bytes32 _exec_id) external view\r\n  returns (bytes32 tier_name, uint tier_index, uint tier_ends_at, uint tier_tokens_remaining, uint tier_price, uint tier_min, bool duration_is_modifiable, bool is_whitelisted) {\r\n\r\n    bytes32[] memory initial_arr = new bytes32[](4);\r\n    // Push current tier expiration time, current tier index, and current tier tokens remaining storage locations to calldata buffer\r\n    initial_arr[0] = currentEndsAt();\r\n    initial_arr[1] = currentTier();\r\n    initial_arr[2] = currentTokensRemaining();\r\n    initial_arr[3] = saleTierList();\r\n    // Read from storage and store return in buffer\r\n    uint[] memory read_values = GetterInterface(_storage).readMulti(_exec_id, initial_arr).toUintArr();\r\n    // Ensure correct return length\r\n    assert(read_values.length == 4);\r\n\r\n    // If the returned index was 0, current tier does not exist: return now\r\n    if (read_values[1] == 0)\r\n      return;\r\n\r\n    // Get returned values -\r\n    tier_ends_at = read_values[0];\r\n    // Indices are stored as 1 + (actual index), to avoid conflicts with a default 0 value\r\n    tier_index = read_values[1] - 1;\r\n    tier_tokens_remaining = read_values[2];\r\n    uint num_tiers = read_values[3];\r\n    bool updated_tier;\r\n\r\n    // If it is beyond the tier's end time, loop through tiers until the current one is found\r\n    while (now >= tier_ends_at && ++tier_index < num_tiers) {\r\n      tier_ends_at += uint(GetterInterface(_storage).read(_exec_id, tierDuration(tier_index)));\r\n      updated_tier = true;\r\n    }\r\n\r\n    // If we have passed the last tier, return default values\r\n    if (tier_index >= num_tiers)\r\n      return (0, 0, 0, 0, 0, 0, false, false);\r\n\r\n    initial_arr = new bytes32[](6);\r\n    initial_arr[0] = tierName(tier_index);\r\n    initial_arr[1] = tierPrice(tier_index);\r\n    initial_arr[2] = tierModifiable(tier_index);\r\n    initial_arr[3] = tierWhitelisted(tier_index);\r\n    initial_arr[4] = tierMin(tier_index);\r\n    initial_arr[5] = tierCap(tier_index);\r\n\r\n    // Read from storage and get return values\r\n    read_values = GetterInterface(_storage).readMulti(_exec_id, initial_arr).toUintArr();\r\n\r\n    // Ensure correct return length\r\n    assert(read_values.length == 6);\r\n\r\n    tier_name = bytes32(read_values[0]);\r\n    tier_price = read_values[1];\r\n    duration_is_modifiable = (read_values[2] == 0 ? false : true);\r\n    is_whitelisted = (read_values[3] == 0 ? false : true);\r\n    tier_min = read_values[4];\r\n    if (updated_tier)\r\n      tier_tokens_remaining = read_values[5];\r\n  }\r\n\r\n  /*\r\n  Returns information on a given tier\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @param _index: The index of the tier in the crowdsale tier list. Input index should be like a normal array index (lowest index: 0)\r\n  @return tier_name: The name of the returned tier\r\n  @return tier_sell_cap: The amount of tokens designated to be sold during this tier\r\n  @return tier_price: The price of each token in wei for this tier\r\n  @return tier_min: The minimum amount of tokens that much be purchased by an investor this tier\r\n  @return tier_duration: The duration of the given tier\r\n  @return duration_is_modifiable: Whether the crowdsale admin can change the duration of this tier prior to its start time\r\n  @return is_whitelisted: Whether an address must be whitelisted to participate in this tier\r\n  */\r\n  function getCrowdsaleTier(address _storage, bytes32 _exec_id, uint _index) external view\r\n  returns (bytes32 tier_name, uint tier_sell_cap, uint tier_price, uint tier_min, uint tier_duration, bool duration_is_modifiable, bool is_whitelisted) {\r\n    GetterInterface target = GetterInterface(_storage);\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](7);\r\n    // Push tier name, sell cap, duration, and modifiable status storage locations to buffer\r\n    arr_indices[0] = tierName(_index);\r\n    arr_indices[1] = tierCap(_index);\r\n    arr_indices[2] = tierPrice(_index);\r\n    arr_indices[3] = tierDuration(_index);\r\n    arr_indices[4] = tierModifiable(_index);\r\n    arr_indices[5] = tierWhitelisted(_index);\r\n    arr_indices[6] = tierMin(_index);\r\n    // Read from storage and store return in buffer\r\n    bytes32[] memory read_values = target.readMulti(_exec_id, arr_indices);\r\n    // Ensure correct return length\r\n    assert(read_values.length == 7);\r\n\r\n    // Get returned values -\r\n    tier_name = read_values[0];\r\n    tier_sell_cap = uint(read_values[1]);\r\n    tier_price = uint(read_values[2]);\r\n    tier_duration = uint(read_values[3]);\r\n    duration_is_modifiable = (read_values[4] == 0 ? false : true);\r\n    is_whitelisted = (read_values[5] == 0 ? false : true);\r\n    tier_min = uint(read_values[6]);\r\n  }\r\n\r\n  /*\r\n  Returns the maximum amount of wei to raise, as well as the total amount of tokens that can be sold\r\n\r\n  @param _storage: The storage address of the crowdsale application\r\n  @param _exec_id: The execution id of the application\r\n  @return wei_raise_cap: The maximum amount of wei to raise\r\n  @return total_sell_cap: The maximum amount of tokens to sell\r\n  */\r\n  function getCrowdsaleMaxRaise(address _storage, bytes32 _exec_id) external view returns (uint wei_raise_cap, uint total_sell_cap) {\r\n    GetterInterface target = GetterInterface(_storage);\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](3);\r\n    // Push crowdsale tier list length, token decimals, and token name storage locations to buffer\r\n    arr_indices[0] = saleTierList();\r\n    arr_indices[1] = tokenDecimals();\r\n    arr_indices[2] = tokenName();\r\n\r\n    // Read from storage\r\n    uint[] memory read_values = target.readMulti(_exec_id, arr_indices).toUintArr();\r\n    // Ensure correct return length\r\n    assert(read_values.length == 3);\r\n\r\n    // Get number of crowdsale tiers\r\n    uint num_tiers = read_values[0];\r\n    // Get number of token decimals\r\n    uint num_decimals = read_values[1];\r\n\r\n    // If the token has not been set, return\r\n    if (read_values[2] == 0)\r\n      return (0, 0);\r\n\r\n    // Overwrite previous buffer - push exec id, data read offset, and read size to buffer\r\n    bytes32[] memory last_arr = new bytes32[](2 * num_tiers);\r\n    // Loop through tiers and get sell cap and purchase price for each tier\r\n    for (uint i = 0; i < 2 * num_tiers; i += 2) {\r\n      last_arr[i] = tierCap(i / 2);\r\n      last_arr[i + 1] = tierPrice(i / 2);\r\n    }\r\n\r\n    // Read from storage\r\n    read_values = target.readMulti(_exec_id, last_arr).toUintArr();\r\n    // Ensure correct return length\r\n    assert(read_values.length == 2 * num_tiers);\r\n\r\n    // Loop through and get wei raise cap and token sell cap\r\n    for (i = 0; i < read_values.length; i+=2) {\r\n      total_sell_cap += read_values[i];\r\n      // Increase maximum wei able to be raised - (tier token sell cap) * (tier price in wei) / (10 ^ decimals)\r\n      wei_raise_cap += (read_values[i] * read_values[i + 1]) / (10 ** num_decimals);\r\n    }\r\n  }\r\n\r\n  /*\r\n  Returns a list of the named tiers of the crowdsale\r\n\r\n  @param _storage: The storage address of the crowdsale application\r\n  @param _exec_id: The execution id of the application\r\n  @return crowdsale_tiers: A list of each tier of the crowdsale\r\n  */\r\n  function getCrowdsaleTierList(address _storage, bytes32 _exec_id) external view returns (bytes32[] memory crowdsale_tiers) {\r\n    GetterInterface target = GetterInterface(_storage);\r\n    // Read from storage and get list length\r\n    uint list_length = uint(target.read(_exec_id, saleTierList()));\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](list_length);\r\n    // Loop over each tier name list location and add to buffer\r\n    for (uint i = 0; i < list_length; i++)\r\n      arr_indices[i] = tierName(i);\r\n\r\n    // Read from storage and return\r\n    crowdsale_tiers = target.readMulti(_exec_id, arr_indices);\r\n  }\r\n\r\n  /*\r\n  Loops through all tiers and their durations, and returns the passed-in index's start and end dates\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @param _index: The index of the tier in the crowdsale tier list. Input index should be like a normal array index (lowest index: 0)\r\n  @return tier_start: The time when the given tier starts\r\n  @return tier_end: The time at which the given tier ends\r\n  */\r\n  function getTierStartAndEndDates(address _storage, bytes32 _exec_id, uint _index) external view returns (uint tier_start, uint tier_end) {\r\n    GetterInterface target = GetterInterface(_storage);\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](3 + _index);\r\n\r\n    // Add crowdsale tier list length and crowdsale start time to buffer\r\n    arr_indices[0] = saleTierList();\r\n    arr_indices[1] = startTime();\r\n\r\n    for (uint i = 0; i <= _index; i++)\r\n      arr_indices[2 + i] = tierDuration(i);\r\n\r\n    // Read from storage and store return in buffer\r\n    uint[] memory read_values = target.readMulti(_exec_id, arr_indices).toUintArr();\r\n    // Ensure correct return length\r\n    assert(read_values.length == 3 + _index);\r\n\r\n    // Check that the passed-in index is within the range of the tier list\r\n    if (read_values[0] <= _index)\r\n      return (0, 0);\r\n\r\n    // Get returned start time, then loop through each returned duration and get the start time for the tier\r\n    tier_start = read_values[1];\r\n    for (i = 0; i < _index; i++)\r\n      tier_start += read_values[2 + i];\r\n\r\n    // Get the tier end time - start time plus the duration of the tier, the last read value in the list\r\n    tier_end = tier_start + read_values[read_values.length - 1];\r\n  }\r\n\r\n  // Returns the number of tokens sold so far this crowdsale\r\n  function getTokensSold(address _storage, bytes32 _exec_id) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, tokensSold())); }\r\n\r\n  /*\r\n  Returns whitelist information for a given buyer\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @param _tier_index: The index of the tier about which the whitelist information will be pulled\r\n  @param _buyer: The address of the user whose whitelist status will be returned\r\n  @return minimum_purchase_amt: The minimum ammount of tokens the buyer must purchase\r\n  @return max_tokens_remaining: The maximum amount of tokens able to be purchased by the user in this tier\r\n  */\r\n  function getWhitelistStatus(address _storage, bytes32 _exec_id, uint _tier_index, address _buyer) external view\r\n  returns (uint minimum_purchase_amt, uint max_tokens_remaining) {\r\n    GetterInterface target = GetterInterface(_storage);\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](2);\r\n    // Push whitelist minimum contribution location to buffer\r\n    arr_indices[0] = whitelistMinTok(_tier_index, _buyer);\r\n    // Push whitlist maximum spend amount remaining location to buffer\r\n    arr_indices[1] = whitelistMaxTok(_tier_index, _buyer);\r\n\r\n    // Read from storage and return\r\n    uint[] memory read_values = target.readMulti(_exec_id, arr_indices).toUintArr();\r\n    // Ensure correct return length\r\n    assert(read_values.length == 2);\r\n\r\n    minimum_purchase_amt = read_values[0];\r\n    max_tokens_remaining = read_values[1];\r\n  }\r\n\r\n  /*\r\n  Returns the list of whitelisted buyers for a given tier\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @param _tier_index: The index of the tier about which the whitelist information will be pulled\r\n  @return num_whitelisted: The length of the tier's whitelist array\r\n  @return whitelist: The tier's whitelisted addresses\r\n  */\r\n  function getTierWhitelist(address _storage, bytes32 _exec_id, uint _tier_index) external view returns (uint num_whitelisted, address[] memory whitelist) {\r\n    // Read from storage and get returned tier whitelist length\r\n    num_whitelisted = uint(GetterInterface(_storage).read(_exec_id, tierWhitelist(_tier_index)));\r\n\r\n    // If there are no whitelisted addresses, return\r\n    if (num_whitelisted == 0)\r\n      return;\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](num_whitelisted);\r\n    // Loop through the number of whitelisted addresses, and push each to the calldata buffer to be read from storage\r\n    for (uint i = 0; i < num_whitelisted; i++)\r\n      arr_indices[i] = bytes32(32 + (32 * i) + uint(tierWhitelist(_tier_index)));\r\n\r\n    // Read from storage and return\r\n    whitelist = GetterInterface(_storage).readMulti(_exec_id, arr_indices).toAddressArr();\r\n  }\r\n\r\n  /// TOKEN GETTERS ///\r\n\r\n  // Returns the token balance of an address\r\n  function balanceOf(address _storage, bytes32 _exec_id, address _owner) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, balances(_owner))); }\r\n\r\n  // Returns the amount of tokens a spender may spend on an owner's behalf\r\n  function allowance(address _storage, bytes32 _exec_id, address _owner, address _spender) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, allowed(_owner, _spender))); }\r\n\r\n  // Returns the number of display decimals for a token\r\n  function decimals(address _storage, bytes32 _exec_id) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, tokenDecimals())); }\r\n\r\n  // Returns the total token supply\r\n  function totalSupply(address _storage, bytes32 _exec_id) external view returns (uint)\r\n    { return uint(GetterInterface(_storage).read(_exec_id, tokenTotalSupply())); }\r\n\r\n  // Returns the token's name\r\n  function name(address _storage, bytes32 _exec_id) external view returns (bytes32)\r\n    { return GetterInterface(_storage).read(_exec_id, tokenName()); }\r\n\r\n  // Returns token's symbol\r\n  function symbol(address _storage, bytes32 _exec_id) external view returns (bytes32)\r\n    { return GetterInterface(_storage).read(_exec_id, tokenSymbol()); }\r\n\r\n  /*\r\n  Returns general information on a token - name, symbol, decimals, and total supply\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under which storage for this instance is located\r\n  @return token_name: The name of the token\r\n  @return token_symbol: The token ticker symbol\r\n  @return token_decimals: The display decimals for the token\r\n  @return total_supply: The total supply of the token\r\n  */\r\n  function getTokenInfo(address _storage, bytes32 _exec_id) external view\r\n  returns (bytes32 token_name, bytes32 token_symbol, uint token_decimals, uint total_supply) {\r\n    //Set up bytes32 array to hold storage seeds\r\n    bytes32[] memory seed_arr = new bytes32[](4);\r\n\r\n    //Assign locations of array to respective seeds\r\n    seed_arr[0] = tokenName();\r\n    seed_arr[1] = tokenSymbol();\r\n    seed_arr[2] = tokenDecimals();\r\n    seed_arr[3] = tokenTotalSupply();\r\n\r\n    //Read and return values from storage\r\n    bytes32[] memory values_arr = GetterInterface(_storage).readMulti(_exec_id, seed_arr);\r\n\r\n    //Assign values to return params\r\n    token_name = values_arr[0];\r\n    token_symbol = values_arr[1];\r\n    token_decimals = uint(values_arr[2]);\r\n    total_supply = uint(values_arr[3]);\r\n  }\r\n\r\n  // Returns whether or not an address is a transfer agent, meaning they can transfer tokens before the crowdsale is finished\r\n  function getTransferAgentStatus(address _storage, bytes32 _exec_id, address _agent) external view returns (bool)\r\n    { return GetterInterface(_storage).read(_exec_id, transferAgents(_agent)) != 0 ? true : false; }\r\n\r\n  /*\r\n  Returns information on a reserved token address (the crowdsale admin can set reserved tokens for addresses before initializing the crowdsale)\r\n\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under storage for this app instance is located\r\n  @return num_destinations: The length of the crowdsale's reserved token destination array\r\n  @return reserved_destinations: A list of the addresses which have reserved tokens or percents\r\n  */\r\n  function getReservedTokenDestinationList(address _storage, bytes32 _exec_id) external view\r\n  returns (uint num_destinations, address[] reserved_destinations) {\r\n    // Read reserved destination list length from storage\r\n    num_destinations = uint(GetterInterface(_storage).read(_exec_id, reservedDestinations()));\r\n\r\n    // If num_destinations is 0, return now\r\n    if (num_destinations == 0)\r\n      return (num_destinations, reserved_destinations);\r\n\r\n    /// Loop through each list in storage, and get each address -\r\n\r\n    bytes32[] memory arr_indices = new bytes32[](num_destinations);\r\n    // Add each destination index location to calldata\r\n    for (uint i = 1; i <= num_destinations; i++)\r\n      arr_indices[i - 1] = bytes32((32 * i) + uint(reservedDestinations()));\r\n\r\n    // Read from storage, and return data to buffer\r\n    reserved_destinations = GetterInterface(_storage).readMulti(_exec_id, arr_indices).toAddressArr();\r\n  }\r\n\r\n  /*\r\n  Returns information on a reserved token address (the crowdsale admin can set reserved tokens for addresses before initializing the crowdsale)\r\n  @param _storage: The address where application storage is located\r\n  @param _exec_id: The application execution id under storage for this app instance is located\r\n  @param _destination: The address about which reserved token information will be pulled\r\n  @return destination_list_index: The index in the reserved token destination list where this address is found, plus 1. If zero, destination has no reserved tokens\r\n  @return num_tokens: The number of tokens reserved for this address\r\n  @return num_percent: The percent of tokens sold during the crowdsale reserved for this address\r\n  @return percent_decimals: The number of decimals in the above percent reserved - used to calculate with precision\r\n  */\r\n  function getReservedDestinationInfo(address _storage, bytes32 _exec_id, address _destination) external view\r\n  returns (uint destination_list_index, uint num_tokens, uint num_percent, uint percent_decimals) {\r\n    bytes32[] memory arr_indices = new bytes32[](4);\r\n    arr_indices[0] = destIndex(_destination);\r\n    arr_indices[1] = destTokens(_destination);\r\n    arr_indices[2] = destPercent(_destination);\r\n    arr_indices[3] = destPrecision(_destination);\r\n\r\n    // Read from storage, and return data to buffer\r\n    bytes32[] memory read_values = GetterInterface(_storage).readMulti(_exec_id, arr_indices);\r\n\r\n    // Get returned values -\r\n    destination_list_index = uint(read_values[0]);\r\n    // If the returned list index for the destination is 0, destination is not in list\r\n    if (destination_list_index == 0)\r\n      return;\r\n    destination_list_index--;\r\n    num_tokens = uint(read_values[1]);\r\n    num_percent = uint(read_values[2]);\r\n    percent_decimals = uint(read_values[3]);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_tier_index\",\"type\":\"uint256\"}],\"name\":\"getTierWhitelist\",\"outputs\":[{\"name\":\"num_whitelisted\",\"type\":\"uint256\"},{\"name\":\"whitelist\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_tier_index\",\"type\":\"uint256\"},{\"name\":\"_buyer\",\"type\":\"address\"}],\"name\":\"getWhitelistStatus\",\"outputs\":[{\"name\":\"minimum_purchase_amt\",\"type\":\"uint256\"},{\"name\":\"max_tokens_remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getTierStartAndEndDates\",\"outputs\":[{\"name\":\"tier_start\",\"type\":\"uint256\"},{\"name\":\"tier_end\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getCrowdsaleTier\",\"outputs\":[{\"name\":\"tier_name\",\"type\":\"bytes32\"},{\"name\":\"tier_sell_cap\",\"type\":\"uint256\"},{\"name\":\"tier_price\",\"type\":\"uint256\"},{\"name\":\"tier_min\",\"type\":\"uint256\"},{\"name\":\"tier_duration\",\"type\":\"uint256\"},{\"name\":\"duration_is_modifiable\",\"type\":\"bool\"},{\"name\":\"is_whitelisted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleStartAndEndTimes\",\"outputs\":[{\"name\":\"start_time\",\"type\":\"uint256\"},{\"name\":\"end_time\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleMaxRaise\",\"outputs\":[{\"name\":\"wei_raise_cap\",\"type\":\"uint256\"},{\"name\":\"total_sell_cap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_agent\",\"type\":\"address\"}],\"name\":\"getTransferAgentStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_destination\",\"type\":\"address\"}],\"name\":\"getReservedDestinationInfo\",\"outputs\":[{\"name\":\"destination_list_index\",\"type\":\"uint256\"},{\"name\":\"num_tokens\",\"type\":\"uint256\"},{\"name\":\"num_percent\",\"type\":\"uint256\"},{\"name\":\"percent_decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"isCrowdsaleFull\",\"outputs\":[{\"name\":\"is_crowdsale_full\",\"type\":\"bool\"},{\"name\":\"max_sellable\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleUniqueBuyers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getReservedTokenDestinationList\",\"outputs\":[{\"name\":\"num_destinations\",\"type\":\"uint256\"},{\"name\":\"reserved_destinations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getTokenInfo\",\"outputs\":[{\"name\":\"token_name\",\"type\":\"bytes32\"},{\"name\":\"token_symbol\",\"type\":\"bytes32\"},{\"name\":\"token_decimals\",\"type\":\"uint256\"},{\"name\":\"total_supply\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleInfo\",\"outputs\":[{\"name\":\"wei_raised\",\"type\":\"uint256\"},{\"name\":\"team_wallet\",\"type\":\"address\"},{\"name\":\"is_initialized\",\"type\":\"bool\"},{\"name\":\"is_finalized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCurrentTierInfo\",\"outputs\":[{\"name\":\"tier_name\",\"type\":\"bytes32\"},{\"name\":\"tier_index\",\"type\":\"uint256\"},{\"name\":\"tier_ends_at\",\"type\":\"uint256\"},{\"name\":\"tier_tokens_remaining\",\"type\":\"uint256\"},{\"name\":\"tier_price\",\"type\":\"uint256\"},{\"name\":\"tier_min\",\"type\":\"uint256\"},{\"name\":\"duration_is_modifiable\",\"type\":\"bool\"},{\"name\":\"is_whitelisted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_storage\",\"type\":\"address\"},{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getCrowdsaleTierList\",\"outputs\":[{\"name\":\"crowdsale_tiers\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_team_wallet\",\"type\":\"address\"},{\"name\":\"_start_time\",\"type\":\"uint256\"},{\"name\":\"_initial_tier_name\",\"type\":\"bytes32\"},{\"name\":\"_initial_tier_price\",\"type\":\"uint256\"},{\"name\":\"_initial_tier_duration\",\"type\":\"uint256\"},{\"name\":\"_initial_tier_token_sell_cap\",\"type\":\"uint256\"},{\"name\":\"_initial_tier_min_purchase\",\"type\":\"uint256\"},{\"name\":\"_initial_tier_is_whitelisted\",\"type\":\"bool\"},{\"name\":\"_initial_tier_duration_is_modifiable\",\"type\":\"bool\"},{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"MintedCappedIdx","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6b68eb4e9f9a1588a16666b1565690da098269ff0ac0cd47ba54ce4b6cf81320"}]}