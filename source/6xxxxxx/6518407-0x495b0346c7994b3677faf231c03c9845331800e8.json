{"status":"1","message":"OK","result":[{"SourceCode":"contract AirSwap {\r\n    function fill(\r\n      address makerAddress,\r\n      uint makerAmount,\r\n      address makerToken,\r\n      address takerAddress,\r\n      uint takerAmount,\r\n      address takerToken,\r\n      uint256 expiration,\r\n      uint256 nonce,\r\n      uint8 v,\r\n      bytes32 r,\r\n      bytes32 s\r\n    ) payable {}\r\n}\r\n\r\ncontract P3D {\r\n  uint256 public stakingRequirement;\r\n  function buy(address _referredBy) public payable returns(uint256) {}\r\n  function balanceOf(address _customerAddress) view public returns(uint256) {}\r\n  function exit() public {}\r\n  function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) {}\r\n  function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) { }\r\n  function myDividends(bool _includeReferralBonus) public view returns(uint256) {}\r\n  function withdraw() public {}\r\n  function totalSupply() public view returns(uint256);\r\n}\r\n\r\ncontract Pool {\r\n  P3D constant public p3d = P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n\r\n  address public owner;\r\n\r\n  event Contribution(address indexed caller, address indexed receiver, uint256 contribution, uint256 divs);\r\n\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  function() external payable {\r\n    // contract accepts donations\r\n    if (msg.sender != address(p3d)) {\r\n      p3d.buy.value(msg.value)(address(0));\r\n      emit Contribution(msg.sender, address(0), msg.value, 0);\r\n    }\r\n  }\r\n\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  mapping (address => bool) public approved;\r\n\r\n  function approve(address _addr) external onlyOwner() {\r\n    approved[_addr] = true;\r\n  }\r\n\r\n  function remove(address _addr) external onlyOwner() {\r\n    approved[_addr] = false;\r\n  }\r\n\r\n  function changeOwner(address _newOwner) external onlyOwner() {\r\n    owner = _newOwner;\r\n  }\r\n\r\n  function contribute(address _masternode, address _receiver) external payable {\r\n    // buy p3d\r\n    p3d.buy.value(msg.value)(_masternode);\r\n\r\n    // caller must be approved to send divs\r\n    if (approved[msg.sender]) {\r\n      // send divs to receiver\r\n      uint256 divs = p3d.myDividends(true);\r\n      if (divs != 0) {\r\n        p3d.withdraw();\r\n        _receiver.transfer(divs);\r\n      }\r\n      emit Contribution(msg.sender, _receiver, msg.value, divs);\r\n    }\r\n  }\r\n\r\n  function getInfo() external view returns (uint256, uint256) {\r\n    return (\r\n      p3d.balanceOf(address(this)),\r\n      p3d.myDividends(true)\r\n    );\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n}\r\n\r\ncontract Weth {\r\n  function deposit() public payable {}\r\n  function withdraw(uint wad) public {}\r\n  function approve(address guy, uint wad) public returns (bool) {}\r\n}\r\n\r\ncontract Dex {\r\n  using SafeMath for uint256;\r\n\r\n  AirSwap constant airswap = AirSwap(0x8fd3121013A07C57f0D69646E86E7a4880b467b7);\r\n  P3D constant p3d = P3D(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n  Pool constant pool = Pool(0x4C9DFf5D802A58668B4a749b749A09DfFE0f14b2);\r\n  Weth constant weth = Weth(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);\r\n  \r\n  uint256 constant MAX_UINT = 2**256 - 1;\r\n  \r\n  constructor() public {\r\n    // pre-approve weth transactions\r\n    weth.approve(address(airswap), MAX_UINT);\r\n  }\r\n  \r\n  function() external payable {}\r\n\r\n  function fill(\r\n    // [makerAddress, masternode]\r\n    address[2] addresses,\r\n    uint256 makerAmount,\r\n    address makerToken,\r\n    uint256 takerAmount,\r\n    address takerToken,\r\n    uint256 expiration,\r\n    uint256 nonce,\r\n    uint8 v,\r\n    bytes32 r,\r\n    bytes32 s\r\n  ) public payable {\r\n\r\n    // fee, ether amount\r\n    uint256 fee;\r\n    uint256 amount;\r\n\r\n    if (takerToken == address(0) || takerToken == address(weth)) {\r\n      // taker is buying a token with ether or weth\r\n\r\n      // maker token must not be ether or weth\r\n      require(makerToken != address(0) && makerToken != address(weth));\r\n\r\n      // 1% fee on ether\r\n      fee = takerAmount / 100;\r\n\r\n      // subtract fee from value\r\n      amount = msg.value.sub(fee);\r\n      \r\n      // taker amount must match\r\n      require(amount == takerAmount);\r\n      \r\n      if (takerToken == address(weth)) {\r\n        // if we are exchanging weth, deposit\r\n        weth.deposit.value(amount);\r\n        \r\n        // fill weth order\r\n        airswap.fill(\r\n          addresses[0],\r\n          makerAmount,\r\n          makerToken,\r\n          address(this),\r\n          amount,\r\n          takerToken,\r\n          expiration,\r\n          nonce,\r\n          v,\r\n          r,\r\n          s\r\n        );\r\n      } else {\r\n        // fill eth order\r\n        airswap.fill.value(amount)(\r\n          addresses[0],\r\n          makerAmount,\r\n          makerToken,\r\n          address(this),\r\n          amount,\r\n          takerToken,\r\n          expiration,\r\n          nonce,\r\n          v,\r\n          r,\r\n          s\r\n        );\r\n      }\r\n\r\n      // send fee to the pool contract\r\n      if (fee != 0) {\r\n        pool.contribute.value(fee)(addresses[1], msg.sender);\r\n      }\r\n\r\n      // finish trade\r\n      require(IERC20(makerToken).transfer(msg.sender, makerAmount));\r\n\r\n    } else {\r\n      // taker is selling a token for ether\r\n\r\n      // no ether should be sent\r\n      require(msg.value == 0);\r\n\r\n      // maker token must be ether or weth\r\n      require(makerToken == address(0) || makerToken == address(weth));\r\n        \r\n      // transfer taker tokens to this contract\r\n      require(IERC20(takerToken).transferFrom(msg.sender, address(this), takerAmount));\r\n\r\n      // approve the airswap contract for this transaction\r\n      if (IERC20(takerToken).allowance(address(this), address(airswap)) < takerAmount) {\r\n        IERC20(takerToken).approve(address(airswap), MAX_UINT);\r\n      }\r\n\r\n      // fill the order\r\n      airswap.fill(\r\n        addresses[0],\r\n        makerAmount,\r\n        makerToken,\r\n        address(this),\r\n        takerAmount,\r\n        takerToken,\r\n        expiration,\r\n        nonce,\r\n        v,\r\n        r,\r\n        s\r\n      );\r\n      \r\n      // if we bought weth, withdraw ether\r\n      if (makerToken == address(weth)) {\r\n        weth.withdraw(makerAmount);\r\n      }\r\n      \r\n      // 1% fee on ether\r\n      fee = makerAmount / 100;\r\n\r\n      // subtract fee from amount\r\n      amount = makerAmount.sub(fee);\r\n\r\n      // send fee to the pool contract\r\n      if (fee != 0) {\r\n        pool.contribute.value(fee)(addresses[1], msg.sender);\r\n      }\r\n\r\n      // finish trade\r\n      msg.sender.transfer(amount);\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[2]\"},{\"name\":\"makerAmount\",\"type\":\"uint256\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerAmount\",\"type\":\"uint256\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"fill\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"Dex","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://43bb7ac7d9d42783e6d9054822a520c3688199de7aa57d9ddff5333ebdedb82d"}]}