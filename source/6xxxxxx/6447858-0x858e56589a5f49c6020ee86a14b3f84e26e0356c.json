{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\ncontract Functions {\r\n\r\n    bytes32[] public randomHashes;\r\n\r\n    function fillWithHashes() public {\r\n        require(randomHashes.length == 0);\r\n\r\n        for (uint i = block.number - 100; i < block.number; i++) {\r\n            randomHashes.push(blockhash(i));\r\n        }\r\n    }\r\n\r\n    /// @notice Function to calculate initial random seed based on our hashes\r\n    /// @param _randomHashIds are ids in our array of hashes\r\n    /// @param _timestamp is timestamp for that hash\r\n    /// @return uint representation of random seed\r\n    function calculateSeed(uint[] _randomHashIds, uint _timestamp) public view returns (uint) {\r\n        require(_timestamp != 0);\r\n        require(_randomHashIds.length == 10);\r\n\r\n        bytes32 randomSeed = keccak256(\r\n            abi.encodePacked(\r\n            randomHashes[_randomHashIds[0]], randomHashes[_randomHashIds[1]],\r\n            randomHashes[_randomHashIds[2]], randomHashes[_randomHashIds[3]],\r\n            randomHashes[_randomHashIds[4]], randomHashes[_randomHashIds[5]],\r\n            randomHashes[_randomHashIds[6]], randomHashes[_randomHashIds[7]],\r\n            randomHashes[_randomHashIds[8]], randomHashes[_randomHashIds[9]],\r\n            _timestamp\r\n            )\r\n        );\r\n\r\n        return uint(randomSeed);\r\n    }\r\n\r\n    function getRandomHashesLength() public view returns(uint) {\r\n        return randomHashes.length;\r\n    }\r\n\r\n    /// @notice Function which decodes bytes32 to array of integers\r\n    /// @param _potentialAssets are potential assets user would like to have\r\n    /// @return array of assetIds\r\n    function decodeAssets(bytes32[] _potentialAssets) public pure returns (uint[] assets) {\r\n        require(_potentialAssets.length > 0);\r\n\r\n        uint[] memory assetsCopy = new uint[](_potentialAssets.length*10);\r\n        uint numberOfAssets = 0;\r\n\r\n        for (uint j = 0; j < _potentialAssets.length; j++) {\r\n            uint input;\r\n            bytes32 pot = _potentialAssets[j];\r\n\r\n            assembly {\r\n                input := pot\r\n            }\r\n\r\n            for (uint i = 10; i > 0; i--) {\r\n                uint mask = (2 << ((i-1) * 24)) / 2;\r\n                uint b = (input & (mask * 16777215)) / mask;\r\n\r\n                if (b != 0) {\r\n                    assetsCopy[numberOfAssets] = b;\r\n                    numberOfAssets++;\r\n                }\r\n            }\r\n        }\r\n\r\n        assets = new uint[](numberOfAssets);\r\n        for (i = 0; i < numberOfAssets; i++) {\r\n            assets[i] = assetsCopy[i];\r\n        }\r\n    }\r\n\r\n    /// @notice Function to pick random assets from potentialAssets array\r\n    /// @param _finalSeed is final random seed\r\n    /// @param _potentialAssets is bytes32[] array of potential assets\r\n    /// @return uint[] array of randomly picked assets\r\n    function pickRandomAssets(uint _finalSeed, bytes32[] _potentialAssets) public pure returns(uint[] finalPicked) {\r\n        require(_finalSeed != 0);\r\n        require(_potentialAssets.length > 0);\r\n\r\n        uint[] memory assetIds = decodeAssets(_potentialAssets);\r\n        uint[] memory pickedIds = new uint[](assetIds.length);\r\n\r\n        uint finalSeedCopy = _finalSeed;\r\n        uint index = 0;\r\n\r\n        for (uint i = 0; i < assetIds.length; i++) {\r\n            finalSeedCopy = uint(keccak256(abi.encodePacked(finalSeedCopy, assetIds[i])));\r\n            if (finalSeedCopy % 2 == 0) {\r\n                pickedIds[index] = assetIds[i];\r\n                index++;\r\n            }\r\n        }\r\n\r\n        finalPicked = new uint[](index);\r\n        for (i = 0; i < index; i++) {\r\n            finalPicked[i] = pickedIds[i];\r\n        }\r\n    }\r\n\r\n    /// @notice Function to pick random assets from potentialAssets array\r\n    /// @param _finalSeed is final random seed\r\n    /// @param _potentialAssets is bytes32[] array of potential assets\r\n    /// @param _width of canvas\r\n    /// @param _height of canvas\r\n    /// @return arrays of randomly picked assets defining ids, coordinates, zoom, rotation and layers\r\n    function getImage(uint _finalSeed, bytes32[] _potentialAssets, uint _width, uint _height) public pure \r\n    returns(uint[] finalPicked, uint[] x, uint[] y, uint[] zoom, uint[] rotation, uint[] layers) {\r\n        require(_finalSeed != 0);\r\n        require(_potentialAssets.length > 0);\r\n\r\n        uint[] memory assetIds = decodeAssets(_potentialAssets);\r\n        uint[] memory pickedIds = new uint[](assetIds.length);\r\n        x = new uint[](assetIds.length);\r\n        y = new uint[](assetIds.length);\r\n        zoom = new uint[](assetIds.length);\r\n        rotation = new uint[](assetIds.length);\r\n        layers = new uint[](assetIds.length);\r\n\r\n        uint finalSeedCopy = _finalSeed;\r\n        uint index = 0;\r\n\r\n        for (uint i = 0; i < assetIds.length; i++) {\r\n            finalSeedCopy = uint(keccak256(abi.encodePacked(finalSeedCopy, assetIds[i])));\r\n            if (finalSeedCopy % 2 == 0) {\r\n                pickedIds[index] = assetIds[i];\r\n                (x[index], y[index], zoom[index], rotation[index], layers[index]) = pickRandomAssetPosition(finalSeedCopy, _width, _height);\r\n                index++;\r\n            }\r\n        }\r\n\r\n        finalPicked = new uint[](index);\r\n        for (i = 0; i < index; i++) {\r\n            finalPicked[i] = pickedIds[i];\r\n        }\r\n    }\r\n\r\n    /// @notice Function to pick random position for an asset\r\n    /// @param _randomSeed is random seed for that image\r\n    /// @param _width of canvas\r\n    /// @param _height of canvas\r\n    /// @return tuple of uints representing x,y,zoom,and rotation\r\n    function pickRandomAssetPosition(uint _randomSeed, uint _width, uint _height) public pure \r\n    returns (uint x, uint y, uint zoom, uint rotation, uint layer) {\r\n        \r\n        x = _randomSeed % _width;\r\n        y = _randomSeed % _height;\r\n        zoom = _randomSeed % 200 + 800;\r\n        rotation = _randomSeed % 360;\r\n        // using random number for now\r\n        // if two layers are same, sort by (keccak256(layer, assetId))\r\n        layer = _randomSeed % 1234567; \r\n    }\r\n\r\n    /// @notice Function to calculate final random seed for user\r\n    /// @param _randomSeed is initially given random seed\r\n    /// @param _iterations is number of iterations\r\n    /// @return final seed for user as uint\r\n    function getFinalSeed(uint _randomSeed, uint _iterations) public pure returns (bytes32) {\r\n        require(_randomSeed != 0);\r\n        require(_iterations != 0);\r\n        bytes32 finalSeed = bytes32(_randomSeed);\r\n\r\n        finalSeed = keccak256(abi.encodePacked(_randomSeed, _iterations));\r\n        for (uint i = 0; i < _iterations; i++) {\r\n            finalSeed = keccak256(abi.encodePacked(finalSeed, i));\r\n        }\r\n\r\n        return finalSeed;\r\n    }\r\n\r\n    function toHex(uint _randomSeed) public pure returns (bytes32) {\r\n        return bytes32(_randomSeed);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomHashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fillWithHashes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_finalSeed\",\"type\":\"uint256\"},{\"name\":\"_potentialAssets\",\"type\":\"bytes32[]\"},{\"name\":\"_width\",\"type\":\"uint256\"},{\"name\":\"_height\",\"type\":\"uint256\"}],\"name\":\"getImage\",\"outputs\":[{\"name\":\"finalPicked\",\"type\":\"uint256[]\"},{\"name\":\"x\",\"type\":\"uint256[]\"},{\"name\":\"y\",\"type\":\"uint256[]\"},{\"name\":\"zoom\",\"type\":\"uint256[]\"},{\"name\":\"rotation\",\"type\":\"uint256[]\"},{\"name\":\"layers\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_randomSeed\",\"type\":\"uint256\"},{\"name\":\"_iterations\",\"type\":\"uint256\"}],\"name\":\"getFinalSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_randomSeed\",\"type\":\"uint256\"},{\"name\":\"_width\",\"type\":\"uint256\"},{\"name\":\"_height\",\"type\":\"uint256\"}],\"name\":\"pickRandomAssetPosition\",\"outputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"},{\"name\":\"zoom\",\"type\":\"uint256\"},{\"name\":\"rotation\",\"type\":\"uint256\"},{\"name\":\"layer\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_randomHashIds\",\"type\":\"uint256[]\"},{\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"calculateSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_randomSeed\",\"type\":\"uint256\"}],\"name\":\"toHex\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_potentialAssets\",\"type\":\"bytes32[]\"}],\"name\":\"decodeAssets\",\"outputs\":[{\"name\":\"assets\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_finalSeed\",\"type\":\"uint256\"},{\"name\":\"_potentialAssets\",\"type\":\"bytes32[]\"}],\"name\":\"pickRandomAssets\",\"outputs\":[{\"name\":\"finalPicked\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRandomHashesLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Functions","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://94a7567301daacd104848cd93df0e40c14484036133e10cb055d0f033155f53e"}]}