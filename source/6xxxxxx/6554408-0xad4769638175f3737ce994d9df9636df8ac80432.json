{"status":"1","message":"OK","result":[{"SourceCode":"/**+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n                            abcLotto: a Block Chain Lottery\r\n\r\n                            Don't trust anyone but the CODE!\r\n ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n /*\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without \r\n * express written consent from the creators is prohibited.\r\n */\r\n\r\n/**+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\r\n                            - this is a 5/16 lotto, choose 5 numbers in 1-16.\r\n                            - per ticket has two chance to win the jackpot, daily and weekly.\r\n                            - daily jackpot need choose 5 right numbers.\r\n                            - weekly jackpot need choose 5 rights numbers with right sequence.\r\n                            - you must have an inviter then to buy.\r\n                            - act as inviter will get bonus.\r\n ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n pragma solidity ^0.4.20;\r\n/**\r\n* @title abc address resolver interface. \r\n */ \r\ncontract abcResolverI{\r\n    function getWalletAddress() public view returns (address);\r\n    function getBookAddress() public view returns (address);\r\n    function getControllerAddress() public view returns (address);\r\n}\r\n\r\n/**\r\n* @title inviter book interface. \r\n */ \r\ncontract inviterBookI{\r\n    function isRoot(address addr) public view returns(bool);\r\n    function hasInviter(address addr) public view returns(bool);\r\n    function setInviter(address addr, string inviter) public;\r\n    function pay(address addr) public payable;\r\n}\r\n\r\n/**\r\n* @title abcLotto : data structure, buy and reward functions.\r\n* @dev a decentralized lottery application. \r\n */ \r\n contract abcLotto{\r\n     using SafeMath for *;\r\n     \r\n     //global varibles\r\n     abcResolverI public resolver;\r\n     address public controller;\r\n     inviterBookI public book;\r\n     address public wallet;\r\n\r\n     uint32 public currentRound;   //current round, plus 1 every day;\r\n     uint8 public currentState; //1 - bet period, 2 - freeze period, 3 - draw period.\r\n     uint32[] public amounts;\t//buy amount per round.\r\n     uint32[] public addrs; //buy addresses per round.\r\n     bool[] public drawed;    //lottery draw finished mark.\r\n     \r\n     uint public rollover = 0;\r\n     uint[] public poolUsed;\r\n     \r\n     //constant\r\n     uint constant ABC_GAS_CONSUME = 50; //this abc Dapp cost, default 50/1000.\r\n     uint constant INVITER_FEE = 100; // inviter fee, default 100/1000;\r\n     uint constant SINGLE_BET_PRICE = 50000000000000000;    // single bet price is 0.05 ether.\r\n     uint constant THISDAPP_DIV = 1000;\r\n     uint constant POOL_ALLOCATION_WEEK = 500;\r\n     uint constant POOL_ALLOCATION_JACKPOT = 618;\r\n     uint constant MAX_BET_AMOUNT = 100;   //per address can bet amount must be less than 100 per round.\r\n     uint8 constant MAX_BET_NUM = 16;\r\n     uint8 constant MIN_BET_NUM = 1;\r\n\r\n     //data structures\r\n     struct UnitBet{\r\n         uint8[5] _nums;\r\n\t\t bool _payed1;  //daily\r\n         bool _payed2;  //weekly\r\n     }\r\n     struct AddrBets{\r\n         UnitBet[] _unitBets;\r\n     }    \r\n     struct RoundBets{\r\n         mapping (address=>AddrBets) _roundBets;\r\n     }\r\n     RoundBets[] allBets;\r\n     \r\n     struct BetKeyEntity{\r\n         mapping (bytes5=>uint32) _entity;\r\n     }     \r\n     BetKeyEntity[] betDaily;\r\n     BetKeyEntity[] betWeekly;\r\n\r\n     struct Jackpot{\r\n\t     uint8[5] _results;\r\n     }\r\n     Jackpot[] dailyJackpot;\r\n     Jackpot[] weeklyJackpot;\r\n     \r\n     //events\r\n     event OnBuy(address user, uint32 round, uint32 index, uint8[5] nums);\r\n     event OnRewardDaily(address user, uint32 round, uint32 index, uint reward);\r\n     event OnRewardWeekly(address user, uint32 round, uint32 index,uint reward);\r\n     event OnRewardDailyFailed(address user, uint32 round, uint32 index);\r\n     event OnRewardWeeklyFailed(address user, uint32 round, uint32 index);\r\n     event OnNewRound(uint32 round);\r\n     event OnFreeze(uint32 round);\r\n     event OnUnFreeze(uint32 round);\r\n     event OnDrawStart(uint32 round);\r\n     event OnDrawFinished(uint32 round, uint8[5] jackpot);\r\n     event BalanceNotEnough();\r\n     \r\n      //modifier\r\n     modifier onlyController {\r\n         require(msg.sender == controller);\r\n         _;\r\n     }     \r\n     \r\n     modifier onlyBetPeriod {\r\n         require(currentState == 1);\r\n         _;\r\n     }\r\n     \r\n     modifier onlyHuman {\r\n         require(msg.sender == tx.origin);\r\n         _;\r\n     }\r\n     \r\n     //check contract interface, are they upgrated?\r\n     modifier abcInterface {\r\n        if((address(resolver)==0)||(getCodeSize(address(resolver))==0)){\r\n            if(abc_initNetwork()){\r\n                wallet = resolver.getWalletAddress();\r\n                book = inviterBookI(resolver.getBookAddress());\r\n                controller = resolver.getControllerAddress();\r\n            }\r\n        }\r\n        else{\r\n            if(wallet != resolver.getWalletAddress())\r\n                wallet = resolver.getWalletAddress();\r\n\r\n            if(address(book) != resolver.getBookAddress())\r\n                book = inviterBookI(resolver.getBookAddress());\r\n                \r\n            if(controller != resolver.getControllerAddress())\r\n                controller = resolver.getControllerAddress();\r\n        }    \r\n\r\n        _;        \r\n     }\r\n\r\n     /**\r\n     * @dev fallback funtion, this contract don't accept ether directly.\r\n     */\r\n     function() public payable { \r\n         revert();\r\n     }\r\n\r\n     /**\r\n     * @dev init address resolver.\r\n     */ \r\n     function abc_initNetwork() internal returns(bool) { \r\n         //mainnet\r\n         if (getCodeSize(0xde4413799c73a356d83ace2dc9055957c0a5c335)>0){     \r\n            resolver = abcResolverI(0xde4413799c73a356d83ace2dc9055957c0a5c335);\r\n            return true;\r\n         }               \r\n   \r\n         //others ...\r\n\r\n         return false;\r\n     }     \r\n    /**\r\n    * @dev get code size of appointed address.\r\n     */\r\n     function getCodeSize(address _addr) internal view returns(uint _size) {\r\n         assembly {\r\n             _size := extcodesize(_addr)\r\n         }\r\n     }\r\n    //+++++++++++++++++++++++++                  public operation functions               +++++++++++++++++++++++++++++++++++++\r\n    /**\r\n    * @dev buy: buy a new ticket.\r\n     */\r\n    function buy(uint8[5] nums, string inviter) \r\n        public\r\n        payable\r\n        onlyBetPeriod\r\n        onlyHuman\r\n        abcInterface\r\n        returns (uint)\r\n     {\r\n         //check number range 1-16, no repeat number.\r\n         if(!isValidNum(nums)) revert();\r\n         //doesn't offer enough value.\r\n         if(msg.value < SINGLE_BET_PRICE) revert();\r\n         \r\n         //check daily amount is less than MAX_BET_AMOUNT\r\n         uint _am = allBets[currentRound-1]._roundBets[msg.sender]._unitBets.length.add(1);      \r\n         if( _am > MAX_BET_AMOUNT) revert();\r\n         \r\n         //update storage varibles.\r\n         amounts[currentRound-1]++;\r\n         if(allBets[currentRound-1]._roundBets[msg.sender]._unitBets.length <= 0)\r\n            addrs[currentRound-1]++;\r\n            \r\n         //insert bet record.\r\n         UnitBet memory _bet;\r\n         _bet._nums = nums;\r\n         _bet._payed1 = false;\r\n         _bet._payed2 = false;\r\n         allBets[currentRound-1]._roundBets[msg.sender]._unitBets.push(_bet);\r\n         \r\n         //increase key-value records.\r\n         bytes5 _key;\r\n         _key = generateCombinationKey(nums);\r\n         betDaily[currentRound-1]._entity[_key]++;\r\n         _key = generatePermutationKey(nums);\r\n         uint32 week = (currentRound-1) / 7;\r\n         betWeekly[week]._entity[_key]++;\r\n         \r\n         //refund extra value.\r\n         if(msg.value > SINGLE_BET_PRICE){\r\n             msg.sender.transfer(msg.value.sub(SINGLE_BET_PRICE));\r\n         }\r\n\r\n         //has inviter?\r\n         if(book.hasInviter(msg.sender) || book.isRoot(msg.sender)){\r\n            book.pay.value(SINGLE_BET_PRICE.mul(INVITER_FEE).div(THISDAPP_DIV))(msg.sender);\r\n         }\r\n         else{\r\n            book.setInviter(msg.sender, inviter);\r\n            book.pay.value(SINGLE_BET_PRICE.mul(INVITER_FEE).div(THISDAPP_DIV))(msg.sender);\r\n         }\r\n         \r\n        //emit event\r\n        emit OnBuy(msg.sender, currentRound, uint32(allBets[currentRound-1]._roundBets[msg.sender]._unitBets.length), nums);\r\n        return allBets[currentRound-1]._roundBets[msg.sender]._unitBets.length;\r\n         \r\n     }\r\n     /**\r\n     * @dev rewardDaily: apply for daily reward.\r\n     */     \r\n     function rewardDaily(uint32 round, uint32 index)\r\n        public \r\n        onlyBetPeriod \r\n        onlyHuman  \r\n        returns(uint) \r\n     {\r\n         require(round>0 && round<=currentRound);\r\n         require(drawed[round-1]);\r\n         require(index>0 && index<=allBets[round-1]._roundBets[msg.sender]._unitBets.length);\r\n         require(!allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._payed1);\r\n\r\n         uint8[5] memory nums = allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._nums;\r\n         \r\n         bytes5 key = generateCombinationKey(nums);\r\n         bytes5 jackpot = generateCombinationKey(dailyJackpot[round-1]._results);\r\n         if(key != jackpot) return;\r\n         \r\n         uint win_amount = betDaily[round-1]._entity[key];\r\n         if(win_amount <= 0) return;\r\n\r\n         uint amount = amounts[round-1];\r\n         uint total = SINGLE_BET_PRICE.mul(amount).mul(THISDAPP_DIV-INVITER_FEE).div(THISDAPP_DIV).mul(THISDAPP_DIV - POOL_ALLOCATION_WEEK).div(THISDAPP_DIV);\r\n         uint pay = total.mul(THISDAPP_DIV - ABC_GAS_CONSUME).div(THISDAPP_DIV).div(win_amount);\r\n\r\n         //pay action\r\n         if(pay > address(this).balance){\r\n            emit BalanceNotEnough();\r\n            revert();             \r\n         }\r\n         allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._payed1 = true;\r\n         if(!msg.sender.send(pay)){\r\n            emit OnRewardDailyFailed(msg.sender, round, index);\r\n            revert();\r\n         }\r\n         \r\n         emit OnRewardDaily(msg.sender, round, index, pay);\r\n         return pay;\r\n     }      \r\n     \r\n     /**\r\n     * @dev rewardWeekly: apply for weekly reward.\r\n      */\r\n     function rewardWeekly(uint32 round, uint32 index) \r\n        public \r\n        onlyBetPeriod \r\n        onlyHuman\r\n        returns(uint) \r\n     {\r\n         require(round>0 && round<=currentRound);\r\n         require(drawed[round-1]);\r\n         require(index>0 && index<=allBets[round-1]._roundBets[msg.sender]._unitBets.length);\r\n         require(!allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._payed2);\r\n\r\n         uint32 week = (round-1)/7 + 1;\r\n         uint8[5] memory nums = allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._nums;\r\n         \r\n         bytes5 key = generatePermutationKey(nums);\r\n         bytes5 jackpot = generatePermutationKey(weeklyJackpot[week-1]._results);\r\n         if(key != jackpot) return;\r\n         \r\n         uint32 win_amount = betWeekly[week-1]._entity[key];\r\n         if(win_amount <= 0) return;     \r\n\r\n         uint pay = poolUsed[week-1].div(win_amount);\r\n         \r\n         //pay action\r\n         if(pay > address(this).balance){\r\n            emit BalanceNotEnough();\r\n            return;             \r\n         }\r\n         allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._payed2 = true;\r\n         if(!msg.sender.send(pay)){\r\n            emit OnRewardWeeklyFailed(msg.sender, round, index);\r\n            revert();\r\n         }\r\n         \r\n        emit OnRewardWeekly(msg.sender, round, index, pay);\r\n        return pay;\r\n     }\r\n     //+++++++++++++++++++++++++                  pure or view functions               +++++++++++++++++++++++++++++++++++++\r\n     /**\r\n     * @dev getSingleBet: get self's bet record.\r\n      */\r\n    function getSingleBet(uint32 round, uint32 index) \r\n        public \r\n        view \r\n        returns(uint8[5] nums, bool payed1, bool payed2)\r\n     {\r\n         if(round == 0 || round > currentRound) return;\r\n\r\n         uint32 iLen = uint32(allBets[round-1]._roundBets[msg.sender]._unitBets.length);\r\n         if(iLen <= 0) return;\r\n         if(index == 0 || index > iLen) return;\r\n         \r\n         nums = allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._nums;\r\n         payed1 = allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._payed1;\r\n         payed2 = allBets[round-1]._roundBets[msg.sender]._unitBets[index-1]._payed2;\r\n     }\r\n     /**\r\n     * @dev getAmountDailybyNum: get the daily bet amount of a set of numbers.\r\n      */\r\n     function getAmountDailybyNum(uint32 round, uint8[5] nums) \r\n        public \r\n        view \r\n        returns(uint32)\r\n    {\r\n         if(round == 0 || round > currentRound) return 0;       \r\n         bytes5 _key = generateCombinationKey(nums);\r\n         \r\n         return betDaily[round-1]._entity[_key];\r\n     }\r\n\r\n     /**\r\n     * @dev getAmountWeeklybyNum: get the weekly bet amount of a set of numbers.\r\n      */     \r\n     function getAmountWeeklybyNum(uint32 week, uint8[5] nums) \r\n        public \r\n        view \r\n        returns(uint32)\r\n    {\r\n         if(week == 0 || currentRound < (week-1)*7) return 0;\r\n         \r\n         bytes5 _key = generatePermutationKey(nums);\r\n         return betWeekly[week-1]._entity[_key];\r\n     }\r\n     \r\n     /**\r\n     * @dev getDailyJackpot: some day's Jackpot.\r\n      */\r\n     function getDailyJackpot(uint32 round) \r\n        public \r\n        view \r\n        returns(uint8[5] jackpot, uint32 amount)\r\n    {\r\n         if(round == 0 || round > currentRound) return;\r\n         jackpot = dailyJackpot[round-1]._results;\r\n         amount = getAmountDailybyNum(round, jackpot);\r\n     }\r\n\r\n     /**\r\n     * @dev getWeeklyJackpot: some week's Jackpot.\r\n      */\r\n     function getWeeklyJackpot(uint32 week) \r\n        public \r\n        view \r\n        returns(uint8[5] jackpot, uint32 amount)\r\n    {\r\n         if(week == 0 || week > currentRound/7) return;\r\n         jackpot = weeklyJackpot[week - 1]._results;\r\n         amount = getAmountWeeklybyNum(week, jackpot);\r\n     }\r\n\r\n     //+++++++++++++++++++++++++                  controller functions               +++++++++++++++++++++++++++++++++++++\r\n     /**\r\n      * @dev start new round.\r\n     */ \r\n    function nextRound() \r\n        abcInterface\r\n        public \r\n        onlyController\r\n    {\r\n         //current round must be drawed.\r\n         if(currentRound > 0)\r\n            require(drawed[currentRound-1]);\r\n         \r\n         currentRound++;\r\n         currentState = 1;\r\n         \r\n         amounts.length++;\r\n         addrs.length++;\r\n         drawed.length++;\r\n         \r\n         RoundBets memory _rb;\r\n         allBets.push(_rb);\r\n         \r\n         BetKeyEntity memory _en1;\r\n         betDaily.push(_en1);\r\n         \r\n         Jackpot memory _b1;\r\n         dailyJackpot.push(_b1);\r\n         //if is a weekend or beginning.\r\n         if((currentRound-1) % 7 == 0){\r\n             BetKeyEntity memory _en2;\r\n             betWeekly.push(_en2);\r\n             Jackpot memory _b2;\r\n             weeklyJackpot.push(_b2);\r\n             poolUsed.length++;\r\n         }\r\n         emit OnNewRound(currentRound);\r\n     }\r\n\r\n    /**\r\n    * @dev freeze: enter freeze period.\r\n     */\r\n    function freeze() \r\n        abcInterface\r\n        public\r\n        onlyController \r\n    {\r\n        currentState = 2;\r\n        emit OnFreeze(currentRound);\r\n    }\r\n\r\n    /**\r\n    * @dev freeze: enter freeze period.\r\n     */\r\n    function unfreeze()\r\n        abcInterface\r\n        public \r\n        onlyController \r\n    {\r\n        require(currentState == 2);\r\n        currentState = 1;\r\n        emit OnUnFreeze(currentRound);\r\n    }\r\n    \r\n    /**\r\n    * @dev draw: enter freeze period.\r\n     */\r\n    function draw() \r\n        abcInterface \r\n        public \r\n        onlyController\r\n    {\r\n        require(!drawed[currentRound-1]);\r\n        currentState = 3;\r\n        emit OnDrawStart(currentRound);\r\n    }\r\n\r\n    /**\r\n    * @dev controller have generated and set Jackpot.\r\n     */\r\n    function setJackpot(uint8[5] jackpot) \r\n        abcInterface\r\n        public\r\n        onlyController\r\n    {\r\n        require(currentState==3 && !drawed[currentRound-1]);\r\n        //check jackpot range 1-16, no repeat number.\r\n        if(!isValidNum(jackpot)) return;\r\n  \r\n        uint _fee = 0;\r\n\r\n        //mark daily entity's prize.-----------------------------------------------------------------------------------\r\n        uint8[5] memory _jackpot1 = sort(jackpot);\r\n        dailyJackpot[currentRound-1]._results = _jackpot1;\r\n        bytes5 _key = generateCombinationKey(_jackpot1);\r\n        uint total = SINGLE_BET_PRICE.mul(amounts[currentRound-1]).mul(THISDAPP_DIV-INVITER_FEE).div(THISDAPP_DIV).mul(THISDAPP_DIV - POOL_ALLOCATION_WEEK).div(THISDAPP_DIV);\r\n        uint win_amount = uint(betDaily[currentRound-1]._entity[_key]);\r\n        uint _bonus_sum;\r\n\r\n        if( win_amount <= 0){\r\n            rollover = rollover.add(total);\r\n        }\r\n        else{\r\n            _bonus_sum = total.mul(THISDAPP_DIV - ABC_GAS_CONSUME).div(THISDAPP_DIV).div(win_amount).mul(win_amount);\r\n            _fee = _fee.add(total.sub(_bonus_sum));\r\n        }\r\n         //end mark.-----------------------------------------------------------------------------------\r\n\r\n        //mark weekly entity's prize.---------------------------------------------------------------------------------------\r\n        if((currentRound > 0) && (currentRound % 7 == 0)){\r\n            uint32 _week = currentRound/7;\r\n            weeklyJackpot[_week-1]._results = jackpot;\r\n           _key = generatePermutationKey(jackpot);\r\n            uint32 _amounts = getAmountWeekly(_week);\r\n            total = SINGLE_BET_PRICE.mul(_amounts).mul(THISDAPP_DIV-INVITER_FEE).div(THISDAPP_DIV).mul(POOL_ALLOCATION_WEEK).div(THISDAPP_DIV);\r\n            win_amount = uint(betWeekly[_week-1]._entity[_key]);\r\n\r\n            if(win_amount > 0){\r\n                total = total.add(rollover);\r\n                _bonus_sum = total.mul(POOL_ALLOCATION_JACKPOT).div(THISDAPP_DIV);\r\n                rollover = total.sub(_bonus_sum);\r\n\r\n                poolUsed[_week-1] = _bonus_sum.mul(THISDAPP_DIV - ABC_GAS_CONSUME).div(THISDAPP_DIV).div(win_amount).mul(win_amount);\r\n                _fee = _fee.add(_bonus_sum.sub(poolUsed[_week-1]));\r\n            }\r\n            else{\r\n                rollover = rollover.add(total);\r\n            }\r\n        }\r\n        //end mark.-----------------------------------------------------------------------------------\r\n        drawed[currentRound-1] = true;\r\n        wallet.transfer(_fee);\r\n        emit OnDrawFinished(currentRound, jackpot);\r\n    }\r\n\r\n     //+++++++++++++++++++++++++                  internal functions               +++++++++++++++++++++++++++++++++++++\r\n     /**\r\n     * @dev getAmountWeekly: the bet amount of a week.\r\n      */\r\n     function getAmountWeekly(uint32 week) internal view returns(uint32){\r\n         if(week == 0 || currentRound < (week-1)*7) return 0;\r\n\r\n         uint32 _ret;\r\n         uint8 i;\r\n         if(currentRound > week*7){\r\n             for(i=0; i<7; i++){\r\n                 _ret += amounts[(week-1)*7+i];\r\n             }\r\n         }\r\n         else{\r\n             uint8 j = uint8((currentRound-1) % 7);\r\n             for(i=0;i<=j;i++){\r\n                 _ret += amounts[(week-1)*7+i];\r\n             }\r\n         }\r\n         return _ret;\r\n     }\r\n     /**\r\n     * @dev check if is a valid set of number.\r\n     * @param nums : chosen number.\r\n     */\r\n     function isValidNum(uint8[5] nums) internal pure returns(bool){\r\n         for(uint i = 0; i<5; i++){\r\n             if(nums[i] < MIN_BET_NUM || nums[i] > MAX_BET_NUM) \r\n                return false;\r\n         }\r\n         if(hasRepeat(nums)) return false;\r\n         \r\n         return true;\r\n    }\r\n    \r\n     /**\r\n     * @dev sort 5 numbers.\r\n     *      don't want to change input numbers sequence, so copy it at first.\r\n     * @param nums : input numbers.\r\n     */\r\n    function sort(uint8[5] nums) internal pure returns(uint8[5]){\r\n        uint8[5] memory _nums;\r\n        uint8 i;\r\n        for(i=0;i<5;i++)\r\n            _nums[i] = nums[i];\r\n            \r\n        uint8 j;\r\n        uint8 temp;\r\n        for(i =0; i<5-1; i++){\r\n            for(j=0; j<5-i-1;j++){\r\n                if(_nums[j]>_nums[j+1]){\r\n                    temp = _nums[j];\r\n                    _nums[j] = _nums[j+1];\r\n                    _nums[j+1] = temp;\r\n                }\r\n            }\r\n        }\r\n        return _nums;\r\n    }\r\n    \r\n    /**\r\n     * @dev does has repeat number?\r\n     * @param nums : input numbers.\r\n     */\r\n    function hasRepeat(uint8[5] nums) internal pure returns(bool){\r\n         uint8 i;\r\n         uint8 j;\r\n         for(i =0; i<5-1; i++){\r\n             for(j=i; j<5-1;j++){\r\n                 if(nums[i]==nums[j+1]) return true;\r\n             }\r\n         }\r\n        return false;       \r\n    }\r\n    \r\n    /**\r\n     * @dev generate Combination key, need sort at first.\r\n     */ \r\n    function generateCombinationKey(uint8[5] nums) internal pure returns(bytes5){\r\n        uint8[5] memory temp = sort(nums);\r\n        bytes5 ret;\r\n        ret = (ret | byte(temp[4])) >> 8;\r\n        ret = (ret | byte(temp[3])) >> 8;\r\n        ret = (ret | byte(temp[2])) >> 8;\r\n        ret = (ret | byte(temp[1])) >> 8;\r\n        ret = ret | byte(temp[0]);\r\n        \r\n        return ret; \r\n    }\r\n    \r\n    /**\r\n     * @dev generate Permutation key.\r\n     */ \r\n    function generatePermutationKey(uint8[5] nums) internal pure returns(bytes5){\r\n        bytes5 ret;\r\n        ret = (ret | byte(nums[4])) >> 8;\r\n        ret = (ret | byte(nums[3])) >> 8;\r\n        ret = (ret | byte(nums[2])) >> 8;\r\n        ret = (ret | byte(nums[1])) >> 8;\r\n        ret = ret | byte(nums[0]);\r\n        \r\n        return ret;         \r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath : it's from openzeppelin.\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two 32 bit numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub_32(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two 32 bit numbers, throws on overflow.\r\n  */\r\n  function add_32(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"book\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"jackpot\",\"type\":\"uint8[5]\"}],\"name\":\"setJackpot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"draw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"addrs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"amounts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint32\"}],\"name\":\"getDailyJackpot\",\"outputs\":[{\"name\":\"jackpot\",\"type\":\"uint8[5]\"},{\"name\":\"amount\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nextRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint32\"},{\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"getSingleBet\",\"outputs\":[{\"name\":\"nums\",\"type\":\"uint8[5]\"},{\"name\":\"payed1\",\"type\":\"bool\"},{\"name\":\"payed2\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nums\",\"type\":\"uint8[5]\"},{\"name\":\"inviter\",\"type\":\"string\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rollover\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"round\",\"type\":\"uint32\"},{\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"rewardWeekly\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"round\",\"type\":\"uint32\"},{\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"rewardDaily\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"drawed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"week\",\"type\":\"uint32\"}],\"name\":\"getWeeklyJackpot\",\"outputs\":[{\"name\":\"jackpot\",\"type\":\"uint8[5]\"},{\"name\":\"amount\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"round\",\"type\":\"uint32\"},{\"name\":\"nums\",\"type\":\"uint8[5]\"}],\"name\":\"getAmountDailybyNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"poolUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"week\",\"type\":\"uint32\"},{\"name\":\"nums\",\"type\":\"uint8[5]\"}],\"name\":\"getAmountWeeklybyNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"nums\",\"type\":\"uint8[5]\"}],\"name\":\"OnBuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"OnRewardDaily\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"OnRewardWeekly\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"OnRewardDailyFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"uint32\"}],\"name\":\"OnRewardWeeklyFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"}],\"name\":\"OnNewRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"}],\"name\":\"OnFreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"}],\"name\":\"OnUnFreeze\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"}],\"name\":\"OnDrawStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"jackpot\",\"type\":\"uint8[5]\"}],\"name\":\"OnDrawFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"BalanceNotEnough\",\"type\":\"event\"}]","ContractName":"abcLotto","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7094b13d651ff093c5e29fc51bc58e13f1744f6b62b741f918d8ec4e6ad3295e"}]}