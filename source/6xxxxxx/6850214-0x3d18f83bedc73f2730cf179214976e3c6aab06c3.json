{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n// https://github.com/ethereum/EIPs/issues/20\r\ninterface ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf(address _owner) public view returns (uint balance);\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success);\r\n    function approve(address _spender, uint _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining);\r\n    function decimals() public view returns(uint digits);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n}\r\n\r\n\r\ncontract PermissionGroups {\r\n\r\n    address public admin;\r\n    address public pendingAdmin;\r\n    mapping(address=>bool) internal operators;\r\n    mapping(address=>bool) internal alerters;\r\n    address[] internal operatorsGroup;\r\n    address[] internal alertersGroup;\r\n    uint constant internal MAX_GROUP_SIZE = 50;\r\n\r\n    function PermissionGroups() public {\r\n        admin = msg.sender;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOperator() {\r\n        require(operators[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAlerter() {\r\n        require(alerters[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    function getOperators () external view returns(address[]) {\r\n        return operatorsGroup;\r\n    }\r\n\r\n    function getAlerters () external view returns(address[]) {\r\n        return alertersGroup;\r\n    }\r\n\r\n    event TransferAdminPending(address pendingAdmin);\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the pendingAdmin address.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdmin(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(pendingAdmin);\r\n        pendingAdmin = newAdmin;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current admin to set the admin in one tx. Useful initial deployment.\r\n     * @param newAdmin The address to transfer ownership to.\r\n     */\r\n    function transferAdminQuickly(address newAdmin) public onlyAdmin {\r\n        require(newAdmin != address(0));\r\n        TransferAdminPending(newAdmin);\r\n        AdminClaimed(newAdmin, admin);\r\n        admin = newAdmin;\r\n    }\r\n\r\n    event AdminClaimed( address newAdmin, address previousAdmin);\r\n\r\n    /**\r\n     * @dev Allows the pendingAdmin address to finalize the change admin process.\r\n     */\r\n    function claimAdmin() public {\r\n        require(pendingAdmin == msg.sender);\r\n        AdminClaimed(pendingAdmin, admin);\r\n        admin = pendingAdmin;\r\n        pendingAdmin = address(0);\r\n    }\r\n\r\n    event AlerterAdded (address newAlerter, bool isAdd);\r\n\r\n    function addAlerter(address newAlerter) public onlyAdmin {\r\n        require(!alerters[newAlerter]); // prevent duplicates.\r\n        require(alertersGroup.length < MAX_GROUP_SIZE);\r\n\r\n        AlerterAdded(newAlerter, true);\r\n        alerters[newAlerter] = true;\r\n        alertersGroup.push(newAlerter);\r\n    }\r\n\r\n    function removeAlerter (address alerter) public onlyAdmin {\r\n        require(alerters[alerter]);\r\n        alerters[alerter] = false;\r\n\r\n        for (uint i = 0; i < alertersGroup.length; ++i) {\r\n            if (alertersGroup[i] == alerter) {\r\n                alertersGroup[i] = alertersGroup[alertersGroup.length - 1];\r\n                alertersGroup.length--;\r\n                AlerterAdded(alerter, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    event OperatorAdded(address newOperator, bool isAdd);\r\n\r\n    function addOperator(address newOperator) public onlyAdmin {\r\n        require(!operators[newOperator]); // prevent duplicates.\r\n        require(operatorsGroup.length < MAX_GROUP_SIZE);\r\n\r\n        OperatorAdded(newOperator, true);\r\n        operators[newOperator] = true;\r\n        operatorsGroup.push(newOperator);\r\n    }\r\n\r\n    function removeOperator (address operator) public onlyAdmin {\r\n        require(operators[operator]);\r\n        operators[operator] = false;\r\n\r\n        for (uint i = 0; i < operatorsGroup.length; ++i) {\r\n            if (operatorsGroup[i] == operator) {\r\n                operatorsGroup[i] = operatorsGroup[operatorsGroup.length - 1];\r\n                operatorsGroup.length -= 1;\r\n                OperatorAdded(operator, false);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens or ethers\r\n * @author Ilan Doron\r\n * @dev This allows to recover any tokens or Ethers received in a contract.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract Withdrawable is PermissionGroups {\r\n\r\n    event TokenWithdraw(ERC20 token, uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw all ERC20 compatible tokens\r\n     * @param token ERC20 The address of the token contract\r\n     */\r\n    function withdrawToken(ERC20 token, uint amount, address sendTo) external onlyAdmin {\r\n        require(token.transfer(sendTo, amount));\r\n        TokenWithdraw(token, amount, sendTo);\r\n    }\r\n\r\n    event EtherWithdraw(uint amount, address sendTo);\r\n\r\n    /**\r\n     * @dev Withdraw Ethers\r\n     */\r\n    function withdrawEther(uint amount, address sendTo) external onlyAdmin {\r\n        sendTo.transfer(amount);\r\n        EtherWithdraw(amount, sendTo);\r\n    }\r\n}\r\n\r\n\r\n/// @title Kyber constants contract\r\ncontract Utils {\r\n\r\n    ERC20 constant internal ETH_TOKEN_ADDRESS = ERC20(0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee);\r\n    uint  constant internal PRECISION = (10**18);\r\n    uint  constant internal MAX_QTY   = (10**28); // 10B tokens\r\n    uint  constant internal MAX_RATE  = (PRECISION * 10**6); // up to 1M tokens per ETH\r\n    uint  constant internal MAX_DECIMALS = 18;\r\n    uint  constant internal ETH_DECIMALS = 18;\r\n    mapping(address=>uint) internal decimals;\r\n\r\n    function setDecimals(ERC20 token) internal {\r\n        if (token == ETH_TOKEN_ADDRESS) decimals[token] = ETH_DECIMALS;\r\n        else decimals[token] = token.decimals();\r\n    }\r\n\r\n    function getDecimals(ERC20 token) internal view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS) return ETH_DECIMALS; // save storage access\r\n        uint tokenDecimals = decimals[token];\r\n        // technically, there might be token with decimals 0\r\n        // moreover, very possible that old tokens have decimals 0\r\n        // these tokens will just have higher gas fees.\r\n        if(tokenDecimals == 0) return token.decimals();\r\n\r\n        return tokenDecimals;\r\n    }\r\n\r\n    function calcDstQty(uint srcQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(srcQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate * (10**(dstDecimals - srcDecimals))) / PRECISION;\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (srcQty * rate) / (PRECISION * (10**(srcDecimals - dstDecimals)));\r\n        }\r\n    }\r\n\r\n    function calcSrcQty(uint dstQty, uint srcDecimals, uint dstDecimals, uint rate) internal pure returns(uint) {\r\n        require(dstQty <= MAX_QTY);\r\n        require(rate <= MAX_RATE);\r\n\r\n        //source quantity is rounded up. to avoid dest quantity being too low.\r\n        uint numerator;\r\n        uint denominator;\r\n        if (srcDecimals >= dstDecimals) {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty * (10**(srcDecimals - dstDecimals)));\r\n            denominator = rate;\r\n        } else {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            numerator = (PRECISION * dstQty);\r\n            denominator = (rate * (10**(dstDecimals - srcDecimals)));\r\n        }\r\n        return (numerator + denominator - 1) / denominator; //avoid rounding down errors\r\n    }\r\n}\r\n\r\n\r\ncontract Utils2 is Utils {\r\n\r\n    /// @dev get the balance of a user.\r\n    /// @param token The token type\r\n    /// @return The balance\r\n    function getBalance(ERC20 token, address user) public view returns(uint) {\r\n        if (token == ETH_TOKEN_ADDRESS)\r\n            return user.balance;\r\n        else\r\n            return token.balanceOf(user);\r\n    }\r\n\r\n    function getDecimalsSafe(ERC20 token) internal returns(uint) {\r\n\r\n        if (decimals[token] == 0) {\r\n            setDecimals(token);\r\n        }\r\n\r\n        return decimals[token];\r\n    }\r\n\r\n    function calcDestAmount(ERC20 src, ERC20 dest, uint srcAmount, uint rate) internal view returns(uint) {\r\n        return calcDstQty(srcAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcSrcAmount(ERC20 src, ERC20 dest, uint destAmount, uint rate) internal view returns(uint) {\r\n        return calcSrcQty(destAmount, getDecimals(src), getDecimals(dest), rate);\r\n    }\r\n\r\n    function calcRateFromQty(uint srcAmount, uint destAmount, uint srcDecimals, uint dstDecimals)\r\n        internal pure returns(uint)\r\n    {\r\n        require(srcAmount <= MAX_QTY);\r\n        require(destAmount <= MAX_QTY);\r\n\r\n        if (dstDecimals >= srcDecimals) {\r\n            require((dstDecimals - srcDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION / ((10 ** (dstDecimals - srcDecimals)) * srcAmount));\r\n        } else {\r\n            require((srcDecimals - dstDecimals) <= MAX_DECIMALS);\r\n            return (destAmount * PRECISION * (10 ** (srcDecimals - dstDecimals)) / srcAmount);\r\n        }\r\n    }\r\n}\r\n\r\n/// @title Kyber Network interface\r\ninterface KyberNetworkInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(address trader, ERC20 src, uint srcAmount, ERC20 dest, address destAddress,\r\n        uint maxDestAmount, uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n}\r\n\r\n\r\n/// @title Kyber Network interface\r\ninterface KyberNetworkProxyInterface {\r\n    function maxGasPrice() public view returns(uint);\r\n    function getUserCapInWei(address user) public view returns(uint);\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint);\r\n    function enabled() public view returns(bool);\r\n    function info(bytes32 id) public view returns(uint);\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty) public view\r\n        returns (uint expectedRate, uint slippageRate);\r\n\r\n    function tradeWithHint(ERC20 src, uint srcAmount, ERC20 dest, address destAddress, uint maxDestAmount,\r\n        uint minConversionRate, address walletId, bytes hint) public payable returns(uint);\r\n}\r\n\r\n\r\n/// @title simple interface for Kyber Network\r\ninterface SimpleNetworkInterface {\r\n    function swapTokenToToken(ERC20 src, uint srcAmount, ERC20 dest, uint minConversionRate) public returns(uint);\r\n    function swapEtherToToken(ERC20 token, uint minConversionRate) public payable returns(uint);\r\n    function swapTokenToEther(ERC20 token, uint srcAmount, uint minConversionRate) public returns(uint);\r\n}\r\n\r\n\r\n\r\n////////////////////////////////////////////////////////////////////////////////////////////////////////\r\n/// @title Kyber Network proxy for main contract\r\ncontract KyberNetworkProxy is KyberNetworkProxyInterface, SimpleNetworkInterface, Withdrawable, Utils2 {\r\n\r\n    KyberNetworkInterface public kyberNetworkContract;\r\n\r\n    function KyberNetworkProxy(address _admin) public {\r\n        require(_admin != address(0));\r\n        admin = _admin;\r\n    }\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest   Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @return amount of actual dest tokens\r\n    function trade(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            destAddress,\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            walletId,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade between src and dest token and send dest tokens to msg sender\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest Destination token\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapTokenToToken(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        uint minConversionRate\r\n    )\r\n        public\r\n        returns(uint)\r\n    {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade from Ether to token. Sends token to msg sender\r\n    /// @param token Destination token\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapEtherToToken(ERC20 token, uint minConversionRate) public payable returns(uint) {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            ETH_TOKEN_ADDRESS,\r\n            msg.value,\r\n            token,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    /// @dev makes a trade from token to Ether, sends Ether to msg sender\r\n    /// @param token Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @return amount of actual dest tokens\r\n    function swapTokenToEther(ERC20 token, uint srcAmount, uint minConversionRate) public returns(uint) {\r\n        bytes memory hint;\r\n\r\n        return tradeWithHint(\r\n            token,\r\n            srcAmount,\r\n            ETH_TOKEN_ADDRESS,\r\n            msg.sender,\r\n            MAX_QTY,\r\n            minConversionRate,\r\n            0,\r\n            hint\r\n        );\r\n    }\r\n\r\n    struct UserBalance {\r\n        uint srcBalance;\r\n        uint destBalance;\r\n    }\r\n\r\n    event ExecuteTrade(address indexed trader, ERC20 src, ERC20 dest, uint actualSrcAmount, uint actualDestAmount);\r\n\r\n    /// @notice use token address ETH_TOKEN_ADDRESS for ether\r\n    /// @dev makes a trade between src and dest token and send dest token to destAddress\r\n    /// @param src Src token\r\n    /// @param srcAmount amount of src tokens\r\n    /// @param dest Destination token\r\n    /// @param destAddress Address to send tokens to\r\n    /// @param maxDestAmount A limit on the amount of dest tokens\r\n    /// @param minConversionRate The minimal conversion rate. If actual rate is lower, trade is canceled.\r\n    /// @param walletId is the wallet ID to send part of the fees\r\n    /// @param hint will give hints for the trade.\r\n    /// @return amount of actual dest tokens\r\n    function tradeWithHint(\r\n        ERC20 src,\r\n        uint srcAmount,\r\n        ERC20 dest,\r\n        address destAddress,\r\n        uint maxDestAmount,\r\n        uint minConversionRate,\r\n        address walletId,\r\n        bytes hint\r\n    )\r\n        public\r\n        payable\r\n        returns(uint)\r\n    {\r\n        require(src == ETH_TOKEN_ADDRESS || msg.value == 0);\r\n\r\n        UserBalance memory userBalanceBefore;\r\n\r\n        userBalanceBefore.srcBalance = getBalance(src, msg.sender);\r\n        userBalanceBefore.destBalance = getBalance(dest, destAddress);\r\n\r\n        if (src == ETH_TOKEN_ADDRESS) {\r\n            userBalanceBefore.srcBalance += msg.value;\r\n        } else {\r\n            require(src.transferFrom(msg.sender, kyberNetworkContract, srcAmount));\r\n        }\r\n\r\n        uint reportedDestAmount = kyberNetworkContract.tradeWithHint.value(msg.value)(\r\n            msg.sender,\r\n            src,\r\n            srcAmount,\r\n            dest,\r\n            destAddress,\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            walletId,\r\n            hint\r\n        );\r\n\r\n        TradeOutcome memory tradeOutcome = calculateTradeOutcome(\r\n            userBalanceBefore.srcBalance,\r\n            userBalanceBefore.destBalance,\r\n            src,\r\n            dest,\r\n            destAddress\r\n        );\r\n\r\n        require(reportedDestAmount == tradeOutcome.userDeltaDestAmount);\r\n        require(tradeOutcome.userDeltaDestAmount <= maxDestAmount);\r\n        require(tradeOutcome.actualRate >= minConversionRate);\r\n\r\n        ExecuteTrade(msg.sender, src, dest, tradeOutcome.userDeltaSrcAmount, tradeOutcome.userDeltaDestAmount);\r\n        return tradeOutcome.userDeltaDestAmount;\r\n    }\r\n\r\n    event KyberNetworkSet(address newNetworkContract, address oldNetworkContract);\r\n\r\n    function setKyberNetworkContract(KyberNetworkInterface _kyberNetworkContract) public onlyAdmin {\r\n\r\n        require(_kyberNetworkContract != address(0));\r\n\r\n        KyberNetworkSet(_kyberNetworkContract, kyberNetworkContract);\r\n\r\n        kyberNetworkContract = _kyberNetworkContract;\r\n    }\r\n\r\n    function getExpectedRate(ERC20 src, ERC20 dest, uint srcQty)\r\n        public view\r\n        returns(uint expectedRate, uint slippageRate)\r\n    {\r\n        return kyberNetworkContract.getExpectedRate(src, dest, srcQty);\r\n    }\r\n\r\n    function getUserCapInWei(address user) public view returns(uint) {\r\n        return kyberNetworkContract.getUserCapInWei(user);\r\n    }\r\n\r\n    function getUserCapInTokenWei(address user, ERC20 token) public view returns(uint) {\r\n        return kyberNetworkContract.getUserCapInTokenWei(user, token);\r\n    }\r\n\r\n    function maxGasPrice() public view returns(uint) {\r\n        return kyberNetworkContract.maxGasPrice();\r\n    }\r\n\r\n    function enabled() public view returns(bool) {\r\n        return kyberNetworkContract.enabled();\r\n    }\r\n\r\n    function info(bytes32 field) public view returns(uint) {\r\n        return kyberNetworkContract.info(field);\r\n    }\r\n\r\n    struct TradeOutcome {\r\n        uint userDeltaSrcAmount;\r\n        uint userDeltaDestAmount;\r\n        uint actualRate;\r\n    }\r\n\r\n    function calculateTradeOutcome (uint srcBalanceBefore, uint destBalanceBefore, ERC20 src, ERC20 dest,\r\n        address destAddress)\r\n        internal returns(TradeOutcome outcome)\r\n    {\r\n        uint userSrcBalanceAfter;\r\n        uint userDestBalanceAfter;\r\n\r\n        userSrcBalanceAfter = getBalance(src, msg.sender);\r\n        userDestBalanceAfter = getBalance(dest, destAddress);\r\n\r\n        //protect from underflow\r\n        require(userDestBalanceAfter > destBalanceBefore);\r\n        require(srcBalanceBefore > userSrcBalanceAfter);\r\n\r\n        outcome.userDeltaDestAmount = userDestBalanceAfter - destBalanceBefore;\r\n        outcome.userDeltaSrcAmount = srcBalanceBefore - userSrcBalanceAfter;\r\n\r\n        outcome.actualRate = calcRateFromQty(\r\n                outcome.userDeltaSrcAmount,\r\n                outcome.userDeltaDestAmount,\r\n                getDecimalsSafe(src),\r\n                getDecimalsSafe(dest)\r\n            );\r\n    }\r\n}\r\n\r\n\r\n/// @title InstaPay On Chain Reserve Pool Contract\r\n/// @dev 1) Fund contract with ETH, convert everything to DAI. Borrow and repay in DAI.\r\n///      2) Faciliate reserve pool functions: transfer in/out, threshold warning\r\n///         and loan repay.\r\n///      3) Transactions should be tracked on chain. Due to lack of daemon\r\n///         support in this version, it is tracked by mapping for now.\r\n///      TODO: remove mapping when daemon is implemented\r\ncontract InstaPayPool is Ownable {\r\n    /* Ropsten */\r\n    ///  Kyber Network Setup\r\n    // KyberNetworkProxy public proxy = KyberNetworkProxy(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\r\n    // ERC20 DAI = ERC20(0xaD6D458402F60fD3Bd25163575031ACDce07538D);\r\n    // ERC20 ETH = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE); // Dummy ETH token address for Kyber\r\n\r\n    /* MAIN NET */\r\n    ///  Kyber Network Setup\r\n    KyberNetworkProxy public proxy = KyberNetworkProxy(0x818E6FECD516Ecc3849DAf6845e3EC868087B755);\r\n    ERC20 DAI = ERC20(0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359);\r\n    ERC20 ETH = ERC20(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE); // Dummy ETH token address for Kyber\r\n\r\n    uint public DECIMALS = 18;                              // Both DAI & ETH uses 18 decimals\r\n    uint public MAX_DAI_AMOUNT = 100000 * 10 ** DECIMALS;   // Maximum amount of DAI from ETH\r\n    uint public OUTSTANDING_LOAN_AMOUNT = 0;                // in DAI\r\n    uint public THRESHOLD = 10 * 10 ** DECIMALS;            // 10 DAI\r\n    uint public RELOAD_AMOUNT = 5 * 10 ** DECIMALS;         //  5 DAI\r\n    bool public BELOW_THRESHOLD = false;                    // initiate loan order if below\r\n    bool public UNDER_FUNDED = false;                       // pool < outstanding loans\r\n\r\n    mapping(address => uint) public balances;\r\n\r\n    event logThresholdUpdated(uint _oldThreshold, uint _threshold);\r\n    event logReloadAmountUpdated(uint _oldAmount, uint _amount);\r\n\r\n    event warnBelowThreshold(uint _threshold, uint _balance);\r\n    event warnUnderFunded(uint _loanBalance, uint _balance);\r\n\r\n    event logLoanFulfilled(address _borrower, uint _amount);\r\n    event logLoanFailed(address _borrower, uint _amount);\r\n    event logLoanRepaid(address _borrower, uint _amount);\r\n\r\n    event logSwapped(address _src, uint _srcAmount, address _dest, uint _destAmount);\r\n    event logSwapFailed(address _src, uint _srcAmount, address _dest);\r\n\r\n    event logFundReceived(address _sender, uint _amount);\r\n\r\n    // @dev fall back function\r\n    function () external payable {\r\n        revert();\r\n    }\r\n\r\n    // @dev accept ETH funding\r\n    function fund() external payable {\r\n        emit logFundReceived(msg.sender, msg.value);\r\n    }\r\n\r\n    // @dev Convert all ETH to DAI\r\n    function stabilize() public onlyOwner returns(bool success) {\r\n        uint srcQty = address(this).balance;    // Convert all ETH to DAI\r\n        require(\r\n            srcQty > 0,\r\n            \"Nothing to stabilize\"\r\n        );\r\n        uint maxDestAmount = MAX_DAI_AMOUNT;\r\n        uint minConversionRate;\r\n        uint newTokenCount;\r\n        address walletId = address(0);  // not using this param\r\n        (minConversionRate,) = proxy.getExpectedRate(ETH, DAI, srcQty);\r\n        newTokenCount = proxy.trade.value(srcQty)(\r\n            ETH,\r\n            srcQty,\r\n            DAI,\r\n            address(this),\r\n            maxDestAmount,\r\n            minConversionRate,\r\n            walletId\r\n        );\r\n        if (newTokenCount > 0) {\r\n            _checkThreshold();\r\n            _checkLoanBalance();\r\n            emit logSwapped(ETH, srcQty, DAI, newTokenCount);\r\n            success = true;   \r\n        } else {\r\n            emit logSwapFailed(ETH, srcQty, DAI);\r\n        }\r\n    }\r\n\r\n    // @dev Transfer _amount to _borrower wallet, update mapping the loan amount\r\n    // @param _borrower wallet address of the borrower\r\n    // @param _amount in DAI (USD), with 18 decimals\r\n    function loan(address _borrower, uint _amount) public onlyOwner returns(bool success) {\r\n        require(\r\n            _amount > 0 && _amount <= DAI.balanceOf(address(this)),\r\n            \"Invalid amount.\"\r\n        );\r\n        success = DAI.transfer(_borrower, _amount);\r\n\r\n        if (success) {\r\n            // Bookkeeping\r\n            OUTSTANDING_LOAN_AMOUNT += _amount;\r\n            balances[_borrower] = balances[_borrower] + _amount;\r\n            _checkThreshold();\r\n            _checkLoanBalance();\r\n            emit logLoanFulfilled(_borrower, _amount);\r\n        } else {\r\n            emit logLoanFailed(_borrower, _amount);\r\n        }\r\n    }\r\n\r\n    // @dev Need to call DAI.transfer, upon success, trigger a call to this function\r\n    // @param _borrower wallet address of the borrower\r\n    // @param _amount in DAI (USD), with 18 decimals\r\n    function repay(address _borrower, uint _amount) public onlyOwner {\r\n        require(\r\n            _amount > 0 && _amount <= balances[_borrower],\r\n            \"Invalid amount\"\r\n        );\r\n        OUTSTANDING_LOAN_AMOUNT -= _amount;\r\n        balances[_borrower] = balances[_borrower] - _amount;\r\n        _checkThreshold();\r\n        _checkLoanBalance();\r\n    }\r\n\r\n    /* Internal functions: Fund status checks */\r\n    function _checkThreshold() internal {\r\n        if (DAI.balanceOf(address(this)) < THRESHOLD) {\r\n            BELOW_THRESHOLD = true;\r\n            emit warnBelowThreshold(THRESHOLD, address(this).balance);\r\n        } else {\r\n            BELOW_THRESHOLD = false;\r\n        }\r\n    }\r\n\r\n    function _checkLoanBalance() internal {\r\n        if (DAI.balanceOf(address(this)) < OUTSTANDING_LOAN_AMOUNT) {\r\n            UNDER_FUNDED = true;\r\n            emit warnUnderFunded(OUTSTANDING_LOAN_AMOUNT, DAI.balanceOf(address(this)));\r\n        } else {\r\n            UNDER_FUNDED = false;\r\n        }\r\n    }\r\n\r\n    /* Admin functions below */\r\n    function updateThreshold(uint _threshold) external onlyOwner {\r\n        uint oldThreshold = THRESHOLD;\r\n        THRESHOLD = _threshold;\r\n        emit logThresholdUpdated(oldThreshold, _threshold);\r\n    }\r\n\r\n    function updateReloadAmount(uint _amount) external onlyOwner {\r\n        uint oldAmount = RELOAD_AMOUNT;\r\n        RELOAD_AMOUNT = _amount;\r\n        emit logReloadAmountUpdated(oldAmount, _amount);\r\n    }\r\n\r\n    /* Withdraw ETH balance */\r\n    function withdraw() external onlyOwner {\r\n        owner.transfer(address(this).balance);\r\n    }\r\n\r\n    /* Withdraw DAI balance */\r\n    function withdrawDai() external onlyOwner returns(bool success) {\r\n        success = DAI.transfer(owner, DAI.balanceOf(address(this)));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_borrower\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"loan\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_borrower\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"repay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_DAI_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BELOW_THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OUTSTANDING_LOAN_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stabilize\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RELOAD_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"UNDER_FUNDED\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"fund\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"updateThreshold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDai\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"proxy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"updateReloadAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldThreshold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"logThresholdUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"logReloadAmountUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_threshold\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"warnBelowThreshold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_loanBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"}],\"name\":\"warnUnderFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"logLoanFulfilled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"logLoanFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_borrower\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"logLoanRepaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_destAmount\",\"type\":\"uint256\"}],\"name\":\"logSwapped\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_src\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_srcAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_dest\",\"type\":\"address\"}],\"name\":\"logSwapFailed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"logFundReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"InstaPayPool","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://606eb0b98466b9c6dd650ea22941ce099c5c88f7d32dea0c55c9f36ff00195c8"}]}