{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;    \r\n////////////////////////////////////////////////////////////////////////////////\r\nlibrary     SafeMath\r\n{\r\n    //------------------\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        if (a == 0)     return 0;\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        return a/b;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract    ERC20 \r\n{\r\n    using SafeMath  for uint256;\r\n\r\n    //----- VARIABLES\r\n\r\n    address public              owner;          // Owner of this contract\r\n    address public              admin;          // The one who is allowed to do changes \r\n\r\n    mapping(address => uint256)                         balances;       // Maintain balance in a mapping\r\n    mapping(address => mapping (address => uint256))    allowances;     // Allowances index-1 = Owner account   index-2 = spender account\r\n\r\n    //------ TOKEN SPECIFICATION\r\n\r\n    string  public  constant    name     = \"Reger Diamond Security Token\";\r\n    string  public  constant    symbol   = \"RDS\";\r\n\r\n    uint256 public  constant    decimals = 18;\r\n    \r\n    uint256 public  constant    initSupply       = 60000000 * 10**decimals;        // 10**18 max\r\n    uint256 public  constant    supplyReserveVal = 37500000 * 10**decimals;          // if quantity => the ##MACRO## addrs \"* 10**decimals\" \r\n\r\n    //-----\r\n\r\n    uint256 public              totalSupply;\r\n    uint256 public              icoSalesSupply   = 0;                   // Needed when burning tokens\r\n    uint256 public              icoReserveSupply = 0;\r\n    uint256 public              softCap =  5000000   * 10**decimals;\r\n    uint256 public              hardCap = 21500000   * 10**decimals;\r\n\r\n    //---------------------------------------------------- smartcontract control\r\n\r\n    uint256 public              icoDeadLine = 1533513600;     // 2018-08-06 00:00 (GMT+0)   not needed\r\n\r\n    bool    public              isIcoPaused            = false; \r\n    bool    public              isStoppingIcoOnHardCap = true;\r\n\r\n    //--------------------------------------------------------------------------\r\n\r\n    modifier duringIcoOnlyTheOwner()  // if not during the ico : everyone is allowed at anytime\r\n    { \r\n        require( now>icoDeadLine || msg.sender==owner );\r\n        _;\r\n    }\r\n\r\n    modifier icoFinished()          { require(now > icoDeadLine);           _; }\r\n    modifier icoNotFinished()       { require(now <= icoDeadLine);          _; }\r\n    modifier icoNotPaused()         { require(isIcoPaused==false);          _; }\r\n    modifier icoPaused()            { require(isIcoPaused==true);           _; }\r\n    modifier onlyOwner()            { require(msg.sender==owner);           _; }\r\n    modifier onlyAdmin()            { require(msg.sender==admin);           _; }\r\n\r\n    //----- EVENTS\r\n\r\n    event Transfer(address indexed fromAddr, address indexed toAddr,   uint256 amount);\r\n    event Approval(address indexed _owner,   address indexed _spender, uint256 amount);\r\n\r\n            //---- extra EVENTS\r\n\r\n    event onAdminUserChanged(   address oldAdmin,       address newAdmin);\r\n    event onOwnershipTransfered(address oldOwner,       address newOwner);\r\n    event onIcoDeadlineChanged( uint256 oldIcoDeadLine, uint256 newIcoDeadline);\r\n    event onHardcapChanged(     uint256 hardCap,        uint256 newHardCap);\r\n    event icoIsNowPaused(       uint8 newPauseStatus);\r\n    event icoHasRestarted(      uint8 newPauseStatus);\r\n\r\n    event log(string key, string value);\r\n    event log(string key, uint   value);\r\n\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    constructor()   public \r\n    {\r\n        owner       = msg.sender;\r\n        admin       = owner;\r\n\r\n        isIcoPaused = false;\r\n        \r\n        //-----\r\n\r\n        balances[owner] = initSupply;   // send the tokens to the owner\r\n        totalSupply     = initSupply;\r\n        icoSalesSupply  = totalSupply;   \r\n\r\n        //----- Handling if there is a special maximum amount of tokens to spend during the ICO or not\r\n\r\n        icoSalesSupply   = totalSupply.sub(supplyReserveVal);\r\n        icoReserveSupply = totalSupply.sub(icoSalesSupply);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //----- ERC20 FUNCTIONS\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function balanceOf(address walletAddress) public constant returns (uint256 balance) \r\n    {\r\n        return balances[walletAddress];\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function transfer(address toAddr, uint256 amountInWei)  public   duringIcoOnlyTheOwner   returns (bool)     // don't icoNotPaused here. It's a logic issue. \r\n    {\r\n        require(toAddr!=0x0 && toAddr!=msg.sender && amountInWei>0);     // Prevent transfer to 0x0 address and to self, amount must be >0\r\n\r\n        uint256 availableTokens = balances[msg.sender];\r\n\r\n        //----- Checking Token reserve first : if during ICO    \r\n\r\n        if (msg.sender==owner && now <= icoDeadLine)                    // ICO Reserve Supply checking: Don't touch the RESERVE of tokens when owner is selling\r\n        {\r\n            assert(amountInWei<=availableTokens);\r\n\r\n            uint256 balanceAfterTransfer = availableTokens.sub(amountInWei);      \r\n\r\n            assert(balanceAfterTransfer >= icoReserveSupply);           // We try to sell more than allowed during an ICO\r\n        }\r\n\r\n        //-----\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(amountInWei);\r\n        balances[toAddr]     = balances[toAddr].add(amountInWei);\r\n\r\n        emit Transfer(msg.sender, toAddr, amountInWei);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function allowance(address walletAddress, address spender) public constant returns (uint remaining)\r\n    {\r\n        return allowances[walletAddress][spender];\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function transferFrom(address fromAddr, address toAddr, uint256 amountInWei)  public  returns (bool) \r\n    {\r\n        if (amountInWei <= 0)                                   return false;\r\n        if (allowances[fromAddr][msg.sender] < amountInWei)     return false;\r\n        if (balances[fromAddr] < amountInWei)                   return false;\r\n\r\n        balances[fromAddr]               = balances[fromAddr].sub(amountInWei);\r\n        balances[toAddr]                 = balances[toAddr].add(amountInWei);\r\n        allowances[fromAddr][msg.sender] = allowances[fromAddr][msg.sender].sub(amountInWei);\r\n\r\n        emit Transfer(fromAddr, toAddr, amountInWei);\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function approve(address spender, uint256 amountInWei) public returns (bool) \r\n    {\r\n        require((amountInWei == 0) || (allowances[msg.sender][spender] == 0));\r\n        allowances[msg.sender][spender] = amountInWei;\r\n        emit Approval(msg.sender, spender, amountInWei);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function() public                       \r\n    {\r\n        assert(true == false);      // If Ether is sent to this address, don't handle it -> send it back.\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function transferOwnership(address newOwner) public onlyOwner               // @param newOwner The address to transfer ownership to.\r\n    {\r\n        require(newOwner != address(0));\r\n\r\n        emit onOwnershipTransfered(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    changeAdminUser(address newAdminAddress) public onlyOwner\r\n    {\r\n        require(newAdminAddress!=0x0);\r\n\r\n        emit onAdminUserChanged(admin, newAdminAddress);\r\n        admin = newAdminAddress;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    changeIcoDeadLine(uint256 newIcoDeadline) public onlyAdmin\r\n    {\r\n        require(newIcoDeadline!=0);\r\n\r\n        emit onIcoDeadlineChanged(icoDeadLine, newIcoDeadline);\r\n        icoDeadLine = newIcoDeadline;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    changeHardCap(uint256 newHardCap) public onlyAdmin\r\n    {\r\n        require(newHardCap!=0);\r\n\r\n        emit onHardcapChanged(hardCap, newHardCap);\r\n        hardCap = newHardCap;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    isHardcapReached()  public view returns(bool)\r\n    {\r\n        return (isStoppingIcoOnHardCap && initSupply-balances[owner] > hardCap);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    pauseICO()  public onlyAdmin\r\n    {\r\n        isIcoPaused = true;\r\n        emit icoIsNowPaused(1);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    unpauseICO()  public onlyAdmin\r\n    {\r\n        isIcoPaused = false;\r\n        emit icoHasRestarted(0);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    isPausedICO() public view     returns(bool)\r\n    {\r\n        return (isIcoPaused) ? true : false;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract    DateTime \r\n{\r\n    struct TDateTime \r\n    {\r\n        uint16 year;    uint8 month;    uint8 day;\r\n        uint8 hour;     uint8 minute;   uint8 second;\r\n        uint8 weekday;\r\n    }\r\n    uint8[] totalDays = [ 0,   31,28,31,30,31,30,  31,31,30,31,30,31];\r\n    uint constant DAY_IN_SECONDS       = 86400;\r\n    uint constant YEAR_IN_SECONDS      = 31536000;\r\n    uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n    uint constant HOUR_IN_SECONDS      = 3600;\r\n    uint constant MINUTE_IN_SECONDS    = 60;\r\n    uint16 constant ORIGIN_YEAR        = 1970;\r\n    //-------------------------------------------------------------------------\r\n    function isLeapYear(uint16 year) public pure returns (bool) \r\n    {\r\n        if ((year %   4)!=0)    return false;\r\n        if ( year % 100 !=0)    return true;\r\n        if ( year % 400 !=0)    return false;\r\n        return true;\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function leapYearsBefore(uint year) public pure returns (uint) \r\n    {\r\n        year -= 1;\r\n        return year / 4 - year / 100 + year / 400;\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) \r\n    {\r\n        uint8   nDay = 30;\r\n             if (month==1)          nDay++;\r\n        else if (month==3)          nDay++;\r\n        else if (month==5)          nDay++;\r\n        else if (month==7)          nDay++;\r\n        else if (month==8)          nDay++;\r\n        else if (month==10)         nDay++;\r\n        else if (month==12)         nDay++;\r\n        else if (month==2) \r\n        {\r\n                                    nDay = 28;\r\n            if (isLeapYear(year))   nDay++;\r\n        }\r\n        return nDay;\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function parseTimestamp(uint timestamp) internal pure returns (TDateTime dt) \r\n    {\r\n        uint  secondsAccountedFor = 0;\r\n        uint  buf;\r\n        uint8 i;\r\n        uint  secondsInMonth;\r\n        dt.year = getYear(timestamp);\r\n        buf     = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n        secondsAccountedFor += YEAR_IN_SECONDS   * (dt.year - ORIGIN_YEAR - buf);\r\n        for (i = 1; i <= 12; i++) \r\n        {\r\n            secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n            if (secondsInMonth + secondsAccountedFor > timestamp) \r\n            {\r\n                dt.month = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += secondsInMonth;\r\n        }\r\n        for (i=1; i<=getDaysInMonth(dt.month, dt.year); i++) \r\n        {\r\n            if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) \r\n            {\r\n                dt.day = i;\r\n                break;\r\n            }\r\n            secondsAccountedFor += DAY_IN_SECONDS;\r\n        }\r\n        dt.hour    = getHour(timestamp);\r\n        dt.minute  = getMinute(timestamp);\r\n        dt.second  = getSecond(timestamp);\r\n        dt.weekday = getWeekday(timestamp);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getYear(uint timestamp) public pure returns (uint16) \r\n    {\r\n        uint secondsAccountedFor = 0;\r\n        uint16 year;\r\n        uint numLeapYears;\r\n        year         = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n        numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n        secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n        secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n        while (secondsAccountedFor > timestamp) \r\n        {\r\n            if (isLeapYear(uint16(year - 1)))   secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n            else                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n            year -= 1;\r\n        }\r\n        return year;\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getMonth(uint timestamp) public pure returns (uint8) \r\n    {\r\n        return parseTimestamp(timestamp).month;\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getDay(uint timestamp) public pure returns (uint8) \r\n    {\r\n        return parseTimestamp(timestamp).day;\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getHour(uint timestamp) public pure returns (uint8) \r\n    {\r\n        return uint8(((timestamp % 86400) / 3600) % 24);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getMinute(uint timestamp) public pure returns (uint8) \r\n    {\r\n        return uint8((timestamp % 3600) / 60);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getSecond(uint timestamp) public pure returns (uint8) \r\n    {\r\n        return uint8(timestamp % 60);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getWeekday(uint timestamp) public pure returns (uint8) \r\n    {\r\n        return uint8((timestamp / DAY_IN_SECONDS + 4) % 7);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) \r\n    {\r\n        return toTimestamp(year, month, day, 0, 0, 0);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) \r\n    {\r\n        return toTimestamp(year, month, day, hour, 0, 0);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) \r\n    {\r\n        return toTimestamp(year, month, day, hour, minute, 0);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) \r\n    {\r\n        uint16 i;\r\n        for (i = ORIGIN_YEAR; i < year; i++) \r\n        {\r\n            if (isLeapYear(i))  timestamp += LEAP_YEAR_IN_SECONDS;\r\n            else                timestamp += YEAR_IN_SECONDS;\r\n        }\r\n        uint8[12] memory monthDayCounts;\r\n        monthDayCounts[0]  = 31;\r\n        monthDayCounts[1]  = 28;     if (isLeapYear(year))   monthDayCounts[1] = 29;\r\n        monthDayCounts[2]  = 31;\r\n        monthDayCounts[3]  = 30;\r\n        monthDayCounts[4]  = 31;\r\n        monthDayCounts[5]  = 30;\r\n        monthDayCounts[6]  = 31;\r\n        monthDayCounts[7]  = 31;\r\n        monthDayCounts[8]  = 30;\r\n        monthDayCounts[9]  = 31;\r\n        monthDayCounts[10] = 30;\r\n        monthDayCounts[11] = 31;\r\n        for (i=1; i<month; i++) \r\n        {\r\n            timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n        }\r\n        timestamp += DAY_IN_SECONDS    * (day - 1);\r\n        timestamp += HOUR_IN_SECONDS   * (hour);\r\n        timestamp += MINUTE_IN_SECONDS * (minute);\r\n        timestamp += second;\r\n        return timestamp;\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getYearDay(uint timestamp) public pure returns (uint16)\r\n    {\r\n        TDateTime memory date = parseTimestamp(timestamp);\r\n        uint16 dayCount=0;\r\n        for (uint8 iMonth=1; iMonth<date.month; iMonth++)\r\n        {\r\n            dayCount += getDaysInMonth(iMonth, date.year);\r\n        }\r\n        dayCount += date.day;   \r\n        return dayCount;        // We have now the amount of days since January 1st of that year\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function getDaysInYear(uint16 year) public pure returns (uint16)\r\n    {\r\n        return (isLeapYear(year)) ? 366:365;\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function    dateToTimestamp(uint16 iYear, uint8 iMonth, uint8 iDay) public pure returns(uint)\r\n    {\r\n        uint8 monthDayCount = 30;\r\n        if (iMonth==2)\r\n        {\r\n                                    monthDayCount = 28;\r\n            if (isLeapYear(iYear))  monthDayCount++;\r\n        }\r\n        if (iMonth==4 || iMonth==6 || iMonth==9 || iMonth==11)\r\n        {\r\n            monthDayCount = 31;\r\n        }\r\n        if (iDay<1)           \r\n        {\r\n            iDay = 1;\r\n        }\r\n        else if (iDay>monthDayCount)     \r\n        {\r\n            iDay = 1;       // if day is over limit, set the date on the first day of the next month\r\n            iMonth++;\r\n            if (iMonth>12)  \r\n            {\r\n                iMonth=1;\r\n                iYear++;\r\n            }\r\n        }\r\n        return toTimestamp(iYear, iMonth, iDay);\r\n    }\r\n    //-------------------------------------------------------------------------\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract    CompoundContract  is  ERC20, DateTime\r\n{\r\n    using SafeMath  for uint256;\r\n\r\n        bool private    isLiveTerm = true;\r\n\r\n    struct TCompoundItem\r\n    {\r\n        uint        id;                         // an HASH to distinguish each compound in contract\r\n        uint        plan;                       // 1: Sapphire   2: Emerald   3:Ruby   4: Diamond\r\n        address     investor;                   // wallet address of the owner of this compound contract\r\n        uint        tokenCapitalInWei;          // = capital\r\n        uint        tokenEarningsInWei;         // This contract will geneeate this amount of tokens for the investor\r\n        uint        earningPerTermInWei;        // Every \"3 months\" the investor will receive this amount of money\r\n        uint        currentlyEarnedInWei;       // cumulative amount of tokens already received\r\n        uint        tokenEarnedInWei;           // = totalEarnings\r\n        uint        overallTokensInWei;         // = capital + totalEarnings\r\n        uint        contractMonthCount;         // 12 or 24\r\n        uint        startTimestamp;\r\n        uint        endTimestamp;               // the date when the compound contract will cease\r\n        uint        interestRate;\r\n        uint        percent;\r\n        bool        isAllPaid;                  // if true : all compound earning has been given. Nothing more to do\r\n        uint8       termPaidCount;              //\r\n        uint8       termCount;                  //\r\n        bool        isContractValidated;        // Any compound contract needs to be confirmed otherwise they will be cancelled\r\n        bool        isCancelled;                // The compound contract was not validated and has been set to cancelled!\r\n    }\r\n\r\n    mapping(address => uint256)                 lockedCapitals;     // During ICO we block some of the tokens\r\n    mapping(address => uint256)                 lockedEarnings;     // During ICO we block some of the tokens\r\n\r\n    mapping(uint256 => bool)         private    activeContractStatues;      // Use when doing a payEarnings to navigate through all contracts\r\n    mapping(uint => TCompoundItem)   private    contracts;\r\n    mapping(uint256 => uint32[12])   private    compoundPayTimes;    \r\n    mapping(uint256 => uint8[12])    private    compoundPayStatus;          // to know if a compound has already been paid or not. So not repaying again    \r\n\r\n    event onCompoundContractCompleted(address investor, uint256 compoundId, \r\n                                                        uint256 capital, \r\n                                                        uint256 earnedAmount, \r\n                                                        uint256 total, \r\n                                                        uint256 timestamp);\r\n\r\n    event onCompoundEarnings(address investor,  uint256 compoundId, \r\n                                                uint256 capital, \r\n                                                uint256 earnedAmount, \r\n                                                uint256 earnedSoFarAmount, \r\n                                                uint32  timestamp,\r\n                                                uint8   paidTermCount,\r\n                                                uint8   totalTermCount);\r\n\r\n    event onCompoundContractLocked(address fromAddr, address toAddr, uint256 amountToLockInWei);\r\n    event onPayEarningsDone(uint contractId, uint nPaid, uint paymentCount, uint paidAmountInWei);\r\n\r\n    event onCompoundContractCancelled(uint contractId, uint lockedCapital, uint lockedEarnings);\r\n    event onCompoundContractValidated(uint contractId);\r\n\r\n    //--------------------------------------------------------------------------\r\n    function    initCompoundContract(address buyerAddress, uint256 amountInWei, uint256 compoundContractId, uint monthCount)  internal onlyOwner  returns(bool)\r\n    {\r\n        TCompoundItem memory    item;\r\n        uint                    overallTokensInWei; \r\n        uint                    tokenEarningsInWei;\r\n        uint                    earningPerTermInWei; \r\n        uint                    percentToUse; \r\n        uint                    interestRate;\r\n        uint                    i;\r\n\r\n        if (activeContractStatues[compoundContractId])\r\n        {\r\n            return false;       // the specified contract is already in place. Don't alter already running contract!!!\r\n        }\r\n\r\n        activeContractStatues[compoundContractId] = true;\r\n\r\n        //----- Calculate the contract revenue generated for the whole monthPeriod\r\n\r\n        (overallTokensInWei, \r\n         tokenEarningsInWei,\r\n         earningPerTermInWei, \r\n         percentToUse, \r\n         interestRate,\r\n         i) = calculateCompoundContract(amountInWei, monthCount);\r\n\r\n        item.plan = i;                  // Not enough stack depth. using i here\r\n\r\n        //----- Checking if we can apply this compound contract or not\r\n\r\n        if (percentToUse==0)        // an error occured\r\n        {\r\n            return false;\r\n        }\r\n\r\n        //----- Calculate when to do payments for that contract\r\n\r\n        generateCompoundTerms(compoundContractId);\r\n\r\n        //-----\r\n\r\n        item.id                   = compoundContractId;\r\n        item.startTimestamp       = now;\r\n\r\n        item.contractMonthCount   = monthCount;\r\n        item.interestRate         = interestRate;\r\n        item.percent              = percentToUse;\r\n        item.investor             = buyerAddress;\r\n        item.isAllPaid            = false;\r\n        item.termCount            = uint8(monthCount/3);\r\n        item.termPaidCount        = 0;\r\n\r\n        item.tokenCapitalInWei    = amountInWei;\r\n        item.currentlyEarnedInWei = 0;\r\n        item.overallTokensInWei   = overallTokensInWei;\r\n        item.tokenEarningsInWei   = tokenEarningsInWei;\r\n        item.earningPerTermInWei  = earningPerTermInWei;\r\n\r\n        item.isCancelled          = false;\r\n        item.isContractValidated  = false;                      // any contract must be validated 35 days after its creation.\r\n\r\n        //-----\r\n\r\n        contracts[compoundContractId] = item;\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    generateCompoundTerms(uint256 compoundContractId)    private\r\n    {\r\n        uint16 iYear  =  getYear(now);\r\n        uint8  iMonth = getMonth(now);\r\n        uint   i;\r\n\r\n        if (isLiveTerm)\r\n        {\r\n            for (i=0; i<8; i++)             // set every pay schedule date (every 3 months)  8 means 2 years payments every 3 months\r\n            {\r\n                iMonth += 3;        // every 3 months\r\n                if (iMonth>12)\r\n                {\r\n                    iYear++;\r\n                    iMonth -= 12;\r\n                }\r\n\r\n                compoundPayTimes[compoundContractId][i]  = uint32(dateToTimestamp(iYear, iMonth, getDay(now)));\r\n                compoundPayStatus[compoundContractId][i] = 0;      \r\n            }\r\n        }\r\n        else\r\n        {\r\n            uint timeSum=now;\r\n            for (i=0; i<8; i++)             // set every pay schedule date (every 3 months)  8 means 2 years payments every 3 months\r\n            {\r\n                            uint duration = 4*60;    // set first period longer to allow confirmation of the contract\r\n                if (i>0)         duration = 2*60;\r\n\r\n                timeSum += duration;\r\n\r\n                compoundPayTimes[compoundContractId][i]  = uint32(timeSum);     // DEBUGING: pay every 3 minutes\r\n                compoundPayStatus[compoundContractId][i] = 0;      \r\n            }\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    calculateCompoundContract(uint256 capitalInWei, uint contractMonthCount)   public  constant returns(uint, uint, uint, uint, uint, uint)    // DON'T Set as pure, otherwise it will make investXXMonths function unusable (too much gas) \r\n    {\r\n        /*  12 months   Sapphire    From     100 to   1,000     12%\r\n                        Emerald     From   1,000 to  10,000     15%\r\n                        Rub         From  10,000 to 100,000     17%\r\n                        Diamond                     100,000+    20%\r\n            24 months   Sapphire    From     100 to   1,000     15%\r\n                        Emerald     From   1,000 to  10,000     17%\r\n                        Rub         From  10,000 to 100,000     20%\r\n                        Diamond                     100,000+    30%        */\r\n\r\n        uint    plan          = 0;\r\n        uint256 interestRate  = 0;\r\n        uint256 percentToUse  = 0;\r\n\r\n        if (contractMonthCount==12)\r\n        {\r\n                 if (capitalInWei<  1000 * 10**18)      { percentToUse=12;  interestRate=1125509;   plan=1; }   // SAPPHIRE\r\n            else if (capitalInWei< 10000 * 10**18)      { percentToUse=15;  interestRate=1158650;   plan=2; }   // EMERALD\r\n            else if (capitalInWei<100000 * 10**18)      { percentToUse=17;  interestRate=1181148;   plan=3; }   // RUBY\r\n            else                                        { percentToUse=20;  interestRate=1215506;   plan=4; }   // DIAMOND\r\n        }\r\n        else if (contractMonthCount==24)\r\n        {\r\n                 if (capitalInWei<  1000 * 10**18)      { percentToUse=15;  interestRate=1342471;   plan=1; }\r\n            else if (capitalInWei< 10000 * 10**18)      { percentToUse=17;  interestRate=1395110;   plan=2; }\r\n            else if (capitalInWei<100000 * 10**18)      { percentToUse=20;  interestRate=1477455;   plan=3; }\r\n            else                                        { percentToUse=30;  interestRate=1783478;   plan=4; }\r\n        }\r\n        else\r\n        {\r\n            return (0,0,0,0,0,0);                   // only 12 and 24 months are allowed here\r\n        }\r\n\r\n        uint256 overallTokensInWei  = (capitalInWei *  interestRate         ) / 1000000;\r\n        uint256 tokenEarningsInWei  = overallTokensInWei - capitalInWei;\r\n        uint256 earningPerTermInWei = tokenEarningsInWei / (contractMonthCount/3);      // 3 is for => Pays a Term of earning every 3 months\r\n\r\n        return (overallTokensInWei,tokenEarningsInWei,earningPerTermInWei, percentToUse, interestRate, plan);\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    lockMoneyOnCompoundCreation(address toAddr, uint compountContractId)  internal  onlyOwner   returns (bool) \r\n    {\r\n        require(toAddr!=0x0 && toAddr!=msg.sender);     // Prevent transfer to 0x0 address and to self, amount must be >0\r\n\r\n        if (isHardcapReached())                                         \r\n        {\r\n            return false;       // an extra check first, who knows. \r\n        }\r\n\r\n        TCompoundItem memory item = contracts[compountContractId];\r\n\r\n        if (item.tokenCapitalInWei==0 || item.tokenEarningsInWei==0)    \r\n        {\r\n            return false;       // don't valid such invalid contract\r\n        }\r\n\r\n        //-----\r\n\r\n        uint256 amountToLockInWei = item.tokenCapitalInWei + item.tokenEarningsInWei;\r\n        uint256 availableTokens   = balances[owner];\r\n\r\n        if (amountToLockInWei <= availableTokens)\r\n        {\r\n            uint256 balanceAfterTransfer = availableTokens.sub(amountToLockInWei);      \r\n\r\n            if (balanceAfterTransfer >= icoReserveSupply)       // don't sell more than allowed during ICO\r\n            {\r\n                lockMoney(toAddr, item.tokenCapitalInWei, item.tokenEarningsInWei);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        //emit log('Exiting lockMoneyOnCompoundCreation', 'cannot lock money');\r\n        return false;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    payCompoundTerm(uint contractId, uint8 termId, uint8 isCalledFromOutside)   public onlyOwner returns(int32)        // DON'T SET icoNotPaused here, since a runnnig compound needs to run anyway\r\n    {\r\n        uint                    id;\r\n        address                 investor;\r\n        uint                    paidAmount;\r\n        TCompoundItem   memory  item;\r\n\r\n        if (!activeContractStatues[contractId])         \r\n        {\r\n            emit log(\"payCompoundTerm\", \"Specified contract is not actived (-1)\");\r\n            return -1;\r\n        }\r\n\r\n        item = contracts[contractId];\r\n\r\n        //----- \r\n        if (item.isCancelled)   // That contract was never validated!!!\r\n        {\r\n            emit log(\"payCompoundTerm\", \"Compound contract already cancelled (-2)\");\r\n            return -2;\r\n        }\r\n\r\n        //-----\r\n\r\n        if (item.isAllPaid)                             \r\n        {\r\n            emit log(\"payCompoundTerm\", \"All earnings already paid for this contract (-2)\");\r\n            return -4;   // everything was paid already\r\n        }\r\n\r\n        id = item.id;\r\n\r\n        if (compoundPayStatus[id][termId]!=0)           \r\n        {\r\n            emit log(\"payCompoundTerm\", \"Specified contract's term was already paid (-5)\");\r\n            return -5;\r\n        }\r\n\r\n        if (now < compoundPayTimes[id][termId])         \r\n        {\r\n            emit log(\"payCompoundTerm\", \"It's too early to pay this term (-6)\");\r\n            return -6;\r\n        }\r\n\r\n        investor = item.investor;                                   // address of the owner of this compound contract\r\n\r\n        //----- It's time for the payment, but was that contract already validated\r\n        //----- If it was not validated, simply refund tokens to the main wallet\r\n\r\n        if (!item.isContractValidated)                          // Compound contract self-destruction since no validation was made of it\r\n        {\r\n            uint    capital  = item.tokenCapitalInWei;\r\n            uint    earnings = item.tokenEarningsInWei;\r\n\r\n            contracts[contractId].isCancelled        = true;\r\n            contracts[contractId].tokenCapitalInWei  = 0;       /// make sure nothing residual is left\r\n            contracts[contractId].tokenEarningsInWei = 0;       ///\r\n\r\n            //-----\r\n\r\n            lockedCapitals[investor] = lockedCapitals[investor].sub(capital);\r\n            lockedEarnings[investor] = lockedEarnings[investor].sub(earnings);\r\n\r\n            balances[owner] = balances[owner].add(capital);\r\n            balances[owner] = balances[owner].add(earnings);\r\n\r\n            emit onCompoundContractCancelled(contractId, capital, earnings);\r\n            emit log(\"payCompoundTerm\", \"Cancelling compound contract (-3)\");\r\n            return -3;\r\n        }\r\n\r\n        //---- it's PAY time!!!\r\n\r\n        contracts[id].termPaidCount++;\r\n        contracts[id].currentlyEarnedInWei += item.earningPerTermInWei;  \r\n\r\n        compoundPayStatus[id][termId] = 1;                          // PAID!!!      meaning not to repay again this revenue term \r\n\r\n        unlockEarnings(investor, item.earningPerTermInWei);\r\n\r\n        paidAmount = item.earningPerTermInWei;\r\n\r\n        if (contracts[id].termPaidCount>=item.termCount && !contracts[item.id].isAllPaid)   // This is the last payment of all payments for this contract\r\n        {\r\n            contracts[id].isAllPaid = true;\r\n\r\n            unlockCapital(investor, item.tokenCapitalInWei);\r\n\r\n            paidAmount += item.tokenCapitalInWei;\r\n        }\r\n\r\n        //----- let's tell the blockchain now how many we've unlocked.\r\n\r\n        if (isCalledFromOutside==0 && paidAmount>0)\r\n        {\r\n            emit Transfer(owner, investor, paidAmount);\r\n        }\r\n\r\n        return 1;       // We just paid one earning!!!\r\n                        // 1 IS IMPORTANT FOR THE TOKEN API. don't change it\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    validateCompoundContract(uint contractId) public onlyOwner   returns(uint)\r\n    {\r\n        TCompoundItem memory  item = contracts[contractId];\r\n\r\n        if (item.isCancelled==true)\r\n        {\r\n            return 2;       // don't try to validated an already dead contract\r\n        }\r\n\r\n        contracts[contractId].isCancelled         = false;\r\n        contracts[contractId].isContractValidated = true;\r\n\r\n        emit onCompoundContractValidated(contractId);\r\n\r\n        return 1;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //-----\r\n    //----- When an investor (investor) is put money (capital) in a compound investor\r\n    //----- We do calculate all interests (earnings) he will receive for the whole contract duration\r\n    //----- Then we lock the capital and the earnings into special vaults.\r\n    //----- We remove from the main token balance the capital invested and the future earnings\r\n    //----- So there won't be wrong calculation when people wishes to buy tokens\r\n    //-----\r\n    //----- If you use the standard ERC20 balanceOf to check balance of an investor, you will see\r\n    //----- balance = 0, if he just invested. This is normal, since money is locked in other vaults.\r\n    //----- To check the exact money of the investor, use instead :\r\n    //----- lockedCapitalOf(address investor)  \r\n    //----- to see the amount of money he fully invested and which which is still not available to him\r\n    //----- Use also\r\n    //----- locakedEarningsOf(address investor)\r\n    //----- It will show all the remaining benefit the person will get soon. The amount shown by This\r\n    //----- function will decrease from time to time, while the real balanceOf(address investor)\r\n    //----- will increase\r\n    //-----\r\n    //--------------------------------------------------------------------------\r\n    function    lockMoney(address investor, uint capitalAmountInWei, uint totalEarningsToReceiveInWei) internal onlyOwner\r\n    {\r\n        uint totalAmountToLockInWei = capitalAmountInWei + totalEarningsToReceiveInWei;\r\n\r\n        if (totalAmountToLockInWei <= balances[owner])\r\n        {\r\n            balances[owner] = balances[owner].sub(capitalAmountInWei.add(totalEarningsToReceiveInWei));     /// We remove capital & future earning from the Token's main balance, to put money in safe areas\r\n\r\n            lockedCapitals[investor] = lockedCapitals[investor].add(capitalAmountInWei);            /// The capital invested is now locked during the whole contract\r\n            lockedEarnings[investor] = lockedEarnings[investor].add(totalEarningsToReceiveInWei);   /// The whole earnings is full locked also in another vault called lockedEarnings\r\n\r\n            emit Transfer(owner, investor, capitalAmountInWei);    // No need to show all locked amounts. Because these locked ones contain capital + future earnings. \r\n        }                                                            // So we just show the capital. the earnings will appear after each payment.\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    unlockCapital(address investor, uint amountToUnlockInWei) internal onlyOwner\r\n    {\r\n        if (amountToUnlockInWei <= lockedCapitals[investor])\r\n        {\r\n            balances[investor]       = balances[investor].add(amountToUnlockInWei);\r\n            lockedCapitals[investor] = lockedCapitals[investor].sub(amountToUnlockInWei);    /// So to make all locked tokens available\r\n\r\n            //---- No need of emit Transfer here. It is called from elsewhere\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    unlockEarnings(address investor, uint amountToUnlockInWei) internal onlyOwner\r\n    {\r\n        if (amountToUnlockInWei <= lockedEarnings[investor])\r\n        {\r\n            balances[investor]       = balances[investor].add(amountToUnlockInWei);\r\n            lockedEarnings[investor] = lockedEarnings[investor].sub(amountToUnlockInWei);    /// So to make all locked tokens available\r\n\r\n            //---- No need of emit Transfer here. It is called from elsewhere\r\n        }\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    lockedCapitalOf(address investor) public  constant  returns(uint256)\r\n    {\r\n        return lockedCapitals[investor];\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    lockedEarningsOf(address investor) public  constant  returns(uint256)\r\n    {\r\n        return lockedEarnings[investor];\r\n    }  \r\n    //--------------------------------------------------------------------------\r\n    function    lockedBalanceOf(address investor) public  constant  returns(uint256)\r\n    {\r\n        return lockedCapitals[investor] + lockedEarnings[investor];\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    geCompoundTimestampsFor12Months(uint contractId) public view  returns(uint256,uint256,uint256,uint256)\r\n    {\r\n        uint32[12] memory t = compoundPayTimes[contractId];\r\n\r\n        return(uint256(t[0]),uint256(t[1]),uint256(t[2]),uint256(t[3]));\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function    geCompoundTimestampsFor24Months(uint contractId) public view  returns(uint256,uint256,uint256,uint256,uint256,uint256,uint256,uint256)\r\n    {\r\n        uint32[12] memory t = compoundPayTimes[contractId];\r\n\r\n        return(uint256(t[0]),uint256(t[1]),uint256(t[2]),uint256(t[3]),uint256(t[4]),uint256(t[5]),uint256(t[6]),uint256(t[7]));\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function    getCompoundContract(uint contractId) public constant    returns(address investor, \r\n                                                                        uint capital, \r\n                                                                        uint profitToGenerate,\r\n                                                                        uint earnedSoFarAmount, \r\n                                                                        uint percent,\r\n                                                                        uint interestRate,\r\n                                                                        uint paidTermCount,\r\n                                                                        uint isAllPaid,\r\n                                                                        uint monthCount,\r\n                                                                        uint earningPerTerm,\r\n                                                                        uint isCancelled)\r\n    {\r\n        TCompoundItem memory item;\r\n\r\n        item = contracts[contractId];\r\n\r\n        return\r\n        (\r\n            item.investor,\r\n            item.tokenCapitalInWei,\r\n            item.tokenEarningsInWei,\r\n            item.currentlyEarnedInWei,\r\n            item.percent,\r\n            item.interestRate,\r\n            uint(item.termPaidCount),\r\n            (item.isAllPaid) ? 1:0,\r\n            item.contractMonthCount,\r\n            item.earningPerTermInWei,\r\n            (item.isCancelled) ? 1:0\r\n        );\r\n    }\r\n    //-------------------------------------------------------------------------\r\n    function    getCompoundPlan(uint contractId) public constant  returns(uint plan)\r\n    {\r\n        return contracts[contractId].plan;\r\n    }\r\n}\r\n////////////////////////////////////////////////////////////////////////////////\r\ncontract    Token  is  CompoundContract\r\n{\r\n    using SafeMath  for uint256;\r\n\r\n    //--------------------------------------------------------------------------\r\n    //----- OVERRIDDEN FUNCTION :  \"transfer\" function from ERC20\r\n    //----- For this smartcontract we don't deal with a deaLine date.\r\n    //----- So it's a normally transfer function with no restriction.\r\n    //----- Restricted tokens are inside the lockedTokens balances, not in ERC20 balances\r\n    //----- That means people after 3 months can start using their earned tokens\r\n    //--------------------------------------------------------------------------\r\n    function transfer(address toAddr, uint256 amountInWei)  public      returns (bool)     // TRANSFER is not restricted during ICO!!!\r\n    {\r\n        require(toAddr!=0x0 && toAddr!=msg.sender && amountInWei>0);    // Prevent transfer to 0x0 address and to self, amount must be >0\r\n\r\n        uint256 availableTokens = balances[msg.sender];\r\n\r\n        //----- Checking Token reserve first : if during ICO    \r\n\r\n        if (msg.sender==owner && !isHardcapReached())              // for RegerDiamond : handle reserved supply while ICO is running\r\n        {\r\n            assert(amountInWei<=availableTokens);\r\n\r\n            uint256 balanceAfterTransfer = availableTokens.sub(amountInWei);      \r\n\r\n            assert(balanceAfterTransfer >= icoReserveSupply);           // We try to sell more than allowed during an ICO\r\n        }\r\n\r\n        //-----\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(amountInWei);\r\n        balances[toAddr]     = balances[toAddr].add(amountInWei);\r\n\r\n        emit Transfer(msg.sender, toAddr, amountInWei);\r\n\r\n        return true;\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    function    investFor12Months(address buyerAddress, uint256  amountInWei,\r\n                                                          uint256  compoundContractId)\r\n                                                public onlyOwner  \r\n                                                returns(int)\r\n    {\r\n\r\n        uint    monthCount=12;\r\n\r\n        if (!isHardcapReached())\r\n        {\r\n            if (initCompoundContract(buyerAddress, amountInWei, compoundContractId, monthCount))\r\n            {\r\n                if (!lockMoneyOnCompoundCreation(buyerAddress, compoundContractId))      // Now lock the main capital (amountInWei) until the end of the compound\r\n                {\r\n                    return -1;\r\n                }\r\n            }\r\n            else \r\n            {\r\n                return -2; \r\n            }\r\n        }\r\n        else        // ICO is over.  Use the ERC20 transfer now. Compound is now forbidden. Nothing more to lock \r\n        {\r\n            Token.transfer(buyerAddress, amountInWei);\r\n            return 2;\r\n        }\r\n\r\n        return 1;       // -1: could not lock the capital\r\n                        // -2: Compound contract creation error\r\n                        //  2: ICO is over, coumpounds no more allowed. Standard ERC20 transfer only\r\n                        //  1: Compound contract created correctly\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    function    investFor24Months(address buyerAddress, uint256  amountInWei,\r\n                                                        uint256  compoundContractId)\r\n                                                public onlyOwner \r\n                                                returns(int)\r\n    {\r\n\r\n        uint    monthCount=24;\r\n\r\n        if (!isHardcapReached())\r\n        {\r\n            if (initCompoundContract(buyerAddress, amountInWei, compoundContractId, monthCount))\r\n            {\r\n                if (!lockMoneyOnCompoundCreation(buyerAddress, compoundContractId))    // Now lock the main capital (amountInWei) until the end of the compound\r\n                {\r\n                    return -1; \r\n                }\r\n            }\r\n            else { return -2; }\r\n        }\r\n        else        // ICO is over.  Use the ERC20 transfer now. Compound is now forbidden. Nothing more to lock \r\n        {\r\n            Token.transfer(buyerAddress, amountInWei);\r\n            return 2;\r\n        }\r\n\r\n        return 1;       // -1: could not lock the capital\r\n                        // -2: Compound contract creation error\r\n                        //  2: ICO is over, coumpounds no more allowed. Standard ERC20 transfer only\r\n                        //  1: Compound contract created correctly*/\r\n    }\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n    //--------------------------------------------------------------------------\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIcoPaused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"iYear\",\"type\":\"uint16\"},{\"name\":\"iMonth\",\"type\":\"uint8\"},{\"name\":\"iDay\",\"type\":\"uint8\"}],\"name\":\"dateToTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractId\",\"type\":\"uint256\"}],\"name\":\"getCompoundPlan\",\"outputs\":[{\"name\":\"plan\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fromAddr\",\"type\":\"address\"},{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newHardCap\",\"type\":\"uint256\"}],\"name\":\"changeHardCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoReserveSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newIcoDeadline\",\"type\":\"uint256\"}],\"name\":\"changeIcoDeadLine\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getHour\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractId\",\"type\":\"uint256\"}],\"name\":\"geCompoundTimestampsFor24Months\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getWeekday\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoSalesSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"lockedBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"},{\"name\":\"minute\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getYearDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isStoppingIcoOnHardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getDay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoDeadLine\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPausedICO\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"supplyReserveVal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getSecond\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"},{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"day\",\"type\":\"uint8\"},{\"name\":\"hour\",\"type\":\"uint8\"},{\"name\":\"minute\",\"type\":\"uint8\"},{\"name\":\"second\",\"type\":\"uint8\"}],\"name\":\"toTimestamp\",\"outputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractId\",\"type\":\"uint256\"}],\"name\":\"geCompoundTimestampsFor12Months\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"isLeapYear\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amountInWei\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"getDaysInYear\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"year\",\"type\":\"uint256\"}],\"name\":\"leapYearsBefore\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"month\",\"type\":\"uint8\"},{\"name\":\"year\",\"type\":\"uint16\"}],\"name\":\"getDaysInMonth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractId\",\"type\":\"uint256\"}],\"name\":\"validateCompoundContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"name\":\"compoundContractId\",\"type\":\"uint256\"}],\"name\":\"investFor12Months\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isHardcapReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"capitalInWei\",\"type\":\"uint256\"},{\"name\":\"contractMonthCount\",\"type\":\"uint256\"}],\"name\":\"calculateCompoundContract\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"lockedEarningsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"lockedCapitalOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"walletAddress\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractId\",\"type\":\"uint256\"},{\"name\":\"termId\",\"type\":\"uint8\"},{\"name\":\"isCalledFromOutside\",\"type\":\"uint8\"}],\"name\":\"payCompoundTerm\",\"outputs\":[{\"name\":\"\",\"type\":\"int32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"amountInWei\",\"type\":\"uint256\"},{\"name\":\"compoundContractId\",\"type\":\"uint256\"}],\"name\":\"investFor24Months\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractId\",\"type\":\"uint256\"}],\"name\":\"getCompoundContract\",\"outputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"capital\",\"type\":\"uint256\"},{\"name\":\"profitToGenerate\",\"type\":\"uint256\"},{\"name\":\"earnedSoFarAmount\",\"type\":\"uint256\"},{\"name\":\"percent\",\"type\":\"uint256\"},{\"name\":\"interestRate\",\"type\":\"uint256\"},{\"name\":\"paidTermCount\",\"type\":\"uint256\"},{\"name\":\"isAllPaid\",\"type\":\"uint256\"},{\"name\":\"monthCount\",\"type\":\"uint256\"},{\"name\":\"earningPerTerm\",\"type\":\"uint256\"},{\"name\":\"isCancelled\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdminAddress\",\"type\":\"address\"}],\"name\":\"changeAdminUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"getMinute\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hardCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"compoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"capital\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"earnedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"onCompoundContractCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"compoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"capital\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"earnedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"earnedSoFarAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"paidTermCount\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"totalTermCount\",\"type\":\"uint8\"}],\"name\":\"onCompoundEarnings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"toAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountToLockInWei\",\"type\":\"uint256\"}],\"name\":\"onCompoundContractLocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paymentCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"paidAmountInWei\",\"type\":\"uint256\"}],\"name\":\"onPayEarningsDone\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockedCapital\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockedEarnings\",\"type\":\"uint256\"}],\"name\":\"onCompoundContractCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractId\",\"type\":\"uint256\"}],\"name\":\"onCompoundContractValidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromAddr\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldAdmin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"onAdminUserChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"onOwnershipTransfered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldIcoDeadLine\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newIcoDeadline\",\"type\":\"uint256\"}],\"name\":\"onIcoDeadlineChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hardCap\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newHardCap\",\"type\":\"uint256\"}],\"name\":\"onHardcapChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newPauseStatus\",\"type\":\"uint8\"}],\"name\":\"icoIsNowPaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newPauseStatus\",\"type\":\"uint8\"}],\"name\":\"icoHasRestarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"string\"}],\"name\":\"log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"key\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"log\",\"type\":\"event\"}]","ContractName":"Token","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b8d0a8473914b9bf33613b3cb1d38550df26870e4f0479a7989151e56dcac595"}]}