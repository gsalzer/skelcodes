{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/generic/SafeMath.sol\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n\r\n    TODO: check against ds-math: https://blog.dapphub.com/ds-math/\r\n    TODO: move roundedDiv to a sep lib? (eg. Math.sol)\r\n    TODO: more unit tests!\r\n*/\r\npragma solidity 0.4.24;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, \"mul overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div by 0\"); // Solidity automatically throws for div by 0 but require to emit reason\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"sub underflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"add overflow\");\r\n        return c;\r\n    }\r\n\r\n    // Division, round to nearest integer, round half up\r\n    function roundedDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div by 0\"); // Solidity automatically throws for div by 0 but require to emit reason\r\n        uint256 halfB = (b % 2 == 0) ? (b / 2) : (b / 2 + 1);\r\n        return (a % b >= halfB) ? (a / b + 1) : (a / b);\r\n    }\r\n\r\n    // Division, always rounds up\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div by 0\"); // Solidity automatically throws for div by 0 but require to emit reason\r\n        return (a % b != 0) ? (a / b + 1) : (a / b);\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? b : a;\r\n    }    \r\n}\r\n\r\n// File: contracts/generic/MultiSig.sol\r\n\r\n/* Abstract multisig contract to allow multi approval execution of atomic contracts scripts\r\n        e.g. migrations or settings.\r\n    * Script added by signing a script address by a signer  (NEW state)\r\n    * Script goes to ALLOWED state once a quorom of signers sign it (quorom fx is defined in each derived contracts)\r\n    * Script can be signed even in APPROVED state\r\n    * APPROVED scripts can be executed only once.\r\n        - if script succeeds then state set to DONE\r\n        - If script runs out of gas or reverts then script state set to FAILEd and not allowed to run again\r\n          (To avoid leaving \"behind\" scripts which fail in a given state but eventually execute in the future)\r\n    * Scripts can be cancelled by an other multisig script approved and calling cancelScript()\r\n    * Adding/removing signers is only via multisig approved scripts using addSigners / removeSigners fxs\r\n*/\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract MultiSig {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => bool) public isSigner;\r\n    address[] public allSigners; // all signers, even the disabled ones\r\n                                // NB: it can contain duplicates when a signer is added, removed then readded again\r\n                                //   the purpose of this array is to being able to iterate on signers in isSigner\r\n    uint public activeSignersCount;\r\n\r\n    enum ScriptState {New, Approved, Done, Cancelled, Failed}\r\n\r\n    struct Script {\r\n        ScriptState state;\r\n        uint signCount;\r\n        mapping(address => bool) signedBy;\r\n        address[] allSigners;\r\n    }\r\n\r\n    mapping(address => Script) public scripts;\r\n    address[] public scriptAddresses;\r\n\r\n    event SignerAdded(address signer);\r\n    event SignerRemoved(address signer);\r\n\r\n    event ScriptSigned(address scriptAddress, address signer);\r\n    event ScriptApproved(address scriptAddress);\r\n    event ScriptCancelled(address scriptAddress);\r\n\r\n    event ScriptExecuted(address scriptAddress, bool result);\r\n\r\n    constructor() public {\r\n        // deployer address is the first signer. Deployer can configure new contracts by itself being the only \"signer\"\r\n        // The first script which sets the new contracts live should add signers and revoke deployer's signature right\r\n        isSigner[msg.sender] = true;\r\n        allSigners.push(msg.sender);\r\n        activeSignersCount = 1;\r\n        emit SignerAdded(msg.sender);\r\n    }\r\n\r\n    function sign(address scriptAddress) public {\r\n        require(isSigner[msg.sender], \"sender must be signer\");\r\n        Script storage script = scripts[scriptAddress];\r\n        require(script.state == ScriptState.Approved || script.state == ScriptState.New,\r\n                \"script state must be New or Approved\");\r\n        require(!script.signedBy[msg.sender], \"script must not be signed by signer yet\");\r\n\r\n        if (script.allSigners.length == 0) {\r\n            // first sign of a new script\r\n            scriptAddresses.push(scriptAddress);\r\n        }\r\n\r\n        script.allSigners.push(msg.sender);\r\n        script.signedBy[msg.sender] = true;\r\n        script.signCount = script.signCount.add(1);\r\n\r\n        emit ScriptSigned(scriptAddress, msg.sender);\r\n\r\n        if (checkQuorum(script.signCount)) {\r\n            script.state = ScriptState.Approved;\r\n            emit ScriptApproved(scriptAddress);\r\n        }\r\n    }\r\n\r\n    function execute(address scriptAddress) public returns (bool result) {\r\n        // only allow execute to signers to avoid someone set an approved script failed by calling it with low gaslimit\r\n        require(isSigner[msg.sender], \"sender must be signer\");\r\n        Script storage script = scripts[scriptAddress];\r\n        require(script.state == ScriptState.Approved, \"script state must be Approved\");\r\n\r\n        // passing scriptAddress to allow called script access its own public fx-s if needed\r\n        if (scriptAddress.delegatecall.gas(gasleft() - 23000)\r\n            (abi.encodeWithSignature(\"execute(address)\", scriptAddress))) {\r\n            script.state = ScriptState.Done;\r\n            result = true;\r\n        } else {\r\n            script.state = ScriptState.Failed;\r\n            result = false;\r\n        }\r\n        emit ScriptExecuted(scriptAddress, result);\r\n    }\r\n\r\n    function cancelScript(address scriptAddress) public {\r\n        require(msg.sender == address(this), \"only callable via MultiSig\");\r\n        Script storage script = scripts[scriptAddress];\r\n        require(script.state == ScriptState.Approved || script.state == ScriptState.New,\r\n                \"script state must be New or Approved\");\r\n\r\n        script.state = ScriptState.Cancelled;\r\n\r\n        emit ScriptCancelled(scriptAddress);\r\n    }\r\n\r\n    /* requires quorum so it's callable only via a script executed by this contract */\r\n    function addSigners(address[] signers) public {\r\n        require(msg.sender == address(this), \"only callable via MultiSig\");\r\n        for (uint i= 0; i < signers.length; i++) {\r\n            if (!isSigner[signers[i]]) {\r\n                require(signers[i] != address(0), \"new signer must not be 0x0\");\r\n                activeSignersCount++;\r\n                allSigners.push(signers[i]);\r\n                isSigner[signers[i]] = true;\r\n                emit SignerAdded(signers[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* requires quorum so it's callable only via a script executed by this contract */\r\n    function removeSigners(address[] signers) public {\r\n        require(msg.sender == address(this), \"only callable via MultiSig\");\r\n        for (uint i= 0; i < signers.length; i++) {\r\n            if (isSigner[signers[i]]) {\r\n                require(activeSignersCount > 1, \"must not remove last signer\");\r\n                activeSignersCount--;\r\n                isSigner[signers[i]] = false;\r\n                emit SignerRemoved(signers[i]);\r\n            }\r\n        }\r\n    }\r\n\r\n    /* implement it in derived contract */\r\n    function checkQuorum(uint signersCount) internal view returns(bool isQuorum);\r\n\r\n    function getAllSignersCount() view external returns (uint allSignersCount) {\r\n        return allSigners.length;\r\n    }\r\n\r\n    // UI helper fx - Returns signers from offset as [signer id (index in allSigners), address as uint, isActive 0 or 1]\r\n    function getSigners(uint offset, uint16 chunkSize)\r\n    external view returns(uint[3][]) {\r\n        uint limit = SafeMath.min(offset.add(chunkSize), allSigners.length);\r\n        uint[3][] memory response = new uint[3][](limit.sub(offset));\r\n        for (uint i = offset; i < limit; i++) {\r\n            address signerAddress = allSigners[i];\r\n            response[i - offset] = [i, uint(signerAddress), isSigner[signerAddress] ? 1 : 0];\r\n        }\r\n        return response;\r\n    }\r\n\r\n    function getScriptsCount() view external returns (uint scriptsCount) {\r\n        return scriptAddresses.length;\r\n    }\r\n\r\n    // UI helper fx - Returns scripts from offset as\r\n    //  [scriptId (index in scriptAddresses[]), address as uint, state, signCount]\r\n    function getScripts(uint offset, uint16 chunkSize)\r\n    external view returns(uint[4][]) {\r\n        uint limit = SafeMath.min(offset.add(chunkSize), scriptAddresses.length);\r\n        uint[4][] memory response = new uint[4][](limit.sub(offset));\r\n        for (uint i = offset; i < limit; i++) {\r\n            address scriptAddress = scriptAddresses[i];\r\n            response[i - offset] = [i, uint(scriptAddress),\r\n                uint(scripts[scriptAddress].state), scripts[scriptAddress].signCount];\r\n        }\r\n        return response;\r\n    }\r\n}\r\n\r\n// File: contracts/StabilityBoardProxy.sol\r\n\r\n/* allows tx to execute if 50% +1 vote of active signers signed */\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract StabilityBoardProxy is MultiSig {\r\n\r\n    function checkQuorum(uint signersCount) internal view returns(bool isQuorum) {\r\n        isQuorum = signersCount > activeSignersCount / 2 ;\r\n    }\r\n}\r\n\r\n// File: contracts/SB_scripts/mainnet/Main0020_removeSigner.sol\r\n\r\n/* Remove deployer account from mainnet signers */\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\ncontract Main0020_removeSigner {\r\n\r\n    StabilityBoardProxy public constant STABILITY_BOARD_PROXY = StabilityBoardProxy(0xde36a8773531406dCBefFdfd3C7b89fCed7A9F84);\r\n\r\n    function execute(Main0020_removeSigner /* self, not used */) external {\r\n        // called via StabilityBoardProxy\r\n        require(address(this) == address(STABILITY_BOARD_PROXY), \"only execute via StabilityBoardProxy\");\r\n\r\n         // revoke deployer account signer rights\r\n         address[] memory signersToRemove = new address[](1); // dynamic array needed for addSigners() & removeSigners()\r\n         signersToRemove[0] = 0x23445fFDDA92567a4c6168D376C35d93AcB96e01;   // treer deployer account\r\n         STABILITY_BOARD_PROXY.removeSigners(signersToRemove);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STABILITY_BOARD_PROXY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Main0020_removeSigner","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7ab8039c80e6c256617799edc7f86ce5dc333246f3f05ddaf478394ad76b8a6c"}]}