{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Note for the truffle testversion:\r\n * DragonKingTest inherits from DragonKing and adds one more function for testing the volcano from truffle.\r\n * For deployment on ropsten or mainnet, just deploy the DragonKing contract and remove this comment before verifying on\r\n * etherscan.\r\n * */\r\n\r\n /**\r\n  * Dragonking is a blockchain game in which players may purchase dragons and knights of different levels and values.\r\n  * Once every period of time the volcano erupts and wipes a few of them from the board. The value of the killed characters\r\n  * gets distributed amongst all of the survivors. The dragon king receive a bigger share than the others.\r\n  * In contrast to dragons, knights need to be teleported to the battlefield first with the use of teleport tokens.\r\n  * Additionally, they may attack a dragon once per period.\r\n  * Both character types can be protected from death up to three times.\r\n  * Take a look at dragonking.io for more detailed information.\r\n  * @author: Julia Altenried, Yuriy Kashnikov\r\n  * */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Destructible\r\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\r\n */\r\ncontract Destructible is Ownable {\r\n\r\n  function Destructible() public payable { }\r\n\r\n  /**\r\n   * @dev Transfers the current balance to the owner and terminates the contract.\r\n   */\r\n  function destroy() onlyOwner public {\r\n    selfdestruct(owner);\r\n  }\r\n\r\n  function destroyAndSend(address _recipient) onlyOwner public {\r\n    selfdestruct(_recipient);\r\n  }\r\n}\r\n\r\ncontract DragonKingConfig {\r\n\r\n\r\n  /** the cost of each character type */\r\n  uint128[] public costs;\r\n  /** the value of each character type (cost - fee), so it's not necessary to compute it each time*/\r\n  uint128[] public values;\r\n  /** the fee to be paid each time an character is bought in percent*/\r\n  uint8 fee;\r\n  /** The maximum of characters allowed in the game */\r\n  uint16 public maxCharacters;\r\n  /** the amount of time that should pass since last eruption **/\r\n  uint256 public eruptionThreshold;\r\n  /** the amount of time that should pass ince last castle loot distribution **/\r\n  uint256 public castleLootDistributionThreshold;\r\n  /** how many characters to kill in %, e.g. 20 will stand for 20%, should be < 100 **/\r\n  uint8 public percentageToKill;\r\n  /* Cooldown threshold */\r\n  uint256 public constant CooldownThreshold = 1 days;\r\n  /** fight factor, used to compute extra probability in fight **/\r\n  uint8 public fightFactor;\r\n\r\n  /** the price for teleportation*/\r\n  uint256 public teleportPrice;\r\n  /** the price for protection */\r\n  uint256 public protectionPrice;\r\n\r\n}\r\n\r\ninterface Token {\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n  function transfer(address _to, uint256 _value) external returns (bool success);\r\n  function balanceOf(address who) external view returns (uint256);\r\n}\r\n\r\n\r\ncontract DragonKing is Destructible {\r\n\r\n  /**\r\n   * @dev Throws if called by contract not a user \r\n   */\r\n  modifier onlyUser() {\r\n    require(msg.sender == tx.origin, \r\n            \"contracts cannot execute this method\"\r\n           );\r\n    _;\r\n  }\r\n\r\n\r\n  struct Character {\r\n    uint8 characterType;\r\n    uint128 value;\r\n    address owner;\r\n    uint64 purchaseTimestamp;\r\n  }\r\n\r\n  DragonKingConfig public config;\r\n\r\n  /** the neverdue token contract used to purchase protection from eruptions and fights */\r\n  Token public neverdieToken;\r\n  /** the teleport token contract used to send knights to the game scene */\r\n  Token public teleportToken;\r\n\r\n  /** the SKL token contract **/\r\n  Token public sklToken;\r\n  /** the XP token contract **/\r\n  Token public xperToken;\r\n  \r\n\r\n  /** array holding ids of the curret characters **/\r\n  uint32[] public ids;\r\n  /** the id to be given to the next character **/\r\n  uint32 public nextId;\r\n  /** non-existant character **/\r\n  uint16 public constant INVALID_CHARACTER_INDEX = ~uint16(0);\r\n\r\n  /** the castle treasury **/\r\n  uint128 public castleTreasury;\r\n  /** the id of the oldest character **/\r\n  uint32 public oldest;\r\n  /** the character belonging to a given id **/\r\n  mapping(uint32 => Character) characters;\r\n  /** teleported knights **/\r\n  mapping(uint32 => bool) teleported;\r\n\r\n  /** constant used to signal that there is no King at the moment **/\r\n  uint32 constant public noKing = ~uint32(0);\r\n\r\n  /** total number of characters in the game **/\r\n  uint16 public numCharacters;\r\n  /** number of characters per type **/\r\n  mapping(uint8 => uint16) public numCharactersXType;\r\n\r\n  /** timestampt of the last eruption event **/\r\n  uint256 public lastEruptionTimestamp;\r\n  /** timestampt of the last castle loot distribution **/\r\n  uint256 public lastCastleLootDistributionTimestamp;\r\n\r\n  /** character type range constants **/\r\n  uint8 public constant DRAGON_MIN_TYPE = 0;\r\n  uint8 public constant DRAGON_MAX_TYPE = 5;\r\n\r\n  uint8 public constant KNIGHT_MIN_TYPE = 6;\r\n  uint8 public constant KNIGHT_MAX_TYPE = 11;\r\n\r\n  uint8 public constant BALLOON_MIN_TYPE = 12;\r\n  uint8 public constant BALLOON_MAX_TYPE = 14;\r\n\r\n  uint8 public constant WIZARD_MIN_TYPE = 15;\r\n  uint8 public constant WIZARD_MAX_TYPE = 20;\r\n\r\n  uint8 public constant ARCHER_MIN_TYPE = 21;\r\n  uint8 public constant ARCHER_MAX_TYPE = 26;\r\n\r\n  uint8 public constant NUMBER_OF_LEVELS = 6;\r\n\r\n  uint8 public constant INVALID_CHARACTER_TYPE = 27;\r\n\r\n  /** minimum amount of XPER and SKL to purchase wizards **/\r\n  uint8 public MIN_XPER_AMOUNT_TO_PURCHASE_WIZARD = 100;\r\n  uint8 public MIN_SKL_AMOUNT_TO_PURCHASE_WIZARD = 50;\r\n\r\n  /** minimum amount of XPER and SKL to purchase archer **/\r\n  uint8 public MIN_XPER_AMOUNT_TO_PURCHASE_ARCHER = 10;\r\n  uint8 public MIN_SKL_AMOUNT_TO_PURCHASE_ARCHER = 5;\r\n\r\n    /** knight cooldown. contains the timestamp of the earliest possible moment to start a fight */\r\n  mapping(uint32 => uint) public cooldown;\r\n\r\n    /** tells the number of times a character is protected */\r\n  mapping(uint32 => uint8) public protection;\r\n\r\n  // EVENTS\r\n\r\n  /** is fired when new characters are purchased (who bought how many characters of which type?) */\r\n  event NewPurchase(address player, uint8 characterType, uint16 amount, uint32 startId);\r\n  /** is fired when a player leaves the game */\r\n  event NewExit(address player, uint256 totalBalance, uint32[] removedCharacters);\r\n  /** is fired when an eruption occurs */\r\n  event NewEruption(uint32[] hitCharacters, uint128 value, uint128 gasCost);\r\n  /** is fired when a single character is sold **/\r\n  event NewSell(uint32 characterId, address player, uint256 value);\r\n  /** is fired when a knight fights a dragon **/\r\n  event NewFight(uint32 winnerID, uint32 loserID, uint256 value, uint16 probability, uint16 dice);\r\n  /** is fired when a knight is teleported to the field **/\r\n  event NewTeleport(uint32 characterId);\r\n  /** is fired when a protection is purchased **/\r\n  event NewProtection(uint32 characterId, uint8 lifes);\r\n  /** is fired when a castle loot distribution occurs**/\r\n  event NewDistributionCastleLoot(uint128 castleLoot);\r\n\r\n  /** initializes the contract parameters  */\r\n  constructor(address tptAddress, address ndcAddress, address sklAddress, address xperAddress, address _configAddress) public {\r\n    nextId = 1;\r\n    teleportToken = Token(tptAddress);\r\n    neverdieToken = Token(ndcAddress);\r\n    sklToken = Token(sklAddress);\r\n    xperToken = Token(xperAddress);\r\n    config = DragonKingConfig(_configAddress);\r\n  }\r\n\r\n  /**\r\n   * buys as many characters as possible with the transfered value of the given type\r\n   * @param characterType the type of the character\r\n   */\r\n  function addCharacters(uint8 characterType) payable public onlyUser {\r\n    uint16 amount = uint16(msg.value / config.costs(characterType));\r\n    uint16 nchars = numCharacters;\r\n    if (characterType >= INVALID_CHARACTER_TYPE || msg.value < config.costs(characterType) || nchars + amount > config.maxCharacters()) revert();\r\n    uint32 nid = nextId;\r\n    //if type exists, enough ether was transferred and there are less than maxCharacters characters in the game\r\n    if (characterType <= DRAGON_MAX_TYPE) {\r\n      //dragons enter the game directly\r\n      if (oldest == 0 || oldest == noKing)\r\n        oldest = nid;\r\n      for (uint8 i = 0; i < amount; i++) {\r\n        addCharacter(nid + i, nchars + i);\r\n        characters[nid + i] = Character(characterType, config.values(characterType), msg.sender, uint64(now));\r\n      }\r\n      numCharactersXType[characterType] += amount;\r\n      numCharacters += amount;\r\n    }\r\n    else {\r\n      uint256 amountSKL = sklToken.balanceOf(msg.sender);\r\n      uint256 amountXPER = xperToken.balanceOf(msg.sender);\r\n      if (characterType >= WIZARD_MIN_TYPE && characterType <= WIZARD_MAX_TYPE) {\r\n        require( amountSKL >= MIN_SKL_AMOUNT_TO_PURCHASE_WIZARD && amountXPER >= MIN_XPER_AMOUNT_TO_PURCHASE_WIZARD, \r\n                \"insufficient amount of SKL and XPER tokens\"\r\n               );\r\n      }\r\n      if (characterType >= ARCHER_MIN_TYPE && characterType <= ARCHER_MAX_TYPE) {\r\n        require( amountSKL >= MIN_SKL_AMOUNT_TO_PURCHASE_ARCHER && amountXPER >= MIN_XPER_AMOUNT_TO_PURCHASE_ARCHER, \r\n                \"insufficient amount of SKL and XPER tokens\" \r\n               );\r\n      }\r\n      // to enter game knights, mages, and archers should be teleported later\r\n      for (uint8 j = 0; j < amount; j++) {\r\n        characters[nid + j] = Character(characterType, config.values(characterType), msg.sender, uint64(now));\r\n      }\r\n    }\r\n    nextId = nid + amount;\r\n    emit NewPurchase(msg.sender, characterType, amount, nid);\r\n  }\r\n\r\n\r\n\r\n  /**\r\n   * adds a single dragon of the given type to the ids array, which is used to iterate over all characters\r\n   * @param nId the id the character is about to receive\r\n   * @param nchars the number of characters currently in the game\r\n   */\r\n  function addCharacter(uint32 nId, uint16 nchars) internal {\r\n    if (nchars < ids.length)\r\n      ids[nchars] = nId;\r\n    else\r\n      ids.push(nId);\r\n  }\r\n\r\n  /**\r\n   * leave the game.\r\n   * pays out the sender's balance and removes him and his characters from the game\r\n   * */\r\n  function exit() public {\r\n    uint32[] memory removed = new uint32[](50);\r\n    uint8 count;\r\n    uint32 lastId;\r\n    uint playerBalance;\r\n    uint16 nchars = numCharacters;\r\n    for (uint16 i = 0; i < nchars; i++) {\r\n      if (characters[ids[i]].owner == msg.sender \r\n          && characters[ids[i]].purchaseTimestamp + 1 days < now\r\n          && (characters[ids[i]].characterType < BALLOON_MIN_TYPE || characters[ids[i]].characterType > BALLOON_MAX_TYPE)) {\r\n        //first delete all characters at the end of the array\r\n        while (nchars > 0 \r\n            && characters[ids[nchars - 1]].owner == msg.sender \r\n            && characters[ids[nchars - 1]].purchaseTimestamp + 1 days < now\r\n            && (characters[ids[i]].characterType < BALLOON_MIN_TYPE || characters[ids[i]].characterType > BALLOON_MAX_TYPE)) {\r\n          nchars--;\r\n          lastId = ids[nchars];\r\n          numCharactersXType[characters[lastId].characterType]--;\r\n          playerBalance += characters[lastId].value;\r\n          removed[count] = lastId;\r\n          count++;\r\n          if (lastId == oldest) oldest = 0;\r\n          delete characters[lastId];\r\n        }\r\n        //replace the players character by the last one\r\n        if (nchars > i + 1) {\r\n          playerBalance += characters[ids[i]].value;\r\n          removed[count] = ids[i];\r\n          count++;\r\n          nchars--;\r\n          replaceCharacter(i, nchars);\r\n        }\r\n      }\r\n    }\r\n    numCharacters = nchars;\r\n    emit NewExit(msg.sender, playerBalance, removed); //fire the event to notify the client\r\n    msg.sender.transfer(playerBalance);\r\n    if (oldest == 0)\r\n      findOldest();\r\n  }\r\n\r\n  /**\r\n   * Replaces the character with the given id with the last character in the array\r\n   * @param index the index of the character in the id array\r\n   * @param nchars the number of characters\r\n   * */\r\n  function replaceCharacter(uint16 index, uint16 nchars) internal {\r\n    uint32 characterId = ids[index];\r\n    numCharactersXType[characters[characterId].characterType]--;\r\n    if (characterId == oldest) oldest = 0;\r\n    delete characters[characterId];\r\n    ids[index] = ids[nchars];\r\n    delete ids[nchars];\r\n  }\r\n\r\n  /**\r\n   * The volcano eruption can be triggered by anybody but only if enough time has passed since the last eription.\r\n   * The volcano hits up to a certain percentage of characters, but at least one.\r\n   * The percantage is specified in 'percentageToKill'\r\n   * */\r\n\r\n  function triggerVolcanoEruption() public onlyUser {\r\n    require(now >= lastEruptionTimestamp + config.eruptionThreshold(),\r\n           \"not enough time passed since last eruption\");\r\n    require(numCharacters > 0,\r\n           \"there are no characters in the game\");\r\n    lastEruptionTimestamp = now;\r\n    uint128 pot;\r\n    uint128 value;\r\n    uint16 random;\r\n    uint32 nextHitId;\r\n    uint16 nchars = numCharacters;\r\n    uint32 howmany = nchars * config.percentageToKill() / 100;\r\n    uint128 neededGas = 80000 + 10000 * uint32(nchars);\r\n    if(howmany == 0) howmany = 1;//hit at least 1\r\n    uint32[] memory hitCharacters = new uint32[](howmany);\r\n    bool[] memory alreadyHit = new bool[](nextId);\r\n    uint8 i = 0;\r\n    uint16 j = 0;\r\n    while (i < howmany) {\r\n      j++;\r\n      random = uint16(generateRandomNumber(lastEruptionTimestamp + j) % nchars);\r\n      nextHitId = ids[random];\r\n      if (!alreadyHit[nextHitId]) {\r\n        alreadyHit[nextHitId] = true;\r\n        hitCharacters[i] = nextHitId;\r\n        value = hitCharacter(random, nchars, 0);\r\n        if (value > 0) {\r\n          nchars--;\r\n        }\r\n        pot += value;\r\n        i++;\r\n      }\r\n    }\r\n    uint128 gasCost = uint128(neededGas * tx.gasprice);\r\n    numCharacters = nchars;\r\n    if (pot > gasCost){\r\n      distribute(pot - gasCost); //distribute the pot minus the oraclize gas costs\r\n      emit NewEruption(hitCharacters, pot - gasCost, gasCost);\r\n    }\r\n    else\r\n      emit NewEruption(hitCharacters, 0, gasCost);\r\n  }\r\n\r\n  /**\r\n   * Knight can attack a dragon.\r\n   * Archer can attack only a balloon.\r\n   * Dragon can attack wizards and archers.\r\n   * Wizard can attack anyone, except balloon.\r\n   * Balloon cannot attack.\r\n   * The value of the loser is transfered to the winner.\r\n   * @param characterID the ID of the knight to perfrom the attack\r\n   * @param characterIndex the index of the knight in the ids-array. Just needed to save gas costs.\r\n   *            In case it's unknown or incorrect, the index is looked up in the array.\r\n   * */\r\n  function fight(uint32 characterID, uint16 characterIndex) public onlyUser {\r\n    if (characterID != ids[characterIndex])\r\n      characterIndex = getCharacterIndex(characterID);\r\n    Character storage character = characters[characterID];\r\n    require(cooldown[characterID] + config.CooldownThreshold() <= now,\r\n            \"not enough time passed since the last fight of this character\");\r\n    require(character.owner == msg.sender,\r\n            \"only owner can initiate a fight for this character\");\r\n\r\n    uint8 ctype = character.characterType;\r\n    require(ctype < BALLOON_MIN_TYPE || ctype > BALLOON_MAX_TYPE,\r\n            \"balloons cannot fight\");\r\n\r\n    uint16 adversaryIndex = getRandomAdversary(characterID, ctype);\r\n    assert(adversaryIndex != INVALID_CHARACTER_INDEX);\r\n    uint32 adversaryID = ids[adversaryIndex];\r\n\r\n    Character storage adversary = characters[adversaryID];\r\n    uint128 value;\r\n    uint16 base_probability;\r\n    uint16 dice = uint16(generateRandomNumber(characterID) % 100);\r\n    uint256 characterPower = sklToken.balanceOf(character.owner) / 10**15 + xperToken.balanceOf(character.owner);\r\n    uint256 adversaryPower = sklToken.balanceOf(adversary.owner) / 10**15 + xperToken.balanceOf(adversary.owner);\r\n    \r\n    if (character.value == adversary.value) {\r\n        base_probability = 50;\r\n      if (characterPower > adversaryPower) {\r\n        base_probability += uint16(100 / config.fightFactor());\r\n      } else if (adversaryPower > characterPower) {\r\n        base_probability -= uint16(100 / config.fightFactor());\r\n      }\r\n    } else if (character.value > adversary.value) {\r\n      base_probability = 100;\r\n      if (adversaryPower > characterPower) {\r\n        base_probability -= uint16((100 * adversary.value) / character.value / config.fightFactor());\r\n      }\r\n    } else if (characterPower > adversaryPower) {\r\n        base_probability += uint16((100 * character.value) / adversary.value / config.fightFactor());\r\n    }\r\n\r\n    if (dice >= base_probability) {\r\n      // adversary won\r\n      if (adversary.characterType < BALLOON_MIN_TYPE || adversary.characterType > BALLOON_MAX_TYPE) {\r\n        value = hitCharacter(characterIndex, numCharacters, adversary.characterType);\r\n        if (value > 0) {\r\n          numCharacters--;\r\n        }\r\n        if (adversary.characterType >= ARCHER_MIN_TYPE && adversary.characterType <= ARCHER_MAX_TYPE) {\r\n          castleTreasury += value;\r\n        } else {\r\n          adversary.value += value;\r\n        }\r\n        emit NewFight(adversaryID, characterID, value, base_probability, dice);\r\n      } else {\r\n        emit NewFight(adversaryID, characterID, 0, base_probability, dice); // balloons do not hit back\r\n      }\r\n    } else {\r\n      // character won\r\n      value = hitCharacter(adversaryIndex, numCharacters, character.characterType);\r\n      if (value > 0) {\r\n        numCharacters--;\r\n      }\r\n      if (character.characterType >= ARCHER_MIN_TYPE && character.characterType <= ARCHER_MAX_TYPE) {\r\n        castleTreasury += value;\r\n      } else {\r\n        character.value += value;\r\n      }\r\n      if (oldest == 0) findOldest();\r\n      emit NewFight(characterID, adversaryID, value, base_probability, dice);\r\n    }\r\n    cooldown[characterID] = now;\r\n  }\r\n\r\n  /*\r\n  * @param characterType\r\n  * @param adversaryType\r\n  * @return whether adversaryType is a valid type of adversary for a given character\r\n  */\r\n  function isValidAdversary(uint8 characterType, uint8 adversaryType) pure returns (bool) {\r\n    if (characterType >= KNIGHT_MIN_TYPE && characterType <= KNIGHT_MAX_TYPE) { // knight\r\n      return (adversaryType <= DRAGON_MAX_TYPE);\r\n    } else if (characterType >= WIZARD_MIN_TYPE && characterType <= WIZARD_MAX_TYPE) { // wizard\r\n      return (adversaryType < BALLOON_MIN_TYPE || adversaryType > BALLOON_MAX_TYPE);\r\n    } else if (characterType >= DRAGON_MIN_TYPE && characterType <= DRAGON_MAX_TYPE) { // dragon\r\n      return (adversaryType >= WIZARD_MIN_TYPE);\r\n    } else if (characterType >= ARCHER_MIN_TYPE && characterType <= ARCHER_MAX_TYPE) { // archer\r\n      return ((adversaryType >= BALLOON_MIN_TYPE && adversaryType <= BALLOON_MAX_TYPE)\r\n             || (adversaryType >= KNIGHT_MIN_TYPE && adversaryType <= KNIGHT_MAX_TYPE));\r\n \r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * pick a random adversary.\r\n   * @param nonce a nonce to make sure there's not always the same adversary chosen in a single block.\r\n   * @return the index of a random adversary character\r\n   * */\r\n  function getRandomAdversary(uint256 nonce, uint8 characterType) internal view returns(uint16) {\r\n    uint16 randomIndex = uint16(generateRandomNumber(nonce) % numCharacters);\r\n    // use 7, 11 or 13 as step size. scales for up to 1000 characters\r\n    uint16 stepSize = numCharacters % 7 == 0 ? (numCharacters % 11 == 0 ? 13 : 11) : 7;\r\n    uint16 i = randomIndex;\r\n    //if the picked character is a knight or belongs to the sender, look at the character + stepSizes ahead in the array (modulo the total number)\r\n    //will at some point return to the startingPoint if no character is suited\r\n    do {\r\n      if (isValidAdversary(characterType, characters[ids[i]].characterType) && characters[ids[i]].owner != msg.sender) {\r\n        return i;\r\n      }\r\n      i = (i + stepSize) % numCharacters;\r\n    } while (i != randomIndex);\r\n\r\n    return INVALID_CHARACTER_INDEX;\r\n  }\r\n\r\n\r\n  /**\r\n   * generate a random number.\r\n   * @param nonce a nonce to make sure there's not always the same number returned in a single block.\r\n   * @return the random number\r\n   * */\r\n  function generateRandomNumber(uint256 nonce) internal view returns(uint) {\r\n    return uint(keccak256(block.blockhash(block.number - 1), now, numCharacters, nonce));\r\n  }\r\n\r\n\t/**\r\n   * Hits the character of the given type at the given index.\r\n   * Wizards can knock off two protections. Other characters can do only one.\r\n   * @param index the index of the character\r\n   * @param nchars the number of characters\r\n   * @return the value gained from hitting the characters (zero is the character was protected)\r\n   * */\r\n  function hitCharacter(uint16 index, uint16 nchars, uint8 characterType) internal returns(uint128 characterValue) {\r\n    uint32 id = ids[index];\r\n    uint8 knockOffProtections = 1;\r\n    if (characterType >= WIZARD_MIN_TYPE && characterType <= WIZARD_MAX_TYPE) {\r\n      knockOffProtections = 2;\r\n    }\r\n    if (protection[id] >= knockOffProtections) {\r\n      protection[id] = protection[id] - knockOffProtections;\r\n      return 0;\r\n    }\r\n    characterValue = characters[ids[index]].value;\r\n    nchars--;\r\n    replaceCharacter(index, nchars);\r\n  }\r\n\r\n  /**\r\n   * finds the oldest character\r\n   * */\r\n  function findOldest() public {\r\n    uint32 newOldest = noKing;\r\n    for (uint16 i = 0; i < numCharacters; i++) {\r\n      if (ids[i] < newOldest && characters[ids[i]].characterType <= DRAGON_MAX_TYPE)\r\n        newOldest = ids[i];\r\n    }\r\n    oldest = newOldest;\r\n  }\r\n\r\n  /**\r\n  * distributes the given amount among the surviving characters\r\n  * @param totalAmount nthe amount to distribute\r\n  */\r\n  function distribute(uint128 totalAmount) internal {\r\n    uint128 amount;\r\n    if (oldest == 0)\r\n      findOldest();\r\n    if (oldest != noKing) {\r\n      //pay 10% to the oldest dragon\r\n      characters[oldest].value += totalAmount / 10;\r\n      amount  = totalAmount / 10 * 9;\r\n    } else {\r\n      amount  = totalAmount;\r\n    }\r\n    //distribute the rest according to their type\r\n    uint128 valueSum;\r\n    uint8 size = ARCHER_MAX_TYPE;\r\n    uint128[] memory shares = new uint128[](size);\r\n    for (uint8 v = 0; v < size; v++) {\r\n      if ((v < BALLOON_MIN_TYPE || v > BALLOON_MAX_TYPE) && numCharactersXType[v] > 0) {\r\n           valueSum += config.values(v);\r\n      }\r\n    }\r\n    for (uint8 m = 0; m < size; m++) {\r\n      if ((v < BALLOON_MIN_TYPE || v > BALLOON_MAX_TYPE) && numCharactersXType[m] > 0) {\r\n        shares[m] = amount * config.values(m) / valueSum / numCharactersXType[m];\r\n      }\r\n    }\r\n    uint8 cType;\r\n    for (uint16 i = 0; i < numCharacters; i++) {\r\n      cType = characters[ids[i]].characterType;\r\n      if (cType < BALLOON_MIN_TYPE || cType > BALLOON_MAX_TYPE)\r\n        characters[ids[i]].value += shares[characters[ids[i]].characterType];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * allows the owner to collect the accumulated fees\r\n   * sends the given amount to the owner's address if the amount does not exceed the\r\n   * fees (cannot touch the players' balances) minus 100 finney (ensure that oraclize fees can be paid)\r\n   * @param amount the amount to be collected\r\n   * */\r\n  function collectFees(uint128 amount) public onlyOwner {\r\n    uint collectedFees = getFees();\r\n    if (amount + 100 finney < collectedFees) {\r\n      owner.transfer(amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n  * withdraw NDC and TPT tokens\r\n  */\r\n  function withdraw() public onlyOwner {\r\n    uint256 ndcBalance = neverdieToken.balanceOf(this);\r\n    assert(neverdieToken.transfer(owner, ndcBalance));\r\n    uint256 tptBalance = teleportToken.balanceOf(this);\r\n    assert(teleportToken.transfer(owner, tptBalance));\r\n  }\r\n\r\n  /**\r\n   * pays out the players.\r\n   * */\r\n  function payOut() public onlyOwner {\r\n    for (uint16 i = 0; i < numCharacters; i++) {\r\n      characters[ids[i]].owner.transfer(characters[ids[i]].value);\r\n      delete characters[ids[i]];\r\n    }\r\n    delete ids;\r\n    numCharacters = 0;\r\n  }\r\n\r\n  /**\r\n   * pays out the players and kills the game.\r\n   * */\r\n  function stop() public onlyOwner {\r\n    withdraw();\r\n    payOut();\r\n    destroy();\r\n  }\r\n\r\n  /* @dev distributes castle loot among archers */\r\n  function distributeCastleLoot() external onlyUser {\r\n    require(now >= lastCastleLootDistributionTimestamp + config.castleLootDistributionThreshold(),\r\n            \"not enough time passed since the last castle loot distribution\");\r\n    lastCastleLootDistributionTimestamp = now;\r\n    uint128 luckFactor = uint128(generateRandomNumber(now) % 51);\r\n    if (luckFactor < 5) {\r\n      luckFactor = 5;\r\n    }\r\n    uint128 amount = castleTreasury * luckFactor / 100; \r\n    uint128 valueSum;\r\n    uint128[] memory shares = new uint128[](NUMBER_OF_LEVELS);\r\n    uint16 archersCount;\r\n    uint32[] memory archers = new uint32[](numCharacters);\r\n\r\n    uint8 cType;\r\n    for (uint8 i = 0; i < ids.length; i++) {\r\n      cType = characters[ids[i]].characterType; \r\n      if ((cType >= ARCHER_MIN_TYPE && cType <= ARCHER_MAX_TYPE) && (((uint64(now) - characters[ids[i]].purchaseTimestamp) / config.eruptionThreshold()) >= 7)) {\r\n        valueSum += config.values(cType);\r\n        archers[archersCount] = ids[i];\r\n        archersCount++;\r\n      }\r\n    }\r\n\r\n    if (valueSum > 0) {\r\n      for (uint8 j = 0; j < NUMBER_OF_LEVELS; j++) {\r\n          shares[j] = amount * config.values(ARCHER_MIN_TYPE + j) / valueSum;\r\n      }\r\n\r\n      for (uint16 k = 0; k < archersCount; k++) {\r\n        characters[archers[k]].value += shares[characters[archers[k]].characterType - ARCHER_MIN_TYPE];\r\n      }\r\n      castleTreasury -= amount;\r\n      emit NewDistributionCastleLoot(amount);\r\n    } else {\r\n      emit NewDistributionCastleLoot(0);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * sell the character of the given id\r\n   * throws an exception in case of a knight not yet teleported to the game\r\n   * @param characterId the id of the character\r\n   * */\r\n  function sellCharacter(uint32 characterId) public onlyUser {\r\n    require(msg.sender == characters[characterId].owner,\r\n            \"only owners can sell their characters\");\r\n    require(characters[characterId].characterType < BALLOON_MIN_TYPE || characters[characterId].characterType > BALLOON_MAX_TYPE,\r\n            \"balloons are not sellable\");\r\n    require(characters[characterId].purchaseTimestamp + 1 days < now,\r\n            \"character can be sold only 1 day after the purchase\");\r\n    uint128 val = characters[characterId].value;\r\n    numCharacters--;\r\n    replaceCharacter(getCharacterIndex(characterId), numCharacters);\r\n    msg.sender.transfer(val);\r\n    if (oldest == 0)\r\n      findOldest();\r\n    emit NewSell(characterId, msg.sender, val);\r\n  }\r\n\r\n  /**\r\n   * receive approval to spend some tokens.\r\n   * used for teleport and protection.\r\n   * @param sender the sender address\r\n   * @param value the transferred value\r\n   * @param tokenContract the address of the token contract\r\n   * @param callData the data passed by the token contract\r\n   * */\r\n  function receiveApproval(address sender, uint256 value, address tokenContract, bytes callData) public {\r\n    uint32 id;\r\n    uint256 price;\r\n    if (msg.sender == address(teleportToken)) {\r\n      id = toUint32(callData);\r\n      price = config.teleportPrice();\r\n      if (characters[id].characterType >= BALLOON_MIN_TYPE && characters[id].characterType <= WIZARD_MAX_TYPE) {\r\n        price *= 2;\r\n      }\r\n      require(value >= price,\r\n              \"insufficinet amount of tokens to teleport this character\");\r\n      assert(teleportToken.transferFrom(sender, this, price));\r\n      teleportCharacter(id);\r\n    } else if (msg.sender == address(neverdieToken)) {\r\n      id = toUint32(callData);\r\n      // user can purchase extra lifes only right after character purchaes\r\n      // in other words, user value should be equal the initial value\r\n      uint8 cType = characters[id].characterType;\r\n      require(characters[id].value == config.values(cType),\r\n              \"protection could be bought only before the first fight and before the first volcano eruption\");\r\n\r\n      // calc how many lifes user can actually buy\r\n      // the formula is the following:\r\n\r\n      uint256 lifePrice;\r\n      uint8 max;\r\n      if(cType <= KNIGHT_MAX_TYPE || (cType >= ARCHER_MIN_TYPE && cType <= ARCHER_MAX_TYPE)){\r\n        lifePrice = ((cType % NUMBER_OF_LEVELS) + 1) * config.protectionPrice();\r\n        max = 3;\r\n      } else if (cType >= BALLOON_MIN_TYPE && cType <= BALLOON_MAX_TYPE) {\r\n        lifePrice = (((cType+3) % NUMBER_OF_LEVELS) + 1) * config.protectionPrice() * 2;\r\n        max = 6;\r\n      } else if (cType >= WIZARD_MIN_TYPE && cType <= WIZARD_MAX_TYPE) {\r\n        lifePrice = (((cType+3) % NUMBER_OF_LEVELS) + 1) * config.protectionPrice() * 2;\r\n        max = 3;\r\n      }\r\n\r\n      price = 0;\r\n      uint8 i = protection[id];\r\n      for (i; i < max && value >= price + lifePrice * (i + 1); i++) {\r\n        price += lifePrice * (i + 1);\r\n      }\r\n      assert(neverdieToken.transferFrom(sender, this, price));\r\n      protectCharacter(id, i);\r\n    } else {\r\n      revert(\"Should be either from Neverdie or Teleport tokens\");\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Knights, balloons, wizards, and archers are only entering the game completely, when they are teleported to the scene\r\n   * @param id the character id\r\n   * */\r\n  function teleportCharacter(uint32 id) internal {\r\n    // ensure we do not teleport twice\r\n    require(teleported[id] == false,\r\n           \"already teleported\");\r\n    teleported[id] = true;\r\n    Character storage character = characters[id];\r\n    require(character.characterType > DRAGON_MAX_TYPE,\r\n           \"dragons do not need to be teleported\"); //this also makes calls with non-existent ids fail\r\n    addCharacter(id, numCharacters);\r\n    numCharacters++;\r\n    numCharactersXType[character.characterType]++;\r\n    emit NewTeleport(id);\r\n  }\r\n\r\n  /**\r\n   * adds protection to a character\r\n   * @param id the character id\r\n   * @param lifes the number of protections\r\n   * */\r\n  function protectCharacter(uint32 id, uint8 lifes) internal {\r\n    protection[id] = lifes;\r\n    emit NewProtection(id, lifes);\r\n  }\r\n\r\n\r\n  /****************** GETTERS *************************/\r\n\r\n  /**\r\n   * returns the character of the given id\r\n   * @param characterId the character id\r\n   * @return the type, value and owner of the character\r\n   * */\r\n  function getCharacter(uint32 characterId) public view returns(uint8, uint128, address) {\r\n    return (characters[characterId].characterType, characters[characterId].value, characters[characterId].owner);\r\n  }\r\n\r\n  /**\r\n   * returns the index of a character of the given id\r\n   * @param characterId the character id\r\n   * @return the character id\r\n   * */\r\n  function getCharacterIndex(uint32 characterId) constant public returns(uint16) {\r\n    for (uint16 i = 0; i < ids.length; i++) {\r\n      if (ids[i] == characterId) {\r\n        return i;\r\n      }\r\n    }\r\n    revert();\r\n  }\r\n\r\n  /**\r\n   * returns 10 characters starting from a certain indey\r\n   * @param startIndex the index to start from\r\n   * @return 4 arrays containing the ids, types, values and owners of the characters\r\n   * */\r\n  function get10Characters(uint16 startIndex) constant public returns(uint32[10] characterIds, uint8[10] types, uint128[10] values, address[10] owners) {\r\n    uint32 endIndex = startIndex + 10 > numCharacters ? numCharacters : startIndex + 10;\r\n    uint8 j = 0;\r\n    uint32 id;\r\n    for (uint16 i = startIndex; i < endIndex; i++) {\r\n      id = ids[i];\r\n      characterIds[j] = id;\r\n      types[j] = characters[id].characterType;\r\n      values[j] = characters[id].value;\r\n      owners[j] = characters[id].owner;\r\n      j++;\r\n    }\r\n\r\n  }\r\n\r\n  /**\r\n   * returns the number of dragons in the game\r\n   * @return the number of dragons\r\n   * */\r\n  function getNumDragons() constant public returns(uint16 numDragons) {\r\n    for (uint8 i = DRAGON_MIN_TYPE; i <= DRAGON_MAX_TYPE; i++)\r\n      numDragons += numCharactersXType[i];\r\n  }\r\n\r\n  /**\r\n   * returns the number of wizards in the game\r\n   * @return the number of wizards\r\n   * */\r\n  function getNumWizards() constant public returns(uint16 numWizards) {\r\n    for (uint8 i = WIZARD_MIN_TYPE; i <= WIZARD_MAX_TYPE; i++)\r\n      numWizards += numCharactersXType[i];\r\n  }\r\n  /**\r\n   * returns the number of archers in the game\r\n   * @return the number of archers\r\n   * */\r\n  function getNumArchers() constant public returns(uint16 numArchers) {\r\n    for (uint8 i = ARCHER_MIN_TYPE; i <= ARCHER_MAX_TYPE; i++)\r\n      numArchers += numCharactersXType[i];\r\n  }\r\n\r\n  /**\r\n   * returns the number of knights in the game\r\n   * @return the number of knights\r\n   * */\r\n  function getNumKnights() constant public returns(uint16 numKnights) {\r\n    for (uint8 i = KNIGHT_MIN_TYPE; i <= KNIGHT_MAX_TYPE; i++)\r\n      numKnights += numCharactersXType[i];\r\n  }\r\n\r\n  /**\r\n   * @return the accumulated fees\r\n   * */\r\n  function getFees() constant public returns(uint) {\r\n    uint reserved = 0;\r\n    for (uint16 j = 0; j < numCharacters; j++)\r\n      reserved += characters[ids[j]].value;\r\n    return address(this).balance - reserved;\r\n  }\r\n\r\n\r\n  /************* HELPERS ****************/\r\n\r\n  /**\r\n   * only works for bytes of length < 32\r\n   * @param b the byte input\r\n   * @return the uint\r\n   * */\r\n  function toUint32(bytes b) internal pure returns(uint32) {\r\n    bytes32 newB;\r\n    assembly {\r\n      newB: = mload(0xa0)\r\n    }\r\n    return uint32(newB);\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"sellCharacter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumArchers\",\"outputs\":[{\"name\":\"numArchers\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerVolcanoEruption\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"xperToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KNIGHT_MAX_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"collectFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"castleTreasury\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"numCharactersXType\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BALLOON_MIN_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"getCharacter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint128\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_CHARACTER_INDEX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"getCharacterIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_XPER_AMOUNT_TO_PURCHASE_WIZARD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint16\"}],\"name\":\"get10Characters\",\"outputs\":[{\"name\":\"characterIds\",\"type\":\"uint32[10]\"},{\"name\":\"types\",\"type\":\"uint8[10]\"},{\"name\":\"values\",\"type\":\"uint128[10]\"},{\"name\":\"owners\",\"type\":\"address[10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastCastleLootDistributionTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"protection\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"characterID\",\"type\":\"uint32\"},{\"name\":\"characterIndex\",\"type\":\"uint16\"}],\"name\":\"fight\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"config\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"characterType\",\"type\":\"uint8\"}],\"name\":\"addCharacters\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumDragons\",\"outputs\":[{\"name\":\"numDragons\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"tokenContract\",\"type\":\"address\"},{\"name\":\"callData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"KNIGHT_MIN_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"distributeCastleLoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WIZARD_MAX_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumWizards\",\"outputs\":[{\"name\":\"numWizards\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teleportToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NUMBER_OF_LEVELS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"characterType\",\"type\":\"uint8\"},{\"name\":\"adversaryType\",\"type\":\"uint8\"}],\"name\":\"isValidAdversary\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ARCHER_MIN_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"name\":\"cooldown\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WIZARD_MIN_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sklToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumKnights\",\"outputs\":[{\"name\":\"numKnights\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_SKL_AMOUNT_TO_PURCHASE_WIZARD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastEruptionTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DRAGON_MAX_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payOut\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_XPER_AMOUNT_TO_PURCHASE_ARCHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"neverdieToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ARCHER_MAX_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BALLOON_MAX_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"noKing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_SKL_AMOUNT_TO_PURCHASE_ARCHER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DRAGON_MIN_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numCharacters\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"}],\"name\":\"destroyAndSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INVALID_CHARACTER_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"findOldest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tptAddress\",\"type\":\"address\"},{\"name\":\"ndcAddress\",\"type\":\"address\"},{\"name\":\"sklAddress\",\"type\":\"address\"},{\"name\":\"xperAddress\",\"type\":\"address\"},{\"name\":\"_configAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"characterType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"startId\",\"type\":\"uint32\"}],\"name\":\"NewPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"removedCharacters\",\"type\":\"uint32[]\"}],\"name\":\"NewExit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hitCharacters\",\"type\":\"uint32[]\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"gasCost\",\"type\":\"uint128\"}],\"name\":\"NewEruption\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"NewSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"winnerID\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"loserID\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"probability\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"dice\",\"type\":\"uint16\"}],\"name\":\"NewFight\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"}],\"name\":\"NewTeleport\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"characterId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"lifes\",\"type\":\"uint8\"}],\"name\":\"NewProtection\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"castleLoot\",\"type\":\"uint128\"}],\"name\":\"NewDistributionCastleLoot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DragonKing","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000c596bd09d652827b0106292d3e378d5938df4b12000000000000000000000000a54ddc7b3cce7fc8b1e3fa0256d0db80d2c10970000000000000000000000000a7bd9d58d22d5e35ec4a08083141e0340ea2ca93000000000000000000000000d28525ad63f337c86843d720dae921228e44f0ac00000000000000000000000013caaedfa70e029a6849a8ef08dd13a64ef891dd","Library":"","SwarmSource":"bzzr://8393d07bed97ecb942b6434a2d3d09daecba7198a8e2f8b5e70fda6e83ab8295"}]}