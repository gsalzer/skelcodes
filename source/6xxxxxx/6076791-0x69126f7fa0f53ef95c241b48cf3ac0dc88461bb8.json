{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: libs/EC.sol\r\n\r\ncontract EC {\r\n\r\n    uint256 constant public gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798;\r\n    uint256 constant public gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8;\r\n    uint256 constant public n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F;\r\n    uint256 constant public a = 0;\r\n    uint256 constant public b = 7;\r\n\r\n    function _jAdd(\r\n        uint256 x1, uint256 z1,\r\n        uint256 x2, uint256 z2)\r\n        public \r\n        pure\r\n        returns(uint256 x3, uint256 z3)\r\n    {\r\n        (x3, z3) = (\r\n            addmod(\r\n                mulmod(z2, x1, n),\r\n                mulmod(x2, z1, n),\r\n                n\r\n            ),\r\n            mulmod(z1, z2, n)\r\n        );\r\n    }\r\n\r\n    function _jSub(\r\n        uint256 x1, uint256 z1,\r\n        uint256 x2, uint256 z2)\r\n        public \r\n        pure\r\n        returns(uint256 x3, uint256 z3)\r\n    {\r\n        (x3, z3) = (\r\n            addmod(\r\n                mulmod(z2, x1, n),\r\n                mulmod(n - x2, z1, n),\r\n                n\r\n            ),\r\n            mulmod(z1, z2, n)\r\n        );\r\n    }\r\n\r\n    function _jMul(\r\n        uint256 x1, uint256 z1,\r\n        uint256 x2, uint256 z2)\r\n        public \r\n        pure\r\n        returns(uint256 x3, uint256 z3)\r\n    {\r\n        (x3, z3) = (\r\n            mulmod(x1, x2, n),\r\n            mulmod(z1, z2, n)\r\n        );\r\n    }\r\n\r\n    function _jDiv(\r\n        uint256 x1, uint256 z1,\r\n        uint256 x2, uint256 z2) \r\n        public \r\n        pure\r\n        returns(uint256 x3, uint256 z3)\r\n    {\r\n        (x3, z3) = (\r\n            mulmod(x1, z2, n),\r\n            mulmod(z1, x2, n)\r\n        );\r\n    }\r\n\r\n    function _inverse(uint256 val) public pure\r\n        returns(uint256 invVal)\r\n    {\r\n        uint256 t = 0;\r\n        uint256 newT = 1;\r\n        uint256 r = n;\r\n        uint256 newR = val;\r\n        uint256 q;\r\n        while (newR != 0) {\r\n            q = r / newR;\r\n\r\n            (t, newT) = (newT, addmod(t, (n - mulmod(q, newT, n)), n));\r\n            (r, newR) = (newR, r - q * newR );\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    function _ecAdd(\r\n        uint256 x1, uint256 y1, uint256 z1,\r\n        uint256 x2, uint256 y2, uint256 z2) \r\n        public \r\n        pure\r\n        returns(uint256 x3, uint256 y3, uint256 z3)\r\n    {\r\n        uint256 lx;\r\n        uint256 lz;\r\n        uint256 da;\r\n        uint256 db;\r\n\r\n        if (x1 == 0 && y1 == 0) {\r\n            return (x2, y2, z2);\r\n        }\r\n\r\n        if (x2 == 0 && y2 == 0) {\r\n            return (x1, y1, z1);\r\n        }\r\n\r\n        if (x1 == x2 && y1 == y2) {\r\n            (lx, lz) = _jMul(x1, z1, x1, z1);\r\n            (lx, lz) = _jMul(lx, lz, 3, 1);\r\n            (lx, lz) = _jAdd(lx, lz, a, 1);\r\n\r\n            (da,db) = _jMul(y1, z1, 2, 1);\r\n        } else {\r\n            (lx, lz) = _jSub(y2, z2, y1, z1);\r\n            (da, db) = _jSub(x2, z2, x1, z1);\r\n        }\r\n\r\n        (lx, lz) = _jDiv(lx, lz, da, db);\r\n\r\n        (x3, da) = _jMul(lx, lz, lx, lz);\r\n        (x3, da) = _jSub(x3, da, x1, z1);\r\n        (x3, da) = _jSub(x3, da, x2, z2);\r\n\r\n        (y3, db) = _jSub(x1, z1, x3, da);\r\n        (y3, db) = _jMul(y3, db, lx, lz);\r\n        (y3, db) = _jSub(y3, db, y1, z1);\r\n\r\n        if (da != db) {\r\n            x3 = mulmod(x3, db, n);\r\n            y3 = mulmod(y3, da, n);\r\n            z3 = mulmod(da, db, n);\r\n        } else {\r\n            z3 = da;\r\n        }\r\n    }\r\n\r\n    function _ecDouble(uint256 x1, uint256 y1, uint256 z1) public pure\r\n        returns(uint256 x3, uint256 y3, uint256 z3)\r\n    {\r\n        (x3, y3, z3) = _ecAdd(x1, y1, z1, x1, y1, z1);\r\n    }\r\n\r\n    function _ecMul(uint256 d, uint256 x1, uint256 y1, uint256 z1) public pure\r\n        returns(uint256 x3, uint256 y3, uint256 z3)\r\n    {\r\n        uint256 remaining = d;\r\n        uint256 px = x1;\r\n        uint256 py = y1;\r\n        uint256 pz = z1;\r\n        uint256 acx = 0;\r\n        uint256 acy = 0;\r\n        uint256 acz = 1;\r\n\r\n        if (d == 0) {\r\n            return (0, 0, 1);\r\n        }\r\n\r\n        while (remaining != 0) {\r\n            if ((remaining & 1) != 0) {\r\n                (acx,acy,acz) = _ecAdd(acx, acy, acz, px, py, pz);\r\n            }\r\n            remaining = remaining / 2;\r\n            (px, py, pz) = _ecDouble(px, py, pz);\r\n        }\r\n\r\n        (x3, y3, z3) = (acx, acy, acz);\r\n    }\r\n\r\n    function ecadd(\r\n        uint256 x1, uint256 y1,\r\n        uint256 x2, uint256 y2)\r\n        public\r\n        pure\r\n        returns(uint256 x3, uint256 y3)\r\n    {\r\n        uint256 z;\r\n        (x3, y3, z) = _ecAdd(x1, y1, 1, x2, y2, 1);\r\n        z = _inverse(z);\r\n        x3 = mulmod(x3, z, n);\r\n        y3 = mulmod(y3, z, n);\r\n    }\r\n\r\n    function ecmul(uint256 x1, uint256 y1, uint256 scalar) public pure\r\n        returns(uint256 x2, uint256 y2)\r\n    {\r\n        uint256 z;\r\n        (x2, y2, z) = _ecMul(scalar, x1, y1, 1);\r\n        z = _inverse(z);\r\n        x2 = mulmod(x2, z, n);\r\n        y2 = mulmod(y2, z, n);\r\n    }\r\n\r\n    function ecmulVerify(uint256 x1, uint256 y1, uint256 scalar, uint256 qx, uint256 qy) public pure\r\n        returns(bool)\r\n    {\r\n        uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141;\r\n        address signer = ecrecover(0, y1 % 2 != 0 ? 28 : 27, bytes32(x1), bytes32(mulmod(scalar, x1, m)));\r\n        address xyAddress = address(uint256(keccak256(abi.encodePacked(qx, qy))) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n        return xyAddress == signer;\r\n    }\r\n\r\n    function publicKey(uint256 privKey) public pure\r\n        returns(uint256 qx, uint256 qy)\r\n    {\r\n        return ecmul(gx, gy, privKey);\r\n    }\r\n\r\n    function publicKeyVerify(uint256 privKey, uint256 x, uint256 y) public pure\r\n        returns(bool)\r\n    {\r\n        return ecmulVerify(gx, gy, privKey, x, y);\r\n    }\r\n\r\n    function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public pure\r\n        returns(uint256 qx, uint256 qy)\r\n    {\r\n        uint256 z;\r\n        (qx, qy, z) = _ecMul(privKey, pubX, pubY, 1);\r\n        z = _inverse(z);\r\n        qx = mulmod(qx, z, n);\r\n        qy = mulmod(qy, z, n);\r\n    }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/Upgradable.sol\r\n\r\ncontract IUpgradable {\r\n    function startUpgrade() public;\r\n    function endUpgrade() public;\r\n}\r\n\r\ncontract Upgradable is Ownable {\r\n    struct UpgradableState {\r\n        bool isUpgrading;\r\n        address prevVersion;\r\n        address nextVersion;\r\n    }\r\n\r\n    UpgradableState public upgradableState;\r\n\r\n    event Initialized(address indexed prevVersion);\r\n    event Upgrading(address indexed nextVersion);\r\n    event Upgraded(address indexed nextVersion);\r\n\r\n    modifier isLastestVersion {\r\n        require(!upgradableState.isUpgrading);\r\n        require(upgradableState.nextVersion == address(0));\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerOrigin {\r\n        require(tx.origin == owner);\r\n        _;\r\n    }\r\n\r\n    constructor(address _prevVersion) public {\r\n        if (_prevVersion != address(0)) {\r\n            require(msg.sender == Ownable(_prevVersion).owner());\r\n            upgradableState.isUpgrading = true;\r\n            upgradableState.prevVersion = _prevVersion;\r\n            IUpgradable(_prevVersion).startUpgrade();\r\n        } else {\r\n            emit Initialized(_prevVersion);\r\n        }\r\n    }\r\n\r\n    function startUpgrade() public onlyOwnerOrigin {\r\n        require(msg.sender != owner);\r\n        require(!upgradableState.isUpgrading);\r\n        require(upgradableState.nextVersion == 0);\r\n        upgradableState.isUpgrading = true;\r\n        upgradableState.nextVersion = msg.sender;\r\n        emit Upgrading(msg.sender);\r\n    }\r\n\r\n    //function upgrade(uint index, uint size) public onlyOwner {}\r\n\r\n    function endUpgrade() public onlyOwnerOrigin {\r\n        require(upgradableState.isUpgrading);\r\n        upgradableState.isUpgrading = false;\r\n        if (msg.sender != owner) {\r\n            require(upgradableState.nextVersion == msg.sender);\r\n            emit Upgraded(upgradableState.nextVersion);\r\n        } \r\n        else  {\r\n            if (upgradableState.prevVersion != address(0)) {\r\n                Upgradable(upgradableState.prevVersion).endUpgrade();\r\n            }\r\n            emit Initialized(upgradableState.prevVersion);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/VanityLib.sol\r\n\r\ncontract VanityLib {\r\n    uint constant m = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f;\r\n\r\n    function lengthOfCommonPrefix(bytes32 a, bytes32 b) public pure returns(uint) {\r\n        for (uint i = 0; i < 32; i++) {\r\n            if (a[i] != b[i] || a[i] == 0) {\r\n                return i;\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n    \r\n    function bytesToBytes32(bytes source) public pure returns(bytes32 result) {\r\n        assembly {\r\n            result := mload(add(source, 32))\r\n        }\r\n    }\r\n\r\n    /* Converts given number to base58, limited by 32 symbols */\r\n    function toBase58Checked(uint256 _value, byte appCode) public pure returns(bytes32) {\r\n        string memory letters = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\r\n        bytes memory alphabet = bytes(letters);\r\n        uint8 base = 58;\r\n        uint8 len = 0;\r\n        uint256 remainder = 0;\r\n        bool needBreak = false;\r\n        bytes memory bytesReversed = bytes(new string(32));\r\n        \r\n        for (uint8 i = 0; true; i++) {\r\n            if (_value < base) {\r\n                needBreak = true;\r\n            }\r\n            remainder = _value % base;\r\n            _value = uint256(_value / base);\r\n            if (len == 32) {\r\n                for (uint j = 0; j < len - 1; j++) {\r\n                    bytesReversed[j] = bytesReversed[j + 1];\r\n                }\r\n                len--;\r\n            }\r\n            bytesReversed[len] = alphabet[remainder];\r\n            len++;\r\n            if (needBreak) {\r\n                break;\r\n            }\r\n        }\r\n        \r\n        // Reverse\r\n        bytes memory result = bytes(new string(32));\r\n        result[0] = appCode;\r\n        for (i = 0; i < 31; i++) {\r\n            result[i + 1] = bytesReversed[len - 1 - i];\r\n        }\r\n        \r\n        return bytesToBytes32(result);\r\n    }\r\n\r\n    // Create BTC Address: https://en.bitcoin.it/wiki/Technical_background_of_version_1_Bitcoin_addresses#How_to_create_Bitcoin_Address\r\n    function createBtcAddressHex(uint256 publicXPoint, uint256 publicYPoint) public pure returns(uint256) {\r\n        bytes20 publicKeyPart = ripemd160(abi.encodePacked(sha256(abi.encodePacked(byte(0x04), publicXPoint, publicYPoint))));\r\n        bytes32 publicKeyCheckCode = sha256(abi.encodePacked(sha256(abi.encodePacked(byte(0x00), publicKeyPart))));\r\n        \r\n        bytes memory publicKey = new bytes(32);\r\n        for (uint i = 0; i < 7; i++) {\r\n            publicKey[i] = 0x00;\r\n        }\r\n        publicKey[7] = 0x00; // Main Network\r\n        for (uint j = 0; j < 20; j++) {\r\n            publicKey[j + 8] = publicKeyPart[j];\r\n        }\r\n        publicKey[28] = publicKeyCheckCode[0];\r\n        publicKey[29] = publicKeyCheckCode[1];\r\n        publicKey[30] = publicKeyCheckCode[2];\r\n        publicKey[31] = publicKeyCheckCode[3];\r\n        \r\n        return uint256(bytesToBytes32(publicKey));\r\n    }\r\n    \r\n    function createBtcAddress(uint256 publicXPoint, uint256 publicYPoint) public pure returns(bytes32) {\r\n        return toBase58Checked(createBtcAddressHex(publicXPoint, publicYPoint), \"1\");\r\n    }\r\n\r\n    function complexityForBtcAddressPrefix(bytes prefix) public pure returns(uint) {\r\n        return complexityForBtcAddressPrefixWithLength(prefix, prefix.length);\r\n    }\r\n\r\n    // https://bitcoin.stackexchange.com/questions/48586\r\n    function complexityForBtcAddressPrefixWithLength(bytes prefix, uint length) public pure returns(uint) {\r\n        require(prefix.length >= length);\r\n        \r\n        uint8[128] memory unbase58 = [\r\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \r\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,\r\n            255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, \r\n            255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 255, 255, 255, 255, 255, 255, \r\n            255, 9, 10, 11, 12, 13, 14, 15, 16, 255, 17, 18, 19, 20, 21, 255, \r\n            22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 255, 255, 255, 255, 255,\r\n            255, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 255, 44, 45, 46,\r\n            47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 255, 255, 255, 255, 255\r\n        ];\r\n\r\n        uint leadingOnes = countBtcAddressLeadingOnes(prefix, length);\r\n\r\n        uint256 prefixValue = 0;\r\n        uint256 prefix1 = 1;\r\n        for (uint i = 0; i < length; i++) {\r\n            uint index = uint(prefix[i]);\r\n            require(index != 255);\r\n            prefixValue = prefixValue * 58 + unbase58[index];\r\n            prefix1 *= 58;\r\n        }\r\n\r\n        uint256 top = (uint256(1) << (200 - 8*leadingOnes));\r\n        uint256 total = 0;\r\n        uint256 prefixMin = prefixValue;\r\n        uint256 diff = 0;\r\n        for (uint digits = 1; prefix1/58 < (1 << 192); digits++) {\r\n            prefix1 *= 58;\r\n            prefixMin *= 58;\r\n            prefixValue = prefixValue * 58 + 57;\r\n\r\n            diff = 0;\r\n            if (prefixValue >= top) {\r\n                diff += prefixValue - top;\r\n            }\r\n            if (prefixMin < (top >> 8)) {\r\n                diff += (top >> 8) - prefixMin;\r\n            }\r\n            \r\n            if ((58 ** digits) >= diff) {\r\n                total += (58 ** digits) - diff;\r\n            }\r\n        }\r\n\r\n        if (prefixMin == 0) { // if prefix is contains only ones: 111111\r\n            total = (58 ** (digits - 1)) - diff;\r\n        }\r\n\r\n        return (1 << 192) / total;\r\n    }\r\n\r\n    function countBtcAddressLeadingOnes(bytes prefix, uint length) public pure returns(uint) {\r\n        uint leadingOnes = 1;\r\n        for (uint j = 0; j < length && prefix[j] == 49; j++) {\r\n            leadingOnes = j + 1;\r\n        }\r\n        return leadingOnes;\r\n    }\r\n\r\n    function isValidBicoinAddressPrefix(bytes prefixArg) public pure returns(bool) {\r\n        if (prefixArg.length < 5) {\r\n            return false;\r\n        }\r\n        if (prefixArg[0] != \"1\" && prefixArg[0] != \"3\") {\r\n            return false;\r\n        }\r\n        \r\n        for (uint i = 0; i < prefixArg.length; i++) {\r\n            byte ch = prefixArg[i];\r\n            if (ch == \"0\" || ch == \"O\" || ch == \"I\" || ch == \"l\") {\r\n                return false;\r\n            }\r\n            if (!((ch >= \"1\" && ch <= \"9\") || (ch >= \"a\" && ch <= \"z\") || (ch >= \"A\" && ch <= \"Z\"))) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function isValidPublicKey(uint256 x, uint256 y) public pure returns(bool) {\r\n        return (mulmod(y, y, m) == addmod(mulmod(x, mulmod(x, x, m), m), 7, m));\r\n    }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/TaskRegister.sol\r\n\r\ncontract TaskRegister is Upgradable, VanityLib {\r\n    using SafeMath for uint256;\r\n\r\n    enum TaskType {\r\n        BITCOIN_ADDRESS_PREFIX\r\n    }\r\n\r\n    struct Task {\r\n        TaskType taskType;\r\n        uint256 taskId;\r\n        address creator;\r\n        address referrer;\r\n        uint256 reward;\r\n        bytes32 data;\r\n        uint256 dataLength;\r\n        uint256 requestPublicXPoint;\r\n        uint256 requestPublicYPoint;\r\n        uint256 answerPrivateKey;\r\n    }\r\n\r\n    EC public ec;\r\n    uint256 public nextTaskId = 1;\r\n    uint256 public totalReward;\r\n    uint256 constant public MAX_PERCENT = 1000000;\r\n    uint256 public serviceFee; // 1% == 10000, 100% == 1000000\r\n    uint256 public referrerFee; // Calculated from service fee, 50% == 500000\r\n    \r\n    Task[] public tasks;\r\n    Task[] public completedTasks;\r\n    mapping(uint256 => uint) public indexOfTaskId; // Starting from 1\r\n\r\n    event TaskCreated(uint256 indexed taskId);\r\n    event TaskSolved(uint256 indexed taskId, uint256 reward);\r\n    event TaskPayed(uint256 indexed taskId, uint256 value);\r\n\r\n    constructor(address _ec, address _prevVersion) public Upgradable(_prevVersion) {\r\n        ec = EC(_ec);\r\n    }\r\n\r\n    function setServiceFee(uint256 _serviceFee) public onlyOwner {\r\n        require(_serviceFee < 20000); // 2% of reward\r\n        serviceFee = _serviceFee;\r\n    }\r\n\r\n    function setReferrerFee(uint256 _referrerFee) public onlyOwner {\r\n        require(_referrerFee < 50000); // 50% of serviceFee\r\n        referrerFee = _referrerFee;\r\n    }\r\n\r\n    function upgrade(uint _size) public onlyOwner {\r\n        require(upgradableState.isUpgrading);\r\n        require(upgradableState.prevVersion != 0);\r\n\r\n        // Migrate some vars\r\n        nextTaskId = TaskRegister(upgradableState.prevVersion).nextTaskId();\r\n        totalReward = TaskRegister(upgradableState.prevVersion).totalReward();\r\n        //TODO: uncomment for the next version\r\n        //serviceFee = TaskRegister(upgradableState.prevVersion).serviceFee();\r\n        //referrerFee = TaskRegister(upgradableState.prevVersion).referrerFee();\r\n        \r\n        uint index = tasks.length;\r\n        uint tasksCount = TaskRegister(upgradableState.prevVersion).tasksCount();\r\n\r\n        // Migrate tasks\r\n\r\n        for (uint i = index; i < index + _size && i < tasksCount; i++) {\r\n            tasks.push(Task(TaskType.BITCOIN_ADDRESS_PREFIX,0,0,0,0,bytes32(0),0,0,0,0));\r\n        }\r\n\r\n        for (uint j = index; j < index + _size && j < tasksCount; j++) {\r\n            (\r\n                tasks[j].taskType,\r\n                tasks[j].taskId,\r\n                tasks[j].creator,\r\n                tasks[j].referrer,\r\n                ,//tasks[j].reward,\r\n                ,//tasks[j].data,\r\n                ,//tasks[j].dataLength, \r\n                ,//tasks[j].requestPublicXPoint, \r\n                ,//tasks[j].requestPublicYPoint,\r\n                 //tasks[j].answerPrivateKey\r\n            ) = TaskRegister(upgradableState.prevVersion).tasks(j);\r\n            indexOfTaskId[tasks[j].taskId] = j + 1;\r\n        }\r\n\r\n        for (j = index; j < index + _size && j < tasksCount; j++) {\r\n            (\r\n                ,//tasks[j].taskType,\r\n                ,//tasks[j].taskId,\r\n                ,//tasks[j].creator,\r\n                ,//tasks[j].referrer,\r\n                tasks[j].reward,\r\n                tasks[j].data,\r\n                tasks[j].dataLength, \r\n                tasks[j].requestPublicXPoint, \r\n                ,//tasks[j].requestPublicYPoint,\r\n                 //tasks[j].answerPrivateKey\r\n            ) = TaskRegister(upgradableState.prevVersion).tasks(j);\r\n        }\r\n\r\n        for (j = index; j < index + _size && j < tasksCount; j++) {\r\n            (\r\n                ,//tasks[j].taskType,\r\n                ,//tasks[j].taskId,\r\n                ,//tasks[j].creator,\r\n                ,//tasks[j].referrer,\r\n                ,//tasks[j].reward,\r\n                ,//tasks[j].data,\r\n                ,//tasks[j].dataLength, \r\n                ,//tasks[j].requestPublicXPoint, \r\n                tasks[j].requestPublicYPoint,\r\n                tasks[j].answerPrivateKey\r\n            ) = TaskRegister(upgradableState.prevVersion).tasks(j);\r\n        }\r\n    }\r\n    \r\n    function endUpgrade() public {\r\n        super.endUpgrade();\r\n    }\r\n\r\n    function tasksCount() public view returns(uint) {\r\n        return tasks.length;\r\n    }\r\n\r\n    function completedTasksCount() public view returns(uint) {\r\n        return completedTasks.length;\r\n    }\r\n\r\n    function payForTask(uint256 _taskId) payable public isLastestVersion {\r\n        if (msg.value > 0) {\r\n            Task storage task = tasks[safeIndexOfTaskId(_taskId)];\r\n            task.reward = task.reward.add(msg.value);\r\n            totalReward = totalReward.add(msg.value);\r\n            emit TaskPayed(_taskId, msg.value);\r\n        }\r\n    }\r\n\r\n    function safeIndexOfTaskId(uint _taskId) public view returns(uint) {\r\n        return indexOfTaskId[_taskId].sub(1);\r\n    }\r\n    \r\n    function createBitcoinAddressPrefixTask(\r\n        bytes prefix,\r\n        uint256 requestPublicXPoint,\r\n        uint256 requestPublicYPoint,\r\n        address referrer\r\n    )\r\n        payable\r\n        public\r\n        isLastestVersion\r\n    {\r\n        require(prefix.length > 5);\r\n        require(prefix[0] == \"1\");\r\n        require(prefix[1] != \"1\"); // Do not support multiple 1s yet\r\n        require(isValidBicoinAddressPrefix(prefix));\r\n        require(isValidPublicKey(requestPublicXPoint, requestPublicYPoint));\r\n\r\n        bytes32 data;\r\n        assembly {\r\n            data := mload(add(prefix, 32))\r\n        }\r\n        \r\n        Task memory task = Task({\r\n            taskType: TaskType.BITCOIN_ADDRESS_PREFIX,\r\n            taskId: nextTaskId++,\r\n            creator: msg.sender,\r\n            referrer: referrer,\r\n            reward: 0,\r\n            data: data,\r\n            dataLength: prefix.length,\r\n            requestPublicXPoint: requestPublicXPoint,\r\n            requestPublicYPoint: requestPublicYPoint,\r\n            answerPrivateKey: 0\r\n        });\r\n\r\n        indexOfTaskId[task.taskId] = tasks.push(task); // incremented to avoid 0 index\r\n        emit TaskCreated(task.taskId);\r\n        payForTask(task.taskId);\r\n    }\r\n    \r\n    function solveTask(uint _taskId, uint256 _answerPrivateKey, uint256 publicXPoint, uint256 publicYPoint) public isLastestVersion {\r\n        uint taskIndex = safeIndexOfTaskId(_taskId);\r\n        Task storage task = tasks[taskIndex];\r\n        require(task.answerPrivateKey == 0, \"solveTask: task is already solved\");\r\n\r\n        // Require private key to be part of address to prevent front-running attack\r\n        require(_answerPrivateKey >> 128 == uint256(msg.sender) >> 32, \"solveTask: this solution does not match miner address\");\r\n\r\n        if (task.taskType == TaskType.BITCOIN_ADDRESS_PREFIX) {\r\n            ///(publicXPoint, publicYPoint) = ec.publicKey(_answerPrivateKey);\r\n            require(ec.publicKeyVerify(_answerPrivateKey, publicXPoint, publicYPoint));\r\n            (publicXPoint, publicYPoint) = ec.ecadd(\r\n                task.requestPublicXPoint,\r\n                task.requestPublicYPoint,\r\n                publicXPoint,\r\n                publicYPoint\r\n            );\r\n\r\n            require(isValidPublicKey(publicXPoint, publicYPoint));\r\n            \r\n            bytes32 btcAddress = createBtcAddress(publicXPoint, publicYPoint);\r\n            uint prefixLength = lengthOfCommonPrefix(btcAddress, task.data);\r\n            require(prefixLength == task.dataLength);\r\n            \r\n            task.answerPrivateKey = _answerPrivateKey;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        uint256 minerReward = task.reward.mul(MAX_PERCENT - serviceFee).div(MAX_PERCENT); // 1% fee\r\n        uint256 referrerReward = task.reward.mul(serviceFee).mul(referrerFee).div(MAX_PERCENT).div(MAX_PERCENT); // 50% of service fee\r\n        msg.sender.transfer(minerReward);\r\n        task.referrer.transfer(referrerReward);\r\n        totalReward = totalReward.sub(task.reward.sub(minerReward.add(referrerReward)));\r\n\r\n        _completeTask(_taskId, taskIndex);\r\n        emit TaskSolved(_taskId, minerReward);\r\n    }\r\n\r\n    function _completeTask(uint _taskId, uint _index) internal {\r\n        completedTasks.push(tasks[_index]);\r\n        if (_index < tasks.length - 1) { // if not latest\r\n            tasks[_index] = tasks[tasks.length - 1];\r\n            indexOfTaskId[tasks[_index].taskId] = _index + 1;\r\n        }\r\n        tasks.length -= 1;\r\n        delete indexOfTaskId[_taskId];\r\n    }\r\n\r\n    function claim(ERC20Basic _token, address _to) public onlyOwner {\r\n        if (_token == address(0)) {\r\n            _to.transfer(address(this).balance - totalReward);\r\n        } else {\r\n            _token.transfer(_to, _token.balanceOf(this));\r\n        }\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MAX_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prefixArg\",\"type\":\"bytes\"}],\"name\":\"isValidBicoinAddressPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endUpgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"a\",\"type\":\"bytes32\"},{\"name\":\"b\",\"type\":\"bytes32\"}],\"name\":\"lengthOfCommonPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"publicXPoint\",\"type\":\"uint256\"},{\"name\":\"publicYPoint\",\"type\":\"uint256\"}],\"name\":\"createBtcAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"appCode\",\"type\":\"bytes1\"}],\"name\":\"toBase58Checked\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"complexityForBtcAddressPrefixWithLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"x\",\"type\":\"uint256\"},{\"name\":\"y\",\"type\":\"uint256\"}],\"name\":\"isValidPublicKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"completedTasks\",\"outputs\":[{\"name\":\"taskType\",\"type\":\"uint8\"},{\"name\":\"taskId\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"dataLength\",\"type\":\"uint256\"},{\"name\":\"requestPublicXPoint\",\"type\":\"uint256\"},{\"name\":\"requestPublicYPoint\",\"type\":\"uint256\"},{\"name\":\"answerPrivateKey\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_size\",\"type\":\"uint256\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taskId\",\"type\":\"uint256\"}],\"name\":\"payForTask\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"}],\"name\":\"complexityForBtcAddressPrefix\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_taskId\",\"type\":\"uint256\"}],\"name\":\"safeIndexOfTaskId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_serviceFee\",\"type\":\"uint256\"}],\"name\":\"setServiceFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"completedTasksCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"},{\"name\":\"length\",\"type\":\"uint256\"}],\"name\":\"countBtcAddressLeadingOnes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tasks\",\"outputs\":[{\"name\":\"taskType\",\"type\":\"uint8\"},{\"name\":\"taskId\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes32\"},{\"name\":\"dataLength\",\"type\":\"uint256\"},{\"name\":\"requestPublicXPoint\",\"type\":\"uint256\"},{\"name\":\"requestPublicYPoint\",\"type\":\"uint256\"},{\"name\":\"answerPrivateKey\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgradableState\",\"outputs\":[{\"name\":\"isUpgrading\",\"type\":\"bool\"},{\"name\":\"prevVersion\",\"type\":\"address\"},{\"name\":\"nextVersion\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prefix\",\"type\":\"bytes\"},{\"name\":\"requestPublicXPoint\",\"type\":\"uint256\"},{\"name\":\"requestPublicYPoint\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"createBitcoinAddressPrefixTask\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tasksCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"source\",\"type\":\"bytes\"}],\"name\":\"bytesToBytes32\",\"outputs\":[{\"name\":\"result\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"publicXPoint\",\"type\":\"uint256\"},{\"name\":\"publicYPoint\",\"type\":\"uint256\"}],\"name\":\"createBtcAddressHex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_taskId\",\"type\":\"uint256\"},{\"name\":\"_answerPrivateKey\",\"type\":\"uint256\"},{\"name\":\"publicXPoint\",\"type\":\"uint256\"},{\"name\":\"publicYPoint\",\"type\":\"uint256\"}],\"name\":\"solveTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"indexOfTaskId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referrerFee\",\"type\":\"uint256\"}],\"name\":\"setReferrerFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ec\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextTaskId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ec\",\"type\":\"address\"},{\"name\":\"_prevVersion\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskId\",\"type\":\"uint256\"}],\"name\":\"TaskCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"TaskSolved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"taskId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TaskPayed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"prevVersion\",\"type\":\"address\"}],\"name\":\"Initialized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nextVersion\",\"type\":\"address\"}],\"name\":\"Upgrading\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nextVersion\",\"type\":\"address\"}],\"name\":\"Upgraded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TaskRegister","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000014712c5a51d1c0a993c5f3df5de844e345f05a2b000000000000000000000000e6e1922862a29ff473b2f0fb7b80bd96bbb7ba95","Library":"","SwarmSource":"bzzr://1ba975d7ea9b4d5dca8a11135e811aa502f7188241ecd2a2f649d6d3238d6756"}]}