{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/IDisputer.sol\r\n\r\n/**\r\n * Interface of what the disputer contract should do.\r\n *\r\n * Its main responsibility to interact with Augur. Only minimal glue methods\r\n * are added apart from that in order for crowdsourcer to be able to interact\r\n * with it.\r\n *\r\n * This contract holds the actual crowdsourced REP for dispute, so it doesn't\r\n * need to transfer it from elsewhere at the moment of dispute. It doesn't care\r\n * at all who this REP belongs to, it just spends it for dispute. Accounting\r\n * is done in other contracts.\r\n */\r\ninterface IDisputer {\r\n  /**\r\n   * This function should use as little gas as possible, as it will be called\r\n   * during rush time. Unnecessary operations are postponed for later.\r\n   *\r\n   * Can by called by anyone, but only once.\r\n   */\r\n  function dispute(address feeReceiver) external;\r\n\r\n  // intentionally can be called by anyone, as no user input is used\r\n  function approveManagerToSpendDisputeTokens() external;\r\n\r\n  function getOwner() external view returns(address);\r\n\r\n  function hasDisputed() external view returns(bool);\r\n\r\n  function feeReceiver() external view returns(address);\r\n\r\n  function getREP() external view returns(IERC20);\r\n\r\n  function getDisputeTokenAddress() external view returns(IERC20);\r\n}\r\n\r\n// File: contracts/augur/feeWindow.sol\r\n\r\ninterface FeeWindow {\r\n  function getStartTime() external view returns(uint256);\r\n}\r\n\r\n// File: contracts/augur/universe.sol\r\n\r\ninterface Universe {\r\n  function getDisputeRoundDurationInSeconds() external view returns(uint256);\r\n  function isForking() external view returns(bool);\r\n}\r\n\r\n// File: contracts/augur/reportingParticipant.sol\r\n\r\n/**\r\n * This should've been an interface, but interfaces cannot inherit interfaces\r\n */\r\ncontract ReportingParticipant is IERC20 {\r\n  function getStake() external view returns(uint256);\r\n  function getPayoutDistributionHash() external view returns(bytes32);\r\n}\r\n\r\n// File: contracts/augur/market.sol\r\n\r\ninterface Market {\r\n  function contribute(\r\n    uint256[] _payoutNumerators,\r\n    bool _invalid,\r\n    uint256 _amount\r\n  ) external returns(bool);\r\n\r\n  function getReputationToken() external view returns(IERC20);\r\n\r\n  function getUniverse() external view returns(Universe);\r\n\r\n  function derivePayoutDistributionHash(\r\n    uint256[] _payoutNumerators,\r\n    bool _invalid\r\n  ) external view returns(bytes32);\r\n\r\n  function getCrowdsourcer(\r\n    bytes32 _payoutDistributionHash\r\n  ) external view returns(ReportingParticipant);\r\n\r\n  function getNumParticipants() external view returns(uint256);\r\n\r\n  function getReportingParticipant(uint256 _index) external view returns(\r\n    ReportingParticipant\r\n  );\r\n\r\n  function isFinalized() external view returns(bool);\r\n\r\n  function getFeeWindow() external view returns(FeeWindow);\r\n\r\n  function getWinningReportingParticipant() external view returns(\r\n    ReportingParticipant\r\n  );\r\n}\r\n\r\n// File: contracts/IDisputerFactory.sol\r\n\r\ninterface IDisputerFactory {\r\n  event DisputerCreated(\r\n    address _owner,\r\n    IDisputer _address,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  );\r\n\r\n  function create(\r\n    address owner,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) external returns(IDisputer);\r\n}\r\n\r\n// File: contracts/DisputerParams.sol\r\n\r\nlibrary DisputerParams {\r\n  struct Params {\r\n    Market market;\r\n    uint256 feeWindowId;\r\n    uint256[] payoutNumerators;\r\n    bool invalid;\r\n  }\r\n}\r\n\r\n// File: contracts/BaseDisputer.sol\r\n\r\n/**\r\n * Shared code between real disputer and mock disputer, to make test coverage\r\n * better.\r\n */\r\ncontract BaseDisputer is IDisputer {\r\n  address public m_owner;\r\n  address public m_feeReceiver = 0;\r\n  DisputerParams.Params public m_params;\r\n  IERC20 public m_rep;\r\n  IERC20 public m_disputeToken;\r\n\r\n  /**\r\n   * As much as we can do during dispute, without actually interacting\r\n   * with Augur\r\n   */\r\n  function dispute(address feeReceiver) external {\r\n    require(m_feeReceiver == 0, \"Can only dispute once\");\r\n    preDisputeCheck();\r\n    require(feeReceiver != 0, \"Must have valid fee receiver\");\r\n    m_feeReceiver = feeReceiver;\r\n\r\n    IERC20 rep = getREP();\r\n    uint256 initialREPBalance = rep.balanceOf(this);\r\n    IERC20 disputeToken = disputeImpl();\r\n    uint256 finalREPBalance = rep.balanceOf(this);\r\n    m_disputeToken = disputeToken;\r\n    uint256 finalDisputeTokenBalance = disputeToken.balanceOf(this);\r\n    assert(finalREPBalance + finalDisputeTokenBalance >= initialREPBalance);\r\n  }\r\n\r\n  // intentionally can be called by anyone, as no user input is used\r\n  function approveManagerToSpendDisputeTokens() external {\r\n    IERC20 disputeTokenAddress = getDisputeTokenAddress();\r\n    require(disputeTokenAddress.approve(m_owner, 2 ** 256 - 1));\r\n  }\r\n\r\n  function getOwner() external view returns(address) {\r\n    return m_owner;\r\n  }\r\n\r\n  function hasDisputed() external view returns(bool) {\r\n    return m_feeReceiver != 0;\r\n  }\r\n\r\n  function feeReceiver() external view returns(address) {\r\n    require(m_feeReceiver != 0);\r\n    return m_feeReceiver;\r\n  }\r\n\r\n  function getREP() public view returns(IERC20) {\r\n    return m_rep;\r\n  }\r\n\r\n  function getDisputeTokenAddress() public view returns(IERC20) {\r\n    require(m_disputeToken != IERC20(address(this)));\r\n    return m_disputeToken;\r\n  }\r\n\r\n  function getREPImpl() internal view returns(IERC20);\r\n  function disputeImpl() internal returns(IERC20 disputeToken);\r\n  function preDisputeCheck() internal;\r\n\r\n  // it is ESSENTIAL that this function is kept internal\r\n  // otherwise it can allow taking over ownership\r\n  function baseInit(\r\n    address owner,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) internal {\r\n    m_owner = owner;\r\n    m_params = DisputerParams.Params(\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n    // we remember REP address with which we were created to persist\r\n    // through forks and not break\r\n    m_rep = getREPImpl();\r\n    assert(m_rep.approve(m_owner, 2 ** 256 - 1));\r\n\r\n    if (address(market) != 0) {\r\n      // this is a hack. Some tests create disputer with 0 as market address\r\n      // however mock ERC20 won't like approving 0 address\r\n      // so we skip approval in those cases\r\n      // TODO: fix those tests and remove conditional here\r\n      assert(m_rep.approve(market, 2 ** 256 - 1));\r\n    }\r\n\r\n    // micro gas optimization, initialize with non-zero to make it cheaper\r\n    // to write during dispute\r\n    m_disputeToken = IERC20(address(this));\r\n  }\r\n}\r\n\r\n// File: contracts/Disputer.sol\r\n\r\n/**\r\n * Only the code that really interacts with Augur should be place here,\r\n * the rest goes into BaseDisputer for better testability.\r\n */\r\ncontract Disputer is BaseDisputer {\r\n  uint256 public m_windowStart;\r\n  uint256 public m_windowEnd;\r\n  bytes32 public m_payoutDistributionHash;\r\n  uint256 public m_roundNumber;\r\n\r\n  // we will keep track of all contributions made so far\r\n  uint256 public m_cumulativeDisputeStake;\r\n  uint256 public m_cumulativeDisputeStakeInOurOutcome;\r\n  uint256 public m_cumulativeRoundsProcessed;\r\n\r\n  constructor(\r\n    address owner,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) public {\r\n    if (address(market) == 0) {\r\n      // needed for easier instantiation for tests, etc.\r\n      // this will be a _very_ crappy uninitialized instance of Disputer\r\n      return;\r\n    }\r\n\r\n    baseInit(owner, market, feeWindowId, payoutNumerators, invalid);\r\n\r\n    Universe universe = market.getUniverse();\r\n    uint256 disputeRoundDuration = universe.getDisputeRoundDurationInSeconds();\r\n    m_windowStart = feeWindowId * disputeRoundDuration;\r\n    m_windowEnd = (feeWindowId + 1) * disputeRoundDuration;\r\n\r\n    m_payoutDistributionHash = market.derivePayoutDistributionHash(\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n\r\n    m_roundNumber = inferRoundNumber();\r\n\r\n    processCumulativeRounds();\r\n  }\r\n\r\n  function inferRoundNumber() public view returns(uint256) {\r\n    Market market = m_params.market;\r\n    Universe universe = market.getUniverse();\r\n    require(!universe.isForking());\r\n\r\n    FeeWindow feeWindow = m_params.market.getFeeWindow();\r\n    require(\r\n      address(feeWindow) != 0,\r\n      \"magic of choosing round number by timestamp only works during disputing\"\r\n    );\r\n    // once there is a fee window, it always corresponds to next round\r\n    uint256 nextParticipant = market.getNumParticipants();\r\n    uint256 disputeRoundDuration = universe.getDisputeRoundDurationInSeconds();\r\n    uint256 nextParticipantFeeWindowStart = feeWindow.getStartTime();\r\n    require(m_windowStart >= nextParticipantFeeWindowStart);\r\n    uint256 feeWindowDifferenceSeconds = m_windowStart - nextParticipantFeeWindowStart;\r\n    require(feeWindowDifferenceSeconds % disputeRoundDuration == 0);\r\n    uint256 feeWindowDifferenceRounds = feeWindowDifferenceSeconds / disputeRoundDuration;\r\n    return nextParticipant + feeWindowDifferenceRounds;\r\n  }\r\n\r\n  // anyone can call this to keep disputer up to date w.r.t. latest rounds sizes\r\n  function processCumulativeRounds() public {\r\n    Market market = m_params.market;\r\n    require(!market.isFinalized());\r\n    uint256 numParticipants = market.getNumParticipants();\r\n\r\n    while (m_cumulativeRoundsProcessed < numParticipants && m_cumulativeRoundsProcessed < m_roundNumber) {\r\n      ReportingParticipant participant = market.getReportingParticipant(\r\n        m_cumulativeRoundsProcessed\r\n      );\r\n      uint256 stake = participant.getStake();\r\n      m_cumulativeDisputeStake += stake;\r\n      if (participant.getPayoutDistributionHash() == m_payoutDistributionHash) {\r\n        m_cumulativeDisputeStakeInOurOutcome += stake;\r\n      }\r\n      ++m_cumulativeRoundsProcessed;\r\n    }\r\n  }\r\n\r\n  function shouldProcessCumulativeRounds() public view returns(bool) {\r\n    Market market = m_params.market;\r\n    require(!market.isFinalized());\r\n    uint256 numParticipants = market.getNumParticipants();\r\n    return m_cumulativeRoundsProcessed < m_roundNumber && m_cumulativeRoundsProcessed < numParticipants;\r\n  }\r\n\r\n  function preDisputeCheck() internal {\r\n    // most frequent reasons for failure, to fail early and save gas\r\n    // solhint-disable-next-line not-rely-on-time\r\n    require(block.timestamp > m_windowStart && block.timestamp < m_windowEnd);\r\n  }\r\n\r\n  /**\r\n   * This function should use as little gas as possible, as it will be called\r\n   * during rush time. Unnecessary operations are postponed for later.\r\n   *\r\n   * Can only be called once.\r\n   */\r\n  function disputeImpl() internal returns(IERC20) {\r\n    if (m_cumulativeRoundsProcessed < m_roundNumber) {\r\n      // hopefully we won't need it, we should prepare contract a few days\r\n      // before time T\r\n      processCumulativeRounds();\r\n    }\r\n\r\n    Market market = m_params.market;\r\n\r\n    // don't waste gas on safe math\r\n    uint256 roundSizeMinusOne = 2 * m_cumulativeDisputeStake - 3 * m_cumulativeDisputeStakeInOurOutcome - 1;\r\n\r\n    ReportingParticipant crowdsourcerBefore = market.getCrowdsourcer(\r\n      m_payoutDistributionHash\r\n    );\r\n    uint256 alreadyContributed = address(\r\n      crowdsourcerBefore\r\n    ) == 0 ? 0 : crowdsourcerBefore.getStake();\r\n\r\n    require(alreadyContributed < roundSizeMinusOne, \"We are too late\");\r\n\r\n    uint256 optimalContributionSize = roundSizeMinusOne - alreadyContributed;\r\n    uint256 ourBalance = getREP().balanceOf(this);\r\n\r\n    require(\r\n      market.contribute(\r\n        m_params.payoutNumerators,\r\n        m_params.invalid,\r\n        ourBalance > optimalContributionSize ? optimalContributionSize : ourBalance\r\n      )\r\n    );\r\n\r\n    if (market.getNumParticipants() == m_roundNumber) {\r\n      // we are still within current round\r\n      return market.getCrowdsourcer(m_payoutDistributionHash);\r\n    } else {\r\n      // We somehow overfilled the round. This sucks, but let's try to recover.\r\n      ReportingParticipant participant = market.getWinningReportingParticipant(\r\n\r\n      );\r\n      require(\r\n        participant.getPayoutDistributionHash() == m_payoutDistributionHash,\r\n        \"Wrong winning participant?\"\r\n      );\r\n      return IERC20(address(participant));\r\n    }\r\n  }\r\n\r\n  function getREPImpl() internal view returns(IERC20) {\r\n    return m_params.market.getReputationToken();\r\n  }\r\n}\r\n\r\n// File: contracts/DisputerFactory.sol\r\n\r\ncontract DisputerFactory is IDisputerFactory {\r\n  function create(\r\n    address owner,\r\n    Market market,\r\n    uint256 feeWindowId,\r\n    uint256[] payoutNumerators,\r\n    bool invalid\r\n  ) external returns(IDisputer) {\r\n    IDisputer _address = new Disputer(\r\n      owner,\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n    emit DisputerCreated(\r\n      owner,\r\n      _address,\r\n      market,\r\n      feeWindowId,\r\n      payoutNumerators,\r\n      invalid\r\n    );\r\n    return _address;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"market\",\"type\":\"address\"},{\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"name\":\"invalid\",\"type\":\"bool\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"market\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"feeWindowId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payoutNumerators\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"invalid\",\"type\":\"bool\"}],\"name\":\"DisputerCreated\",\"type\":\"event\"}]","ContractName":"DisputerFactory","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://d9b1f76acae0d846b1e2b19a9579b7e862fbdcc61980217ced1493b7f4ac46e5"}]}