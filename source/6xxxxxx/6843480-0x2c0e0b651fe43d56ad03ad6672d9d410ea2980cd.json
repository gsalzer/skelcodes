{"status":"1","message":"OK","result":[{"SourceCode":"library SafeMath8 {\r\n\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint8 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint8 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath16 {\r\n\r\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint16 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        uint16 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint16 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeConvert {\r\n\r\n    function toUint8(uint256 _value) internal pure returns (uint8) {\r\n        assert(_value <= 255);\r\n        return uint8(_value);\r\n    }\r\n\r\n    function toUint16(uint256 _value) internal pure returns (uint16) {\r\n        assert(_value <= 2**16 - 1);\r\n        return uint16(_value);\r\n    }\r\n\r\n    function toUint32(uint256 _value) internal pure returns (uint32) {\r\n        assert(_value <= 2**32 - 1);\r\n        return uint32(_value);\r\n    }\r\n}\r\n\r\ncontract DragonStorage {\r\n    function getGenome(uint256) external view returns (uint256[4]);\r\n}\r\n\r\ncontract Parser {\r\n    using SafeMath8 for uint8;\r\n    using SafeMath256 for uint256;\r\n\r\n    using SafeConvert for uint256;\r\n    \r\n    DragonStorage _storage_ = DragonStorage(0x960f401AED58668ef476eF02B2A2D43B83C261D8);\r\n\r\n    function _getIndexAndFactor(uint8 _counter) internal pure returns (uint8 index, uint8 factor) {\r\n        if (_counter < 44) index = 0;\r\n        else if (_counter < 88) index = 1;\r\n        else if (_counter < 132) index = 2;\r\n        else index = 3;\r\n        factor = _counter.add(1) % 4 == 0 ? 10 : 100;\r\n    }\r\n\r\n    function getParsedGenome(uint256 _id) external view returns (uint8[16][10] parsed) {\r\n        uint256[4] memory _composed = _storage_.getGenome(_id);\r\n        uint8 counter = 160; // 40 genes with 4 values in each one\r\n        uint8 _factor;\r\n        uint8 _index;\r\n\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            for (uint8 j = 0; j < 16; j++) {\r\n                counter = counter.sub(1);\r\n                // _index - index of value in genome array where current gene is stored\r\n                // _factor - denominator that determines the number of digits\r\n                (_index, _factor) = _getIndexAndFactor(counter);\r\n                parsed[9 - i][15 - j] = (_composed[_index] % _factor).toUint8();\r\n                _composed[_index] /= _factor;\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getParsedGenome\",\"outputs\":[{\"name\":\"parsed\",\"type\":\"uint8[16][10]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"Parser","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"500","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4201b45a9560ac251c29bd1ede7a21dd5d9e4ea79dad70ea2e2accac6657b6e5"}]}