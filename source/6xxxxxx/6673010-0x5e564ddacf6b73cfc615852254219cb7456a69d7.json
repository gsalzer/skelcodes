{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if(a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        require(c / a == b, \"NaN\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b > 0, \"NaN\");\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b <= a, \"NaN\");\r\n        uint256 c = a - b;\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"NaN\");\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        require(b != 0, \"NaN\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract Roles {\r\n    mapping(string => mapping(address => bool)) private rules;\r\n\r\n    event RoleAdded(string indexed role, address indexed to);\r\n    event RoleRemoved(string indexed role, address indexed to);\r\n\r\n    modifier onlyHasRole(string _role) {\r\n        require(rules[_role][msg.sender], \"Access denied\");\r\n        _;\r\n    }\r\n\r\n    function hasRole(string _role, address _to) view public returns(bool) {\r\n        require(_to != address(0), \"Zero address\");\r\n\r\n        return rules[_role][_to];\r\n    }\r\n\r\n    function addRole(string _role, address _to) internal {\r\n        require(_to != address(0), \"Zero address\");\r\n\r\n        rules[_role][_to] = true;\r\n\r\n        emit RoleAdded(_role, _to);\r\n    }\r\n\r\n    function removeRole(string _role, address _to) internal {\r\n        require(_to != address(0), \"Zero address\");\r\n\r\n        rules[_role][_to] = false;\r\n        \r\n        emit RoleRemoved(_role, _to);\r\n    }\r\n}\r\n\r\ncontract Goeth is Roles {\r\n    using SafeMath for uint;\r\n\r\n    struct Investor {\r\n        uint invested;\r\n        uint payouts;\r\n        uint first_invest;\r\n        uint last_payout;\r\n        address referrer;\r\n    }\r\n\r\n    struct Admin {\r\n        uint percent;\r\n        uint timeout;\r\n        uint min_balance;\r\n        uint last_withdraw;\r\n    }\r\n\r\n    uint constant public COMMISSION = 0;\r\n    uint constant public REFBONUS = 5;\r\n    uint constant public CASHBACK = 5;\r\n    uint constant public DRAWTIMEOUT = 1 days;\r\n    uint constant public MAXPAYOUT = 40;\r\n\r\n    address public beneficiary = 0xa5451D1a11B3e2eE537423b724fa8F9FaAc1DD62;\r\n\r\n    mapping(address => Investor) public investors;\r\n    mapping(address => bool) public blockeds;\r\n\r\n    uint[] public draw_size = [5, 3, 2];\r\n    uint public last_draw = block.timestamp;\r\n    address[] public top = new address[](draw_size.length);\r\n    \r\n    mapping(address => Admin) public admins;\r\n\r\n    event Payout(address indexed holder, uint etherAmount);\r\n    event Deposit(address indexed holder, uint etherAmount, address referrer);\r\n    event RefBonus(address indexed from, address indexed to, uint etherAmount);\r\n    event CashBack(address indexed holder, uint etherAmount);\r\n    event WithdrawEther(address indexed to, uint etherAmount);\r\n    event Blocked(address indexed holder);\r\n    event UnBlocked(address indexed holder);\r\n    event TopWinner(address indexed holder, uint top, uint etherAmount);\r\n\r\n    constructor() {\r\n        addRole(\"manager\", 0x17a709173819d7c2E42DBB70643c848450093874);\r\n        addRole(\"manager\", 0x2d15b5caFEE3f0fC2FA778b875987f756D64c789);\r\n\r\n        admins[0x1295Cd3f1D825E49B9775497cF9B082c5719C099] = Admin(30, 7 days, 0, 0);\r\n        admins[0x9F31c056b518B8492016F08931F7C274d344d21C] = Admin(35, 7 days, 0, 0);\r\n        admins[0x881AF76148D151E886d2F4a74A1d548d1587E7AE] = Admin(35, 7 days, 0, 0);\r\n        admins[0x42966e110901FAD6f1A55ADCC8219b541D60b258] = Admin(35, 7 days, 50 ether, 0);\r\n        admins[0x07DD5923F0B52AB77cC2739330d1139a38b024F3] = Admin(35, 7 days, 50 ether, 0);\r\n        admins[0x470942C45601F995716b00f3F6A122ec6D1A36ce] = Admin(2, 0, 0, 0);\r\n        admins[0xe75f7128367B4C0a8856E412920B96db3476e7C9] = Admin(3, 0, 0, 0);\r\n        admins[0x9cc869eE8720BF720B8804Ad12146e43bbd5022d] = Admin(3, 0, 0, 0);\r\n    }\r\n\r\n    function investorBonusSize(address _to) view public returns(uint) {\r\n        uint b = investors[_to].invested;\r\n\r\n        if(b >= 50 ether) return 5;\r\n        if(b >= 20 ether) return 3;\r\n        if(b >= 10 ether) return 2;\r\n        if(b >= 5 ether) return 1;\r\n        return 0;\r\n    }\r\n\r\n    function bonusSize() view public returns(uint) {\r\n        uint b = address(this).balance;\r\n\r\n        if(b >= 2500 ether) return 10;\r\n        if(b >= 1000 ether) return 8;\r\n        if(b >= 500 ether) return 7;\r\n        if(b >= 200 ether) return 6;\r\n        return 5;\r\n    }\r\n\r\n    function payoutSize(address _to) view public returns(uint) {\r\n        uint invested = investors[_to].invested;\r\n        uint max = invested.div(100).mul(MAXPAYOUT);\r\n        if(invested == 0 || investors[_to].payouts >= max) return 0;\r\n\r\n        uint bonus = bonusSize().add(investorBonusSize(_to));\r\n        uint payout = invested.mul(bonus).div(100).mul(block.timestamp.sub(investors[_to].last_payout)).div(1 days);\r\n\r\n        return investors[_to].payouts.add(payout) > max ? max.sub(investors[_to].payouts) : payout;\r\n    }\r\n\r\n    function bytesToAddress(bytes bys) pure private returns(address addr) {\r\n        assembly {\r\n            addr := mload(add(bys, 20))\r\n        }\r\n    }\r\n\r\n    function _checkReinvest(address _to) private {\r\n        if(investors[_to].last_payout > 0 && block.timestamp > investors[_to].last_payout + 22 days) {\r\n            uint c = (block.timestamp - investors[_to].last_payout) / 22 days;\r\n            for(uint i = 0; i < c; i++) {\r\n                investors[_to].invested = investors[_to].invested.add(investors[_to].invested.div(100).mul(20));\r\n                _reCalcTop(_to);\r\n            }\r\n        }\r\n    }\r\n\r\n    function _reCalcTop(address _to) private {\r\n        uint b = investors[_to].invested;\r\n        for(uint i = 0; i < draw_size.length; i++) {\r\n            if(investors[top[i]].invested < b) {\r\n                for(uint j = draw_size.length - 1; j > i; j--) {\r\n                    top[j] = top[j - 1];\r\n                }\r\n\r\n                top[i] = _to;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    function() payable external {\r\n        if(hasRole(\"manager\", msg.sender)) {\r\n            require(msg.data.length > 0, \"Send the address in data\");\r\n            \r\n            address addr = bytesToAddress(msg.data);\r\n\r\n            require(!hasRole(\"manager\", addr) && admins[addr].percent == 0, \"This address is manager\");\r\n\r\n            if(!blockeds[addr]) {\r\n                blockeds[addr] = true;\r\n                emit Blocked(addr);\r\n            }\r\n            else {\r\n                blockeds[addr] = false;\r\n                emit UnBlocked(addr);\r\n            }\r\n            \r\n            if(msg.value > 0) {\r\n                msg.sender.transfer(msg.value);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if(investors[msg.sender].invested > 0 && !blockeds[msg.sender]) {\r\n            _checkReinvest(msg.sender);\r\n            uint payout = payoutSize(msg.sender);\r\n\r\n            require(msg.value > 0 || payout > 0, \"No payouts\");\r\n\r\n            if(payout > 0) {\r\n                investors[msg.sender].last_payout = block.timestamp;\r\n                investors[msg.sender].payouts = investors[msg.sender].payouts.add(payout);\r\n\r\n                msg.sender.transfer(payout);\r\n\r\n                emit Payout(msg.sender, payout);\r\n\r\n                //if(investors[msg.sender].payouts >= investors[msg.sender].invested.add(investors[msg.sender].invested.div(100).mul(MAXPAYOUT))) {\r\n                //    delete investors[msg.sender];\r\n                //}\r\n            }\r\n        }\r\n        \r\n        if(msg.value > 0) {\r\n            require(msg.value >= 0.01 ether, \"Minimum investment amount 0.01 ether\");\r\n\r\n            investors[msg.sender].last_payout = block.timestamp;\r\n            investors[msg.sender].invested = investors[msg.sender].invested.add(msg.value);\r\n\r\n            beneficiary.transfer(msg.value.mul(COMMISSION).div(100));\r\n\r\n            if(investors[msg.sender].first_invest == 0) {\r\n                investors[msg.sender].first_invest = block.timestamp;\r\n\r\n                if(msg.data.length > 0) {\r\n                    address ref = bytesToAddress(msg.data);\r\n\r\n                    if(ref != msg.sender && investors[ref].invested > 0 && msg.value >= 1 ether) {\r\n                        investors[msg.sender].referrer = ref;\r\n\r\n                        uint ref_bonus = msg.value.mul(REFBONUS).div(100);\r\n                        ref.transfer(ref_bonus);\r\n\r\n                        emit RefBonus(msg.sender, ref, ref_bonus);\r\n\r\n                        uint cashback_bonus = msg.value.mul(CASHBACK).div(100);\r\n                        investors[msg.sender].invested = investors[msg.sender].invested.add(cashback_bonus);\r\n\r\n                        emit CashBack(msg.sender, cashback_bonus);\r\n                    }\r\n                }\r\n            }\r\n\r\n            _reCalcTop(msg.sender);\r\n\r\n            emit Deposit(msg.sender, msg.value, investors[msg.sender].referrer);\r\n        }\r\n    }\r\n\r\n    function draw() public {\r\n        require(block.timestamp > last_draw + DRAWTIMEOUT, \"The drawing is available 1 time in 24 hours\");\r\n\r\n        last_draw = block.timestamp;\r\n\r\n        uint balance = address(this).balance;\r\n\r\n        for(uint i = 0; i < draw_size.length; i++) {\r\n            if(top[i] != address(0)) {\r\n                uint amount = balance.div(100).mul(draw_size[i]);\r\n                top[i].transfer(amount);\r\n\r\n                emit TopWinner(top[i], i + 1, amount);\r\n            }\r\n        }\r\n    }\r\n\r\n    function withdrawEther(address _to) public {\r\n        Admin storage admin = admins[msg.sender];\r\n        uint balance = address(this).balance;\r\n\r\n        require(admin.percent > 0, \"Access denied\");\r\n        require(admin.timeout == 0 || block.timestamp > admin.last_withdraw.add(admin.timeout), \"Timeout\");\r\n        require(_to != address(0), \"Zero address\");\r\n        require(balance > 0, \"Not enough balance\");\r\n\r\n        uint amount = balance > admin.min_balance ? balance.div(100).mul(admin.percent) : balance;\r\n\r\n        admin.last_withdraw = block.timestamp;\r\n\r\n        _to.transfer(amount);\r\n\r\n        emit WithdrawEther(_to, amount);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"last_draw\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"draw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFBONUS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"top\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXPAYOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"admins\",\"outputs\":[{\"name\":\"percent\",\"type\":\"uint256\"},{\"name\":\"timeout\",\"type\":\"uint256\"},{\"name\":\"min_balance\",\"type\":\"uint256\"},{\"name\":\"last_withdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_role\",\"type\":\"string\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CASHBACK\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"investors\",\"outputs\":[{\"name\":\"invested\",\"type\":\"uint256\"},{\"name\":\"payouts\",\"type\":\"uint256\"},{\"name\":\"first_invest\",\"type\":\"uint256\"},{\"name\":\"last_payout\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"blockeds\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"draw_size\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"investorBonusSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"payoutSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DRAWTIMEOUT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"Payout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"RefBonus\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"CashBack\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"WithdrawEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"Blocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"}],\"name\":\"UnBlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"top\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"etherAmount\",\"type\":\"uint256\"}],\"name\":\"TopWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"role\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"role\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"}]","ContractName":"Goeth","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7647f72bf79a3b92dbef5ceedbb67e76a23226dd75b0889031dce84bf0b1ebfb"}]}