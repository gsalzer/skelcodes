{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n/******************************************************************************\\\r\n* Author: Nick Mudge, nick@mokens.io\r\n* Mokens\r\n* Copyright (c) 2018\r\n*\r\n* Implements ERC998ERC20TopDown.\r\n/******************************************************************************/\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Storage contracts\r\n////////////\r\n//Some delegate contracts are listed with storage contracts they inherit.\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Mokens\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage0 {\r\n    // funcId => delegate contract\r\n    mapping(bytes4 => address) internal delegates;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenUpdates\r\n//MokenOwner\r\n//QueryMokenDelegates\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage1 is Storage0 {\r\n    address internal contractOwner;\r\n    bytes[] internal funcSignatures;\r\n    // signature => index+1\r\n    mapping(bytes => uint256) internal funcSignatureToIndex;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokensSupportsInterfaces\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage2 is Storage1 {\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenRootOwnerOf\r\n//MokenERC721Metadata\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage3 is Storage2 {\r\n    struct Moken {\r\n        string name;\r\n        uint256 data;\r\n        uint256 parentTokenId;\r\n    }\r\n    //tokenId => moken\r\n    mapping(uint256 => Moken) internal mokens;\r\n    uint256 internal mokensLength;\r\n    // child address => child tokenId => tokenId+1\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC721Enumerable\r\n//MokenLinkHash\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage4 is Storage3 {\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) internal ownedTokens;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC721TopDown\r\n//MokenERC998ERC721TopDownBatch\r\n//MokenERC721\r\n//MokenERC721Batch\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage5 is Storage4 {\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n    // tokenId => (child address => (child token => child index)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n    // tokenId => (child address => contract index)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC20TopDown\r\n//MokenStateChange\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage6 is Storage5 {\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) internal erc20Contracts;\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\r\n}\r\n\r\ncontract RootOwnerOfHelper is Storage3 {\r\n\r\n    bytes32 constant ERC998_MAGIC_VALUE = 0xcd740db5;\r\n\r\n    // Use Cases handled:\r\n    // Case 1: Token owner is this contract and token\r\n    // Case 2: Token owner is this contract and top-down composable.\r\n    // Case 3: Token owner is top-down composable\r\n    // Case 4: Token owner is an unknown contract\r\n    // Case 5: Token owner is a user\r\n    // Case 6: Token owner is a bottom-up composable\r\n    // Case 7: Token owner is ERC721 token owned by top-down token\r\n    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n    // Case 9: Token owner is ERC721 token owned by user\r\n    function rootOwnerOf_(uint256 _tokenId) internal view returns (bytes32 rootOwner) {\r\n        address rootOwnerAddress = address(mokens[_tokenId].data);\r\n        require(rootOwnerAddress != address(0), \"tokenId not found.\");\r\n        uint256 parentTokenId;\r\n        bool isParent;\r\n\r\n        while (rootOwnerAddress == address(this)) {\r\n            parentTokenId = mokens[_tokenId].parentTokenId;\r\n            isParent = parentTokenId > 0;\r\n            if (isParent) {\r\n                // Case 1: Token owner is this contract and token\r\n                _tokenId = parentTokenId - 1;\r\n            }\r\n            else {\r\n                // Case 2: Token owner is this contract and top-down composable.\r\n                _tokenId = childTokenOwner[rootOwnerAddress][_tokenId] - 1;\r\n            }\r\n            rootOwnerAddress = address(mokens[_tokenId].data);\r\n        }\r\n\r\n        parentTokenId = mokens[_tokenId].parentTokenId;\r\n        isParent = parentTokenId > 0;\r\n        if (isParent) {\r\n            parentTokenId--;\r\n        }\r\n\r\n        bytes memory calldata;\r\n        bool callSuccess;\r\n\r\n        if (isParent == false) {\r\n\r\n            // success if this token is owned by a top-down token\r\n            // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n            calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 3: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // Case 4: Token owner is an unknown contract\r\n                // Or\r\n                // Case 5: Token owner is a user\r\n                return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n            }\r\n        }\r\n        else {\r\n\r\n            // 0x43a61a8e == rootOwnerOf(uint256)\r\n            calldata = abi.encodeWithSelector(0x43a61a8e, parentTokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 6: Token owner is a bottom-up composable\r\n                // Or\r\n                // Case 2: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // token owner is ERC721\r\n                address childContract = rootOwnerAddress;\r\n                //0x6352211e == \"ownerOf(uint256)\"\r\n                calldata = abi.encodeWithSelector(0x6352211e, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwnerAddress := mload(calldata)\r\n                    }\r\n                }\r\n                require(callSuccess, \"Call to ownerOf failed\");\r\n\r\n                // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n                calldata = abi.encodeWithSelector(0xed81cdda, childContract, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwner := mload(calldata)\r\n                    }\r\n                }\r\n                if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                    // Case 7: Token owner is ERC721 token owned by top-down token\r\n                    return rootOwner;\r\n                }\r\n                else {\r\n                    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n                    // Or\r\n                    // Case 9: Token owner is ERC721 token owned by user\r\n                    return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ninterface ERC20AndERC223 {\r\n    function transferFrom(address _from, address _to, uint _value) external returns (bool success);\r\n    function transfer(address _to, uint _value) external returns (bool success);\r\n    function transfer(address _to, uint _value, bytes data) external returns (bool success);\r\n}\r\n\r\ncontract MokenERC998ERC20TopDown is Storage6, RootOwnerOfHelper {\r\n\r\n    event ReceivedERC20(address indexed from, uint256 indexed tokenId, address indexed erc20Contract, uint256 value);\r\n    event TransferERC20(uint256 indexed tokenId, address indexed to, address indexed erc20Contract, uint256 value);\r\n\r\n    function removeERC20(uint256 _tokenId, address _erc20Contract, uint256 _value) internal {\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract];\r\n        require(erc20Balance >= _value, \"Not enough token available to transfer.\");\r\n        uint256 newERC20Balance = erc20Balance - _value;\r\n        erc20Balances[_tokenId][_erc20Contract] = newERC20Balance;\r\n        if (newERC20Balance == 0) {\r\n            uint256 lastContractIndex = erc20Contracts[_tokenId].length - 1;\r\n            address lastContract = erc20Contracts[_tokenId][lastContractIndex];\r\n            if (_erc20Contract != lastContract) {\r\n                uint256 contractIndex = erc20ContractIndex[_tokenId][_erc20Contract];\r\n                erc20Contracts[_tokenId][contractIndex] = lastContract;\r\n                erc20ContractIndex[_tokenId][lastContract] = contractIndex;\r\n            }\r\n            erc20Contracts[_tokenId].length--;\r\n            delete erc20ContractIndex[_tokenId][_erc20Contract];\r\n        }\r\n    }\r\n\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(addr)}\r\n        return size > 0;\r\n    }\r\n\r\n    function transferERC20(uint256 _tokenId, address _to, address _erc20Contract, uint256 _value) external {\r\n        address rootOwner = address(rootOwnerOf_(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        require(_to != address(0), \"_to cannot be 0 address\");\r\n        removeERC20(_tokenId, _erc20Contract, _value);\r\n        require(ERC20AndERC223(_erc20Contract).transfer(_to, _value), \"ERC20 transfer failed.\");\r\n        emit TransferERC20(_tokenId, _to, _erc20Contract, _value);\r\n    }\r\n\r\n    // implementation of ERC 223\r\n    function transferERC223(uint256 _tokenId, address _to, address _erc223Contract, uint256 _value, bytes _data) external {\r\n        address rootOwner = address(rootOwnerOf_(_tokenId));\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId] == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n        require(_to != address(0), \"_to cannot be 0 address\");\r\n        removeERC20(_tokenId, _erc223Contract, _value);\r\n        require(ERC20AndERC223(_erc223Contract).transfer(_to, _value, _data), \"ERC223 transfer failed.\");\r\n        emit TransferERC20(_tokenId, _to, _erc223Contract, _value);\r\n    }\r\n\r\n    // this contract has to be approved first by _erc20Contract\r\n    function getERC20(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) public {\r\n        bool allowed = _from == msg.sender;\r\n        if (!allowed) {\r\n            uint256 remaining;\r\n            // 0xdd62ed3e == allowance(address,address)\r\n            bytes memory calldata = abi.encodeWithSelector(0xdd62ed3e, _from, msg.sender);\r\n            bool callSuccess;\r\n            assembly {\r\n                callSuccess := staticcall(gas, _erc20Contract, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    remaining := mload(calldata)\r\n                }\r\n            }\r\n            require(callSuccess, \"call to allowance failed\");\r\n            require(remaining >= _value, \"Value greater than remaining\");\r\n            allowed = true;\r\n        }\r\n        require(allowed, \"msg.sender not _from and has no allowance.\");\r\n        erc20Received(_from, _tokenId, _erc20Contract, _value);\r\n        require(ERC20AndERC223(_erc20Contract).transferFrom(_from, this, _value), \"ERC20 transfer failed.\");\r\n    }\r\n\r\n    function erc20Received(address _from, uint256 _tokenId, address _erc20Contract, uint256 _value) internal {\r\n        require(address(mokens[_tokenId].data) != address(0), \"_tokenId does not exist.\");\r\n        if (_value == 0) {\r\n            return;\r\n        }\r\n        uint256 erc20Balance = erc20Balances[_tokenId][_erc20Contract];\r\n        if (erc20Balance == 0) {\r\n            erc20ContractIndex[_tokenId][_erc20Contract] = erc20Contracts[_tokenId].length;\r\n            erc20Contracts[_tokenId].push(_erc20Contract);\r\n        }\r\n        erc20Balances[_tokenId][_erc20Contract] += _value;\r\n        emit ReceivedERC20(_from, _tokenId, _erc20Contract, _value);\r\n    }\r\n\r\n    // used by ERC 223\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) external {\r\n        require(_data.length > 0, \"_data must contain the uint256 tokenId to transfer the token to.\");\r\n        require(isContract(msg.sender), \"msg.sender is not a contract\");\r\n        // convert up to 32 bytes of_data to uint256, owner nft tokenId passed as uint in bytes\r\n        uint256 tokenId;\r\n        assembly {\r\n            tokenId := calldataload(132)\r\n        }\r\n        if (_data.length < 32) {\r\n            tokenId = tokenId >> 256 - _data.length * 8;\r\n        }\r\n        //END TODO\r\n        erc20Received(_from, tokenId, msg.sender, _value);\r\n    }\r\n\r\n    function balanceOfERC20(uint256 _tokenId, address _erc20Contract) external view returns (uint256) {\r\n        return erc20Balances[_tokenId][_erc20Contract];\r\n    }\r\n\r\n    function erc20ContractByIndex(uint256 _tokenId, uint256 _index) external view returns (address) {\r\n        require(_index < erc20Contracts[_tokenId].length, \"Contract address does not exist for this token and index.\");\r\n        return erc20Contracts[_tokenId][_index];\r\n    }\r\n\r\n    function totalERC20Contracts(uint256 _tokenId) external view returns (uint256) {\r\n        return erc20Contracts[_tokenId].length;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"getERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"erc20ContractByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferERC20\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"totalERC20Contracts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_erc223Contract\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferERC223\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_erc20Contract\",\"type\":\"address\"}],\"name\":\"balanceOfERC20\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReceivedERC20\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"erc20Contract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"TransferERC20\",\"type\":\"event\"}]","ContractName":"MokenERC998ERC20TopDown","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://680e0a557785a36b0080f3da49b5adbc60f775cc18bd899b39af6b8603485891"}]}