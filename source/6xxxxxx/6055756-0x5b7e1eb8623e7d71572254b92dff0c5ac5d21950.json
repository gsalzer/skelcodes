{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\ncontract Utils {\r\n    /**\r\n        constructor\r\n    */\r\n    function Utils() internal {\r\n    }\r\n\r\n    // validates an address - currently only checks that it isn't null\r\n    modifier validAddress(address _address) {\r\n        require(_address != 0x0);\r\n        _;\r\n    }\r\n\r\n    // verifies that the address is different than this contract address\r\n    modifier notThis(address _address) {\r\n        require(_address != address(this));\r\n        _;\r\n    }\r\n\r\n    // Overflow protected math functions\r\n\r\n    /**\r\n        @dev returns the sum of _x and _y, asserts if the calculation overflows\r\n\r\n        @param _x   value 1\r\n        @param _y   value 2\r\n\r\n        @return sum\r\n    */\r\n    function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x + _y;\r\n        assert(z >= _x);\r\n        return z;\r\n    }\r\n\r\n    /**\r\n        @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number\r\n\r\n        @param _x   minuend\r\n        @param _y   subtrahend\r\n\r\n        @return difference\r\n    */\r\n    function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        assert(_x >= _y);\r\n        return _x - _y;\r\n    }\r\n\r\n    /**\r\n        @dev returns the product of multiplying _x by _y, asserts if the calculation overflows\r\n\r\n        @param _x   factor 1\r\n        @param _y   factor 2\r\n\r\n        @return product\r\n    */\r\n    function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) {\r\n        uint256 z = _x * _y;\r\n        assert(_x == 0 || z / _x == _y);\r\n        return z;\r\n    }\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ncontract IERC20Token {\r\n    // these functions aren't abstract since the compiler emits automatically generated getter functions as external\r\n    function name() public constant returns (string) { name; }\r\n    function symbol() public constant returns (string) { symbol; }\r\n    function decimals() public constant returns (uint8) { decimals; }\r\n    function totalSupply() public constant returns (uint256) { totalSupply; }\r\n    function balanceOf(address _owner) public constant returns (uint256 balance);\r\n    function allowance(address _owner, address _spender) public constant returns (uint256 remaining);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n\r\n/*\r\n    Owned contract interface\r\n*/\r\ncontract IOwned {\r\n    // this function isn't abstract since the compiler emits automatically generated getter functions as external\r\n    function owner() public constant returns (address) { owner; }\r\n\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n}\r\n\r\n/*\r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still needs to accept the transfer\r\n        can only be called by the contract owner\r\n\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n}\r\n\r\ncontract YooStop is Owned{\r\n\r\n    bool public stopped = true;\r\n\r\n    modifier stoppable {\r\n        assert (!stopped);\r\n        _;\r\n    }\r\n    function stop() public ownerOnly{\r\n        stopped = true;\r\n    }\r\n    function start() public ownerOnly{\r\n        stopped = false;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract YoobaICO is  Owned,YooStop,Utils {\r\n    IERC20Token public yoobaTokenAddress;\r\n    uint256 public startICOTime = 0;  \r\n    uint256 public endICOTime = 0;  \r\n    uint256 public leftICOTokens = 0;\r\n    uint256 public tatalEthFromBuyer = 0;\r\n    uint256 public daysnumber = 0;\r\n    mapping (address => uint256) public pendingBalanceMap;\r\n    mapping (address => uint256) public totalBuyMap;\r\n    mapping (address => uint256) public totalBuyerETHMap;\r\n    mapping (uint256 => uint256) public daySellMap;\r\n    mapping (address => uint256) public withdrawYOOMap;\r\n    uint256 internal milestone1 = 4000000000000000000000000000;\r\n    uint256 internal milestone2 = 2500000000000000000000000000;\r\n       uint256 internal dayLimit = 300000000000000000000000000;\r\n    bool internal hasInitLeftICOTokens = false;\r\n\r\n\r\n\r\n    /**\r\n        @dev constructor\r\n        \r\n    */\r\n    function YoobaICO(IERC20Token _yoobaTokenAddress) public{\r\n         yoobaTokenAddress = _yoobaTokenAddress;\r\n    }\r\n    \r\n\r\n    function startICO(uint256 _startICOTime,uint256 _endICOTime) public ownerOnly {\r\n        startICOTime = _startICOTime;\r\n        endICOTime = _endICOTime;\r\n    }\r\n    \r\n    function initLeftICOTokens() public ownerOnly{\r\n        require(!hasInitLeftICOTokens);\r\n       leftICOTokens = yoobaTokenAddress.balanceOf(this);\r\n       hasInitLeftICOTokens = true;\r\n    }\r\n    function setLeftICOTokens(uint256 left) public ownerOnly {\r\n        leftICOTokens = left;\r\n    }\r\n    function setDaySellAmount(uint256 _dayNum,uint256 _sellAmount) public ownerOnly {\r\n        daySellMap[_dayNum] = _sellAmount;\r\n    }\r\n    \r\n    function withdrawTo(address _to, uint256 _amount) public ownerOnly notThis(_to)\r\n    {   \r\n        require(_amount <= this.balance);\r\n        _to.transfer(_amount); // send the amount to the target account\r\n    }\r\n    \r\n    function withdrawERC20TokenTo(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n\r\n    }\r\n    \r\n    function withdrawToBuyer(IERC20Token _token,address[] _to)  public ownerOnly {\r\n        require(_to.length > 0  && _to.length < 10000);\r\n        for(uint16 i = 0; i < _to.length ;i++){\r\n            if(pendingBalanceMap[_to[i]] > 0){\r\n                assert(_token.transfer(_to[i],pendingBalanceMap[_to[i]])); \r\n                withdrawYOOMap[_to[i]] = safeAdd(withdrawYOOMap[_to[i]],pendingBalanceMap[_to[i]]);\r\n                pendingBalanceMap[_to[i]] = 0;\r\n            }\r\n         \r\n        }\r\n    }\r\n    \r\n      function withdrawToBuyer(IERC20Token _token, address _to, uint256 _amount)\r\n        public\r\n        ownerOnly\r\n        validAddress(_token)\r\n        validAddress(_to)\r\n        notThis(_to)\r\n    {\r\n        assert(_token.transfer(_to, _amount));\r\n        withdrawYOOMap[_to] = safeAdd(withdrawYOOMap[_to],_amount);\r\n        pendingBalanceMap[_to] = safeSub(pendingBalanceMap[_to],_amount);\r\n\r\n    }\r\n    \r\n    function refund(address[] _to) public ownerOnly{\r\n        require(_to.length > 0  && _to.length < 10000 );\r\n        for(uint16 i = 0; i < _to.length ;i++){\r\n            if(pendingBalanceMap[_to[i]] > 0 && withdrawYOOMap[_to[i]] == 0 && totalBuyerETHMap[_to[i]] > 0 && totalBuyMap[_to[i]] > 0){\r\n                 if(totalBuyerETHMap[_to[i]] <= this.balance){\r\n                _to[i].transfer(totalBuyerETHMap[_to[i]]); \r\n                tatalEthFromBuyer = tatalEthFromBuyer - totalBuyerETHMap[_to[i]];\r\n                leftICOTokens = leftICOTokens + pendingBalanceMap[_to[i]];\r\n                totalBuyerETHMap[_to[i]] = 0;\r\n                pendingBalanceMap[_to[i]] = 0; \r\n                totalBuyMap[_to[i]] = 0;\r\n              \r\n                 }\r\n            }\r\n         \r\n        }\r\n    }\r\n  \r\n    function buyToken() internal\r\n    {\r\n        require(!stopped && now >= startICOTime && now <= endICOTime );\r\n        require(msg.value >= 0.1 ether && msg.value <= 100 ether);\r\n        \r\n        uint256  dayNum = ((now - startICOTime) / 1 days) + 1;\r\n        daysnumber = dayNum;\r\n         assert(daySellMap[dayNum] <= dayLimit);\r\n         uint256 amount = 0;\r\n        if(now < (startICOTime + 1 weeks) && leftICOTokens > milestone1){\r\n               \r\n                if(msg.value * 320000 <= (leftICOTokens - milestone1))\r\n                { \r\n                     amount = msg.value * 320000;\r\n                }else{\r\n                   uint256 priceOneEther1 =  (leftICOTokens - milestone1)/320000;\r\n                     amount = (msg.value - priceOneEther1) * 250000 + priceOneEther1 * 320000;\r\n                }\r\n        }else{\r\n           if(leftICOTokens > milestone2){\r\n                if(msg.value * 250000 <= (leftICOTokens - milestone2))\r\n                {\r\n                   amount = msg.value * 250000;\r\n                }else{\r\n                   uint256 priceOneEther2 =  (leftICOTokens - milestone2)/250000;\r\n                   amount = (msg.value - priceOneEther2) * 180000 + priceOneEther2 * 250000;\r\n                }\r\n            }else{\r\n               assert(msg.value * 180000 <= leftICOTokens);\r\n            if((leftICOTokens - msg.value * 180000) < 18000 && msg.value * 180000 <= 100 * 180000 * (10 ** 18)){\r\n                  amount = leftICOTokens;\r\n            }else{\r\n                 amount = msg.value * 180000;\r\n            }\r\n            }\r\n        }\r\n           if(amount >= 18000 * (10 ** 18) && amount <= 320000 * 100 * (10 ** 18)){\r\n              leftICOTokens = safeSub(leftICOTokens,amount);\r\n              pendingBalanceMap[msg.sender] = safeAdd(pendingBalanceMap[msg.sender], amount);\r\n              totalBuyMap[msg.sender] = safeAdd(totalBuyMap[msg.sender], amount);\r\n              daySellMap[dayNum] += amount;\r\n              totalBuyerETHMap[msg.sender] = safeAdd(totalBuyerETHMap[msg.sender],msg.value);\r\n              tatalEthFromBuyer += msg.value;\r\n              return;\r\n          }else{\r\n               revert();\r\n          }\r\n    }\r\n\r\n    function() public payable stoppable {\r\n        buyToken();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"stop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dayNum\",\"type\":\"uint256\"},{\"name\":\"_sellAmount\",\"type\":\"uint256\"}],\"name\":\"setDaySellAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"daySellMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBuyMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address[]\"}],\"name\":\"withdrawToBuyer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"totalBuyerETHMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leftICOTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawERC20TokenTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initLeftICOTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"daysnumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stopped\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startICOTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startICOTime\",\"type\":\"uint256\"},{\"name\":\"_endICOTime\",\"type\":\"uint256\"}],\"name\":\"startICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingBalanceMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endICOTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"withdrawYOOMap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tatalEthFromBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"left\",\"type\":\"uint256\"}],\"name\":\"setLeftICOTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"yoobaTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address[]\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawToBuyer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_yoobaTokenAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"YoobaICO","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000001d4105534da120da243281cfc3f26aaf038e2d6f","Library":"","SwarmSource":"bzzr://2bd6413b22a160f26cd8427fb6270566a8fc4ccf03ae1ae79d01609ec092df9e"}]}