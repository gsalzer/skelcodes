{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/ownership/MultiOwnable.sol\r\n\r\n/**\r\n * @title MultiOwnable\r\n * @dev The MultiOwnable contract has owners addresses and provides basic authorization control\r\n * functions, this simplifies the implementation of \"users permissions\".\r\n */\r\ncontract MultiOwnable {\r\n    address public manager; // address used to set owners\r\n    address[] public owners;\r\n    mapping(address => bool) public ownerByAddress;\r\n\r\n    event SetOwners(address[] owners);\r\n\r\n    modifier onlyOwner() {\r\n        require(ownerByAddress[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev MultiOwnable constructor sets the manager\r\n     */\r\n    function MultiOwnable() public {\r\n        manager = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to set owners addresses\r\n     */\r\n    function setOwners(address[] _owners) public {\r\n        require(msg.sender == manager);\r\n        _setOwners(_owners);\r\n\r\n    }\r\n\r\n    function _setOwners(address[] _owners) internal {\r\n        for(uint256 i = 0; i < owners.length; i++) {\r\n            ownerByAddress[owners[i]] = false;\r\n        }\r\n\r\n\r\n        for(uint256 j = 0; j < _owners.length; j++) {\r\n            ownerByAddress[_owners[j]] = true;\r\n        }\r\n        owners = _owners;\r\n        emit SetOwners(_owners);\r\n    }\r\n\r\n    function getOwners() public constant returns (address[]) {\r\n        return owners;\r\n    }\r\n}\r\n\r\n// File: contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function allowance(address _owner, address _spender)\r\n        public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    function approve(address _spender, uint256 _value)\r\n        public returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value)\r\n        public returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n// File: contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    uint256 totalSupply_;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    * @param _owner address The address which owns the funds.\r\n    * @param _spender address The address which will spend the funds.\r\n    * @return A uint256 specifying the amount of tokens still available for the spender.\r\n    */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n      public\r\n      view\r\n      returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances[msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = (\r\n            allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n}\r\n\r\n// File: contracts/token/ITokenEventListener.sol\r\n\r\n/**\r\n * @title ITokenEventListener\r\n * @dev Interface which should be implemented by token listener\r\n */\r\ninterface ITokenEventListener {\r\n    /**\r\n     * @dev Function is called after token transfer/transferFrom\r\n     * @param _from Sender address\r\n     * @param _to Receiver address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function onTokenTransfer(address _from, address _to, uint256 _value) external;\r\n}\r\n\r\n// File: contracts/token/ManagedToken.sol\r\n\r\n/**\r\n * @title ManagedToken\r\n * @dev ERC20 compatible token with issue and destroy facilities\r\n * @dev All transfers can be monitored by token event listener\r\n */\r\ncontract ManagedToken is StandardToken, MultiOwnable {\r\n\r\n    bool public allowTransfers = false;\r\n    bool public issuanceFinished = false;\r\n\r\n    ITokenEventListener public eventListener;\r\n\r\n    event AllowTransfersChanged(bool _newState);\r\n    event Issue(address indexed _to, uint256 _value);\r\n    event Destroy(address indexed _from, uint256 _value);\r\n    event IssuanceFinished();\r\n\r\n    modifier transfersAllowed() {\r\n        assert(allowTransfers);\r\n        _;\r\n    }\r\n\r\n    modifier canIssue() {\r\n        assert(!issuanceFinished);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev ManagedToken constructor\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owners Owners list\r\n     */\r\n    function ManagedToken(address _listener, address[] _owners) public {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        }\r\n        _setOwners(_owners);\r\n    }\r\n\r\n    /**\r\n     * @dev Enable/disable token transfers. Can be called only by owners\r\n     * @param _allowTransfers True - allow False - disable\r\n     */\r\n    function setAllowTransfers(bool _allowTransfers) external onlyOwner {\r\n        allowTransfers = _allowTransfers;\r\n        emit AllowTransfersChanged(_allowTransfers);\r\n    }\r\n\r\n    /**\r\n     * @dev Set/remove token event listener\r\n     * @param _listener Listener address (Contract must implement ITokenEventListener interface)\r\n     */\r\n    function setListener(address _listener) public onlyOwner {\r\n        if(_listener != address(0)) {\r\n            eventListener = ITokenEventListener(_listener);\r\n        } else {\r\n            delete eventListener;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Override transfer function. Add event listener condition\r\n     */\r\n    function transfer(address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transfer(_to, _value);\r\n        if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(msg.sender, _to, _value);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    /**\r\n     * @dev Override transferFrom function. Add event listener condition\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool) {\r\n        bool success = super.transferFrom(_from, _to, _value);\r\n        if(hasListener() && success) {\r\n            eventListener.onTokenTransfer(_from, _to, _value);\r\n        }\r\n        return success;\r\n    }\r\n\r\n    function hasListener() internal view returns(bool) {\r\n        if(eventListener == address(0)) {\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Issue tokens to specified wallet\r\n     * @param _to Wallet address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\r\n    }\r\n\r\n    /**\r\n     * @dev Destroy tokens on specified address (Called by owner or token holder)\r\n     * @dev Fund contract address must be in the list of owners to burn token during refund\r\n     * @param _from Wallet address\r\n     * @param _value Amount of tokens to destroy\r\n     */\r\n    function destroy(address _from, uint256 _value) external {\r\n    }\r\n    \r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From OpenZeppelin StandardToken.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Finish token issuance\r\n     * @return True if success\r\n     */\r\n    function finishIssuance() public onlyOwner {\r\n        issuanceFinished = true;\r\n        emit IssuanceFinished();\r\n    }\r\n}\r\n\r\n// File: contracts/token/TransferLimitedToken.sol\r\n\r\n/**\r\n * @title TransferLimitedToken\r\n * @dev Token with ability to limit transfers within wallets included in limitedWallets list for certain period of time\r\n */\r\ncontract TransferLimitedToken is ManagedToken {\r\n\r\n    mapping(address => bool) public limitedWallets;\r\n    address public limitedWalletsManager;\r\n    bool public isLimitEnabled;\r\n\r\n    modifier onlyManager() {\r\n        require(msg.sender == limitedWalletsManager);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Check if transfer between addresses is available\r\n     * @param _from From address\r\n     * @param _to To address\r\n     */\r\n    modifier canTransfer(address _from, address _to)  {\r\n        require(!isLimitEnabled || (!limitedWallets[_from] && !limitedWallets[_to]));\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev TransferLimitedToken constructor\r\n     * @param _listener Token listener(address can be 0x0)\r\n     * @param _owners Owners list\r\n     * @param _limitedWalletsManager Address used to add/del wallets from limitedWallets\r\n     */\r\n    function TransferLimitedToken(address _listener, address[] _owners, address _limitedWalletsManager) public\r\n        ManagedToken(_listener, _owners)\r\n    {\r\n        isLimitEnabled = true;\r\n        limitedWalletsManager = _limitedWalletsManager;\r\n    }\r\n\r\n    /**\r\n     * @dev Add address to limitedWallets\r\n     * @dev Can be called only by manager\r\n     */\r\n    function addLimitedWalletAddress(address _wallet) public onlyManager {\r\n        limitedWallets[_wallet] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Del address from limitedWallets\r\n     * @dev Can be called only by manager\r\n     */\r\n    function delLimitedWalletAddress(address _wallet) public onlyManager {\r\n        limitedWallets[_wallet] = false;\r\n    }\r\n\r\n    function isLimitedWalletAddress(address _wallet) public view returns(bool) {\r\n        return limitedWallets[_wallet];\r\n    }\r\n\r\n    /**\r\n     * @dev Enable/disable token transfers limited wallet. Can be called only by manager\r\n     * @param _setLimitEnabled True - enable limit transfer False - disable\r\n     */\r\n    function setLimitEnabled(bool _setLimitEnabled) public onlyManager {\r\n        isLimitEnabled = _setLimitEnabled;\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev Override transfer function. Add canTransfer modifier to check possibility of transferring\r\n     */\r\n    function transfer(address _to, uint256 _value) public canTransfer(msg.sender, _to) returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Override transferFrom function. Add canTransfer modifier to check possibility of transferring\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public canTransfer(_from, _to) returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Override approve function. Add canTransfer modifier to check possibility of transferring\r\n     */\r\n    function approve(address _spender, uint256 _value) public canTransfer(msg.sender, _spender) returns (bool) {\r\n        return super.approve(_spender,_value);\r\n    }\r\n}\r\n\r\n// File: contracts/MCCToken.sol\r\n\r\ncontract MCCToken is TransferLimitedToken {\r\n    // =================================================================================================================\r\n    //                                         Members\r\n    // =================================================================================================================\r\n    string public name = \"MyCreditChain\";\r\n\r\n    string public symbol = \"MCC\";\r\n\r\n    uint8 public decimals = 18;\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n    // =================================================================================================================\r\n    //                                         Constructor\r\n    // =================================================================================================================\r\n\r\n    /**\r\n     * @dev MCC Token\r\n     *      To change to a token for DAICO, you must set up an ITokenEvenListener\r\n     *      to change the voting weight setting through the listener for the\r\n     *      transfer of the token.\r\n     */\r\n    function MCCToken(address _listener, address[] _owners, address _manager) public\r\n        TransferLimitedToken(_listener, _owners, _manager)\r\n    {\r\n        totalSupply_ = uint256(1000000000).mul(uint256(10) ** decimals); // token total supply : 1000000000\r\n\r\n        balances[_owners[0]] = totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * @dev Override ManagedToken.issue. MCCToken can not issue but it need to\r\n     *      distribute tokens to contributors while crowding sales. So. we changed this\r\n     *       Issue tokens to specified wallet\r\n     * @param _to Wallet address\r\n     * @param _value Amount of tokens\r\n     */\r\n    function issue(address _to, uint256 _value) external onlyOwner canIssue {\r\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\r\n        balances[_to] = SafeMath.add(balances[_to], _value);\r\n        emit Issue(_to, _value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Burns a specific amount of tokens.\r\n     * @param _value The amount of token to be burned.\r\n     */\r\n    function burn(uint256 _value) public {\r\n        _burn(msg.sender, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Burns a specific amount of tokens from the target address and decrements allowance\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _value uint256 The amount of token to be burned\r\n    */\r\n    function burnFrom(address _from, uint256 _value) public {\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n        // this function needs to emit an event with the updated approval.\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        _burn(_from, _value);\r\n    }\r\n\r\n    function _burn(address _who, uint256 _value) internal {\r\n        require(_value <= balances[_who]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit Burn(_who, _value);\r\n        emit Transfer(_who, address(0), _value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allowTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"limitedWallets\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitedWalletsManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuanceFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burnFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"delLimitedWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"issue\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_setLimitEnabled\",\"type\":\"bool\"}],\"name\":\"setLimitEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOwners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"isLimitedWalletAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_listener\",\"type\":\"address\"}],\"name\":\"setListener\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishIssuance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"eventListener\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isLimitEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_allowTransfers\",\"type\":\"bool\"}],\"name\":\"setAllowTransfers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownerByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"}],\"name\":\"addLimitedWalletAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"}],\"name\":\"setOwners\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_listener\",\"type\":\"address\"},{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_manager\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_newState\",\"type\":\"bool\"}],\"name\":\"AllowTransfersChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Issue\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Destroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"IssuanceFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owners\",\"type\":\"address[]\"}],\"name\":\"SetOwners\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MCCToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000060000000000000000000000000de85017c66df2e1e154c5c67a0fb176a4c02e9470000000000000000000000000000000000000000000000000000000000000002000000000000000000000000b750aa45ffd490437b4a88c0c746275827fea110000000000000000000000000f56a76a6d41a4e6204983c4b2aef3ff7a1b6edf7","Library":"","SwarmSource":"bzzr://ad4d45eb992b76e1f99d4eb004b8efe81326ae26c403e3d6f37e9d7e56928c36"}]}