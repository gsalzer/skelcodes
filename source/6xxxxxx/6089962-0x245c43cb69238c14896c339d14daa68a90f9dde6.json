{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n\r\n    https://zethr.io https://zethr.io https://zethr.io https://zethr.io https://zethr.io\r\n\r\n\r\n                          ███████╗███████╗████████╗██╗  ██╗██████╗\r\n                          ╚══███╔╝██╔════╝╚══██╔══╝██║  ██║██╔══██╗\r\n                            ███╔╝ █████╗     ██║   ███████║██████╔╝\r\n                           ███╔╝  ██╔══╝     ██║   ██╔══██║██╔══██╗\r\n                          ███████╗███████╗   ██║   ██║  ██║██║  ██║\r\n                          ╚══════╝╚══════╝   ╚═╝   ╚═╝  ╚═╝╚═╝  ╚═╝\r\n\r\n\r\n.------..------.     .------..------..------.     .------..------..------..------..------.\r\n|B.--. ||E.--. |.-.  |T.--. ||H.--. ||E.--. |.-.  |H.--. ||O.--. ||U.--. ||S.--. ||E.--. |\r\n| :(): || (\\/) (( )) | :/\\: || :/\\: || (\\/) (( )) | :/\\: || :/\\: || (\\/) || :/\\: || (\\/) |\r\n| ()() || :\\/: |'-.-.| (__) || (__) || :\\/: |'-.-.| (__) || :\\/: || :\\/: || :\\/: || :\\/: |\r\n| '--'B|| '--'E| (( )) '--'T|| '--'H|| '--'E| (( )) '--'H|| '--'O|| '--'U|| '--'S|| '--'E|\r\n`------'`------'  '-'`------'`------'`------'  '-'`------'`------'`------'`------'`------'\r\n\r\nAn interactive, variable-dividend rate contract with an ICO-capped price floor and collectibles.\r\n\r\nBankroll contract, containing tokens purchased from all dividend-card profit and ICO dividends.\r\nActs as token repository for games on the Zethr platform.\r\n\r\n\r\nCredits\r\n=======\r\n\r\nAnalysis:\r\n    blurr\r\n    Randall\r\n\r\nContract Developers:\r\n    Etherguy\r\n    klob\r\n    Norsefire\r\n\r\nFront-End Design:\r\n    cryptodude\r\n    oguzhanox\r\n    TropicalRogue\r\n\r\n**/\r\n\r\ncontract ZTHInterface {\r\n    function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string providedUnhashedPass) public payable returns (uint);\r\n    function balanceOf(address who) public view returns (uint);\r\n    function transfer(address _to, uint _value)     public returns (bool);\r\n    function transferFrom(address _from, address _toAddress, uint _amountOfTokens) public returns (bool);\r\n    function exit() public;\r\n    function sell(uint amountOfTokens) public;\r\n    function withdraw(address _recipient) public;\r\n    function getUserAverageDividendRate(address user) public view returns (uint);\r\n}\r\n\r\n// Interface of zethr games \r\ncontract ZethrGameInterface{\r\n    function execute(address from, uint value, uint userDivRate, bytes data) public;\r\n}\r\n\r\ncontract ERC223Receiving {\r\n    function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\r\n}\r\n\r\n// Interface of master bankroll\r\ncontract ZethrBankroll {\r\n    address public stakeAddress;\r\n    mapping (address => bool) public isOwner;\r\n    function changeAllocation(address what, int delta) public;\r\n}\r\n\r\n// Library to return the actual tier of an average dividend rate \r\nlibrary ZethrTierLibrary{\r\n    uint constant internal magnitude = 2**64;\r\n\r\n    // Gets the tier (1-7) of the divs sent based off of average dividend rate\r\n    // This is an index used to call into the correct sub-bankroll to withdraw tokens\r\n    function getTier(uint divRate) internal pure returns (uint){\r\n        \r\n        // Divide the average dividned rate by magnitude\r\n        // Remainder doesn't matter because of the below logic\r\n        uint actualDiv = divRate / magnitude; \r\n        if (actualDiv >= 30){\r\n            return 7;\r\n        }\r\n        else if (actualDiv >= 25){\r\n            return 6;\r\n        }\r\n        else if (actualDiv >= 20){\r\n            return 5;\r\n        }\r\n        else if (actualDiv >= 15){\r\n            return 4;\r\n        }\r\n        else if (actualDiv >= 10){\r\n            return 3; \r\n        }\r\n        else if (actualDiv >= 5){\r\n            return 2;\r\n        }\r\n        else if (actualDiv >= 2){\r\n            return 1;\r\n        }\r\n        else{\r\n            // Should be impossible\r\n            revert();\r\n        }\r\n    }\r\n}\r\n\r\ncontract ZethrTokenBankroll is ERC223Receiving {\r\n\r\n    /*=================================\r\n    =          LIST OF OWNERS         =\r\n    =================================*/\r\n\r\n    /*\r\n        This list is for reference/identification purposes only, and comprises the eight core Zethr developers.\r\n        For game contracts to be listed, they must be approved by a majority (i.e. currently five) of the owners.\r\n        Contracts can be delisted in an emergency by a single owner.\r\n\r\n        0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae // Norsefire\r\n        0x11e52c75998fe2E7928B191bfc5B25937Ca16741 // klob\r\n        0x20C945800de43394F70D789874a4daC9cFA57451 // Etherguy\r\n        0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB // blurr\r\n        0x8537aa2911b193e5B377938A723D805bb0865670 // oguzhanox\r\n        0x9D221b2100CbE5F05a0d2048E2556a6Df6f9a6C3 // Randall\r\n        0x71009e9E4e5e68e77ECc7ef2f2E95cbD98c6E696 // cryptodude\r\n        0xDa83156106c4dba7A26E9bF2Ca91E273350aa551 // TropicalRogue\r\n    */\r\n    \r\n    // Mapping of whitelisted contracts\r\n    mapping(address => bool) public whitelistedContract; \r\n  \r\n    // Daily allocation mapping is master bankroll\r\n    // mapping(address => uint) public dailyAllocation;\r\n    \r\n    mapping (address => uint) public tokenVolumeInput; // tokens in per game \r\n    mapping (address => uint) public tokenVolumeOutput; // tokens out per  game \r\n    mapping (address => uint) public gameTokenAmount; // track tokens per game\r\n    mapping (address => uint) public gameTokenAllocation; // game token allocation \r\n    \r\n    // \"free\" tokens in the contract, can be allocated to games\r\n    uint public freeTokens;\r\n    \r\n    // List of all games\r\n    address[] public games; \r\n    \r\n    // Zethr main contract address\r\n    address Zethr; \r\n  \r\n    // Zethr interface\r\n    ZTHInterface ZethrContract;  \r\n\r\n    // Zethr bankroll address\r\n    address ZethrMainBankroll; \r\n    \r\n    // Dividend rate of this tokenBankroll\r\n    uint public divRate;\r\n\r\n    // \"tier\" of this tokeknBankroll (1-7)\r\n    uint public tier;\r\n    \r\n    // Magnitude for calculating average div rate\r\n    uint constant internal magnitude = 2**64;\r\n    \r\n    // Requires supplied address to be a whitelisted contract\r\n    // Pulls from master bankroll\r\n    modifier contractIsWhiteListed(address ctr){\r\n        require(whitelistedContract[ctr]);\r\n        _;\r\n    }\r\n    \r\n    // Requires msg.sender to be a dev or the bankroll\r\n    modifier onlyDevOrBankroll(){\r\n        require(msg.sender == ZethrMainBankroll || ZethrBankroll(ZethrMainBankroll).isOwner(msg.sender));\r\n        _;\r\n    }\r\n    \r\n    // Requires msg.sender to be a dev\r\n    modifier onlyDev(){\r\n        require(ZethrBankroll(ZethrMainBankroll).isOwner(msg.sender));\r\n        _;\r\n    }\r\n\r\n    /*=================================\r\n    =         PUBLIC FUNCTIONS        =\r\n    =================================*/\r\n\r\n    /// @dev Contract constructor sets sub roll divrate \r\n    constructor (uint ctrDivRate) public {\r\n        // Set the address of Zethr main contract\r\n        Zethr = address(0xD48B633045af65fF636F3c6edd744748351E020D); \r\n       \r\n        // Instantiate the Zethr contract \r\n        ZethrContract = ZTHInterface(Zethr);\r\n\r\n    \t// Set the master bankroll address\r\n        ZethrMainBankroll = address(0x1866abdba62468c33c32eb9cc366923af4b760f9); \r\n        \r\n        // Dev addresses are pulled from the bankroll\r\n        \r\n        // Set this tokenBankroll's dividend rate\r\n        divRate = ctrDivRate;\r\n\r\n        // Set this token's dividend tier (1-7)\r\n        tier = ZethrTierLibrary.getTier(divRate * magnitude);\r\n    }\r\n\r\n    // Admin / bankroll function to change bankroll address\r\n    function setBankroll(address bankrollAddress) public onlyDevOrBankroll() {\r\n      ZethrMainBankroll =  bankrollAddress;\r\n    }\r\n\r\n    // Assembly function \r\n    // Takes: bytes data as input \r\n    // Returns: the address we want to call \r\n    // plus the remaining bytes of data which should be fed to the game\r\n    \r\n    /*\r\n        Layout of the actual bytes data as input: \r\n        First bytes32: an address you want to call to (the game address)\r\n        (Optional) extra bytes32: remaining data \r\n        Padding of the address is how we see it in raw tx data: 0x00...address \r\n        \r\n        Input MUST have bytes which are a multiple of 32 \r\n        Input MUST have at least one bytes32 \r\n        \r\n        Test cases \r\n            Only address\r\n            0x000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551\r\n            Address + bytes \r\n            0x000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551\r\n            Address + 2 bytes \r\n            0x000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa551\r\n        \r\n        Error cases: \r\n            Not a multiple of 32 \r\n            0x000000000000000000000000Da83156106c4dba7A26E9bF2Ca91E273350aa5\r\n            Empty\r\n            0x0 \r\n            \r\n        Note: sanity check is done after the getData call to check if address is a contract \r\n    */\r\n    function getData(bytes data) public pure returns (address, bytes rem) {\r\n        // edge case: len 0 should revert \r\n        // case: len 1 should only parse addr and empty bytes \r\n        // case: len more should forloop over bytes and dump them \r\n        \r\n        require(data.length == (data.length/32) * 32); // sanity check only bytes32 multiples \r\n    \r\n        // no address found \r\n        if (data.length == 0) {\r\n            revert(); // no data \r\n        }\r\n    \r\n        address out_a;\r\n        bytes memory out_b; // initialzie to empty array \r\n        \r\n        \r\n        // start the assembly magic \r\n        if (data.length == 32){\r\n            // ONLY an address, rest is empty data. Fine! \r\n            assembly {\r\n                // Things to know here: \r\n                // x := bla sets x to bla \r\n                // mload loads 32 bytes, the input is the memory slot \r\n                // vars used here are actually POINTERS not the actual data! \r\n                // Logic (IMPORTANT)\r\n                // A bytes is laid out in solidity as: \r\n                // first bytes32: a uint which has the LENGTH of this byte \r\n                // the length of the byte is the numbers of bytes (so in here its a multiple of 32, aka 0x20!)\r\n                //So if we want to retrieve the actual data at the first slot (hence, the address) we need\r\n                //to add 32 bytes to the actual pointer of data, to skip over the length bytes32 \r\n                //then we load this bytes32 and dump it into out_a \r\n                out_a := mload(add(data, 0x20)) // load first byte into the address slot \r\n            }\r\n        }\r\n        else{\r\n            // Logic: remove 32 from the actual data length because we want to remove the game address from the data \r\n            // (Why do that here not in the game? Because it adds a load of code)\r\n            uint len = data.length - 32;\r\n            assembly {\r\n                out_a := mload(add(data, 0x20)) // load first byte into the address slot, same as above in case of only the address \r\n                // at the out_b pointer, we store the length we want this bytes to have \r\n                // yup - thats the number of bytes in data (data.length) minus 32 as defined above \r\n                mstore(out_b, len)\r\n                // now we will actually fill this bytes \r\n                // for loop: for(uint i=0; i<len; i++)\r\n                for { let i := 0 } lt(i, div(len, 0x20)) { i := add(i, 0x1) } {\r\n                    // calculate the memory slot we want to dump data in: \r\n                    // take the out_b pointer \r\n                    // add 32 * (i+1) to this (could have optimized this)\r\n                    let mem_slot := add(out_b, mul(0x20, add(i,1)))\r\n                    // calculate the load slot where we want to actually read memory from \r\n                    // this is the same as the memory slot we want to write to, +32 \r\n                    // this makes sense becausae we want to basically move all bytes32 one place back! \r\n                    let load_slot := add(mem_slot,0x20)\r\n                    // actually dump the loaded memory at load_slot into mem_slot \r\n                    mstore(mem_slot, mload(load_slot))\r\n                }\r\n            }\r\n        }\r\n        //uint codelen;\r\n        //assembly{\r\n          //  codelen := extcodesize(out_a)\r\n        //}\r\n        // require(codelen > 0); // sanity check we are delegate of a contract \r\n        return (out_a, out_b);\r\n    }\r\n\r\n    // Returns true if supplied address is a contract\r\n\t\t// Does not return true if this contract is deployed during this block\r\n    function isContract(address ctr) internal view returns (bool){\r\n        uint codelen;\r\n        assembly{\r\n            codelen := extcodesize(ctr)\r\n        }\r\n        return (codelen > 0);\r\n    }\r\n\r\n  // Token fallback - gets entered when users transfer tokens to this contract \r\n\tfunction tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool) {\r\n\r\n\t\t\t// Can only be called from Zethr\r\n\t    require(msg.sender == Zethr); \r\n\r\n\t\t\t// Get the user's dividend rate\r\n\t\t\t// This is a big nasty number\r\n\t    uint userDivRate = ZethrContract.getUserAverageDividendRate(_from);\r\n\r\n\t\t\t// Calculate the user's tier, and make sure it is appropriate for this contract\r\n\t\t\t// (sanity check)\r\n\t    require(ZethrTierLibrary.getTier(userDivRate) == tier); \r\n\r\n\t    address target;  \r\n\t    bytes memory remaining_data;\r\n\r\n\t    // Grab the data we want to forward (target is the game address)\r\n\t    (target, remaining_data) = getData(_data);\r\n\r\n\t    // Sanity check to make sure we're calling a contract\r\n\t    require(isContract(target));\r\n\r\n\t    // Sanity check to make sure this game is actually one which can use the bankroll \r\n\t    require(whitelistedContract[target]);\r\n\t    \r\n\t\t\t// Add tokens the game's token amount counter (for this contract only)\r\n\t    gameTokenAmount[target] = SafeMath.add(gameTokenAmount[target], _amountOfTokens);\r\n\r\n\t\t\t// Add tokens the game's token volume counter (for this contract only)\r\n\t    tokenVolumeInput[target] = SafeMath.add(tokenVolumeInput[target], _amountOfTokens);\r\n\t    \r\n\t    // EXECUTE the actual game! \r\n\t\t\t// Call into the game with data\r\n\t    ZethrGameInterface(target).execute(_from, _amountOfTokens, userDivRate, remaining_data);\r\n\t}\t\r\n\t\r\n\t// Function called ONLY by a whitelisted game\r\n\t// Sends tokens to the target address (player)\r\n\tfunction gameRequestTokens(address target, uint tokens) \r\n\t    public \r\n\t    contractIsWhiteListed(msg.sender)\r\n    {\r\n\t\t\t// Don't sent more tokens than the game owns\r\n\t    require(gameTokenAmount[msg.sender] >= tokens);  \r\n\r\n\t\t\t// Subtract the amount of tokens the game owns\r\n\t    gameTokenAmount[msg.sender] = gameTokenAmount[msg.sender] - tokens; \r\n\r\n\t\t\t// Update output volume\r\n\t    tokenVolumeOutput[msg.sender] = tokenVolumeOutput[msg.sender] + tokens; \r\n\r\n\t\t\t// Actually transfer. Re-entrancy possibility\r\n\t    ZethrContract.transfer(target, tokens);\r\n\t}\r\n\t\r\n\t// Add a game to the whitelist. Can only be called by dev or bankroll.\t\r\n\tfunction addGame(address game, uint allocated)\r\n\t    onlyDevOrBankroll\r\n\t    public\r\n    {\r\n\t\t\t\t// Push the game address to the list\r\n        games.push(game); \r\n\r\n\t\t\t\t// Set the token allocation\r\n        gameTokenAllocation[game] = allocated; \r\n\r\n\t\t\t\t// If we have enough \"free\" tokens, allocate them\r\n        if (freeTokens >= allocated){ \r\n            freeTokens = SafeMath.sub(freeTokens, allocated);\r\n            gameTokenAmount[game] = allocated;\r\n        }\r\n\r\n        // Change this tokenbankroll's allocation\r\n        ZethrBankroll(ZethrMainBankroll).changeAllocation(address(this), int(allocated));\r\n\r\n\t\t\t\t// Ad the game to the whitelisted addresses\r\n        whitelistedContract[game] = true; \r\n    }\r\n    \r\n    // Remove the game from the list & dewhitelist it\r\n    function removeGame(address game)\r\n        public\r\n        onlyDevOrBankroll\r\n        contractIsWhiteListed(game) // Only remove games which are added \r\n    {\r\n        // Loop over games to find the actual index to remove \r\n        for (uint i=0; i < games.length; i++){\r\n            if (games[i] == game){\r\n                games[i] = address(0x0); // Delete it \r\n                if (i != games.length){ // If its NOT at the end remove the last game address into the array TO this position\r\n                    games[i] = games[games.length];\r\n                }\r\n                games.length = games.length - 1; // Remove 1 from length \r\n                break; // Found it, great \r\n            }\r\n        }\r\n\r\n        // Add remaining tokens from game to the \"free\" list \r\n        freeTokens = SafeMath.add(freeTokens, gameTokenAmount[game]);\r\n\r\n        // Aint got no tokens \r\n        gameTokenAmount[game] = 0;\r\n\r\n        // Aint whitelisted \r\n        whitelistedContract[game] = false;\r\n\r\n        // Change this tokenBankroll's allocation\r\n        ZethrBankroll(ZethrMainBankroll).changeAllocation(address(this), int(-gameTokenAllocation[game]));\r\n\r\n        // No allocate \r\n        gameTokenAllocation[game] = 0;\r\n    }\r\n\t\r\n\t// Callable from games to change their own token allocation \r\n  // The game must have \"free\" tokens\r\n  // Triggers a change in the tokenBankroll's allocation amount on the master bankroll\r\n\tfunction changeAllocation(int delta)\r\n\t    public\r\n\t    contractIsWhiteListed(msg.sender)\r\n\t{\r\n\t    uint newAlloc;\r\n      // We need to INCREASE token allocation:\r\n\t    if (delta > 0){\r\n\t        // Calculate new allocation \r\n\t        newAlloc = SafeMath.add(gameTokenAllocation[msg.sender], uint(delta));\r\n\r\n\t        // It SHOULD have enough tokens\r\n\t        require(gameTokenAmount[msg.sender] >= newAlloc);\r\n\r\n\t        // Set the game's token allocation\r\n\t        gameTokenAllocation[msg.sender] = newAlloc;\r\n\r\n          // Set this tokenBankroll's allocation (increase it)\r\n          ZethrBankroll(ZethrMainBankroll).changeAllocation(address(this), delta);\r\n\t    } else {\r\n      // We need to DECREASE token allocation:\r\n\t        // Calculate the new allocation \r\n\t        newAlloc = SafeMath.sub(gameTokenAllocation[msg.sender], uint(-delta));\r\n\r\n\t        // Set the game's token allocation\r\n\t        gameTokenAllocation[msg.sender] = newAlloc;\r\n\r\n          // Set this tokenBankroll's allocation (decrease it)\r\n          ZethrBankroll(ZethrMainBankroll).changeAllocation(address(this), delta);\r\n\t    }\r\n\t}\r\n\t\r\n\t// Allocates tokens to games\r\n\t// Also buys in if balance >= 0.1 ETH\r\n\tfunction allocateTokens()\r\n\t    onlyDevOrBankroll\r\n\t    public\r\n\t{\r\n\t    // Withdraw divs first\r\n\t    ZethrContract.withdraw(address(this));\r\n\r\n\t\t\t// Buy in, but only if balance >= 0.1 ETH\r\n\t    if (address(this).balance >= (0.1 ether)){\r\n\t        zethrBuyIn(); \r\n\t    }\r\n\r\n      // Store current game address for loop\r\n      address gameAddress;    \r\n      // Stoe game's balance for loop\r\n      uint gameBalance;\r\n      // Store game's allotment for loop \r\n      uint gameAllotment;\r\n      // Store game's difference (positive or negative) in tokenBalance vs tokenAllotment\r\n      int difference;\r\n\r\n      // Loop over each game\r\n      // Remove any \"free\" tokens (auto-withdraw) over its allotment\r\n      for (uint i=0; i < games.length; i++) {\r\n        // Grab the info about this game's token amounts\r\n        gameAddress = games[i];\r\n        gameBalance = gameTokenAmount[gameAddress];\r\n        gameAllotment = gameTokenAllocation[gameAddress];   \r\n\r\n        // Calculate deltaTokens (positive if it has more than it needs, negative if it needs tokens)\r\n        difference = int(gameBalance) - int(gameAllotment);\r\n\r\n        // If the game has extra tokens, re-allocate them to the \"free\" balance\r\n        // This reminds me of when I had to write malloc() for my C class\r\n        // I hated that shit\r\n        if (difference > 0) {\r\n          // Game now has exactly the amount of tokens it needs\r\n          gameTokenAmount[gameAddress] = gameAllotment;\r\n \r\n          // \"Free\" the extra\r\n          freeTokens = freeTokens + uint(difference);\r\n        } else {\r\n          // This means it needs tokenks. We'll address that in the next for loop.\r\n        } \r\n      } \r\n\r\n      // Now that all games have had their excess removed, loop through the games again and allocated them tokens\r\n      // We /will/ have enough tokens to allocate - because we bought in ETH.\r\n      for (uint j=0; j < games.length; j++) {\r\n        // Grab the info about this game's token amounts\r\n        gameAddress = games[i];\r\n        gameBalance = gameTokenAmount[gameAddress];\r\n        gameAllotment = gameTokenAllocation[gameAddress];\r\n\r\n        // Calculate deltaTokens (either zero or negative in this case)\r\n        difference = int(gameBalance) - int(gameAllotment);\r\n\r\n        // Game either has zero or negative tokens\r\n        // If it has negative tokens, allocate it tokens out of the free balance\r\n        if (difference < 0) {\r\n          // Sanity check\r\n          require(freeTokens >= uint(-difference));\r\n\r\n          // Subtract from free tokens\r\n          freeTokens = freeTokens - uint(-difference);\r\n\r\n          // Allocate\r\n          gameTokenAmount[gameAddress] = gameAllotment;\r\n        }\r\n      }\r\n\r\n      // After the above two for loops, every game has\r\n      //  a) no excess tokens\r\n      //  b) exactly it's allotment of tokens\r\n\r\n      // There will probably be some free tokens left over due to the 1% extra ETH deposit.\r\n\t}\r\n\r\n  // Dump all free tokens back to the main bankroll\r\n  function dumpFreeTokens(address stakeAddress) onlyDevOrBankroll public returns (uint) {\r\n    // First, allocate tokens    \r\n    allocateTokens();\r\n\r\n    // Don't transfer tokens if we have less than 1 free token\r\n    if (freeTokens < 1e18) { return 0; }\r\n\r\n    // Transfer free tokens to bankroll\r\n    ZethrContract.transfer(stakeAddress, freeTokens);\r\n\r\n    // Set free tokens to zero\r\n    uint sent = freeTokens;\r\n    freeTokens = 0;\r\n\r\n    // Return the number of tokens we sent\r\n    return sent;\r\n  }\r\n\r\n\t// Contract withdraw free tokens back to the free tokens \r\n\tfunction contractTokenWithdrawToFreeTokens(address ctr, uint amount)\r\n\t    onlyDevOrBankroll\r\n\t    contractIsWhiteListed(ctr)\r\n\t    public \r\n\t{\r\n\t    uint currentBalance = gameTokenAmount[ctr];\r\n\t    uint allocated = gameTokenAllocation[ctr];\r\n\t    if ( SafeMath.sub(currentBalance, amount) > allocated){\r\n\t        gameTokenAmount[ctr] = gameTokenAmount[ctr] - amount;\r\n\t        freeTokens = SafeMath.add(freeTokens, amount);\r\n\t    }\r\n\t    else{\r\n\t        revert();\r\n\t    }\r\n\t}\r\n\t\r\n\t// Function to buy in tokens with Ethereum \r\n\t// Updates free tokens so they can be allocated \r\n\tfunction zethrBuyIn()\r\n\t    onlyDevOrBankroll\r\n\t    public\r\n\t{\r\n      // Only buy in if balance >= 0.1 ETH\r\n      if (address(this).balance < 0.1 ether) { return; } \r\n\r\n      // Grab the tokenBankroll's token balance\r\n\t    uint cBal = ZethrContract.balanceOf(address(this)); \r\n\r\n      // Buy in with entire balance (divs go to bankroll)\r\n\t    ZethrContract.buyAndSetDivPercentage.value(address(this).balance)(ZethrMainBankroll, uint8(divRate), \"\");\r\n\r\n      // Calculate and increment freeTokens\r\n\t    freeTokens = freeTokens + (ZethrContract.balanceOf(address(this)) - cBal); \r\n\t}\r\n\t\r\n\t// Emergency this fucks up free tokens \r\n\t// Need a redeploy after this \r\n\tfunction WithdrawTokensToBankroll(uint amount) \r\n\t    onlyDevOrBankroll\r\n\t    public\r\n\t{\r\n\t    ZethrContract.transfer(ZethrMainBankroll, amount);\r\n\t}\r\n\r\n  // Withdraw eth \r\n  function WithdrawToBankroll() public {\r\n    ZethrMainBankroll.transfer(address(this).balance);\r\n  }\r\n    \r\n  // Withdraw divs and send to bankroll \r\n  function WithdrawAndTransferToBankroll() public {\r\n    ZethrContract.withdraw(ZethrMainBankroll);\r\n    WithdrawToBankroll();\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint a, uint b) internal pure returns (uint) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint a, uint b) internal pure returns (uint) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint a, uint b) internal pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"allocateTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawAndTransferToBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameTokenAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getData\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"rem\",\"type\":\"bytes\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tier\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelistedContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"address\"},{\"name\":\"allocated\",\"type\":\"uint256\"}],\"name\":\"addGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"zethrBuyIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithdrawToBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawTokensToBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"gameRequestTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"stakeAddress\",\"type\":\"address\"}],\"name\":\"dumpFreeTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"delta\",\"type\":\"int256\"}],\"name\":\"changeAllocation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameTokenAllocation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ctr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"contractTokenWithdrawToFreeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"divRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"game\",\"type\":\"address\"}],\"name\":\"removeGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"bankrollAddress\",\"type\":\"address\"}],\"name\":\"setBankroll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenVolumeInput\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenVolumeOutput\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"ctrDivRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ZethrTokenBankroll","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000002","Library":"","SwarmSource":"bzzr://4a32fd4c2850b41f70feaf656e0bc6101ca52e540018ff1df86d15c73050750b"}]}