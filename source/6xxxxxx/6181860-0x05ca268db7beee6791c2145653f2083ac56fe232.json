{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender)\r\n        public view returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n        public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n    );\r\n}\r\n\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    uint256 totalSupply_;\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n  \r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\ncontract BurnableToken is BasicToken {\r\n\r\n    event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n    function burn(uint256 _value) public {\r\n        _burn(msg.sender, _value);\r\n    }\r\n\r\n    function _burn(address _who, uint256 _value) internal {\r\n        require(_value <= balances[_who]);\r\n\r\n        balances[_who] = balances[_who].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit Burn(_who, _value);\r\n        emit Transfer(_who, address(0), _value);\r\n    }\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint _addedValue\r\n    )\r\n    public\r\n    returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = (\r\n        allowed[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint _subtractedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract NRXtoken is StandardToken, BurnableToken {\r\n    string public constant name = \"Neironix\";\r\n    string public constant symbol = \"NRX\";\r\n    uint32 public constant decimals = 18;\r\n    uint256 public INITIAL_SUPPLY = 140000000 * 1 ether;\r\n    address public CrowdsaleAddress;\r\n    bool public lockTransfers = false;\r\n\r\n    event AcceptToken(address indexed from, uint256 value);\r\n\r\n    constructor(address _CrowdsaleAddress) public {\r\n        CrowdsaleAddress = _CrowdsaleAddress;\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;      \r\n    }\r\n  \r\n    modifier onlyOwner() {\r\n        // only Crowdsale contract\r\n        require(msg.sender == CrowdsaleAddress);\r\n        _;\r\n    }\r\n\r\n     // Override\r\n    function transfer(address _to, uint256 _value) public returns(bool){\r\n        if (msg.sender != CrowdsaleAddress){\r\n            require(!lockTransfers, \"Transfers are prohibited in Crowdsale period\");\r\n        }\r\n        return super.transfer(_to,_value);\r\n    }\r\n\r\n     // Override\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool){\r\n        if (msg.sender != CrowdsaleAddress){\r\n            require(!lockTransfers, \"Transfers are prohibited in Crowdsale period\");\r\n        }\r\n        return super.transferFrom(_from,_to,_value);\r\n    }\r\n\r\n    /**\r\n     * @dev function accept tokens from users as a payment for servises and burn their\r\n     * @dev can run only from crowdsale contract\r\n    */\r\n    function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){\r\n        require (balances[_from] >= _value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit AcceptToken(_from, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev function transfer tokens from special address to users\r\n     * @dev can run only from crowdsale contract\r\n    */\r\n    function transferTokensFromSpecialAddress(address _from, address _to, uint256 _value) public onlyOwner returns (bool){\r\n        require (balances[_from] >= _value);\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n\r\n    function lockTransfer(bool _lock) public onlyOwner {\r\n        lockTransfers = _lock;\r\n    }\r\n\r\n\r\n\r\n    function() external payable {\r\n        revert(\"The token contract don`t receive ether\");\r\n    }  \r\n}\r\n\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    address candidate;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        candidate = newOwner;\r\n    }\r\n\r\n    function confirmOwnership() public {\r\n        require(candidate == msg.sender);\r\n        owner = candidate;\r\n        delete candidate;\r\n    }\r\n\r\n}\r\n\r\ncontract ProjectFundAddress {\r\n    //Address where stored project fund tokens- 7%\r\n    function() external payable {\r\n        // The contract don`t receive ether\r\n        revert();\r\n    } \r\n}\r\n\r\n\r\ncontract TeamAddress {\r\n    //Address where stored command tokens- 10%\r\n    //Withdraw tokens allowed only after 0.5 year\r\n    function() external payable {\r\n        // The contract don`t receive ether\r\n        revert();\r\n    } \r\n}\r\n\r\ncontract PartnersAddress {\r\n    //Address where stored partners tokens- 10%\r\n    //Withdraw tokens allowed only after 0.5 year\r\n    function() external payable {\r\n        // The contract don`t receive ether\r\n        revert();\r\n    } \r\n}\r\n\r\ncontract AdvisorsAddress {\r\n    //Address where stored advisors tokens- 3,5%\r\n    //Withdraw tokens allowed only after 0.5 year\r\n    function() external payable {\r\n        // The contract don`t receive ether\r\n        revert();\r\n    } \r\n}\r\n\r\ncontract BountyAddress {\r\n    //Address where stored bounty tokens- 3%\r\n    function() external payable {\r\n        // The contract don`t receive ether\r\n        revert();\r\n    } \r\n}\r\n\r\n/**\r\n * @title Crowdsale contract and burnable token ERC20\r\n */\r\ncontract Crowdsale is Ownable {\r\n    using SafeMath for uint; \r\n    event LogStateSwitch(State newState);\r\n    event Withdraw(address indexed from, address indexed to, uint256 amount);\r\n\r\n    address myAddress = this;\r\n\r\n    uint64 crowdSaleStartTime = 0;\r\n    uint64 crowdSaleEndTime = 0;\r\n\r\n    uint public  tokenRate = 942;  //tokens for 1 ether\r\n\r\n    address public marketingProfitAddress = 0x0;\r\n    address public neironixProfitAddress = 0x0;\r\n    address public lawSupportProfitAddress = 0x0;\r\n    address public hostingProfitAddress = 0x0;\r\n    address public teamProfitAddress = 0x0;\r\n    address public contractorsProfitAddress = 0x0;\r\n    address public saasApiProfitAddress = 0x0;\r\n\r\n    \r\n    NRXtoken public token = new NRXtoken(myAddress);\r\n\r\n    /**\r\n    * @dev New address for hold tokens\r\n    */\r\n    ProjectFundAddress public holdAddress1 = new ProjectFundAddress();\r\n    TeamAddress public holdAddress2 = new TeamAddress();\r\n    PartnersAddress public holdAddress3 = new PartnersAddress();\r\n    AdvisorsAddress public holdAddress4 = new AdvisorsAddress();\r\n    BountyAddress public holdAddress5 = new BountyAddress();\r\n\r\n    /**\r\n     * @dev Create state of contract \r\n     */\r\n    enum State { \r\n        Init,    \r\n        CrowdSale,\r\n        WorkTime\r\n    }\r\n        \r\n    State public currentState = State.Init;\r\n\r\n    modifier onlyInState(State state){ \r\n        require(state==currentState); \r\n        _; \r\n    }\r\n\r\n    constructor() public {\r\n        uint256 TotalTokens = token.INITIAL_SUPPLY().div(1 ether);\r\n        // distribute tokens\r\n        //Transer tokens to project fund address.  (7%)\r\n        _transferTokens(address(holdAddress1), TotalTokens.mul(7).div(100));\r\n        // Transer tokens to team address.  (10%)\r\n        _transferTokens(address(holdAddress2), TotalTokens.div(10));\r\n        // Transer tokens to partners address. (10%)\r\n        _transferTokens(address(holdAddress3), TotalTokens.div(10));\r\n        // Transer tokens to advisors address. (3.5%)\r\n        _transferTokens(address(holdAddress4), TotalTokens.mul(35).div(1000));\r\n        // Transer tokens to bounty address. (3%)\r\n        _transferTokens(address(holdAddress5), TotalTokens.mul(3).div(100));\r\n        \r\n        /**\r\n         * @dev Create periods\r\n         * TokenSale between 01/09/2018 and 30/11/2018\r\n         * Unix timestamp 01/09/2018 - 1535760000\r\n        */\r\n\r\n\r\n        crowdSaleStartTime = 1535760000;\r\n        crowdSaleEndTime = crowdSaleStartTime + 91 days;\r\n        \r\n        \r\n    }\r\n    \r\n    function setRate(uint _newRate) public onlyOwner {\r\n        /**\r\n         * @dev Enter the amount of tokens per 1 ether\r\n         */\r\n        tokenRate = _newRate;\r\n    }\r\n\r\n    function setMarketingProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\r\n        require (_addr != address(0));\r\n        marketingProfitAddress = _addr;\r\n    }\r\n    \r\n    function setNeironixProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\r\n        require (_addr != address(0));\r\n        neironixProfitAddress = _addr;\r\n    }\r\n\r\n    function setLawSupportProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\r\n        require (_addr != address(0));\r\n        lawSupportProfitAddress = _addr;\r\n    }\r\n \r\n    function setHostingProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\r\n        require (_addr != address(0));\r\n        hostingProfitAddress = _addr;\r\n    }\r\n \r\n    function setTeamProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\r\n        require (_addr != address(0));\r\n        teamProfitAddress = _addr;\r\n    }\r\n    \r\n    function setContractorsProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\r\n        require (_addr != address(0));\r\n        contractorsProfitAddress = _addr;\r\n    }\r\n\r\n    function setSaasApiProfitAddress(address _addr) public onlyOwner onlyInState(State.Init){\r\n        require (_addr != address(0));\r\n        saasApiProfitAddress = _addr;\r\n    }\r\n    \r\n    function acceptTokensFromUsers(address _investor, uint256 _value) public onlyOwner{\r\n        token.acceptTokens(_investor, _value); \r\n    }\r\n\r\n    function transferTokensFromProjectFundAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\r\n        /**\r\n         * @dev the function transfer tokens from ProjectFundAddress  to investor\r\n         * not hold\r\n         * the sum is entered in whole tokens (1 = 1 token)\r\n         */\r\n\r\n        uint256 value = _value;\r\n        require (value >= 1);\r\n        value = value.mul(1 ether);\r\n        token.transferTokensFromSpecialAddress(address(holdAddress1), _investor, value); \r\n        return true;\r\n    } \r\n\r\n    function transferTokensFromTeamAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\r\n        /**\r\n         * @dev the function tranfer tokens from TeamAddress to investor\r\n         * only after 182 days\r\n         * the sum is entered in whole tokens (1 = 1 token)\r\n         */\r\n        uint256 value = _value;\r\n        require (value >= 1);\r\n        value = value.mul(1 ether);\r\n        require (now >= crowdSaleEndTime + 182 days, \"only after 182 days\");\r\n        token.transferTokensFromSpecialAddress(address(holdAddress2), _investor, value); \r\n        return true;\r\n    } \r\n    \r\n    function transferTokensFromPartnersAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\r\n        /**\r\n         * @dev the function transfer tokens from PartnersAddress to investor\r\n         * only after 182 days\r\n         * the sum is entered in whole tokens (1 = 1 token)\r\n         */\r\n        uint256 value = _value;\r\n        require (value >= 1);\r\n        value = value.mul(1 ether);\r\n        require (now >= crowdSaleEndTime + 91 days, \"only after 91 days\");\r\n        token.transferTokensFromSpecialAddress(address(holdAddress3), _investor, value); \r\n        return true;\r\n    } \r\n    \r\n    function transferTokensFromAdvisorsAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\r\n        /**\r\n         * @dev the function transfer tokens from AdvisorsAddress to investor\r\n         * only after 182 days\r\n         * the sum is entered in whole tokens (1 = 1 token)\r\n         */\r\n        uint256 value = _value;\r\n        require (value >= 1);\r\n        value = value.mul(1 ether);\r\n        require (now >= crowdSaleEndTime + 91 days, \"only after 91 days\");\r\n        token.transferTokensFromSpecialAddress(address(holdAddress4), _investor, value); \r\n        return true;\r\n    }     \r\n    \r\n    function transferTokensFromBountyAddress(address _investor, uint256 _value) public onlyOwner returns(bool){\r\n        /**\r\n         * @dev the function transfer tokens from BountyAddress to investor\r\n         * not hold\r\n         * the sum is entered in whole tokens (1 = 1 token)\r\n         */\r\n        uint256 value = _value;\r\n        require (value >= 1);\r\n        value = value.mul(1 ether);\r\n        token.transferTokensFromSpecialAddress(address(holdAddress5), _investor, value); \r\n        return true;\r\n    }     \r\n\r\n\r\n    function _transferTokens(address _newInvestor, uint256 _value) internal {\r\n        require (_newInvestor != address(0));\r\n        require (_value >= 1);\r\n        uint256 value = _value;\r\n        value = value.mul(1 ether);\r\n        token.transfer(_newInvestor, value);\r\n    }  \r\n\r\n    function transferTokens(address _newInvestor, uint256 _value) public onlyOwner {\r\n        /**\r\n         * @dev the function transfer tokens to new investor\r\n         * the sum is entered in whole tokens (1 = 1 token)\r\n         */\r\n        _transferTokens(_newInvestor, _value);\r\n    }\r\n    \r\n    function setState(State _state) internal {\r\n        currentState = _state;\r\n        emit LogStateSwitch(_state);\r\n    }\r\n\r\n    function startSale() public onlyOwner onlyInState(State.Init) {\r\n        require(uint64(now) > crowdSaleStartTime, \"Sale time is not coming.\");\r\n        require(neironixProfitAddress != address(0));\r\n        setState(State.CrowdSale);\r\n        token.lockTransfer(true);\r\n    }\r\n\r\n\r\n    function finishCrowdSale() public onlyOwner onlyInState(State.CrowdSale) {\r\n        /**\r\n         * @dev the function is burn all unsolded tokens and unblock external token transfer\r\n         */\r\n        require (now > crowdSaleEndTime, \"CrowdSale stage is not over\");\r\n        setState(State.WorkTime);\r\n        token.lockTransfer(false);\r\n        // burn all unsolded tokens\r\n        token.burn(token.balanceOf(myAddress));\r\n    }\r\n\r\n\r\n    function blockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){\r\n        /**\r\n         * @dev Blocking all external token transfer\r\n         */\r\n        require (token.lockTransfers() == false);\r\n        token.lockTransfer(true);\r\n    }\r\n\r\n    function unBlockExternalTransfer() public onlyOwner onlyInState (State.WorkTime){\r\n        /**\r\n         * @dev Unblocking all external token transfer\r\n         */\r\n        require (token.lockTransfers() == true);\r\n        token.lockTransfer(false);\r\n    }\r\n\r\n\r\n    function setBonus () public view returns(uint256) {\r\n        /**\r\n         * @dev calculation bonus\r\n         */\r\n        uint256 actualBonus = 0;\r\n        if ((uint64(now) >= crowdSaleStartTime) && (uint64(now) < crowdSaleStartTime + 30 days)){\r\n            actualBonus = 35;\r\n        }\r\n        if ((uint64(now) >= crowdSaleStartTime + 30 days) && (uint64(now) < crowdSaleStartTime + 61 days)){\r\n            actualBonus = 15;\r\n        }\r\n        if ((uint64(now) >= crowdSaleStartTime + 61 days) && (uint64(now) < crowdSaleStartTime + 91 days)){\r\n            actualBonus = 5;\r\n        }\r\n        return actualBonus;\r\n    }\r\n\r\n    function _withdrawProfit () internal {\r\n        /**\r\n         * @dev Distributing profit\r\n         * the function start automatically every time when contract receive a payable transaction\r\n         */\r\n        \r\n        uint256 marketingProfit = myAddress.balance.mul(30).div(100);   // 30%\r\n        uint256 lawSupportProfit = myAddress.balance.div(20);           // 5%\r\n        uint256 hostingProfit = myAddress.balance.div(20);              // 5%\r\n        uint256 teamProfit = myAddress.balance.div(10);                 // 10%\r\n        uint256 contractorsProfit = myAddress.balance.div(20);          // 5%\r\n        uint256 saasApiProfit = myAddress.balance.div(20);              // 5%\r\n        //uint256 neironixProfit =  myAddress.balance.mul(40).div(100); // 40% but not use. Just transfer all rest\r\n\r\n\r\n        if (marketingProfitAddress != address(0)) {\r\n            marketingProfitAddress.transfer(marketingProfit);\r\n            emit Withdraw(msg.sender, marketingProfitAddress, marketingProfit);\r\n        }\r\n        \r\n        if (lawSupportProfitAddress != address(0)) {\r\n            lawSupportProfitAddress.transfer(lawSupportProfit);\r\n            emit Withdraw(msg.sender, lawSupportProfitAddress, lawSupportProfit);\r\n        }\r\n\r\n        if (hostingProfitAddress != address(0)) {\r\n            hostingProfitAddress.transfer(hostingProfit);\r\n            emit Withdraw(msg.sender, hostingProfitAddress, hostingProfit);\r\n        }\r\n\r\n        if (teamProfitAddress != address(0)) {\r\n            teamProfitAddress.transfer(teamProfit);\r\n            emit Withdraw(msg.sender, teamProfitAddress, teamProfit);\r\n        }\r\n\r\n        if (contractorsProfitAddress != address(0)) {\r\n            contractorsProfitAddress.transfer(contractorsProfit);\r\n            emit Withdraw(msg.sender, contractorsProfitAddress, contractorsProfit);\r\n        }\r\n\r\n        if (saasApiProfitAddress != address(0)) {\r\n            saasApiProfitAddress.transfer(saasApiProfit);\r\n            emit Withdraw(msg.sender, saasApiProfitAddress, saasApiProfit);\r\n        }\r\n\r\n        require(neironixProfitAddress != address(0));\r\n        uint myBalance = myAddress.balance;\r\n        neironixProfitAddress.transfer(myBalance);\r\n        emit Withdraw(msg.sender, neironixProfitAddress, myBalance);\r\n\r\n    }\r\n \r\n    function _saleTokens() internal returns(bool) {\r\n        require(uint64(now) > crowdSaleStartTime, \"Sale stage is not yet, Contract is init, do not accept ether.\"); \r\n         \r\n        if (currentState == State.Init) {\r\n            require(neironixProfitAddress != address(0),\"At least one of profit addresses must be entered\");\r\n            setState(State.CrowdSale);\r\n        }\r\n        \r\n        /**\r\n         * @dev calculation length of periods, pauses, auto set next stage\r\n         */\r\n        if (uint64(now) > crowdSaleEndTime){\r\n            require (false, \"CrowdSale stage is passed - contract do not accept ether\");\r\n        }\r\n        \r\n        uint tokens = tokenRate.mul(msg.value);\r\n        \r\n        if (currentState == State.CrowdSale) {\r\n            require (msg.value <= 250 ether, \"Maximum 250 ether for transaction all CrowdSale period\");\r\n            require (msg.value >= 0.1 ether, \"Minimum 0,1 ether for transaction all CrowdSale period\");\r\n        }\r\n        \r\n        tokens = tokens.add(tokens.mul(setBonus()).div(100));\r\n        token.transfer(msg.sender, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    function() external payable {\r\n        if (_saleTokens()) {\r\n            _withdrawProfit();\r\n        }\r\n    }    \r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"hostingProfitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromPartnersAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"acceptTokensFromUsers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdAddress1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromTeamAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"setBonus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unBlockExternalTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setHostingProfitAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdAddress3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingProfitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setNeironixProfitAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setLawSupportProfitAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saasApiProfitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdAddress5\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamProfitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setContractorsProfitAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromBountyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractorsProfitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newInvestor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromProjectFundAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lawSupportProfitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromAdvisorsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishCrowdSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdAddress4\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"neironixProfitAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setSaasApiProfitAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"blockExternalTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMarketingProfitAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTeamProfitAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint8\"}],\"name\":\"LogStateSwitch\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e3d324e068235256867c4115b91039141f866caeed959fee242b2eaafa38857d"}]}