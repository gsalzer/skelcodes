{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts\\CloneFactory.sol\r\n\r\n/**\r\n*This contracts helps clone factories and swaps through the Deployer.sol and MasterDeployer.sol.\r\n*The address of the targeted contract to clone has to be provided.\r\n*/\r\ncontract CloneFactory {\r\n\r\n    /*Variables*/\r\n    address internal owner;\r\n    \r\n    /*Events*/\r\n    event CloneCreated(address indexed target, address clone);\r\n\r\n    /*Modifiers*/\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    /*Functions*/\r\n    constructor() public{\r\n        owner = msg.sender;\r\n    }    \r\n    \r\n    /**\r\n    *@dev Allows the owner to set a new owner address\r\n    *@param _owner the new owner address\r\n    */\r\n    function setOwner(address _owner) public onlyOwner(){\r\n        owner = _owner;\r\n    }\r\n\r\n    /**\r\n    *@dev Creates factory clone\r\n    *@param _target is the address being cloned\r\n    *@return address for clone\r\n    */\r\n    function createClone(address target) internal returns (address result) {\r\n        bytes memory clone = hex\"600034603b57603080600f833981f36000368180378080368173bebebebebebebebebebebebebebebebebebebebe5af43d82803e15602c573d90f35b3d90fd\";\r\n        bytes20 targetBytes = bytes20(target);\r\n        for (uint i = 0; i < 20; i++) {\r\n            clone[26 + i] = targetBytes[i];\r\n        }\r\n        assembly {\r\n            let len := mload(clone)\r\n            let data := add(clone, 0x20)\r\n            result := create(0, data, len)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts\\interfaces\\DRCT_Token_Interface.sol\r\n\r\n//DRCT_Token functions - descriptions can be found in DRCT_Token.sol\r\ninterface DRCT_Token_Interface {\r\n  function addressCount(address _swap) external constant returns (uint);\r\n  function getBalanceAndHolderByIndex(uint _ind, address _swap) external constant returns (uint, address);\r\n  function getIndexByAddress(address _owner, address _swap) external constant returns (uint);\r\n  function createToken(uint _supply, address _owner, address _swap) external;\r\n  function getFactoryAddress() external view returns(address);\r\n  function pay(address _party, address _swap) external;\r\n  function partyCount(address _swap) external constant returns(uint);\r\n}\r\n\r\n// File: contracts\\interfaces\\ERC20_Interface.sol\r\n\r\n//ERC20 function interface\r\ninterface ERC20_Interface {\r\n  function totalSupply() external constant returns (uint);\r\n  function balanceOf(address _owner) external constant returns (uint);\r\n  function transfer(address _to, uint _amount) external returns (bool);\r\n  function transferFrom(address _from, address _to, uint _amount) external returns (bool);\r\n  function approve(address _spender, uint _amount) external returns (bool);\r\n  function allowance(address _owner, address _spender) external constant returns (uint);\r\n}\r\n\r\n// File: contracts\\interfaces\\Factory_Interface.sol\r\n\r\n//Swap factory functions - descriptions can be found in Factory.sol\r\ninterface Factory_Interface {\r\n  function createToken(uint _supply, address _party, uint _start_date) external returns (address,address, uint);\r\n  function payToken(address _party, address _token_add) external;\r\n  function deployContract(uint _start_date) external payable returns (address);\r\n   function getBase() external view returns(address);\r\n  function getVariables() external view returns (address, uint, uint, address,uint);\r\n  function isWhitelisted(address _member) external view returns (bool);\r\n}\r\n\r\n// File: contracts\\interfaces\\Oracle_Interface.sol\r\n\r\n//Swap Oracle functions - descriptions can be found in Oracle.sol\r\ninterface Oracle_Interface{\r\n  function getQuery(uint _date) external view returns(bool);\r\n  function retrieveData(uint _date) external view returns (uint);\r\n  function pushData() external payable;\r\n}\r\n\r\n// File: contracts\\libraries\\SafeMath.sol\r\n\r\n//Slightly modified SafeMath library - includes a min function\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n  function min(uint a, uint b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n// File: contracts\\libraries\\TokenLibrary.sol\r\n\r\n/**\r\n*The TokenLibrary contains the reference code used to create the specific DRCT base contract \r\n*that holds the funds of the contract and redistributes them based upon the change in the\r\n*underlying values\r\n*/\r\n\r\nlibrary TokenLibrary{\r\n\r\n    using SafeMath for uint256;\r\n\r\n    /*Variables*/\r\n    enum SwapState {\r\n        created,\r\n        started,\r\n        ended\r\n    }\r\n    \r\n    /*Structs*/\r\n    struct SwapStorage{\r\n        //The Oracle address (check for list at www.github.com/DecentralizedDerivatives/Oracles)\r\n        address oracle_address;\r\n        //Address of the Factory that created this contract\r\n        address factory_address;\r\n        Factory_Interface factory;\r\n        address creator;\r\n        //Addresses of ERC20 token\r\n        address token_address;\r\n        ERC20_Interface token;\r\n        //Enum state of the swap\r\n        SwapState current_state;\r\n        //Start date, end_date, multiplier duration,start_value,end_value,fee\r\n        uint[8] contract_details;\r\n        // pay_to_x refers to the amount of the base token (a or b) to pay to the long or short side based upon the share_long and share_short\r\n        uint pay_to_long;\r\n        uint pay_to_short;\r\n        //Address of created long and short DRCT tokens\r\n        address long_token_address;\r\n        address short_token_address;\r\n        //Number of DRCT Tokens distributed to both parties\r\n        uint num_DRCT_tokens;\r\n        //The notional that the payment is calculated on from the change in the reference rate\r\n        uint token_amount;\r\n        address userContract;\r\n    }\r\n\r\n    /*Events*/\r\n    event SwapCreation(address _token_address, uint _start_date, uint _end_date, uint _token_amount);\r\n    //Emitted when the swap has been paid out\r\n    event PaidOut(uint pay_to_long, uint pay_to_short);\r\n\r\n    /*Functions*/\r\n    /**\r\n    *@dev Acts the constructor function in the cloned swap\r\n    *@param _factory_address\r\n    *@param _creator address of swap creator\r\n    *@param _userContract address\r\n    *@param _start_date swap start date\r\n    */\r\n    function startSwap (SwapStorage storage self, address _factory_address, address _creator, address _userContract, uint _start_date) internal {\r\n        require(self.creator == address(0));\r\n        self.creator = _creator;\r\n        self.factory_address = _factory_address;\r\n        self.userContract = _userContract;\r\n        self.contract_details[0] = _start_date;\r\n        self.current_state = SwapState.created;\r\n        self.contract_details[7] = 0;\r\n    }\r\n\r\n    /**\r\n    *@dev A getter function for retriving standardized variables from the factory contract\r\n    *@return \r\n    *[userContract, Long Token addresss, short token address, oracle address, base token address], number DRCT tokens, , multiplier, duration, Start date, end_date\r\n    */\r\n    function showPrivateVars(SwapStorage storage self) internal view returns (address[5],uint, uint, uint, uint, uint){\r\n        return ([self.userContract, self.long_token_address,self.short_token_address, self.oracle_address, self.token_address], self.num_DRCT_tokens, self.contract_details[2], self.contract_details[3], self.contract_details[0], self.contract_details[1]);\r\n    }\r\n\r\n    /**\r\n    *@dev Allows the sender to create the terms for the swap\r\n    *@param _amount Amount of Token that should be deposited for the notional\r\n    *@param _senderAdd States the owner of this side of the contract (does not have to be msg.sender)\r\n    */\r\n    function createSwap(SwapStorage storage self,uint _amount, address _senderAdd) internal{\r\n       require(self.current_state == SwapState.created && msg.sender == self.creator  && _amount > 0 || (msg.sender == self.userContract && _senderAdd == self.creator) && _amount > 0);\r\n        self.factory = Factory_Interface(self.factory_address);\r\n        getVariables(self);\r\n        self.contract_details[1] = self.contract_details[0].add(self.contract_details[3].mul(86400));\r\n        assert(self.contract_details[1]-self.contract_details[0] < 28*86400);\r\n        self.token_amount = _amount;\r\n        self.token = ERC20_Interface(self.token_address);\r\n        assert(self.token.balanceOf(address(this)) == SafeMath.mul(_amount,2));\r\n        uint tokenratio = 1;\r\n        (self.long_token_address,self.short_token_address,tokenratio) = self.factory.createToken(self.token_amount,self.creator,self.contract_details[0]);\r\n        self.num_DRCT_tokens = self.token_amount.div(tokenratio);\r\n        emit SwapCreation(self.token_address,self.contract_details[0],self.contract_details[1],self.token_amount);\r\n        self.current_state = SwapState.started;\r\n    }\r\n\r\n    /**\r\n    *@dev Getter function for contract details saved in the SwapStorage struct\r\n    *Gets the oracle address, duration, multiplier, base token address, and fee\r\n    *and from the Factory.getVariables function.\r\n    */\r\n    function getVariables(SwapStorage storage self) internal{\r\n        (self.oracle_address,self.contract_details[3],self.contract_details[2],self.token_address,self.contract_details[6]) = self.factory.getVariables();\r\n    }\r\n\r\n    /**\r\n    *@dev check if the oracle has been queried within the last day \r\n    *@return true if it was queried and the start and end values are not zero\r\n    *and false if they are.\r\n    */\r\n    function oracleQuery(SwapStorage storage self) internal returns(bool){\r\n        Oracle_Interface oracle = Oracle_Interface(self.oracle_address);\r\n        uint _today = now - (now % 86400);\r\n        uint i = 0;\r\n        if(_today >= self.contract_details[0]){\r\n            while(i <= (_today- self.contract_details[0])/86400 && self.contract_details[4] == 0){\r\n                if(oracle.getQuery(self.contract_details[0]+i*86400)){\r\n                    self.contract_details[4] = oracle.retrieveData(self.contract_details[0]+i*86400);\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n        i = 0;\r\n        if(_today >= self.contract_details[1]){\r\n            while(i <= (_today- self.contract_details[1])/86400 && self.contract_details[5] == 0){\r\n                if(oracle.getQuery(self.contract_details[1]+i*86400)){\r\n                    self.contract_details[5] = oracle.retrieveData(self.contract_details[1]+i*86400);\r\n                }\r\n                i++;\r\n            }\r\n        }\r\n        if(self.contract_details[4] != 0 && self.contract_details[5] != 0){\r\n            return true;\r\n        }\r\n        else{\r\n            return false;\r\n        }\r\n    }\r\n\r\n    /**\r\n    *@dev This function calculates the payout of the swap. It can be called after the Swap has been tokenized.\r\n    *The value of the underlying cannot reach zero, but rather can only get within 0.001 * the precision\r\n    *of the Oracle.\r\n    */\r\n    function Calculate(SwapStorage storage self) internal{\r\n        uint ratio;\r\n        self.token_amount = self.token_amount.mul(10000-self.contract_details[6]).div(10000);\r\n        if (self.contract_details[4] > 0 && self.contract_details[5] > 0)\r\n            ratio = (self.contract_details[5]).mul(100000).div(self.contract_details[4]);\r\n            if (ratio > 100000){\r\n                ratio = (self.contract_details[2].mul(ratio - 100000)).add(100000);\r\n            }\r\n            else if (ratio < 100000){\r\n                    ratio = SafeMath.min(100000,(self.contract_details[2].mul(100000-ratio)));\r\n                    ratio = 100000 - ratio;\r\n            }\r\n        else if (self.contract_details[5] > 0)\r\n            ratio = 10e10;\r\n        else if (self.contract_details[4] > 0)\r\n            ratio = 0;\r\n        else\r\n            ratio = 100000;\r\n        ratio = SafeMath.min(200000,ratio);\r\n        self.pay_to_long = (ratio.mul(self.token_amount)).div(self.num_DRCT_tokens).div(100000);\r\n        self.pay_to_short = (SafeMath.sub(200000,ratio).mul(self.token_amount)).div(self.num_DRCT_tokens).div(100000);\r\n    }\r\n\r\n    /**\r\n    *@dev This function can be called after the swap is tokenized or after the Calculate function is called.\r\n    *If the Calculate function has not yet been called, this function will call it.\r\n    *The function then pays every token holder of both the long and short DRCT tokens\r\n    *@param _numtopay number of contracts to try and pay (run it again if its not enough)\r\n    *@return true if the oracle was called and all contracts are paid or false ?\r\n    */\r\n    function forcePay(SwapStorage storage self,uint _numtopay) internal returns (bool) {\r\n       //Calls the Calculate function first to calculate short and long shares\r\n        require(self.current_state == SwapState.started && now >= self.contract_details[1]);\r\n        bool ready = oracleQuery(self);\r\n        if(ready){\r\n            Calculate(self);\r\n            //Loop through the owners of long and short DRCT tokens and pay them\r\n            DRCT_Token_Interface drct = DRCT_Token_Interface(self.long_token_address);\r\n            uint[6] memory counts;\r\n            address token_owner;\r\n            counts[0] = drct.addressCount(address(this));\r\n            counts[1] = counts[0] <= self.contract_details[7].add(_numtopay) ? counts[0] : self.contract_details[7].add(_numtopay).add(1);\r\n            //Indexing begins at 1 for DRCT_Token balances\r\n            if(self.contract_details[7] < counts[1]){\r\n                for(uint i = counts[1]-1; i > self.contract_details[7] ; i--) {\r\n                    (counts[4], token_owner) = drct.getBalanceAndHolderByIndex(i, address(this));\r\n                    paySwap(self,token_owner,counts[4], true);\r\n                }\r\n            }\r\n\r\n            drct = DRCT_Token_Interface(self.short_token_address);\r\n            counts[2] = drct.addressCount(address(this));\r\n            counts[3] = counts[2] <= self.contract_details[7].add(_numtopay) ? counts[2] : self.contract_details[7].add(_numtopay).add(1);\r\n            if(self.contract_details[7] < counts[3]){\r\n                for(uint j = counts[3]-1; j > self.contract_details[7] ; j--) {\r\n                    (counts[5], token_owner) = drct.getBalanceAndHolderByIndex(j, address(this));\r\n                    paySwap(self,token_owner,counts[5], false);\r\n                }\r\n            }\r\n            if (counts[0] == counts[1] && counts[2] == counts[3]){\r\n                self.token.transfer(self.factory_address, self.token.balanceOf(address(this)));\r\n                emit PaidOut(self.pay_to_long,self.pay_to_short);\r\n                self.current_state = SwapState.ended;\r\n            }\r\n            self.contract_details[7] = self.contract_details[7].add(_numtopay);\r\n        }\r\n        return ready;\r\n    }\r\n\r\n    /**\r\n    *This function pays the receiver an amount determined by the Calculate function\r\n    *@param _receiver is the recipient of the payout\r\n    *@param _amount is the amount of token the recipient holds\r\n    *@param _is_long is true if the reciever holds a long token\r\n    */\r\n    function paySwap(SwapStorage storage self,address _receiver, uint _amount, bool _is_long) internal {\r\n        if (_is_long) {\r\n            if (self.pay_to_long > 0){\r\n                self.token.transfer(_receiver, _amount.mul(self.pay_to_long));\r\n                self.factory.payToken(_receiver,self.long_token_address);\r\n            }\r\n        } else {\r\n            if (self.pay_to_short > 0){\r\n                self.token.transfer(_receiver, _amount.mul(self.pay_to_short));\r\n                self.factory.payToken(_receiver,self.short_token_address);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    *@dev Getter function for swap state\r\n    *@return current state of swap\r\n    */\r\n    function showCurrentState(SwapStorage storage self)  internal view returns(uint) {\r\n        return uint(self.current_state);\r\n    }\r\n    \r\n}\r\n\r\n// File: contracts\\TokenToTokenSwap.sol\r\n\r\n/**\r\n*This contract is the specific DRCT base contract that holds the funds of the contract and\r\n*redistributes them based upon the change in the underlying values\r\n*/\r\n\r\ncontract TokenToTokenSwap {\r\n\r\n    using TokenLibrary for TokenLibrary.SwapStorage;\r\n\r\n    /*Variables*/\r\n    TokenLibrary.SwapStorage public swap;\r\n\r\n\r\n    /*Functions*/\r\n    /**\r\n    *@dev Constructor - Run by the factory at contract creation\r\n    *@param _factory_address address of the factory that created this contract\r\n    *@param _creator address of the person who created the contract\r\n    *@param _userContract address of the _userContract that is authorized to interact with this contract\r\n    *@param _start_date start date of the contract\r\n    */\r\n    constructor (address _factory_address, address _creator, address _userContract, uint _start_date) public {\r\n        swap.startSwap(_factory_address,_creator,_userContract,_start_date);\r\n    }\r\n    \r\n    /**\r\n    *@dev Acts as a constructor when cloning the swap\r\n    *@param _factory_address address of the factory that created this contract\r\n    *@param _creator address of the person who created the contract\r\n    *@param _userContract address of the _userContract that is authorized to interact with this contract\r\n    *@param _start_date start date of the contract\r\n    */\r\n    function init (address _factory_address, address _creator, address _userContract, uint _start_date) public {\r\n        swap.startSwap(_factory_address,_creator,_userContract,_start_date);\r\n    }\r\n\r\n    /**\r\n    *@dev A getter function for retriving standardized variables from the factory contract\r\n    *@return \r\n    *[userContract, Long Token addresss, short token address, oracle address, base token address], number DRCT tokens, , multiplier, duration, Start date, end_date\r\n    */\r\n    function showPrivateVars() public view returns (address[5],uint, uint, uint, uint, uint){\r\n        return swap.showPrivateVars();\r\n    }\r\n\r\n    /**\r\n    *@dev A getter function for retriving current swap state from the factory contract\r\n    *@return current state (References swapState Enum: 1=created, 2=started, 3=ended)\r\n    */\r\n    function currentState() public view returns(uint){\r\n        return swap.showCurrentState();\r\n    }\r\n\r\n    /**\r\n    *@dev Allows the sender to create the terms for the swap\r\n    *@param _amount Amount of Token that should be deposited for the notional\r\n    *@param _senderAdd States the owner of this side of the contract (does not have to be msg.sender)\r\n    */\r\n    function createSwap(uint _amount, address _senderAdd) public {\r\n        swap.createSwap(_amount,_senderAdd);\r\n    }\r\n\r\n    /**\r\n    *@dev This function can be called after the swap is tokenized or after the Calculate function is called.\r\n    *If the Calculate function has not yet been called, this function will call it.\r\n    *The function then pays every token holder of both the long and short DRCT tokens\r\n    *@param _topay number of contracts to try and pay (run it again if its not enough)\r\n    *@return true if the oracle was called and all contracts were paid out or false once ?\r\n    */\r\n    function forcePay(uint _topay) public returns (bool) {\r\n       swap.forcePay(_topay);\r\n    }\r\n\r\n\r\n}\r\n\r\n// File: contracts\\Deployer.sol\r\n\r\n/**\r\n*Swap Deployer Contract - purpose is to save gas for deployment of Factory contract.\r\n*It ensures only the factory can create new contracts and uses CloneFactory to clone \r\n*the swap specified.\r\n*/\r\n\r\ncontract Deployer is CloneFactory {\r\n    /*Variables*/\r\n    address internal factory;\r\n    address public swap;\r\n    \r\n    /*Events*/\r\n    event Deployed(address indexed master, address indexed clone);\r\n\r\n    /*Functions*/\r\n    /**\r\n    *@dev Deploys the factory contract and swap address\r\n    *@param _factory is the address of the factory contract\r\n    */    \r\n    constructor(address _factory) public {\r\n        factory = _factory;\r\n        swap = new TokenToTokenSwap(address(this),msg.sender,address(this),now);\r\n    }\r\n\r\n    /**\r\n    *@dev Set swap address to clone\r\n    *@param _addr swap address to clone\r\n    */\r\n    function updateSwap(address _addr) public onlyOwner() {\r\n        swap = _addr;\r\n    }\r\n        \r\n    /**\r\n    *@notice The function creates a new contract\r\n    *@dev It ensures the new contract can only be created by the factory\r\n    *@param _party address of user creating the contract\r\n    *@param user_contract address of userContract.sol \r\n    *@param _start_date contract start date\r\n    *@return returns the address for the new contract\r\n    */\r\n    function newContract(address _party, address _user, uint _start) public returns (address) {\r\n        address new_swap = createClone(swap);\r\n        TokenToTokenSwap(new_swap).init(factory, _party, _user, _start);\r\n        emit Deployed(swap, new_swap);\r\n        return new_swap;\r\n    }\r\n\r\n    /**\r\n    *@dev Set variables if the owner is the factory contract\r\n    *@param _factory address\r\n    *@param _owner address\r\n    */\r\n    function setVars(address _factory, address _owner) public {\r\n        require (msg.sender == owner);\r\n        factory = _factory;\r\n        owner = _owner;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_party\",\"type\":\"address\"},{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_start\",\"type\":\"uint256\"}],\"name\":\"newContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"swap\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"updateSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"setVars\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_factory\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"master\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"Deployed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"clone\",\"type\":\"address\"}],\"name\":\"CloneCreated\",\"type\":\"event\"}]","ContractName":"Deployer","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009bcf387637c128d319320a9be43daea349f29028","Library":"","SwarmSource":"bzzr://002925b7dd474074e6baed5da684d48f3964993d36ff459e81f564de80bda1a5"}]}