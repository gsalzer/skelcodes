{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\n\r\n\r\n// @title iNovaStaking\r\n// @dev The interface for cross-contract calls to the Nova Staking contract\r\n// @author Dragon Foundry (https://www.nvt.gg)\r\n// (c) 2018 Dragon Foundry LLC. All Rights Reserved. This code is not open source.\r\ncontract iNovaStaking {\r\n\r\n  function balanceOf(address _owner) public view returns (uint256);\r\n}\r\n\r\n\r\n\r\n// @title iNovaGame\r\n// @dev The interface for cross-contract calls to the Nova Game contract\r\n// @author Dragon Foundry (https://www.nvt.gg)\r\n// (c) 2018 Dragon Foundry LLC. All Rights Reserved. This code is not open source.\r\ncontract iNovaGame {\r\n  function isAdminForGame(uint _game, address account) external view returns(bool);\r\n\r\n  // List of all games tracked by the Nova Game contract\r\n  uint[] public games;\r\n}\r\n\r\n\r\n\r\n// @title SafeMath\r\n// @dev Math operations with safety checks that throw on error\r\nlibrary SafeMath {\r\n\r\n  // @dev Multiplies two numbers, throws on overflow.\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    require(c / a == b, \"mul failed\");\r\n    return c;\r\n  }\r\n\r\n  // @dev Integer division of two numbers, truncating the quotient.\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a, \"sub fail\");\r\n    return a - b;\r\n  }\r\n\r\n  // @dev Adds two numbers, throws on overflow.\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    require(c >= a, \"add fail\");\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n// @title Nova Game Access (Nova Token Game Access Control)\r\n// @dev NovaGame contract for controlling access to games, and allowing managers to add and remove operator accounts\r\n// @author Dragon Foundry (https://www.nvt.gg)\r\n// (c) 2018 Dragon Foundry LLC. All Rights Reserved. This code is not open source.\r\ncontract NovaGameAccess is iNovaGame {\r\n  using SafeMath for uint256;\r\n\r\n  event AdminPrivilegesChanged(uint indexed game, address indexed account, bool isAdmin);\r\n  event OperatorPrivilegesChanged(uint indexed game, address indexed account, bool isAdmin);\r\n\r\n  // Admin addresses are stored both by gameId and address\r\n  mapping(uint => address[]) public adminAddressesByGameId; \r\n  mapping(address => uint[]) public gameIdsByAdminAddress;\r\n\r\n  // Stores admin status (as a boolean) by gameId and account\r\n  mapping(uint => mapping(address => bool)) public gameAdmins;\r\n\r\n  // Reference to the Nova Staking contract\r\n  iNovaStaking public stakingContract;\r\n\r\n  // @dev Access control modifier to limit access to game admin accounts\r\n  modifier onlyGameAdmin(uint _game) {\r\n    require(gameAdmins[_game][msg.sender]);\r\n    _;\r\n  }\r\n\r\n  constructor(address _stakingContract)\r\n    public\r\n  {\r\n    stakingContract = iNovaStaking(_stakingContract);\r\n  }\r\n\r\n  // @dev gets the admin status for a game & account\r\n  // @param _game - the gameId of the game\r\n  // @param _account - the address of the user\r\n  // @returns bool - the admin status of the requested account for the requested game\r\n  function isAdminForGame(uint _game, address _account)\r\n    external\r\n    view\r\n  returns(bool) {\r\n    return gameAdmins[_game][_account];\r\n  }\r\n\r\n  // @dev gets the list of admins for a game\r\n  // @param _game - the gameId of the game\r\n  // @returns address[] - the list of admin addresses for the requested game\r\n  function getAdminsForGame(uint _game) \r\n    external\r\n    view\r\n  returns(address[]) {\r\n    return adminAddressesByGameId[_game];\r\n  }\r\n\r\n  // @dev gets the list of games that the requested account is the admin of\r\n  // @param _account - the address of the user\r\n  // @returns uint[] - the list of game Ids for the requested account\r\n  function getGamesForAdmin(address _account) \r\n    external\r\n    view\r\n  returns(uint[]) {\r\n    return gameIdsByAdminAddress[_account];\r\n  }\r\n\r\n  // @dev Adds an address as an admin for a game\r\n  // @notice Can only be called by an admin of the game\r\n  // @param _game - the gameId of the game\r\n  // @param _account - the address of the user\r\n  function addAdminAccount(uint _game, address _account)\r\n    external\r\n    onlyGameAdmin(_game)\r\n  {\r\n    require(_account != msg.sender);\r\n    require(_account != address(0));\r\n    require(!gameAdmins[_game][_account]);\r\n    _addAdminAccount(_game, _account);\r\n  }\r\n\r\n  // @dev Removes an address from an admin for a game\r\n  // @notice Can only be called by an admin of the game.\r\n  // @notice Can't remove your own account's admin privileges.\r\n  // @param _game - the gameId of the game\r\n  // @param _account - the address of the user to remove admin privileges.\r\n  function removeAdminAccount(uint _game, address _account)\r\n    external\r\n    onlyGameAdmin(_game)\r\n  {\r\n    require(_account != msg.sender);\r\n    require(gameAdmins[_game][_account]);\r\n    \r\n    address[] storage opsAddresses = adminAddressesByGameId[_game];\r\n    uint startingLength = opsAddresses.length;\r\n    // Yes, \"i < startingLength\" is right. 0 - 1 == uint.maxvalue, not -1.\r\n    for (uint i = opsAddresses.length - 1; i < startingLength; i--) {\r\n      if (opsAddresses[i] == _account) {\r\n        uint newLength = opsAddresses.length.sub(1);\r\n        opsAddresses[i] = opsAddresses[newLength];\r\n        delete opsAddresses[newLength];\r\n        opsAddresses.length = newLength;\r\n      }\r\n    }\r\n\r\n    uint[] storage gamesByAdmin = gameIdsByAdminAddress[_account];\r\n    startingLength = gamesByAdmin.length;\r\n    for (i = gamesByAdmin.length - 1; i < startingLength; i--) {\r\n      if (gamesByAdmin[i] == _game) {\r\n        newLength = gamesByAdmin.length.sub(1);\r\n        gamesByAdmin[i] = gamesByAdmin[newLength];\r\n        delete gamesByAdmin[newLength];\r\n        gamesByAdmin.length = newLength;\r\n      }\r\n    }\r\n\r\n    gameAdmins[_game][_account] = false;\r\n    emit AdminPrivilegesChanged(_game, _account, false);\r\n  }\r\n\r\n  // @dev Adds an address as an admin for a game\r\n  // @notice Can only be called by an admin of the game\r\n  // @notice Operator privileges are managed on the layer 2 network\r\n  // @param _game - the gameId of the game\r\n  // @param _account - the address of the user to\r\n  // @param _isOperator - \"true\" to grant operator privileges, \"false\" to remove them\r\n  function setOperatorPrivileges(uint _game, address _account, bool _isOperator)\r\n    external\r\n    onlyGameAdmin(_game)\r\n  {\r\n    emit OperatorPrivilegesChanged(_game, _account, _isOperator);\r\n  }\r\n\r\n  // @dev Internal function to add an address as an admin for a game\r\n  // @param _game - the gameId of the game\r\n  // @param _account - the address of the user\r\n  function _addAdminAccount(uint _game, address _account)\r\n    internal\r\n  {\r\n    address[] storage opsAddresses = adminAddressesByGameId[_game];\r\n    require(opsAddresses.length < 256, \"a game can only have 256 admins\");\r\n    for (uint i = opsAddresses.length; i < opsAddresses.length; i--) {\r\n      require(opsAddresses[i] != _account);\r\n    }\r\n\r\n    uint[] storage gamesByAdmin = gameIdsByAdminAddress[_account];\r\n    require(gamesByAdmin.length < 256, \"you can only own 256 games\");\r\n    for (i = gamesByAdmin.length; i < gamesByAdmin.length; i--) {\r\n      require(gamesByAdmin[i] != _game, \"you can't become an operator twice\");\r\n    }\r\n    gamesByAdmin.push(_game);\r\n\r\n    opsAddresses.push(_account);\r\n    gameAdmins[_game][_account] = true;\r\n    emit AdminPrivilegesChanged(_game, _account, true);\r\n  }\r\n}\r\n\r\n\r\n// @title Nova Game (Nova Token Game Data)\r\n// @dev NovaGame contract for managing all game data\r\n// @author Dragon Foundry (https://www.nvt.gg)\r\n// (c) 2018 Dragon Foundry LLC. All Rights Reserved. This code is not open source.\r\ncontract NovaGame is NovaGameAccess {\r\n\r\n  struct GameData {\r\n    string json;\r\n    uint tradeLockSeconds;\r\n    bytes32[] metadata;\r\n  }\r\n\r\n  event GameCreated(uint indexed game, address indexed owner, string json, bytes32[] metadata);\r\n\r\n  event GameMetadataUpdated(\r\n    uint indexed game, \r\n    string json,\r\n    uint tradeLockSeconds, \r\n    bytes32[] metadata\r\n  );\r\n\r\n  mapping(uint => GameData) internal gameData;\r\n\r\n  constructor(address _stakingContract) \r\n    public \r\n    NovaGameAccess(_stakingContract)\r\n  {\r\n    games.push(2**32);\r\n  }\r\n\r\n  // @dev Create a new game by setting its data. \r\n  //   Created games are initially owned and managed by the game's creator\r\n  // @notice - there's a maximum of 2^32 games (4.29 billion games)\r\n  // @param _json - a json encoded string containing the game's name, uri, logo, description, etc\r\n  // @param _tradeLockSeconds - the number of seconds a card remains locked to a purchaser's account\r\n  // @param _metadata - game-specific metadata, in bytes32 format. \r\n  function createGame(string _json, uint _tradeLockSeconds, bytes32[] _metadata) \r\n    external\r\n  returns(uint _game) {\r\n    // Create the game\r\n    _game = games.length;\r\n    require(_game < games[0], \"too many games created\");\r\n    games.push(_game);\r\n\r\n    // Log the game as created\r\n    emit GameCreated(_game, msg.sender, _json, _metadata);\r\n\r\n    // Add the creator as the first game admin\r\n    _addAdminAccount(_game, msg.sender);\r\n\r\n    // Store the game's metadata\r\n    updateGameMetadata(_game, _json, _tradeLockSeconds, _metadata);\r\n  }\r\n\r\n  // @dev Gets the number of games in the system\r\n  // @returns the number of games stored in the system\r\n  function numberOfGames() \r\n    external\r\n    view\r\n  returns(uint) {\r\n    return games.length;\r\n  }\r\n\r\n  // @dev Get all game data for one given game\r\n  // @param _game - the # of the game\r\n  // @returns game - the game ID of the requested game\r\n  // @returns json - the json data of the game\r\n  // @returns tradeLockSeconds - the number of card sets\r\n  // @returns balance - the Nova Token balance \r\n  // @returns metadata - a bytes32 array of metadata used by the game\r\n  function getGameData(uint _game)\r\n    external\r\n    view\r\n  returns(uint game,\r\n    string json,\r\n    uint tradeLockSeconds,\r\n    uint256 balance,\r\n    bytes32[] metadata) \r\n  {\r\n    GameData storage data = gameData[_game];\r\n    game = _game;\r\n    json = data.json;\r\n    tradeLockSeconds = data.tradeLockSeconds;\r\n    balance = stakingContract.balanceOf(address(_game));\r\n    metadata = data.metadata;\r\n  }\r\n\r\n  // @dev Update the json, trade lock, and metadata for a single game\r\n  // @param _game - the # of the game\r\n  // @param _json - a json encoded string containing the game's name, uri, logo, description, etc\r\n  // @param _tradeLockSeconds - the number of seconds a card remains locked to a purchaser's account\r\n  // @param _metadata - game-specific metadata, in bytes32 format. \r\n  function updateGameMetadata(uint _game, string _json, uint _tradeLockSeconds, bytes32[] _metadata)\r\n    public\r\n    onlyGameAdmin(_game)\r\n  {\r\n    gameData[_game].tradeLockSeconds = _tradeLockSeconds;\r\n    gameData[_game].json = _json;\r\n\r\n    bytes32[] storage data = gameData[_game].metadata;\r\n    if (_metadata.length > data.length) { data.length = _metadata.length; }\r\n    for (uint k = 0; k < _metadata.length; k++) { data[k] = _metadata[k]; }\r\n    for (k; k < data.length; k++) { delete data[k]; }\r\n    if (_metadata.length < data.length) { data.length = _metadata.length; }\r\n\r\n    emit GameMetadataUpdated(_game, _json, _tradeLockSeconds, _metadata);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"gameIdsByAdminAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_game\",\"type\":\"uint256\"},{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_isOperator\",\"type\":\"bool\"}],\"name\":\"setOperatorPrivileges\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"adminAddressesByGameId\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameAdmins\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_json\",\"type\":\"string\"},{\"name\":\"_tradeLockSeconds\",\"type\":\"uint256\"},{\"name\":\"_metadata\",\"type\":\"bytes32[]\"}],\"name\":\"createGame\",\"outputs\":[{\"name\":\"_game\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"getGamesForAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_game\",\"type\":\"uint256\"},{\"name\":\"_json\",\"type\":\"string\"},{\"name\":\"_tradeLockSeconds\",\"type\":\"uint256\"},{\"name\":\"_metadata\",\"type\":\"bytes32[]\"}],\"name\":\"updateGameMetadata\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"getAdminsForGame\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_game\",\"type\":\"uint256\"}],\"name\":\"getGameData\",\"outputs\":[{\"name\":\"game\",\"type\":\"uint256\"},{\"name\":\"json\",\"type\":\"string\"},{\"name\":\"tradeLockSeconds\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"metadata\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_game\",\"type\":\"uint256\"},{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"removeAdminAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_game\",\"type\":\"uint256\"},{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"isAdminForGame\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_game\",\"type\":\"uint256\"},{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"addAdminAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfGames\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_stakingContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"json\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"metadata\",\"type\":\"bytes32[]\"}],\"name\":\"GameCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"json\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"tradeLockSeconds\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"metadata\",\"type\":\"bytes32[]\"}],\"name\":\"GameMetadataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"AdminPrivilegesChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"game\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isAdmin\",\"type\":\"bool\"}],\"name\":\"OperatorPrivilegesChanged\",\"type\":\"event\"}]","ContractName":"NovaGame","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000b590c2a26ee8663bb584d0e5b74b1631cca23720","Library":"","SwarmSource":"bzzr://9c88c09f228869b99ee127e7f9863f893d4d228db7f49d5a2422fcecd9a095c2"}]}