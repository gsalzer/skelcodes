{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/utils/ReentrancyGuard.sol\r\n\r\n/**\r\n * @title Helps contracts guard against reentrancy attacks.\r\n * @author Remco Bloemen <remco@2π.com>, Eenae <alexey@mixbytes.io>\r\n * @dev If you mark a function `nonReentrant`, you should also\r\n * mark it `external`.\r\n */\r\ncontract ReentrancyGuard {\r\n\r\n  /// @dev counter to allow mutex lock with only one SSTORE operation\r\n  uint256 private _guardCounter;\r\n\r\n  constructor() internal {\r\n    // The counter starts at one to prevent changing it from zero to a non-zero\r\n    // value, which is a more expensive operation.\r\n    _guardCounter = 1;\r\n  }\r\n\r\n  /**\r\n   * @dev Prevents a contract from calling itself, directly or indirectly.\r\n   * Calling a `nonReentrant` function from another `nonReentrant`\r\n   * function is not supported. It is possible to prevent this from happening\r\n   * by making the `nonReentrant` function external, and make it call a\r\n   * `private` function that does the actual work.\r\n   */\r\n  modifier nonReentrant() {\r\n    _guardCounter += 1;\r\n    uint256 localCounter = _guardCounter;\r\n    _;\r\n    require(localCounter == _guardCounter);\r\n  }\r\n\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/math/Safemath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: node_modules/openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: lib/CanReclaimToken.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20 compatible tokens\r\n   * @param token ERC20 The address of the token contract\r\n   */\r\n  function reclaimToken(IERC20 token) external onlyOwner {\r\n    if (address(token) == address(0)) {\r\n      owner().transfer(address(this).balance);\r\n      return;\r\n    }\r\n    uint256 balance = token.balanceOf(this);\r\n    token.transfer(owner(), balance);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/Mentoring.sol\r\n\r\ninterface HEROES {\r\n  function getLevel(uint256 tokenId) external view returns (uint256);\r\n  function getGenes(uint256 tokenId) external view returns (uint256);\r\n  function getRace(uint256 tokenId) external view returns (uint256);\r\n  function lock(uint256 tokenId, uint256 lockedTo, bool onlyFreeze) external returns (bool);\r\n  function unlock(uint256 tokenId) external returns (bool);\r\n  function ownerOf(uint256 tokenId) external view returns (address);\r\n  function isCallerAgentOf(uint tokenId) external view returns (bool);\r\n  function addWin(uint256 tokenId, uint winsCount, uint levelUp) external returns (bool);\r\n  function addLoss(uint256 tokenId, uint256 lossesCount, uint levelDown) external returns (bool);\r\n}\r\n\r\n\r\ncontract Mentoring is Ownable, ReentrancyGuard, CanReclaimToken  {\r\n  using SafeMath for uint256;\r\n\r\n  event BecomeMentor(uint256 indexed mentorId);\r\n  event BreakMentoring(uint256 indexed mentorId);\r\n  event ChangeLevelPrice(uint256 indexed mentorId, uint256 newLevelPrice);\r\n  event Income(address source, uint256 amount);\r\n\r\n  event StartLecture(uint256 indexed lectureId,\r\n    uint256 indexed mentorId,\r\n    uint256 indexed studentId,\r\n    uint256 mentorLevel,\r\n    uint256 studentLevel,\r\n    uint256 levelUp,\r\n    uint256 levelPrice,\r\n    uint256 startedAt,\r\n    uint256 endsAt);\r\n\r\n//  event Withdraw(address to, uint256 amount);\r\n\r\n  struct Lecture {\r\n    uint256 mentorId;\r\n    uint256 studentId;\r\n    uint256 mentorLevel;\r\n    uint256 studentLevel;\r\n    uint256 levelUp;\r\n    uint256 levelPrice;\r\n//    uint256 cost;\r\n    uint256 startedAt;\r\n    uint256 endsAt;\r\n  }\r\n\r\n  HEROES public heroes;\r\n\r\n  uint256 public fee = 290; //2.9%\r\n  uint256 public levelUpTime = 20 minutes;\r\n\r\n  mapping(uint256 => uint256) internal prices;\r\n\r\n  Lecture[] internal lectures;\r\n  /* tokenId => lecture index */\r\n  mapping(uint256 => uint256[]) studentToLecture;\r\n  mapping(uint256 => uint256[]) mentorToLecture;\r\n\r\n  modifier onlyOwnerOf(uint256 _tokenId) {\r\n    require(heroes.ownerOf(_tokenId) == msg.sender);\r\n    _;\r\n  }\r\n\r\n  constructor (HEROES _heroes) public {\r\n    require(address(_heroes) != address(0));\r\n    heroes = _heroes;\r\n\r\n    //fix lectureId issue - add zero lecture\r\n    lectures.length = 1;\r\n  }\r\n\r\n  /// @notice The fallback function payable\r\n  function() external payable {\r\n    require(msg.value > 0);\r\n    _flushBalance();\r\n  }\r\n\r\n  function _flushBalance() private {\r\n    uint256 balance = address(this).balance;\r\n    if (balance > 0) {\r\n      address(heroes).transfer(balance);\r\n      emit Income(address(this), balance);\r\n    }\r\n  }\r\n\r\n\r\n  function _distributePayment(address _account, uint256 _amount) internal {\r\n    uint256 pcnt = _getPercent(_amount, fee);\r\n    uint256 amount = _amount.sub(pcnt);\r\n    _account.transfer(amount);\r\n  }\r\n\r\n  /**\r\n   * Set fee\r\n   */\r\n  function setFee(uint256 _fee) external onlyOwner\r\n  {\r\n    fee = _fee;\r\n  }\r\n\r\n  // MENTORING\r\n\r\n  /**\r\n   * Set the one level up time\r\n   */\r\n\r\n  function setLevelUpTime(uint256 _newLevelUpTime) external onlyOwner\r\n  {\r\n    levelUpTime = _newLevelUpTime;\r\n  }\r\n\r\n  function isMentor(uint256 _mentorId) public view returns (bool)\r\n  {\r\n    //проверяем установлена ли цена обучения и текущий агент пресонажа =менторство\r\n    return heroes.isCallerAgentOf(_mentorId); // && prices[_mentorId] != 0;\r\n  }\r\n\r\n  function inStudying(uint256 _tokenId) public view returns (bool) {\r\n    return now <= lectures[getLastLectureIdAsStudent(_tokenId)].endsAt;\r\n  }\r\n\r\n  function inMentoring(uint256 _tokenId) public view returns (bool) {\r\n    return now <= lectures[getLastLectureIdAsMentor(_tokenId)].endsAt;\r\n  }\r\n\r\n  function inLecture(uint256 _tokenId) public view returns (bool)\r\n  {\r\n    return inMentoring(_tokenId) || inStudying(_tokenId);\r\n  }\r\n\r\n  /**\r\n   * Set the character as mentor\r\n   */\r\n  function becomeMentor(uint256 _mentorId, uint256 _levelPrice) external onlyOwnerOf(_mentorId) {\r\n    require(_levelPrice > 0);\r\n    require(heroes.lock(_mentorId, 0, false));\r\n    prices[_mentorId] = _levelPrice;\r\n    emit BecomeMentor(_mentorId);\r\n    emit ChangeLevelPrice(_mentorId, _levelPrice);\r\n  }\r\n\r\n  /**\r\n   * Change price\r\n   */\r\n  function changeLevelPrice(uint256 _mentorId, uint256 _levelPrice) external onlyOwnerOf(_mentorId) {\r\n    require(_levelPrice > 0);\r\n    require(isMentor(_mentorId));\r\n    prices[_mentorId] = _levelPrice;\r\n    emit ChangeLevelPrice(_mentorId, _levelPrice);\r\n  }\r\n\r\n  /**\r\n   * Break mentoring for character\r\n   */\r\n  function breakMentoring(uint256 _mentorId) external onlyOwnerOf(_mentorId)\r\n  {\r\n    require(heroes.unlock(_mentorId));\r\n    emit BreakMentoring(_mentorId);\r\n  }\r\n\r\n  function getMentor(uint256 _mentorId) external view returns (uint256 level, uint256 price) {\r\n    require(isMentor(_mentorId));\r\n    return (heroes.getLevel(_mentorId), prices[_mentorId]);\r\n  }\r\n\r\n  function _calcLevelIncrease(uint256 _mentorLevel, uint256 _studentLevel) internal pure returns (uint256) {\r\n    if (_mentorLevel < _studentLevel) {\r\n      return 0;\r\n    }\r\n    uint256 levelDiff = _mentorLevel - _studentLevel;\r\n    return (levelDiff >> 1) + (levelDiff & 1);\r\n  }\r\n\r\n  /**\r\n   * calc full cost of study\r\n   */\r\n  function calcCost(uint256 _mentorId, uint256 _studentId) external view returns (uint256) {\r\n    uint256 levelUp = _calcLevelIncrease(heroes.getLevel(_mentorId), heroes.getLevel(_studentId));\r\n    return levelUp.mul(prices[_mentorId]);\r\n  }\r\n\r\n  function isRaceSuitable(uint256 _mentorId, uint256 _studentId) public view returns (bool) {\r\n    uint256 mentorRace = heroes.getGenes(_mentorId) & 0xFFFF;\r\n    uint256 studentRace = heroes.getGenes(_studentId) & 0xFFFF;\r\n    return (mentorRace == 1 || mentorRace == studentRace);\r\n  }\r\n\r\n  /**\r\n   * Start the study\r\n   */\r\n  function startLecture(uint256 _mentorId, uint256 _studentId) external payable onlyOwnerOf(_studentId) {\r\n    require(isMentor(_mentorId));\r\n\r\n    // Check race\r\n    require(isRaceSuitable(_mentorId, _studentId));\r\n\r\n    uint256 mentorLevel = heroes.getLevel(_mentorId);\r\n    uint256 studentLevel = heroes.getLevel(_studentId);\r\n\r\n    uint256 levelUp = _calcLevelIncrease(mentorLevel, studentLevel);\r\n    require(levelUp > 0);\r\n\r\n    // check sum is enough\r\n    uint256 cost = levelUp.mul(prices[_mentorId]);\r\n    require(cost == msg.value);\r\n\r\n    Lecture memory lecture = Lecture({\r\n      mentorId : _mentorId,\r\n      studentId : _studentId,\r\n      mentorLevel: mentorLevel,\r\n      studentLevel: studentLevel,\r\n      levelUp: levelUp,\r\n      levelPrice : prices[_mentorId],\r\n      startedAt : now,\r\n      endsAt : now + levelUp.mul(levelUpTime)\r\n      });\r\n\r\n    //locking mentor\r\n    require(heroes.lock(_mentorId, lecture.endsAt, true));\r\n\r\n    //locking student\r\n    require(heroes.lock(_studentId, lecture.endsAt, true));\r\n\r\n\r\n    //save lecture\r\n    //id starts from 1\r\n    uint256 lectureId = lectures.push(lecture) - 1;\r\n\r\n    studentToLecture[_studentId].push(lectureId);\r\n    mentorToLecture[_mentorId].push(lectureId);\r\n\r\n    heroes.addWin(_studentId, 0, levelUp);\r\n\r\n    emit StartLecture(\r\n      lectureId,\r\n      _mentorId,\r\n      _studentId,\r\n      lecture.mentorLevel,\r\n      lecture.studentLevel,\r\n      lecture.levelUp,\r\n      lecture.levelPrice,\r\n      lecture.startedAt,\r\n      lecture.endsAt\r\n    );\r\n\r\n    _distributePayment(heroes.ownerOf(_mentorId), cost);\r\n\r\n    _flushBalance();\r\n  }\r\n\r\n  function lectureExists(uint256 _lectureId) public view returns (bool)\r\n  {\r\n    return (_lectureId > 0 && _lectureId < lectures.length);\r\n  }\r\n\r\n  function getLecture(uint256 lectureId) external view returns (\r\n    uint256 mentorId,\r\n    uint256 studentId,\r\n    uint256 mentorLevel,\r\n    uint256 studentLevel,\r\n    uint256 levelUp,\r\n    uint256 levelPrice,\r\n    uint256 cost,\r\n    uint256 startedAt,\r\n    uint256 endsAt)\r\n  {\r\n    require(lectureExists(lectureId));\r\n    Lecture memory l = lectures[lectureId];\r\n    return (l.mentorId, l.studentId, l.mentorLevel, l.studentLevel, l.levelUp, l.levelPrice, l.levelUp.mul(l.levelPrice), l.startedAt, l.endsAt);\r\n  }\r\n\r\n  function getLastLectureIdAsMentor(uint256 _tokenId) public view returns (uint256) {\r\n    return mentorToLecture[_tokenId].length > 0 ? mentorToLecture[_tokenId][mentorToLecture[_tokenId].length - 1] : 0;\r\n  }\r\n  function getLastLectureIdAsStudent(uint256 _tokenId) public view returns (uint256) {\r\n    return studentToLecture[_tokenId].length > 0 ? studentToLecture[_tokenId][studentToLecture[_tokenId].length - 1] : 0;\r\n  }\r\n \r\n\r\n  function getLastLecture(uint256 tokenId) external view returns (\r\n    uint256 lectureId,\r\n    uint256 mentorId,\r\n    uint256 studentId,\r\n    uint256 mentorLevel,\r\n    uint256 studentLevel,\r\n    uint256 levelUp,\r\n    uint256 levelPrice,\r\n    uint256 cost,\r\n    uint256 startedAt,\r\n    uint256 endsAt)\r\n  {\r\n    uint256 mentorLectureId = getLastLectureIdAsMentor(tokenId);\r\n    uint256 studentLectureId = getLastLectureIdAsStudent(tokenId);\r\n    lectureId = studentLectureId > mentorLectureId ? studentLectureId : mentorLectureId;\r\n    require(lectureExists(lectureId));\r\n    Lecture storage l = lectures[lectureId];\r\n    return (lectureId, l.mentorId, l.studentId, l.mentorLevel, l.studentLevel, l.levelUp, l.levelPrice, l.levelUp.mul(l.levelPrice), l.startedAt, l.endsAt);\r\n  }\r\n\r\n  //// SERVICE\r\n  //1% - 100, 10% - 1000 50% - 5000\r\n  function _getPercent(uint256 _v, uint256 _p) internal pure returns (uint)    {\r\n    return _v.mul(_p).div(10000);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_mentorId\",\"type\":\"uint256\"}],\"name\":\"isMentor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mentorId\",\"type\":\"uint256\"},{\"name\":\"_levelPrice\",\"type\":\"uint256\"}],\"name\":\"changeLevelPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"getLastLecture\",\"outputs\":[{\"name\":\"lectureId\",\"type\":\"uint256\"},{\"name\":\"mentorId\",\"type\":\"uint256\"},{\"name\":\"studentId\",\"type\":\"uint256\"},{\"name\":\"mentorLevel\",\"type\":\"uint256\"},{\"name\":\"studentLevel\",\"type\":\"uint256\"},{\"name\":\"levelUp\",\"type\":\"uint256\"},{\"name\":\"levelPrice\",\"type\":\"uint256\"},{\"name\":\"cost\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"endsAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mentorId\",\"type\":\"uint256\"}],\"name\":\"breakMentoring\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"heroes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"inStudying\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLastLectureIdAsStudent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mentorId\",\"type\":\"uint256\"}],\"name\":\"getMentor\",\"outputs\":[{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"inLecture\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lectureId\",\"type\":\"uint256\"}],\"name\":\"getLecture\",\"outputs\":[{\"name\":\"mentorId\",\"type\":\"uint256\"},{\"name\":\"studentId\",\"type\":\"uint256\"},{\"name\":\"mentorLevel\",\"type\":\"uint256\"},{\"name\":\"studentLevel\",\"type\":\"uint256\"},{\"name\":\"levelUp\",\"type\":\"uint256\"},{\"name\":\"levelPrice\",\"type\":\"uint256\"},{\"name\":\"cost\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"endsAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLevelUpTime\",\"type\":\"uint256\"}],\"name\":\"setLevelUpTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mentorId\",\"type\":\"uint256\"},{\"name\":\"_levelPrice\",\"type\":\"uint256\"}],\"name\":\"becomeMentor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mentorId\",\"type\":\"uint256\"},{\"name\":\"_studentId\",\"type\":\"uint256\"}],\"name\":\"calcCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mentorId\",\"type\":\"uint256\"},{\"name\":\"_studentId\",\"type\":\"uint256\"}],\"name\":\"startLecture\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"levelUpTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"inMentoring\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_lectureId\",\"type\":\"uint256\"}],\"name\":\"lectureExists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_mentorId\",\"type\":\"uint256\"},{\"name\":\"_studentId\",\"type\":\"uint256\"}],\"name\":\"isRaceSuitable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getLastLectureIdAsMentor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_heroes\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"mentorId\",\"type\":\"uint256\"}],\"name\":\"BecomeMentor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"mentorId\",\"type\":\"uint256\"}],\"name\":\"BreakMentoring\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"mentorId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newLevelPrice\",\"type\":\"uint256\"}],\"name\":\"ChangeLevelPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"source\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Income\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lectureId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"mentorId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"studentId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mentorLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"studentLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"levelUp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"levelPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startedAt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endsAt\",\"type\":\"uint256\"}],\"name\":\"StartLecture\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Mentoring","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000d2bae9a30a40376d25353773010ffe52dba0d688","Library":"","SwarmSource":"bzzr://482a7d2d84cf1716ee8bd3edcd2525b634b315a1496d490556725ec1acf4d064"}]}