{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.11;\r\n\r\n\r\ninterface CommonWallet {\r\n    function receive() external payable;\r\n}\r\n\r\nlibrary StringUtils {\r\n    function concat(string _a, string _b)\r\n        internal\r\n        pure\r\n        returns (string)\r\n    {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n\r\n        bytes memory bab = new bytes(_ba.length + _bb.length);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n        return string(bab);\r\n    }\r\n}\r\n\r\nlibrary UintStringUtils {\r\n    function toString(uint i)\r\n        internal\r\n        pure\r\n        returns (string)\r\n    {\r\n        if (i == 0) return '0';\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n}\r\n\r\n// @title AddressUtils\r\n// @dev Utility library of inline functions on addresses\r\nlibrary AddressUtils {\r\n    // Returns whether the target address is a contract\r\n    // @dev This function will return false if invoked during the constructor of a contract,\r\n    // as the code is not actually created until after the constructor finishes.\r\n    // @param addr address to check\r\n    // @return whether the target address is a contract\r\n    function isContract(address addr)\r\n        internal\r\n        view\r\n        returns(bool)\r\n    {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n // @title SafeMath256\r\n // @dev Math operations with safety checks that throw on error\r\nlibrary SafeMath256 {\r\n\r\n  // @dev Multiplies two numbers, throws on overflow.\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  // @dev Integer division of two numbers, truncating the quotient.\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n\r\n  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n\r\n  // @dev Adds two numbers, throws on overflow.\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n  // @dev Multiplies two numbers, throws on overflow.\r\n  function mul(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n\r\n  // @dev Integer division of two numbers, truncating the quotient.\r\n  function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint32 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n\r\n  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n\r\n  // @dev Adds two numbers, throws on overflow.\r\n  function add(uint32 a, uint32 b) internal pure returns (uint32 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\nlibrary SafeMath8 {\r\n  // @dev Multiplies two numbers, throws on overflow.\r\n  function mul(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n\r\n  // @dev Integer division of two numbers, truncating the quotient.\r\n  function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint8 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n\r\n  // @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n\r\n  // @dev Adds two numbers, throws on overflow.\r\n  function add(uint8 a, uint8 b) internal pure returns (uint8 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/// @title A facet of DragonCore that manages special access privileges.\r\ncontract DragonAccessControl \r\n{\r\n    // @dev Non Assigned address.\r\n    address constant NA = address(0);\r\n\r\n    /// @dev Contract owner\r\n    address internal controller_;\r\n\r\n    /// @dev Contract modes\r\n    enum Mode {TEST, PRESALE, OPERATE}\r\n\r\n    /// @dev Contract state\r\n    Mode internal mode_ = Mode.TEST;\r\n\r\n    /// @dev OffChain Server accounts ('minions') addresses\r\n    /// It's used for money withdrawal and export of tokens \r\n    mapping(address => bool) internal minions_;\r\n    \r\n    /// @dev Presale contract address. Can call `presale` method.\r\n    address internal presale_;\r\n\r\n    // Modifiers ---------------------------------------------------------------\r\n    /// @dev Limit execution to controller account only.\r\n    modifier controllerOnly() {\r\n        require(controller_ == msg.sender, \"controller_only\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Limit execution to minion account only.\r\n    modifier minionOnly() {\r\n        require(minions_[msg.sender], \"minion_only\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Limit execution to test time only.\r\n    modifier testModeOnly {\r\n        require(mode_ == Mode.TEST, \"test_mode_only\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Limit execution to presale time only.\r\n    modifier presaleModeOnly {\r\n        require(mode_ == Mode.PRESALE, \"presale_mode_only\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Limit execution to operate time only.\r\n    modifier operateModeOnly {\r\n        require(mode_ == Mode.OPERATE, \"operate_mode_only\");\r\n        _;\r\n    }\r\n\r\n     /// @dev Limit execution to presale account only.\r\n    modifier presaleOnly() {\r\n        require(msg.sender == presale_, \"presale_only\");\r\n        _;\r\n    }\r\n\r\n    /// @dev set state to Mode.OPERATE.\r\n    function setOperateMode()\r\n        external \r\n        controllerOnly\r\n        presaleModeOnly\r\n    {\r\n        mode_ = Mode.OPERATE;\r\n    }\r\n\r\n    /// @dev Set presale contract address. Becomes useless when presale is over.\r\n    /// @param _presale Presale contract address.\r\n    function setPresale(address _presale)\r\n        external\r\n        controllerOnly\r\n    {\r\n        presale_ = _presale;\r\n    }\r\n\r\n    /// @dev set state to Mode.PRESALE.\r\n    function setPresaleMode()\r\n        external\r\n        controllerOnly\r\n        testModeOnly\r\n    {\r\n        mode_ = Mode.PRESALE;\r\n    }    \r\n\r\n        /// @dev Get controller address.\r\n    /// @return Address of contract's controller.\r\n    function controller()\r\n        external\r\n        view\r\n        returns(address)\r\n    {\r\n        return controller_;\r\n    }\r\n\r\n    /// @dev Transfer control to new address. Set controller an approvee for\r\n    /// tokens that managed by contract itself. Remove previous controller value\r\n    /// from contract's approvees.\r\n    /// @param _to New controller address.\r\n    function setController(address _to)\r\n        external\r\n        controllerOnly\r\n    {\r\n        require(_to != NA, \"_to\");\r\n        require(controller_ != _to, \"already_controller\");\r\n\r\n        controller_ = _to;\r\n    }\r\n\r\n    /// @dev Check if address is a minion.\r\n    /// @param _addr Address to check.\r\n    /// @return True if address is a minion.\r\n    function isMinion(address _addr)\r\n        public view returns(bool)\r\n    {\r\n        return minions_[_addr];\r\n    }   \r\n\r\n    function getCurrentMode() \r\n        public view returns (Mode) \r\n    {\r\n        return mode_;\r\n    }    \r\n}\r\n\r\n/// @dev token description, storage and transfer functions\r\ncontract DragonBase is DragonAccessControl\r\n{\r\n    using SafeMath8 for uint8;\r\n    using SafeMath32 for uint32;\r\n    using SafeMath256 for uint256;\r\n    using StringUtils for string;\r\n    using UintStringUtils for uint;    \r\n\r\n    /// @dev The Birth event is fired whenever a new dragon comes into existence. \r\n    event Birth(address owner, uint256 petId, uint256 tokenId, uint256 parentA, uint256 parentB, string genes, string params);\r\n\r\n    /// @dev Token name\r\n    string internal name_;\r\n    /// @dev Token symbol\r\n    string internal symbol_;\r\n    /// @dev Token resolving url\r\n    string internal url_;\r\n\r\n    struct DragonToken {\r\n        // Constant Token params\r\n        uint8   genNum;  // generation number. uses for dragon view\r\n        string  genome;  // genome description\r\n        uint256 petId;   // offchain dragon identifier\r\n\r\n        // Parents\r\n        uint256 parentA;\r\n        uint256 parentB;\r\n\r\n        // Game-depening Token params\r\n        string  params;  // can change in export operation\r\n\r\n        // State\r\n        address owner; \r\n    }\r\n\r\n    /// @dev Count of minted tokens\r\n    uint256 internal mintCount_;\r\n    /// @dev Maximum token supply\r\n    uint256 internal maxSupply_;\r\n     /// @dev Count of burn tokens\r\n    uint256 internal burnCount_;\r\n\r\n    // Tokens state\r\n    /// @dev Token approvals values\r\n    mapping(uint256 => address) internal approvals_;\r\n    /// @dev Operator approvals\r\n    mapping(address => mapping(address => bool)) internal operatorApprovals_;\r\n    /// @dev Index of token in owner's token list\r\n    mapping(uint256 => uint256) internal ownerIndex_;\r\n    /// @dev Owner's tokens list\r\n    mapping(address => uint256[]) internal ownTokens_;\r\n    /// @dev Tokens\r\n    mapping(uint256 => DragonToken) internal tokens_;\r\n\r\n    // @dev Non Assigned address.\r\n    address constant NA = address(0);\r\n\r\n    /// @dev Add token to new owner. Increase owner's balance.\r\n    /// @param _to Token receiver.\r\n    /// @param _tokenId New token id.\r\n    function _addTo(address _to, uint256 _tokenId)\r\n        internal\r\n    {\r\n        DragonToken storage token = tokens_[_tokenId];\r\n        require(token.owner == NA, \"taken\");\r\n\r\n        uint256 lastIndex = ownTokens_[_to].length;\r\n        ownTokens_[_to].push(_tokenId);\r\n        ownerIndex_[_tokenId] = lastIndex;\r\n\r\n        token.owner = _to;\r\n    }\r\n\r\n    /// @dev Create new token and increase mintCount.\r\n    /// @param _genome New token's genome.\r\n    /// @param _params Token params string. \r\n    /// @param _parentA Token A parent.\r\n    /// @param _parentB Token B parent.\r\n    /// @return New token id.\r\n    function _createToken(\r\n        address _to,\r\n        \r\n        // Constant Token params\r\n        uint8   _genNum,\r\n        string   _genome,\r\n        uint256 _parentA,\r\n        uint256 _parentB,\r\n        \r\n        // Game-depening Token params\r\n        uint256 _petId,\r\n        string   _params        \r\n    )\r\n        internal returns(uint256)\r\n    {\r\n        uint256 tokenId = mintCount_.add(1);\r\n        mintCount_ = tokenId;\r\n\r\n        DragonToken memory token = DragonToken(\r\n            _genNum,\r\n            _genome,\r\n            _petId,\r\n\r\n            _parentA,\r\n            _parentB,\r\n\r\n            _params,\r\n            NA\r\n        );\r\n        \r\n        tokens_[tokenId] = token;\r\n        \r\n        _addTo(_to, tokenId);\r\n        \r\n        emit Birth(_to, _petId, tokenId, _parentA, _parentB, _genome, _params);\r\n        \r\n        return tokenId;\r\n    }    \r\n \r\n    /// @dev Get token genome.\r\n    /// @param _tokenId Token id.\r\n    /// @return Token's genome.\r\n    function getGenome(uint256 _tokenId)\r\n        external view returns(string)\r\n    {\r\n        return tokens_[_tokenId].genome;\r\n    }\r\n\r\n    /// @dev Get token params.\r\n    /// @param _tokenId Token id.\r\n    /// @return Token's params.\r\n    function getParams(uint256 _tokenId)\r\n        external view returns(string)\r\n    {\r\n        return tokens_[_tokenId].params;\r\n    }\r\n\r\n    /// @dev Get token parentA.\r\n    /// @param _tokenId Token id.\r\n    /// @return Parent token id.\r\n    function getParentA(uint256 _tokenId)\r\n        external view returns(uint256)\r\n    {\r\n        return tokens_[_tokenId].parentA;\r\n    }   \r\n\r\n    /// @dev Get token parentB.\r\n    /// @param _tokenId Token id.\r\n    /// @return Parent token id.\r\n    function getParentB(uint256 _tokenId)\r\n        external view returns(uint256)\r\n    {\r\n        return tokens_[_tokenId].parentB;\r\n    }\r\n\r\n    /// @dev Check if `_tokenId` exists. Check if owner is not addres(0).\r\n    /// @param _tokenId Token id\r\n    /// @return Return true if token owner is real.\r\n    function isExisting(uint256 _tokenId)\r\n        public view returns(bool)\r\n    {\r\n        return tokens_[_tokenId].owner != NA;\r\n    }    \r\n\r\n    /// @dev Receive maxium token supply value.\r\n    /// @return Contracts `maxSupply_` variable.\r\n    function maxSupply()\r\n        external view returns(uint256)\r\n    {\r\n        return maxSupply_;\r\n    }\r\n\r\n    /// @dev Set url prefix for tokenURI generation.\r\n    /// @param _url Url prefix value.\r\n    function setUrl(string _url)\r\n        external controllerOnly\r\n    {\r\n        url_ = _url;\r\n    }\r\n\r\n    /// @dev Get token symbol.\r\n    /// @return Token symbol name.\r\n    function symbol()\r\n        external view returns(string)\r\n    {\r\n        return symbol_;\r\n    }\r\n\r\n    /// @dev Get token URI to receive offchain information by it's id.\r\n    /// @param _tokenId Token id.\r\n    /// @return URL string. For example \"http://erc721.tld/tokens/1\".\r\n    function tokenURI(uint256 _tokenId)\r\n        external view returns(string)\r\n    {\r\n        return url_.concat(_tokenId.toString());\r\n    }\r\n\r\n     /// @dev Get token name.\r\n    /// @return Token name string.\r\n    function name()\r\n        external view returns(string)\r\n    {\r\n        return name_;\r\n    }\r\n\r\n    /// @dev return information about _owner tokens\r\n    function getTokens(address _owner)\r\n        external view  returns (uint256[], uint256[], byte[]) \r\n    {\r\n        uint256[] memory tokens = ownTokens_[_owner];\r\n        uint256[] memory tokenIds = new uint256[](tokens.length);\r\n        uint256[] memory petIds = new uint256[](tokens.length);\r\n\r\n        byte[] memory genomes = new byte[](tokens.length * 77);\r\n        uint index = 0;\r\n\r\n        for(uint i = 0; i < tokens.length; i++) {\r\n            uint256 tokenId = tokens[i];\r\n            \r\n            DragonToken storage token = tokens_[tokenId];\r\n\r\n            tokenIds[i] = tokenId;\r\n            petIds[i] = token.petId;\r\n            \r\n            bytes storage genome = bytes(token.genome);\r\n            \r\n            for(uint j = 0; j < genome.length; j++) {\r\n                genomes[index++] = genome[j];\r\n            }\r\n        }\r\n        return (tokenIds, petIds, genomes);\r\n    }\r\n    \r\n}\r\n\r\n/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens\r\n/// @dev See https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC721/ERC721.sol\r\n\r\ncontract ERC721Basic \r\n{\r\n    /// @dev Emitted when token approvee is set\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    /// @dev Emitted when owner approve all own tokens to operator.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    /// @dev Emitted when user deposit some funds.\r\n    event Deposit(address indexed _sender, uint256 _value);\r\n    /// @dev Emitted when user deposit some funds.\r\n    event Withdraw(address indexed _sender, uint256 _value);\r\n    /// @dev Emitted when token transferred to new owner\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n\r\n    // Required methods\r\n    function balanceOf(address _owner) external view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n    \r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function getApproved(uint256 _tokenId) public view returns (address _to);\r\n\r\n    //function transfer(address _to, uint256 _tokenId) public;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    function totalSupply() public view returns (uint256 total);\r\n\r\n    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic \r\n{\r\n    function name() external view returns (string _name);\r\n    function symbol() external view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver \r\n{\r\n  /**\r\n   * @dev Magic value to be returned upon successful reception of an NFT\r\n   *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n   *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n   */\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n  /**\r\n   * @notice Handle the receipt of an NFT\r\n   * @dev The ERC721 smart contract calls this function on the recipient\r\n   *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n   *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n   *  than the magic value MUST result in the transaction being reverted.\r\n   *  Note: the contract address is always the message sender.\r\n   * @param _from The sending address\r\n   * @param _tokenId The NFT identifier which is being transfered\r\n   * @param _data Additional data with no specified format\r\n   * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n   */\r\n    function onERC721Received(address _from, uint256 _tokenId, bytes _data )\r\n        public returns(bytes4);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Metadata, ERC721Receiver \r\n{\r\n    /// @dev Interface signature 721 for interface detection.\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 = 0x01ffc9a7;\r\n    /*\r\n    bytes4(keccak256('supportsInterface(bytes4)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721Enumerable = 0x780e9d63;\r\n    /*\r\n    bytes4(keccak256('totalSupply()')) ^\r\n    bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n    bytes4(keccak256('tokenByIndex(uint256)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721Metadata = 0x5b5e139f;\r\n    /*\r\n    bytes4(keccak256('name()')) ^\r\n    bytes4(keccak256('symbol()')) ^\r\n    bytes4(keccak256('tokenURI(uint256)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 = 0x80ac58cd;\r\n    /*\r\n    bytes4(keccak256('balanceOf(address)')) ^\r\n    bytes4(keccak256('ownerOf(uint256)')) ^\r\n    bytes4(keccak256('approve(address,uint256)')) ^\r\n    bytes4(keccak256('getApproved(uint256)')) ^\r\n    bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n    bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'));\r\n    */\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        return ((_interfaceID == InterfaceSignature_ERC165)\r\n            || (_interfaceID == InterfaceSignature_ERC721)\r\n            || (_interfaceID == InterfaceSignature_ERC721Enumerable)\r\n            || (_interfaceID == InterfaceSignature_ERC721Metadata));\r\n    }    \r\n}\r\n\r\n/// @dev ERC721 methods\r\ncontract DragonOwnership is ERC721, DragonBase\r\n{\r\n    using StringUtils for string;\r\n    using UintStringUtils for uint;    \r\n    using AddressUtils for address;\r\n\r\n    /// @dev Emitted when token transferred to new owner. Additional fields is petId, genes, params\r\n    /// it uses for client-side indication\r\n    event TransferInfo(address indexed _from, address indexed _to, uint256 _tokenId, uint256 petId, string genes, string params);\r\n\r\n    /// @dev Specify if _addr is token owner or approvee. Also check if `_addr`\r\n    /// is operator for token owner.\r\n    /// @param _tokenId Token to check ownership of.\r\n    /// @param _addr Address to check if it's an owner or an aprovee of `_tokenId`.\r\n    /// @return True if token can be managed by provided `_addr`.\r\n    function isOwnerOrApproved(uint256 _tokenId, address _addr)\r\n        public view returns(bool)\r\n    {\r\n        DragonToken memory token = tokens_[_tokenId];\r\n\r\n        if (token.owner == _addr) {\r\n            return true;\r\n        }\r\n        else if (isApprovedFor(_tokenId, _addr)) {\r\n            return true;\r\n        }\r\n        else if (isApprovedForAll(token.owner, _addr)) {\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /// @dev Limit execution to token owner or approvee only.\r\n    /// @param _tokenId Token to check ownership of.\r\n    modifier ownerOrApprovedOnly(uint256 _tokenId) {\r\n        require(isOwnerOrApproved(_tokenId, msg.sender), \"tokenOwnerOrApproved_only\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Contract's own token only acceptable.\r\n    /// @param _tokenId Contract's token id.\r\n    modifier ownOnly(uint256 _tokenId) {\r\n        require(tokens_[_tokenId].owner == address(this), \"own_only\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Determine if token is approved for specified approvee.\r\n    /// @param _tokenId Target token id.\r\n    /// @param _approvee Approvee address.\r\n    /// @return True if so.\r\n    function isApprovedFor(uint256 _tokenId, address _approvee)\r\n        public view returns(bool)\r\n    {\r\n        return approvals_[_tokenId] == _approvee;\r\n    }\r\n\r\n    /// @dev Specify is given address set as operator with setApprovalForAll.\r\n    /// @param _owner Token owner.\r\n    /// @param _operator Address to check if it an operator.\r\n    /// @return True if operator is set.\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        public view returns(bool)\r\n    {\r\n        return operatorApprovals_[_owner][_operator];\r\n    }\r\n\r\n    /// @dev Check if `_tokenId` exists. Check if owner is not addres(0).\r\n    /// @param _tokenId Token id\r\n    /// @return Return true if token owner is real.\r\n    function exists(uint256 _tokenId)\r\n        public view returns(bool)\r\n    {\r\n        return tokens_[_tokenId].owner != NA;\r\n    }\r\n\r\n    /// @dev Get owner of a token.\r\n    /// @param _tokenId Token owner id.\r\n    /// @return Token owner address.\r\n    function ownerOf(uint256 _tokenId)\r\n        public view returns(address)\r\n    {\r\n        return tokens_[_tokenId].owner;\r\n    }\r\n\r\n    /// @dev Get approvee address. If there is not approvee returns 0x0.\r\n    /// @param _tokenId Token id to get approvee of.\r\n    /// @return Approvee address or 0x0.\r\n    function getApproved(uint256 _tokenId)\r\n        public view returns(address)\r\n    {\r\n        return approvals_[_tokenId];\r\n    }\r\n\r\n    /// @dev Grant owner alike controll permissions to third party.\r\n    /// @param _to Permission receiver.\r\n    /// @param _tokenId Granted token id.\r\n    function approve(address _to, uint256 _tokenId)\r\n        external ownerOrApprovedOnly(_tokenId)\r\n    {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_to != owner);\r\n\r\n        if (getApproved(_tokenId) != NA || _to != NA) {\r\n            approvals_[_tokenId] = _to;\r\n\r\n            emit Approval(owner, _to, _tokenId);\r\n        }\r\n    }\r\n\r\n    /// @dev Current total tokens supply. Always less then maxSupply.\r\n    /// @return Difference between minted and burned tokens.\r\n    function totalSupply()\r\n        public view returns(uint256)\r\n    {\r\n        return mintCount_;\r\n    }    \r\n\r\n    /// @dev Get number of tokens which `_owner` owns.\r\n    /// @param _owner Address to count own tokens.\r\n    /// @return Count of owned tokens.\r\n    function balanceOf(address _owner)\r\n        external view returns(uint256)\r\n    {\r\n        return ownTokens_[_owner].length;\r\n    }    \r\n\r\n    /// @dev Internal set approval for all without _owner check.\r\n    /// @param _owner Granting user.\r\n    /// @param _to New account approvee.\r\n    /// @param _approved Set new approvee status.\r\n    function _setApprovalForAll(address _owner, address _to, bool _approved)\r\n        internal\r\n    {\r\n        operatorApprovals_[_owner][_to] = _approved;\r\n\r\n        emit ApprovalForAll(_owner, _to, _approved);\r\n    }\r\n\r\n    /// @dev Set approval for all account tokens.\r\n    /// @param _to Approvee address.\r\n    /// @param _approved Value true or false.\r\n    function setApprovalForAll(address _to, bool _approved)\r\n        external\r\n    {\r\n        require(_to != msg.sender);\r\n\r\n        _setApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    /// @dev Remove approval bindings for token. Do nothing if no approval\r\n    /// exists.\r\n    /// @param _from Address of token owner.\r\n    /// @param _tokenId Target token id.\r\n    function _clearApproval(address _from, uint256 _tokenId)\r\n        internal\r\n    {\r\n        if (approvals_[_tokenId] == NA) {\r\n            return;\r\n        }\r\n\r\n        approvals_[_tokenId] = NA;\r\n        emit Approval(_from, NA, _tokenId);\r\n    }\r\n\r\n    /// @dev Check if contract was received by other side properly if receiver\r\n    /// is a ctontract.\r\n    /// @param _from Current token owner.\r\n    /// @param _to New token owner.\r\n    /// @param _tokenId token Id.\r\n    /// @param _data Transaction data.\r\n    /// @return True on success.\r\n    function _checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        internal returns(bool)\r\n    {\r\n        if (! _to.isContract()) {\r\n            return true;\r\n        }\r\n\r\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n            _from, _tokenId, _data\r\n        );\r\n\r\n        return (retval == ERC721_RECEIVED);\r\n    }\r\n\r\n    /// @dev Remove token from owner. Unrecoverable.\r\n    /// @param _tokenId Removing token id.\r\n    function _remove(uint256 _tokenId)\r\n        internal\r\n    {\r\n        address owner = tokens_[_tokenId].owner;\r\n        _removeFrom(owner, _tokenId);\r\n    }\r\n\r\n    /// @dev Completely remove token from the contract. Unrecoverable.\r\n    /// @param _owner Owner of removing token.\r\n    /// @param _tokenId Removing token id.\r\n    function _removeFrom(address _owner, uint256 _tokenId)\r\n        internal\r\n    {\r\n        uint256 lastIndex = ownTokens_[_owner].length.sub(1);\r\n        uint256 lastToken = ownTokens_[_owner][lastIndex];\r\n\r\n        // Swap users token\r\n        ownTokens_[_owner][ownerIndex_[_tokenId]] = lastToken;\r\n        ownTokens_[_owner].length--;\r\n\r\n        // Swap token indexes\r\n        ownerIndex_[lastToken] = ownerIndex_[_tokenId];\r\n        ownerIndex_[_tokenId] = 0;\r\n\r\n        DragonToken storage token = tokens_[_tokenId];\r\n        token.owner = NA;\r\n    }\r\n\r\n    /// @dev Transfer token from owner `_from` to another address or contract\r\n    /// `_to` by it's `_tokenId`.\r\n    /// @param _from Current token owner.\r\n    /// @param _to New token owner.\r\n    /// @param _tokenId token Id.\r\n    function transferFrom( address _from, address _to, uint256 _tokenId )\r\n        public ownerOrApprovedOnly(_tokenId)\r\n    {\r\n        require(_from != NA);\r\n        require(_to != NA);\r\n\r\n        _clearApproval(_from, _tokenId);\r\n        _removeFrom(_from, _tokenId);\r\n        _addTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n\r\n        DragonToken storage token = tokens_[_tokenId];\r\n        emit TransferInfo(_from, _to, _tokenId, token.petId, token.genome, token.params);\r\n    }\r\n\r\n    /// @dev Update token params and transfer to new owner. Only contract's own\r\n    /// tokens could be updated. Also notifies receiver of the token.\r\n    /// @param _to Address to transfer token to.\r\n    /// @param _tokenId Id of token that should be transferred.\r\n    /// @param _params New token params.\r\n    function updateAndSafeTransferFrom(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        string _params\r\n    )\r\n        public\r\n    {\r\n        updateAndSafeTransferFrom(_to, _tokenId, _params, \"\");\r\n    }\r\n\r\n    /// @dev Update token params and transfer to new owner. Only contract's own\r\n    /// tokens could be updated. Also notifies receiver of the token and send\r\n    /// protion of _data to it.\r\n    /// @param _to Address to transfer token to.\r\n    /// @param _tokenId Id of token that should be transferred.\r\n    /// @param _params New token params.\r\n    /// @param _data Notification data.\r\n    function updateAndSafeTransferFrom(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        string _params,\r\n        bytes _data\r\n    )\r\n        public\r\n    {\r\n        // Safe transfer from\r\n        updateAndTransferFrom(_to, _tokenId, _params, 0, 0);\r\n        require(_checkAndCallSafeTransfer(address(this), _to, _tokenId, _data));\r\n    }\r\n\r\n    /// @dev Update token params and transfer to new owner. Only contract's own\r\n    /// tokens could be updated.\r\n    /// @param _to Address to transfer token to.\r\n    /// @param _tokenId Id of token that should be transferred.\r\n    /// @param _params New token params.\r\n    function updateAndTransferFrom(\r\n        address _to,\r\n        uint256 _tokenId,\r\n        string _params,\r\n        uint256 _petId, \r\n        uint256 _transferCost\r\n    )\r\n        public\r\n        ownOnly(_tokenId)\r\n        minionOnly\r\n    {\r\n        require(bytes(_params).length > 0, \"params_length\");\r\n\r\n        // Update\r\n        tokens_[_tokenId].params = _params;\r\n        if (tokens_[_tokenId].petId == 0 ) {\r\n            tokens_[_tokenId].petId = _petId;\r\n        }\r\n\r\n        address from = tokens_[_tokenId].owner;\r\n\r\n        // Transfer from\r\n        transferFrom(from, _to, _tokenId);\r\n\r\n        // send to the server's wallet the transaction cost\r\n        // withdraw it from the balance of the contract. this amount must be withdrawn from the player\r\n        // on the side of the game server        \r\n        if (_transferCost > 0) {\r\n            msg.sender.transfer(_transferCost);\r\n        }\r\n    }\r\n\r\n    /// @dev Transfer token from one owner to new one and check if it was\r\n    /// properly received if receiver is a contact.\r\n    /// @param _from Current token owner.\r\n    /// @param _to New token owner.\r\n    /// @param _tokenId token Id.\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n    {\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /// @dev Transfer token from one owner to new one and check if it was\r\n    /// properly received if receiver is a contact.\r\n    /// @param _from Current token owner.\r\n    /// @param _to New token owner.\r\n    /// @param _tokenId token Id.\r\n    /// @param _data Transaction data.\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n    {\r\n        transferFrom(_from, _to, _tokenId);\r\n        require(_checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n    /// @dev Burn owned token. Increases `burnCount_` and decrease `totalSupply`\r\n    /// value.\r\n    /// @param _tokenId Id of burning token.\r\n    function burn(uint256 _tokenId)\r\n        public\r\n        ownerOrApprovedOnly(_tokenId)\r\n    {\r\n        address owner = tokens_[_tokenId].owner;\r\n        _remove(_tokenId);\r\n\r\n        burnCount_ += 1;\r\n\r\n        emit Transfer(owner, NA, _tokenId);\r\n    }\r\n\r\n    /// @dev Receive count of burned tokens. Should be greater than `totalSupply`\r\n    /// but less than `mintCount`.\r\n    /// @return Number of burned tokens\r\n    function burnCount()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return burnCount_;\r\n    }\r\n\r\n    function onERC721Received(address, uint256, bytes)\r\n        public returns(bytes4) \r\n    {\r\n        return ERC721_RECEIVED;\r\n    }\r\n}\r\n\r\n\r\n\r\n/// @title Managing contract. implements the logic of buying tokens, depositing / withdrawing funds \r\n/// to the project account and importing / exporting tokens\r\ncontract EtherDragonsCore is DragonOwnership \r\n{\r\n    using SafeMath8 for uint8;\r\n    using SafeMath32 for uint32;\r\n    using SafeMath256 for uint256;\r\n    using AddressUtils for address;\r\n    using StringUtils for string;\r\n    using UintStringUtils for uint;\r\n\r\n    // @dev Non Assigned address.\r\n    address constant NA = address(0);\r\n\r\n    /// @dev Bounty tokens count limit\r\n    uint256 public constant BOUNTY_LIMIT = 2500;\r\n    /// @dev Presale tokens count limit\r\n    uint256 public constant PRESALE_LIMIT = 7500;\r\n    ///@dev Total gen0tokens generation limit\r\n    uint256 public constant GEN0_CREATION_LIMIT = 90000;\r\n    \r\n    /// @dev Number of tokens minted in presale stage\r\n    uint256 internal presaleCount_;  \r\n    /// @dev Number of tokens minted for bounty campaign\r\n    uint256 internal bountyCount_;\r\n   \r\n    ///@dev Company bank address\r\n    address internal bank_;\r\n\r\n    // Extension ---------------------------------------------------------------\r\n\r\n    /// @dev Contract is not payable. To fullfil balance method `depositTo`\r\n    /// should be used.\r\n    function ()\r\n        public payable\r\n    {\r\n        revert();\r\n    }\r\n\r\n    /// @dev amount on the account of the contract. This amount consists of deposits  from players and the system reserve for payment of transactions\r\n    /// the player at any time to withdraw the amount corresponding to his account in the game, minus the cost of the transaction \r\n    function getBalance() \r\n        public view returns (uint256)\r\n    {\r\n        return address(this).balance;\r\n    }    \r\n\r\n    /// @dev at the moment of creation of the contract we transfer the address of the bank\r\n    /// presell contract address set later\r\n    constructor(\r\n        address _bank\r\n    )\r\n        public\r\n    {\r\n        require(_bank != NA);\r\n        \r\n        controller_ = msg.sender;\r\n        bank_ = _bank;\r\n        \r\n        // Meta\r\n        name_ = \"EtherDragons\";\r\n        symbol_ = \"ED\";\r\n        url_ = \"https://game.etherdragons.world/token/\";\r\n\r\n        // Token mint limit\r\n        maxSupply_ = GEN0_CREATION_LIMIT + BOUNTY_LIMIT + PRESALE_LIMIT;\r\n    }\r\n\r\n    /// Number of tokens minted in presale stage\r\n    function totalPresaleCount()\r\n        public view returns(uint256)\r\n    {\r\n        return presaleCount_;\r\n    }    \r\n\r\n    /// @dev Number of tokens minted for bounty campaign\r\n    function totalBountyCount()\r\n        public view returns(uint256)\r\n    {\r\n        return bountyCount_;\r\n    }    \r\n    \r\n    /// @dev Check if new token could be minted. Return true if count of minted\r\n    /// tokens less than could be minted through contract deploy.\r\n    /// Also, tokens can not be created more often than once in mintDelay_ minutes\r\n    /// @return True if current count is less then maximum tokens available for now.\r\n    function canMint()\r\n        public view returns(bool)\r\n    {\r\n        return (mintCount_ + presaleCount_ + bountyCount_) < maxSupply_;\r\n    }\r\n\r\n    /// @dev Here we write the addresses of the wallets of the server from which it is accessed\r\n    /// to contract methods.\r\n    /// @param _to New minion address\r\n    function minionAdd(address _to)\r\n        external controllerOnly\r\n    {\r\n        require(minions_[_to] == false, \"already_minion\");\r\n        \r\n        // разрешаем этому адресу пользоваться токенами контакта\r\n        // allow the address to use contract tokens \r\n        _setApprovalForAll(address(this), _to, true);\r\n        \r\n        minions_[_to] = true;\r\n    }\r\n\r\n    /// @dev delete the address of the server wallet\r\n    /// @param _to Minion address\r\n    function minionRemove(address _to)\r\n        external controllerOnly\r\n    {\r\n        require(minions_[_to], \"not_a_minion\");\r\n\r\n        // and forbid this wallet to use tokens of the contract\r\n        _setApprovalForAll(address(this), _to, false);\r\n        minions_[_to] = false;\r\n    }\r\n\r\n    /// @dev Here the player can put funds to the account of the contract\r\n    /// and get the same amount of in-game currency\r\n    /// the game server understands who puts money at the wallet address\r\n    function depositTo()\r\n        public payable\r\n    {\r\n        emit Deposit(msg.sender, msg.value);\r\n    }    \r\n    \r\n    /// @dev Transfer amount of Ethers to specified receiver. Only owner can\r\n    // call this method.\r\n    /// @param _to Transfer receiver.\r\n    /// @param _amount Transfer value.\r\n    /// @param _transferCost Transfer cost.\r\n    function transferAmount(address _to, uint256 _amount, uint256 _transferCost)\r\n        external minionOnly\r\n    {\r\n        require((_amount + _transferCost) <= address(this).balance, \"not enough money!\");\r\n        _to.transfer(_amount);\r\n\r\n        // send to the wallet of the server the transfer cost\r\n        // withdraw  it from the balance of the contract. this amount must be withdrawn from the player\r\n        // on the side of the game server\r\n        if (_transferCost > 0) {\r\n            msg.sender.transfer(_transferCost);\r\n        }\r\n\r\n        emit Withdraw(_to, _amount);\r\n    }        \r\n\r\n   /// @dev Mint new token with specified params. Transfer `_fee` to the\r\n    /// `bank`. \r\n    /// @param _to New token owner.\r\n    /// @param _fee Transaction fee.\r\n    /// @param _genNum Generation number..\r\n    /// @param _genome New genome unique value.\r\n    /// @param _parentA Parent A.\r\n    /// @param _parentB Parent B.\r\n    /// @param _petId Pet identifier.\r\n    /// @param _params List of parameters for pet.\r\n    /// @param _transferCost Transfer cost.\r\n    /// @return New token id.\r\n    function mintRelease(\r\n        address _to,\r\n        uint256 _fee,\r\n        \r\n        // Constant Token params\r\n        uint8   _genNum,\r\n        string   _genome,\r\n        uint256 _parentA,\r\n        uint256 _parentB,\r\n        \r\n        // Game-depening Token params\r\n        uint256 _petId,  //if petID = 0, then it was created outside of the server\r\n        string   _params,\r\n        uint256 _transferCost\r\n    )\r\n        external minionOnly operateModeOnly returns(uint256)\r\n    {\r\n        require(canMint(), \"can_mint\");\r\n        require(_to != NA, \"_to\");\r\n        require((_fee + _transferCost) <= address(this).balance, \"_fee\");\r\n        require(bytes(_params).length != 0, \"params_length\");\r\n        require(bytes(_genome).length == 77, \"genome_length\");\r\n        \r\n        // Parents should be both 0 or both not.\r\n        if (_parentA != 0 && _parentB != 0) {\r\n            require(_parentA != _parentB, \"same_parent\");\r\n        }\r\n        else if (_parentA == 0 && _parentB != 0) {\r\n            revert(\"parentA_empty\");\r\n        }\r\n        else if (_parentB == 0 && _parentA != 0) {\r\n            revert(\"parentB_empty\");\r\n        }\r\n\r\n        uint256 tokenId = _createToken(_to, _genNum, _genome, _parentA, _parentB, _petId, _params);\r\n\r\n        require(_checkAndCallSafeTransfer(NA, _to, tokenId, \"\"), \"safe_transfer\");\r\n\r\n        // Transfer mint fee to the fund\r\n        CommonWallet(bank_).receive.value(_fee)();\r\n\r\n        emit Transfer(NA, _to, tokenId);\r\n\r\n        // send to the server wallet server the transfer cost,\r\n        // withdraw it from the balance of the contract. this amount must be withdrawn from the player\r\n        // on the side of the game server\r\n        if (_transferCost > 0) {\r\n            msg.sender.transfer(_transferCost);\r\n        }\r\n\r\n        return tokenId;\r\n    }\r\n\r\n    /// @dev Create new token via presale state\r\n    /// @param _to New token owner.\r\n    /// @param _genome New genome unique value.\r\n    /// @return New token id.\r\n    /// at the pre-sale stage we sell the zero-generation pets, which have only a genome.\r\n    /// other attributes of such a token get when importing to the server\r\n    function mintPresell(address _to, string _genome)\r\n        external presaleOnly presaleModeOnly returns(uint256)\r\n    {\r\n        require(presaleCount_ < PRESALE_LIMIT, \"presale_limit\");\r\n\r\n        // у пресейл пета нет параметров. Их он получит после ввода в игру.\r\n        uint256 tokenId = _createToken(_to, 0, _genome, 0, 0, 0, \"\");\r\n        presaleCount_ += 1;\r\n\r\n        require(_checkAndCallSafeTransfer(NA, _to, tokenId, \"\"), \"safe_transfer\");\r\n\r\n        emit Transfer(NA, _to, tokenId);\r\n        \r\n        return tokenId;\r\n    }    \r\n    \r\n    /// @dev Create new token for bounty activity\r\n    /// @param _to New token owner.\r\n    /// @return New token id.\r\n    function mintBounty(address _to, string _genome)\r\n        external controllerOnly returns(uint256)\r\n    {\r\n        require(bountyCount_ < BOUNTY_LIMIT, \"bounty_limit\");\r\n\r\n        // bounty pet has no parameters. They will receive them after importing to the game.\r\n        uint256 tokenId = _createToken(_to, 0, _genome, 0, 0, 0, \"\");\r\n    \r\n        bountyCount_ += 1;\r\n        require(_checkAndCallSafeTransfer(NA, _to, tokenId, \"\"), \"safe_transfer\");\r\n\r\n        emit Transfer(NA, _to, tokenId);\r\n\r\n        return tokenId;\r\n    }        \r\n}\r\n\r\ncontract Presale\r\n{\r\n    // Extension ---------------------------------------------------------------\r\n    using AddressUtils for address;\r\n\r\n    // Events ------------------------------------------------------------------\r\n    ///the event is fired when starting a new wave presale stage\r\n    event StageBegin(uint8 stage, uint256 timestamp);\r\n\r\n    ///the event is fired when token sold\r\n    event TokensBought(address buyerAddr, uint256[] tokenIds, bytes genomes);\r\n\r\n    // Types -------------------------------------------------------------------\r\n    struct Stage {\r\n        // Predefined values\r\n        uint256 price;      // token's price on the stage\r\n        uint16 softcap;     // stage softCap\r\n        uint16 hardcap;     // stage hardCap\r\n        \r\n        // Unknown values\r\n        uint16 bought;      // sold on stage\r\n        uint32 startDate;   // stage's beginDate\r\n        uint32 endDate;     // stage's endDate\r\n    }\r\n    \r\n    // Constants ---------------------------------------------------------------\r\n    // 10 stages of 5 genocodes\r\n    uint8 public constant STAGES = 10;\r\n    uint8 internal constant TOKENS_PER_STAGE = 5;\r\n    address constant NA = address(0);\r\n    \r\n    // State -------------------------------------------------------------------\r\n    address internal CEOAddress;    // contract owner\r\n    address internal bank_;         // profit wallet address (not a contract)\r\n    address internal erc721_;       // main contract address\r\n    \r\n    /// @dev genomes for bounty stage\r\n    string[TOKENS_PER_STAGE][STAGES] internal genomes_;\r\n\r\n    /// stages data\r\n    Stage[STAGES] internal stages_;\r\n    \r\n    // internal transaction counter, it uses for random generator\r\n    uint32  internal counter_;\r\n    \r\n    /// stage is over\r\n    bool    internal isOver_;\r\n\r\n    /// stage number\r\n    uint8   internal stageIndex_;\r\n\r\n    ///  stage start Data\r\n    uint32  internal stageStart_;\r\n\r\n    // Lifetime ----------------------------------------------------------------\r\n    constructor(\r\n        address _bank,  \r\n        address _erc721\r\n    )\r\n        public\r\n    {\r\n        require(_bank != NA, '_bank');\r\n        require(_erc721.isContract(), '_erc721');\r\n\r\n        CEOAddress = msg.sender;\r\n\r\n        // Addresses should not be the same.\r\n        require(_bank != CEOAddress, \"bank = CEO\");\r\n        require(CEOAddress != _erc721, \"CEO = erc721\");\r\n        require(_erc721 != _bank, \"bank = erc721\");\r\n\r\n        // Update state\r\n        bank_ = _bank;\r\n        erc721_ = _erc721;\r\n       \r\n        // stages data \r\n        stages_[0].price = 10 finney;\r\n        stages_[0].softcap = 100;\r\n        stages_[0].hardcap = 300;\r\n        \r\n        stages_[1].price = 20 finney;\r\n        stages_[1].softcap = 156;\r\n        stages_[1].hardcap = 400;\r\n    \r\n        stages_[2].price = 32 finney;\r\n        stages_[2].softcap = 212;\r\n        stages_[2].hardcap = 500;\r\n        \r\n        stages_[3].price = 45 finney;\r\n        stages_[3].softcap = 268;\r\n        stages_[3].hardcap = 600;\r\n        \r\n        stages_[4].price = 58 finney;\r\n        stages_[4].softcap = 324;\r\n        stages_[4].hardcap = 700;\r\n    \r\n        stages_[5].price = 73 finney;\r\n        stages_[5].softcap = 380;\r\n        stages_[5].hardcap = 800;\r\n    \r\n        stages_[6].price = 87 finney;\r\n        stages_[6].softcap = 436;\r\n        stages_[6].hardcap = 900;\r\n    \r\n        stages_[7].price = 102 finney;\r\n        stages_[7].softcap = 492;\r\n        stages_[7].hardcap = 1000;\r\n    \r\n        stages_[8].price = 118 finney;\r\n        stages_[8].softcap = 548;\r\n        stages_[8].hardcap = 1100;\r\n        \r\n        stages_[9].price = 129 finney;\r\n        stages_[9].softcap = 604;\r\n        stages_[9].hardcap = 1200;\r\n    }\r\n\r\n    /// fill the genomes data\r\n    function setStageGenomes(\r\n        uint8 _stage,\r\n        string _genome0, \r\n        string _genome1,\r\n        string _genome2, \r\n        string _genome3, \r\n        string _genome4\r\n    ) \r\n        external controllerOnly\r\n    {\r\n        genomes_[_stage][0] = _genome0;\r\n        genomes_[_stage][1] = _genome1;\r\n        genomes_[_stage][2] = _genome2;\r\n        genomes_[_stage][3] = _genome3;\r\n        genomes_[_stage][4] = _genome4;\r\n    }\r\n\r\n    /// @dev Contract itself is non payable\r\n    function ()\r\n        public payable\r\n    {\r\n        revert();\r\n    }\r\n    \r\n    // Modifiers ---------------------------------------------------------------\r\n    \r\n    /// only from contract owner\r\n    modifier controllerOnly() {\r\n        require(msg.sender == CEOAddress, 'controller_only');\r\n        _;\r\n    }\r\n\r\n    /// only for active stage\r\n    modifier notOverOnly() {\r\n        require(isOver_ == false, 'notOver_only');\r\n        _;\r\n    }\r\n\r\n    // Getters -----------------------------------------------------------------\r\n    /// owner address\r\n    function getCEOAddress()\r\n        public view returns(address)\r\n    {\r\n        return CEOAddress;\r\n    }\r\n\r\n    /// counter from random number generator\r\n    function counter()\r\n        internal view returns(uint32)\r\n    {\r\n        return counter_;\r\n    }\r\n\r\n    // tokens sold by stage ...\r\n    function stageTokensBought(uint8 _stage)\r\n        public view returns(uint16)\r\n    {\r\n        return stages_[_stage].bought;\r\n    }\r\n\r\n    // stage softcap\r\n    function stageSoftcap(uint8 _stage)\r\n        public view returns(uint16)\r\n    {\r\n        return stages_[_stage].softcap;\r\n    }\r\n\r\n    /// stage hardcap\r\n    function stageHardcap(uint8 _stage)\r\n        public view returns(uint16)\r\n    {\r\n        return stages_[_stage].hardcap;\r\n    }\r\n\r\n    /// stage Start Date    \r\n    function stageStartDate(uint8 _stage)\r\n        public view returns(uint)\r\n    {\r\n        return stages_[_stage].startDate;\r\n    }\r\n    \r\n    /// stage Finish Date\r\n    function stageEndDate(uint8 _stage)\r\n        public view returns(uint)\r\n    {\r\n        return stages_[_stage].endDate;\r\n    }\r\n\r\n    /// stage token price\r\n    function stagePrice(uint _stage)\r\n        public view returns(uint)\r\n    {\r\n        return stages_[_stage].price;\r\n    }\r\n    \r\n    // Genome Logic -----------------------------------------------------------------\r\n    /// within the prelase , the dragons are generated, which are the ancestors of the destiny\r\n    /// newborns have a high chance of mutation and are unlikely to be purebred\r\n    /// the player will have to collect the breed, crossing a lot of pets\r\n    /// In addition, you will need to pick up combat abilities\r\n    /// these characteristics are assigned to the pet when the dragon is imported to the game server.    \r\n    function nextGenome()\r\n        internal returns(string)\r\n    {\r\n        uint8 n = getPseudoRandomNumber();\r\n\r\n        counter_ += 1;\r\n        \r\n        return genomes_[stageIndex_][n];\r\n    }\r\n\r\n    function getPseudoRandomNumber()\r\n        internal view returns(uint8 index)\r\n    {\r\n        uint8 n = uint8(\r\n            keccak256(abi.encode(msg.sender, block.timestamp + counter_))\r\n        );\r\n        return n % TOKENS_PER_STAGE;\r\n    }\r\n    \r\n    // PreSale Logic -----------------------------------------------------------------\r\n    /// Presale stage0 begin date set\r\n    /// presale start is possible only once    \r\n    function setStartDate(uint32 _startDate)\r\n        external controllerOnly\r\n    {\r\n        require(stages_[0].startDate == 0, 'already_set');\r\n        \r\n        stages_[0].startDate = _startDate;\r\n        stageStart_ = _startDate;\r\n        stageIndex_ = 0;\r\n        \r\n        emit StageBegin(stageIndex_, stageStart_); \r\n    }\r\n\r\n    /// current stage number\r\n    /// switches to the next stage if the time has come\r\n    function stageIndex()\r\n        external view returns(uint8)\r\n    {\r\n        Stage memory stage = stages_[stageIndex_];\r\n\r\n        if (stage.endDate > 0 && stage.endDate <= now) {\r\n            return stageIndex_ + 1;\r\n        }\r\n        else {\r\n            return stageIndex_;\r\n        }\r\n    }\r\n    \r\n    /// check whether the phase started\r\n    /// switch to the next stage, if necessary    \r\n    function beforeBuy()\r\n        internal\r\n    {\r\n        if (stageStart_ == 0) {\r\n            revert('presale_not_started');\r\n        }\r\n        else if (stageStart_ > now) {\r\n            revert('stage_not_started');\r\n        }\r\n\r\n        Stage memory stage = stages_[stageIndex_];\r\n        if (stage.endDate > 0 && stage.endDate <= now) \r\n        {\r\n            stageIndex_ += 1;\r\n            stageStart_ = stages_[stageIndex_].startDate;\r\n\r\n            if (stageStart_ > now) {\r\n                revert('stage_not_started');\r\n            }\r\n        }\r\n    }\r\n    \r\n    /// time to next midnight\r\n    function midnight()\r\n        public view returns(uint32)\r\n    {\r\n        uint32 tomorrow = uint32(now + 1 days);\r\n        uint32 remain = uint32(tomorrow % 1 days);\r\n        return tomorrow - remain;\r\n    }\r\n    \r\n    /// buying a specified number of tokens\r\n    function buyTokens(uint16 numToBuy)\r\n        public payable notOverOnly returns(uint256[])\r\n    {\r\n        beforeBuy();\r\n        \r\n        require(numToBuy > 0 && numToBuy <= 10, \"numToBuy error\");\r\n\r\n        Stage storage stage = stages_[stageIndex_];\r\n        require((stage.price * numToBuy) <= msg.value, 'price');\r\n        \r\n        uint16 prevBought = stage.bought;\r\n        require(prevBought + numToBuy <= stage.hardcap, \"have required tokens\");\r\n        \r\n        stage.bought += numToBuy;\r\n        uint256[] memory tokenIds = new uint256[](numToBuy);\r\n        \r\n        bytes memory genomes = new bytes(numToBuy * 77);\r\n        uint32 genomeByteIndex = 0;\r\n\r\n        for(uint16 t = 0; t < numToBuy; t++) \r\n        {\r\n            string memory genome = nextGenome();\r\n            uint256 tokenId = EtherDragonsCore(erc721_).mintPresell(msg.sender, genome);\r\n\r\n            bytes memory genomeBytes = bytes(genome);\r\n            \r\n            for(uint8 gi = 0; gi < genomeBytes.length; gi++) {\r\n                genomes[genomeByteIndex++] = genomeBytes[gi];\r\n            }\r\n\r\n            tokenIds[t] = tokenId;\r\n        }\r\n\r\n        // Transfer mint fee to the fund\r\n        bank_.transfer(address(this).balance);\r\n\r\n        if (stage.bought == stage.hardcap) {\r\n            stage.endDate = uint32(now);\r\n            stageStart_ = midnight() + 1 days + 1 seconds;\r\n            if (stageIndex_ < STAGES - 1) {\r\n                stageIndex_ += 1;\r\n            }\r\n            else {\r\n                isOver_ = true;\r\n            }\r\n        }\r\n        else if (stage.bought >= stage.softcap && prevBought < stage.softcap) {\r\n            stage.endDate = midnight() + 1 days;\r\n            if (stageIndex_ < STAGES - 1) {\r\n                stages_[stageIndex_ + 1].startDate = stage.endDate + 1 days;\r\n            }\r\n        }\r\n\r\n        emit TokensBought(msg.sender, tokenIds, genomes);\r\n\r\n        return tokenIds;\r\n    }\r\n\r\n    function currTime()\r\n        public view returns(uint)\r\n    {\r\n        return now;\r\n    }\r\n    \r\n    /// stages data\r\n    function getStagesInfo() \r\n        public view returns (uint256[] prices, uint16[] softcaps, uint16[] hardcaps, uint16[] boughts) \r\n    {\r\n            prices = new uint256[](STAGES);\r\n            softcaps = new uint16[](STAGES);\r\n            hardcaps = new uint16[](STAGES);\r\n            boughts = new uint16[](STAGES);\r\n            \r\n            for(uint8 s = 0; s < STAGES; s++) {\r\n                prices[s] = stages_[s].price;\r\n                softcaps[s] = stages_[s].softcap;\r\n                hardcaps[s] = stages_[s].hardcap;\r\n                boughts[s] = stages_[s].bought;\r\n            }\r\n    }\r\n    \r\n    /// stages dates data\r\n    function getStagesBeginEnd() \r\n        public view returns (uint32[] startDates, uint32[] endDates) \r\n    {\r\n        startDates = new uint32[](STAGES);\r\n        endDates = new uint32[](STAGES);\r\n        \r\n        for(uint8 s = 0; s < STAGES; s++) {\r\n            startDates[s] = stages_[s].startDate;\r\n            endDates[s] = stages_[s].endDate;\r\n        }\r\n    }\r\n\r\n    /// returns data which genomes can be purchased at the stage\r\n    function stageGenomes(uint8 _stage)\r\n        public view returns(byte[])\r\n    {\r\n        byte[] memory genomes = new byte[](uint16(TOKENS_PER_STAGE) * 77);\r\n        uint32 gbIndex = 0;\r\n\r\n        for(uint8 tokenIndex = 0; tokenIndex < TOKENS_PER_STAGE; tokenIndex++) {\r\n            \r\n            bytes memory genomeBytes = bytes(genomes_[_stage][tokenIndex]);\r\n            \r\n            for(uint8 gi = 0; gi < genomeBytes.length; gi++) {\r\n                genomes[gbIndex++] = genomeBytes[gi];\r\n            }\r\n        }\r\n\r\n        return genomes;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"stageEndDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"numToBuy\",\"type\":\"uint16\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"},{\"name\":\"_genome0\",\"type\":\"string\"},{\"name\":\"_genome1\",\"type\":\"string\"},{\"name\":\"_genome2\",\"type\":\"string\"},{\"name\":\"_genome3\",\"type\":\"string\"},{\"name\":\"_genome4\",\"type\":\"string\"}],\"name\":\"setStageGenomes\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStagesBeginEnd\",\"outputs\":[{\"name\":\"startDates\",\"type\":\"uint32[]\"},{\"name\":\"endDates\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"stageTokensBought\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STAGES\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"midnight\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"stageHardcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStagesInfo\",\"outputs\":[{\"name\":\"prices\",\"type\":\"uint256[]\"},{\"name\":\"softcaps\",\"type\":\"uint16[]\"},{\"name\":\"hardcaps\",\"type\":\"uint16[]\"},{\"name\":\"boughts\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"stageStartDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"stageGenomes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startDate\",\"type\":\"uint32\"}],\"name\":\"setStartDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint256\"}],\"name\":\"stagePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_stage\",\"type\":\"uint8\"}],\"name\":\"stageSoftcap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCEOAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stageIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_bank\",\"type\":\"address\"},{\"name\":\"_erc721\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stage\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"StageBegin\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenIds\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"genomes\",\"type\":\"bytes\"}],\"name\":\"TokensBought\",\"type\":\"event\"}]","ContractName":"Presale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000aa7b1425d5f79386235c84e180874da8b63dc2920000000000000000000000001680855238bf0dfb458dcf46ceb146b18ef65bd2","Library":"","SwarmSource":"bzzr://0929c159307ddb3761ae8bf080321af40e57372033ae728f7b972f2a3b21b7aa"}]}