{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an address access to this role\r\n   */\r\n  function add(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an address' access to this role\r\n   */\r\n  function remove(Role storage role, address addr)\r\n    internal\r\n  {\r\n    role.bearer[addr] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * // reverts\r\n   */\r\n  function check(Role storage role, address addr)\r\n    view\r\n    internal\r\n  {\r\n    require(has(role, addr));\r\n  }\r\n\r\n  /**\r\n   * @dev check if an address has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address addr)\r\n    view\r\n    internal\r\n    returns (bool)\r\n  {\r\n    return role.bearer[addr];\r\n  }\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract MultiSigTransfer is Ownable {\r\n  string public name = \"MultiSigTransfer\";\r\n  string public symbol = \"MST\";\r\n  bool public complete = false;\r\n  bool public denied = false;\r\n  uint32 public quantity;\r\n  address public targetAddress;\r\n  address public requesterAddress;\r\n\r\n  /**\r\n  * @dev The multisig transfer contract ensures that no single administrator can\r\n  * KVTs without approval of another administrator\r\n  * @param _quantity The number of KVT to transfer\r\n  * @param _targetAddress The receiver of the KVTs\r\n  * @param _requesterAddress The administrator requesting the transfer\r\n  */\r\n  constructor(\r\n    uint32 _quantity,\r\n    address _targetAddress,\r\n    address _requesterAddress\r\n  ) public {\r\n    quantity = _quantity;\r\n    targetAddress = _targetAddress;\r\n    requesterAddress = _requesterAddress;\r\n  }\r\n\r\n  /**\r\n  * @dev Mark the transfer as approved / complete\r\n  */\r\n  function approveTransfer() public onlyOwner {\r\n    require(denied == false, \"cannot approve a denied transfer\");\r\n    require(complete == false, \"cannot approve a complete transfer\");\r\n    complete = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Mark the transfer as denied\r\n  */\r\n  function denyTransfer() public onlyOwner {\r\n    require(denied == false, \"cannot deny a transfer that is already denied\");\r\n    denied = true;\r\n  }\r\n\r\n  /**\r\n  * @dev Determine if the transfer is pending\r\n  */\r\n  function isPending() public view returns (bool) {\r\n    return !complete;\r\n  }\r\n}\r\n\r\ncontract RBAC {\r\n  using Roles for Roles.Role;\r\n\r\n  mapping (string => Roles.Role) private roles;\r\n\r\n  event RoleAdded(address indexed operator, string role);\r\n  event RoleRemoved(address indexed operator, string role);\r\n\r\n  /**\r\n   * @dev reverts if addr does not have role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  function checkRole(address _operator, string _role)\r\n    view\r\n    public\r\n  {\r\n    roles[_role].check(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev determine if addr has role\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   * @return bool\r\n   */\r\n  function hasRole(address _operator, string _role)\r\n    view\r\n    public\r\n    returns (bool)\r\n  {\r\n    return roles[_role].has(_operator);\r\n  }\r\n\r\n  /**\r\n   * @dev add a role to an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function addRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].add(_operator);\r\n    emit RoleAdded(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev remove a role from an address\r\n   * @param _operator address\r\n   * @param _role the name of the role\r\n   */\r\n  function removeRole(address _operator, string _role)\r\n    internal\r\n  {\r\n    roles[_role].remove(_operator);\r\n    emit RoleRemoved(_operator, _role);\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a single role (uses msg.sender as addr)\r\n   * @param _role the name of the role\r\n   * // reverts\r\n   */\r\n  modifier onlyRole(string _role)\r\n  {\r\n    checkRole(msg.sender, _role);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev modifier to scope access to a set of roles (uses msg.sender as addr)\r\n   * @param _roles the names of the roles to scope access to\r\n   * // reverts\r\n   *\r\n   * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this\r\n   *  see: https://github.com/ethereum/solidity/issues/2467\r\n   */\r\n  // modifier onlyRoles(string[] _roles) {\r\n  //     bool hasAnyRole = false;\r\n  //     for (uint8 i = 0; i < _roles.length; i++) {\r\n  //         if (hasRole(msg.sender, _roles[i])) {\r\n  //             hasAnyRole = true;\r\n  //             break;\r\n  //         }\r\n  //     }\r\n\r\n  //     require(hasAnyRole);\r\n\r\n  //     _;\r\n  // }\r\n}\r\n\r\ncontract KinesisVelocityToken is BasicToken, Ownable, RBAC {\r\n  string public name = \"KinesisVelocityToken\";\r\n  string public symbol = \"KVT\";\r\n  uint8 public decimals = 0;\r\n  string public constant ADMIN_ROLE = \"ADMIN\";\r\n\r\n  address[] public transfers;\r\n\r\n  uint public constant INITIAL_SUPPLY = 300000;\r\n  uint public totalSupply = 0;\r\n\r\n  bool public isTransferable = false;\r\n  bool public toggleTransferablePending = false;\r\n  address public transferToggleRequester = address(0);\r\n\r\n  constructor() public {\r\n    totalSupply = INITIAL_SUPPLY;\r\n    balances[msg.sender] = INITIAL_SUPPLY;\r\n    addRole(msg.sender, ADMIN_ROLE);\r\n  }\r\n\r\n  /**\r\n  * @dev Determine if the address is the owner of the contract\r\n  * @param _address The address to determine of ownership\r\n  */\r\n  function isOwner(address _address) public view returns (bool) {\r\n    return owner == _address;\r\n  }\r\n\r\n  /**\r\n  * @dev Returns the list of MultiSig transfers\r\n  */\r\n  function getTransfers() public view returns (address[]) {\r\n    return transfers;\r\n  }\r\n\r\n  /**\r\n  * @dev The KVT ERC20 token uses adminstrators to handle transfering to the crowdsale, vesting and pre-purchasers\r\n  */\r\n  function isAdmin(address _address) public view returns (bool) {\r\n    return hasRole(_address, ADMIN_ROLE);\r\n  }\r\n\r\n  /**\r\n  * @dev Set an administrator as the owner, using Open Zepplin RBAC implementation\r\n  */\r\n  function setAdmin(address _newAdmin) public onlyOwner {\r\n    return addRole(_newAdmin, ADMIN_ROLE);\r\n  }\r\n\r\n  /**\r\n  * @dev Remove an administrator as the owner, using Open Zepplin RBAC implementation\r\n  */\r\n  function removeAdmin(address _oldAdmin) public onlyOwner {\r\n    return removeRole(_oldAdmin, ADMIN_ROLE);\r\n  }\r\n\r\n  /**\r\n  * @dev As an administrator, request the token is made transferable\r\n  * @param _toState The transfer state being requested\r\n  */\r\n  function setTransferable(bool _toState) public onlyRole(ADMIN_ROLE) {\r\n    require(isTransferable != _toState, \"to init a transfer toggle, the toState must change\");\r\n    toggleTransferablePending = true;\r\n    transferToggleRequester = msg.sender;\r\n  }\r\n\r\n  /**\r\n  * @dev As an administrator who did not make the request, approve the transferable state change\r\n  */\r\n  function approveTransferableToggle() public onlyRole(ADMIN_ROLE) {\r\n    require(toggleTransferablePending == true, \"transfer toggle not in pending state\");\r\n    require(transferToggleRequester != msg.sender, \"the requester cannot approve the transfer toggle\");\r\n    isTransferable = !isTransferable;\r\n    toggleTransferablePending = false;\r\n    transferToggleRequester = address(0);\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function _transfer(address _to, address _from, uint256 _value) private returns (bool) {\r\n    require(_value <= balances[_from], \"the balance in the from address is smaller than the tx value\");\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Public transfer token function. This wrapper ensures the token is transferable\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0), \"cannot transfer to the zero address\");\r\n\r\n    /* We allow holders to return their Tokens to the contract owner at any point */\r\n    if (_to != owner && msg.sender != crowdsale) {\r\n      require(isTransferable == true, \"kvt is not yet transferable\");\r\n    }\r\n\r\n    /* Transfers from the owner address must use the administrative transfer */\r\n    require(msg.sender != owner, \"the owner of the kvt contract cannot transfer\");\r\n\r\n    return _transfer(_to, msg.sender, _value);\r\n  }\r\n\r\n  /**\r\n  * @dev Request an administrative transfer. This does not move tokens\r\n  * @param _to The address to transfer to.\r\n  * @param _quantity The amount to be transferred.\r\n  */\r\n  function adminTransfer(address _to, uint32 _quantity) public onlyRole(ADMIN_ROLE) {\r\n    address newTransfer = new MultiSigTransfer(_quantity, _to, msg.sender);\r\n    transfers.push(newTransfer);\r\n  }\r\n\r\n  /**\r\n  * @dev Approve an administrative transfer. This moves the tokens if the requester\r\n  * is an admin, but not the same admin as the one who made the request\r\n  * @param _approvedTransfer The contract address of the multisignature transfer.\r\n  */\r\n  function approveTransfer(address _approvedTransfer) public onlyRole(ADMIN_ROLE) returns (bool) {\r\n    MultiSigTransfer transferToApprove = MultiSigTransfer(_approvedTransfer);\r\n\r\n    uint32 transferQuantity = transferToApprove.quantity();\r\n    address deliveryAddress = transferToApprove.targetAddress();\r\n    address requesterAddress = transferToApprove.requesterAddress();\r\n\r\n    require(msg.sender != requesterAddress, \"a requester cannot approve an admin transfer\");\r\n\r\n    transferToApprove.approveTransfer();\r\n    return _transfer(deliveryAddress, owner, transferQuantity);\r\n  }\r\n\r\n  /**\r\n  * @dev Deny an administrative transfer. This ensures it cannot be approved.\r\n  * @param _approvedTransfer The contract address of the multisignature transfer.\r\n  */\r\n  function denyTransfer(address _approvedTransfer) public onlyRole(ADMIN_ROLE) returns (bool) {\r\n    MultiSigTransfer transferToApprove = MultiSigTransfer(_approvedTransfer);\r\n    transferToApprove.denyTransfer();\r\n  }\r\n\r\n  address public crowdsale = address(0);\r\n\r\n  /**\r\n  * @dev Any admin can set the current crowdsale address, to allows transfers\r\n  * from the crowdsale to the purchaser\r\n  */\r\n  function setCrowdsaleAddress(address _crowdsaleAddress) public onlyRole(ADMIN_ROLE) {\r\n    crowdsale = _crowdsaleAddress;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"checkRole\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldAdmin\",\"type\":\"address\"}],\"name\":\"removeAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsaleAddress\",\"type\":\"address\"}],\"name\":\"setCrowdsaleAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isTransferable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"string\"}],\"name\":\"hasRole\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"toggleTransferablePending\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_quantity\",\"type\":\"uint32\"}],\"name\":\"adminTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_SUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"approveTransferableToggle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approvedTransfer\",\"type\":\"address\"}],\"name\":\"approveTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ADMIN_ROLE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transfers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toState\",\"type\":\"bool\"}],\"name\":\"setTransferable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferToggleRequester\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approvedTransfer\",\"type\":\"address\"}],\"name\":\"denyTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"string\"}],\"name\":\"RoleRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"KinesisVelocityToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e627866e043cf4da56f8c79cec5a79ae3e0ab147c534df8d16f19fe0b4d13b9c"}]}