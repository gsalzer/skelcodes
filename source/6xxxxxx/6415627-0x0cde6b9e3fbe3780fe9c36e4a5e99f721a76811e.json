{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * In this place you can write any text before deploy the contract in MainNet\r\n */\r\n\r\npragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address _who) external view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender) external view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) external returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) external returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b,\"Math error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0,\"Math error\"); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a,\"Math error\");\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a,\"Math error\");\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0,\"Math error\");\r\n        return a % b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n * @dev Implementation of the basic standard token.\r\n */\r\ncontract ERC20 is IERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => uint256) internal balances_;\r\n\r\n    mapping (address => mapping (address => uint256)) private allowed_;\r\n\r\n    uint256 private totalSupply_;\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances_[_owner];\r\n    }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n      public\r\n      view\r\n      returns (uint256)\r\n    {\r\n        return allowed_[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer token for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances_[msg.sender],\"Invalid value\");\r\n        require(_to != address(0),\"Invalid address\");\r\n\r\n        balances_[msg.sender] = balances_[msg.sender].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n    * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n    * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n    * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n    * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _value The amount of tokens to be spent.\r\n    */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed_[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        require(_value <= balances_[_from],\"Value is more than balance\");\r\n        require(_value <= allowed_[_from][msg.sender],\"Value is more than alloved\");\r\n        require(_to != address(0),\"Invalid address\");\r\n\r\n        balances_[_from] = balances_[_from].sub(_value);\r\n        balances_[_to] = balances_[_to].add(_value);\r\n        allowed_[_from][msg.sender] = allowed_[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        allowed_[msg.sender][_spender] = (allowed_[msg.sender][_spender].add(_addedValue));\r\n        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed_[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n      public\r\n      returns (bool)\r\n    {\r\n        uint256 oldValue = allowed_[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed_[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed_[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed_[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that mints an amount of the token and assigns it to\r\n    * an account. This encapsulates the modification of balances such that the\r\n    * proper events are emitted.\r\n    * @param _account The account that will receive the created tokens.\r\n    * @param _amount The amount that will be created.\r\n    */\r\n    function _mint(address _account, uint256 _amount) internal {\r\n        require(_account != 0,\"Invalid address\");\r\n        totalSupply_ = totalSupply_.add(_amount);\r\n        balances_[_account] = balances_[_account].add(_amount);\r\n        emit Transfer(address(0), _account, _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account.\r\n    * @param _account The account whose tokens will be burnt.\r\n    * @param _amount The amount that will be burnt.\r\n    */\r\n    function _burn(address _account, uint256 _amount) internal {\r\n        require(_account != 0,\"Invalid address\");\r\n        require(_amount <= balances_[_account],\"Amount is more than balance\");\r\n\r\n        totalSupply_ = totalSupply_.sub(_amount);\r\n        balances_[_account] = balances_[_account].sub(_amount);\r\n        emit Transfer(_account, address(0), _amount);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function that burns an amount of the token of a given\r\n    * account, deducting from the sender's allowance for said account. Uses the\r\n    * internal _burn function.\r\n    * @param _account The account whose tokens will be burnt.\r\n    * @param _amount The amount that will be burnt.\r\n    */\r\n    function _burnFrom(address _account, uint256 _amount) internal {\r\n        require(_amount <= allowed_[_account][msg.sender],\"Amount is more than alloved\");\r\n\r\n        // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n        // this function needs to emit an event with the updated approval.\r\n        allowed_[_account][msg.sender] = allowed_[_account][msg.sender].sub(_amount);\r\n        _burn(_account, _amount);\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n    function safeTransfer(\r\n        IERC20 _token,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.transfer(_to, _value),\"Transfer error\");\r\n    }\r\n\r\n    function safeTransferFrom(\r\n        IERC20 _token,\r\n        address _from,\r\n        address _to,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.transferFrom(_from, _to, _value),\"Tranfer error\");\r\n    }\r\n\r\n    function safeApprove(\r\n        IERC20 _token,\r\n        address _spender,\r\n        uint256 _value\r\n    )\r\n      internal\r\n    {\r\n        require(_token.approve(_spender, _value),\"Approve error\");\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable {\r\n    event Paused();\r\n    event Unpaused();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is not paused.\r\n    */\r\n    modifier whenNotPaused() {\r\n        require(!paused,\"Contract is paused, sorry\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Modifier to make a function callable only when the contract is paused.\r\n    */\r\n    modifier whenPaused() {\r\n        require(paused, \"Contract is running now\");\r\n        _;\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev ERC20 modified with pausable transfers.\r\n **/\r\ncontract ERC20Pausable is ERC20, Pausable {\r\n\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Contract RESTO token\r\n * @dev ERC20 compatible token contract\r\n */\r\ncontract RESTOToken is ERC20Pausable {\r\n    string public constant name = \"RESTO\";\r\n    string public constant symbol = \"RESTO\";\r\n    uint32 public constant decimals = 18;\r\n    uint256 public INITIAL_SUPPLY = 1100000000 * 1 ether; // 1 100 000 000\r\n    address public CrowdsaleAddress;\r\n    uint64 crowdSaleEndTime = 1544745600;       // 14.12.2018\r\n\r\n    mapping (address => bool) internal kyc;\r\n\r\n\r\n    constructor(address _CrowdsaleAddress) public {\r\n    \r\n        CrowdsaleAddress = _CrowdsaleAddress;\r\n        _mint(_CrowdsaleAddress, INITIAL_SUPPLY);\r\n    }\r\n\r\n    modifier kyc_passed(address _investor) {\r\n        if (_investor != CrowdsaleAddress){\r\n            require(kyc[_investor],\"For transfer tokens you need to go through the procedure KYC\");\r\n        }\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == CrowdsaleAddress,\"Only CrowdSale contract can run this\");\r\n        _;\r\n    }\r\n    \r\n    modifier validDestination( address to ) {\r\n        require(to != address(0x0),\"Empty address\");\r\n        require(to != address(this),\"RESTO Token address\");\r\n        _;\r\n    }\r\n    \r\n    modifier isICOover {\r\n        if (msg.sender != CrowdsaleAddress){\r\n            require(now > crowdSaleEndTime,\"Transfer of tokens is prohibited until the end of the ICO\");\r\n        }\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev Override for testing address destination\r\n     */\r\n    function transfer(address _to, uint256 _value) public validDestination(_to) kyc_passed(msg.sender) isICOover returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n     * @dev Override for testing address destination\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) \r\n    public validDestination(_to) kyc_passed(msg.sender) isICOover returns (bool) \r\n    {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    \r\n    /**\r\n     * @dev function set kyc bool to true\r\n     * can run only from crowdsale contract\r\n     * @param _investor The investor who passed the procedure KYC\r\n     */\r\n    function kycPass(address _investor) public onlyOwner {\r\n        kyc[_investor] = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev function transfer tokens from special address to users\r\n     * can run only from crowdsale contract\r\n     * @param _value is entered in whole tokens (1 = 1 token)\r\n     */\r\n    function transferTokensFromSpecialAddress(address _from, address _to, uint256 _value) public onlyOwner whenNotPaused returns (bool){\r\n        uint256 value = _value;\r\n        require (value >= 1,\"Min value is 1\");\r\n        value = value.mul(1 ether);\r\n        require (balances_[_from] >= value,\"Decrease value\");\r\n        \r\n        balances_[_from] = balances_[_from].sub(value);\r\n        balances_[_to] = balances_[_to].add(value);\r\n        \r\n        emit Transfer(_from, _to, value);\r\n        \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev called from crowdsale contract to pause, triggers stopped state\r\n     * can run only from crowdsale contract\r\n     */\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Paused();\r\n    }\r\n\r\n    /**\r\n     * @dev called from crowdsale contract to unpause, returns to normal state\r\n     * can run only from crowdsale contract\r\n     */\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpaused();\r\n    }\r\n\r\n    function() external payable {\r\n        revert(\"The token contract don`t receive ether\");\r\n    }  \r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner and manager addresses, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n    address public manager;\r\n    address candidate;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        manager = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner,\"Access denied\");\r\n        _;\r\n    }\r\n\r\n    modifier restricted() {\r\n        require(msg.sender == owner || msg.sender == manager,\"Access denied\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != address(0),\"Invalid address\");\r\n        candidate = _newOwner;\r\n    }\r\n\r\n    function setManager(address _newManager) public onlyOwner {\r\n        require(_newManager != address(0),\"Invalid address\");\r\n        manager = _newManager;\r\n    }\r\n\r\n\r\n    function confirmOwnership() public {\r\n        require(candidate == msg.sender,\"Only from candidate\");\r\n        owner = candidate;\r\n        delete candidate;\r\n    }\r\n\r\n}\r\n\r\n\r\ncontract TeamAddress1 {\r\n    function() external payable {\r\n        revert(\"The contract don`t receive ether\");\r\n    } \r\n}\r\n\r\n\r\ncontract TeamAddress2 {\r\n    function() external payable {\r\n        revert(\"The contract don`t receive ether\");\r\n    } \r\n}\r\n\r\n\r\ncontract MarketingAddress {\r\n    function() external payable {\r\n        revert(\"The contract don`t receive ether\");\r\n    } \r\n}\r\n\r\n\r\ncontract RetailersAddress {\r\n    function() external payable {\r\n        revert(\"The contract don`t receive ether\");\r\n    } \r\n}\r\n\r\n\r\ncontract ReserveAddress {\r\n    function() external payable {\r\n        revert(\"The contract don`t receive ether\");\r\n    } \r\n}\r\n\r\n\r\ncontract BountyAddress {\r\n    function() external payable {\r\n        revert(\"The contract don`t receive ether\");\r\n    } \r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale\r\n */\r\ncontract Crowdsale is Ownable {\r\n    using SafeMath for uint256;\r\n    using SafeERC20 for RESTOToken;\r\n\r\n    uint256 hardCap = 50000 * 1 ether;\r\n    address myAddress = this;\r\n    RESTOToken public token = new RESTOToken(myAddress);\r\n    uint64 crowdSaleStartTime = 1537401600;     // 20.09.2018\r\n    uint64 crowdSaleEndTime = 1544745600;       // 14.12.2018\r\n\r\n    //Addresses for store tokens\r\n    TeamAddress1 public teamAddress1 = new TeamAddress1();\r\n    TeamAddress2 public teamAddress2 = new TeamAddress2();\r\n    MarketingAddress public marketingAddress = new MarketingAddress();\r\n    RetailersAddress public retailersAddress = new RetailersAddress();\r\n    ReserveAddress public reserveAddress = new ReserveAddress();\r\n    BountyAddress public bountyAddress = new BountyAddress();\r\n      \r\n    // How many token units a buyer gets per wei.\r\n    uint256 public rate;\r\n\r\n    // Amount of wei raised\r\n    uint256 public weiRaised;\r\n\r\n    event Withdraw(\r\n        address indexed from, \r\n        address indexed to, \r\n        uint256 amount\r\n    );\r\n\r\n    event TokensPurchased(\r\n        address indexed purchaser,\r\n        address indexed beneficiary,\r\n        uint256 value,\r\n        uint256 amount\r\n    );\r\n\r\n    constructor() public {\r\n        uint256 totalTokens = token.INITIAL_SUPPLY();\r\n        /**\r\n        * @dev Inicial distributing tokens to special adresses\r\n        * TeamAddress1 - 4.5%\r\n        * TeamAddress2 - 13.5% (hold one year)\r\n        * MarketingAddress - 18%\r\n        * RetailersAddress - 9%\r\n        * ReserveAddress - 8%\r\n        * BountyAddress - 1%\r\n        */\r\n        _deliverTokens(teamAddress1, totalTokens.mul(45).div(1000));\r\n        _deliverTokens(teamAddress2, totalTokens.mul(135).div(1000));\r\n        _deliverTokens(marketingAddress, totalTokens.mul(18).div(100));\r\n        _deliverTokens(retailersAddress, totalTokens.mul(9).div(100));\r\n        _deliverTokens(reserveAddress, totalTokens.mul(8).div(100));\r\n        _deliverTokens(bountyAddress, totalTokens.div(100));\r\n\r\n        rate = 1000;\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // Crowdsale external interface\r\n    // -----------------------------------------\r\n\r\n    /**\r\n    * @dev fallback function\r\n    */\r\n    function () external payable {\r\n        require(msg.data.length == 0,\"Only for simple payments\");\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * @dev low level token purchase ***DO NOT OVERRIDE***\r\n    * @param _beneficiary Address performing the token purchase\r\n    */\r\n    function buyTokens(address _beneficiary) public payable {\r\n        uint256 weiAmount = msg.value;\r\n        _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n        // calculate token amount to be created\r\n        uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n        // update state\r\n        weiRaised = weiRaised.add(weiAmount);\r\n\r\n        _processPurchase(_beneficiary, tokens);\r\n        \r\n        emit TokensPurchased(\r\n            msg.sender,\r\n            _beneficiary,\r\n            weiAmount,\r\n            tokens\r\n        );\r\n\r\n    }\r\n\r\n    // -----------------------------------------\r\n    // Internal interface (extensible)\r\n    // -----------------------------------------\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pauseCrowdsale() public onlyOwner {\r\n        token.pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpauseCrowdsale() public onlyOwner {\r\n        token.unpause();\r\n    }\r\n\r\n    /**\r\n     * @dev function set kyc bool to true\r\n     * @param _investor The investor who passed the procedure KYC\r\n     */\r\n    function setKYCpassed(address _investor) public restricted returns(bool){\r\n        token.kycPass(_investor);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev the function tranfer tokens from TeamAddress1 to investor\r\n     * @param _value is entered in whole tokens (1 = 1 token)\r\n     */\r\n    function transferTokensFromTeamAddress1(address _investor, uint256 _value) public restricted returns(bool){\r\n        token.transferTokensFromSpecialAddress(address(teamAddress1), _investor, _value); \r\n        return true;\r\n    } \r\n\r\n    /**\r\n     * @dev the function tranfer tokens from TeamAddress1 to investor\r\n     * only after 1 year\r\n     * @param _value is entered in whole tokens (1 = 1 token)\r\n     */\r\n    function transferTokensFromTeamAddress2(address _investor, uint256 _value) public restricted returns(bool){\r\n        require (now >= (crowdSaleEndTime + 365 days), \"Only after 1 year\");\r\n        token.transferTokensFromSpecialAddress(address(teamAddress2), _investor, _value); \r\n        return true;\r\n    } \r\n    \r\n    /**\r\n     * @dev the function tranfer tokens from MarketingAddress to investor\r\n     * @param _value is entered in whole tokens (1 = 1 token)\r\n     */\r\n    function transferTokensFromMarketingAddress(address _investor, uint256 _value) public restricted returns(bool){\r\n        token.transferTokensFromSpecialAddress(address(marketingAddress), _investor, _value); \r\n        return true;\r\n    } \r\n    \r\n    /**\r\n     * @dev the function tranfer tokens from RetailersAddress to investor\r\n     * @param _value is entered in whole tokens (1 = 1 token)\r\n     */\r\n    function transferTokensFromRetailersAddress(address _investor, uint256 _value) public restricted returns(bool){\r\n        token.transferTokensFromSpecialAddress(address(retailersAddress), _investor, _value); \r\n        return true;\r\n    } \r\n\r\n    /**\r\n     * @dev the function tranfer tokens from ReserveAddress to investor\r\n     * @param _value is entered in whole tokens (1 = 1 token)\r\n     */\r\n    function transferTokensFromReserveAddress(address _investor, uint256 _value) public restricted returns(bool){\r\n        token.transferTokensFromSpecialAddress(address(reserveAddress), _investor, _value); \r\n        return true;\r\n    } \r\n\r\n    /**\r\n     * @dev the function tranfer tokens from BountyAddress to investor\r\n     * @param _value is entered in whole tokens (1 = 1 token)\r\n     */\r\n    function transferTokensFromBountyAddress(address _investor, uint256 _value) public restricted returns(bool){\r\n        token.transferTokensFromSpecialAddress(address(bountyAddress), _investor, _value); \r\n        return true;\r\n    } \r\n    \r\n    /**\r\n    * @dev Validation of an incoming purchase. \r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _weiAmount Value in wei involved in the purchase\r\n    * Start Crowdsale 20/09/2018       - 1537401600\r\n    * Finish Crowdsale 14/12/2018      - 1544745600\r\n    * Greate pause until 01/11/2020    - 1604188800\r\n    */\r\n    function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view{\r\n        require(_beneficiary != address(0),\"Invalid address\");\r\n        require(_weiAmount != 0,\"Invalid amount\");\r\n        require((now > crowdSaleStartTime && now <= crowdSaleEndTime) || now > 1604188800,\"At this time contract don`t sell tokens, sorry\");\r\n        require(weiRaised < hardCap,\"HardCap is passed, contract don`t accept ether.\");\r\n    }\r\n\r\n    /**\r\n    * @dev internal function\r\n    * @param _beneficiary Address performing the token purchase\r\n    * @param _tokenAmount Number of tokens to be emitted\r\n    */\r\n    function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal {\r\n        token.safeTransfer(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Function transfer token to new investors\r\n     * Access restricted owner and manager\r\n     */ \r\n    function transferTokens(address _newInvestor, uint256 _tokenAmount) public restricted {\r\n        uint256 value = _tokenAmount;\r\n        require (value >= 1,\"Min _tokenAmount is 1\");\r\n        value = value.mul(1 ether);        \r\n        _deliverTokens(_newInvestor, value);\r\n    }\r\n\r\n    /**\r\n    * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n    * @param _beneficiary Address receiving the tokens\r\n    * @param _tokenAmount Number of tokens to be purchased\r\n    */\r\n    function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n        _deliverTokens(_beneficiary, _tokenAmount);\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev this function is ether converted to tokens.\r\n    * @param _weiAmount Value in wei to be converted into tokens\r\n    * @return Number of tokens that can be purchased with the specified _weiAmount\r\n    */\r\n    function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n        uint256 bonus = 0;\r\n        uint256 resultAmount = _weiAmount;\r\n        /**\r\n        * Start PreSale      20/09/2018      - 1537401600\r\n        * Start ICO          10/10/2018      - 1539129600 \r\n        * Finish ICO         14/12/2018      - 1544745600    \r\n        */\r\n        if (now < 1539129600) {\r\n            // Calculating bonus for PreSale period\r\n            if (_weiAmount >= 100 * 1 ether) {\r\n                bonus = 300;\r\n            } else {\r\n                bonus = 100;\r\n            }\r\n        } else {\r\n            // Calculating bonus for ICO period\r\n            if (_weiAmount >= 100 * 1 ether) {\r\n                bonus = 200;\r\n            } else {\r\n                /**\r\n                * ICO bonus                        UnisTimeStamp \r\n                *                                  Start date      End date\r\n                * 10.10.2018-16.10.2018 - 40%      1539129600\r\n                * 17.10.2018-23.10.2018 - 30%      1539734400\r\n                * 24.10.2018-31.10.2018 - 20%      1540339200\r\n                * 01.11.2018-16.11.2018 - 10%      1541030400      1542326400\r\n                */\r\n                if (now >= 1539129600 && now < 1539734400) {\r\n                    bonus = 40;\r\n                }\r\n                if (now >= 1539734400 && now < 1540339200) {\r\n                    bonus = 30;\r\n                }\r\n                if (now >= 1540339200 && now < 1541030400) {\r\n                    bonus = 20;\r\n                }\r\n                if (now >= 1541030400 && now < 1542326400) {\r\n                    bonus = 10;\r\n                }\r\n            }\r\n        }\r\n        if (bonus > 0) {\r\n            resultAmount += _weiAmount.mul(bonus).div(100);\r\n        }\r\n        return resultAmount.mul(rate);\r\n    }\r\n\r\n    /**\r\n    * @dev Determines how ETH is stored/forwarded on purchases.\r\n    */\r\n    function forwardFunds() public onlyOwner {\r\n        uint256 transferValue = myAddress.balance.div(8);\r\n\r\n        // Addresses where funds are collected\r\n        address wallet1 = 0xcE3685fA1D8F7552a55F044dC8695477e705dbEd;\r\n        address wallet2 = 0x1745CBBE7a986c1309006535AadA971CB1ecD7Bd;\r\n        address wallet3 = 0x56c6A074b2fA480898c1c9fc6337401594F0B2BF;\r\n        address wallet4 = 0xC053f9138593B109A8d83975506b7B29Feb53824;\r\n        address wallet5 = 0x980F6EE9DCd0Ca5aD8e24bf47D43021bBC66b282;\r\n        address wallet6 = 0x3b78a31326F8d4932295Beb0A79D7A0C50a92aE4;\r\n        address wallet7 = 0x7b09024782744693E01E04A8ceb7Bc849684A423;\r\n        address wallet8 = 0x2C057c64647911996b455b3338cBcEF5024d294f;\r\n\r\n        wallet1.transfer(transferValue);\r\n        wallet2.transfer(transferValue);\r\n        wallet3.transfer(transferValue);\r\n        wallet4.transfer(transferValue);\r\n        wallet5.transfer(transferValue);\r\n        wallet6.transfer(transferValue);\r\n        wallet7.transfer(transferValue);\r\n        wallet8.transfer(myAddress.balance);\r\n    }\r\n    \r\n    function withdrawFunds (address _to, uint256 _value) public onlyOwner {\r\n        require (now > crowdSaleEndTime, \"CrowdSale is not finished yet. Access denied.\");\r\n        require (myAddress.balance >= _value,\"Value is more than balance\");\r\n        require(_to != address(0),\"Invalid address\");\r\n        _to.transfer(_value);\r\n        emit Withdraw(msg.sender, _to, _value);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromMarketingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromTeamAddress1\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromTeamAddress2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"forwardFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromRetailersAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"marketingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamAddress1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromBountyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newInvestor\",\"type\":\"address\"},{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"setKYCpassed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferTokensFromReserveAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"retailersAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"}]","ContractName":"Crowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://b07095bbbbe1c36d5cddc9eae48d2ac85729ab90f7bd72e0c3af9d8245322a35"}]}