{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * This contract is used to protect the users of Storm4:\r\n * https://www.storm4.cloud\r\n * \r\n * That is, to ensure the public keys of users are verifiable, auditable & tamper-proof.\r\n * \r\n * Here's the general idea:\r\n * - We batch the public keys of multiple users into a merkle tree.\r\n * - We publish the merkle tree root to this contract.\r\n * - The merkle tree root for any user can only be assigned once.\r\n * \r\n * In order to verify a user:\r\n * - Use this contract to fetch the merkle tree root value for the userID.\r\n * - Then use HTTPS to fetch the corresponding merkle file from our server.\r\n *   For example, if the merkle tree root value is\r\n *   \"0xcd59b7bda6dc1dd82cb173d0cdfa408db30e9a747d4366eb5b60597899eb69c1\",\r\n *   then you could fetch the corresponding JSON file at\r\n *   https://blockchain.storm4.cloud/cd59b7bda6dc1dd82cb173d0cdfa408db30e9a747d4366eb5b60597899eb69c1.json\r\n * - The JSON file allows you to independently verify the public key information\r\n *   by calculating the merkle tree root for yourself.\r\n**/\r\ncontract PubKeyTrust {\r\n\taddress public owner;\r\n\tstring public constant HASH_TYPE = \"sha256\";\r\n\r\n\t/**\r\n\t * users[userID] => merkleTreeRoot\r\n\t * \r\n\t * A value of zero indicates that a merkleTreeRoot has not been\r\n\t * published for the userID.\r\n\t**/\r\n\tmapping(bytes20 => bytes32) private users;\r\n\t\r\n\t/**\r\n\t * merkleTreeRoots[merkleTreeRootValue] => blockNumber\r\n\t * \r\n\t * Note: merkleTreeRoots[0x0] is initialized in the constructor to store\r\n\t * the block number of when the contract was published.\r\n\t**/\r\n\tmapping(bytes32 => uint) private merkleTreeRoots;\r\n\r\n\tconstructor() public {\r\n\t\towner = msg.sender;\r\n\t\tmerkleTreeRoots[bytes32(0)] = block.number;\r\n\t}\r\n\r\n\tmodifier onlyByOwner()\r\n\t{\r\n\t\tif (msg.sender != owner)\r\n\t\t\trequire(false);\r\n\t\telse\r\n\t\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * We originally passed the userIDs as: bytes20[] userIDs\r\n\t * But it was discovered that this was inefficiently packed,\r\n\t * and ended up sending 12 bytes of zero's per userID.\r\n\t * Since gtxdatazero is set to 4 gas/bytes, this translated into\r\n\t * 48 gas wasted per user due to inefficient packing.\r\n\t**/\r\n\tfunction addMerkleTreeRoot(bytes32 merkleTreeRoot, bytes userIDsPacked) public onlyByOwner {\r\n\r\n\t\tif (merkleTreeRoot == bytes32(0)) require(false);\r\n\r\n\t\tbool addedUser = false;\r\n\r\n\t\tuint numUserIDs = userIDsPacked.length / 20;\r\n\t\tfor (uint i = 0; i < numUserIDs; i++)\r\n\t\t{\r\n\t\t\tbytes20 userID;\r\n\t\t\tassembly {\r\n\t\t\t\tuserID := mload(add(userIDsPacked, add(32, mul(20, i))))\r\n\t\t\t}\r\n\r\n\t\t\tbytes32 existingMerkleTreeRoot = users[userID];\r\n\t\t\tif (existingMerkleTreeRoot == bytes32(0))\r\n\t\t\t{\r\n\t\t\t\tusers[userID] = merkleTreeRoot;\r\n\t\t\t\taddedUser = true;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (addedUser && (merkleTreeRoots[merkleTreeRoot] == 0))\r\n\t\t{\r\n\t\t\tmerkleTreeRoots[merkleTreeRoot] = block.number;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getMerkleTreeRoot(bytes20 userID) public view returns (bytes32) {\r\n\r\n\t\treturn users[userID];\r\n\t}\r\n\r\n\tfunction getBlockNumber(bytes32 merkleTreeRoot) public view returns (uint) {\r\n\r\n\t\treturn merkleTreeRoots[merkleTreeRoot];\r\n\t}\r\n\r\n    function getUserInfo(bytes20 userID) public view returns (bytes32, uint) {\r\n        \r\n        bytes32 merkleTreeRoot = users[userID];\r\n        uint blockNumber = merkleTreeRoots[merkleTreeRoot];\r\n        \r\n        return (merkleTreeRoot, blockNumber);\r\n    }\t\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"merkleTreeRoot\",\"type\":\"bytes32\"},{\"name\":\"userIDsPacked\",\"type\":\"bytes\"}],\"name\":\"addMerkleTreeRoot\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"merkleTreeRoot\",\"type\":\"bytes32\"}],\"name\":\"getBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userID\",\"type\":\"bytes20\"}],\"name\":\"getUserInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HASH_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"userID\",\"type\":\"bytes20\"}],\"name\":\"getMerkleTreeRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"PubKeyTrust","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a3e34e5625c9f4c43ef1beaadb29e949c2cd6a051d3d675b319c08a02212796d"}]}