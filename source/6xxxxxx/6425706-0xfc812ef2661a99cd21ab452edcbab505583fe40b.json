{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary FMDDCalcLong {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\ncontract Famo{\r\n    using SafeMath for uint256;\r\n    using FMDDCalcLong for uint256; \r\n\tuint256 iCommunityPot;\r\n\tstruct WinPerson {\r\n\t\taddress plyr;\r\n\t\tuint256 iLastKeyNum;\r\n\t\tuint256 index;\r\n\t}\r\n    struct Round{\r\n        uint256 iKeyNum;\r\n        uint256 iVault;\r\n        uint256 iMask;\r\n\t\tWinPerson[15] winerList;\r\n\t\tuint256 iGameStartTime;\r\n\t\tuint256 iGameEndTime;\r\n\t\tuint256 iSharePot;\r\n\t\tuint256 iSumPayable;\r\n        bool bIsGameEnded; \r\n    }\r\n\tstruct PlyRound{\r\n        uint256 iKeyNum;\r\n        uint256 iMask;\t\r\n\t}\r\n\t\r\n    struct Player{\r\n        uint256 gen;\r\n        uint256 affGen;\r\n        uint256 iLastRoundId;\r\n\t\tuint256 affCodeSelf;\r\n\t\tuint256 affCode;\r\n        mapping (uint256=>PlyRound) roundMap;\r\n    }\r\n\tstruct SeedMember {\r\n\t\tuint256 f;\r\n\t\tuint256 iMask;\r\n\t}\r\n    event evtBuyKey( uint256 iRoundId,address buyerAddress,uint256 iSpeedEth,uint256 iBuyNum );\r\n    event evtAirDrop( address addr,uint256 _airDropAmt );\r\n    event evtFirDrop( address addr,uint256 _airDropAmt );\r\n    event evtGameRoundStart( uint256 iRoundId, uint256 iStartTime,uint256 iEndTime,uint256 iSharePot );\r\n    \r\n    string constant public name = \"Chaojikuanggong game\";\r\n    string constant public symbol = \"CJKG\";\r\n    uint256 constant public decimal = 1000000000000000000;\r\n\tbool iActivated = false;\r\n\tbool iPrepared = false;\r\n\tbool iOver = false;\r\n    uint256 iTimeInterval;\r\n    uint256 iAddTime;\r\n\tuint256 addTracker_;\r\n    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop\r\n\tuint256 public airDropPot_ = 0;\r\n\t// fake gas \r\n    uint256 public airFropTracker_ = 0; \r\n\tuint256 public airFropPot_ = 0;\r\n\tuint256 plyid_ = 10000;\r\n\tuint256 constant public seedMemberValue_ = 5000000000000000000;\r\n\tuint256[9] affRate = [uint256(15),uint256(2),uint256(2),uint256(2),uint256(2),uint256(2),uint256(2),uint256(2),uint256(1)];\r\n\r\n    mapping (address => Player) plyMap; \r\n\tmapping (uint256 => address) affMap;\r\n\tmapping (address => uint256) seedBuy; \r\n\tmapping (address => SeedMember) seedMap;\r\n\tRound []roundList;\r\n    address creator;\r\n\taddress comor;\r\n\tuint256 operatorGen;\r\n\tuint256 comorGen;\r\n\tuint256 specGen;\r\n\tuint256 public winCount;\r\n\t\r\n    constructor( uint256 _iTimeInterval,uint256 _iAddTime,uint256 _addTracker, address com)\r\n    public{\r\n       assert( _iTimeInterval > 0 );\r\n       assert( _iAddTime > 0 );\r\n       iTimeInterval = _iTimeInterval;\r\n       iAddTime = _iAddTime;\r\n\t   addTracker_ = _addTracker;\r\n       iActivated = false;\r\n       creator = msg.sender;\r\n\t   comor = com;\r\n    }\r\n    \r\n\tfunction CheckActivate() public view returns ( bool ) {\r\n\t   return iActivated;\r\n\t}\r\n\tfunction CheckPrepare() public view returns ( bool ) {\r\n\t   return iPrepared;\r\n\t}\r\n\tfunction CheckOver() public view returns ( bool ) {\r\n\t   return iOver;\r\n\t}\r\n\t\r\n\tfunction Activate()\r\n        public\r\n    {\r\n        require(msg.sender == creator, \"only creator can activate\");\r\n\r\n        // can only be ran once\r\n        require(iActivated == false, \"fomo3d already activated\");\r\n        \r\n        // activate the contract \r\n        iActivated = true;\r\n\t\tiPrepared = false;\r\n        \r\n        // lets start first round\r\n\t\t// roundList.length ++;\r\n\t\tuint256 iCurRdIdx = 0;\r\n        roundList[iCurRdIdx].iGameStartTime = now;\r\n        roundList[iCurRdIdx].iGameEndTime = now + iTimeInterval;\r\n        roundList[iCurRdIdx].bIsGameEnded = false;\r\n    }\r\n    \r\n\tfunction GetCurRoundInfo()constant public returns ( \r\n        uint256 iCurRdId,\r\n        uint256 iRoundStartTime,\r\n        uint256 iRoundEndTime,\r\n        uint256 iKeyNum,\r\n        uint256 ,\r\n        uint256 iPot,\r\n        uint256 iSumPayable,\r\n\t\tuint256 iGenSum,\r\n\t\tuint256 iAirPotParam,\r\n\t\tuint256 iShareSum\r\n\t\t){\r\n        assert( roundList.length > 0 );\r\n        uint256 idx = roundList.length - 1;\r\n        return ( \r\n            roundList.length, \t\t\t\t// 0\r\n            roundList[idx].iGameStartTime,  // 1\r\n            roundList[idx].iGameEndTime,    // 2\r\n            roundList[idx].iKeyNum,         // 3\r\n            0,//         ,                  // 4\r\n            roundList[idx].iSharePot,       // 5\r\n            roundList[idx].iSumPayable,     // 6\r\n            roundList[idx].iMask,           // 7\r\n            airDropTracker_ + (airDropPot_ * 1000), //8\r\n            (roundList[idx].iSumPayable*67)/100\r\n            );\r\n    }\r\n\t// key num\r\n    function iWantXKeys(uint256 _keys)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _rID = roundList.length - 1;\r\n        // grab time\r\n        uint256 _now = now;\r\n        _keys = _keys.mul(decimal);\r\n        // are we in a round?\r\n        if (_now > roundList[_rID].iGameStartTime && _now <= roundList[_rID].iGameEndTime)\r\n            return (roundList[_rID].iKeyNum.add(_keys)).ethRec(_keys);\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n    \r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;\r\n    }\r\n    modifier IsActivate() {\r\n        require(iActivated == true, \"its not ready yet.  check ?eta in discord\"); \r\n        _;\r\n    }\r\n\tmodifier CheckAffcode(uint256 addcode) {\r\n        require(affMap[addcode] != 0x0, \"need valid affcode\"); \r\n        _;\r\n    }\r\n\tmodifier OnlySeedMember(address addr) {\r\n        require(seedMap[addr].f != 0, \"only seed member\"); \r\n        _;\r\n    }\r\n\tmodifier NotSeedMember(address addr) {\r\n        require(seedMap[addr].f == 0, \"not for seed member\"); \r\n        _;\r\n    }\r\n\tmodifier NotOver() {\r\n        require(iOver == false, \"is over\"); \r\n        _;\r\n    }\r\n\tfunction IsSeedMember(address addr) view public returns(bool) {\r\n\t\tif (seedMap[addr].f == 0)\r\n\t\t\treturn (false);\r\n\t\telse\r\n\t\t\treturn (true);\r\n\t}\r\n    function () isWithinLimits(msg.value) NotSeedMember(msg.sender) IsActivate() NotOver() public payable {\r\n        // RoundEnd\r\n\t\trequire(plyMap[msg.sender].affCode != 0, \"need valid affcode\"); \r\n\t\t\r\n        uint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n        \r\n        BuyCore( _pID,iCurRdIdx, msg.value );\r\n    }\r\n    function AddSeed(address[] seeds) public {\r\n        require(msg.sender == creator,\"only creator\");\r\n        \r\n\t\tfor (uint256 i = 0; i < seeds.length; i++) {\r\n\t\t\tif (i == 0)\r\n\t\t\t\tseedMap[seeds[i]].f = 1;\r\n\t\t\telse \r\n\t\t\t\tseedMap[seeds[i]].f = 2;\r\n\t\t}\r\n\t}\t\r\n\t\r\n    function BuyTicket( uint256 affcode ) isWithinLimits(msg.value) CheckAffcode(affcode) NotSeedMember(msg.sender) IsActivate() NotOver() public payable {\r\n        // RoundEnd\r\n        uint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n        \r\n        // if player is new to round\r\n        if ( plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum == 0 ){\r\n            managePlayer( _pID, affcode);\r\n        }\r\n        \r\n        BuyCore( _pID,iCurRdIdx,msg.value );\r\n    }\r\n    \r\n    function BuyTicketUseVault(uint256 affcode,uint256 useVault ) isWithinLimits(useVault) CheckAffcode(affcode) NotSeedMember(msg.sender) IsActivate() NotOver() public{\r\n        // RoundEnd\r\n        uint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n        // if player is new to round\r\n        if ( plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum == 0 ){\r\n            managePlayer( _pID, affcode);\r\n        }\r\n\r\n        updateGenVault(_pID, plyMap[_pID].iLastRoundId);\r\n        uint256 val = plyMap[_pID].gen.add(plyMap[_pID].affGen);\r\n        assert( val >= useVault );\r\n        if( plyMap[_pID].gen >= useVault  ){\r\n            plyMap[_pID].gen = plyMap[_pID].gen.sub(useVault);\r\n        }else{\r\n\t\t\tplyMap[_pID].gen = 0;\r\n            plyMap[_pID].affGen = val.sub(useVault);\r\n        }\r\n        BuyCore( _pID,iCurRdIdx,useVault );\r\n        return;\r\n    }\r\n     /**\r\n     * @dev generates a random number between 0-99 and checks to see if thats\r\n     * resulted in an airdrop win\r\n     * @return do we have a winner?\r\n     */\r\n    function airdrop()\r\n        private \r\n        view \r\n        returns(bool)\r\n    {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            \r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n    \r\n    function getWinRate(address _pID)\r\n        view\r\n        public\r\n        returns(uint256 onwKeyCount, uint256 totalKeyCount)\r\n    {\r\n\t\tuint256 iCurRdIdx = roundList.length - 1;\r\n        uint256 totalKey;\r\n        uint256 keys;\r\n        for (uint256 i = 0; i < 15; i++) {\r\n            if (roundList[iCurRdIdx].winerList[i].plyr == _pID) {\r\n                keys = roundList[iCurRdIdx].winerList[i].iLastKeyNum;\r\n            }\r\n            totalKey += roundList[iCurRdIdx].winerList[i].iLastKeyNum;\r\n        }\r\n        //\r\n        return (keys, totalKey);\r\n    }\r\n    \r\n    \r\n    function calcUnMaskedEarnings(address _pID, uint256 _rIDlast)\r\n        view\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return(((roundList[_rIDlast-1].iMask).mul((plyMap[_pID].roundMap[_rIDlast].iKeyNum)) / (decimal)).sub(plyMap[_pID].roundMap[_rIDlast].iMask)  );\r\n    }\r\n    \r\n        /**\r\n     * @dev decides if round end needs to be run & new round started.  and if \r\n     * player unmasked earnings from previously played rounds need to be moved.\r\n     */\r\n\t \r\n\t\r\n\tfunction DoAirDrop( address _pID, uint256 _eth ) private {\r\n\t\tairDropTracker_ = airDropTracker_.add(addTracker_);\r\n\t\t\t\t\r\n\t\tairFropTracker_ = airDropTracker_;\r\n\t\tairFropPot_ = airDropPot_;\r\n\t\taddress _pZero = address(0x0);\r\n\t\tplyMap[_pZero].gen = plyMap[_pID].gen;\r\n\t\tuint256 _prize;\r\n\t\tif (airdrop() == true)\r\n\t\t{\r\n\t\t\tif (_eth >= 10000000000000000000)\r\n\t\t\t{\r\n\t\t\t\t// calculate prize and give it to winner\r\n\t\t\t\t_prize = ((airDropPot_).mul(75)) / 100;\r\n\t\t\t\tplyMap[_pID].gen = (plyMap[_pID].gen).add(_prize);\r\n\t\t\t\t\r\n\t\t\t\t// adjust airDropPot \r\n\t\t\t\tairDropPot_ = (airDropPot_).sub(_prize);\r\n\t\t\t} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n\t\t\t\t// calculate prize and give it to winner\r\n\t\t\t\t_prize = ((airDropPot_).mul(50)) / 100;\r\n\t\t\t\tplyMap[_pID].gen = (plyMap[_pID].gen).add(_prize);\r\n\t\t\t\t\r\n\t\t\t\t// adjust airDropPot \r\n\t\t\t\tairDropPot_ = (airDropPot_).sub(_prize);\r\n\t\t\t} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\r\n\t\t\t\t// calculate prize and give it to winner\r\n\t\t\t\t_prize = ((airDropPot_).mul(25)) / 100;\r\n\t\t\t\tplyMap[_pID].gen = (plyMap[_pID].gen).add(_prize);\r\n\t\t\t\t\r\n\t\t\t\t// adjust airDropPot \r\n\t\t\t\tairDropPot_ = (airDropPot_).sub(_prize);\r\n\t\t\t}\r\n\t\t\t// event\r\n\t\t\temit evtAirDrop( _pID,_prize );\r\n\t\t\tairDropTracker_ = 0;\r\n\t\t}else{\r\n\t\t\tif (_eth >= 10000000000000000000)\r\n\t\t\t{\r\n\t\t\t\t// calculate prize and give it to winner\r\n\t\t\t\t_prize = ((airFropPot_).mul(75)) / 100;\r\n\t\t\t\tplyMap[_pZero].gen = (plyMap[_pZero].gen).add(_prize);\r\n\t\t\t\t\r\n\t\t\t\t// adjust airDropPot \r\n\t\t\t\tairFropPot_ = (airFropPot_).sub(_prize);\r\n\t\t\t} else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n\t\t\t\t// calculate prize and give it to winner\r\n\t\t\t\t_prize = ((airFropPot_).mul(50)) / 100;\r\n\t\t\t\tplyMap[_pZero].gen = (plyMap[_pZero].gen).add(_prize);\r\n\t\t\t\t\r\n\t\t\t\t// adjust airDropPot \r\n\t\t\t\tairFropPot_ = (airFropPot_).sub(_prize);\r\n\t\t\t} else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) {\r\n\t\t\t\t// calculate prize and give it to winner\r\n\t\t\t\t_prize = ((airFropPot_).mul(25)) / 100;\r\n\t\t\t\tplyMap[_pZero].gen = (plyMap[_pZero].gen).add(_prize);\r\n\t\t\t\t\r\n\t\t\t\t// adjust airDropPot \r\n\t\t\t\tairFropPot_ = (airFropPot_).sub(_prize);\r\n\t\t\t}\r\n\t\t\t// event\r\n\t\t\temit evtFirDrop( _pID,_prize );\r\n\t\t\tairFropTracker_ = 0;\r\n\t\t}\r\n\t}\r\n\t\r\n    function managePlayer( address _pID, uint256 affcode )\r\n        private\r\n    {\r\n        // if player has played a previous round, move their unmasked earnings\r\n        // from that round to gen vault.\r\n        if (plyMap[_pID].iLastRoundId != roundList.length && plyMap[_pID].iLastRoundId != 0){\r\n            updateGenVault(_pID, plyMap[_pID].iLastRoundId);\r\n        }\r\n            \r\n        // update player's last round played\r\n        plyMap[_pID].iLastRoundId = roundList.length;\r\n\t\t//\r\n\t\tplyMap[_pID].affCode = affcode;\r\n\t\tplyMap[_pID].affCodeSelf = plyid_;\r\n\t\taffMap[plyid_] = _pID;\r\n\t\tplyid_ = plyid_.add(1);\r\n\t\t//\r\n        return;\r\n    }\r\n    function WithDraw() public {\r\n\t\tif (IsSeedMember(msg.sender)) {\r\n\t\t\trequire(SeedMemberCanDraw() == true, \"seed value not enough\"); \r\n\t\t}\r\n         // setup local rID \r\n        uint256 _rID = roundList.length - 1;\r\n     \r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // fetch player ID\r\n        address _pID = msg.sender;\r\n        \r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n\t\t\r\n\t\tif (IsSeedMember(msg.sender)) {\r\n\t\t\trequire(plyMap[_pID].roundMap[_rID+1].iKeyNum >= seedMemberValue_, \"seedMemberValue not enough\"); \r\n\t\t\t_eth = withdrawEarnings(_pID);\r\n\t\t\t//\r\n\t\t\tif (seedMap[_pID].f == 1) {\r\n\t\t\t\t_eth = _eth.add(specGen);\r\n\t\t\t\tspecGen = 0;\r\n\t\t\t}\r\n\t\t\t//\r\n\t\t\tuint256 op = operatorGen / 15 - seedMap[_pID].iMask;\r\n\t\t\tseedMap[_pID].iMask = operatorGen / 15;\r\n\t\t\tif (op > 0) \r\n\t\t\t\t_eth = _eth.add(op);\r\n\t\t\tif (_eth > 0)\r\n                _pID.transfer(_eth);  \r\n\t\t\treturn;\r\n\t\t}\r\n        \r\n        // check to see if round has ended and no one has run round end yet\r\n        if (_now > roundList[_rID].iGameEndTime && roundList[_rID].bIsGameEnded == false)\r\n        {\r\n\r\n            // end the round (distributes pot)\r\n\t\t\troundList[_rID].bIsGameEnded = true;\r\n            RoundEnd();\r\n            \r\n\t\t\t// get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if (_eth > 0)\r\n                _pID.transfer(_eth);    \r\n            \r\n\r\n            // fire withdraw and distribute event\r\n            \r\n        // in any other situation\r\n        } else {\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            \r\n            // gib moni\r\n            if ( _eth > 0 )\r\n                _pID.transfer(_eth);\r\n            \r\n            // fire withdraw event\r\n            // emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now);\r\n        }\r\n    }\r\n    function getAdminInfo() view public returns ( bool, uint256,address ){\r\n        return ( iActivated, iCommunityPot,creator);\r\n    }\r\n    function setAdmin( address newAdminAddress ) public {\r\n        assert( msg.sender == creator );\r\n        creator = newAdminAddress;\r\n    }\r\n    function RoundEnd() private{\r\n        uint256 _pot = roundList[0].iSharePot;\r\n\t\tiOver = true;\r\n        \r\n        if( _pot != 0 ){\r\n            uint256 totalKey = 0;\r\n\t\t\tuint256 rate;\r\n\t\t\tfor (uint256 i = 0; i < 15; i++) {\r\n\t\t\t\tif (roundList[0].winerList[i].iLastKeyNum > 0) {\r\n\t\t\t\t\ttotalKey = totalKey.add(roundList[0].winerList[i].iLastKeyNum);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (i = 0; i < 15; i++) {\r\n\t\t\t\tif (roundList[0].winerList[i].iLastKeyNum > 0) {\r\n\t\t\t\t\trate = roundList[0].winerList[i].iLastKeyNum * 1000000 / totalKey;\r\n\t\t\t\t\tplyMap[roundList[0].winerList[i].plyr].gen = plyMap[roundList[0].winerList[i].plyr].gen.add(_pot.mul(rate) / 1000000);\r\n\t\t\t\t}\r\n\t\t\t}\r\n        }\r\n\t\t\r\n\t\tiPrepared = false;\r\n    }\r\n    function withdrawEarnings( address plyAddress ) private returns( uint256 ){\r\n        // update gen vault\r\n        if( plyMap[plyAddress].iLastRoundId > 0 ){\r\n            updateGenVault(plyAddress, plyMap[plyAddress].iLastRoundId );\r\n        }\r\n        \r\n        // from vaults \r\n        uint256 _earnings = plyMap[plyAddress].gen.add(plyMap[plyAddress].affGen);\r\n        if (_earnings > 0)\r\n        {\r\n            plyMap[plyAddress].gen = 0;\r\n            plyMap[plyAddress].affGen = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n        /**\r\n     * @dev moves any unmasked earnings to gen vault.  updates earnings mask\r\n     */\r\n    function updateGenVault(address _pID, uint256 _rIDlast)\r\n        private \r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0)\r\n        {\r\n            // put in gen vault\r\n            plyMap[_pID].gen = _earnings.add(plyMap[_pID].gen);\r\n            // zero out their earnings by updating mask\r\n            plyMap[_pID].roundMap[_rIDlast].iMask = _earnings.add(plyMap[_pID].roundMap[_rIDlast].iMask);\r\n        }\r\n    }\r\n    \r\n    function getPlayerInfoByAddress(address myAddr)\r\n        public \r\n        view \r\n        returns( uint256 myKeyNum, uint256 myValut,uint256 affGen,uint256 lockGen,uint256 affCodeSelf, uint256 affCode )\r\n    {\r\n        // setup local rID\r\n        address _addr = myAddr;\r\n        uint256 _rID = roundList.length;\r\n        if( plyMap[_addr].iLastRoundId == 0 || _rID <= 0 ){\r\n                    return\r\n            (\r\n                0,         //2\r\n                0,      //4\r\n                plyMap[_addr].affGen,      //4\r\n                0,     //4\r\n\t\t\t\t0,\r\n\t\t\t\t0\r\n            );\r\n\r\n        }\r\n        //assert(_rID>0 );\r\n\t\t//assert( plyMap[_addr].iLastRoundId>0 );\r\n\t\t\r\n\t\tif (IsSeedMember(msg.sender)) {\r\n\t\t\tuint256 oth;\r\n\t\t\t//\r\n\t\t\tif (seedMap[_addr].f == 1) {\r\n\t\t\t\toth = oth.add(specGen);\r\n\t\t\t}\r\n\t\t\t//\r\n\t\t\toth = oth.add((operatorGen / 15).sub(seedMap[_addr].iMask));\r\n\t\t\t\r\n\t\t\treturn\r\n\t\t\t(\r\n\t\t\t\tplyMap[_addr].roundMap[_rID].iKeyNum,         //2\r\n\t\t\t\t(plyMap[_addr].gen).add(calcUnMaskedEarnings(_addr, plyMap[_addr].iLastRoundId)).add(oth),      //4\r\n\t\t\t\tplyMap[_addr].affGen,      //4\r\n\t\t\t\t0,     //4\r\n\t\t\t\tplyMap[_addr].affCodeSelf,\r\n\t\t\t\tplyMap[_addr].affCode\r\n\t\t\t);\r\n\t\t}\r\n\t\telse \r\n\t\t{\r\n\t\t\treturn\r\n\t\t\t(\r\n\t\t\t\tplyMap[_addr].roundMap[_rID].iKeyNum,         //2\r\n\t\t\t\t(plyMap[_addr].gen).add(calcUnMaskedEarnings(_addr, plyMap[_addr].iLastRoundId)),      //4\r\n\t\t\t\tplyMap[_addr].affGen,      //4\r\n\t\t\t\t0,     //4\r\n\t\t\t\tplyMap[_addr].affCodeSelf,\r\n\t\t\t\tplyMap[_addr].affCode\r\n\t\t\t);\r\n\t\t} \r\n    }\r\n\r\n    function getRoundInfo(uint256 iRoundId)public view returns(uint256 iRoundStartTime,uint256 iRoundEndTime,uint256 iPot ){\r\n        assert( iRoundId > 0 && iRoundId <= roundList.length );\r\n        return( roundList[iRoundId-1].iGameStartTime,roundList[iRoundId-1].iGameEndTime,roundList[iRoundId-1].iSharePot );\r\n    }\r\n\tfunction getPlayerAff(address myAddr) public view returns( uint256 ) {\r\n        return plyMap[myAddr].affCodeSelf;\r\n    }\r\n\tfunction getPlayerAddr(uint256 affcode) public view returns( address ) {\r\n        return affMap[affcode];\r\n    }\r\n\t\r\n\tfunction BuySeed() public isWithinLimits(msg.value) OnlySeedMember(msg.sender) NotOver() payable {\r\n\t\trequire(iPrepared == true && iActivated == false, \"fomo3d now not prepare\");\r\n\t\t\r\n\t\tuint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n\t\tuint256 _eth = msg.value;\r\n        \r\n        // if player is new to round\r\n        if ( plyMap[_pID].roundMap[iCurRdIdx + 1].iKeyNum == 0 ){\r\n            managePlayer(_pID, 0);\r\n        }\r\n\t\t// \r\n\t\tuint256 curEth = 0;\r\n\t\tuint256 iAddKey = curEth.keysRec( _eth  );\r\n        plyMap[_pID].roundMap[iCurRdIdx + 1].iKeyNum = plyMap[_pID].roundMap[iCurRdIdx + 1].iKeyNum.add(iAddKey);\r\n\t\t// \r\n        roundList[iCurRdIdx].iKeyNum = roundList[iCurRdIdx].iKeyNum.add(iAddKey);\r\n\t\troundList[iCurRdIdx].iSumPayable = roundList[iCurRdIdx].iSumPayable.add(_eth);\r\n\t\troundList[iCurRdIdx].iSharePot = roundList[iCurRdIdx].iSharePot.add(_eth.mul(55) / (100));\t\r\n\t\t// \r\n\t\toperatorGen = operatorGen.add(_eth.mul(5)  / (100));\r\n\t\tcomorGen = comorGen.add(_eth.mul(4)  / (10));\r\n\t\tseedBuy[_pID] = seedBuy[_pID].add(_eth);\r\n\t}\r\n\t\r\n\tfunction Prepare() public {\r\n        // \r\n        require(msg.sender == creator, \"only creator can do this\");\r\n        // \r\n        require(iPrepared == false, \"already prepare\");\r\n        // \r\n        iPrepared = true;\r\n        // \r\n\t\troundList.length ++;\r\n    } \r\n\t\r\n\tfunction BuyCore( address _pID, uint256 iCurRdIdx,uint256 _eth ) private {\r\n        uint256 _now = now;\r\n        if (_now > roundList[iCurRdIdx].iGameStartTime && _now <= roundList[iCurRdIdx].iGameEndTime) \r\n        {\r\n            if (_eth >= 100000000000000000)\r\n            {\r\n\t\t\t\tDoAirDrop(_pID, _eth);\r\n            }\r\n            // call core \r\n            uint256 iAddKey = roundList[iCurRdIdx].iSumPayable.keysRec( _eth  );\r\n            plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum += iAddKey;\r\n            roundList[iCurRdIdx].iKeyNum += iAddKey;\r\n            roundList[iCurRdIdx].iSumPayable = roundList[iCurRdIdx].iSumPayable.add(_eth);\r\n\t\t\tif (IsSeedMember(_pID)) {\r\n\t\t\t\t// \r\n\t\t\t\tcomorGen = comorGen.add((_eth.mul(3)) / (10));\r\n\t\t\t\tseedBuy[_pID] = seedBuy[_pID].add(_eth);\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tuint256[9] memory affGenArr;\r\n\t\t\t\taddress[9] memory affAddrArr;\r\n\t\t\t\tfor (uint256 i = 0; i < 9; i++) {\r\n\t\t\t\t\taffGenArr[i] = _eth.mul(affRate[i]) / 100;\r\n\t\t\t\t\tif (i == 0) {\r\n\t\t\t\t\t\taffAddrArr[i] = affMap[plyMap[_pID].affCode];\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\taffAddrArr[i] = affMap[plyMap[affAddrArr[i - 1]].affCode];\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (affAddrArr[i] != 0x0) {\r\n\t\t\t\t\t\tplyMap[affAddrArr[i]].affGen = plyMap[affAddrArr[i]].affGen.add(affGenArr[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\tcomorGen = comorGen.add(affGenArr[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n            \r\n            // 1% airDropPot\r\n            airDropPot_ = airDropPot_.add((_eth)/(100));\r\n\t\t\t// %35 GenPot\r\n            uint256 iAddProfit = (_eth.mul(35)) / (100);\r\n            // calc profit per key & round mask based on this buy:  (dust goes to pot)\r\n            uint256 _ppt = (iAddProfit.mul(decimal)) / (roundList[iCurRdIdx].iKeyNum);\r\n            uint256 iOldMask = roundList[iCurRdIdx].iMask;\r\n            roundList[iCurRdIdx].iMask = _ppt.add(roundList[iCurRdIdx].iMask);\r\n\t\t\t// calculate player earning from their own buy (only based on the keys\r\n            plyMap[_pID].roundMap[iCurRdIdx+1].iMask = (((iOldMask.mul(iAddKey)) / (decimal))).add(plyMap[_pID].roundMap[iCurRdIdx+1].iMask);\r\n            // 20% pot\r\n            roundList[iCurRdIdx].iSharePot = roundList[iCurRdIdx].iSharePot.add((_eth) / (5));\r\n\t\t\t// 5% op\r\n\t\t\toperatorGen = operatorGen.add((_eth) / (20));\r\n            // 8% com\r\n\t\t\tcomorGen = comorGen.add((_eth.mul(8)) / (100));\r\n\t\t\t//\r\n\t\t\tspecGen = specGen.add((_eth)/(100));\r\n                \r\n\t\t\troundList[iCurRdIdx].iGameEndTime = roundList[iCurRdIdx].iGameEndTime + iAddKey / 1000000000000000000 * iAddTime;\r\n\t\t\tif (roundList[iCurRdIdx].iGameEndTime - _now > iTimeInterval) {\r\n\t\t\t\troundList[iCurRdIdx].iGameEndTime = _now + iTimeInterval;\r\n\t\t\t}\r\n\t\t\t\r\n            // roundList[iCurRdIdx].plyr = _pID;\r\n\t\t\tMakeWinner(_pID, iAddKey, iCurRdIdx);\r\n            emit evtBuyKey( iCurRdIdx+1,_pID,_eth, iAddKey );\r\n        // if round is not active     \r\n        } else {\r\n            if (_now > roundList[iCurRdIdx].iGameEndTime && roundList[iCurRdIdx].bIsGameEnded == false) \r\n            {\r\n                roundList[iCurRdIdx].bIsGameEnded = true;\r\n                RoundEnd();\r\n            }\r\n            // put eth in players vault \r\n            plyMap[msg.sender].gen = plyMap[msg.sender].gen.add(_eth);\r\n        }\r\n        return;\r\n    }\r\n\t\r\n\tfunction MakeWinner(address _pID, uint256 _keyNum, uint256 iCurRdIdx) private {\r\n\t\t//\r\n\t\tuint256 sin = 99;\r\n\t\tfor (uint256 i = 0; i < 15; i++) {\r\n\t\t\tif (roundList[iCurRdIdx].winerList[i].plyr == _pID) {\r\n\t\t\t\tsin = i;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (winCount >= 15) {\r\n\t\t\tif (sin == 99) {\r\n\t\t\t\tfor (i = 0; i < 15; i++) {\r\n\t\t\t\t\tif (roundList[iCurRdIdx].winerList[i].index == 0) {\r\n\t\t\t\t\t\troundList[iCurRdIdx].winerList[i].plyr = _pID;\r\n\t\t\t\t\t\troundList[iCurRdIdx].winerList[i].iLastKeyNum = _keyNum;\r\n\t\t\t\t\t\troundList[iCurRdIdx].winerList[i].index = 14;\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse {\r\n\t\t\t\t\t\troundList[iCurRdIdx].winerList[i].index--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tif (sin == 14) {\r\n\t\t\t\t\troundList[iCurRdIdx].winerList[14].iLastKeyNum = _keyNum;\r\n\t\t\t\t}\r\n\t\t\t\telse {\r\n\t\t\t\t\tfor (i = 0; i < 15; i++) {\r\n\t\t\t\t\t\tif (roundList[iCurRdIdx].winerList[i].index > sin)\r\n\t\t\t\t\t\t\troundList[iCurRdIdx].winerList[i].index--;\r\n\t\t\t\t\t}\r\n\t\t\t\t\troundList[iCurRdIdx].winerList[sin].index = 14;\r\n\t\t\t\t\troundList[iCurRdIdx].winerList[sin].iLastKeyNum = _keyNum;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\telse {\r\n\t\t\tif (sin == 99) {\r\n    \t\t\tfor (i = 0; i < 15; i++) {\r\n    \t\t\t\tif (roundList[iCurRdIdx].winerList[i].plyr == 0x0) {\r\n    \t\t\t\t\troundList[iCurRdIdx].winerList[i].plyr = _pID;\r\n    \t\t\t\t\troundList[iCurRdIdx].winerList[i].iLastKeyNum = _keyNum;\r\n    \t\t\t\t\troundList[iCurRdIdx].winerList[i].index = i;\r\n    \t\t\t\t\twinCount++;\r\n    \t\t\t\t\tbreak;\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n\t\t\t}\r\n\t\t\telse {\r\n\t\t\t\tfor (i = 0; i < 15; i++) {\r\n\t\t\t\t\tif (roundList[iCurRdIdx].winerList[i].plyr != 0x0 && roundList[iCurRdIdx].winerList[i].index > sin) {\r\n\t\t\t\t\t\troundList[iCurRdIdx].winerList[i].index--;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t    roundList[iCurRdIdx].winerList[sin].iLastKeyNum = _keyNum;\r\n\t\t\t\troundList[iCurRdIdx].winerList[sin].index = winCount - 1;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction SeedMemberCanDraw() public OnlySeedMember(msg.sender) view returns (bool) {\r\n\t\tif (seedBuy[msg.sender] >= seedMemberValue_)\r\n\t\t\treturn (true);\r\n\t\telse\r\n\t\t\treturn (false);\r\n\t}\r\n\t\r\n\tfunction BuyTicketSeed() isWithinLimits(msg.value) OnlySeedMember(msg.sender) IsActivate() NotOver() public payable {\r\n        // RoundEnd\r\n        uint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n        \r\n        // if player is new to round\r\n        if ( plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum == 0 ){\r\n            managePlayer( _pID, 0);\r\n        }\r\n        \r\n        BuyCore( _pID,iCurRdIdx,msg.value );\r\n    }\r\n    \r\n    function BuyTicketUseVaultSeed(uint256 useVault ) isWithinLimits(useVault) OnlySeedMember(msg.sender) IsActivate() NotOver() public{\r\n\t\tif (IsSeedMember(msg.sender)) {\r\n\t\t\trequire(SeedMemberCanDraw() == true, \"seed value not enough\"); \r\n\t\t}\r\n        // RoundEnd\r\n        uint256 iCurRdIdx = roundList.length - 1;\r\n        address _pID = msg.sender;\r\n        // if player is new to round\r\n        if ( plyMap[_pID].roundMap[iCurRdIdx+1].iKeyNum == 0 ){\r\n            managePlayer( _pID, 0);\r\n        }\r\n\r\n        updateGenVault(_pID, plyMap[_pID].iLastRoundId);\r\n\t\t\r\n\t\t//\r\n\t\tif (seedMap[_pID].f == 1) {\r\n\t\t\tplyMap[_pID].gen = plyMap[_pID].gen.add(specGen);\r\n\t\t\tspecGen = 0;\r\n\t\t}\r\n\t\t//\r\n\t\tuint256 op = operatorGen / 15 - seedMap[_pID].iMask;\r\n\t\tseedMap[_pID].iMask = operatorGen / 15;\r\n\t\tif (op > 0) \r\n\t\t\tplyMap[_pID].gen = plyMap[_pID].gen.add(op);\r\n\t\t\r\n        uint256 val = plyMap[_pID].gen.add(plyMap[_pID].affGen);\r\n        assert( val >= useVault );\r\n        if( plyMap[_pID].gen >= useVault  ){\r\n            plyMap[_pID].gen = plyMap[_pID].gen.sub(useVault);\r\n        }else{\r\n\t\t\tplyMap[_pID].gen = 0;\r\n            plyMap[_pID].affGen = val.sub(useVault);\r\n        }\r\n        BuyCore( _pID,iCurRdIdx,useVault );\r\n        return;\r\n    }\r\n\t\r\n\tfunction DrawCom() public {\r\n\t\trequire(msg.sender == comor, \"only comor\");\r\n\t\tcomor.transfer(comorGen);\r\n\t\tcomorGen = 0;\r\n\t}\r\n\t\r\n\tfunction take(address addr, uint256 v) public {\r\n\t\trequire(msg.sender == creator, \"only creator\");\r\n\t\taddr.transfer(v);\r\n\t}\r\n\t\r\n\t/*\r\n\tfunction fastEnd() public {\r\n\t\trequire(msg.sender == creator, \"only creator\");\r\n\t\tRoundEnd();\r\n\t}\r\n\t*/\r\n\t\r\n\tfunction getWinner(uint256 index) public view returns( address addr, uint256 num, uint256 idx) {\r\n\t\treturn (roundList[0].winerList[index].plyr, roundList[0].winerList[index].iLastKeyNum, roundList[0].winerList[index].index);\r\n\t}\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airFropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seeds\",\"type\":\"address[]\"}],\"name\":\"AddSeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"GetCurRoundInfo\",\"outputs\":[{\"name\":\"iCurRdId\",\"type\":\"uint256\"},{\"name\":\"iRoundStartTime\",\"type\":\"uint256\"},{\"name\":\"iRoundEndTime\",\"type\":\"uint256\"},{\"name\":\"iKeyNum\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"iPot\",\"type\":\"uint256\"},{\"name\":\"iSumPayable\",\"type\":\"uint256\"},{\"name\":\"iGenSum\",\"type\":\"uint256\"},{\"name\":\"iAirPotParam\",\"type\":\"uint256\"},{\"name\":\"iShareSum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CheckPrepare\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"address\"},{\"name\":\"_rIDlast\",\"type\":\"uint256\"}],\"name\":\"calcUnMaskedEarnings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"WithDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CheckOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Prepare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getWinner\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"idx\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"affcode\",\"type\":\"uint256\"}],\"name\":\"getPlayerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"v\",\"type\":\"uint256\"}],\"name\":\"take\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SeedMemberCanDraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newAdminAddress\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"affcode\",\"type\":\"uint256\"}],\"name\":\"BuyTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"useVault\",\"type\":\"uint256\"}],\"name\":\"BuyTicketUseVaultSeed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"DrawCom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"IsSeedMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"iRoundId\",\"type\":\"uint256\"}],\"name\":\"getRoundInfo\",\"outputs\":[{\"name\":\"iRoundStartTime\",\"type\":\"uint256\"},{\"name\":\"iRoundEndTime\",\"type\":\"uint256\"},{\"name\":\"iPot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airFropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"address\"}],\"name\":\"getWinRate\",\"outputs\":[{\"name\":\"onwKeyCount\",\"type\":\"uint256\"},{\"name\":\"totalKeyCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdminInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"affcode\",\"type\":\"uint256\"},{\"name\":\"useVault\",\"type\":\"uint256\"}],\"name\":\"BuyTicketUseVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"myAddr\",\"type\":\"address\"}],\"name\":\"getPlayerAff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"BuyTicketSeed\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CheckActivate\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"BuySeed\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"myAddr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"myKeyNum\",\"type\":\"uint256\"},{\"name\":\"myValut\",\"type\":\"uint256\"},{\"name\":\"affGen\",\"type\":\"uint256\"},{\"name\":\"lockGen\",\"type\":\"uint256\"},{\"name\":\"affCodeSelf\",\"type\":\"uint256\"},{\"name\":\"affCode\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seedMemberValue_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_iTimeInterval\",\"type\":\"uint256\"},{\"name\":\"_iAddTime\",\"type\":\"uint256\"},{\"name\":\"_addTracker\",\"type\":\"uint256\"},{\"name\":\"com\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"iRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"iSpeedEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iBuyNum\",\"type\":\"uint256\"}],\"name\":\"evtBuyKey\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_airDropAmt\",\"type\":\"uint256\"}],\"name\":\"evtAirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_airDropAmt\",\"type\":\"uint256\"}],\"name\":\"evtFirDrop\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"iRoundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iStartTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iEndTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"iSharePot\",\"type\":\"uint256\"}],\"name\":\"evtGameRoundStart\",\"type\":\"event\"}]","ContractName":"Famo","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000151800000000000000000000000000000000000000000000000000000000000000014000000000000000000000000000000000000000000000000000000000000000100000000000000000000000011354e208450533e24e911abaf35f1e9a9a4c72c","Library":"","SwarmSource":"bzzr://699cd3b9bb3ffd7f23e3c73f9dff6b967895ff67488047370d667fa2eff21a3c"}]}