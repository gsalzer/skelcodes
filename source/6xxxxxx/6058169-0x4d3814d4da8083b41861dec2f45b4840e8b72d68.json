{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n    /**\r\n    * Returns whether the target address is a contract\r\n    * @dev This function will return false if invoked during the constructor of a contract,\r\n    *  as the code is not actually created until after the constructor finishes.\r\n    * @param addr address to check\r\n    * @return whether the target address is a contract\r\n    */\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n/* Controls state and access rights for contract functions\r\n * @title Operational Control\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n * Inspired and adapted from contract created by OpenZeppelin\r\n * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\r\n */\r\ncontract OperationalControl {\r\n    // Facilitates access & control for the game.\r\n    // Roles:\r\n    //  -The Managers (Primary/Secondary): Has universal control of all elements (No ability to withdraw)\r\n    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\r\n    //  -otherManagers: Contracts that need access to functions for gameplay\r\n\r\n    /// @dev Emited when contract is upgraded\r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public managerPrimary;\r\n    address public managerSecondary;\r\n    address public bankManager;\r\n\r\n    // Contracts that require access for gameplay\r\n    mapping(address => uint8) public otherManagers;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    // @dev Keeps track whether the contract erroredOut. When that is true, most actions are blocked & refund can be claimed\r\n    bool public error = false;\r\n\r\n    /// @dev Operation modifiers for limiting access\r\n    modifier onlyManager() {\r\n        require(msg.sender == managerPrimary || msg.sender == managerSecondary);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBanker() {\r\n        require(msg.sender == bankManager);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOtherManagers() {\r\n        require(otherManagers[msg.sender] == 1);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier anyOperator() {\r\n        require(\r\n            msg.sender == managerPrimary ||\r\n            msg.sender == managerSecondary ||\r\n            msg.sender == bankManager ||\r\n            otherManagers[msg.sender] == 1\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Other Manager. (State = 1 is active, 0 is disabled)\r\n    function setOtherManager(address _newOp, uint8 _state) external onlyManager {\r\n        require(_newOp != address(0));\r\n\r\n        otherManagers[_newOp] = _state;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Primary Manager.\r\n    function setPrimaryManager(address _newGM) external onlyManager {\r\n        require(_newGM != address(0));\r\n\r\n        managerPrimary = _newGM;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Secondary Manager.\r\n    function setSecondaryManager(address _newGM) external onlyManager {\r\n        require(_newGM != address(0));\r\n\r\n        managerSecondary = _newGM;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Banker.\r\n    function setBanker(address _newBK) external onlyManager {\r\n        require(_newBK != address(0));\r\n\r\n        bankManager = _newBK;\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract has Error\r\n    modifier whenError {\r\n        require(error);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any Operator role to pause the contract.\r\n    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)\r\n    function pause() external onlyManager whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\r\n    /// @notice This is public rather than external so it can be called by derived contracts. \r\n    function unpause() public onlyManager whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\r\n    /// @notice This is public rather than external so it can be called by derived contracts. \r\n    function hasError() public onlyManager whenPaused {\r\n        error = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\r\n    /// @notice This is public rather than external so it can be called by derived contracts. \r\n    function noError() public onlyManager whenPaused {\r\n        error = false;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic interface\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Basic {\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _tokenId\r\n    );\r\n    event Approval(\r\n        address indexed _owner,\r\n        address indexed _approved,\r\n        uint256 _tokenId\r\n    );\r\n    event ApprovalForAll(\r\n        address indexed _owner,\r\n        address indexed _operator,\r\n        bool _approved\r\n    );\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint256 _tokenId)\r\n        public view returns (address _operator);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        public view returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (uint256 _tokenId);\r\n\r\n    function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n    function name() public view returns (string _name);\r\n    function symbol() public view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\n/**\r\n * @title ERC721 Non-Fungible Token Standard basic implementation\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721BasicToken is ERC721Basic {\r\n    using SafeMath for uint256;\r\n    using AddressUtils for address;\r\n\r\n    // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    // Mapping from token ID to owner\r\n    mapping (uint256 => address) internal tokenOwner;\r\n\r\n    // Mapping from token ID to approved address\r\n    mapping (uint256 => address) internal tokenApprovals;\r\n\r\n    // Mapping from owner to number of owned token\r\n    mapping (address => uint256) internal ownedTokensCount;\r\n\r\n    // Mapping from owner to operator approvals\r\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\r\n\r\n    /**\r\n    * @dev Guarantees msg.sender is owner of the given token\r\n    * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender\r\n    */\r\n    modifier onlyOwnerOf(uint256 _tokenId) {\r\n        require(ownerOf(_tokenId) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n    * @param _tokenId uint256 ID of the token to validate\r\n    */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        require(isApprovedOrOwner(msg.sender, _tokenId));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address\r\n    * @param _owner address to query the balance of\r\n    * @return uint256 representing the amount owned by the passed address\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownedTokensCount[_owner];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the owner of the specified token ID\r\n    * @param _tokenId uint256 ID of the token to query the owner of\r\n    * @return owner address currently marked as the owner of the given token ID\r\n    */\r\n    function ownerOf(uint256 _tokenId) public view returns (address) {\r\n        address owner = tokenOwner[_tokenId];\r\n        require(owner != address(0));\r\n        return owner;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns whether the specified token exists\r\n    * @param _tokenId uint256 ID of the token to query the existence of\r\n    * @return whether the token exists\r\n    */\r\n    function exists(uint256 _tokenId) public view returns (bool) {\r\n        address owner = tokenOwner[_tokenId];\r\n        return owner != address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Approves another address to transfer the given token ID\r\n    * @dev The zero address indicates there is no approved address.\r\n    * @dev There can only be one approved address per token at a given time.\r\n    * @dev Can only be called by the token owner or an approved operator.\r\n    * @param _to address to be approved for the given token ID\r\n    * @param _tokenId uint256 ID of the token to be approved\r\n    */\r\n    function approve(address _to, uint256 _tokenId) public {\r\n        address owner = ownerOf(_tokenId);\r\n        require(_to != owner);\r\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n\r\n        if (getApproved(_tokenId) != address(0) || _to != address(0)) {\r\n            tokenApprovals[_tokenId] = _to;\r\n            emit Approval(owner, _to, _tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the approved address for a token ID, or zero if no address set\r\n    * @param _tokenId uint256 ID of the token to query the approval of\r\n    * @return address currently approved for the given token ID\r\n    */\r\n    function getApproved(uint256 _tokenId) public view returns (address) {\r\n        return tokenApprovals[_tokenId];\r\n    }\r\n\r\n    /**\r\n    * @dev Sets or unsets the approval of a given operator\r\n    * @dev An operator is allowed to transfer all tokens of the sender on their behalf\r\n    * @param _to operator address to set the approval\r\n    * @param _approved representing the status of the approval to be set\r\n    */\r\n    function setApprovalForAll(address _to, bool _approved) public {\r\n        require(_to != msg.sender);\r\n        operatorApprovals[msg.sender][_to] = _approved;\r\n        emit ApprovalForAll(msg.sender, _to, _approved);\r\n    }\r\n\r\n    /**\r\n    * @dev Tells whether an operator is approved by a given owner\r\n    * @param _owner owner address which you want to query the approval of\r\n    * @param _operator operator address which you want to query the approval of\r\n    * @return bool whether the given operator is approved by the given owner\r\n    */\r\n    function isApprovedForAll(\r\n        address _owner,\r\n        address _operator\r\n    )\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return operatorApprovals[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers the ownership of a given token ID to another address\r\n    * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n    *  which is called upon a safe transfer, and return the magic value\r\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n    *  the transfer is reverted.\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        // solium-disable-next-line arg-overflow\r\n        safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n    * @dev Safely transfers the ownership of a given token ID to another address\r\n    * @dev If the target address is a contract, it must implement `onERC721Received`,\r\n    *  which is called upon a safe transfer, and return the magic value\r\n    *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise,\r\n    *  the transfer is reverted.\r\n    * @dev Requires the msg sender to be the owner, approved, or operator\r\n    * @param _from current owner of the token\r\n    * @param _to address to receive the ownership of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes data to send along with a safe transfer check\r\n    */\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        transferFrom(_from, _to, _tokenId);\r\n        // solium-disable-next-line arg-overflow\r\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\r\n    }\r\n\r\n    /**\r\n    * @dev Returns whether the given spender can transfer a given token ID\r\n    * @param _spender address of the spender to query\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @return bool whether the msg.sender is approved for the given token ID,\r\n    *  is an operator of the owner, or is the owner of the token\r\n    */\r\n    function isApprovedOrOwner(\r\n        address _spender,\r\n        uint256 _tokenId\r\n    )\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        address owner = ownerOf(_tokenId);\r\n        // Disable solium check because of\r\n        // https://github.com/duaraghav8/Solium/issues/175\r\n        // solium-disable-next-line operator-whitespace\r\n        return (\r\n        _spender == owner ||\r\n        getApproved(_tokenId) == _spender ||\r\n        isApprovedForAll(owner, _spender)\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to mint a new token\r\n    * @dev Reverts if the given token ID already exists\r\n    * @param _to The address that will own the minted token\r\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n    */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        addTokenTo(_to, _tokenId);\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * @dev Reverts if the token does not exist\r\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n    */\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        clearApproval(_owner, _tokenId);\r\n        removeTokenFrom(_owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to clear current approval of a given token ID\r\n    * @dev Reverts if the given address is not indeed the owner of the token\r\n    * @param _owner owner of the token\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    */\r\n    function clearApproval(address _owner, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _owner);\r\n        if (tokenApprovals[_tokenId] != address(0)) {\r\n            tokenApprovals[_tokenId] = address(0);\r\n            emit Approval(_owner, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to add a token ID to the list of a given address\r\n    * @param _to address representing the new owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        require(tokenOwner[_tokenId] == address(0));\r\n        tokenOwner[_tokenId] = _to;\r\n        ownedTokensCount[_to] = ownedTokensCount[_to].add(1);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to remove a token ID from the list of a given address\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n    */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        require(ownerOf(_tokenId) == _from);\r\n        ownedTokensCount[_from] = ownedTokensCount[_from].sub(1);\r\n        tokenOwner[_tokenId] = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to invoke `onERC721Received` on a target address\r\n    * @dev The call is not executed if the target address is not a contract\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _to target address that will receive the tokens\r\n    * @param _tokenId uint256 ID of the token to be transferred\r\n    * @param _data bytes optional data to send along with the call\r\n    * @return whether the call correctly returned the expected magic value\r\n    */\r\n    function checkAndCallSafeTransfer(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        internal\r\n        returns (bool)\r\n    {\r\n        if (!_to.isContract()) {\r\n            return true;\r\n        }\r\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\r\n        _from, _tokenId, _data);\r\n        return (retval == ERC721_RECEIVED);\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n    /**\r\n    * @dev Magic value to be returned upon successful reception of an NFT\r\n    *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n    *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    */\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    /**\r\n    * @notice Handle the receipt of an NFT\r\n    * @dev The ERC721 smart contract calls this function on the recipient\r\n    *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n    *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    *  than the magic value MUST result in the transaction being reverted.\r\n    *  Note: the contract address is always the message sender.\r\n    * @param _from The sending address\r\n    * @param _tokenId The NFT identifier which is being transfered\r\n    * @param _data Additional data with no specified format\r\n    * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    */\r\n    function onERC721Received(\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        returns(bytes4);\r\n}\r\ncontract ERC721Holder is ERC721Receiver {\r\n    function onERC721Received(address, uint256, bytes) public returns(bytes4) {\r\n        return ERC721_RECEIVED;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Full ERC721 Token\r\n * This implementation includes all the required and some optional functionality of the ERC721 standard\r\n * Moreover, it includes approve all functionality using operator terminology\r\n * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Token is ERC721, ERC721BasicToken {\r\n\r\n    // Token name\r\n    string internal name_;\r\n\r\n    // Token symbol\r\n    string internal symbol_;\r\n\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint256[]) internal ownedTokens;\r\n\r\n    // Mapping from token ID to index of the owner tokens list\r\n    mapping(uint256 => uint256) internal ownedTokensIndex;\r\n\r\n    // Array with all token ids, used for enumeration\r\n    uint256[] internal allTokens;\r\n\r\n    // Mapping from token id to position in the allTokens array\r\n    mapping(uint256 => uint256) internal allTokensIndex;\r\n\r\n    // Base Server Address for Token MetaData URI\r\n    string internal tokenURIBase;\r\n\r\n    /**\r\n    * @dev Returns an URI for a given token ID. Only returns the based location, you will have to appending a token ID to this\r\n    * @dev Throws if the token ID does not exist. May return an empty string.\r\n    * @param _tokenId uint256 ID of the token to query\r\n    */\r\n    function tokenURI(uint256 _tokenId) public view returns (string) {\r\n        require(exists(_tokenId));\r\n        return tokenURIBase;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of the tokens list of the requested owner\r\n    * @param _owner address owning the tokens list to be accessed\r\n    * @param _index uint256 representing the index to be accessed of the requested tokens list\r\n    * @return uint256 token ID at the given index of the tokens list owned by the requested address\r\n    */\r\n    function tokenOfOwnerByIndex(\r\n        address _owner,\r\n        uint256 _index\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        require(_index < balanceOf(_owner));\r\n        return ownedTokens[_owner][_index];\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the total amount of tokens stored by the contract\r\n    * @return uint256 representing the total amount of tokens\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return allTokens.length;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token ID at a given index of all the tokens in this contract\r\n    * @dev Reverts if the index is greater or equal to the total number of tokens\r\n    * @param _index uint256 representing the index to be accessed of the tokens list\r\n    * @return uint256 token ID at the given index of the tokens list\r\n    */\r\n    function tokenByIndex(uint256 _index) public view returns (uint256) {\r\n        require(_index < totalSupply());\r\n        return allTokens[_index];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Internal function to set the token URI for a given token\r\n    * @dev Reverts if the token ID does not exist\r\n    * @param _uri string URI to assign\r\n    */\r\n    function _setTokenURIBase(string _uri) internal {\r\n        tokenURIBase = _uri;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to add a token ID to the list of a given address\r\n    * @param _to address representing the new owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\r\n    */\r\n    function addTokenTo(address _to, uint256 _tokenId) internal {\r\n        super.addTokenTo(_to, _tokenId);\r\n        uint256 length = ownedTokens[_to].length;\r\n        ownedTokens[_to].push(_tokenId);\r\n        ownedTokensIndex[_tokenId] = length;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to remove a token ID from the list of a given address\r\n    * @param _from address representing the previous owner of the given token ID\r\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\r\n    */\r\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n        super.removeTokenFrom(_from, _tokenId);\r\n\r\n        uint256 tokenIndex = ownedTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownedTokens[_from].length.sub(1);\r\n        uint256 lastToken = ownedTokens[_from][lastTokenIndex];\r\n\r\n        ownedTokens[_from][tokenIndex] = lastToken;\r\n        ownedTokens[_from][lastTokenIndex] = 0;\r\n        // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to\r\n        // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping\r\n        // the lastToken to the first position, and then dropping the element placed in the last position of the list\r\n\r\n        ownedTokens[_from].length--;\r\n        ownedTokensIndex[_tokenId] = 0;\r\n        ownedTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token name\r\n    * @return string representing the token name\r\n    */\r\n    function name() public view returns (string) {\r\n        return name_;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token symbol\r\n    */\r\n    function symbol() public view returns (string) {\r\n        return symbol_;\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to mint a new token\r\n    * @dev Reverts if the given token ID already exists\r\n    * @param _to address the beneficiary that will own the minted token\r\n    * @param _tokenId uint256 ID of the token to be minted by the msg.sender\r\n    */\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        super._mint(_to, _tokenId);\r\n\r\n        allTokensIndex[_tokenId] = allTokens.length;\r\n        allTokens.push(_tokenId);\r\n    }\r\n\r\n    /**\r\n    * @dev Internal function to burn a specific token\r\n    * @dev Reverts if the token does not exist\r\n    * @param _owner owner of the token to burn\r\n    * @param _tokenId uint256 ID of the token being burned by the msg.sender\r\n    */\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        super._burn(_owner, _tokenId);\r\n\r\n        // Reorg all tokens array\r\n        uint256 tokenIndex = allTokensIndex[_tokenId];\r\n        uint256 lastTokenIndex = allTokens.length.sub(1);\r\n        uint256 lastToken = allTokens[lastTokenIndex];\r\n\r\n        allTokens[tokenIndex] = lastToken;\r\n        allTokens[lastTokenIndex] = 0;\r\n\r\n        allTokens.length--;\r\n        allTokensIndex[_tokenId] = 0;\r\n        allTokensIndex[lastToken] = tokenIndex;\r\n    }\r\n\r\n    bytes4 constant InterfaceSignature_ERC165 = 0x01ffc9a7;\r\n    /*\r\n    bytes4(keccak256('supportsInterface(bytes4)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721Enumerable = 0x780e9d63;\r\n    /*\r\n    bytes4(keccak256('totalSupply()')) ^\r\n    bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^\r\n    bytes4(keccak256('tokenByIndex(uint256)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721Metadata = 0x5b5e139f;\r\n    /*\r\n    bytes4(keccak256('name()')) ^\r\n    bytes4(keccak256('symbol()')) ^\r\n    bytes4(keccak256('tokenURI(uint256)'));\r\n    */\r\n\r\n    bytes4 constant InterfaceSignature_ERC721 = 0x80ac58cd;\r\n    /*\r\n    bytes4(keccak256('balanceOf(address)')) ^\r\n    bytes4(keccak256('ownerOf(uint256)')) ^\r\n    bytes4(keccak256('approve(address,uint256)')) ^\r\n    bytes4(keccak256('getApproved(uint256)')) ^\r\n    bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n    bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n    bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n    bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'));\r\n    */\r\n\r\n    bytes4 public constant InterfaceSignature_ERC721Optional =- 0x4f558e79;\r\n    /*\r\n    bytes4(keccak256('exists(uint256)'));\r\n    */\r\n\r\n    /**\r\n    * @notice Introspection interface as per ERC-165 (https://github.com/ethereum/EIPs/issues/165).\r\n    * @dev Returns true for any standardized interfaces implemented by this contract.\r\n    * @param _interfaceID bytes4 the interface to check for\r\n    * @return true for any standardized interfaces implemented by this contract.\r\n    */\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool)\r\n    {\r\n        return ((_interfaceID == InterfaceSignature_ERC165)\r\n        || (_interfaceID == InterfaceSignature_ERC721)\r\n        || (_interfaceID == InterfaceSignature_ERC721Enumerable)\r\n        || (_interfaceID == InterfaceSignature_ERC721Metadata));\r\n    }\r\n\r\n    function implementsERC721() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\ncontract CSCNFTFactory is ERC721Token, OperationalControl {\r\n\r\n    /*** EVENTS ***/\r\n    /// @dev The Created event is fired whenever a new asset comes into existence.\r\n    event AssetCreated(address owner, uint256 assetId, uint256 assetType, uint256 sequenceId, uint256 creationTime);\r\n\r\n    event DetachRequest(address owner, uint256 assetId, uint256 timestamp);\r\n\r\n    event NFTDetached(address requester, uint256 assetId);\r\n\r\n    event NFTAttached(address requester, uint256 assetId);\r\n\r\n    // Mapping from assetId to uint encoded data for NFT\r\n    mapping(uint256 => uint256) internal nftDataA;\r\n    mapping(uint256 => uint128) internal nftDataB;\r\n\r\n    // Mapping from Asset Types to count of that type in exsistance\r\n    mapping(uint32 => uint64) internal assetTypeTotalCount;\r\n\r\n    mapping(uint32 => uint64) internal assetTypeBurnedCount;\r\n  \r\n    // Mapping from index of a Asset Type to get AssetID\r\n    mapping(uint256 => mapping(uint32 => uint64) ) internal sequenceIDToTypeForID;\r\n\r\n     // Mapping from Asset Type to string name of type\r\n    mapping(uint256 => string) internal assetTypeName;\r\n\r\n    // Mapping from assetType to creation limit\r\n    mapping(uint256 => uint32) internal assetTypeCreationLimit;\r\n\r\n    // Indicates if attached system is Active (Transfers will be blocked if attached and active)\r\n    bool public attachedSystemActive;\r\n\r\n    // Is Asset Burning Active\r\n    bool public canBurn;\r\n\r\n    // Time LS Oracle has to respond to detach requests\r\n    uint32 public detachmentTime = 300;\r\n\r\n    /**\r\n    * @dev Constructor function\r\n    */\r\n    constructor() public {\r\n        require(msg.sender != address(0));\r\n        paused = true;\r\n        error = false;\r\n        canBurn = false;\r\n        managerPrimary = msg.sender;\r\n        managerSecondary = msg.sender;\r\n        bankManager = msg.sender;\r\n\r\n        name_ = \"CSCNFTFactory\";\r\n        symbol_ = \"CSCNFT\";\r\n    }\r\n\r\n    /**\r\n    * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator\r\n    * @param _tokenId uint256 ID of the token to validate\r\n    */\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        uint256 isAttached = getIsNFTAttached(_tokenId);\r\n        if(isAttached == 2) {\r\n            //One-Time Auth for Physical Card Transfers\r\n            require(msg.sender == managerPrimary ||\r\n                msg.sender == managerSecondary ||\r\n                msg.sender == bankManager ||\r\n                otherManagers[msg.sender] == 1\r\n            );\r\n            updateIsAttached(_tokenId, 1);\r\n        } else if(attachedSystemActive == true && isAttached >= 1) {\r\n            require(msg.sender == managerPrimary ||\r\n                msg.sender == managerSecondary ||\r\n                msg.sender == bankManager ||\r\n                otherManagers[msg.sender] == 1\r\n            );\r\n        }\r\n        else {\r\n            require(isApprovedOrOwner(msg.sender, _tokenId));\r\n        }\r\n        \r\n    _;\r\n    }\r\n\r\n    /** Public Functions */\r\n\r\n    // Returns the AssetID for the Nth assetID for a specific type\r\n    function getAssetIDForTypeSequenceID(uint256 _seqId, uint256 _type) public view returns (uint256 _assetID) {\r\n        return sequenceIDToTypeForID[_seqId][uint32(_type)];\r\n    }\r\n\r\n    function getAssetDetails(uint256 _assetId) public view returns(\r\n        uint256 assetId,\r\n        uint256 ownersIndex,\r\n        uint256 assetTypeSeqId,\r\n        uint256 assetType,\r\n        uint256 createdTimestamp,\r\n        uint256 isAttached,\r\n        address creator,\r\n        address owner\r\n    ) {\r\n        require(exists(_assetId));\r\n\r\n        uint256 nftData = nftDataA[_assetId];\r\n        uint256 nftDataBLocal = nftDataB[_assetId];\r\n\r\n        assetId = _assetId;\r\n        ownersIndex = ownedTokensIndex[_assetId];\r\n        createdTimestamp = uint256(uint48(nftData>>160));\r\n        assetType = uint256(uint32(nftData>>208));\r\n        assetTypeSeqId = uint256(uint64(nftDataBLocal));\r\n        isAttached = uint256(uint48(nftDataBLocal>>64));\r\n        creator = address(nftData);\r\n        owner = ownerOf(_assetId);\r\n    }\r\n\r\n    function totalSupplyOfType(uint256 _type) public view returns (uint256 _totalOfType) {\r\n        return assetTypeTotalCount[uint32(_type)] - assetTypeBurnedCount[uint32(_type)];\r\n    }\r\n\r\n    function totalCreatedOfType(uint256 _type) public view returns (uint256 _totalOfType) {\r\n        return assetTypeTotalCount[uint32(_type)];\r\n    }\r\n\r\n    function totalBurnedOfType(uint256 _type) public view returns (uint256 _totalOfType) {\r\n        return assetTypeBurnedCount[uint32(_type)];\r\n    }\r\n\r\n    function getAssetRawMeta(uint256 _assetId) public view returns(\r\n        uint256 dataA,\r\n        uint128 dataB\r\n    ) {\r\n        require(exists(_assetId));\r\n\r\n        dataA = nftDataA[_assetId];\r\n        dataB = nftDataB[_assetId];\r\n    }\r\n\r\n    function getAssetIdItemType(uint256 _assetId) public view returns(\r\n        uint256 assetType\r\n    ) {\r\n        require(exists(_assetId));\r\n        uint256 dataA = nftDataA[_assetId];\r\n        assetType = uint256(uint32(dataA>>208));\r\n    }\r\n\r\n    function getAssetIdTypeSequenceId(uint256 _assetId) public view returns(\r\n        uint256 assetTypeSequenceId\r\n    ) {\r\n        require(exists(_assetId));\r\n        uint256 dataB = nftDataB[_assetId];\r\n        assetTypeSequenceId = uint256(uint64(dataB));\r\n    }\r\n    \r\n    function getIsNFTAttached( uint256 _assetId) \r\n    public view returns(\r\n        uint256 isAttached\r\n    ) {\r\n        uint256 nftData = nftDataB[_assetId];\r\n        isAttached = uint256(uint48(nftData>>64));\r\n    }\r\n\r\n    function getAssetIdCreator(uint256 _assetId) public view returns(\r\n        address creator\r\n    ) {\r\n        require(exists(_assetId));\r\n        uint256 dataA = nftDataA[_assetId];\r\n        creator = address(dataA);\r\n    }\r\n\r\n    function isAssetIdOwnerOrApproved(address requesterAddress, uint256 _assetId) public view returns(\r\n        bool\r\n    ) {\r\n        return isApprovedOrOwner(requesterAddress, _assetId);\r\n    }\r\n\r\n    function getAssetIdOwner(uint256 _assetId) public view returns(\r\n        address owner\r\n    ) {\r\n        require(exists(_assetId));\r\n\r\n        owner = ownerOf(_assetId);\r\n    }\r\n\r\n    function getAssetIdOwnerIndex(uint256 _assetId) public view returns(\r\n        uint256 ownerIndex\r\n    ) {\r\n        require(exists(_assetId));\r\n        ownerIndex = ownedTokensIndex[_assetId];\r\n    }\r\n\r\n    /// @param _owner The owner whose ships tokens we are interested in.\r\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n    ///  expensive (it walks the entire NFT owners array looking for NFT belonging to owner),\r\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n    ///  not contract-to-contract calls.\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 resultIndex = 0;\r\n\r\n            // We count on the fact that all Asset have IDs starting at 0 and increasing\r\n            // sequentially up to the total count.\r\n            uint256 _itemIndex;\r\n\r\n            for (_itemIndex = 0; _itemIndex < tokenCount; _itemIndex++) {\r\n                result[resultIndex] = tokenOfOwnerByIndex(_owner,_itemIndex);\r\n                resultIndex++;\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    // Get the name of the Asset type\r\n    function getTypeName (uint32 _type) public returns(string) {\r\n        return assetTypeName[_type];\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Transfers the ownership of a given token ID to another address, modified to prevent transfer if attached and system is active\r\n    */\r\n    function transferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        require(_from != address(0));\r\n        require(_to != address(0));\r\n\r\n        clearApproval(_from, _tokenId);\r\n        removeTokenFrom(_from, _tokenId);\r\n        addTokenTo(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n    \r\n\r\n    \r\n    function multiBatchTransferFrom(\r\n        uint256[] _assetIds, \r\n        address[] _fromB, \r\n        address[] _toB) \r\n        public\r\n    {\r\n        uint256 _id;\r\n        address _to;\r\n        address _from;\r\n        \r\n        for (uint256 i = 0; i < _assetIds.length; ++i) {\r\n            _id = _assetIds[i];\r\n            _to = _toB[i];\r\n            _from = _fromB[i];\r\n\r\n            require(isApprovedOrOwner(msg.sender, _id));\r\n\r\n            require(_from != address(0));\r\n            require(_to != address(0));\r\n    \r\n            clearApproval(_from, _id);\r\n            removeTokenFrom(_from, _id);\r\n            addTokenTo(_to, _id);\r\n    \r\n            emit Transfer(_from, _to, _id);\r\n        }\r\n        \r\n    }\r\n    \r\n    function batchTransferFrom(uint256[] _assetIds, address _from, address _to) \r\n        public\r\n    {\r\n        uint256 _id;\r\n        \r\n        for (uint256 i = 0; i < _assetIds.length; ++i) {\r\n            _id = _assetIds[i];\r\n\r\n            require(isApprovedOrOwner(msg.sender, _id));\r\n\r\n            require(_from != address(0));\r\n            require(_to != address(0));\r\n    \r\n            clearApproval(_from, _id);\r\n            removeTokenFrom(_from, _id);\r\n            addTokenTo(_to, _id);\r\n    \r\n            emit Transfer(_from, _to, _id);\r\n        }\r\n    }\r\n    \r\n    function multiBatchSafeTransferFrom(\r\n        uint256[] _assetIds, \r\n        address[] _fromB, \r\n        address[] _toB\r\n        )\r\n        public\r\n    {\r\n        uint256 _id;\r\n        address _to;\r\n        address _from;\r\n        \r\n        for (uint256 i = 0; i < _assetIds.length; ++i) {\r\n            _id = _assetIds[i];\r\n            _to  = _toB[i];\r\n            _from  = _fromB[i];\r\n\r\n            safeTransferFrom(_from, _to, _id);\r\n        }\r\n    }\r\n\r\n    function batchSafeTransferFrom(\r\n        uint256[] _assetIds, \r\n        address _from, \r\n        address _to\r\n        )\r\n        public\r\n    {\r\n        uint256 _id;\r\n        for (uint256 i = 0; i < _assetIds.length; ++i) {\r\n            _id = _assetIds[i];\r\n            safeTransferFrom(_from, _to, _id);\r\n        }\r\n    }\r\n\r\n\r\n    function batchApprove(\r\n        uint256[] _assetIds, \r\n        address _spender\r\n        )\r\n        public\r\n    {\r\n        uint256 _id;\r\n        for (uint256 i = 0; i < _assetIds.length; ++i) {\r\n            _id = _assetIds[i];\r\n            approve(_spender, _id);\r\n        }\r\n        \r\n    }\r\n\r\n\r\n    function batchSetApprovalForAll(\r\n        address[] _spenders,\r\n        bool _approved\r\n        )\r\n        public\r\n    {\r\n        address _spender;\r\n        for (uint256 i = 0; i < _spenders.length; ++i) {\r\n            _spender = _spenders[i];\r\n            setApprovalForAll(_spender, _approved);\r\n        }\r\n    }  \r\n    \r\n    function requestDetachment(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n    {\r\n        //Request can only be made by owner or approved address\r\n        require(isApprovedOrOwner(msg.sender, _tokenId));\r\n\r\n        uint256 isAttached = getIsNFTAttached(_tokenId);\r\n\r\n        require(isAttached >= 1);\r\n\r\n        if(attachedSystemActive == true) {\r\n            //Checks to see if request was made and if time elapsed\r\n            if(isAttached > 1 && block.timestamp - isAttached > detachmentTime) {\r\n                isAttached = 0;\r\n            } else if(isAttached > 1) {\r\n                //Fail if time is already set for attachment\r\n                require(isAttached == 1);\r\n            } else {\r\n                //Is attached, set detachment time and make request to detach\r\n                emit DetachRequest(msg.sender, _tokenId, block.timestamp);\r\n                isAttached = block.timestamp;\r\n            }           \r\n        } else {\r\n            isAttached = 0;\r\n        } \r\n\r\n        if(isAttached == 0) {\r\n            emit NFTDetached(msg.sender, _tokenId);\r\n        }\r\n\r\n        updateIsAttached(_tokenId, isAttached);\r\n    }\r\n\r\n    function attachAsset(\r\n        uint256 _tokenId\r\n    )\r\n        public\r\n        canTransfer(_tokenId)\r\n    {\r\n        uint256 isAttached = getIsNFTAttached(_tokenId);\r\n\r\n        require(isAttached == 0);\r\n        isAttached = 1;\r\n\r\n        updateIsAttached(_tokenId, isAttached);\r\n\r\n        emit NFTAttached(msg.sender, _tokenId);\r\n    }\r\n\r\n    function batchAttachAssets(uint256[] _ids) public {\r\n        for(uint i = 0; i < _ids.length; i++) {\r\n            attachAsset(_ids[i]);\r\n        }\r\n    }\r\n\r\n    function batchDetachAssets(uint256[] _ids) public {\r\n        for(uint i = 0; i < _ids.length; i++) {\r\n            requestDetachment(_ids[i]);\r\n        }\r\n    }\r\n\r\n    function requestDetachmentOnPause (uint256 _tokenId) public \r\n    whenPaused {\r\n        //Request can only be made by owner or approved address\r\n        require(isApprovedOrOwner(msg.sender, _tokenId));\r\n\r\n        updateIsAttached(_tokenId, 0);\r\n    }\r\n\r\n    function batchBurnAssets(uint256[] _assetIDs) public {\r\n        uint256 _id;\r\n        for(uint i = 0; i < _assetIDs.length; i++) {\r\n            _id = _assetIDs[i];\r\n            burnAsset(_id);\r\n        }\r\n    }\r\n\r\n    function burnAsset(uint256 _assetID) public {\r\n        // Is Burn Enabled\r\n        require(canBurn == true);\r\n\r\n        // Deny Action if Attached\r\n        require(getIsNFTAttached(_assetID) == 0);\r\n\r\n        require(isApprovedOrOwner(msg.sender, _assetID) == true);\r\n        \r\n        //Updates Type Total Count\r\n        uint256 _assetType = getAssetIdItemType(_assetID);\r\n        assetTypeBurnedCount[uint32(_assetType)] += 1;\r\n        \r\n        _burn(msg.sender, _assetID);\r\n    }\r\n\r\n\r\n    /** Dev Functions */\r\n\r\n    function setTokenURIBase (string _tokenURI) public onlyManager {\r\n        _setTokenURIBase(_tokenURI);\r\n    }\r\n\r\n    function setPermanentLimitForType (uint32 _type, uint256 _limit) public onlyManager {\r\n        //Only allows Limit to be set once\r\n        require(assetTypeCreationLimit[_type] == 0);\r\n\r\n        assetTypeCreationLimit[_type] = uint32(_limit);\r\n    }\r\n\r\n    function setTypeName (uint32 _type, string _name) public anyOperator {\r\n        assetTypeName[_type] = _name;\r\n    }\r\n\r\n    // Minting Function\r\n    function batchSpawnAsset(address _to, uint256[] _assetTypes, uint256[] _assetIds, uint256 _isAttached) public anyOperator {\r\n        uint256 _id;\r\n        uint256 _assetType;\r\n        for(uint i = 0; i < _assetIds.length; i++) {\r\n            _id = _assetIds[i];\r\n            _assetType = _assetTypes[i];\r\n            _createAsset(_to, _assetType, _id, _isAttached, address(0));\r\n        }\r\n    }\r\n\r\n    function batchSpawnAsset(address[] _toB, uint256[] _assetTypes, uint256[] _assetIds, uint256 _isAttached) public anyOperator {\r\n        address _to;\r\n        uint256 _id;\r\n        uint256 _assetType;\r\n        for(uint i = 0; i < _assetIds.length; i++) {\r\n            _to = _toB[i];\r\n            _id = _assetIds[i];\r\n            _assetType = _assetTypes[i];\r\n            _createAsset(_to, _assetType, _id, _isAttached, address(0));\r\n        }\r\n    }\r\n\r\n    function batchSpawnAssetWithCreator(address[] _toB, uint256[] _assetTypes, uint256[] _assetIds, uint256[] _isAttacheds, address[] _creators) public anyOperator {\r\n        address _to;\r\n        address _creator;\r\n        uint256 _id;\r\n        uint256 _assetType;\r\n        uint256 _isAttached;\r\n        for(uint i = 0; i < _assetIds.length; i++) {\r\n            _to = _toB[i];\r\n            _id = _assetIds[i];\r\n            _assetType = _assetTypes[i];\r\n            _creator = _creators[i];\r\n            _isAttached = _isAttacheds[i];\r\n            _createAsset(_to, _assetType, _id, _isAttached, _creator);\r\n        }\r\n    }\r\n\r\n    function spawnAsset(address _to, uint256 _assetType, uint256 _assetID, uint256 _isAttached) public anyOperator {\r\n        _createAsset(_to, _assetType, _assetID, _isAttached, address(0));\r\n    }\r\n\r\n    function spawnAssetWithCreator(address _to, uint256 _assetType, uint256 _assetID, uint256 _isAttached, address _creator) public anyOperator {\r\n        _createAsset(_to, _assetType, _assetID, _isAttached, _creator);\r\n    }\r\n\r\n    /// @dev Remove all Ether from the contract, shouldn't have any but just incase.\r\n    function withdrawBalance() public onlyBanker {\r\n        // We are using this boolean method to make sure that even if one fails it will still work\r\n        bankManager.transfer(address(this).balance);\r\n    }\r\n\r\n    // Burn Functions\r\n\r\n    function setCanBurn(bool _state) public onlyManager {\r\n        canBurn = _state;\r\n    }\r\n\r\n    function burnAssetOperator(uint256 _assetID) public anyOperator {\r\n        \r\n        require(getIsNFTAttached(_assetID) > 0);\r\n\r\n        //Updates Type Total Count\r\n        uint256 _assetType = getAssetIdItemType(_assetID);\r\n        assetTypeBurnedCount[uint32(_assetType)] += 1;\r\n        \r\n        _burn(ownerOf(_assetID), _assetID);\r\n    }\r\n\r\n    function toggleAttachedEnforement (bool _state) public onlyManager {\r\n        attachedSystemActive = _state;\r\n    }\r\n\r\n    function setDetachmentTime (uint256 _time) public onlyManager {\r\n        //Detactment Time can not be set greater than 2 weeks.\r\n        require(_time <= 1209600);\r\n        detachmentTime = uint32(_time);\r\n    }\r\n\r\n    function setNFTDetached(uint256 _assetID) public anyOperator {\r\n        require(getIsNFTAttached(_assetID) > 0);\r\n\r\n        updateIsAttached(_assetID, 0);\r\n        emit NFTDetached(msg.sender, _assetID);\r\n    }\r\n\r\n    function setBatchDetachCollectibles(uint256[] _assetIds) public anyOperator {\r\n        uint256 _id;\r\n        for(uint i = 0; i < _assetIds.length; i++) {\r\n            _id = _assetIds[i];\r\n            setNFTDetached(_id);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /** Internal Functions */\r\n\r\n    // @dev For creating NFT Collectible\r\n    function _createAsset(address _to, uint256 _assetType, uint256 _assetID, uint256 _attachState, address _creator) internal returns(uint256) {\r\n        \r\n        uint256 _sequenceId = uint256(assetTypeTotalCount[uint32(_assetType)]) + 1;\r\n\r\n        //Will not allow creation if over limit\r\n        require(assetTypeCreationLimit[uint32(_assetType)] == 0 || assetTypeCreationLimit[uint32(_assetType)] > _sequenceId);\r\n        \r\n        // These requires are not strictly necessary, our calling code should make\r\n        // sure that these conditions are never broken.\r\n        require(_sequenceId == uint256(uint64(_sequenceId)));\r\n\r\n        //Creates NFT\r\n        _mint(_to, _assetID);\r\n\r\n        uint256 nftData = uint256(_creator); // 160 bit address of creator\r\n        nftData |= now<<160; // 48 bit creation timestamp\r\n        nftData |= _assetType<<208; // 32 bit item type \r\n\r\n        uint256 nftDataContinued = uint256(_sequenceId); // 64 bit sequence id of item\r\n        nftDataContinued |= _attachState<<64; // 48 bit state and/or timestamp for detachment\r\n\r\n        nftDataA[_assetID] = nftData;\r\n        nftDataB[_assetID] = uint128(nftDataContinued);\r\n\r\n        assetTypeTotalCount[uint32(_assetType)] += 1;\r\n        sequenceIDToTypeForID[_sequenceId][uint32(_assetType)] = uint64(_assetID);\r\n\r\n        // emit Created event\r\n        emit AssetCreated(_to, _assetID, _assetType, _sequenceId, now);\r\n\r\n        return _assetID;\r\n    }\r\n\r\n    function updateIsAttached(uint256 _assetID, uint256 _isAttached) \r\n    internal\r\n    {\r\n        uint256 nftData = nftDataB[_assetID];\r\n\r\n        uint256 assetTypeSeqId = uint256(uint64(nftData));\r\n\r\n        uint256 nftDataContinued = uint256(assetTypeSeqId); // 64 bit sequence id of item\r\n        nftDataContinued |= _isAttached<<64; // 48 bit state and/or timestamp for detachment\r\n\r\n        nftDataB[_assetID] = uint128(nftDataContinued);\r\n    }\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"name\":\"_fromB\",\"type\":\"address[]\"},{\"name\":\"_toB\",\"type\":\"address[]\"}],\"name\":\"multiBatchSafeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"totalBurnedOfType\",\"outputs\":[{\"name\":\"_totalOfType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"requestDetachment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetID\",\"type\":\"uint256\"}],\"name\":\"burnAssetOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spenders\",\"type\":\"address[]\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"batchSetApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetIdOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetRawMeta\",\"outputs\":[{\"name\":\"dataA\",\"type\":\"uint256\"},{\"name\":\"dataB\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"detachmentTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetIdItemType\",\"outputs\":[{\"name\":\"assetType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"name\":\"_fromB\",\"type\":\"address[]\"},{\"name\":\"_toB\",\"type\":\"address[]\"}],\"name\":\"multiBatchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"otherManagers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint32\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setTypeName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"setCanBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"batchApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"exists\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setDetachmentTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"totalCreatedOfType\",\"outputs\":[{\"name\":\"_totalOfType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceSignature_ERC721Optional\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toB\",\"type\":\"address[]\"},{\"name\":\"_assetTypes\",\"type\":\"uint256[]\"},{\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"name\":\"_isAttacheds\",\"type\":\"uint256[]\"},{\"name\":\"_creators\",\"type\":\"address[]\"}],\"name\":\"batchSpawnAssetWithCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"attachedSystemActive\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetIdOwnerIndex\",\"outputs\":[{\"name\":\"ownerIndex\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"batchDetachAssets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setSecondaryManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"tokensOfOwner\",\"outputs\":[{\"name\":\"ownerTokens\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ids\",\"type\":\"uint256[]\"}],\"name\":\"batchAttachAssets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"noError\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetID\",\"type\":\"uint256\"}],\"name\":\"burnAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"batchSafeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetIdCreator\",\"outputs\":[{\"name\":\"creator\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetDetails\",\"outputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"ownersIndex\",\"type\":\"uint256\"},{\"name\":\"assetTypeSeqId\",\"type\":\"uint256\"},{\"name\":\"assetType\",\"type\":\"uint256\"},{\"name\":\"createdTimestamp\",\"type\":\"uint256\"},{\"name\":\"isAttached\",\"type\":\"uint256\"},{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_assetTypes\",\"type\":\"uint256[]\"},{\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"name\":\"_isAttached\",\"type\":\"uint256\"}],\"name\":\"batchSpawnAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetIds\",\"type\":\"uint256[]\"}],\"name\":\"setBatchDetachCollectibles\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getIsNFTAttached\",\"outputs\":[{\"name\":\"isAttached\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"hasError\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint32\"}],\"name\":\"getTypeName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"totalSupplyOfType\",\"outputs\":[{\"name\":\"_totalOfType\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerPrimary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOp\",\"type\":\"address\"},{\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setOtherManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_assetType\",\"type\":\"uint256\"},{\"name\":\"_assetID\",\"type\":\"uint256\"},{\"name\":\"_isAttached\",\"type\":\"uint256\"},{\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"spawnAssetWithCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setPrimaryManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"attachAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canBurn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"uint32\"},{\"name\":\"_limit\",\"type\":\"uint256\"}],\"name\":\"setPermanentLimitForType\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"error\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetIDs\",\"type\":\"uint256[]\"}],\"name\":\"batchBurnAssets\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getAssetIdTypeSequenceId\",\"outputs\":[{\"name\":\"assetTypeSequenceId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenURI\",\"type\":\"string\"}],\"name\":\"setTokenURIBase\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"requestDetachmentOnPause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetID\",\"type\":\"uint256\"}],\"name\":\"setNFTDetached\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerSecondary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_seqId\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint256\"}],\"name\":\"getAssetIDForTypeSequenceID\",\"outputs\":[{\"name\":\"_assetID\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_assetType\",\"type\":\"uint256\"},{\"name\":\"_assetID\",\"type\":\"uint256\"},{\"name\":\"_isAttached\",\"type\":\"uint256\"}],\"name\":\"spawnAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBK\",\"type\":\"address\"}],\"name\":\"setBanker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_state\",\"type\":\"bool\"}],\"name\":\"toggleAttachedEnforement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"requesterAddress\",\"type\":\"address\"},{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"isAssetIdOwnerOrApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toB\",\"type\":\"address[]\"},{\"name\":\"_assetTypes\",\"type\":\"uint256[]\"},{\"name\":\"_assetIds\",\"type\":\"uint256[]\"},{\"name\":\"_isAttached\",\"type\":\"uint256\"}],\"name\":\"batchSpawnAsset\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sequenceId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"creationTime\",\"type\":\"uint256\"}],\"name\":\"AssetCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"}],\"name\":\"DetachRequest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"NFTDetached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"requester\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"NFTAttached\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"CSCNFTFactory","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7ba6d647dfc4c3d9f9692264302bcbfa1c1e96a6ec11a5a43f31a91efd079d65"}]}