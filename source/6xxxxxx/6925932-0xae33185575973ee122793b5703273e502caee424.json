{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address private _owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    _owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), _owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == _owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(_owner, address(0));\r\n    _owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    _transferOwnership(newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address newOwner) internal {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(_owner, newOwner);\r\n    _owner = newOwner;\r\n  }\r\n}\r\n\r\n// File: solidity-rlp/contracts/RLPReader.sol\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\npragma solidity ^0.4.24;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        if (item.length == 0) \r\n            return RLPItem(0, 0);\r\n\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr); \r\n            memPtr = memPtr + dataLen;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * Helpers\r\n    */\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) internal pure returns (uint) {\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) internal pure returns (uint len) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            return 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            return byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n                \r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            return byte0 - LIST_SHORT_START + 1;\r\n        } \r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) internal pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) \r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes) {\r\n        bytes memory result = new bytes(item.len);\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1, \"Invalid RLPItem. Booleans are encoded in 1 byte\");\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix according to RLP spec\r\n        require(item.len <= 21, \"Invalid RLPItem. Addresses are encoded in 20 bytes or less\");\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n        uint memPtr = item.memPtr + offset;\r\n\r\n        uint result;\r\n        assembly {\r\n            result := div(mload(memPtr), exp(256, sub(32, len))) // shift to the correct location\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) internal pure {\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/BetStorage.sol\r\n\r\n/**\r\n * @title ClashHash\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without\r\n * express written consent from the creators is prohibited.\r\n */\r\n\r\n\r\n\r\n\r\ncontract BetStorage is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => mapping(address => uint256)) public bets;\r\n    mapping(address => uint256) public betsSumByOption;\r\n    address public wonOption;\r\n\r\n    event BetAdded(address indexed user, address indexed option, uint256 value);\r\n    event Finalized(address indexed option);\r\n    event RewardClaimed(address indexed user, uint256 reward);\r\n\r\n    function addBet(address user, address option) public payable onlyOwner {\r\n        require(msg.value > 0, \"Empty bet is not allowed\");\r\n        require(option != address(0), \"Option should not be zero\");\r\n\r\n        bets[user][option] = bets[user][option].add(msg.value);\r\n        betsSumByOption[option] = betsSumByOption[option].add(msg.value);\r\n        emit BetAdded(user, option, msg.value);\r\n    }\r\n\r\n    function finalize(address option, address admin) public onlyOwner {\r\n        require(wonOption == address(0), \"Finalization could be called only once\");\r\n        require(option != address(0), \"Won option should not be zero\");\r\n\r\n        wonOption = option;\r\n        emit Finalized(option);\r\n\r\n        if (betsSumByOption[option] == 0) {\t\t\r\n            selfdestruct(admin);\t\t\r\n        }\t\t\r\n    }\r\n\r\n    function rewardFor(address user) public view returns(uint256 reward) {\r\n        if (bets[user][wonOption] > 0) {\r\n            reward = address(this).balance\r\n                .mul(bets[user][wonOption])\r\n                .div(betsSumByOption[wonOption]);\r\n        }\r\n    }\r\n\r\n    function rewards(\r\n        address user,\r\n        address referrer,\r\n        uint256 referrerFee,\r\n        uint256 adminFee\r\n    )\r\n        public\r\n        view\r\n        returns(uint256 userReward, uint256 referrerReward, uint256 adminReward)\r\n    {\r\n        userReward = rewardFor(user);\r\n        adminReward = userReward.sub(bets[user][wonOption]).mul(adminFee).div(100);\r\n\r\n        if (referrer != address(0)) {\r\n            referrerReward = adminReward.mul(referrerFee).div(100);\r\n            adminReward = adminReward.sub(referrerReward);\r\n        }\r\n\r\n        userReward = userReward.sub(adminReward).sub(referrerReward);\r\n    }\r\n\r\n    function claimReward(\r\n        address user,\r\n        address admin,\r\n        uint256 adminFee,\r\n        address referrer,\r\n        uint256 referrerFee\r\n    )\r\n        public\r\n        onlyOwner\r\n    {\r\n        require(wonOption != address(0), \"Round not yet finalized\");\r\n\r\n        (uint256 userReward, uint256 referrerReward, uint256 adminReward) = rewards(\r\n            user,\r\n            referrer,\r\n            referrerFee,\r\n            adminFee\r\n        );\r\n        require(userReward > 0, \"Reward was claimed previously or never existed\");\r\n        \r\n        betsSumByOption[wonOption] = betsSumByOption[wonOption].sub(bets[user][wonOption]);\r\n        bets[user][wonOption] = 0;\r\n\r\n        if (referrerReward > 0) {\r\n            referrer.send(referrerReward);\r\n        }\r\n\r\n        if (adminReward > 0) {\r\n            admin.send(adminReward);\r\n        }\r\n\r\n        user.transfer(userReward);\r\n        emit RewardClaimed(user, userReward);\r\n\r\n        if (betsSumByOption[wonOption] == 0) {\r\n            selfdestruct(admin);\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/BlockHash.sol\r\n\r\ncontract BlockHash {\r\n    using SafeMath for uint256;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    mapping (uint256 => bytes32) private _hashes;\r\n\r\n    function blockhashes(\r\n        uint256 blockNumber\r\n    )\r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        if (blockNumber >= block.number.sub(256)) {\r\n            return blockhash(blockNumber);\r\n        }\r\n\r\n        return _hashes[blockNumber];\r\n    }\r\n\r\n    function addBlocks(\r\n        uint256 blockNumber,\r\n        bytes blocksData,\r\n        uint256[] starts\r\n    )\r\n        public\r\n    {\r\n        require(starts.length > 0 && starts[starts.length - 1] == blocksData.length, \"Wrong starts argument\");\r\n\r\n        bytes32 expectedHash = blockhashes(blockNumber);\r\n        for (uint i = 0; i < starts.length - 1; i++) {\r\n            uint256 offset = starts[i];\r\n            uint256 length = starts[i + 1].sub(starts[i]);\r\n            bytes32 result;\r\n            uint256 ptr;\r\n            assembly {\r\n                ptr := add(add(blocksData, 0x20), offset)\r\n                result := keccak256(ptr, length)\r\n            }\r\n\r\n            require(result == expectedHash, \"Blockhash didn't match\");\r\n            expectedHash = bytes32(RLPReader.RLPItem({len: length, memPtr: ptr}).toList()[0].toUint());\r\n        }\r\n        \r\n        uint256 index = blockNumber.add(1).sub(starts.length);\r\n        if (_hashes[index] == 0) {\r\n            _hashes[index] = expectedHash;\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ClashHash.sol\r\n\r\n/**\r\n * @title ClashHash\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without\r\n * express written consent from the creators is prohibited.\r\n */\r\n\r\ncontract ClashHash is Ownable {\r\n    using SafeMath for uint256;\r\n    using RLPReader for bytes;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    struct Round {\r\n        BetStorage records;\r\n        uint256 betsCount;\r\n        uint256 totalReward;\r\n        address winner;\r\n    }\r\n\r\n    uint256 public minBet = 0.001 ether;\r\n    uint256 constant public MIN_BLOCKS_BEFORE_ROUND = 10;\r\n    uint256 constant public MIN_BLOCKS_AFTER_ROUND = 10;\r\n    uint256 constant public MAX_BLOCKS_AFTER_ROUND = 256;\r\n\r\n    uint256 public adminFee = 5;\r\n    uint256 public referrerFee = 50;\r\n\r\n    mapping(address => address) public referrers;\r\n    mapping(uint256 => Round) public rounds;\r\n    BlockHash public _blockStorage;\r\n\r\n    //\r\n\r\n    event RoundCreated(uint256 indexed blockNumber, address contractAddress);\r\n    event RoundBetAdded(uint256 indexed blockNumber, address indexed user, address indexed option, uint256 value);\r\n    event RoundFinalized(uint256 indexed blockNumber, address indexed option);\r\n    event RewardClaimed(uint256 indexed blockNumber, address indexed user, address indexed winner, uint256 reward);\r\n\r\n    event NewReferral(address indexed user, address indexed referrer);\r\n    event ReferralReward(address indexed user, address indexed referrer, uint256 value);\r\n\r\n    event AdminFeeUpdate(uint256 oldFee, uint256 newFee);\r\n    event ReferrerFeeUpdate(uint256 oldFee, uint256 newFee);\r\n    event MinBetUpdate(uint256 oldMinBet, uint256 newMinBet);\r\n\r\n    //\r\n\r\n    constructor (BlockHash blockStorage) public {\r\n        _blockStorage = blockStorage;\r\n    }\r\n\r\n    //\r\n\r\n    function setReferrerFee(uint256 newFee) public onlyOwner {\r\n        emit ReferrerFeeUpdate(referrerFee, newFee);\r\n        referrerFee = newFee;\r\n    }\r\n\r\n    function setAdminFee(uint256 newFee) public onlyOwner {\r\n        emit AdminFeeUpdate(adminFee, newFee);\r\n        adminFee = newFee;\r\n    }\r\n\r\n    function setMinBet(uint256 newMinBet) public onlyOwner {\r\n        emit MinBetUpdate(minBet, newMinBet);\r\n        minBet = newMinBet;\r\n    }\r\n\r\n    /**\r\n     * @param referrer Who has invited the user.\r\n     */\r\n    function addReferral(address referrer) public {\r\n        require(referrer != address(0), \"Invalid referrer address\");\r\n        require(referrer != msg.sender, \"Different addresses required\");\r\n        require(referrers[msg.sender] == address(0), \"User has referrer already\");\r\n\r\n        referrers[msg.sender] = referrer;\r\n        emit NewReferral(msg.sender, referrer);\r\n    }\r\n\r\n    function addBet(uint256 blockNumber, address option) public payable {\r\n        require(msg.value >= minBet, \"Bet amount is too low\");\r\n        require(block.number <= blockNumber.sub(MIN_BLOCKS_BEFORE_ROUND), \"It's too late\");\r\n\r\n        Round storage round = rounds[blockNumber];\r\n        if (round.records == address(0)) {\r\n            round.records = new BetStorage();\r\n            emit RoundCreated(blockNumber, round.records);\r\n        }\r\n\r\n        round.betsCount += 1;\r\n        round.totalReward = round.totalReward.add(msg.value);\r\n        round.records.addBet.value(msg.value)(msg.sender, option);\r\n\r\n        emit RoundBetAdded(\r\n            blockNumber,\r\n            msg.sender,\r\n            option,\r\n            msg.value\r\n        );\r\n    }\r\n\r\n    function addBetWithReferrer(\r\n        uint256 blockNumber,\r\n        address option,\r\n        address referrer\r\n    )\r\n        public\r\n        payable\r\n    {\r\n        addReferral(referrer);\r\n        addBet(blockNumber, option);\r\n    }\r\n\r\n    function claimRewardWithBlockData(uint256 blockNumber, bytes blockData) public {\r\n        if (blockData.length > 0 && rounds[blockNumber].winner == address(0)) {\r\n            addBlockData(blockNumber, blockData);\r\n        }\r\n\r\n        claimRewardForUser(blockNumber, msg.sender);\r\n    }\r\n\r\n    function claimRewardForUser(uint256 blockNumber, address user) public {\r\n        Round storage round = rounds[blockNumber];\r\n        require(round.winner != address(0), \"Round not yet finished\");\r\n        require(address(round.records).balance > 0, \"Round prizes are already distributed\");\r\n\r\n        (uint256 userReward, uint256 referrerReward,) = round.records.rewards(\r\n            user,\r\n            referrers[user],\r\n            referrerFee,\r\n            adminFee\r\n        );\r\n        round.records.claimReward(user, owner(), adminFee, referrers[user], referrerFee);\r\n\r\n        emit RewardClaimed(blockNumber, user, round.winner, userReward);\r\n\r\n        if (referrerReward > 0) {\r\n            emit ReferralReward(user, referrers[user], referrerReward);\r\n        }\r\n    }\r\n\r\n    function addBlockData(uint256 blockNumber, bytes blockData) public {\r\n        Round storage round = rounds[blockNumber];\r\n\r\n        require(round.winner == address(0), \"Winner was already submitted\");\r\n        require(block.number <= blockNumber.add(MAX_BLOCKS_AFTER_ROUND), \"It's too late, 256 blocks gone\");\r\n        require(block.number >= blockNumber.add(MIN_BLOCKS_AFTER_ROUND), \"Wait at least 10 blocks\");\r\n\r\n        address blockBeneficiary = _readBlockBeneficiary(blockNumber, blockData);\r\n\r\n        round.winner = blockBeneficiary;\r\n        round.records.finalize(blockBeneficiary, owner());\r\n        emit RoundFinalized(blockNumber, blockBeneficiary);\r\n    }\r\n\r\n    function _readBlockBeneficiary(\r\n        uint256 blockNumber,\r\n        bytes blockData\r\n    )\r\n        internal\r\n        view\r\n        returns(address)\r\n    {\r\n        require(keccak256(blockData) == _blockStorage.blockhashes(blockNumber), \"Block data isn't valid\");\r\n        RLPReader.RLPItem[] memory items = blockData.toRlpItem().toList();\r\n        return items[2].toAddress();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"option\",\"type\":\"address\"},{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"addBetWithReferrer\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"blockData\",\"type\":\"bytes\"}],\"name\":\"claimRewardWithBlockData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"blockData\",\"type\":\"bytes\"}],\"name\":\"addBlockData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BLOCKS_BEFORE_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"claimRewardForUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"referrerFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_BLOCKS_AFTER_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinBet\",\"type\":\"uint256\"}],\"name\":\"setMinBet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setAdminFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"records\",\"type\":\"address\"},{\"name\":\"betsCount\",\"type\":\"uint256\"},{\"name\":\"totalReward\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_BLOCKS_AFTER_ROUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"option\",\"type\":\"address\"}],\"name\":\"addBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_blockStorage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"addReferral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setReferrerFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"blockStorage\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"contractAddress\",\"type\":\"address\"}],\"name\":\"RoundCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"option\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"RoundBetAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"option\",\"type\":\"address\"}],\"name\":\"RoundFinalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"}],\"name\":\"NewReferral\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"referrer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ReferralReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"AdminFeeUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"ReferrerFeeUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldMinBet\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newMinBet\",\"type\":\"uint256\"}],\"name\":\"MinBetUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ClashHash","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000cd0ba5c1a81782ed5c01e9959e6bfdb7e9344067","Library":"","SwarmSource":"bzzr://d7b0a9bb3763d1813b8eac112910f1367699099fcf9b3b3472c262d91a3267a6"}]}