{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\npragma experimental ABIEncoderV2;\r\n\r\n/*\r\n\r\n    Copyright 2018 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/external/0x/v2/libs/LibOrder.sol\r\n\r\ncontract LibOrder\r\n{\r\n    // A valid order remains fillable until it is expired, fully filled, or cancelled.\r\n    // An order's state is unaffected by external factors, like account balances.\r\n    enum OrderStatus {\r\n        INVALID,                     // Default value\r\n        INVALID_MAKER_ASSET_AMOUNT,  // Order does not have a valid maker asset amount\r\n        INVALID_TAKER_ASSET_AMOUNT,  // Order does not have a valid taker asset amount\r\n        FILLABLE,                    // Order is fillable\r\n        EXPIRED,                     // Order has already expired\r\n        FULLY_FILLED,                // Order is fully filled\r\n        CANCELLED                    // Order has been cancelled\r\n    }\r\n\r\n    struct Order {\r\n        address makerAddress;           // Address that created the order.\r\n        address takerAddress;           // Address that is allowed to fill the order. If set to 0, any address is allowed to fill the order.\r\n        address feeRecipientAddress;    // Address that will recieve fees when order is filled.\r\n        address senderAddress;          // Address that is allowed to call Exchange contract methods that affect this order. If set to 0, any address is allowed to call these methods.\r\n        uint256 makerAssetAmount;       // Amount of makerAsset being offered by maker. Must be greater than 0.\r\n        uint256 takerAssetAmount;       // Amount of takerAsset being bid on by maker. Must be greater than 0.\r\n        uint256 makerFee;               // Amount of ZRX paid to feeRecipient by maker when order is filled. If set to 0, no transfer of ZRX from maker to feeRecipient will be attempted.\r\n        uint256 takerFee;               // Amount of ZRX paid to feeRecipient by taker when order is filled. If set to 0, no transfer of ZRX from taker to feeRecipient will be attempted.\r\n        uint256 expirationTimeSeconds;  // Timestamp in seconds at which order expires.\r\n        uint256 salt;                   // Arbitrary number to facilitate uniqueness of the order's hash.\r\n        bytes makerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring makerAsset. The last byte references the id of this proxy.\r\n        bytes takerAssetData;           // Encoded data that can be decoded by a specified proxy contract when transferring takerAsset. The last byte references the id of this proxy.\r\n    }\r\n\r\n    struct OrderInfo {\r\n        uint8 orderStatus;                    // Status that describes order's validity and fillability.\r\n        bytes32 orderHash;                    // EIP712 hash of the order (see LibOrder.getOrderHash).\r\n        uint256 orderTakerAssetFilledAmount;  // Amount of order that has already been filled.\r\n    }\r\n}\r\n\r\n// File: contracts/external/0x/v2/libs/LibFillResults.sol\r\n\r\ncontract LibFillResults\r\n{\r\n    struct FillResults {\r\n        uint256 makerAssetFilledAmount;  // Total amount of makerAsset(s) filled.\r\n        uint256 takerAssetFilledAmount;  // Total amount of takerAsset(s) filled.\r\n        uint256 makerFeePaid;            // Total amount of ZRX paid by maker(s) to feeRecipient(s).\r\n        uint256 takerFeePaid;            // Total amount of ZRX paid by taker to feeRecipients(s).\r\n    }\r\n\r\n    struct MatchedFillResults {\r\n        FillResults left;                    // Amounts filled and fees paid of left order.\r\n        FillResults right;                   // Amounts filled and fees paid of right order.\r\n        uint256 leftMakerAssetSpreadAmount;  // Spread between price of left and right order, denominated in the left order's makerAsset, paid to taker.\r\n    }\r\n}\r\n\r\n// File: contracts/external/0x/v2/interfaces/IExchangeCore.sol\r\n\r\ncontract IExchangeCore {\r\n\r\n    /// @dev Cancels all orders created by makerAddress with a salt less than or equal to the targetOrderEpoch\r\n    ///      and senderAddress equal to msg.sender (or null address if msg.sender == makerAddress).\r\n    /// @param targetOrderEpoch Orders created with a salt less or equal to this value will be cancelled.\r\n    function cancelOrdersUpTo(uint256 targetOrderEpoch)\r\n        external;\r\n\r\n    /// @dev Fills the input order.\r\n    /// @param order Order struct containing order specifications.\r\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\r\n    /// @param signature Proof that order has been created by maker.\r\n    /// @return Amounts filled and fees paid by maker and taker.\r\n    function fillOrder(\r\n        LibOrder.Order memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory fillResults);\r\n\r\n    /// @dev After calling, the order can not be filled anymore.\r\n    /// @param order Order struct containing order specifications.\r\n    function cancelOrder(LibOrder.Order memory order)\r\n        public;\r\n\r\n    /// @dev Gets information about an order: status, hash, and amount filled.\r\n    /// @param order Order to gather information on.\r\n    /// @return OrderInfo Information about the order and its state.\r\n    ///                   See LibOrder.OrderInfo for a complete description.\r\n    function getOrderInfo(LibOrder.Order memory order)\r\n        public\r\n        view\r\n        returns (LibOrder.OrderInfo memory orderInfo);\r\n}\r\n\r\n// File: contracts/external/0x/v2/interfaces/IMatchOrders.sol\r\n\r\ncontract IMatchOrders {\r\n\r\n    /// @dev Match two complementary orders that have a profitable spread.\r\n    ///      Each order is filled at their respective price point. However, the calculations are\r\n    ///      carried out as though the orders are both being filled at the right order's price point.\r\n    ///      The profit made by the left order goes to the taker (who matched the two orders).\r\n    /// @param leftOrder First order to match.\r\n    /// @param rightOrder Second order to match.\r\n    /// @param leftSignature Proof that order was created by the left maker.\r\n    /// @param rightSignature Proof that order was created by the right maker.\r\n    /// @return matchedFillResults Amounts filled and fees paid by maker and taker of matched orders.\r\n    function matchOrders(\r\n        LibOrder.Order memory leftOrder,\r\n        LibOrder.Order memory rightOrder,\r\n        bytes memory leftSignature,\r\n        bytes memory rightSignature\r\n    )\r\n        public\r\n        returns (LibFillResults.MatchedFillResults memory matchedFillResults);\r\n}\r\n\r\n// File: contracts/external/0x/v2/interfaces/ISignatureValidator.sol\r\n\r\ncontract ISignatureValidator {\r\n\r\n    /// @dev Approves a hash on-chain using any valid signature type.\r\n    ///      After presigning a hash, the preSign signature type will become valid for that hash and signer.\r\n    /// @param signerAddress Address that should have signed the given hash.\r\n    /// @param signature Proof that the hash has been signed by signer.\r\n    function preSign(\r\n        bytes32 hash,\r\n        address signerAddress,\r\n        bytes signature\r\n    )\r\n        external;\r\n\r\n    /// @dev Approves/unnapproves a Validator contract to verify signatures on signer's behalf.\r\n    /// @param validatorAddress Address of Validator contract.\r\n    /// @param approval Approval or disapproval of  Validator contract.\r\n    function setSignatureValidatorApproval(\r\n        address validatorAddress,\r\n        bool approval\r\n    )\r\n        external;\r\n\r\n    /// @dev Verifies that a signature is valid.\r\n    /// @param hash Message hash that is signed.\r\n    /// @param signerAddress Address of signer.\r\n    /// @param signature Proof of signing.\r\n    /// @return Validity of order signature.\r\n    function isValidSignature(\r\n        bytes32 hash,\r\n        address signerAddress,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        view\r\n        returns (bool isValid);\r\n}\r\n\r\n// File: contracts/external/0x/v2/interfaces/ITransactions.sol\r\n\r\ncontract ITransactions {\r\n\r\n    /// @dev Executes an exchange method call in the context of signer.\r\n    /// @param salt Arbitrary number to ensure uniqueness of transaction hash.\r\n    /// @param signerAddress Address of transaction signer.\r\n    /// @param data AbiV2 encoded calldata.\r\n    /// @param signature Proof of signer transaction by signer.\r\n    function executeTransaction(\r\n        uint256 salt,\r\n        address signerAddress,\r\n        bytes data,\r\n        bytes signature\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/external/0x/v2/interfaces/IAssetProxyDispatcher.sol\r\n\r\ncontract IAssetProxyDispatcher {\r\n\r\n    /// @dev Registers an asset proxy to its asset proxy id.\r\n    ///      Once an asset proxy is registered, it cannot be unregistered.\r\n    /// @param assetProxy Address of new asset proxy to register.\r\n    function registerAssetProxy(address assetProxy)\r\n        external;\r\n\r\n    /// @dev Gets an asset proxy.\r\n    /// @param assetProxyId Id of the asset proxy.\r\n    /// @return The asset proxy registered to assetProxyId. Returns 0x0 if no proxy is registered.\r\n    function getAssetProxy(bytes4 assetProxyId)\r\n        external\r\n        view\r\n        returns (address);\r\n}\r\n\r\n// File: contracts/external/0x/v2/interfaces/IWrapperFunctions.sol\r\n\r\ncontract IWrapperFunctions {\r\n\r\n    /// @dev Fills the input order. Reverts if exact takerAssetFillAmount not filled.\r\n    /// @param order LibOrder.Order struct containing order specifications.\r\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\r\n    /// @param signature Proof that order has been created by maker.\r\n    function fillOrKillOrder(\r\n        LibOrder.Order memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory fillResults);\r\n\r\n    /// @dev Fills an order with specified parameters and ECDSA signature.\r\n    ///      Returns false if the transaction would otherwise revert.\r\n    /// @param order LibOrder.Order struct containing order specifications.\r\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\r\n    /// @param signature Proof that order has been created by maker.\r\n    /// @return Amounts filled and fees paid by maker and taker.\r\n    function fillOrderNoThrow(\r\n        LibOrder.Order memory order,\r\n        uint256 takerAssetFillAmount,\r\n        bytes memory signature\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory fillResults);\r\n\r\n    /// @dev Synchronously executes multiple calls of fillOrder.\r\n    /// @param orders Array of order specifications.\r\n    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\r\n    /// @param signatures Proofs that orders have been created by makers.\r\n    /// @return Amounts filled and fees paid by makers and taker.\r\n    function batchFillOrders(\r\n        LibOrder.Order[] memory orders,\r\n        uint256[] memory takerAssetFillAmounts,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory totalFillResults);\r\n\r\n    /// @dev Synchronously executes multiple calls of fillOrKill.\r\n    /// @param orders Array of order specifications.\r\n    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\r\n    /// @param signatures Proofs that orders have been created by makers.\r\n    /// @return Amounts filled and fees paid by makers and taker.\r\n    function batchFillOrKillOrders(\r\n        LibOrder.Order[] memory orders,\r\n        uint256[] memory takerAssetFillAmounts,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory totalFillResults);\r\n\r\n    /// @dev Fills an order with specified parameters and ECDSA signature.\r\n    ///      Returns false if the transaction would otherwise revert.\r\n    /// @param orders Array of order specifications.\r\n    /// @param takerAssetFillAmounts Array of desired amounts of takerAsset to sell in orders.\r\n    /// @param signatures Proofs that orders have been created by makers.\r\n    /// @return Amounts filled and fees paid by makers and taker.\r\n    function batchFillOrdersNoThrow(\r\n        LibOrder.Order[] memory orders,\r\n        uint256[] memory takerAssetFillAmounts,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory totalFillResults);\r\n\r\n    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\r\n    /// @param orders Array of order specifications.\r\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\r\n    /// @param signatures Proofs that orders have been created by makers.\r\n    /// @return Amounts filled and fees paid by makers and taker.\r\n    function marketSellOrders(\r\n        LibOrder.Order[] memory orders,\r\n        uint256 takerAssetFillAmount,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory totalFillResults);\r\n\r\n    /// @dev Synchronously executes multiple calls of fillOrder until total amount of takerAsset is sold by taker.\r\n    ///      Returns false if the transaction would otherwise revert.\r\n    /// @param orders Array of order specifications.\r\n    /// @param takerAssetFillAmount Desired amount of takerAsset to sell.\r\n    /// @param signatures Proofs that orders have been signed by makers.\r\n    /// @return Amounts filled and fees paid by makers and taker.\r\n    function marketSellOrdersNoThrow(\r\n        LibOrder.Order[] memory orders,\r\n        uint256 takerAssetFillAmount,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory totalFillResults);\r\n\r\n    /// @dev Synchronously executes multiple calls of fillOrder until total amount of makerAsset is bought by taker.\r\n    /// @param orders Array of order specifications.\r\n    /// @param makerAssetFillAmount Desired amount of makerAsset to buy.\r\n    /// @param signatures Proofs that orders have been signed by makers.\r\n    /// @return Amounts filled and fees paid by makers and taker.\r\n    function marketBuyOrders(\r\n        LibOrder.Order[] memory orders,\r\n        uint256 makerAssetFillAmount,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory totalFillResults);\r\n\r\n    /// @dev Synchronously executes multiple fill orders in a single transaction until total amount is bought by taker.\r\n    ///      Returns false if the transaction would otherwise revert.\r\n    /// @param orders Array of order specifications.\r\n    /// @param makerAssetFillAmount Desired amount of makerAsset to buy.\r\n    /// @param signatures Proofs that orders have been signed by makers.\r\n    /// @return Amounts filled and fees paid by makers and taker.\r\n    function marketBuyOrdersNoThrow(\r\n        LibOrder.Order[] memory orders,\r\n        uint256 makerAssetFillAmount,\r\n        bytes[] memory signatures\r\n    )\r\n        public\r\n        returns (LibFillResults.FillResults memory totalFillResults);\r\n\r\n    /// @dev Synchronously cancels multiple orders in a single transaction.\r\n    /// @param orders Array of order specifications.\r\n    function batchCancelOrders(LibOrder.Order[] memory orders)\r\n        public;\r\n\r\n    /// @dev Fetches information for all passed in orders\r\n    /// @param orders Array of order specifications.\r\n    /// @return Array of OrderInfo instances that correspond to each order.\r\n    function getOrdersInfo(LibOrder.Order[] memory orders)\r\n        public\r\n        view\r\n        returns (LibOrder.OrderInfo[] memory);\r\n}\r\n\r\n// File: contracts/external/0x/v2/interfaces/IExchange.sol\r\n\r\ncontract IExchange is\r\n    IExchangeCore,\r\n    IMatchOrders,\r\n    ISignatureValidator,\r\n    ITransactions,\r\n    IAssetProxyDispatcher,\r\n    IWrapperFunctions\r\n{}\r\n\r\n// File: contracts/lib/MathHelpers.sol\r\n\r\n/**\r\n * @title MathHelpers\r\n * @author dYdX\r\n *\r\n * This library helps with common math functions in Solidity\r\n */\r\nlibrary MathHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              target * numerator / denominator\r\n     */\r\n    function getPartialAmount(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return numerator.mul(target).div(denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              Rounded-up result of target * numerator / denominator\r\n     */\r\n    function getPartialAmountRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return divisionRoundedUp(numerator.mul(target), denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates division given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator.\r\n     * @param  denominator  Denominator.\r\n     * @return              Rounded-up result of numerator / denominator\r\n     */\r\n    function divisionRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(denominator != 0); // coverage-enable-line\r\n        if (numerator == 0) {\r\n            return 0;\r\n        }\r\n        return numerator.sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint256(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2 ** 256 - 1;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint32(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        return 2 ** 32 - 1;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\r\n     *\r\n     * @param  n  The uint256 to get the number of bits in\r\n     * @return    The number of bits in n\r\n     */\r\n    function getNumBits(\r\n        uint256 n\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 first = 0;\r\n        uint256 last = 256;\r\n        while (first < last) {\r\n            uint256 check = (first + last) / 2;\r\n            if ((n >> check) == 0) {\r\n                last = check;\r\n            } else {\r\n                first = check + 1;\r\n            }\r\n        }\r\n        assert(first <= 256);\r\n        return first;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/GeneralERC20.sol\r\n\r\n/**\r\n * @title GeneralERC20\r\n * @author dYdX\r\n *\r\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\r\n * that we dont automatically revert when calling non-compliant tokens that have no return value for\r\n * transfer(), transferFrom(), or approve().\r\n */\r\ninterface GeneralERC20 {\r\n    function totalSupply(\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address who\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/lib/TokenInteract.sol\r\n\r\n/**\r\n * @title TokenInteract\r\n * @author dYdX\r\n *\r\n * This library contains functions for interacting with ERC20 tokens\r\n */\r\nlibrary TokenInteract {\r\n    function balanceOf(\r\n        address token,\r\n        address owner\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GeneralERC20(token).balanceOf(owner);\r\n    }\r\n\r\n    function allowance(\r\n        address token,\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GeneralERC20(token).allowance(owner, spender);\r\n    }\r\n\r\n    function approve(\r\n        address token,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        GeneralERC20(token).approve(spender, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#approve: Approval failed\"\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        address from = address(this);\r\n        if (\r\n            amount == 0\r\n            || from == to\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        GeneralERC20(token).transfer(to, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#transfer: Transfer failed\"\r\n        );\r\n    }\r\n\r\n    function transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        if (\r\n            amount == 0\r\n            || from == to\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        GeneralERC20(token).transferFrom(from, to, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#transferFrom: TransferFrom failed\"\r\n        );\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\r\n     * function returned 0 bytes or 32 bytes that are not all-zero.\r\n     */\r\n    function checkSuccess(\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 returnValue = 0;\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            // check number of bytes returned from last function call\r\n            switch returndatasize\r\n\r\n            // no bytes returned: assume success\r\n            case 0x0 {\r\n                returnValue := 1\r\n            }\r\n\r\n            // 32 bytes returned: check if non-zero\r\n            case 0x20 {\r\n                // copy 32 bytes into scratch space\r\n                returndatacopy(0x0, 0x0, 0x20)\r\n\r\n                // load those bytes into returnValue\r\n                returnValue := mload(0x0)\r\n            }\r\n\r\n            // not sure what was returned: dont mark as success\r\n            default { }\r\n        }\r\n\r\n        return returnValue != 0;\r\n    }\r\n}\r\n\r\n// File: contracts/margin/interfaces/ExchangeReader.sol\r\n\r\n/**\r\n * @title ExchangeReader\r\n * @author dYdX\r\n *\r\n * Contract interface that wraps an exchange and provides information about the current state of the\r\n * exchange or particular orders\r\n */\r\ninterface ExchangeReader {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Get the maxmimum amount of makerToken for some order\r\n     *\r\n     * @param  makerToken           Address of makerToken, the token to receive\r\n     * @param  takerToken           Address of takerToken, the token to pay\r\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                      Maximum amount of makerToken\r\n     */\r\n    function getMaxMakerAmount(\r\n        address makerToken,\r\n        address takerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/margin/interfaces/ExchangeWrapper.sol\r\n\r\n/**\r\n * @title ExchangeWrapper\r\n * @author dYdX\r\n *\r\n * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\r\n * with other smart contracts through a common interface.\r\n */\r\ninterface ExchangeWrapper {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Exchange some amount of takerToken for makerToken.\r\n     *\r\n     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\r\n     *                              cannot always be trusted as it is set at the discretion of the\r\n     *                              msg.sender)\r\n     * @param  receiver             Address to set allowance on once the trade has completed\r\n     * @param  makerToken           Address of makerToken, the token to receive\r\n     * @param  takerToken           Address of takerToken, the token to pay\r\n     * @param  requestedFillAmount  Amount of takerToken being paid\r\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                      The amount of makerToken received\r\n     */\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes orderData\r\n    )\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\r\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\r\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\r\n     * than desiredMakerToken\r\n     *\r\n     * @param  makerToken         Address of makerToken, the token to receive\r\n     * @param  takerToken         Address of takerToken, the token to pay\r\n     * @param  desiredMakerToken  Amount of makerToken requested\r\n     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                    Amount of takerToken the needed to complete the transaction\r\n     */\r\n    function getExchangeCost(\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 desiredMakerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/margin/external/exchangewrappers/ZeroExV2ExchangeWrapper.sol\r\n\r\n/**\r\n * @title ZeroExV2ExchangeWrapper\r\n * @author dYdX\r\n *\r\n * dYdX ExchangeWrapper to interface with 0x Version 2\r\n */\r\ncontract ZeroExV2ExchangeWrapper is\r\n    LibFillResults,\r\n    LibOrder,\r\n    ExchangeWrapper,\r\n    ExchangeReader\r\n{\r\n    using SafeMath for uint256;\r\n    using TokenInteract for address;\r\n\r\n    // ============ State Variables ============\r\n\r\n    // msg.senders that will put the correct tradeOriginator in callerData when doing an exchange\r\n    mapping (address => bool) public TRUSTED_MSG_SENDER;\r\n\r\n    // address of the ZeroEx V2 Exchange\r\n    address public ZERO_EX_EXCHANGE;\r\n\r\n    // address of the ZeroEx V2 ERC20Proxy\r\n    address public ZERO_EX_TOKEN_PROXY;\r\n\r\n    // address of the ZRX token\r\n    address public ZRX;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address zeroExExchange,\r\n        address zeroExProxy,\r\n        address zrxToken,\r\n        address[] trustedMsgSenders\r\n    )\r\n        public\r\n    {\r\n        ZERO_EX_EXCHANGE = zeroExExchange;\r\n        ZERO_EX_TOKEN_PROXY = zeroExProxy;\r\n        ZRX = zrxToken;\r\n\r\n        for (uint256 i = 0; i < trustedMsgSenders.length; i++) {\r\n            TRUSTED_MSG_SENDER[trustedMsgSenders[i]] = true;\r\n        }\r\n\r\n        // The ZRX token does not decrement allowance if set to MAX_UINT\r\n        // therefore setting it once to the maximum amount is sufficient\r\n        // NOTE: this is *not* standard behavior for an ERC20, so do not rely on it for other tokens\r\n        ZRX.approve(ZERO_EX_TOKEN_PROXY, MathHelpers.maxUint256());\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes orderData\r\n    )\r\n        external\r\n        returns (uint256)\r\n    {\r\n        // prepare the exchange\r\n        Order memory order = parseOrder(orderData, makerToken, takerToken);\r\n        bytes memory signature = parseSignature(orderData);\r\n\r\n        // transfer ZRX fee from trader if applicable\r\n        transferTakerFee(\r\n            order,\r\n            tradeOriginator,\r\n            requestedFillAmount\r\n        );\r\n\r\n        // make sure that the exchange can take the tokens from this contract\r\n        ensureAllowance(\r\n            takerToken,\r\n            ZERO_EX_TOKEN_PROXY,\r\n            requestedFillAmount\r\n        );\r\n\r\n        // do the exchange\r\n        IExchange v2Exchange = IExchange(ZERO_EX_EXCHANGE);\r\n        FillResults memory fill = v2Exchange.fillOrKillOrder(order, requestedFillAmount, signature);\r\n\r\n        // validate results\r\n        assert(fill.takerAssetFilledAmount == requestedFillAmount);\r\n\r\n        // set allowance\r\n        ensureAllowance(makerToken, receiver, fill.makerAssetFilledAmount);\r\n\r\n        return fill.makerAssetFilledAmount;\r\n    }\r\n\r\n    function getExchangeCost(\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 desiredMakerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Order memory order = parseOrder(orderData, makerToken, takerToken);\r\n\r\n        return MathHelpers.getPartialAmountRoundedUp(\r\n            order.takerAssetAmount,\r\n            order.makerAssetAmount,\r\n            desiredMakerToken\r\n        );\r\n    }\r\n\r\n    function getMaxMakerAmount(\r\n        address makerToken,\r\n        address takerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Order memory order = parseOrder(orderData, makerToken, takerToken);\r\n        IExchange v2Exchange = IExchange(ZERO_EX_EXCHANGE);\r\n        OrderInfo memory orderInfo = v2Exchange.getOrderInfo(order);\r\n\r\n        if (orderInfo.orderStatus != uint8(OrderStatus.FILLABLE)) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 remainingTakerAssetAmount =\r\n            order.takerAssetAmount.sub(orderInfo.orderTakerAssetFilledAmount);\r\n\r\n        return MathHelpers.getPartialAmount(\r\n            remainingTakerAssetAmount,\r\n            order.takerAssetAmount,\r\n            order.makerAssetAmount\r\n        );\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function ensureAllowance(\r\n        address token,\r\n        address spender,\r\n        uint256 requiredAmount\r\n    )\r\n        private\r\n    {\r\n        if (token.allowance(address(this), spender) >= requiredAmount) {\r\n            return;\r\n        }\r\n\r\n        token.approve(\r\n            spender,\r\n            MathHelpers.maxUint256()\r\n        );\r\n    }\r\n\r\n    function transferTakerFee(\r\n        Order memory order,\r\n        address tradeOriginator,\r\n        uint256 requestedFillAmount\r\n    )\r\n        private\r\n    {\r\n        uint256 takerFee = MathHelpers.getPartialAmount(\r\n            requestedFillAmount,\r\n            order.takerAssetAmount,\r\n            order.takerFee\r\n        );\r\n\r\n        if (takerFee == 0) {\r\n            return;\r\n        }\r\n\r\n        require(\r\n            TRUSTED_MSG_SENDER[msg.sender],\r\n            \"ZeroExV2ExchangeWrapper#transferTakerFee: Only trusted senders can dictate the fee payer\"\r\n        );\r\n\r\n        ZRX.transferFrom(\r\n            tradeOriginator,\r\n            address(this),\r\n            takerFee\r\n        );\r\n    }\r\n\r\n    function parseSignature(\r\n        bytes orderData\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes memory)\r\n    {\r\n        bytes memory signature = new bytes(66);\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            mstore(add(signature, 32), mload(add(orderData, 352)))  // first 32 bytes\r\n            mstore(add(signature, 64), mload(add(orderData, 384)))  // next 32 bytes\r\n            mstore(add(signature, 66), mload(add(orderData, 386)))  // last 2 bytes\r\n        }\r\n\r\n        return signature;\r\n    }\r\n\r\n    function parseOrder(\r\n        bytes orderData,\r\n        address makerToken,\r\n        address takerToken\r\n    )\r\n        private\r\n        pure\r\n        returns (Order memory)\r\n    {\r\n        Order memory order;\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            mstore(order,           mload(add(orderData, 32)))  // makerAddress\r\n            mstore(add(order, 32),  mload(add(orderData, 64)))  // takerAddress\r\n            mstore(add(order, 64),  mload(add(orderData, 96)))  // feeRecipientAddress\r\n            mstore(add(order, 96),  mload(add(orderData, 128))) // senderAddress\r\n            mstore(add(order, 128), mload(add(orderData, 160))) // makerAssetAmount\r\n            mstore(add(order, 160), mload(add(orderData, 192))) // takerAssetAmount\r\n            mstore(add(order, 192), mload(add(orderData, 224))) // makerFee\r\n            mstore(add(order, 224), mload(add(orderData, 256))) // takerFee\r\n            mstore(add(order, 256), mload(add(orderData, 288))) // expirationTimeSeconds\r\n            mstore(add(order, 288), mload(add(orderData, 320))) // salt\r\n        }\r\n\r\n        order.makerAssetData = tokenAddressToAssetData(makerToken);\r\n        order.takerAssetData = tokenAddressToAssetData(takerToken);\r\n\r\n        return order;\r\n    }\r\n\r\n    function tokenAddressToAssetData(\r\n        address tokenAddress\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes)\r\n    {\r\n        bytes memory result = new bytes(36);\r\n\r\n        // padded version of bytes4(keccak256(\"ERC20Token(address)\"));\r\n        bytes32 selector = 0xf47261b000000000000000000000000000000000000000000000000000000000;\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            // Store the selector and address in the asset data\r\n            // The first 32 bytes of an array are the length (already set above)\r\n            mstore(add(result, 32), selector)\r\n            mstore(add(result, 36), tokenAddress)\r\n        }\r\n\r\n        return result;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"desiredMakerToken\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"getExchangeCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"getMaxMakerAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_EX_EXCHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeOriginator\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"requestedFillAmount\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_EX_TOKEN_PROXY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZRX\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"TRUSTED_MSG_SENDER\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"zeroExExchange\",\"type\":\"address\"},{\"name\":\"zeroExProxy\",\"type\":\"address\"},{\"name\":\"zrxToken\",\"type\":\"address\"},{\"name\":\"trustedMsgSenders\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ZeroExV2ExchangeWrapper","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"0000000000000000000000004f833a24e1f95d70f028921e27040ca56e09ab0b0000000000000000000000002240dab907db71e64d3e0dba4800c83b5c502d4e000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f4980000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000100000000000000000000000036bf21c8e661b21e6166e4385f574941fdc6caff","Library":"","SwarmSource":"bzzr://e1ee8fa45b2f074f24a7263a7347b75d19fbaa5d37cdf73a82e8b3cd5c13e543"}]}