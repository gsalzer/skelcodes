{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: Multiownable/contracts/Multiownable.sol\r\n\r\ncontract Multiownable {\r\n\r\n    // VARIABLES\r\n\r\n    uint256 public ownersGeneration;\r\n    uint256 public howManyOwnersDecide;\r\n    address[] public owners;\r\n    bytes32[] public allOperations;\r\n    address internal insideCallSender;\r\n    uint256 internal insideCallCount;\r\n\r\n    // Reverse lookup tables for owners and allOperations\r\n    mapping(address => uint) public ownersIndices; // Starts from 1\r\n    mapping(bytes32 => uint) public allOperationsIndicies;\r\n\r\n    // Owners voting mask per operations\r\n    mapping(bytes32 => uint256) public votesMaskByOperation;\r\n    mapping(bytes32 => uint256) public votesCountByOperation;\r\n\r\n    // EVENTS\r\n\r\n    event OwnershipTransferred(address[] previousOwners, uint howManyOwnersDecide, address[] newOwners, uint newHowManyOwnersDecide);\r\n    event OperationCreated(bytes32 operation, uint howMany, uint ownersCount, address proposer);\r\n    event OperationUpvoted(bytes32 operation, uint votes, uint howMany, uint ownersCount, address upvoter);\r\n    event OperationPerformed(bytes32 operation, uint howMany, uint ownersCount, address performer);\r\n    event OperationDownvoted(bytes32 operation, uint votes, uint ownersCount,  address downvoter);\r\n    event OperationCancelled(bytes32 operation, address lastCanceller);\r\n    \r\n    // ACCESSORS\r\n\r\n    function isOwner(address wallet) public constant returns(bool) {\r\n        return ownersIndices[wallet] > 0;\r\n    }\r\n\r\n    function ownersCount() public constant returns(uint) {\r\n        return owners.length;\r\n    }\r\n\r\n    function allOperationsCount() public constant returns(uint) {\r\n        return allOperations.length;\r\n    }\r\n\r\n    // MODIFIERS\r\n\r\n    /**\r\n    * @dev Allows to perform method by any of the owners\r\n    */\r\n    modifier onlyAnyOwner {\r\n        if (checkHowManyOwners(1)) {\r\n            bool update = (insideCallSender == address(0));\r\n            if (update) {\r\n                insideCallSender = msg.sender;\r\n                insideCallCount = 1;\r\n            }\r\n            _;\r\n            if (update) {\r\n                insideCallSender = address(0);\r\n                insideCallCount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows to perform method only after many owners call it with the same arguments\r\n    */\r\n    modifier onlyManyOwners {\r\n        if (checkHowManyOwners(howManyOwnersDecide)) {\r\n            bool update = (insideCallSender == address(0));\r\n            if (update) {\r\n                insideCallSender = msg.sender;\r\n                insideCallCount = howManyOwnersDecide;\r\n            }\r\n            _;\r\n            if (update) {\r\n                insideCallSender = address(0);\r\n                insideCallCount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows to perform method only after all owners call it with the same arguments\r\n    */\r\n    modifier onlyAllOwners {\r\n        if (checkHowManyOwners(owners.length)) {\r\n            bool update = (insideCallSender == address(0));\r\n            if (update) {\r\n                insideCallSender = msg.sender;\r\n                insideCallCount = owners.length;\r\n            }\r\n            _;\r\n            if (update) {\r\n                insideCallSender = address(0);\r\n                insideCallCount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows to perform method only after some owners call it with the same arguments\r\n    */\r\n    modifier onlySomeOwners(uint howMany) {\r\n        require(howMany > 0, \"onlySomeOwners: howMany argument is zero\");\r\n        require(howMany <= owners.length, \"onlySomeOwners: howMany argument exceeds the number of owners\");\r\n        \r\n        if (checkHowManyOwners(howMany)) {\r\n            bool update = (insideCallSender == address(0));\r\n            if (update) {\r\n                insideCallSender = msg.sender;\r\n                insideCallCount = howMany;\r\n            }\r\n            _;\r\n            if (update) {\r\n                insideCallSender = address(0);\r\n                insideCallCount = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    // CONSTRUCTOR\r\n\r\n    constructor() public {\r\n        owners.push(msg.sender);\r\n        ownersIndices[msg.sender] = 1;\r\n        howManyOwnersDecide = 1;\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n\r\n    /**\r\n     * @dev onlyManyOwners modifier helper\r\n     */\r\n    function checkHowManyOwners(uint howMany) internal returns(bool) {\r\n        if (insideCallSender == msg.sender) {\r\n            require(howMany <= insideCallCount, \"checkHowManyOwners: nested owners modifier check require more owners\");\r\n            return true;\r\n        }\r\n\r\n        uint ownerIndex = ownersIndices[msg.sender] - 1;\r\n        require(ownerIndex < owners.length, \"checkHowManyOwners: msg.sender is not an owner\");\r\n        bytes32 operation = keccak256(msg.data, ownersGeneration);\r\n\r\n        require((votesMaskByOperation[operation] & (2 ** ownerIndex)) == 0, \"checkHowManyOwners: owner already voted for the operation\");\r\n        votesMaskByOperation[operation] |= (2 ** ownerIndex);\r\n        uint operationVotesCount = votesCountByOperation[operation] + 1;\r\n        votesCountByOperation[operation] = operationVotesCount;\r\n        if (operationVotesCount == 1) {\r\n            allOperationsIndicies[operation] = allOperations.length;\r\n            allOperations.push(operation);\r\n            emit OperationCreated(operation, howMany, owners.length, msg.sender);\r\n        }\r\n        emit OperationUpvoted(operation, operationVotesCount, howMany, owners.length, msg.sender);\r\n\r\n        // If enough owners confirmed the same operation\r\n        if (votesCountByOperation[operation] == howMany) {\r\n            deleteOperation(operation);\r\n            emit OperationPerformed(operation, howMany, owners.length, msg.sender);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * @dev Used to delete cancelled or performed operation\r\n    * @param operation defines which operation to delete\r\n    */\r\n    function deleteOperation(bytes32 operation) internal {\r\n        uint index = allOperationsIndicies[operation];\r\n        if (index < allOperations.length - 1) { // Not last\r\n            allOperations[index] = allOperations[allOperations.length - 1];\r\n            allOperationsIndicies[allOperations[index]] = index;\r\n        }\r\n        allOperations.length--;\r\n\r\n        delete votesMaskByOperation[operation];\r\n        delete votesCountByOperation[operation];\r\n        delete allOperationsIndicies[operation];\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n\r\n    /**\r\n    * @dev Allows owners to change their mind by cacnelling votesMaskByOperation operations\r\n    * @param operation defines which operation to delete\r\n    */\r\n    function cancelPending(bytes32 operation) public onlyAnyOwner {\r\n        uint ownerIndex = ownersIndices[msg.sender] - 1;\r\n        require((votesMaskByOperation[operation] & (2 ** ownerIndex)) != 0, \"cancelPending: operation not found for this user\");\r\n        votesMaskByOperation[operation] &= ~(2 ** ownerIndex);\r\n        uint operationVotesCount = votesCountByOperation[operation] - 1;\r\n        votesCountByOperation[operation] = operationVotesCount;\r\n        emit OperationDownvoted(operation, operationVotesCount, owners.length, msg.sender);\r\n        if (operationVotesCount == 0) {\r\n            deleteOperation(operation);\r\n            emit OperationCancelled(operation, msg.sender);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Allows owners to change ownership\r\n    * @param newOwners defines array of addresses of new owners\r\n    */\r\n    function transferOwnership(address[] newOwners) public {\r\n        transferOwnershipWithHowMany(newOwners, newOwners.length);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows owners to change ownership\r\n    * @param newOwners defines array of addresses of new owners\r\n    * @param newHowManyOwnersDecide defines how many owners can decide\r\n    */\r\n    function transferOwnershipWithHowMany(address[] newOwners, uint256 newHowManyOwnersDecide) public onlyManyOwners {\r\n        require(newOwners.length > 0, \"transferOwnershipWithHowMany: owners array is empty\");\r\n        require(newOwners.length <= 256, \"transferOwnershipWithHowMany: owners count is greater then 256\");\r\n        require(newHowManyOwnersDecide > 0, \"transferOwnershipWithHowMany: newHowManyOwnersDecide equal to 0\");\r\n        require(newHowManyOwnersDecide <= newOwners.length, \"transferOwnershipWithHowMany: newHowManyOwnersDecide exceeds the number of owners\");\r\n\r\n        // Reset owners reverse lookup table\r\n        for (uint j = 0; j < owners.length; j++) {\r\n            delete ownersIndices[owners[j]];\r\n        }\r\n        for (uint i = 0; i < newOwners.length; i++) {\r\n            require(newOwners[i] != address(0), \"transferOwnershipWithHowMany: owners array contains zero\");\r\n            require(ownersIndices[newOwners[i]] == 0, \"transferOwnershipWithHowMany: owners array contains duplicates\");\r\n            ownersIndices[newOwners[i]] = i + 1;\r\n        }\r\n        \r\n        emit OwnershipTransferred(owners, howManyOwnersDecide, newOwners, newHowManyOwnersDecide);\r\n        owners = newOwners;\r\n        howManyOwnersDecide = newHowManyOwnersDecide;\r\n        allOperations.length = 0;\r\n        ownersGeneration++;\r\n    }\r\n\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/BadERC20Aware.sol\r\n\r\nlibrary BadERC20Aware {\r\n    using SafeMath for uint;\r\n\r\n    function isContract(address addr) internal view returns(bool result) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            result := gt(extcodesize(addr), 0)\r\n        }\r\n    }\r\n\r\n    function handleReturnBool() internal pure returns(bool result) {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            switch returndatasize()\r\n            case 0 { // not a std erc20\r\n                result := 1\r\n            }\r\n            case 32 { // std erc20\r\n                returndatacopy(0, 0, 32)\r\n                result := mload(0)\r\n            }\r\n            default { // anything else, should revert for safety\r\n                revert(0, 0)\r\n            }\r\n        }\r\n    }\r\n\r\n    function asmTransfer(ERC20 _token, address _to, uint256 _value) internal returns(bool) {\r\n        require(isContract(_token));\r\n        // solium-disable-next-line security/no-low-level-calls\r\n        require(address(_token).call(bytes4(keccak256(\"transfer(address,uint256)\")), _to, _value));\r\n        return handleReturnBool();\r\n    }\r\n\r\n    function safeTransfer(ERC20 _token, address _to, uint256 _value) internal {\r\n        require(asmTransfer(_token, _to, _value));\r\n    }\r\n}\r\n\r\n// File: contracts/TokenSwap.sol\r\n\r\n/**\r\n * @title TokenSwap\r\n * This product is protected under license.  Any unauthorized copy, modification, or use without\r\n * express written consent from the creators is prohibited.\r\n */\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract TokenSwap is Ownable, Multiownable {\r\n\r\n    // LIBRARIES\r\n\r\n    using BadERC20Aware for ERC20;\r\n    using SafeMath for uint256;\r\n\r\n    // TYPES\r\n\r\n    enum Status {AddParties, WaitingDeposits, SwapConfirmed, SwapCanceled}\r\n\r\n    struct SwapOffer {\r\n        address participant;\r\n        ERC20 token;\r\n\r\n        uint256 tokensForSwap;\r\n        uint256 withdrawnTokensForSwap;\r\n\r\n        uint256 tokensFee;\r\n        uint256 withdrawnFee;\r\n\r\n        uint256 tokensTotal;\r\n        uint256 withdrawnTokensTotal;\r\n    }\r\n\r\n    struct LockupStage {\r\n        uint256 secondsSinceLockupStart;\r\n        uint8 unlockedTokensPercentage;\r\n    }\r\n\r\n    // VARIABLES\r\n    Status public status = Status.AddParties;\r\n\r\n    uint256 internal startLockupAt;\r\n    LockupStage[] internal lockupStages;\r\n\r\n    address[] internal participants;\r\n    mapping(address => bool) internal isParticipant;\r\n    mapping(address => address) internal tokenByParticipant;\r\n    mapping(address => SwapOffer) internal offerByToken;\r\n\r\n    // EVENTS\r\n    event AddLockupStage(uint256 secondsSinceLockupStart, uint8 unlockedTokensPercentage);\r\n    event StatusUpdate(Status oldStatus, Status newStatus);\r\n    event AddParty(address participant, ERC20 token, uint256 amount);\r\n    event RemoveParty(address participant);\r\n    event ConfirmParties();\r\n    event CancelSwap();\r\n    event ConfirmSwap();\r\n    event StartLockup(uint256 startLockupAt);\r\n    event Withdraw(address participant, ERC20 token, uint256 amount);\r\n    event WithdrawFee(ERC20 token, uint256 amount);\r\n    event Reclaim(address participant, ERC20 token, uint256 amount);\r\n\r\n    // MODIFIERS\r\n    modifier onlyParticipant {\r\n        require(\r\n            isParticipant[msg.sender] == true,\r\n            \"Only swap participants allowed to call the method\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canAddParty {\r\n        require(status == Status.AddParties, \"Unable to add new parties in the current status\");\r\n        _;\r\n    }\r\n\r\n    modifier canRemoveParty {\r\n        require(status == Status.AddParties, \"Unable to remove parties in the current status\");\r\n        _;\r\n    }\r\n\r\n    modifier canConfirmParties {\r\n        require(\r\n            status == Status.AddParties,\r\n            \"Unable to confirm parties in the current status\"\r\n        );\r\n        require(participants.length > 1, \"Need at least two participants\");\r\n        _;\r\n    }\r\n\r\n    modifier canCancelSwap {\r\n        require(\r\n            status == Status.WaitingDeposits,\r\n            \"Unable to cancel swap in the current status\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canConfirmSwap {\r\n        require(status == Status.WaitingDeposits, \"Unable to confirm in the current status\");\r\n        require(\r\n            _haveEveryoneDeposited(),\r\n            \"Unable to confirm swap before all parties have deposited tokens\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    modifier canWithdraw {\r\n        require(status == Status.SwapConfirmed, \"Unable to withdraw tokens in the current status\");\r\n        require(startLockupAt != 0, \"Lockup has not been started\");\r\n        _;\r\n    }\r\n\r\n    modifier canWithdrawFee {\r\n        require(status == Status.SwapConfirmed, \"Unable to withdraw fee in the current status\");\r\n        require(startLockupAt != 0, \"Lockup has not been started\");\r\n        _;\r\n    }\r\n\r\n    modifier canReclaim {\r\n        require(\r\n            status == Status.SwapConfirmed || status == Status.SwapCanceled,\r\n            \"Unable to reclaim in the current status\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // CONSTRUCTOR\r\n    constructor() public {\r\n        _initializeLockupStages();\r\n        _validateLockupStages();\r\n    }\r\n\r\n    // EXTERNAL METHODS\r\n    /**\r\n     * @dev Add new party to the swap.\r\n     * @param _participant Address of the participant.\r\n     * @param _token An ERC20-compliant token which participant is offering to swap.\r\n     * @param _tokensForSwap How much tokens the participant wants to swap.\r\n     * @param _tokensFee How much tokens will be payed as a fee.\r\n     * @param _tokensTotal How much tokens the participant is offering (i.e. _tokensForSwap + _tokensFee).\r\n     */\r\n    function addParty(\r\n        address _participant,\r\n        ERC20 _token,\r\n        uint256 _tokensForSwap,\r\n        uint256 _tokensFee,\r\n        uint256 _tokensTotal\r\n    )\r\n        external\r\n        onlyOwner\r\n        canAddParty\r\n    {\r\n        require(_participant != address(0), \"_participant is invalid address\");\r\n        require(_token != address(0), \"_token is invalid address\");\r\n        require(_tokensForSwap > 0, \"_tokensForSwap must be positive\");\r\n        require(_tokensFee > 0, \"_tokensFee must be positive\");\r\n        require(_tokensTotal == _tokensForSwap.add(_tokensFee), \"token amounts inconsistency\");\r\n        require(\r\n            isParticipant[_participant] == false,\r\n            \"Unable to add the same party multiple times\"\r\n        );\r\n\r\n        isParticipant[_participant] = true;\r\n        SwapOffer memory offer = SwapOffer({\r\n            participant: _participant,\r\n            token: _token,\r\n            tokensForSwap: _tokensForSwap,\r\n            withdrawnTokensForSwap: 0,\r\n            tokensFee: _tokensFee,\r\n            withdrawnFee: 0,\r\n            tokensTotal: _tokensTotal,\r\n            withdrawnTokensTotal: 0\r\n        });\r\n        participants.push(offer.participant);\r\n        offerByToken[offer.token] = offer;\r\n        tokenByParticipant[offer.participant] = offer.token;\r\n\r\n        emit AddParty(offer.participant, offer.token, offer.tokensTotal);\r\n    }\r\n\r\n    /**\r\n     * @dev Remove party.\r\n     * @param _participantIndex Index of the participant in the participants array.\r\n     */\r\n    function removeParty(uint256 _participantIndex) external onlyOwner canRemoveParty {\r\n        require(_participantIndex < participants.length, \"Participant does not exist\");\r\n\r\n        address participant = participants[_participantIndex];\r\n        address token = tokenByParticipant[participant];\r\n\r\n        delete isParticipant[participant];\r\n        participants[_participantIndex] = participants[participants.length - 1];\r\n        participants.length--;\r\n        delete offerByToken[token];\r\n        delete tokenByParticipant[participant];\r\n\r\n        emit RemoveParty(participant);\r\n    }\r\n\r\n    /**\r\n     * @dev Confirm swap parties\r\n     */\r\n    function confirmParties() external onlyOwner canConfirmParties {\r\n        address[] memory newOwners = new address[](participants.length + 1);\r\n\r\n        for (uint256 i = 0; i < participants.length; i++) {\r\n            newOwners[i] = participants[i];\r\n        }\r\n\r\n        newOwners[newOwners.length - 1] = owner;\r\n        transferOwnershipWithHowMany(newOwners, newOwners.length - 1);\r\n        _changeStatus(Status.WaitingDeposits);\r\n        emit ConfirmParties();\r\n    }\r\n\r\n    /**\r\n     * @dev Confirm swap.\r\n     */\r\n    function confirmSwap() external canConfirmSwap onlyManyOwners {\r\n        emit ConfirmSwap();\r\n        _changeStatus(Status.SwapConfirmed);\r\n        _startLockup();\r\n    }\r\n\r\n    /**\r\n     * @dev Cancel swap.\r\n     */\r\n    function cancelSwap() external canCancelSwap onlyManyOwners {\r\n        emit CancelSwap();\r\n        _changeStatus(Status.SwapCanceled);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw tokens\r\n     */\r\n    function withdraw() external onlyParticipant canWithdraw {\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address token = tokenByParticipant[participants[i]];\r\n            SwapOffer storage offer = offerByToken[token];\r\n\r\n            if (offer.participant == msg.sender) {\r\n                continue;\r\n            }\r\n\r\n            uint256 tokenReceivers = participants.length - 1;\r\n            uint256 tokensAmount = _withdrawableAmount(offer).div(tokenReceivers);\r\n\r\n            offer.token.safeTransfer(msg.sender, tokensAmount);\r\n            emit Withdraw(msg.sender, offer.token, tokensAmount);\r\n            offer.withdrawnTokensForSwap = offer.withdrawnTokensForSwap.add(tokensAmount);\r\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw swap fee\r\n     */\r\n    function withdrawFee() external onlyOwner canWithdrawFee {\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address token = tokenByParticipant[participants[i]];\r\n            SwapOffer storage offer = offerByToken[token];\r\n\r\n            uint256 tokensAmount = _withdrawableFee(offer);\r\n\r\n            offer.token.safeTransfer(msg.sender, tokensAmount);\r\n            emit WithdrawFee(offer.token, tokensAmount);\r\n            offer.withdrawnFee = offer.withdrawnFee.add(tokensAmount);\r\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Reclaim tokens if a participant has deposited too much or if the swap has been canceled.\r\n     */\r\n    function reclaim() external onlyParticipant canReclaim {\r\n        address token = tokenByParticipant[msg.sender];\r\n\r\n        SwapOffer storage offer = offerByToken[token];\r\n        uint256 currentBalance = offer.token.balanceOf(address(this));\r\n        uint256 availableForReclaim = currentBalance\r\n            .sub(offer.tokensTotal.sub(offer.withdrawnTokensTotal));\r\n\r\n        if (status == Status.SwapCanceled) {\r\n            availableForReclaim = currentBalance;\r\n        }\r\n\r\n        if (availableForReclaim > 0) {\r\n            offer.token.safeTransfer(offer.participant, availableForReclaim);\r\n        }\r\n\r\n        emit Reclaim(offer.participant, offer.token, availableForReclaim);\r\n    }\r\n\r\n    // PUBLIC METHODS\r\n    /**\r\n     * @dev Standard ERC223 function that will handle incoming token transfers.\r\n     *\r\n     * @param _from  Token sender address.\r\n     * @param _value Amount of tokens.\r\n     * @param _data  Transaction metadata.\r\n     */\r\n    function tokenFallback(address _from, uint256 _value, bytes _data) public {\r\n\r\n    }\r\n\r\n    // INTERNAL METHODS\r\n    /**\r\n     * @dev Initialize lockup period stages.\r\n     */\r\n    function _initializeLockupStages() internal {\r\n        _addLockupStage(LockupStage(0, 33));\r\n        _addLockupStage(LockupStage(180 days, 66));\r\n        _addLockupStage(LockupStage(360 days, 100));\r\n    }\r\n\r\n    /**\r\n     * @dev Add lockup period stage\r\n     */\r\n    function _addLockupStage(LockupStage _stage) internal {\r\n        emit AddLockupStage(_stage.secondsSinceLockupStart, _stage.unlockedTokensPercentage);\r\n        lockupStages.push(_stage);\r\n    }\r\n\r\n    /**\r\n     * @dev Validate lock-up period configuration.\r\n     */\r\n    function _validateLockupStages() internal view {\r\n        for (uint i = 0; i < lockupStages.length; i++) {\r\n            LockupStage memory stage = lockupStages[i];\r\n\r\n            require(\r\n                stage.unlockedTokensPercentage >= 0,\r\n                \"LockupStage.unlockedTokensPercentage must not be negative\"\r\n            );\r\n            require(\r\n                stage.unlockedTokensPercentage <= 100,\r\n                \"LockupStage.unlockedTokensPercentage must not be greater than 100\"\r\n            );\r\n\r\n            if (i == 0) {\r\n                continue;\r\n            }\r\n\r\n            LockupStage memory previousStage = lockupStages[i - 1];\r\n            require(\r\n                stage.secondsSinceLockupStart > previousStage.secondsSinceLockupStart,\r\n                \"LockupStage.secondsSinceLockupStart must increase monotonically\"\r\n            );\r\n            require(\r\n                stage.unlockedTokensPercentage > previousStage.unlockedTokensPercentage,\r\n                \"LockupStage.unlockedTokensPercentage must increase monotonically\"\r\n            );\r\n        }\r\n\r\n        require(\r\n            lockupStages[0].secondsSinceLockupStart == 0,\r\n            \"The first lockup stage must start immediately\"\r\n        );\r\n        require(\r\n            lockupStages[lockupStages.length - 1].unlockedTokensPercentage == 100,\r\n            \"The last lockup stage must unlock 100% of tokens\"\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @dev Change swap status.\r\n     */\r\n    function _changeStatus(Status _newStatus) internal {\r\n        emit StatusUpdate(status, _newStatus);\r\n        status = _newStatus;\r\n    }\r\n\r\n    /**\r\n     * @dev Check whether every participant has deposited enough tokens for the swap to be confirmed.\r\n     */\r\n    function _haveEveryoneDeposited() internal view returns(bool) {\r\n        for (uint i = 0; i < participants.length; i++) {\r\n            address token = tokenByParticipant[participants[i]];\r\n            SwapOffer memory offer = offerByToken[token];\r\n\r\n            if (offer.token.balanceOf(address(this)) < offer.tokensTotal) {\r\n                return false;\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Start lockup period\r\n     */\r\n    function _startLockup() internal {\r\n        startLockupAt = now;\r\n        emit StartLockup(startLockupAt);\r\n    }\r\n\r\n    /**\r\n     * @dev Find amount of tokens ready to be withdrawn by a swap party.\r\n     */\r\n    function _withdrawableAmount(SwapOffer _offer) internal view returns(uint256) {\r\n        return _unlockedAmount(_offer.tokensForSwap).sub(_offer.withdrawnTokensForSwap);\r\n    }\r\n\r\n    /**\r\n     * @dev Find amount of tokens ready to be withdrawn as the swap fee.\r\n     */\r\n    function _withdrawableFee(SwapOffer _offer) internal view returns(uint256) {\r\n        return _unlockedAmount(_offer.tokensFee).sub(_offer.withdrawnFee);\r\n    }\r\n\r\n    /**\r\n     * @dev Find amount of unlocked tokens, including withdrawn tokens.\r\n     */\r\n    function _unlockedAmount(uint256 totalAmount) internal view returns(uint256) {\r\n        return totalAmount.mul(_getUnlockedTokensPercentage()).div(100);\r\n    }\r\n\r\n    /**\r\n     * @dev Get percent of unlocked tokens\r\n     */\r\n    function _getUnlockedTokensPercentage() internal view returns(uint256) {\r\n        for (uint256 i = lockupStages.length; i > 0; i--) {\r\n            LockupStage storage stage = lockupStages[i - 1];\r\n            uint256 stageBecomesActiveAt = startLockupAt.add(stage.secondsSinceLockupStart);\r\n\r\n            if (now < stageBecomesActiveAt) {\r\n                continue;\r\n            }\r\n\r\n            return stage.unlockedTokensPercentage;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwners\",\"type\":\"address[]\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participantIndex\",\"type\":\"uint256\"}],\"name\":\"removeParty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allOperationsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"howManyOwnersDecide\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"allOperations\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"votesMaskByOperation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmParties\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"operation\",\"type\":\"bytes32\"}],\"name\":\"cancelPending\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"votesCountByOperation\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersGeneration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownersCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"confirmSwap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ownersIndices\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_participant\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_tokensForSwap\",\"type\":\"uint256\"},{\"name\":\"_tokensFee\",\"type\":\"uint256\"},{\"name\":\"_tokensTotal\",\"type\":\"uint256\"}],\"name\":\"addParty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwners\",\"type\":\"address[]\"},{\"name\":\"newHowManyOwnersDecide\",\"type\":\"uint256\"}],\"name\":\"transferOwnershipWithHowMany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"allOperationsIndicies\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"secondsSinceLockupStart\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unlockedTokensPercentage\",\"type\":\"uint8\"}],\"name\":\"AddLockupStage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldStatus\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"newStatus\",\"type\":\"uint8\"}],\"name\":\"StatusUpdate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AddParty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"}],\"name\":\"RemoveParty\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ConfirmParties\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"CancelSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"ConfirmSwap\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"startLockupAt\",\"type\":\"uint256\"}],\"name\":\"StartLockup\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"participant\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Reclaim\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"howManyOwnersDecide\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newOwners\",\"type\":\"address[]\"},{\"indexed\":false,\"name\":\"newHowManyOwnersDecide\",\"type\":\"uint256\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"proposer\",\"type\":\"address\"}],\"name\":\"OperationCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"upvoter\",\"type\":\"address\"}],\"name\":\"OperationUpvoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"howMany\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"performer\",\"type\":\"address\"}],\"name\":\"OperationPerformed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"votes\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ownersCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"downvoter\",\"type\":\"address\"}],\"name\":\"OperationDownvoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"operation\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"lastCanceller\",\"type\":\"address\"}],\"name\":\"OperationCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenSwap","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ef0fe5836036b6edacf5637f491edc03b0d7e0fe60b9f6d4bb7ab8b1d844691f"}]}