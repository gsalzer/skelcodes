{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n/*\r\n\r\nThis is a token wallet contract\r\n\r\nStore your tokens in this contract to give them super powers\r\n\r\nTokens can be spent from the contract with only an ecSignature from the owner - onchain approve is not needed\r\n\r\n\r\n*/\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint);\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\ncontract ERC918Interface {\r\n  function totalSupply() public constant returns (uint);\r\n  function getMiningDifficulty() public constant returns (uint);\r\n  function getMiningTarget() public constant returns (uint);\r\n  function getMiningReward() public constant returns (uint);\r\n  function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n\r\n  function mint(uint256 nonce, bytes32 challenge_digest) public returns (bool success);\r\n\r\n  event Mint(address indexed from, uint reward_amount, uint epochCount, bytes32 newChallengeNumber);\r\n\r\n}\r\n\r\ncontract MiningKingInterface {\r\n    function getMiningKing() public returns (address);\r\n    function transferKing(address newKing) public;\r\n    function mint(uint256 nonce, bytes32 challenge_digest) returns (bool);\r\n\r\n    event TransferKing(address from, address to);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract LavaWallet {\r\n\r\n\r\n  using SafeMath for uint;\r\n\r\n  // balances[tokenContractAddress][EthereumAccountAddress] = 0\r\n   mapping(address => mapping (address => uint256)) balances;\r\n\r\n   //token => owner => spender : amount\r\n   mapping(address => mapping (address => mapping (address => uint256))) allowed;\r\n\r\n   //mapping(address => uint256) depositedTokens;\r\n\r\n   mapping(bytes32 => uint256) burnedSignatures;\r\n\r\n   address relayKingContract;\r\n\r\n  event Deposit(address token, address user, uint amount, uint balance);\r\n  event Withdraw(address token, address user, uint amount, uint balance);\r\n  event Transfer(address indexed from, address indexed to,address token, uint tokens);\r\n  event Approval(address indexed tokenOwner, address indexed spender,address token, uint tokens);\r\n\r\n  function LavaWallet(address relayKingContractAddress ) public  {\r\n    relayKingContract = relayKingContractAddress;\r\n  }\r\n\r\n\r\n  //do not allow ether to enter\r\n  function() public payable {\r\n      revert();\r\n  }\r\n\r\n\r\n   //Remember you need pre-approval for this - nice with ApproveAndCall\r\n  function depositTokens(address from, address token, uint256 tokens ) public returns (bool success)\r\n  {\r\n      //we already have approval so lets do a transferFrom - transfer the tokens into this contract\r\n\r\n      if(!ERC20Interface(token).transferFrom(from, this, tokens)) revert();\r\n\r\n\r\n      balances[token][from] = balances[token][from].add(tokens);\r\n  //    depositedTokens[token] = depositedTokens[token].add(tokens);\r\n\r\n      Deposit(token, from, tokens, balances[token][from]);\r\n\r\n      return true;\r\n  }\r\n\r\n\r\n  //No approve needed, only from msg.sender\r\n  function withdrawTokens(address token, uint256 tokens) public returns (bool success){\r\n    balances[token][msg.sender] = balances[token][msg.sender].sub(tokens);\r\n\r\n    if(!ERC20Interface(token).transfer(msg.sender, tokens)) revert();\r\n\r\n\r\n     Withdraw(token, msg.sender, tokens, balances[token][msg.sender]);\r\n     return true;\r\n  }\r\n\r\n  //Requires approval so it can be public\r\n  function withdrawTokensFrom( address from, address to,address token,  uint tokens) public returns (bool success) {\r\n      balances[token][from] = balances[token][from].sub(tokens);\r\n       allowed[token][from][to] = allowed[token][from][to].sub(tokens);\r\n\r\n      if(!ERC20Interface(token).transfer(to, tokens)) revert();\r\n\r\n\r\n      Withdraw(token, from, tokens, balances[token][from]);\r\n      return true;\r\n  }\r\n\r\n\r\n  function balanceOf(address token,address user) public constant returns (uint) {\r\n       return balances[token][user];\r\n   }\r\n\r\n\r\n\r\n   function allowance(address token, address tokenOwner, address spender) public constant returns (uint remaining) {\r\n\r\n       return allowed[token][tokenOwner][spender];\r\n\r\n   }\r\n\r\n\r\n\r\n\r\n  //Can also be used to remove approval by using a 'tokens' value of 0.  P.S. it makes no sense to do an ApproveTokensFrom\r\n  function approveTokens(address spender, address token, uint tokens) public returns (bool success) {\r\n      allowed[token][msg.sender][spender] = tokens;\r\n      Approval(msg.sender, token, spender, tokens);\r\n      return true;\r\n  }\r\n\r\n  ///transfer tokens within the lava balances\r\n  //No approve needed, only from msg.sender\r\n   function transferTokens(address to, address token, uint tokens) public returns (bool success) {\r\n        balances[token][msg.sender] = balances[token][msg.sender].sub(tokens);\r\n        balances[token][to] = balances[token][to].add(tokens);\r\n        Transfer(msg.sender, token, to, tokens);\r\n        return true;\r\n    }\r\n\r\n\r\n    ///transfer tokens within the lava balances\r\n    //Can be public because it requires approval\r\n   function transferTokensFrom( address from, address to,address token,  uint tokens) public returns (bool success) {\r\n       balances[token][from] = balances[token][from].sub(tokens);\r\n       allowed[token][from][to] = allowed[token][from][to].sub(tokens);\r\n       balances[token][to] = balances[token][to].add(tokens);\r\n       Transfer(token, from, to, tokens);\r\n       return true;\r\n   }\r\n\r\n   //Nonce is the same thing as a 'check number'\r\n   //EIP 712\r\n   function getLavaTypedDataHash(bytes methodname, address from, address to, address token, uint256 tokens, uint256 relayerReward,\r\n                                     uint256 expires, uint256 nonce) public constant returns (bytes32)\r\n   {\r\n         bytes32 hardcodedSchemaHash = 0x8fd4f9177556bbc74d0710c8bdda543afd18cc84d92d64b5620d5f1881dceb37; //with methodname\r\n\r\n\r\n        bytes32 typedDataHash = sha3(\r\n            hardcodedSchemaHash,\r\n            sha3(methodname,from,to,this,token,tokens,relayerReward,expires,nonce)\r\n          );\r\n\r\n        return typedDataHash;\r\n   }\r\n\r\n\r\n   function tokenApprovalWithSignature(bool requiresKing, address from, address to, address token, uint256 tokens, uint256 relayerReward,\r\n                                     uint256 expires, bytes32 sigHash, bytes signature) internal returns (bool success)\r\n   {\r\n\r\n       address recoveredSignatureSigner = ECRecovery.recover(sigHash,signature);\r\n\r\n       //make sure the signer is the depositor of the tokens\r\n       if(from != recoveredSignatureSigner) revert();\r\n\r\n       if(msg.sender != getRelayingKing() && requiresKing ) revert();  // you must be the 'king of the hill' to relay\r\n\r\n       //make sure the signature has not expired\r\n       if(block.number > expires) revert();\r\n\r\n       uint burnedSignature = burnedSignatures[sigHash];\r\n       burnedSignatures[sigHash] = 0x1; //spent\r\n       if(burnedSignature != 0x0 ) revert();\r\n\r\n       //approve the relayer reward\r\n       allowed[token][from][msg.sender] = relayerReward;\r\n       Approval(from, token, msg.sender, relayerReward);\r\n\r\n       //transferRelayerReward\r\n       if(!transferTokensFrom(from, msg.sender, token, relayerReward)) revert();\r\n\r\n       //approve transfer of tokens\r\n       allowed[token][from][to] = tokens;\r\n       Approval(from, token, to, tokens);\r\n\r\n\r\n       return true;\r\n   }\r\n\r\n   function approveTokensFromAnyWithSignature(address from, address to, address token, uint256 tokens, uint256 relayerReward,\r\n                                     uint256 expires, uint256 nonce, bytes signature) public returns (bool success)\r\n   {\r\n\r\n\r\n       bytes32 sigHash = getLavaTypedDataHash('anyApprove',from,to,token,tokens,relayerReward,expires,nonce);\r\n\r\n       if(!tokenApprovalWithSignature(false,from,to,token,tokens,relayerReward,expires,sigHash,signature)) revert();\r\n\r\n\r\n       return true;\r\n   }\r\n\r\n   function approveTokensFromKingWithSignature(address from, address to, address token, uint256 tokens, uint256 relayerReward,\r\n                                     uint256 expires, uint256 nonce, bytes signature) public returns (bool success)\r\n   {\r\n\r\n\r\n       bytes32 sigHash = getLavaTypedDataHash('kingApprove',from,to,token,tokens,relayerReward,expires,nonce);\r\n\r\n       if(!tokenApprovalWithSignature(true,from,to,token,tokens,relayerReward,expires,sigHash,signature)) revert();\r\n\r\n\r\n       return true;\r\n   }\r\n\r\n   //the tokens remain in lava wallet\r\n  function transferTokensFromAnyWithSignature(address from, address to,  address token, uint256 tokens,  uint256 relayerReward,\r\n                                    uint256 expires, uint256 nonce, bytes signature) public returns (bool success)\r\n  {\r\n\r\n\r\n      //check to make sure that signature == ecrecover signature\r\n\r\n      bytes32 sigHash = getLavaTypedDataHash('anyTransfer',from,to,token,tokens,relayerReward,expires,nonce);\r\n\r\n      if(!tokenApprovalWithSignature(false,from,to,token,tokens,relayerReward,expires,sigHash,signature)) revert();\r\n\r\n      //it can be requested that fewer tokens be sent that were approved -- the whole approval will be invalidated though\r\n      if(!transferTokensFrom( from, to, token, tokens)) revert();\r\n\r\n\r\n      return true;\r\n\r\n  }\r\n\r\n   //The tokens are withdrawn from the lava wallet and transferred into the To account\r\n  function transferTokensFromKingWithSignature(address from, address to,  address token, uint256 tokens,  uint256 relayerReward,\r\n                                    uint256 expires, uint256 nonce, bytes signature) public returns (bool success)\r\n  {\r\n\r\n      //check to make sure that signature == ecrecover signature\r\n\r\n      bytes32 sigHash = getLavaTypedDataHash('kingTransfer',from,to,token,tokens,relayerReward,expires,nonce);\r\n\r\n      if(!tokenApprovalWithSignature(true,from,to,token,tokens,relayerReward,expires,sigHash,signature)) revert();\r\n\r\n      //it can be requested that fewer tokens be sent that were approved -- the whole approval will be invalidated though\r\n      if(!transferTokensFrom( from, to, token, tokens)) revert();\r\n\r\n\r\n      return true;\r\n\r\n  }\r\n\r\n  //the tokens remain in lava wallet\r\n function withdrawTokensFromAnyWithSignature(address from, address to,  address token, uint256 tokens,  uint256 relayerReward,\r\n                                   uint256 expires, uint256 nonce, bytes signature) public returns (bool success)\r\n {\r\n\r\n\r\n     //check to make sure that signature == ecrecover signature\r\n\r\n     bytes32 sigHash = getLavaTypedDataHash('anyWithdraw',from,to,token,tokens,relayerReward,expires,nonce);\r\n\r\n     if(!tokenApprovalWithSignature(false,from,to,token,tokens,relayerReward,expires,sigHash,signature)) revert();\r\n\r\n     //it can be requested that fewer tokens be sent that were approved -- the whole approval will be invalidated though\r\n     if(!withdrawTokensFrom( from, to, token, tokens)) revert();\r\n\r\n\r\n     return true;\r\n\r\n }\r\n\r\n  //The tokens are withdrawn from the lava wallet and transferred into the To account\r\n function withdrawTokensFromKingWithSignature(address from, address to,  address token, uint256 tokens,  uint256 relayerReward,\r\n                                   uint256 expires, uint256 nonce, bytes signature) public returns (bool success)\r\n {\r\n\r\n     //check to make sure that signature == ecrecover signature\r\n\r\n     bytes32 sigHash = getLavaTypedDataHash('kingWithdraw',from,to,token,tokens,relayerReward,expires,nonce);\r\n\r\n     if(!tokenApprovalWithSignature(true,from,to,token,tokens,relayerReward,expires,sigHash,signature)) revert();\r\n\r\n     //it can be requested that fewer tokens be sent that were approved -- the whole approval will be invalidated though\r\n     if(!withdrawTokensFrom( from, to, token, tokens)) revert();\r\n\r\n\r\n     return true;\r\n\r\n }\r\n\r\n\r\n\r\n\r\n\r\n     function burnSignature(bytes methodname, address from, address to, address token, uint256 tokens, uint256 relayerReward, uint256 expires, uint256 nonce,  bytes signature) public returns (bool success)\r\n     {\r\n\r\n        bytes32 sigHash = getLavaTypedDataHash(methodname,from,to,token,tokens,relayerReward,expires,nonce);\r\n\r\n\r\n         address recoveredSignatureSigner = ECRecovery.recover(sigHash,signature);\r\n\r\n         //make sure the invalidator is the signer\r\n         if(recoveredSignatureSigner != from) revert();\r\n\r\n         //only the original packet owner can burn signature, not a relay\r\n         if(from != msg.sender) revert();\r\n\r\n         //make sure this signature has never been used\r\n         uint burnedSignature = burnedSignatures[sigHash];\r\n         burnedSignatures[sigHash] = 0x2; //invalidated\r\n         if(burnedSignature != 0x0 ) revert();\r\n\r\n         return true;\r\n     }\r\n\r\n\r\n     //2 is burned\r\n     //1 is redeemed\r\n     function signatureBurnStatus(bytes32 digest) public view returns (uint)\r\n     {\r\n       return (burnedSignatures[digest]);\r\n     }\r\n\r\n\r\n\r\n\r\n       /*\r\n         Receive approval to spend tokens and perform any action all in one transaction\r\n       */\r\n     function receiveApproval(address from, uint256 tokens, address token, bytes data) public returns (bool success) {\r\n\r\n\r\n       return depositTokens(from, token, tokens );\r\n\r\n     }\r\n\r\n     /*\r\n      Approve lava tokens for a smart contract and call the contracts receiveApproval method all in one fell swoop\r\n\r\n      One issue: the data is not being signed and so it could be manipulated\r\n      */\r\n     function approveAndCall(bytes methodname, address from, address to, address token, uint256 tokens, uint256 relayerReward,\r\n                                       uint256 expires, uint256 nonce, bytes signature ) public   {\r\n\r\n\r\n\r\n          bytes32 sigHash = getLavaTypedDataHash(methodname,from,to,token,tokens,relayerReward,expires,nonce);\r\n\r\n          bool requiresKing = getRequiresKing(methodname);\r\n\r\n          if(!tokenApprovalWithSignature(requiresKing,from,to,token,tokens,relayerReward,expires,sigHash,signature)) revert();\r\n\r\n          ApproveAndCallFallBack(to).receiveApproval(from, tokens, token, methodname);\r\n\r\n\r\n     }\r\n\r\n     function getRelayingKing() public returns (address)\r\n     {\r\n       return MiningKingInterface(relayKingContract).getMiningKing();\r\n     }\r\n\r\n\r\n\r\n     function getRequiresKing(bytes methodname) pure internal returns (bool)\r\n    {\r\n      return (bytesEqual(methodname,'kingTransfer') || bytesEqual(methodname,'kingWithdraw') || bytesEqual(methodname,'kingApprove'));\r\n    }\r\n\r\n    function bytesEqual(bytes b1,bytes b2) pure internal returns (bool)\r\n    {\r\n      if(b1.length != b2.length) return false;\r\n\r\n      for (uint i=0; i<b1.length; i++) {\r\n        if(b1[i] != b2[i]) return false;\r\n      }\r\n\r\n      return true;\r\n    }\r\n\r\n\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"digest\",\"type\":\"bytes32\"}],\"name\":\"signatureBurnStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"approveTokensFromKingWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferTokensFromAnyWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"depositTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getRelayingKing\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawTokensFromKingWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferTokensFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"withdrawTokensFromAnyWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"methodname\",\"type\":\"bytes\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getLavaTypedDataHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approveTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferTokens\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"withdrawTokensFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"transferTokensFromKingWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"methodname\",\"type\":\"bytes\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"burnSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"approveTokensFromAnyWithSignature\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"methodname\",\"type\":\"bytes\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"relayerReward\",\"type\":\"uint256\"},{\"name\":\"expires\",\"type\":\"uint256\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signature\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"relayKingContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"LavaWallet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000002a20403757ffa6b4e5c613026b7a7308f8722db7","Library":"ECRecovery:f532bd0ef20914ea1f78763f0e22495b326ee3a2","SwarmSource":"bzzr://6333d9b35b942ab35ea64749208288253d9c358c86a52618925f8beb67a68988"}]}