{"status":"1","message":"OK","result":[{"SourceCode":"// File: @laborx/solidity-shared-lib/contracts/ERC20Interface.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/// @title Defines an interface for EIP20 token smart contract\r\ncontract ERC20Interface {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n    string public symbol;\r\n\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n}\r\n\r\n// File: @laborx/solidity-shared-lib/contracts/Owned.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/// @title Owned contract with safe ownership pass.\r\n///\r\n/// Note: all the non constant functions return false instead of throwing in case if state change\r\n/// didn't happen yet.\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    address public contractOwner;\r\n    address public pendingContractOwner;\r\n\r\n    modifier onlyContractOwner {\r\n        if (msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /// @notice Prepares ownership pass.\r\n    /// Can only be called by current owner.\r\n    /// @param _to address of the next owner.\r\n    /// @return success.\r\n    function changeContractOwnership(address _to)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (_to == 0x0) {\r\n            return false;\r\n        }\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Finalize ownership pass.\r\n    /// Can only be called by pending owner.\r\n    /// @return success.\r\n    function claimContractOwnership()\r\n    public\r\n    returns (bool)\r\n    {\r\n        if (msg.sender != pendingContractOwner) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, pendingContractOwner);\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (newOwner == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, newOwner);\r\n        contractOwner = newOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @dev Backward compatibility only.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferContractOwnership(address newOwner)\r\n    public\r\n    returns (bool)\r\n    {\r\n        return transferOwnership(newOwner);\r\n    }\r\n\r\n    /// @notice Withdraw given tokens from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawTokens(address[] tokens)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        address _contractOwner = contractOwner;\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20Interface token = ERC20Interface(tokens[i]);\r\n            uint balance = token.balanceOf(this);\r\n            if (balance > 0) {\r\n                token.transfer(_contractOwner, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw ether from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawEther()\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        uint balance = address(this).balance;\r\n        if (balance > 0)  {\r\n            contractOwner.transfer(balance);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers ether to another address.\r\n    /// Allowed only for contract owners.\r\n    /// @param _to recepient address\r\n    /// @param _value wei to transfer; must be less or equal to total balance on the contract\r\n    function transferEther(address _to, uint256 _value)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        require(_to != 0x0, \"INVALID_ETHER_RECEPIENT_ADDRESS\");\r\n        if (_value > address(this).balance) {\r\n            revert(\"INVALID_VALUE_TO_TRANSFER_ETHER\");\r\n        }\r\n\r\n        _to.transfer(_value);\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-eventshistory-lib/contracts/EventsHistorySourceAdapter.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n/**\r\n * @title EventsHistory Source Adapter.\r\n */\r\ncontract EventsHistorySourceAdapter {\r\n\r\n    // It is address of MultiEventsHistory caller assuming we are inside of delegate call.\r\n    function _self()\r\n    internal\r\n    view\r\n    returns (address)\r\n    {\r\n        return msg.sender;\r\n    }\r\n}\r\n\r\n// File: @laborx/solidity-eventshistory-lib/contracts/MultiEventsHistoryAdapter.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.21;\r\n\r\n\r\n\r\n/**\r\n * @title General MultiEventsHistory user.\r\n */\r\ncontract MultiEventsHistoryAdapter is EventsHistorySourceAdapter {\r\n\r\n    address internal localEventsHistory;\r\n\r\n    event ErrorCode(address indexed self, uint errorCode);\r\n\r\n    function getEventsHistory()\r\n    public\r\n    view\r\n    returns (address)\r\n    {\r\n        address _eventsHistory = localEventsHistory;\r\n        return _eventsHistory != 0x0 ? _eventsHistory : this;\r\n    }\r\n\r\n    function emitErrorCode(uint _errorCode) public {\r\n        emit ErrorCode(_self(), _errorCode);\r\n    }\r\n\r\n    function _setEventsHistory(address _eventsHistory) internal returns (bool) {\r\n        localEventsHistory = _eventsHistory;\r\n        return true;\r\n    }\r\n    \r\n    function _emitErrorCode(uint _errorCode) internal returns (uint) {\r\n        MultiEventsHistoryAdapter(getEventsHistory()).emitErrorCode(_errorCode);\r\n        return _errorCode;\r\n    }\r\n}\r\n\r\n// File: contracts/StorageManager.sol\r\n\r\n/**\r\n * Copyright 2017–2018, LaborX PTY\r\n * Licensed under the AGPL Version 3 license.\r\n */\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n\r\ncontract StorageManager is Owned, MultiEventsHistoryAdapter {\r\n\r\n    uint constant OK = 1;\r\n\r\n    event AccessGiven(address indexed self, address indexed actor, bytes32 role);\r\n    event AccessBlocked(address indexed self, address indexed actor, bytes32 role);\r\n    event AuthorizationGranted(address indexed self, address indexed account);\r\n    event AuthorizationRevoked(address indexed self, address indexed account);\r\n\r\n    mapping (address => uint) public authorised;\r\n    mapping (bytes32 => bool) public accessRights;\r\n    mapping (address => bool) public acl;\r\n\r\n    modifier onlyAuthorized {\r\n        if (msg.sender == contractOwner || acl[msg.sender]) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    function setupEventsHistory(address _eventsHistory)\r\n    external\r\n    onlyContractOwner\r\n    returns (uint)\r\n    {\r\n        _setEventsHistory(_eventsHistory);\r\n        return OK;\r\n    }\r\n\r\n    function authorize(address _address)\r\n    external\r\n    onlyAuthorized\r\n    returns (uint)\r\n    {\r\n        require(_address != 0x0, \"STORAGE_MANAGER_INVALID_ADDRESS\");\r\n        acl[_address] = true;\r\n\r\n        _emitter().emitAuthorizationGranted(_address);\r\n        return OK;\r\n    }\r\n\r\n    function revoke(address _address)\r\n    external\r\n    onlyContractOwner\r\n    returns (uint)\r\n    {\r\n        require(acl[_address], \"STORAGE_MANAGER_ADDRESS_SHOULD_EXIST\");\r\n        delete acl[_address];\r\n\r\n        _emitter().emitAuthorizationRevoked(_address);\r\n        return OK;\r\n    }\r\n\r\n    function giveAccess(address _actor, bytes32 _role)\r\n    external\r\n    onlyAuthorized\r\n    returns (uint)\r\n    {\r\n        if (!accessRights[_getKey(_actor, _role)]) {\r\n            accessRights[_getKey(_actor, _role)] = true;\r\n            authorised[_actor] += 1;\r\n            _emitter().emitAccessGiven(_actor, _role);\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    function blockAccess(address _actor, bytes32 _role)\r\n    external\r\n    onlyAuthorized\r\n    returns (uint)\r\n    {\r\n        if (accessRights[_getKey(_actor, _role)]) {\r\n            delete accessRights[_getKey(_actor, _role)];\r\n            authorised[_actor] -= 1;\r\n            if (authorised[_actor] == 0) {\r\n                delete authorised[_actor];\r\n            }\r\n            _emitter().emitAccessBlocked(_actor, _role);\r\n        }\r\n\r\n        return OK;\r\n    }\r\n\r\n    function isAllowed(address _actor, bytes32 _role)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return accessRights[keccak256(abi.encodePacked(_actor, _role))] || (this == _actor);\r\n    }\r\n\r\n    function hasAccess(address _actor)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        return (authorised[_actor] > 0) || (address(this) == _actor);\r\n    }\r\n\r\n    function emitAccessGiven(address _user, bytes32 _role) public {\r\n        emit AccessGiven(_self(), _user, _role);\r\n    }\r\n\r\n    function emitAccessBlocked(address _user, bytes32 _role) public {\r\n        emit AccessBlocked(_self(), _user, _role);\r\n    }\r\n\r\n    function emitAuthorizationGranted(address _account) public {\r\n        emit AuthorizationGranted(_self(), _account);\r\n    }\r\n\r\n    function emitAuthorizationRevoked(address _account) public {\r\n        emit AuthorizationRevoked(_self(), _account);\r\n    }\r\n\r\n    function _emitter() internal view returns (StorageManager) {\r\n        return StorageManager(getEventsHistory());\r\n    }\r\n\r\n    function _getKey(address _actor, bytes32 _role) private pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_actor, _role));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_eventsHistory\",\"type\":\"address\"}],\"name\":\"setupEventsHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"emitAccessBlocked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"acl\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"emitAuthorizationRevoked\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"emitAccessGiven\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"emitAuthorizationGranted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_actor\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"isAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"revoke\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"accessRights\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_actor\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"giveAccess\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_errorCode\",\"type\":\"uint256\"}],\"name\":\"emitErrorCode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_actor\",\"type\":\"address\"}],\"name\":\"hasAccess\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"authorize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_actor\",\"type\":\"address\"},{\"name\":\"_role\",\"type\":\"bytes32\"}],\"name\":\"blockAccess\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"authorised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getEventsHistory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"self\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"actor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"AccessGiven\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"self\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"actor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"role\",\"type\":\"bytes32\"}],\"name\":\"AccessBlocked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"self\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AuthorizationGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"self\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"AuthorizationRevoked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"self\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"errorCode\",\"type\":\"uint256\"}],\"name\":\"ErrorCode\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"StorageManager","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cce1c0b8e3e63d6cbbebcc682b2141fc7654b7f3928fd90a9d0521980010ba27"}]}