{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n *  https://Smart-Pyramid.io\r\n *\r\n * Smart-Pyramid Contract\r\n *  - GAIN 1.2% PER 24 HOURS (every 5900 blocks)\r\n *  - Minimal contribution 0.01 eth\r\n *  - Currency and payment - ETH\r\n *  - Contribution allocation schemes:\r\n *    -- 84% payments\r\n *    -- 16% Marketing + Operating Expenses\r\n *\r\n * How to use:\r\n *  1. Send any amount of ether to make an investment\r\n *  2a. Claim your profit by sending 0 ether transaction (every day, every week, i don't care unless you're spending too much on GAS)\r\n *  OR\r\n *  2b. Send more ether to reinvest AND get your profit at the same time\r\n *\r\n * RECOMMENDED GAS LIMIT: 200000\r\n * RECOMMENDED GAS PRICE: https://ethgasstation.info/\r\n *\r\n *Investors Contest rules\r\n *\r\n * Investor contest lasts a whole week\r\n * The results of the competition are confirmed every MON not earlier than 13:00 MSK (10:00 UTC)\r\n * According to the results, will be determined 3 winners, who during the week invested the maximum amounts\r\n * in one payment.\r\n * If two investors invest the same amount - the highest place in the competition is occupied by the one whose operation\r\n *  was before\r\n *\r\n * Prizes:\r\n * 1st place: 2 ETH\r\n * 2nd place: 1 ETH\r\n * 3rd place: 0.5 ETH\r\n *\r\n * On the offensive (10:00 UTC) on Monday, it is necessary to initiate the summing up of the competition.\r\n * Until the results are announced - the competition is still on.\r\n * To sum up the results, you need to call the PayDay function\r\n *\r\n *\r\n * Contract reviewed and approved by experts!\r\n *\r\n */\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0);\r\n        uint256 c = _a / _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\ncontract InvestorsStorage {\r\n    address private owner;\r\n\r\n    mapping (address => Investor) private investors;\r\n\r\n    struct Investor {\r\n        uint deposit;\r\n        uint checkpoint;\r\n        address referrer;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function updateInfo(address _address, uint _value) external onlyOwner {\r\n        investors[_address].deposit += _value;\r\n        investors[_address].checkpoint = block.timestamp;\r\n    }\r\n\r\n    function updateCheckpoint(address _address) external onlyOwner {\r\n        investors[_address].checkpoint = block.timestamp;\r\n    }\r\n\r\n    function addReferrer(address _referral, address _referrer) external onlyOwner {\r\n        investors[_referral].referrer = _referrer;\r\n    }\r\n\r\n    function d(address _address) external view onlyOwner returns(uint) {\r\n        return investors[_address].deposit;\r\n    }\r\n\r\n    function c(address _address) external view onlyOwner returns(uint) {\r\n        return investors[_address].checkpoint;\r\n    }\r\n\r\n    function r(address _address) external view onlyOwner returns(address) {\r\n        return investors[_address].referrer;\r\n    }\r\n}\r\n\r\ncontract SmartPyramid {\r\n    using SafeMath for uint;\r\n\r\n    address public owner;\r\n    address fee_address;\r\n    \r\n    uint waveStartUp;\r\n    uint nextPayDay;\r\n\r\n    mapping (uint => Leader) top;\r\n\r\n    event LogInvestment(address _addr, uint _value);\r\n    event LogPayment(address _addr, uint _value);\r\n    event LogNewReferrer(address _referral, address _referrer);\r\n    event LogReferralInvestment(address _referral, uint _value);\r\n    event LogGift(address _first, address _second, address _third);\r\n    event LogNewWave(uint _waveStartUp);\r\n\r\n    InvestorsStorage private x;\r\n\r\n    modifier notOnPause() {\r\n        require(waveStartUp <= block.timestamp);\r\n        _;\r\n    }\r\n\r\n    struct Leader {\r\n        address addr;\r\n        uint deposit;\r\n    }\r\n\r\n    function renounceOwnership() external {\r\n        require(msg.sender == owner);\r\n        owner = 0x0;\r\n    }\r\n\r\n    function bytesToAddress(bytes _source) internal pure returns(address parsedReferrer) {\r\n        assembly {\r\n            parsedReferrer := mload(add(_source,0x14))\r\n        }\r\n        return parsedReferrer;\r\n    }\r\n\r\n    function addReferrer(uint _value) internal {\r\n        address _referrer = bytesToAddress(bytes(msg.data));\r\n        if (_referrer != msg.sender) {\r\n            x.addReferrer(msg.sender, _referrer);\r\n            x.r(msg.sender).transfer(_value / 20);\r\n            emit LogNewReferrer(msg.sender, _referrer);\r\n            emit LogReferralInvestment(msg.sender, _value);\r\n        }\r\n    }\r\n\r\n    constructor(address _fee_address) public {\r\n        owner = msg.sender;\r\n        fee_address = _fee_address;\r\n        x = new InvestorsStorage();\r\n    }\r\n\r\n    function getInfo(address _address) external view returns(uint deposit, uint amountToWithdraw) {\r\n        deposit = x.d(_address);\r\n        if (block.timestamp >= x.c(_address) + 10 minutes) {\r\n            amountToWithdraw = (x.d(_address).mul(12).div(1000)).mul(block.timestamp.sub(x.c(_address))).div(1 days);\r\n        } else {\r\n            amountToWithdraw = 0;\r\n        }\r\n    }\r\n\r\n    function getTop() external view returns(address, uint, address, uint, address, uint) {\r\n        return(top[1].addr, top[1].deposit, top[2].addr, top[2].deposit, top[3].addr, top[3].deposit);\r\n    }\r\n\r\n    function() external payable {\r\n        if (msg.value == 0) {\r\n            withdraw();\r\n        } else {\r\n            invest();\r\n        }\r\n    }\r\n\r\n    function invest() notOnPause public payable {\r\n\r\n        fee_address.transfer(msg.value * 16 / 100);\r\n\r\n        if (x.d(msg.sender) > 0) {\r\n            withdraw();\r\n        }\r\n\r\n        x.updateInfo(msg.sender, msg.value);\r\n\r\n        if (msg.value > top[3].deposit) {\r\n            toTheTop();\r\n        }\r\n\r\n        if (x.r(msg.sender) != 0x0) {\r\n            x.r(msg.sender).transfer(msg.value / 20);\r\n            emit LogReferralInvestment(msg.sender, msg.value);\r\n        } else if (msg.data.length == 20) {\r\n            addReferrer(msg.value);\r\n        }\r\n\r\n        emit LogInvestment(msg.sender, msg.value);\r\n    }\r\n\r\n\r\n    function withdraw() notOnPause public {\r\n\r\n        if (block.timestamp >= x.c(msg.sender) + 10 minutes) {\r\n            uint _payout = (x.d(msg.sender).mul(12).div(1000)).mul(block.timestamp.sub(x.c(msg.sender))).div(1 days);\r\n            x.updateCheckpoint(msg.sender);\r\n        }\r\n\r\n        if (_payout > 0) {\r\n\r\n            if (_payout > address(this).balance) {\r\n                nextWave();\r\n                return;\r\n            }\r\n\r\n            msg.sender.transfer(_payout);\r\n            emit LogPayment(msg.sender, _payout);\r\n        }\r\n    }\r\n\r\n    function toTheTop() internal {\r\n        if (msg.value <= top[2].deposit) {\r\n            top[3] = Leader(msg.sender, msg.value);\r\n        } else {\r\n            if (msg.value <= top[1].deposit) {\r\n                top[3] = top[2];\r\n                top[2] = Leader(msg.sender, msg.value);\r\n            } else {\r\n                top[3] = top[2];\r\n                top[2] = top[1];\r\n                top[1] = Leader(msg.sender, msg.value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function payDay() external {\r\n        require(block.timestamp >= nextPayDay);\r\n        nextPayDay = block.timestamp.sub((block.timestamp - 1538388000).mod(7 days)).add(7 days);\r\n        emit LogGift(top[1].addr, top[2].addr, top[3].addr);\r\n        for (uint i = 0; i <= 2; i++) {\r\n            top[i+1].addr.transfer(2 ether / 2 ** i);\r\n            top[i+1] = Leader(0x0, 0);\r\n        }\r\n    }\r\n\r\n    function nextWave() private {\r\n        for (uint i = 0; i <= 2; i++) {\r\n            top[i+1] = Leader(0x0, 0);\r\n        }\r\n        x = new InvestorsStorage();\r\n        waveStartUp = block.timestamp + 7 days;\r\n        emit LogNewWave(waveStartUp);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTop\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payDay\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"invest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_fee_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogPayment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_referrer\",\"type\":\"address\"}],\"name\":\"LogNewReferrer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_referral\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"LogReferralInvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_first\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_second\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_third\",\"type\":\"address\"}],\"name\":\"LogGift\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_waveStartUp\",\"type\":\"uint256\"}],\"name\":\"LogNewWave\",\"type\":\"event\"}]","ContractName":"SmartPyramid","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000014f55a50b281efd12294f0cda821bd8171e920","Library":"","SwarmSource":"bzzr://344710f0de960901372800df4a85198fee2b0e3fd14294707255a5d3db5bb6f1"}]}