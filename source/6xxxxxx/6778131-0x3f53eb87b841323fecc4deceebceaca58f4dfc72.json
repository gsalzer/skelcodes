{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title MerkleProof\r\n * @dev Merkle proof verification based on\r\n * https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\nlibrary MerkleProof {\r\n  /**\r\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\r\n   * and each pair of pre-images are sorted.\r\n   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\r\n   * @param _root Merkle root\r\n   * @param _leaf Leaf of Merkle tree\r\n   */\r\n  function verifyProof(\r\n    bytes32[] _proof,\r\n    bytes32 _root,\r\n    bytes32 _leaf\r\n  )\r\n    internal\r\n    pure\r\n    returns (bool)\r\n  {\r\n    bytes32 computedHash = _leaf;\r\n\r\n    for (uint256 i = 0; i < _proof.length; i++) {\r\n      bytes32 proofElement = _proof[i];\r\n\r\n      if (computedHash < proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == _root;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract Controlled {\r\n\r\n    mapping(address => bool) public controllers;\r\n\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { \r\n        require(controllers[msg.sender]); \r\n        _; \r\n    }\r\n\r\n    address public controller;\r\n\r\n    constructor() internal { \r\n        controllers[msg.sender] = true; \r\n        controller = msg.sender;\r\n    }\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n\r\n    function changeControllerAccess(address _controller, bool _access) public onlyController {\r\n        controllers[_controller] = _access;\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ninterface ERC20Token {\r\n\r\n    /**\r\n     * @notice send `_value` token to `_to` from `msg.sender`\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    /**\r\n     * @notice return total supply of tokens\r\n     */\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\ncontract SNTGiveaway is Controlled {\r\n    \r\n    mapping(address => bool) public sentToAddress;\r\n    mapping(bytes5 => bool) public codeUsed;\r\n    \r\n    ERC20Token public SNT;\r\n    \r\n    uint public ethAmount;\r\n    uint public sntAmount;\r\n    bytes32 public root;\r\n    \r\n    event AddressFunded(address dest, bytes5 code, uint ethAmount, uint sntAmount);\r\n    \r\n    /// @notice Constructor\r\n    /// @param _sntAddress address SNT contract address\r\n    /// @param _ethAmount uint Amount of ETH in wei to send\r\n    /// @param _sntAmount uint Amount of SNT in wei to send\r\n    /// @param _root bytes32 Merkle tree root\r\n    constructor(address _sntAddress, uint _ethAmount, uint _sntAmount, bytes32 _root) public {\r\n        SNT = ERC20Token(_sntAddress);\r\n        ethAmount = _ethAmount;\r\n        sntAmount = _sntAmount;\r\n        root = _root;\r\n    }\r\n\r\n    /// @notice Determine if a request to send SNT/ETH is valid based on merkle proof, and destination address\r\n    /// @param _proof bytes32[] Merkle proof\r\n    /// @param _code bytes5 Unhashed code\r\n    /// @param _dest address Destination address\r\n    function validRequest(bytes32[] _proof, bytes5 _code, address _dest) public view returns(bool) {\r\n        return !sentToAddress[_dest] && !codeUsed[_code] && MerkleProof.verifyProof(_proof, root, keccak256(abi.encodePacked(_code)));\r\n    }\r\n\r\n    /// @notice Process request for SNT/ETH and send it to destination address\r\n    /// @param _proof bytes32[] Merkle proof\r\n    /// @param _code bytes5 Unhashed code\r\n    /// @param _dest address Destination address\r\n    function processRequest(bytes32[] _proof, bytes5 _code, address _dest) public onlyController {\r\n        require(!sentToAddress[_dest] && !codeUsed[_code], \"Funds already sent / Code already used\");\r\n        require(MerkleProof.verifyProof(_proof, root, keccak256(abi.encodePacked(_code))), \"Invalid code\");\r\n\r\n        sentToAddress[_dest] = true;\r\n        codeUsed[_code] = true;\r\n        \r\n        require(SNT.transfer(_dest, sntAmount), \"Transfer did not work\");\r\n        _dest.transfer(ethAmount);\r\n        \r\n        emit AddressFunded(_dest, _code, ethAmount, sntAmount);\r\n    }\r\n    \r\n    /// @notice Update configuration settings\r\n    /// @param _ethAmount uint Amount of ETH in wei to send\r\n    /// @param _sntAmount uint Amount of SNT in wei to send\r\n    /// @param _root bytes32 Merkle tree root\r\n    function updateSettings(uint _ethAmount, uint _sntAmount, bytes32 _root) public onlyController {\r\n        ethAmount = _ethAmount;\r\n        sntAmount = _sntAmount;\r\n        root = _root;\r\n        \r\n    }\r\n\r\n    function manualSend(address _dest, bytes5 _code) public onlyController {\r\n        require(!sentToAddress[_dest] && !codeUsed[_code], \"Funds already sent / Code already used\");\r\n\r\n        sentToAddress[_dest] = true;\r\n        codeUsed[_code] = true;\r\n\r\n        require(SNT.transfer(_dest, sntAmount), \"Transfer did not work\");\r\n        _dest.transfer(ethAmount);\r\n        \r\n        emit AddressFunded(_dest, _code, ethAmount, sntAmount);\r\n    }\r\n    \r\n    /// @notice Extract balance in ETH + SNT from the contract and destroy the contract\r\n    function boom() public onlyController {\r\n        uint sntBalance = SNT.balanceOf(address(this));\r\n        require(SNT.transfer(msg.sender, sntBalance), \"Transfer did not work\");\r\n        selfdestruct(msg.sender);\r\n    }\r\n    \r\n    /// @notice Extract balance in ETH + SNT from the contract\r\n    function retrieveFunds() public onlyController {\r\n        uint sntBalance = SNT.balanceOf(address(this));\r\n        require(SNT.transfer(msg.sender, sntBalance), \"Transfer did not work\");\r\n        selfdestruct(msg.sender);\r\n    }\r\n\r\n\r\n    function() public payable {\r\n          \r\n    }\r\n\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"retrieveFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_code\",\"type\":\"bytes5\"}],\"name\":\"manualSend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes5\"}],\"name\":\"codeUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_code\",\"type\":\"bytes5\"},{\"name\":\"_dest\",\"type\":\"address\"}],\"name\":\"processRequest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sntAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sentToAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"boom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"name\":\"_sntAmount\",\"type\":\"uint256\"},{\"name\":\"_root\",\"type\":\"bytes32\"}],\"name\":\"updateSettings\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_code\",\"type\":\"bytes5\"},{\"name\":\"_dest\",\"type\":\"address\"}],\"name\":\"validRequest\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controller\",\"type\":\"address\"},{\"name\":\"_access\",\"type\":\"bool\"}],\"name\":\"changeControllerAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SNT\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"controllers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_sntAddress\",\"type\":\"address\"},{\"name\":\"_ethAmount\",\"type\":\"uint256\"},{\"name\":\"_sntAmount\",\"type\":\"uint256\"},{\"name\":\"_root\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"code\",\"type\":\"bytes5\"},{\"indexed\":false,\"name\":\"ethAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sntAmount\",\"type\":\"uint256\"}],\"name\":\"AddressFunded\",\"type\":\"event\"}]","ContractName":"SNTGiveaway","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000744d70fdbe2ba4cf95131626614a1763df805b9e000000000000000000000000000000000000000000000000002386f26fc10000000000000000000000000000000000000000000000000002b5e3af16b18800000000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://caa38d981db250d78a33db9ec5a892701b7eb389c989c5ea0d77c4d4ed1dc148"}]}