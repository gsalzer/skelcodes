{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity >=0.4.22 <0.6.0;\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title ERC20Detailed token\r\n * @dev The decimals are only for visualization purposes.\r\n * All the operations are done using the smallest and indivisible token unit,\r\n * just as on Ethereum all the operations are done in wei.\r\n */\r\ncontract ERC20Detailed is IERC20 {\r\n  string private _name;\r\n  string private _symbol;\r\n  uint8 private _decimals;\r\n\r\n  constructor(string name, string symbol, uint8 decimals) public {\r\n    _name = name;\r\n    _symbol = symbol;\r\n    _decimals = decimals;\r\n  }\r\n\r\n  /**\r\n   * @return the name of the token.\r\n   */\r\n  function name() public view returns(string) {\r\n    return _name;\r\n  }\r\n\r\n  /**\r\n   * @return the symbol of the token.\r\n   */\r\n  function symbol() public view returns(string) {\r\n    return _symbol;\r\n  }\r\n\r\n  /**\r\n   * @return the number of decimals of the token.\r\n   */\r\n  function decimals() public view returns(uint8) {\r\n    return _decimals;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract ERC20 is IERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private _balances;\r\n\r\n  mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n  uint256 private _totalSupply;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return _totalSupply;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param owner The address to query the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address owner) public view returns (uint256) {\r\n    return _balances[owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param owner address The address which owns the funds.\r\n   * @param spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address owner,\r\n    address spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return _allowed[owner][spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function transfer(address to, uint256 value) public returns (bool) {\r\n    _transfer(msg.sender, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param spender The address which will spend the funds.\r\n   * @param value The amount of tokens to be spent.\r\n   */\r\n  function approve(address spender, uint256 value) public returns (bool) {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = value;\r\n    emit Approval(msg.sender, spender, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param from address The address which you want to send tokens from\r\n   * @param to address The address which you want to transfer to\r\n   * @param value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(value <= _allowed[from][msg.sender]);\r\n\r\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\r\n    _transfer(from, to, value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseAllowance(\r\n    address spender,\r\n    uint256 addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].add(addedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed_[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param spender The address which will spend the funds.\r\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseAllowance(\r\n    address spender,\r\n    uint256 subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(spender != address(0));\r\n\r\n    _allowed[msg.sender][spender] = (\r\n      _allowed[msg.sender][spender].sub(subtractedValue));\r\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified addresses\r\n  * @param from The address to transfer from.\r\n  * @param to The address to transfer to.\r\n  * @param value The amount to be transferred.\r\n  */\r\n  function _transfer(address from, address to, uint256 value) internal {\r\n    require(value <= _balances[from]);\r\n    require(to != address(0));\r\n\r\n    _balances[from] = _balances[from].sub(value);\r\n    _balances[to] = _balances[to].add(value);\r\n    emit Transfer(from, to, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param account The account that will receive the created tokens.\r\n   * @param value The amount that will be created.\r\n   */\r\n  function _mint(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    _totalSupply = _totalSupply.add(value);\r\n    _balances[account] = _balances[account].add(value);\r\n    emit Transfer(address(0), account, value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burn(address account, uint256 value) internal {\r\n    require(account != 0);\r\n    require(value <= _balances[account]);\r\n\r\n    _totalSupply = _totalSupply.sub(value);\r\n    _balances[account] = _balances[account].sub(value);\r\n    emit Transfer(account, address(0), value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account, deducting from the sender's allowance for said account. Uses the\r\n   * internal burn function.\r\n   * @param account The account whose tokens will be burnt.\r\n   * @param value The amount that will be burnt.\r\n   */\r\n  function _burnFrom(address account, uint256 value) internal {\r\n    require(value <= _allowed[account][msg.sender]);\r\n\r\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\r\n    // this function needs to emit an event with the updated approval.\r\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\r\n      value);\r\n    _burn(account, value);\r\n  }\r\n}\r\n\r\nlibrary CommUtils{\r\n\r\n \r\n    uint256 constant MAX_MUL_BASE = 340282366920939000000000000000000000000;\r\n\r\n\r\n    function abs(uint256 a,uint256 b) internal pure returns(uint256){\r\n        return a>b ? a-b : b-a;\r\n    }\r\n\r\n   \r\n    function mult(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }    \r\n\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mult(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n\r\n\r\n    function mulRate(uint256 tar,uint256 rate) public pure returns (uint256){\r\n        return tar *rate / 100;\r\n    }  \r\n    \r\n    function mulRate1000(uint256 tar,uint256 rate) public pure returns (uint256){\r\n        return tar *rate / 1000;\r\n    }  \r\n    \r\n    \r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }   \r\n    \r\n    function isStringEmpty(string str) internal pure returns(bool){\r\n        bytes memory tempEmptyStringTest = bytes(str); \r\n        return tempEmptyStringTest.length == 0;\r\n    }\r\n     \r\n    \r\n    \r\n    \r\n    \r\n    struct Float{\r\n        uint256 number;\r\n        uint256 digits;\r\n    }\r\n    \r\n    function initFloat(uint256 v,uint256 denominator) internal pure returns(Float){\r\n        return Float(v*denominator,denominator);\r\n    }\r\n    \r\n    \r\n    function pow(Float f ,uint256 count) internal pure returns(Float ans){\r\n\r\n        if (count==0){\r\n            return Float(10,1);\r\n        }\r\n        ans.number = f.number;\r\n        ans.digits = f.digits;\r\n        for(uint256 i=1;i<count;i++){\r\n            ans = multiply(ans,f);\r\n        }\r\n    }\r\n    \r\n    function decrease(Float f,Float o) internal pure returns(bool ok,Float ans){\r\n        sameDigits(f,o);\r\n        require(f.digits == o.digits,\"it`s must same sameDigits\");\r\n        if(f.number >= o.number ){\r\n            ok = true;            \r\n            ans.number = f.number - o.number;\r\n            ans.digits = f.digits;\r\n        }\r\n    }\r\n    \r\n    function increase(Float f,Float o) internal pure returns(Float ans){\r\n        sameDigits(f,o);\r\n        require(f.digits == o.digits,\"it`s must same sameDigits\");\r\n        ans.number = f.number+o.number;\r\n        ans.digits = f.digits;\r\n    }\r\n    \r\n    function sameDigits(Float f,Float o) private pure {\r\n        return f.digits > o.digits ? _sameDigits(f,o) : _sameDigits(o,f) ;\r\n    }\r\n    \r\n    function _sameDigits(Float big,Float small ) private pure {\r\n        uint256 dd = big.digits - small.digits;\r\n        small.number = small.number * pwr(10,dd);\r\n        small.digits = big.digits;\r\n    }\r\n    \r\n    function multiSafe(uint256 a,uint256 b) internal pure returns (uint256 ans,uint256 ap,uint256 bp){\r\n        (uint256 newA, uint256 apow)  = powDown(a);\r\n        (uint256 newB, uint256 bpow)  = powDown(b);\r\n        ans = mult(newA , newB);\r\n        ap = apow;\r\n        bp = bpow;\r\n    }\r\n    \r\n    function powDown(uint256 a) internal pure returns(uint256 newA,uint256 pow10){\r\n        newA = a;\r\n        while(newA>=MAX_MUL_BASE){\r\n            pow10++;\r\n            newA /= 10;\r\n        }\r\n    }\r\n    \r\n    function multiply(Float  f,Float o) internal pure returns(Float ans){\r\n        (uint256 v,uint256 ap,uint256 bp ) = multiSafe(f.number,o.number);\r\n        ans.number = v;  \r\n        ans.digits = f.digits+o.digits-(ap+bp);\r\n    }\r\n    \r\n    function multiply(Float  f,uint256 tar) internal pure returns(Float ans){\r\n        (uint256 v,uint256 ap,uint256 bp ) = multiSafe(f.number,tar);\r\n        ans.number = v;\r\n        ans.digits = f.digits-(ap+bp);\r\n    }    \r\n    \r\n    function divide(Float f,Float o) internal pure returns(Float ans){\r\n       if(f.digits >= o.digits){\r\n           ans.digits = f.digits - o.digits;\r\n       }else{\r\n           uint256 dp = o.digits - f.digits;\r\n           ans.digits = 0;\r\n           ans.number = mult( f.number , pwr(10,dp));\r\n       }\r\n        ans.number = ans.number / o.number;\r\n    }\r\n    \r\n    function toUint256(Float f) internal pure returns(uint256 ans){\r\n        ans = f.number;\r\n        for(uint256 i=0;i<f.digits;i++){\r\n            ans /= 10;\r\n        }\r\n    }\r\n    \r\n    function getIntegral(Float exCoefficient,uint256 xb,uint256 tokenDigits,uint256 X_POW) internal pure returns(uint256 ){\r\n        CommUtils.Float memory x = CommUtils.Float(xb,tokenDigits);\r\n        Float memory xPow = pow(x,X_POW+1);\r\n        Float memory ec = pow(exCoefficient,X_POW);\r\n        Float memory tempAns = multiply(xPow,ec);\r\n        return toUint256(tempAns)/(X_POW+1); \r\n    }   \r\n    \r\n    \r\n    \r\n    struct Countdown{\r\n        uint128 max;\r\n        uint128 current;\r\n        uint256 timestamp;\r\n        uint256 period;\r\n        bool passing;\r\n    }\r\n    \r\n    function freshAndCheck(Countdown  d,uint256 curP,uint256 max,uint256 period) view internal returns(Countdown){\r\n        if(d.timestamp == 0) {\r\n            d=Countdown( uint128( max),0,  now,period , true);\r\n        }  \r\n        if(now - d.timestamp > period){\r\n          d= Countdown( uint128( max),0,now,period,true);  \r\n        } \r\n        d.current += uint128(curP);\r\n        d.passing = d.current <= d.max;\r\n        return d;\r\n    }    \r\n    \r\n    \r\n}\r\n\r\n\r\n\r\nlibrary Player{\r\n\r\n    using CommUtils for string;\r\n    using CommUtils for CommUtils.Countdown;\r\n    uint256 public constant BONUS_INTERVAL = 60*60*24*7;\r\n    \r\n    \r\n    struct Map{\r\n        mapping(address=>uint256) bonusAt;\r\n        mapping(address=>uint256) ethMap;\r\n        mapping(address=>address) referrerMap;\r\n        mapping(address=>bytes32) addrNameMap;\r\n        mapping(bytes32=>address) nameAddrMap;\r\n        mapping(address=>CommUtils.Countdown) sellLimeMap;\r\n    }\r\n    \r\n    function remove(Map storage ps,address adr) internal{\r\n        //transferAuthor(ps.ethMap[adr]);\r\n        delete ps.ethMap[adr];\r\n        bytes32 b = ps.addrNameMap[adr];\r\n        delete ps.nameAddrMap[b];\r\n        delete ps.addrNameMap[adr];\r\n    }\r\n    \r\n    function deposit(Map storage  ps,address adr,uint256 v) internal returns(uint256) {\r\n       ps.ethMap[adr]+=v;\r\n        return v;\r\n    }\r\n    \r\n    \r\n\r\n\r\n\r\n    function refleshBonusAt(Map storage  ps,address addr,uint256 allCount,uint256 plusCount) internal{\r\n        if(ps.bonusAt[addr] == 0)        {\r\n            ps.bonusAt[addr] = now;\r\n            return;\r\n        }\r\n        uint256 plsuAt = BONUS_INTERVAL * plusCount / allCount;\r\n        ps.bonusAt[addr] += plsuAt;\r\n        ps.bonusAt[addr] = ps.bonusAt[addr] > now ? now : ps.bonusAt[addr];\r\n    }\r\n    \r\n    \r\n    \r\n    function isOverBonusAt(Map storage ps,address addr) internal returns(bool ){\r\n        if( (ps.bonusAt[addr] - now)> BONUS_INTERVAL){\r\n            ps.bonusAt[addr] = now;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    function transferSafe(address addr,uint256 v) internal {\r\n        if(address(this).balance>=v){\r\n            addr.transfer(v);\r\n        }else{\r\n            addr.transfer( address(this).balance);\r\n        }\r\n    }\r\n    \r\n\r\n    function minus(Map storage  ps,address adr,uint256 num) internal  {\r\n        uint256 sum = ps.ethMap[adr];\r\n        if(sum==num){\r\n             withdrawalAll(ps,adr);\r\n        }else{\r\n            require(sum > num);\r\n            ps.ethMap[adr] = sum-num;\r\n        }\r\n    }\r\n    \r\n    function minusAndTransfer(Map storage  ps,address adr,uint256 num) internal  {\r\n        minus(ps,adr,num);\r\n        transferSafe(adr,num);\r\n    }    \r\n    \r\n    function withdrawalAll(Map storage  ps,address adr) public returns(uint256) {\r\n        uint256 sum = ps.ethMap[adr];\r\n        delete ps.ethMap[adr];\r\n        return sum;\r\n    }\r\n    \r\n    function getAmmount(Map storage ps,address adr) public view returns(uint256) {\r\n        return ps.ethMap[adr];\r\n    }\r\n    \r\n    function registerName(Map storage ps,bytes32 _name)internal  {\r\n        require(ps.nameAddrMap[_name] == address(0) );\r\n        ps.nameAddrMap[_name] = msg.sender;\r\n        ps.addrNameMap[msg.sender] = _name;\r\n    }\r\n    \r\n    function isEmptyName(Map storage ps,bytes32 _name) public view returns(bool) {\r\n        return ps.nameAddrMap[_name] == address(0);\r\n    }\r\n    \r\n    function getByName(Map storage ps,bytes32 _name)public view returns(address) {\r\n        return ps.nameAddrMap[_name] ;\r\n    }\r\n    \r\n    function getName(Map storage ps) public view returns(bytes32){\r\n        return ps.addrNameMap[msg.sender];\r\n    }\r\n    \r\n    function getName(Map storage ps,address adr) public view returns(bytes32){\r\n        return ps.addrNameMap[adr];\r\n    }    \r\n    \r\n    function getNameByAddr(Map storage ps,address adr) public view returns(bytes32){\r\n        return ps.addrNameMap[adr];\r\n    }    \r\n    \r\n    function getReferrer(Map storage ps,address adr)public view returns(address){\r\n        address refA = ps.referrerMap[adr];\r\n        bytes32 b= ps.addrNameMap[refA];\r\n        return b.length == 0 ? getReferrer(ps,refA) : refA;\r\n    }\r\n    \r\n    function getReferrerName(Map storage ps,address adr)public view returns(bytes32){\r\n        return getNameByAddr(ps,getReferrer(ps,adr));\r\n    }\r\n    \r\n    function setReferrer(Map storage ps,address self,address referrer)internal {\r\n         ps.referrerMap[self] = referrer;\r\n    }\r\n    \r\n    function applyReferrer(Map storage ps,string referrer)internal {\r\n        bytes32 rbs = referrer.nameFilter();\r\n        address referrerAdr = getByName(ps,rbs);\r\n        require(referrerAdr != address(0),\"referrerAdr is null\");\r\n        require(getReferrer(ps,msg.sender) == address(0) ,\"must reffer is null\");\r\n        require(referrerAdr != msg.sender ,\"referrerAdr is self \");\r\n        require(getName(ps).length==0 || getName(ps) == bytes32(0),\"must not reqester\");\r\n        setReferrer(ps,msg.sender,referrerAdr);\r\n    }    \r\n    \r\n    \r\n    function checkSellLimt(Map storage ps,uint256 curP,uint256 max,uint256 period)  internal returns(CommUtils.Countdown) {\r\n        CommUtils.Countdown storage cd =  ps.sellLimeMap[msg.sender];\r\n        ps.sellLimeMap[msg.sender] = cd.freshAndCheck(curP,max,period);\r\n        return ps.sellLimeMap[msg.sender];\r\n    }   \r\n    \r\n    function getSellLimt(Map storage ps) internal view returns (CommUtils.Countdown ) {\r\n        return ps.sellLimeMap[msg.sender];\r\n    }\r\n    \r\n    \r\n    \r\n}\r\n\r\n\r\ncontract IOE is  ERC20, ERC20Detailed {\r\n    \r\n    using CommUtils for CommUtils.Countdown;\r\n    using CommUtils for CommUtils.Float;\r\n    using CommUtils for string;\r\n    using Player for Player.Map;\r\n    \r\n    \r\n\r\n    uint256 private constant MAX_BUY_BY_USER_RATE = 3;\r\n    uint256 private constant MAX_SELL_BY_USER_RATE = 10;\r\n    uint256 private constant MAX_SELL_PER_USER_RATE = 25;\r\n    uint256 private constant SELL_BUY_PERIOD= 60*60*24;\r\n    uint256 private constant tokenDigits = 9;\r\n    uint256 private constant tokenM = 1000000000;\r\n    uint256 private constant INITIAL_SUPPLY = 100000000 * tokenM;\r\n    uint256 private constant X_POW = 2; // y= (exCoefficient * x)^X_POW\r\n    uint256 private constant BUY_BONUS_IN_1000 = 80;\r\n    uint256 private constant SELL_BONUS_IN_1000 = 100;\r\n    uint256 private constant REGESTER_FEE = 0.02 ether;\r\n    uint256 private constant VIP_DISCOUNT_WEIGHT = 3;\r\n    uint256 private constant VIP_INTTO_POOL_WEIGHT = 3;\r\n    uint256 private constant VIP_TOUP_WEIGHT = 3;\r\n    uint256 private constant VIP_RETOUP_RATE_1000 = 110;\r\n    uint256 private constant HELP_MINING_BUY_1000 = 30;\r\n    uint256 private constant HELP_MINING_SELL_1000 = 50;\r\n    uint256 private constant VIP_ALL_WEIGHT = VIP_DISCOUNT_WEIGHT+VIP_INTTO_POOL_WEIGHT+VIP_TOUP_WEIGHT;\r\n\r\n    address private OFFICIAL_ADDR ;\r\n    uint256 private constant MIN_TX_ETHER = 0.001 ether;\r\n    uint256 private providedCount =0;\r\n    uint256 private vipPool = 0;\r\n    Player.Map private players;\r\n    CommUtils.Float exCoefficient;\r\n    CommUtils.Countdown private buyByUserCD ;\r\n    CommUtils.Countdown private sellByUserCD ;\r\n    \r\n\r\n    /**\r\n     * @dev Constructor that gives msg.sender all of existing tokens.\r\n     */\r\n    constructor (address oa) public   ERC20Detailed(\"INTELLIGENT OPERATING SYSTEM EXCHANGE\", \"IOE\",9) {\r\n        _mint(this, INITIAL_SUPPLY);\r\n        require(CommUtils.pwr(10,tokenDigits) == tokenM,\"it`s not same tokenM\");\r\n        exCoefficient = CommUtils.Float(1224744871,8);\r\n        OFFICIAL_ADDR = oa;\r\n    } \r\n    \r\n    \r\n    function getInfo() public view returns(\r\n            uint256, //constractBlance\r\n            uint256, //current providedCount count\r\n            uint256,   // selfTokenBlance\r\n            uint256,  //bounus pool\r\n            uint256,   // contract now\r\n            uint256,    // bonusAt\r\n            bytes32, // registeredName\r\n            bytes32, // refname\r\n            uint256,   //VIP Reward\r\n            address   //offAdd\r\n        ){\r\n        return (\r\n            address(this).balance,\r\n            providedCount, \r\n            balanceOf(msg.sender),\r\n            getBonusPool(),\r\n            now,\r\n            players.bonusAt[msg.sender],\r\n            players.getName(),\r\n            players.getReferrerName(msg.sender),\r\n            players.getAmmount(msg.sender),\r\n            OFFICIAL_ADDR\r\n        );\r\n    }\r\n    \r\n    function getLimtInfo() public view returns(\r\n        uint256 buyMax,uint256 buyCur,uint256 buyStartAt,\r\n        uint256 sellMax , uint256 sellCur , uint256 sellStartAt,\r\n        uint256 sellPerMax, uint256 sellCurPer , uint256 sellPerStartAt\r\n    ){\r\n        CommUtils.Countdown memory bCD = buyByUserCD.freshAndCheck(0,CommUtils.mulRate(INITIAL_SUPPLY-providedCount,MAX_BUY_BY_USER_RATE),SELL_BUY_PERIOD);\r\n        buyMax = bCD.max;\r\n        buyCur = bCD.current;\r\n        buyStartAt = bCD.timestamp;\r\n        CommUtils.Countdown memory sCD  = sellByUserCD.freshAndCheck(0,CommUtils.mulRate(providedCount,MAX_SELL_BY_USER_RATE),SELL_BUY_PERIOD);\r\n        sellMax = sCD.max;\r\n        sellCur = sCD.current;\r\n        sellStartAt = sCD.timestamp;\r\n        CommUtils.Countdown memory perCD = players.getSellLimt().freshAndCheck(0,CommUtils.mulRate(balanceOf(msg.sender),MAX_SELL_PER_USER_RATE),SELL_BUY_PERIOD);\r\n        sellPerMax = perCD.max;\r\n        sellCurPer = perCD.current;\r\n        sellPerStartAt = perCD.timestamp;\r\n    }\r\n    \r\n    \r\n    \r\n    function applyReferrer(string referrer) private {\r\n        if(referrer.isStringEmpty()) return;\r\n        players.applyReferrer(referrer);\r\n    }\r\n    \r\n    function getBuyMinPow(uint256 eth) view public  returns(uint256 pow, uint256 current,uint256 valuePowNum,uint256 valuePowDig){\r\n        pow = X_POW+1;\r\n        current = providedCount;\r\n        CommUtils.Float memory x2Pow = CommUtils.Float(providedCount,tokenDigits).pow(X_POW+1);\r\n        CommUtils.Float memory rr = exCoefficient.pow(X_POW);\r\n        CommUtils.Float memory V3 = CommUtils.Float((X_POW+1) * eth,0);\r\n        CommUtils.Float memory LEFT = V3.divide(rr);\r\n        CommUtils.Float memory value = LEFT.increase( x2Pow);\r\n        valuePowNum = value.number;\r\n        valuePowDig = value.digits;\r\n    }\r\n    \r\n    function getSellMinPow(uint256 eth) view public  returns(uint256 pow, uint256 current,uint256 valuePowNum,uint256 valuePowDig){\r\n        pow = X_POW+1;\r\n        current = providedCount;\r\n        CommUtils.Float memory x2Pow = CommUtils.Float(providedCount,tokenDigits).pow(X_POW+1);\r\n        CommUtils.Float memory rr = exCoefficient.pow(X_POW);\r\n        CommUtils.Float memory V3 = CommUtils.Float((X_POW+1) * eth,0);\r\n        CommUtils.Float memory LEFT = V3.divide(rr);\r\n        (bool ok,CommUtils.Float memory _value) = x2Pow.decrease(LEFT);\r\n        CommUtils.Float memory value = ok ? _value : CommUtils.Float(current,tokenDigits).pow(pow);\r\n        valuePowNum = value.number;\r\n        valuePowDig = value.digits;\r\n    }    \r\n    \r\n    \r\n    function getIntegralAtBound(uint256 start,uint256 end) view public  returns(uint256){\r\n        require(end>start,\"must end > start\");\r\n        uint256 endI = exCoefficient.getIntegral(end,tokenDigits,X_POW);\r\n        uint256 startI = exCoefficient.getIntegral(start,tokenDigits,X_POW);\r\n        require(endI > startI ,\"it`s endI  Integral > startI\");\r\n        return endI - startI;\r\n    }\r\n    \r\n    function buyByUser(uint256 count,string referrer)   public payable {\r\n        buyByUserCD = buyByUserCD.freshAndCheck(count,CommUtils.mulRate(INITIAL_SUPPLY-providedCount,MAX_BUY_BY_USER_RATE),SELL_BUY_PERIOD);\r\n        require(buyByUserCD.passing ,\"it`s over buy max count\");\r\n        applyReferrer(referrer);\r\n        uint256 all = providedCount+count;\r\n        require(all<= INITIAL_SUPPLY,\"count over INITIAL_SUPPLY\");\r\n        uint256 costEth = getIntegralAtBound(providedCount,providedCount+count);\r\n        uint256 reqEth = costEth * (1000+BUY_BONUS_IN_1000) / 1000;\r\n        require(msg.value >= reqEth,\"not enough eth\");\r\n        bonusFee(costEth,reqEth);\r\n        providedCount = all;\r\n        uint256 helpM = CommUtils.mulRate1000(count,HELP_MINING_BUY_1000);\r\n        _transfer(this,msg.sender,count-helpM);\r\n         _transfer(this,OFFICIAL_ADDR,helpM);\r\n        players.refleshBonusAt(msg.sender,balanceOf(msg.sender),count);\r\n        emit OnDealed (msg.sender,true,count,providedCount); \r\n    }\r\n    \r\n    function sellByUser(uint256 count,string referrer)   public  {\r\n        require(providedCount >= count ,\"count over providedCount \");\r\n        sellByUserCD = sellByUserCD.freshAndCheck(count,CommUtils.mulRate(providedCount,MAX_SELL_BY_USER_RATE),SELL_BUY_PERIOD);\r\n        require(sellByUserCD.passing ,\"it`s over sell max count\");\r\n        require(players.checkSellLimt(count,CommUtils.mulRate(balanceOf(msg.sender),MAX_SELL_PER_USER_RATE),SELL_BUY_PERIOD).passing,\"SELL over per user count\");\r\n        applyReferrer(referrer);\r\n        uint256 helpM = CommUtils.mulRate1000(count,HELP_MINING_SELL_1000);\r\n        uint256 realCount = (count-helpM);\r\n        uint256 start = providedCount-realCount;\r\n        uint256 end = providedCount;\r\n        uint256 reqEth = getIntegralAtBound(start,end);\r\n        uint256 costEth = reqEth * (1000- SELL_BONUS_IN_1000) / 1000;\r\n        providedCount -= realCount;\r\n        bonusFee(costEth,reqEth);\r\n        transfer(this,count);\r\n         _transfer(this,OFFICIAL_ADDR,helpM);\r\n        emit OnDealed (msg.sender,false,count,providedCount); \r\n        Player.transferSafe(msg.sender,costEth);\r\n    }\r\n    \r\n    function bonusFee(uint256 costEth,uint256 reqEth) private {\r\n        address referrer = players.getReferrer(msg.sender);\r\n        bool unreged = players.getName().length==0 || players.getName() == bytes32(0);\r\n        if(unreged && referrer==address(0)) return;\r\n        if(reqEth < costEth ) return ;\r\n        uint256 orgFee = reqEth - costEth;\r\n        uint256 repay = orgFee * VIP_DISCOUNT_WEIGHT / VIP_ALL_WEIGHT;\r\n        uint256 toUp = orgFee * VIP_TOUP_WEIGHT / VIP_ALL_WEIGHT;\r\n       // uint256 inPool = orgFee -(repay+toUp);\r\n        players.deposit(msg.sender,repay);\r\n        vipPool += repay;\r\n        if(referrer != address(0)){\r\n            players.deposit(referrer,toUp);\r\n            vipPool += toUp;\r\n        }\r\n    }    \r\n    \r\n    /*  @override  */  \r\n    function transferFrom(address from,address to,uint256 value)public returns (bool){\r\n        players.refleshBonusAt(to,balanceOf(to),value);\r\n        return super.transferFrom(from,to,value);\r\n    }    \r\n    \r\n    /*  @override  */\r\n    function transfer(address to, uint256 value) public returns (bool) {\r\n        players.refleshBonusAt(to,balanceOf(to),value);\r\n        return super.transfer(to,value);\r\n    }    \r\n    \r\n    function getStockBlance() view private returns(uint256){\r\n        return exCoefficient.getIntegral(providedCount,tokenDigits,X_POW);\r\n    }\r\n    \r\n    function getBonusPool() view private returns(uint256){\r\n        return address(this).balance - (getStockBlance()+ vipPool);\r\n    }    \r\n\r\n    function withdrawalBunos(address[] adrs) public  {\r\n        if(adrs.length == 0){\r\n            withdrawalBunos(msg.sender);\r\n        }else{\r\n            for(uint256 i=0;i<adrs.length;i++){\r\n                withdrawalBunos(adrs[i]);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    function withdrawalBunos(address adr) private {\r\n        bool b = players.isOverBonusAt(adr) ;\r\n        if(!b) return;\r\n        uint256 bonus = getBonusPool() * balanceOf(adr) / providedCount;\r\n        Player.transferSafe(adr,bonus);\r\n    }    \r\n    \r\n    function withdrawalVipReward() public  {\r\n        uint256 reward = players.withdrawalAll(msg.sender);\r\n        uint256 toUp = CommUtils.mulRate1000(reward,VIP_RETOUP_RATE_1000);\r\n        uint256 realReward =reward- toUp;\r\n        vipPool -= realReward;\r\n        Player.transferSafe(msg.sender,realReward);\r\n        address referrer = players.getReferrer(msg.sender);\r\n        if(referrer != address(0)){\r\n            players.deposit(referrer,toUp);\r\n        }else{\r\n            vipPool -= toUp;\r\n        }\r\n    }    \r\n    \r\n    \r\n    function isEmptyName(string _n) public view returns(bool){\r\n        return players.isEmptyName(_n.nameFilter());\r\n    }     \r\n    \r\n    function registerName(string name)  public  payable {\r\n        require(msg.value >= REGESTER_FEE,\"fee not enough\");\r\n        players.registerName(name.nameFilter());\r\n    }     \r\n\r\n    // function testWithdrawalAll()  public {\r\n    //     msg.sender.transfer(address( this).balance);\r\n    // }\r\n    \r\n\r\n    event OnDealed(\r\n        address who,\r\n        bool buyed,\r\n        uint256 ammount,\r\n        uint256 newProvidedCount\r\n    );\r\n\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"registerName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"}],\"name\":\"getIntegralAtBound\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_n\",\"type\":\"string\"}],\"name\":\"isEmptyName\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"getSellMinPow\",\"outputs\":[{\"name\":\"pow\",\"type\":\"uint256\"},{\"name\":\"current\",\"type\":\"uint256\"},{\"name\":\"valuePowNum\",\"type\":\"uint256\"},{\"name\":\"valuePowDig\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"string\"}],\"name\":\"buyByUser\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"eth\",\"type\":\"uint256\"}],\"name\":\"getBuyMinPow\",\"outputs\":[{\"name\":\"pow\",\"type\":\"uint256\"},{\"name\":\"current\",\"type\":\"uint256\"},{\"name\":\"valuePowNum\",\"type\":\"uint256\"},{\"name\":\"valuePowDig\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adrs\",\"type\":\"address[]\"}],\"name\":\"withdrawalBunos\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"referrer\",\"type\":\"string\"}],\"name\":\"sellByUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawalVipReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLimtInfo\",\"outputs\":[{\"name\":\"buyMax\",\"type\":\"uint256\"},{\"name\":\"buyCur\",\"type\":\"uint256\"},{\"name\":\"buyStartAt\",\"type\":\"uint256\"},{\"name\":\"sellMax\",\"type\":\"uint256\"},{\"name\":\"sellCur\",\"type\":\"uint256\"},{\"name\":\"sellStartAt\",\"type\":\"uint256\"},{\"name\":\"sellPerMax\",\"type\":\"uint256\"},{\"name\":\"sellCurPer\",\"type\":\"uint256\"},{\"name\":\"sellPerStartAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"oa\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyed\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"ammount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newProvidedCount\",\"type\":\"uint256\"}],\"name\":\"OnDealed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"IOE","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000081d7b5c7365cb1c72165e79565acb0eb11c4a746","Library":"Player:eF99396e68Fdf7F45040a64f9f2915565c8356dF;CommUtils:f0139FAC9684AD7372c190A4deFCAC2b488A79d3","SwarmSource":"bzzr://22a6e187a4f4a8c4af3c9bfd008d2239131a9c3d2ca6beceaddea9d3f0560760"}]}