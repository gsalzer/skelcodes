{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\ninterface TeamJustInterface {\r\n    function requiredSignatures() external view returns(uint256);\r\n    function requiredDevSignatures() external view returns(uint256);\r\n    function adminCount() external view returns(uint256);\r\n    function devCount() external view returns(uint256);\r\n    function adminName(address _who) external view returns(bytes32);\r\n    function isAdmin(address _who) external view returns(bool);\r\n    function isDev(address _who) external view returns(bool);\r\n}\r\ninterface PlayerBookReceiverInterface {\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external;\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name) external;\r\n}\r\n\r\ninterface PlayerBookInterface {\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function isDev(address _who) external view returns(bool);\r\n}\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\nlibrary MSFun {\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DATA SETS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // contact data setup\r\n    struct Data \r\n    {\r\n        mapping (bytes32 => ProposalData) proposal_;\r\n    }\r\n    struct ProposalData \r\n    {\r\n        // a hash of msg.data \r\n        bytes32 msgData;\r\n        // number of signers\r\n        uint256 count;\r\n        // tracking of wither admins have signed\r\n        mapping (address => bool) admin;\r\n        // list of admins who have signed\r\n        mapping (uint256 => address) log;\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // MULTI SIG FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function multiSig(Data storage self, uint256 _requiredSignatures, bytes32 _whatFunction)\r\n        internal\r\n        returns(bool) \r\n    {\r\n        // our proposal key will be a hash of our function name + our contracts address \r\n        // by adding our contracts address to this, we prevent anyone trying to circumvent\r\n        // the proposal's security via external calls.\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        \r\n        // this is just done to make the code more readable.  grabs the signature count\r\n        uint256 _currentCount = self.proposal_[_whatProposal].count;\r\n        \r\n        // store the address of the person sending the function call.  we use msg.sender \r\n        // here as a layer of security.  in case someone imports our contract and tries to \r\n        // circumvent function arguments.  still though, our contract that imports this\r\n        // library and calls multisig, needs to use onlyAdmin modifiers or anyone who\r\n        // calls the function will be a signer. \r\n        address _whichAdmin = msg.sender;\r\n        \r\n        // prepare our msg data.  by storing this we are able to verify that all admins\r\n        // are approving the same argument input to be executed for the function.  we hash \r\n        // it and store in bytes32 so its size is known and comparable\r\n        bytes32 _msgData = keccak256(msg.data);\r\n        \r\n        // check to see if this is a new execution of this proposal or not\r\n        if (_currentCount == 0)\r\n        {\r\n            // if it is, lets record the original signers data\r\n            self.proposal_[_whatProposal].msgData = _msgData;\r\n            \r\n            // record original senders signature\r\n            self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \r\n            \r\n            // update log (used to delete records later, and easy way to view signers)\r\n            // also useful if the calling function wants to give something to a \r\n            // specific signer.  \r\n            self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \r\n            \r\n            // track number of signatures\r\n            self.proposal_[_whatProposal].count += 1;  \r\n            \r\n            // if we now have enough signatures to execute the function, lets\r\n            // return a bool of true.  we put this here in case the required signatures\r\n            // is set to 1.\r\n            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\r\n                return(true);\r\n            }            \r\n        // if its not the first execution, lets make sure the msgData matches\r\n        } else if (self.proposal_[_whatProposal].msgData == _msgData) {\r\n            // msgData is a match\r\n            // make sure admin hasnt already signed\r\n            if (self.proposal_[_whatProposal].admin[_whichAdmin] == false) \r\n            {\r\n                // record their signature\r\n                self.proposal_[_whatProposal].admin[_whichAdmin] = true;        \r\n                \r\n                // update log (used to delete records later, and easy way to view signers)\r\n                self.proposal_[_whatProposal].log[_currentCount] = _whichAdmin;  \r\n                \r\n                // track number of signatures\r\n                self.proposal_[_whatProposal].count += 1;  \r\n            }\r\n            \r\n            // if we now have enough signatures to execute the function, lets\r\n            // return a bool of true.\r\n            // we put this here for a few reasons.  (1) in normal operation, if \r\n            // that last recorded signature got us to our required signatures.  we \r\n            // need to return bool of true.  (2) if we have a situation where the \r\n            // required number of signatures was adjusted to at or lower than our current \r\n            // signature count, by putting this here, an admin who has already signed,\r\n            // can call the function again to make it return a true bool.  but only if\r\n            // they submit the correct msg data\r\n            if (self.proposal_[_whatProposal].count == _requiredSignatures) {\r\n                return(true);\r\n            }\r\n        }\r\n    }\r\n    \r\n    \r\n    // deletes proposal signature data after successfully executing a multiSig function\r\n    function deleteProposal(Data storage self, bytes32 _whatFunction)\r\n        internal\r\n    {\r\n        //done for readability sake\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        address _whichAdmin;\r\n        \r\n        //delete the admins votes & log.   i know for loops are terrible.  but we have to do this \r\n        //for our data stored in mappings.  simply deleting the proposal itself wouldn't accomplish this.\r\n        for (uint256 i=0; i < self.proposal_[_whatProposal].count; i++) {\r\n            _whichAdmin = self.proposal_[_whatProposal].log[i];\r\n            delete self.proposal_[_whatProposal].admin[_whichAdmin];\r\n            delete self.proposal_[_whatProposal].log[i];\r\n        }\r\n        //delete the rest of the data in the record\r\n        delete self.proposal_[_whatProposal];\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // HELPER FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n\r\n    function whatProposal(bytes32 _whatFunction)\r\n        private\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        return(keccak256(abi.encodePacked(_whatFunction,this)));\r\n    }\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // VANITY FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // returns a hashed version of msg.data sent by original signer for any given function\r\n    function checkMsgData (Data storage self, bytes32 _whatFunction)\r\n        internal\r\n        view\r\n        returns (bytes32 msg_data)\r\n    {\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].msgData);\r\n    }\r\n    \r\n    // returns number of signers for any given function\r\n    function checkCount (Data storage self, bytes32 _whatFunction)\r\n        internal\r\n        view\r\n        returns (uint256 signature_count)\r\n    {\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].count);\r\n    }\r\n    \r\n    // returns address of an admin who signed for any given function\r\n    function checkSigner (Data storage self, bytes32 _whatFunction, uint256 _signer)\r\n        internal\r\n        view\r\n        returns (address signer)\r\n    {\r\n        require(_signer > 0, \"MSFun checkSigner failed - 0 not allowed\");\r\n        bytes32 _whatProposal = whatProposal(_whatFunction);\r\n        return (self.proposal_[_whatProposal].log[_signer - 1]);\r\n    }\r\n}\r\ncontract TeamJust is TeamJustInterface {\r\n    address private Jekyll_Island_Inc;\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // SET UP MSFun (note, check signers by name is modified from MSFun sdk)\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    MSFun.Data private msData;\r\n    function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\r\n    function checkData(bytes32 _whatFunction) onlyAdmins() public view returns(bytes32 message_data, uint256 signature_count) {return(MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\r\n    function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyAdmins() public view returns(bytes32, bytes32, bytes32) {return(this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), this.adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DATA SETUP\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    struct Admin {\r\n        bool isAdmin;\r\n        bool isDev;\r\n        bytes32 name;\r\n    }\r\n    mapping (address => Admin) admins_;\r\n    \r\n    uint256 adminCount_;\r\n    uint256 devCount_;\r\n    uint256 requiredSignatures_;\r\n    uint256 requiredDevSignatures_;\r\n    \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // CONSTRUCTOR\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    constructor()\r\n        public\r\n    {\r\n        Jekyll_Island_Inc = msg.sender;\r\n        address inventor = 0x18E90Fc6F70344f53EBd4f6070bf6Aa23e2D748C;\r\n        address mantso   = 0x8b4DA1827932D71759687f925D17F81Fc94e3A9D;\r\n        address justo    = 0x8e0d985f3Ec1857BEc39B76aAabDEa6B31B67d53;\r\n        address sumpunk  = 0x7ac74Fcc1a71b106F12c55ee8F802C9F672Ce40C;\r\n\t\taddress deployer = msg.sender;\r\n        \r\n        admins_[inventor] = Admin(true, true, \"inventor\");\r\n        admins_[mantso]   = Admin(true, true, \"mantso\");\r\n        admins_[justo]    = Admin(true, true, \"justo\");\r\n        admins_[sumpunk]  = Admin(true, true, \"sumpunk\");\r\n\t\tadmins_[deployer] = Admin(true, true, \"deployer\");\r\n        \r\n        adminCount_ = 5;\r\n        devCount_ = 5;\r\n        requiredSignatures_ = 1;\r\n        requiredDevSignatures_ = 1;\r\n    }\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // FALLBACK, SETUP, AND FORWARD\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // there should never be a balance in this contract.  but if someone\r\n    // does stupidly send eth here for some reason.  we can forward it \r\n    // to jekyll island\r\n    function ()\r\n        public\r\n        payable\r\n    {\r\n        Jekyll_Island_Inc.transfer(address(this).balance);\r\n    }\r\n\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // MODIFIERS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    modifier onlyDevs()\r\n    {\r\n        require(admins_[msg.sender].isDev == true, \"onlyDevs failed - msg.sender is not a dev\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyAdmins()\r\n    {\r\n        require(admins_[msg.sender].isAdmin == true, \"onlyAdmins failed - msg.sender is not an admin\");\r\n        _;\r\n    }\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // DEV ONLY FUNCTIONS\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    /**\r\n    * @dev DEV - use this to add admins.  this is a dev only function.\r\n    * @param _who - address of the admin you wish to add\r\n    * @param _name - admins name\r\n    * @param _isDev - is this admin also a dev?\r\n    */\r\n    function addAdmin(address _who, bytes32 _name, bool _isDev)\r\n        public\r\n        onlyDevs()\r\n    {\r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"addAdmin\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"addAdmin\");\r\n            \r\n            // must check this so we dont mess up admin count by adding someone\r\n            // who is already an admin\r\n            if (admins_[_who].isAdmin == false) \r\n            { \r\n                \r\n                // set admins flag to true in admin mapping\r\n                admins_[_who].isAdmin = true;\r\n        \r\n                // adjust admin count and required signatures\r\n                adminCount_ += 1;\r\n                requiredSignatures_ += 1;\r\n            }\r\n            \r\n            // are we setting them as a dev?\r\n            // by putting this outside the above if statement, we can upgrade existing\r\n            // admins to devs.\r\n            if (_isDev == true) \r\n            {\r\n                // bestow the honored dev status\r\n                admins_[_who].isDev = _isDev;\r\n                \r\n                // increase dev count and required dev signatures\r\n                devCount_ += 1;\r\n                requiredDevSignatures_ += 1;\r\n            }\r\n        }\r\n        \r\n        // by putting this outside the above multisig, we can allow easy name changes\r\n        // without having to bother with multisig.  this will still create a proposal though\r\n        // so use the deleteAnyProposal to delete it if you want to\r\n        admins_[_who].name = _name;\r\n    }\r\n\r\n    /**\r\n    * @dev DEV - use this to remove admins. this is a dev only function.\r\n    * -requirements: never less than 1 admin\r\n    *                never less than 1 dev\r\n    *                never less admins than required signatures\r\n    *                never less devs than required dev signatures\r\n    * @param _who - address of the admin you wish to remove\r\n    */\r\n    function removeAdmin(address _who)\r\n        public\r\n        onlyDevs()\r\n    {\r\n        // we can put our requires outside the multisig, this will prevent\r\n        // creating a proposal that would never pass checks anyway.\r\n        require(adminCount_ > 1, \"removeAdmin failed - cannot have less than 2 admins\");\r\n        require(adminCount_ >= requiredSignatures_, \"removeAdmin failed - cannot have less admins than number of required signatures\");\r\n        if (admins_[_who].isDev == true)\r\n        {\r\n            require(devCount_ > 1, \"removeAdmin failed - cannot have less than 2 devs\");\r\n            require(devCount_ >= requiredDevSignatures_, \"removeAdmin failed - cannot have less devs than number of required dev signatures\");\r\n        }\r\n        \r\n        // checks passed\r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"removeAdmin\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"removeAdmin\");\r\n            \r\n            // must check this so we dont mess up admin count by removing someone\r\n            // who wasnt an admin to start with\r\n            if (admins_[_who].isAdmin == true) {  \r\n                \r\n                //set admins flag to false in admin mapping\r\n                admins_[_who].isAdmin = false;\r\n                \r\n                //adjust admin count and required signatures\r\n                adminCount_ -= 1;\r\n                if (requiredSignatures_ > 1) \r\n                {\r\n                    requiredSignatures_ -= 1;\r\n                }\r\n            }\r\n            \r\n            // were they also a dev?\r\n            if (admins_[_who].isDev == true) {\r\n                \r\n                //set dev flag to false\r\n                admins_[_who].isDev = false;\r\n                \r\n                //adjust dev count and required dev signatures\r\n                devCount_ -= 1;\r\n                if (requiredDevSignatures_ > 1) \r\n                {\r\n                    requiredDevSignatures_ -= 1;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev DEV - change the number of required signatures.  must be between\r\n    * 1 and the number of admins.  this is a dev only function\r\n    * @param _howMany - desired number of required signatures\r\n    */\r\n    function changeRequiredSignatures(uint256 _howMany)\r\n        public\r\n        onlyDevs()\r\n    {  \r\n        // make sure its between 1 and number of admins\r\n        require(_howMany > 0 && _howMany <= adminCount_, \"changeRequiredSignatures failed - must be between 1 and number of admins\");\r\n        \r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"changeRequiredSignatures\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"changeRequiredSignatures\");\r\n            \r\n            // store new setting.\r\n            requiredSignatures_ = _howMany;\r\n        }\r\n    }\r\n    \r\n    /**\r\n    * @dev DEV - change the number of required dev signatures.  must be between\r\n    * 1 and the number of devs.  this is a dev only function\r\n    * @param _howMany - desired number of required dev signatures\r\n    */\r\n    function changeRequiredDevSignatures(uint256 _howMany)\r\n        public\r\n        onlyDevs()\r\n    {  \r\n        // make sure its between 1 and number of admins\r\n        require(_howMany > 0 && _howMany <= devCount_, \"changeRequiredDevSignatures failed - must be between 1 and number of devs\");\r\n        \r\n        if (MSFun.multiSig(msData, requiredDevSignatures_, \"changeRequiredDevSignatures\") == true) \r\n        {\r\n            MSFun.deleteProposal(msData, \"changeRequiredDevSignatures\");\r\n            \r\n            // store new setting.\r\n            requiredDevSignatures_ = _howMany;\r\n        }\r\n    }\r\n\r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    // EXTERNAL FUNCTIONS \r\n    //^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n    function requiredSignatures() external view returns(uint256) {return(requiredSignatures_);}\r\n    function requiredDevSignatures() external view returns(uint256) {return(requiredDevSignatures_);}\r\n    function adminCount() external view returns(uint256) {return(adminCount_);}\r\n    function devCount() external view returns(uint256) {return(devCount_);}\r\n    function adminName(address _who) external view returns(bytes32) {return(admins_[_who].name);}\r\n    function isAdmin(address _who) external view returns(bool) {return(admins_[_who].isAdmin);}\r\n    function isDev(address _who) external view returns(bool) {return(admins_[_who].isDev);}\r\n}\r\ncontract PlayerBook is PlayerBookInterface {\r\n    using NameFilter for string;\r\n    using SafeMath for uint256;\r\n\r\n    address private Jekyll_Island_Inc;\r\n    address public teamJust;// = new TeamJustInterface();\r\n\r\n    MSFun.Data private msData;\r\n\r\n    function multiSigDev(bytes32 _whatFunction) private returns (bool) {return (MSFun.multiSig(msData, TeamJustInterface(teamJust).requiredDevSignatures(), _whatFunction));}\r\n\r\n    function deleteProposal(bytes32 _whatFunction) private {MSFun.deleteProposal(msData, _whatFunction);}\r\n\r\n    function deleteAnyProposal(bytes32 _whatFunction) onlyDevs() public {MSFun.deleteProposal(msData, _whatFunction);}\r\n\r\n    function checkData(bytes32 _whatFunction) onlyDevs() public view returns (bytes32, uint256) {return (MSFun.checkMsgData(msData, _whatFunction), MSFun.checkCount(msData, _whatFunction));}\r\n\r\n    function checkSignersByAddress(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyDevs() public view returns (address, address, address) {return (MSFun.checkSigner(msData, _whatFunction, _signerA), MSFun.checkSigner(msData, _whatFunction, _signerB), MSFun.checkSigner(msData, _whatFunction, _signerC));}\r\n\r\n    function checkSignersByName(bytes32 _whatFunction, uint256 _signerA, uint256 _signerB, uint256 _signerC) onlyDevs() public view returns (bytes32, bytes32, bytes32) {return (TeamJustInterface(teamJust).adminName(MSFun.checkSigner(msData, _whatFunction, _signerA)), TeamJustInterface(teamJust).adminName(MSFun.checkSigner(msData, _whatFunction, _signerB)), TeamJustInterface(teamJust).adminName(MSFun.checkSigner(msData, _whatFunction, _signerC)));}\r\n    //==============================================================================\r\n    //     _| _ _|_ _    _ _ _|_    _   .\r\n    //    (_|(_| | (_|  _\\(/_ | |_||_)  .\r\n    //=============================|================================================\r\n    uint256 public registrationFee_ = 10 finney;            // price to register a name\r\n    mapping(uint256 => address) public games_;  // mapping of our game interfaces for sending your account info to games\r\n    mapping(address => bytes32) public gameNames_;          // lookup a games name\r\n    mapping(address => uint256) public gameIDs_;            // lokup a games ID\r\n    uint256 public gID_;        // total number of games\r\n    uint256 public pID_;        // total number of players\r\n    mapping(address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address\r\n    mapping(bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name\r\n    mapping(uint256 => Player) public plyr_;               // (pID => data) player data\r\n    mapping(uint256 => mapping(bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amoungst any name you own)\r\n    mapping(uint256 => mapping(uint256 => bytes32)) public plyrNameList_; // (pID => nameNum => name) list of names a player owns\r\n    struct Player {\r\n        address addr;\r\n        bytes32 name;\r\n        uint256 laff;\r\n        uint256 names;\r\n    }\r\n\r\n    address public owner;\r\n\r\n    function setTeam(address _teamJust) external {\r\n        require(msg.sender == owner, 'only dev!');\r\n        require(address(teamJust) == address(0), 'already set!');\r\n        teamJust = _teamJust;\r\n    }\r\n    //==============================================================================\r\n    //     _ _  _  __|_ _    __|_ _  _  .\r\n    //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n    //==============================================================================\r\n    constructor()\r\n    public\r\n    {\r\n        owner = msg.sender;\r\n        // premine the dev names (sorry not sorry)\r\n        // No keys are purchased with this method, it's simply locking our addresses,\r\n        // PID's and names for referral codes.\r\n        plyr_[1].addr = msg.sender;\r\n        plyr_[1].name = \"wq\";\r\n        plyr_[1].names = 1;\r\n        pIDxAddr_[msg.sender] = 1;\r\n        pIDxName_[\"wq\"] = 1;\r\n        plyrNames_[1][\"wq\"] = true;\r\n        plyrNameList_[1][1] = \"wq\";\r\n\r\n        pID_ = 1;\r\n        Jekyll_Island_Inc = msg.sender;\r\n    }\r\n    //==============================================================================\r\n    //     _ _  _  _|. |`. _  _ _  .\r\n    //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n    //==============================================================================\r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyDevs()\r\n    {\r\n        require(TeamJustInterface(teamJust).isDev(msg.sender) == true, \"msg sender is not a dev\");\r\n        _;\r\n    }\r\n\r\n    modifier isRegisteredGame()\r\n    {\r\n        require(gameIDs_[msg.sender] != 0);\r\n        _;\r\n    }\r\n    //==============================================================================\r\n    //     _    _  _ _|_ _  .\r\n    //    (/_\\/(/_| | | _\\  .\r\n    //==============================================================================\r\n    // fired whenever a player registers a name\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n    //==============================================================================\r\n    //     _  _ _|__|_ _  _ _  .\r\n    //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan)\r\n    //=====_|=======================================================================\r\n    function checkIfNameValid(string _nameStr)\r\n    public\r\n    view\r\n    returns (bool)\r\n    {\r\n        bytes32 _name = _nameStr.nameFilter();\r\n        if (pIDxName_[_name] == 0)\r\n            return (true);\r\n        else\r\n            return (false);\r\n    }\r\n    //==============================================================================\r\n    //     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n    //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n    //====|=========================================================================\r\n    /**\r\n     * @dev registers a name.  UI will always display the last name you registered.\r\n     * but you will still own all previously registered names to use as affiliate \r\n     * links.\r\n     * - must pay a registration fee.\r\n     * - name must be unique\r\n     * - names will be converted to lowercase\r\n     * - name cannot start or end with a space \r\n     * - cannot have more than 1 space in a row\r\n     * - cannot be only numbers\r\n     * - cannot start with 0x \r\n     * - name must be at least 1 char\r\n     * - max length of 32 characters long\r\n     * - allowed characters: a-z, 0-9, and space\r\n     * -functionhash- 0x921dec21 (using ID for affiliate)\r\n     * -functionhash- 0x3ddd4698 (using address for affiliate)\r\n     * -functionhash- 0x685ffd83 (using name for affiliate)\r\n     * @param _nameString players desired name\r\n     * @param _affCode affiliate ID, address, or name of who refered you\r\n     * @param _all set to true if you want this to push your info to all games \r\n     * (this might cost a lot of gas)\r\n     */\r\n    function registerNameXID(string _nameString, uint256 _affCode, bool _all)\r\n    isHuman()\r\n    public\r\n    payable\r\n    {\r\n        // make sure name fees paid\r\n        require(msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n\r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n\r\n        // set up address \r\n        address _addr = msg.sender;\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the \r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        if (_affCode != 0 && _affCode != plyr_[_pID].laff && _affCode != _pID)\r\n        {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affCode;\r\n        } else if (_affCode == _pID) {\r\n            _affCode = 0;\r\n        }\r\n\r\n        // register name \r\n        registerNameCore(_pID, _addr, _affCode, _name, _isNewPlayer, _all);\r\n    }\r\n\r\n    function registerNameXaddr(string _nameString, address _affCode, bool _all)\r\n    isHuman()\r\n    public\r\n    payable\r\n    {\r\n        // make sure name fees paid\r\n        require(msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n\r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n\r\n        // set up address \r\n        address _addr = msg.sender;\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != address(0) && _affCode != _addr)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n\r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n\r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n    }\r\n\r\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all)\r\n    isHuman()\r\n    public\r\n    payable\r\n    {\r\n        // make sure name fees paid\r\n        require(msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n\r\n        // filter name + condition checks\r\n        bytes32 _name = NameFilter.nameFilter(_nameString);\r\n\r\n        // set up address \r\n        address _addr = msg.sender;\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != \"\" && _affCode != _name)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxName_[_affCode];\r\n\r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n\r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n    }\r\n\r\n    /**\r\n     * @dev players, if you registered a profile, before a game was released, or\r\n     * set the all bool to false when you registered, use this function to push\r\n     * your profile to a single game.  also, if you've  updated your name, you\r\n     * can use this to push your name to games of your choosing.\r\n     * -functionhash- 0x81c5b206\r\n     * @param _gameID game id \r\n     */\r\n    function addMeToGame(uint256 _gameID)\r\n    isHuman()\r\n    public\r\n    {\r\n        require(_gameID <= gID_, \"silly player, that game doesn't exist yet\");\r\n        address _addr = msg.sender;\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        require(_pID != 0, \"hey there buddy, you dont even have an account\");\r\n        uint256 _totalNames = plyr_[_pID].names;\r\n\r\n        // add players profile and most recent name\r\n        PlayerBookReceiverInterface(games_[_gameID]).receivePlayerInfo(_pID, _addr, plyr_[_pID].name, plyr_[_pID].laff);\r\n\r\n        // add list of all names\r\n        if (_totalNames > 1)\r\n            for (uint256 ii = 1; ii <= _totalNames; ii++)\r\n                PlayerBookReceiverInterface(games_[_gameID]).receivePlayerNameList(_pID, plyrNameList_[_pID][ii]);\r\n    }\r\n\r\n    /**\r\n     * @dev players, use this to push your player profile to all registered games.\r\n     * -functionhash- 0x0c6940ea\r\n     */\r\n    function addMeToAllGames()\r\n    isHuman()\r\n    public\r\n    {\r\n        address _addr = msg.sender;\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        require(_pID != 0, \"hey there buddy, you dont even have an account\");\r\n        uint256 _laff = plyr_[_pID].laff;\r\n        uint256 _totalNames = plyr_[_pID].names;\r\n        bytes32 _name = plyr_[_pID].name;\r\n\r\n        for (uint256 i = 1; i <= gID_; i++)\r\n        {\r\n            PlayerBookReceiverInterface(games_[i]).receivePlayerInfo(_pID, _addr, _name, _laff);\r\n            if (_totalNames > 1)\r\n                for (uint256 ii = 1; ii <= _totalNames; ii++)\r\n                    PlayerBookReceiverInterface(games_[i]).receivePlayerNameList(_pID, plyrNameList_[_pID][ii]);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev players use this to change back to one of your old names.  tip, you'll\r\n     * still need to push that info to existing games.\r\n     * -functionhash- 0xb9291296\r\n     * @param _nameString the name you want to use \r\n     */\r\n    function useMyOldName(string _nameString)\r\n    isHuman()\r\n    public\r\n    {\r\n        // filter name, and get pID\r\n        bytes32 _name = _nameString.nameFilter();\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        // make sure they own the name \r\n        require(plyrNames_[_pID][_name] == true, \"umm... thats not a name you own\");\r\n\r\n        // update their current name \r\n        plyr_[_pID].name = _name;\r\n    }\r\n\r\n    //==============================================================================\r\n    //     _ _  _ _   | _  _ . _  .\r\n    //    (_(_)| (/_  |(_)(_||(_  .\r\n    //=====================_|=======================================================\r\n    function registerNameCore(uint256 _pID, address _addr, uint256 _affID, bytes32 _name, bool _isNewPlayer, bool _all)\r\n    private\r\n    {\r\n        // if names already has been used, require that current msg sender owns the name\r\n        if (pIDxName_[_name] != 0)\r\n            require(plyrNames_[_pID][_name] == true, \"sorry that names already taken\");\r\n\r\n        // add name to player profile, registry, and name book\r\n        plyr_[_pID].name = _name;\r\n        pIDxName_[_name] = _pID;\r\n        if (plyrNames_[_pID][_name] == false)\r\n        {\r\n            plyrNames_[_pID][_name] = true;\r\n            plyr_[_pID].names++;\r\n            plyrNameList_[_pID][plyr_[_pID].names] = _name;\r\n        }\r\n\r\n        // registration fee goes directly to community rewards\r\n        Jekyll_Island_Inc.transfer(address(this).balance);\r\n\r\n        // push player info to games\r\n        if (_all == true)\r\n            for (uint256 i = 1; i <= gID_; i++)\r\n                PlayerBookReceiverInterface(games_[i]).receivePlayerInfo(_pID, _addr, _name, _affID);\r\n\r\n        // fire event\r\n        emit onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, msg.value, now);\r\n    }\r\n    //==============================================================================\r\n    //    _|_ _  _ | _  .\r\n    //     | (_)(_)|_\\  .\r\n    //==============================================================================\r\n    function determinePID(address _addr)\r\n    private\r\n    returns (bool)\r\n    {\r\n        if (pIDxAddr_[_addr] == 0)\r\n        {\r\n            pID_++;\r\n            pIDxAddr_[_addr] = pID_;\r\n            plyr_[pID_].addr = _addr;\r\n\r\n            // set the new player bool to true\r\n            return (true);\r\n        } else {\r\n            return (false);\r\n        }\r\n    }\r\n    //==============================================================================\r\n    //   _   _|_ _  _ _  _ |   _ _ || _  .\r\n    //  (/_>< | (/_| | |(_||  (_(_|||_\\  .\r\n    //==============================================================================\r\n    function getPlayerID(address _addr)\r\n    isRegisteredGame()\r\n    external\r\n    returns (uint256)\r\n    {\r\n        determinePID(_addr);\r\n        return (pIDxAddr_[_addr]);\r\n    }\r\n\r\n    function getPlayerName(uint256 _pID)\r\n    external\r\n    view\r\n    returns (bytes32)\r\n    {\r\n        return (plyr_[_pID].name);\r\n    }\r\n\r\n    function getPlayerLAff(uint256 _pID)\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return (plyr_[_pID].laff);\r\n    }\r\n\r\n    function getPlayerAddr(uint256 _pID)\r\n    external\r\n    view\r\n    returns (address)\r\n    {\r\n        return (plyr_[_pID].addr);\r\n    }\r\n\r\n    function getNameFee()\r\n    external\r\n    view\r\n    returns (uint256)\r\n    {\r\n        return (registrationFee_);\r\n    }\r\n\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all)\r\n    isRegisteredGame()\r\n    external\r\n    payable\r\n    returns (bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require(msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given, no new affiliate code was given, or the \r\n        // player tried to use their own pID as an affiliate code, lolz\r\n        uint256 _affID = _affCode;\r\n        if (_affID != 0 && _affID != plyr_[_pID].laff && _affID != _pID)\r\n        {\r\n            // update last affiliate \r\n            plyr_[_pID].laff = _affID;\r\n        } else if (_affID == _pID) {\r\n            _affID = 0;\r\n        }\r\n\r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n\r\n        return (_isNewPlayer, _affID);\r\n    }\r\n\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all)\r\n    isRegisteredGame()\r\n    external\r\n    payable\r\n    returns (bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require(msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != address(0) && _affCode != _addr)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxAddr_[_affCode];\r\n\r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n\r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n\r\n        return (_isNewPlayer, _affID);\r\n    }\r\n\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all)\r\n    isRegisteredGame()\r\n    external\r\n    payable\r\n    returns (bool, uint256)\r\n    {\r\n        // make sure name fees paid\r\n        require(msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\");\r\n\r\n        // set up our tx event data and determine if player is new or not\r\n        bool _isNewPlayer = determinePID(_addr);\r\n\r\n        // fetch player id\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        // manage affiliate residuals\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        uint256 _affID;\r\n        if (_affCode != \"\" && _affCode != _name)\r\n        {\r\n            // get affiliate ID from aff Code \r\n            _affID = pIDxName_[_affCode];\r\n\r\n            // if affID is not the same as previously stored \r\n            if (_affID != plyr_[_pID].laff)\r\n            {\r\n                // update last affiliate\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n\r\n        // register name \r\n        registerNameCore(_pID, _addr, _affID, _name, _isNewPlayer, _all);\r\n\r\n        return (_isNewPlayer, _affID);\r\n    }\r\n\r\n    //==============================================================================\r\n    //   _ _ _|_    _   .\r\n    //  _\\(/_ | |_||_)  .\r\n    //=============|================================================================\r\n    function addGame(address _gameAddress, bytes32 _gameNameStr)\r\n    onlyDevs()\r\n    external\r\n    {\r\n        require(gameIDs_[_gameAddress] == 0, \"derp, that games already been registered\");\r\n\r\n        if (multiSigDev(\"addGame\") == true)\r\n        {deleteProposal(\"addGame\");\r\n            gID_++;\r\n            bytes32 _name = _gameNameStr;\r\n            gameIDs_[_gameAddress] = gID_;\r\n            gameNames_[_gameAddress] = _name;\r\n            games_[gID_] = _gameAddress;\r\n\r\n//            PlayerBookReceiverInterface(games_[gID_]).receivePlayerInfo(1, plyr_[1].addr, plyr_[1].name, 0);\r\n\r\n        }\r\n    }\r\n\r\n    function setRegistrationFee(uint256 _fee)\r\n    onlyDevs()\r\n    public\r\n    {\r\n        if (multiSigDev(\"setRegistrationFee\") == true)\r\n        {deleteProposal(\"setRegistrationFee\");\r\n            registrationFee_ = _fee;\r\n        }\r\n    }\r\n\r\n    function isDev(address _who) external view returns(bool) {return TeamJustInterface(teamJust).isDev(_who);}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_teamJust\",\"type\":\"address\"}],\"name\":\"setTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"isDev\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addMeToAllGames\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"}],\"name\":\"deleteAnyProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamJust\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registrationFee_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNameFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_nameStr\",\"type\":\"string\"}],\"name\":\"checkIfNameValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXnameFromDapp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"},{\"name\":\"_signerA\",\"type\":\"uint256\"},{\"name\":\"_signerB\",\"type\":\"uint256\"},{\"name\":\"_signerC\",\"type\":\"uint256\"}],\"name\":\"checkSignersByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameID\",\"type\":\"uint256\"}],\"name\":\"addMeToGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrNameList_\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"}],\"name\":\"checkData\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddrFromDapp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"useMyOldName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXIDFromDapp\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint256\"}],\"name\":\"setRegistrationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gameAddress\",\"type\":\"address\"},{\"name\":\"_gameNameStr\",\"type\":\"bytes32\"}],\"name\":\"addGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"gameIDs_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"names\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerLAff\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_whatFunction\",\"type\":\"bytes32\"},{\"name\":\"_signerA\",\"type\":\"uint256\"},{\"name\":\"_signerB\",\"type\":\"uint256\"},{\"name\":\"_signerC\",\"type\":\"uint256\"}],\"name\":\"checkSignersByName\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"}]","ContractName":"PlayerBook","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://1110cd346ab02e44724cd0d688f016f137e756c88df0edd0339df3d06b156d81"}]}