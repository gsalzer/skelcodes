{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract Town {\r\n    struct Position {\r\n        int x;\r\n        int y;\r\n    }\r\n    \r\n    uint movePrice = 0.001 ether;\r\n    uint attackPrice = 0.005 ether;\r\n    uint spawnPrice = 0.01 ether;\r\n    uint fee = 20;\r\n    uint refFee = 10;\r\n    \r\n    mapping (address => bool) internal users;\r\n    mapping (address => bool) internal ingame;\r\n    mapping (address => address) public referrers;\r\n    mapping (int => mapping (int => address)) public field;\r\n    mapping (address => Position) public positions;\r\n    address support = msg.sender;\r\n    \r\n    uint private seed;\r\n    \r\n    event UserPlaced(address user, int x, int y);\r\n    event UserAttacked(address user, address by);\r\n    event UserRemoved(address user);\r\n    \r\n    /* Converts uint256 to bytes32 */\r\n    function toBytes(uint256 x) internal pure returns (bytes b) {\r\n        b = new bytes(32);\r\n        assembly {\r\n            mstore(add(b, 32), x)\r\n        }\r\n    }\r\n    \r\n    function random(uint lessThan) internal returns (uint) {\r\n        seed += block.timestamp + uint(msg.sender);\r\n        return uint(sha256(toBytes(uint(blockhash(block.number - 1)) + seed))) % lessThan;\r\n    }\r\n    \r\n    function bytesToAddress(bytes source) internal pure returns (address parsedAddress) {\r\n        assembly {\r\n            parsedAddress := mload(add(source,0x14))\r\n        }\r\n        return parsedAddress;\r\n    }\r\n    \r\n    function requireEmptyCell(int x, int y) internal view {\r\n        require(field[x][y] == 0x0);\r\n    }\r\n    \r\n    function moveTo(int diffX, int diffY) internal {\r\n        Position storage p = positions[msg.sender];\r\n        int _x = p.x + diffX;\r\n        int _y = p.y + diffY;\r\n        requireEmptyCell(_x, _y);\r\n        delete field[p.x][p.y];\r\n        field[_x][_y] = msg.sender;\r\n        positions[msg.sender] = Position(_x, _y);\r\n    }\r\n    \r\n    function removeUserFrom(address user, int x, int y) internal {\r\n        delete ingame[user];\r\n        delete field[x][y];\r\n        delete positions[user];\r\n    }\r\n    \r\n    function tryAttack(int diffX, int diffY) internal returns (address) {\r\n        Position storage p = positions[msg.sender];\r\n        int _x = p.x + diffX;\r\n        int _y = p.y + diffY;\r\n        address enemy = field[_x][_y];\r\n        if (enemy != 0x0) {\r\n            removeUserFrom(enemy, _x, _y);\r\n            msg.sender.transfer(address(this).balance / 2);\r\n            return enemy;\r\n        } else {\r\n            return 0x0;\r\n        }\r\n    }\r\n    \r\n    function fees() internal {\r\n        support.transfer(msg.value * fee / 100);\r\n        if (referrers[msg.sender] != 0x0) {\r\n            referrers[msg.sender].transfer(msg.value * refFee / 100);\r\n        }\r\n    }\r\n\r\n    function move(uint8 dir) external payable {\r\n        require(ingame[msg.sender]);\r\n        require(msg.value == movePrice);\r\n        require(dir < 4);\r\n        fees();\r\n        if (dir == 0) {\r\n            moveTo(0, -1);\r\n        } else if (dir == 1) {\r\n            moveTo(1, 0);\r\n        } else if (dir == 2) {\r\n            moveTo(0, 1);\r\n        } else {\r\n            moveTo(-1, 0);\r\n        }\r\n        emit UserPlaced(msg.sender, positions[msg.sender].x, positions[msg.sender].y);\r\n    }\r\n    \r\n    function attack(uint8 dir) external payable {\r\n        require(ingame[msg.sender]);\r\n        require(msg.value == attackPrice);\r\n        require(dir < 4);\r\n        fees();\r\n        address enemy;\r\n        if (dir == 0) {\r\n            enemy = tryAttack(0, -1);\r\n        } else if (dir == 1) {\r\n            enemy = tryAttack(1, 0);\r\n        } else if (dir == 2) {\r\n            enemy = tryAttack(0, 1);\r\n        } else {\r\n            enemy = tryAttack(-1, 0);\r\n        }\r\n        emit UserAttacked(enemy, msg.sender);\r\n        emit UserRemoved(enemy);\r\n    }\r\n    \r\n    function () external payable {\r\n        require(!ingame[msg.sender]);\r\n        require(msg.value == spawnPrice);\r\n        ingame[msg.sender] = true;\r\n        if (!users[msg.sender]) {\r\n            users[msg.sender] = true;\r\n            address referrerAddress = bytesToAddress(bytes(msg.data));\r\n            require(referrerAddress != msg.sender);     \r\n            if (users[referrerAddress]) {\r\n                referrers[msg.sender] = referrerAddress;\r\n            }\r\n        }\r\n        \r\n        fees();\r\n        \r\n        int x = int(random(20)) - 10;\r\n        int y = int(random(20)) - 10;\r\n        \r\n        while (field[x][y] != 0x0) {\r\n            x += int(random(2)) * 2 - 1;\r\n            y += int(random(2)) * 2 - 1;\r\n        }\r\n        \r\n        field[x][y] = msg.sender;\r\n        positions[msg.sender] = Position(x, y);\r\n        \r\n        emit UserPlaced(msg.sender, x, y);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"dir\",\"type\":\"uint8\"}],\"name\":\"attack\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrers\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"positions\",\"outputs\":[{\"name\":\"x\",\"type\":\"int256\"},{\"name\":\"y\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dir\",\"type\":\"uint8\"}],\"name\":\"move\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"int256\"},{\"name\":\"\",\"type\":\"int256\"}],\"name\":\"field\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"x\",\"type\":\"int256\"},{\"indexed\":false,\"name\":\"y\",\"type\":\"int256\"}],\"name\":\"UserPlaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"UserAttacked\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"}],\"name\":\"UserRemoved\",\"type\":\"event\"}]","ContractName":"Town","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://648048cd80af6e0bf5007f811202df029ef9dc39ee47d09000d429d5ee768cdd"}]}