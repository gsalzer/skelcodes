{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/Genetic.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.23;\r\n\r\n\r\ncontract Genetic {\r\n\r\n    // TODO mutations\r\n    // maximum number of random mutations per chromatid\r\n    uint8 public constant R = 5;\r\n\r\n    // solhint-disable-next-line function-max-lines\r\n    function breed(uint256[2] mother, uint256[2] father, uint256 seed) internal view returns (uint256[2] memOffset) {\r\n        // Meiosis I: recombining alleles (Chromosomal crossovers)\r\n\r\n        // Note about optimization I: no cell duplication,\r\n        //  producing 2 seeds/eggs per cell is enough, instead of 4 (like humans do)\r\n\r\n        // Note about optimization II: crossovers happen,\r\n        //  but only 1 side of the result is computed,\r\n        //  as the other side will not affect anything.\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // allocate output\r\n            // 1) get the pointer to our memory\r\n            memOffset := mload(0x40)\r\n            // 2) Change the free-memory pointer to keep our memory\r\n            //     (we will only use 64 bytes: 2 values of 256 bits)\r\n            mstore(0x40, add(memOffset, 64))\r\n\r\n\r\n            // Put seed in scratchpad 0\r\n            mstore(0x0, seed)\r\n            // Also use the timestamp, best we could do to increase randomness\r\n            //  without increasing costs dramatically. (Trade-off)\r\n            mstore(0x20, timestamp)\r\n\r\n            // Hash it for a universally random bitstring.\r\n            let hash := keccak256(0, 64)\r\n\r\n            // Byzantium VM does not support shift opcodes, will be introduced in Constantinople.\r\n            // Soldity itself, in non-assembly, also just uses other opcodes to simulate it.\r\n            // Optmizer should take care of inlining, just declare shiftR ourselves here.\r\n            // Where possible, better optimization is applied to make it cheaper.\r\n            function shiftR(value, offset) -> result {\r\n                result := div(value, exp(2, offset))\r\n            }\r\n\r\n            // solhint-disable max-line-length\r\n            // m_context << Instruction::SWAP1 << u256(2) << Instruction::EXP << Instruction::SWAP1 << (c_leftSigned ? Instruction::SDIV : Instruction::DIV);\r\n\r\n            // optimization: although one side consists of multiple chromatids,\r\n            //  we handle them just as one long chromatid:\r\n            //  only difference is that a crossover in chromatid i affects chromatid i+1.\r\n            //  No big deal, order and location is random anyway\r\n            function processSide(fatherSrc, motherSrc, rngSrc) -> result {\r\n\r\n                {\r\n                    // initial rngSrc bit length: 254 bits\r\n\r\n                    // Run the crossovers\r\n                    // =====================================================\r\n\r\n                    // Pick some crossovers\r\n                    // Each crossover is spaced ~64 bits on average.\r\n                    // To achieve this, we get a random 7 bit number, [0, 128), for each crossover.\r\n\r\n                    // 256 / 64 = 4, we need 4 crossovers,\r\n                    //  and will have 256 / 127 = 2 at least (rounded down).\r\n\r\n                    // Get one bit determining if we should pick DNA from the father,\r\n                    //  or from the mother.\r\n                    // This changes every crossover. (by swapping father and mother)\r\n                    {\r\n                        if eq(and(rngSrc, 0x1), 0) {\r\n                            // Swap mother and father,\r\n                            // create a temporary variable (code golf XOR swap costs more in gas)\r\n                            let temp := fatherSrc\r\n                            fatherSrc := motherSrc\r\n                            motherSrc := temp\r\n                        }\r\n\r\n                        // remove the bit from rng source, 253 rng bits left\r\n                        rngSrc := shiftR(rngSrc, 1)\r\n                    }\r\n\r\n                    // Don't push/pop this all the time, we have just enough space on stack.\r\n                    let mask := 0\r\n\r\n                    // Cap at 4 crossovers, no more than that.\r\n                    let cap := 0\r\n                    let crossoverLen := and(rngSrc, 0x7f) // bin: 1111111 (7 bits ON)\r\n                    // remove bits from hash, e.g. 254 - 7 = 247 left.\r\n                    rngSrc := shiftR(rngSrc, 7)\r\n                    let crossoverPos := crossoverLen\r\n\r\n                    // optimization: instead of shifting with an opcode we don't have until Constantinople,\r\n                    //  keep track of the a shifted number, updated using multiplications.\r\n                    let crossoverPosLeading1 := 1\r\n\r\n                    // solhint-disable-next-line no-empty-blocks\r\n                    for { } and(lt(crossoverPos, 256), lt(cap, 4)) {\r\n\r\n                        crossoverLen := and(rngSrc, 0x7f) // bin: 1111111 (7 bits ON)\r\n                        // remove bits from hash, e.g. 254 - 7 = 247 left.\r\n                        rngSrc := shiftR(rngSrc, 7)\r\n\r\n                        crossoverPos := add(crossoverPos, crossoverLen)\r\n\r\n                        cap := add(cap, 1)\r\n                    } {\r\n\r\n                        // Note: we go from right to left in the bit-string.\r\n\r\n                        // Create a mask for this crossover.\r\n                        // Example:\r\n                        // 00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000.....\r\n                        // |Prev. data ||Crossover here  ||remaining data .......\r\n                        //\r\n                        // The crossover part is copied from the mother/father to the child.\r\n\r\n                        // Create the bit-mask\r\n                        // Create a bitstring that ignores the previous data:\r\n                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\r\n                        // First create a leading 1, just before the crossover, like:\r\n                        // 00000000000010000000000000000000000000000000000000000000000000000000000.....\r\n                        // Then substract 1, to get a long string of 1s\r\n                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\r\n                        // Now do the same for the remain part, and xor it.\r\n                        // leading 1\r\n                        // 00000000000000000000000000000010000000000000000000000000000000000000000000000000000000000.....\r\n                        // sub 1\r\n                        // 00000000000000000000000000000001111111111111111111111111111111111111111111111111111111111.....\r\n                        // xor with other\r\n                        // 00000000000001111111111111111111111111111111111111111111111111111111111111111111111111111.....\r\n                        // 00000000000000000000000000000001111111111111111111111111111111111111111111111111111111111.....\r\n                        // 00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000.....\r\n\r\n                        // Use the final shifted 1 of the previous crossover as the start marker\r\n                        mask := sub(crossoverPosLeading1, 1)\r\n\r\n                        // update for this crossover, (and will be used as start for next crossover)\r\n                        crossoverPosLeading1 := mul(1, exp(2, crossoverPos))\r\n                        mask := xor(mask,\r\n                                    sub(crossoverPosLeading1, 1)\r\n                        )\r\n\r\n                        // Now add the parent data to the child genotype\r\n                        // E.g.\r\n                        // Mask:         00000000000001111111111111111110000000000000000000000000000000000000000000000000000000000....\r\n                        // Parent:       10010111001000110101011111001010001011100000000000010011000001000100000001011101111000111....\r\n                        // Child (pre):  00000000000000000000000000000001111110100101111111000011001010000000101010100000110110110....\r\n                        // Child (post): 00000000000000110101011111001011111110100101111111000011001010000000101010100000110110110....\r\n\r\n                        // To do this, we run: child_post = child_pre | (mask & father)\r\n                        result := or(result, and(mask, fatherSrc))\r\n\r\n                        // Swap father and mother, next crossover will take a string from the other.\r\n                        let temp := fatherSrc\r\n                        fatherSrc := motherSrc\r\n                        motherSrc := temp\r\n                    }\r\n\r\n                    // We still have a left-over part that was not copied yet\r\n                    // E.g., we have something like:\r\n                    // Father: |            xxxxxxxxxxxxxxxxxxx          xxxxxxxxxxxxxxxxxxxxxxxx            ....\r\n                    // Mother: |############                   xxxxxxxxxx                        xxxxxxxxxxxx....\r\n                    // Child:  |            xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx....\r\n                    // The ############ still needs to be applied to the child, also,\r\n                    //  this can be done cheaper than in the loop above,\r\n                    //  as we don't have to swap anything for the next crossover or something.\r\n\r\n                    // At this point we have to assume 4 crossovers ran,\r\n                    //  and that we only have 127 - 1 - (4 * 7) = 98 bits of randomness left.\r\n                    // We stopped at the bit after the crossoverPos index, see \"x\":\r\n                    // 000000000xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.....\r\n                    // now create a leading 1 at crossoverPos like:\r\n                    // 000000001000000000000000000000000000000000000000000000000000000000000000000.....\r\n                    // Sub 1, get the mask for what we had.\r\n                    // 000000000111111111111111111111111111111111111111111111111111111111111111111.....\r\n                    // Invert, and we have the final mask:\r\n                    // 111111111000000000000000000000000000000000000000000000000000000000000000000.....\r\n                    mask := not(sub(crossoverPosLeading1, 1))\r\n                    // Apply it to the result\r\n                    result := or(result, and(mask, fatherSrc))\r\n\r\n                    // Random mutations\r\n                    // =====================================================\r\n\r\n                    // random mutations\r\n                    // Put rng source in scratchpad 0\r\n                    mstore(0x0, rngSrc)\r\n                    // And some arbitrary padding in scratchpad 1,\r\n                    //  used to create different hashes based on input size changes\r\n                    mstore(0x20, 0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)\r\n                    // Hash it for a universally random bitstring.\r\n                    // Then reduce the number of 1s by AND-ing it with other *different* hashes.\r\n                    // Each bit in mutations has a probability of 0.5^5 = 0.03125 = 3.125% to be a 1\r\n                    let mutations := and(\r\n                            and(\r\n                                and(keccak256(0, 32), keccak256(1, 33)),\r\n                                and(keccak256(2, 34), keccak256(3, 35))\r\n                            ),\r\n                            keccak256(0, 36)\r\n                    )\r\n\r\n                    result := xor(result, mutations)\r\n\r\n                }\r\n            }\r\n\r\n\r\n            {\r\n\r\n                // Get 1 bit of pseudo randomness that will\r\n                //  determine if side #1 will come from the left, or right side.\r\n                // Either 0 or 1, shift it by 5 bits to get either 0x0 or 0x20, cheaper later on.\r\n                let relativeFatherSideLoc := mul(and(hash, 0x1), 0x20) // shift by 5 bits = mul by 2^5=32 (0x20)\r\n                // Either 0 or 1, shift it by 5 bits to get either 0x0 or 0x20, cheaper later on.\r\n                let relativeMotherSideLoc := mul(and(hash, 0x2), 0x10) // already shifted by 1, mul by 2^4=16 (0x10)\r\n\r\n                // Now remove the used 2 bits from the hash, 254 bits remaining now.\r\n                hash := div(hash, 4)\r\n\r\n                // Process the side, load the relevant parent data that will be used.\r\n                mstore(memOffset, processSide(\r\n                    mload(add(father, relativeFatherSideLoc)),\r\n                    mload(add(mother, relativeMotherSideLoc)),\r\n                    hash\r\n                ))\r\n\r\n                // The other side will be the opposite index: 1 -> 0, 0 -> 1\r\n                // Apply it to the location,\r\n                //  which is either 0x20 (For index 1) or 0x0 for index 0.\r\n                relativeFatherSideLoc := xor(relativeFatherSideLoc, 0x20)\r\n                relativeMotherSideLoc := xor(relativeMotherSideLoc, 0x20)\r\n\r\n                mstore(0x0, seed)\r\n                // Second argument will be inverse,\r\n                //  resulting in a different second hash.\r\n                mstore(0x20, not(timestamp))\r\n\r\n                // Now create another hash, for the other side\r\n                hash := keccak256(0, 64)\r\n\r\n                // Process the other side\r\n                mstore(add(memOffset, 0x20), processSide(\r\n                    mload(add(father, relativeFatherSideLoc)),\r\n                    mload(add(mother, relativeMotherSideLoc)),\r\n                    hash\r\n                ))\r\n\r\n            }\r\n\r\n        }\r\n\r\n        // Sample input:\r\n        // [\"0xAAABBBBBBBBCCCCCCCCAAAAAAAAABBBBBBBBBBCCCCCCCCCAABBBBBBBCCCCCCCC\",\"0x4444444455555555555555556666666666666644444444455555555555666666\"]\r\n        //\r\n        // [\"0x1111111111112222222223333311111111122222223333333331111112222222\",\"0x7777788888888888999999999999977777777777788888888888999999997777\"]\r\n\r\n        // Expected results (or similar, depends on the seed):\r\n        // 0xAAABBBBBBBBCCCCCCCCAAAAAAAAABBBBBBBBBBCCCCCCCCCAABBBBBBBCCCCCCCC < Father side A\r\n        // 0x4444444455555555555555556666666666666644444444455555555555666666 < Father side B\r\n\r\n        // 0x1111111111112222222223333311111111122222223333333331111112222222 < Mother side A\r\n        // 0x7777788888888888999999999999977777777777788888888888999999997777 < Mother side B\r\n\r\n        //   xxxxxxxxxxxxxxxxx           xxxxxxxxx                         xx\r\n        // 0xAAABBBBBBBBCCCCCD99999999998BBBBBBBBF77778888888888899999999774C < Child side A\r\n        //   xxx                       xxxxxxxxxxx\r\n        // 0x4441111111112222222223333366666666666222223333333331111112222222 < Child side B\r\n\r\n        // And then random mutations, for gene pool expansion.\r\n        // Each bit is flipped with a 3.125% chance\r\n\r\n        // Example:\r\n        //a2c37edc61dca0ca0b199e098c80fd5a221c2ad03605b4b54332361358745042 < random hash 1\r\n        //c217d04b19a83fe497c1cf6e1e10030e455a0812a6949282feec27d67fe2baa7 < random hash 2\r\n        //2636a55f38bed26d804c63a13628e21b2d701c902ca37b2b0ca94fada3821364 < random hash 3\r\n        //86bb023a85e2da50ac233b946346a53aa070943b0a8e91c56e42ba181729a5f9 < random hash 4\r\n        //5d71456a1288ab30ddd4c955384d42e66a09d424bd7743791e3eab8e09aa13f1 < random hash 5\r\n        //0000000800800000000000000000000200000000000000000000020000000000 < resulting mutation\r\n        //aaabbbbbbbbcccccd99999999998bbbbbbbbf77778888888888899999999774c < original\r\n        //aaabbbb3bb3cccccd99999999998bbb9bbbbf7777888888888889b999999774c < mutated (= original XOR mutation)\r\n    }\r\n\r\n    // Generates (psuedo) random Pepe DNA\r\n    function randomDNA(uint256 seed) internal pure returns (uint256[2] memOffset) {\r\n\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly {\r\n            // allocate output\r\n            // 1) get the pointer to our memory\r\n            memOffset := mload(0x40)\r\n            // 2) Change the free-memory pointer to keep our memory\r\n            //     (we will only use 64 bytes: 2 values of 256 bits)\r\n            mstore(0x40, add(memOffset, 64))\r\n\r\n            // Load the seed into 1st scratchpad memory slot.\r\n            // adjacent to the additional value (used to create two distinct hashes)\r\n            mstore(0x0, seed)\r\n\r\n            // In second scratchpad slot:\r\n            // The additional value can be any word, as long as the caller uses\r\n            //  it (second hash needs to be different)\r\n            mstore(0x20, 0x434f4c4c454354205045504553204f4e2043525950544f50455045532e494f21)\r\n\r\n\r\n            // // Create first element pointer of array\r\n            // mstore(memOffset, add(memOffset, 64)) // pointer 1\r\n            // mstore(add(memOffset, 32), add(memOffset, 96)) // pointer 2\r\n\r\n            // control block to auto-pop the hash.\r\n            {\r\n                // L * N * 2 * 4 = 4 * 2 * 2 * 4 = 64 bytes, 2x 256 bit hash\r\n\r\n                // Sha3 is cheaper than sha256, make use of it\r\n                let hash := keccak256(0, 64)\r\n\r\n                // Store first array value\r\n                mstore(memOffset, hash)\r\n\r\n                // Now hash again, but only 32 bytes of input,\r\n                //  to ignore make the input different than the previous call,\r\n                hash := keccak256(0, 32)\r\n                mstore(add(memOffset, 32), hash)\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: contracts/Usernames.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.19;\r\n\r\n\r\ncontract Usernames {\r\n\r\n    mapping(address => bytes32) public addressToUser;\r\n    mapping(bytes32 => address) public userToAddress;\r\n\r\n    event UserNamed(address indexed user, bytes32 indexed username);\r\n\r\n    /**\r\n     * Claim a username. Frees up a previously used one\r\n     * @param _username to claim\r\n     */\r\n    function claimUsername(bytes32 _username) external {\r\n        require(userToAddress[_username] == address(0));// Username must be free\r\n\r\n        if (addressToUser[msg.sender] != bytes32(0)) { // If user already has username free it up\r\n            userToAddress[addressToUser[msg.sender]] = address(0);\r\n        }\r\n\r\n        //all is well assign username\r\n        addressToUser[msg.sender] = _username;\r\n        userToAddress[_username] = msg.sender;\r\n\r\n        emit UserNamed(msg.sender, _username);\r\n\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Beneficiary.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/** @title Beneficiary */\r\ncontract Beneficiary is Ownable {\r\n    address public beneficiary;\r\n\r\n    constructor() public {\r\n        beneficiary = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Change the beneficiary address\r\n     * @param _beneficiary Address of the new beneficiary\r\n     */\r\n    function setBeneficiary(address _beneficiary) public onlyOwner {\r\n        beneficiary = _beneficiary;\r\n    }\r\n}\r\n\r\n// File: contracts/Affiliate.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.25;\r\n\r\n\r\n\r\n/** @title Affiliate */\r\ncontract Affiliate is Ownable {\r\n    mapping(address => bool) public canSetAffiliate;\r\n    mapping(address => address) public userToAffiliate;\r\n\r\n    /** @dev Allows an address to set the affiliate address for a user\r\n      * @param _setter The address that should be allowed\r\n      */\r\n    function setAffiliateSetter(address _setter) public onlyOwner {\r\n        canSetAffiliate[_setter] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the affiliate of a user\r\n     * @param _user user to set affiliate for\r\n     * @param _affiliate address to set\r\n     */\r\n    function setAffiliate(address _user, address _affiliate) public {\r\n        require(canSetAffiliate[msg.sender]);\r\n        if (userToAffiliate[_user] == address(0)) {\r\n            userToAffiliate[_user] = _affiliate;\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ERC721.sol\r\n\r\ncontract ERC721 {\r\n    function implementsERC721() public pure returns (bool);\r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public returns (bool) ;\r\n    function transfer(address _to, uint256 _tokenId) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    // Optional\r\n    // function name() public view returns (string name);\r\n    // function symbol() public view returns (string symbol);\r\n    // function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256 tokenId);\r\n    // function tokenMetadata(uint256 _tokenId) public view returns (string infoUrl);\r\n}\r\n\r\n// File: contracts/interfaces/PepeInterface.sol\r\n\r\ncontract PepeInterface is ERC721{\r\n    function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) public returns (bool);\r\n    function getCozyAgain(uint256 _pepeId) public view returns(uint64);\r\n}\r\n\r\n// File: contracts/AuctionBase.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n/** @title AuctionBase */\r\ncontract AuctionBase is Beneficiary {\r\n    mapping(uint256 => PepeAuction) public auctions;//maps pepes to auctions\r\n    PepeInterface public pepeContract;\r\n    Affiliate public affiliateContract;\r\n    uint256 public fee = 37500; //in 1 10000th of a percent so 3.75% at the start\r\n    uint256 public constant FEE_DIVIDER = 1000000; //Perhaps needs better name?\r\n\r\n    struct PepeAuction {\r\n        address seller;\r\n        uint256 pepeId;\r\n        uint64 auctionBegin;\r\n        uint64 auctionEnd;\r\n        uint256 beginPrice;\r\n        uint256 endPrice;\r\n    }\r\n\r\n    event AuctionWon(uint256 indexed pepe, address indexed winner, address indexed seller);\r\n    event AuctionStarted(uint256 indexed pepe, address indexed seller);\r\n    event AuctionFinalized(uint256 indexed pepe, address indexed seller);\r\n\r\n    constructor(address _pepeContract, address _affiliateContract) public {\r\n        pepeContract = PepeInterface(_pepeContract);\r\n        affiliateContract = Affiliate(_affiliateContract);\r\n    }\r\n\r\n    /**\r\n     * @dev Return a pepe from a auction that has passed\r\n     * @param  _pepeId the id of the pepe to save\r\n     */\r\n    function savePepe(uint256 _pepeId) external {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(auctions[_pepeId].auctionEnd < now);//auction must have ended\r\n        require(pepeContract.transfer(auctions[_pepeId].seller, _pepeId));//transfer pepe back to seller\r\n\r\n        emit AuctionFinalized(_pepeId, auctions[_pepeId].seller);\r\n\r\n        delete auctions[_pepeId];//delete auction\r\n    }\r\n\r\n    /**\r\n     * @dev change the fee on pepe sales. Can only be lowerred\r\n     * @param _fee The new fee to set. Must be lower than current fee\r\n     */\r\n    function changeFee(uint256 _fee) external onlyOwner {\r\n        require(_fee < fee);//fee can not be raised\r\n        fee = _fee;\r\n    }\r\n\r\n    /**\r\n     * @dev Start a auction\r\n     * @param  _pepeId Pepe to sell\r\n     * @param  _beginPrice Price at which the auction starts\r\n     * @param  _endPrice Ending price of the auction\r\n     * @param  _duration How long the auction should take\r\n     */\r\n    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\r\n        require(pepeContract.transferFrom(msg.sender, address(this), _pepeId));\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(now > auctions[_pepeId].auctionEnd);//can only start new auction if no other is active\r\n\r\n        PepeAuction memory auction;\r\n\r\n        auction.seller = msg.sender;\r\n        auction.pepeId = _pepeId;\r\n        // solhint-disable-next-line not-rely-on-time\r\n        auction.auctionBegin = uint64(now);\r\n        // solhint-disable-next-line not-rely-on-time\r\n        auction.auctionEnd = uint64(now) + _duration;\r\n        require(auction.auctionEnd > auction.auctionBegin);\r\n        auction.beginPrice = _beginPrice;\r\n        auction.endPrice = _endPrice;\r\n\r\n        auctions[_pepeId] = auction;\r\n\r\n        emit AuctionStarted(_pepeId, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev directly start a auction from the PepeBase contract\r\n     * @param  _pepeId Pepe to put on auction\r\n     * @param  _beginPrice Price at which the auction starts\r\n     * @param  _endPrice Ending price of the auction\r\n     * @param  _duration How long the auction should take\r\n     * @param  _seller The address selling the pepe\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\r\n        require(msg.sender == address(pepeContract)); //can only be called by pepeContract\r\n        //solhint-disable-next-line not-rely-on-time\r\n        require(now > auctions[_pepeId].auctionEnd);//can only start new auction if no other is active\r\n\r\n        PepeAuction memory auction;\r\n\r\n        auction.seller = _seller;\r\n        auction.pepeId = _pepeId;\r\n        // solhint-disable-next-line not-rely-on-time\r\n        auction.auctionBegin = uint64(now);\r\n        // solhint-disable-next-line not-rely-on-time\r\n        auction.auctionEnd = uint64(now) + _duration;\r\n        require(auction.auctionEnd > auction.auctionBegin);\r\n        auction.beginPrice = _beginPrice;\r\n        auction.endPrice = _endPrice;\r\n\r\n        auctions[_pepeId] = auction;\r\n\r\n        emit AuctionStarted(_pepeId, _seller);\r\n    }\r\n\r\n  /**\r\n   * @dev Calculate the current price of a auction\r\n   * @param  _pepeId the pepeID to calculate the current price for\r\n   * @return currentBid the current price for the auction\r\n   */\r\n    function calculateBid(uint256 _pepeId) public view returns(uint256 currentBid) {\r\n        PepeAuction storage auction = auctions[_pepeId];\r\n        // solhint-disable-next-line not-rely-on-time\r\n        uint256 timePassed = now - auctions[_pepeId].auctionBegin;\r\n\r\n        // If auction ended return auction end price.\r\n        // solhint-disable-next-line not-rely-on-time\r\n        if (now >= auction.auctionEnd) {\r\n            return auction.endPrice;\r\n        } else {\r\n            // Can be negative\r\n            int256 priceDifference = int256(auction.endPrice) - int256(auction.beginPrice);\r\n            // Always positive\r\n            int256 duration = int256(auction.auctionEnd) - int256(auction.auctionBegin);\r\n\r\n            // As already proven in practice by CryptoKitties:\r\n            //  timePassed -> 64 bits at most\r\n            //  priceDifference -> 128 bits at most\r\n            //  timePassed * priceDifference -> 64 + 128 bits at most\r\n            int256 priceChange = priceDifference * int256(timePassed) / duration;\r\n\r\n            // Will be positive, both operands are less than 256 bits\r\n            int256 price = int256(auction.beginPrice) + priceChange;\r\n\r\n            return uint256(price);\r\n        }\r\n    }\r\n\r\n  /**\r\n   * @dev collect the fees from the auction\r\n   */\r\n    function getFees() public {\r\n        beneficiary.transfer(address(this).balance);\r\n    }\r\n\r\n\r\n}\r\n\r\n// File: contracts/CozyTimeAuction.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\n/** @title CozyTimeAuction */\r\ncontract CozyTimeAuction is AuctionBase {\r\n    // solhint-disable-next-line\r\n    constructor (address _pepeContract, address _affiliateContract) AuctionBase(_pepeContract, _affiliateContract) public {\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Start an auction\r\n     * @param  _pepeId The id of the pepe to start the auction for\r\n     * @param  _beginPrice Start price of the auction\r\n     * @param  _endPrice End price of the auction\r\n     * @param  _duration How long the auction should take\r\n     */\r\n    function startAuction(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\r\n        super.startAuction(_pepeId, _beginPrice, _endPrice, _duration);\r\n    }\r\n\r\n    /**\r\n     * @dev Start a auction direclty from the PepeBase smartcontract\r\n     * @param  _pepeId The id of the pepe to start the auction for\r\n     * @param  _beginPrice Start price of the auction\r\n     * @param  _endPrice End price of the auction\r\n     * @param  _duration How long the auction should take\r\n     * @param  _seller The address of the seller\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function startAuctionDirect(uint256 _pepeId, uint256 _beginPrice, uint256 _endPrice, uint64 _duration, address _seller) public {\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(pepeContract.getCozyAgain(_pepeId) <= now);//need to have this extra check\r\n        super.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, _seller);\r\n    }\r\n\r\n    /**\r\n     * @dev Buy cozy right from the auction\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _cozyCandidate the pepe to cozy with\r\n     * @param  _candidateAsFather Is the _cozyCandidate father?\r\n     * @param  _pepeReceiver address receiving the pepe after cozy time\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function buyCozy(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver) public payable {\r\n        require(address(pepeContract) == msg.sender); //caller needs to be the PepeBase contract\r\n\r\n        PepeAuction storage auction = auctions[_pepeId];\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(now < auction.auctionEnd);// auction must be still going\r\n\r\n        uint256 price = calculateBid(_pepeId);\r\n        require(msg.value >= price);//must send enough ether\r\n        uint256 totalFee = price * fee / FEE_DIVIDER; //safe math needed?\r\n\r\n        //Send ETH to seller\r\n        auction.seller.transfer(price - totalFee);\r\n        //send ETH to beneficiary\r\n\r\n        address affiliate = affiliateContract.userToAffiliate(_pepeReceiver);\r\n\r\n        //solhint-disable-next-line\r\n        if (affiliate != address(0) && affiliate.send(totalFee / 2)) { //if user has affiliate\r\n            //nothing just to suppress warning\r\n        }\r\n\r\n        //actual cozytiming\r\n        if (_candidateAsFather) {\r\n            if (!pepeContract.cozyTime(auction.pepeId, _cozyCandidate, _pepeReceiver)) {\r\n                revert();\r\n            }\r\n        } else {\r\n          // Swap around the two pepes, they have no set gender, the user decides what they are.\r\n            if (!pepeContract.cozyTime(_cozyCandidate, auction.pepeId, _pepeReceiver)) {\r\n                revert();\r\n            }\r\n        }\r\n\r\n        //Send pepe to seller of auction\r\n        if (!pepeContract.transfer(auction.seller, _pepeId)) {\r\n            revert(); //can't complete transfer if this fails\r\n        }\r\n\r\n        if (msg.value > price) { //return ether send to much\r\n            _pepeReceiver.transfer(msg.value - price);\r\n        }\r\n\r\n        emit AuctionWon(_pepeId, _pepeReceiver, auction.seller);//emit event\r\n\r\n        delete auctions[_pepeId];//deletes auction\r\n    }\r\n\r\n    /**\r\n     * @dev Buy cozytime and pass along affiliate\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _cozyCandidate the pepe to cozy with\r\n     * @param  _candidateAsFather Is the _cozyCandidate father?\r\n     * @param  _pepeReceiver address receiving the pepe after cozy time\r\n     * @param  _affiliate Affiliate address to set\r\n     */\r\n    //solhint-disable-next-line max-line-length\r\n    function buyCozyAffiliated(uint256 _pepeId, uint256 _cozyCandidate, bool _candidateAsFather, address _pepeReceiver, address _affiliate) public payable {\r\n        affiliateContract.setAffiliate(_pepeReceiver, _affiliate);\r\n        buyCozy(_pepeId, _cozyCandidate, _candidateAsFather, _pepeReceiver);\r\n    }\r\n}\r\n\r\n// File: contracts/Haltable.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract Haltable is Ownable {\r\n    uint256 public haltTime; //when the contract was halted\r\n    bool public halted;//is the contract halted?\r\n    uint256 public haltDuration;\r\n    uint256 public maxHaltDuration = 8 weeks;//how long the contract can be halted\r\n\r\n    modifier stopWhenHalted {\r\n        require(!halted);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWhenHalted {\r\n        require(halted);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Halt the contract for a set time smaller than maxHaltDuration\r\n     * @param  _duration Duration how long the contract should be halted. Must be smaller than maxHaltDuration\r\n     */\r\n    function halt(uint256 _duration) public onlyOwner {\r\n        require(haltTime == 0); //cannot halt if it was halted before\r\n        require(_duration <= maxHaltDuration);//cannot halt for longer than maxHaltDuration\r\n        haltDuration = _duration;\r\n        halted = true;\r\n        // solhint-disable-next-line not-rely-on-time\r\n        haltTime = now;\r\n    }\r\n\r\n    /**\r\n     * @dev Unhalt the contract. Can only be called by the owner or when the haltTime has passed\r\n     */\r\n    function unhalt() public {\r\n        // solhint-disable-next-line\r\n        require(now > haltTime + haltDuration || msg.sender == owner);//unhalting is only possible when haltTime has passed or the owner unhalts\r\n        halted = false;\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/interfaces/ERC721TokenReceiver.sol\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0xf0b9e5ba\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    ///  than the magic value MUST result in the transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _from The sending address\r\n    /// @param _tokenId The NFT identifier which is being transfered\r\n    /// @param data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n\tfunction onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4);\r\n}\r\n\r\n// File: contracts/PepeBase.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.24;\r\n\r\n// solhint-disable func-order\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract PepeBase is Genetic, Ownable, Usernames, Haltable {\r\n\r\n    uint32[15] public cozyCoolDowns = [ //determined by generation / 2\r\n        uint32(1 minutes),\r\n        uint32(2 minutes),\r\n        uint32(5 minutes),\r\n        uint32(15 minutes),\r\n        uint32(30 minutes),\r\n        uint32(45 minutes),\r\n        uint32(1 hours),\r\n        uint32(2 hours),\r\n        uint32(4 hours),\r\n        uint32(8 hours),\r\n        uint32(16 hours),\r\n        uint32(1 days),\r\n        uint32(2 days),\r\n        uint32(4 days),\r\n        uint32(7 days)\r\n    ];\r\n\r\n    struct Pepe {\r\n        address master; //The master of the pepe\r\n        uint256[2] genotype; //all genes stored here\r\n        uint64 canCozyAgain; //time when pepe can have nice time again\r\n        uint64 generation; //what generation?\r\n        uint64 father; //father of this pepe\r\n        uint64 mother; //mommy of this pepe\r\n        uint8 coolDownIndex;\r\n    }\r\n\r\n    mapping(uint256 => bytes32) public pepeNames;\r\n\r\n    //stores all pepes\r\n    Pepe[] public pepes;\r\n\r\n    bool public implementsERC721 = true; //signal erc721 support\r\n\r\n    // solhint-disable-next-line const-name-snakecase\r\n    string public constant name = \"Crypto Pepe\";\r\n    // solhint-disable-next-line const-name-snakecase\r\n    string public constant symbol = \"CPEP\";\r\n\r\n    mapping(address => uint256[]) private wallets;\r\n    mapping(address => uint256) public balances; //amounts of pepes per address\r\n    mapping(uint256 => address) public approved; //pepe index to address approved to transfer\r\n    mapping(address => mapping(address => bool)) public approvedForAll;\r\n\r\n    uint256 public zeroGenPepes; //how many zero gen pepes are mined\r\n    uint256 public constant MAX_PREMINE = 100;//how many pepes can be premined\r\n    uint256 public constant MAX_ZERO_GEN_PEPES = 1100; //max number of zero gen pepes\r\n    address public miner; //address of the miner contract\r\n\r\n    modifier onlyPepeMaster(uint256 _pepeId) {\r\n        require(pepes[_pepeId].master == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAllowed(uint256 _tokenId) {\r\n        // solhint-disable-next-line max-line-length\r\n        require(msg.sender == pepes[_tokenId].master || msg.sender == approved[_tokenId] || approvedForAll[pepes[_tokenId].master][msg.sender]); //check if msg.sender is allowed\r\n        _;\r\n    }\r\n\r\n    event PepeBorn(uint256 indexed mother, uint256 indexed father, uint256 indexed pepeId);\r\n    event PepeNamed(uint256 indexed pepeId);\r\n\r\n    constructor() public {\r\n\r\n        Pepe memory pepe0 = Pepe({\r\n            master: 0x0,\r\n            genotype: [uint256(0), uint256(0)],\r\n            canCozyAgain: 0,\r\n            father: 0,\r\n            mother: 0,\r\n            generation: 0,\r\n            coolDownIndex: 0\r\n        });\r\n\r\n        pepes.push(pepe0);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function that creates a new pepe\r\n     * @param  _genoType DNA of the new pepe\r\n     * @param  _mother The ID of the mother\r\n     * @param  _father The ID of the father\r\n     * @param  _generation The generation of the new Pepe\r\n     * @param  _master The owner of this new Pepe\r\n     * @return The ID of the newly generated Pepe\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function _newPepe(uint256[2] _genoType, uint64 _mother, uint64 _father, uint64 _generation, address _master) internal returns (uint256 pepeId) {\r\n        uint8 tempCoolDownIndex;\r\n\r\n        tempCoolDownIndex = uint8(_generation / 2);\r\n\r\n        if (_generation > 28) {\r\n            tempCoolDownIndex = 14;\r\n        }\r\n\r\n        Pepe memory _pepe = Pepe({\r\n            master: _master, //The master of the pepe\r\n            genotype: _genoType, //all genes stored here\r\n            canCozyAgain: 0, //time when pepe can have nice time again\r\n            father: _father, //father of this pepe\r\n            mother: _mother, //mommy of this pepe\r\n            generation: _generation, //what generation?\r\n            coolDownIndex: tempCoolDownIndex\r\n        });\r\n\r\n        if (_generation == 0) {\r\n            zeroGenPepes += 1; //count zero gen pepes\r\n        }\r\n\r\n        //push returns the new length, use it to get a new unique id\r\n        pepeId = pepes.push(_pepe) - 1;\r\n\r\n        //add it to the wallet of the master of the new pepe\r\n        addToWallet(_master, pepeId);\r\n\r\n        emit PepeBorn(_mother, _father, pepeId);\r\n        emit Transfer(address(0), _master, pepeId);\r\n\r\n        return pepeId;\r\n    }\r\n\r\n    /**\r\n     * @dev Set the miner contract. Can only be called once\r\n     * @param _miner Address of the miner contract\r\n     */\r\n    function setMiner(address _miner) public onlyOwner {\r\n        require(miner == address(0));//can only be set once\r\n        miner = _miner;\r\n    }\r\n\r\n    /**\r\n     * @dev Mine a new Pepe. Can only be called by the miner contract.\r\n     * @param  _seed Seed to be used for the generation of the DNA\r\n     * @param  _receiver Address receiving the newly mined Pepe\r\n     * @return The ID of the newly mined Pepe\r\n     */\r\n    function minePepe(uint256 _seed, address _receiver) public stopWhenHalted returns(uint256) {\r\n        require(msg.sender == miner);//only miner contract can call\r\n        require(zeroGenPepes < MAX_ZERO_GEN_PEPES);\r\n\r\n        return _newPepe(randomDNA(_seed), 0, 0, 0, _receiver);\r\n    }\r\n\r\n    /**\r\n     * @dev Premine pepes. Can only be called by the owner and is limited to MAX_PREMINE\r\n     * @param  _amount Amount of Pepes to premine\r\n     */\r\n    function pepePremine(uint256 _amount) public onlyOwner stopWhenHalted {\r\n        for (uint i = 0; i < _amount; i++) {\r\n            require(zeroGenPepes <= MAX_PREMINE);//can only generate set amount during premine\r\n            //create a new pepe\r\n            // 1) who's genes are based on hash of the timestamp and the number of pepes\r\n            // 2) who has no mother or father\r\n            // 3) who is generation zero\r\n            // 4) who's master is the manager\r\n\r\n            // solhint-disable-next-line\r\n            _newPepe(randomDNA(uint256(keccak256(abi.encodePacked(block.timestamp, pepes.length)))), 0, 0, 0, owner);\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev CozyTime two Pepes together\r\n     * @param  _mother The mother of the new Pepe\r\n     * @param  _father The father of the new Pepe\r\n     * @param  _pepeReceiver Address receiving the new Pepe\r\n     * @return If it was a success\r\n     */\r\n    function cozyTime(uint256 _mother, uint256 _father, address _pepeReceiver) external stopWhenHalted returns (bool) {\r\n        //cannot cozyTime with itself\r\n        require(_mother != _father);\r\n        //caller has to either be master or approved for mother\r\n        // solhint-disable-next-line max-line-length\r\n        require(pepes[_mother].master == msg.sender || approved[_mother] == msg.sender || approvedForAll[pepes[_mother].master][msg.sender]);\r\n        //caller has to either be master or approved for father\r\n        // solhint-disable-next-line max-line-length\r\n        require(pepes[_father].master == msg.sender || approved[_father] == msg.sender || approvedForAll[pepes[_father].master][msg.sender]);\r\n        //require both parents to be ready for cozytime\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(now > pepes[_mother].canCozyAgain && now > pepes[_father].canCozyAgain);\r\n        //require both mother parents not to be father\r\n        require(pepes[_mother].mother != _father && pepes[_mother].father != _father);\r\n        //require both father parents not to be mother\r\n        require(pepes[_father].mother != _mother && pepes[_father].father != _mother);\r\n\r\n        Pepe storage father = pepes[_father];\r\n        Pepe storage mother = pepes[_mother];\r\n\r\n\r\n        approved[_father] = address(0);\r\n        approved[_mother] = address(0);\r\n\r\n        uint256[2] memory newGenotype = breed(father.genotype, mother.genotype, pepes.length);\r\n\r\n        uint64 newGeneration;\r\n\r\n        newGeneration = mother.generation + 1;\r\n        if (newGeneration < father.generation + 1) { //if father generation is bigger\r\n            newGeneration = father.generation + 1;\r\n        }\r\n\r\n        _handleCoolDown(_mother);\r\n        _handleCoolDown(_father);\r\n\r\n        //sets pepe birth when mother is done\r\n        // solhint-disable-next-line max-line-length\r\n        pepes[_newPepe(newGenotype, uint64(_mother), uint64(_father), newGeneration, _pepeReceiver)].canCozyAgain = mother.canCozyAgain; //_pepeReceiver becomes the master of the pepe\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Internal function to increase the coolDownIndex\r\n     * @param _pepeId The id of the Pepe to update the coolDown of\r\n     */\r\n    function _handleCoolDown(uint256 _pepeId) internal {\r\n        Pepe storage tempPep = pepes[_pepeId];\r\n\r\n        // solhint-disable-next-line not-rely-on-time\r\n        tempPep.canCozyAgain = uint64(now + cozyCoolDowns[tempPep.coolDownIndex]);\r\n\r\n        if (tempPep.coolDownIndex < 14) {// after every cozy time pepe gets slower\r\n            tempPep.coolDownIndex++;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @dev Set the name of a Pepe. Can only be set once\r\n     * @param _pepeId ID of the pepe to name\r\n     * @param _name The name to assign\r\n     */\r\n    function setPepeName(uint256 _pepeId, bytes32 _name) public stopWhenHalted onlyPepeMaster(_pepeId) returns(bool) {\r\n        require(pepeNames[_pepeId] == 0x0000000000000000000000000000000000000000000000000000000000000000);\r\n        pepeNames[_pepeId] = _name;\r\n        emit PepeNamed(_pepeId);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer a Pepe to the auction contract and auction it\r\n     * @param  _pepeId ID of the Pepe to auction\r\n     * @param  _auction Auction contract address\r\n     * @param  _beginPrice Price the auction starts at\r\n     * @param  _endPrice Price the auction ends at\r\n     * @param  _duration How long the auction should run\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function transferAndAuction(uint256 _pepeId, address _auction, uint256 _beginPrice, uint256 _endPrice, uint64 _duration) public stopWhenHalted onlyPepeMaster(_pepeId) {\r\n        _transfer(msg.sender, _auction, _pepeId);//transfer pepe to auction\r\n        AuctionBase auction = AuctionBase(_auction);\r\n\r\n        auction.startAuctionDirect(_pepeId, _beginPrice, _endPrice, _duration, msg.sender);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve and buy. Used to buy cozyTime in one call\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _auction Address of the auction contract\r\n     * @param  _cozyCandidate Pepe to approve and cozy with\r\n     * @param  _candidateAsFather Use the candidate as father or not\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function approveAndBuy(uint256 _pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather) public stopWhenHalted payable onlyPepeMaster(_cozyCandidate) {\r\n        approved[_cozyCandidate] = _auction;\r\n        // solhint-disable-next-line max-line-length\r\n        CozyTimeAuction(_auction).buyCozy.value(msg.value)(_pepeId, _cozyCandidate, _candidateAsFather, msg.sender); //breeding resets approval\r\n    }\r\n\r\n    /**\r\n     * @dev The same as above only pass an extra parameter\r\n     * @param  _pepeId Pepe to cozy with\r\n     * @param  _auction Address of the auction contract\r\n     * @param  _cozyCandidate Pepe to approve and cozy with\r\n     * @param  _candidateAsFather Use the candidate as father or not\r\n     * @param  _affiliate Address to set as affiliate\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function approveAndBuyAffiliated(uint256 _pepeId, address _auction, uint256 _cozyCandidate, bool _candidateAsFather, address _affiliate) public stopWhenHalted payable onlyPepeMaster(_cozyCandidate) {\r\n        approved[_cozyCandidate] = _auction;\r\n        // solhint-disable-next-line max-line-length\r\n        CozyTimeAuction(_auction).buyCozyAffiliated.value(msg.value)(_pepeId, _cozyCandidate, _candidateAsFather, msg.sender, _affiliate); //breeding resets approval\r\n    }\r\n\r\n    /**\r\n     * @dev get Pepe information\r\n     * @param  _pepeId ID of the Pepe to get information of\r\n     * @return master\r\n     * @return genotype\r\n     * @return canCozyAgain\r\n     * @return generation\r\n     * @return father\r\n     * @return mother\r\n     * @return pepeName\r\n     * @return coolDownIndex\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function getPepe(uint256 _pepeId) public view returns(address master, uint256[2] genotype, uint64 canCozyAgain, uint64 generation, uint256 father, uint256 mother, bytes32 pepeName, uint8 coolDownIndex) {\r\n        Pepe storage tempPep = pepes[_pepeId];\r\n\r\n        master = tempPep.master;\r\n        genotype = tempPep.genotype;\r\n        canCozyAgain = tempPep.canCozyAgain;\r\n        generation = tempPep.generation;\r\n        father = tempPep.father;\r\n        mother = tempPep.mother;\r\n        pepeName = pepeNames[_pepeId];\r\n        coolDownIndex = tempPep.coolDownIndex;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the time when a pepe can cozy again\r\n     * @param  _pepeId ID of the pepe\r\n     * @return Time when the pepe can cozy again\r\n     */\r\n    function getCozyAgain(uint256 _pepeId) public view returns(uint64) {\r\n        return pepes[_pepeId].canCozyAgain;\r\n    }\r\n\r\n    /**\r\n     *  ERC721 Compatibility\r\n     *\r\n     */\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /**\r\n     * @dev Get the total number of Pepes\r\n     * @return total Returns the total number of pepes\r\n     */\r\n    function totalSupply() public view returns(uint256 total) {\r\n        total = pepes.length - balances[address(0)];\r\n        return total;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the number of pepes owned by an address\r\n     * @param  _owner Address to get the balance from\r\n     * @return balance The number of pepes\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256 balance) {\r\n        balance = balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Get the owner of a Pepe\r\n     * @param  _tokenId the token to get the owner of\r\n     * @return _owner the owner of the pepe\r\n     */\r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\r\n        _owner = pepes[_tokenId].master;\r\n    }\r\n\r\n    /**\r\n     * @dev Get the id of an token by its index\r\n     * @param _owner The address to look up the tokens of\r\n     * @param _index Index to look at\r\n     * @return tokenId the ID of the token of the owner at the specified index\r\n     */\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public constant returns (uint256 tokenId) {\r\n        //The index must be smaller than the balance,\r\n        // to guarantee that there is no leftover token returned.\r\n        require(_index < balances[_owner]);\r\n\r\n        return wallets[_owner][_index];\r\n    }\r\n\r\n    /**\r\n     * @dev Private method that ads a token to the wallet\r\n     * @param _owner Address of the owner\r\n     * @param _tokenId Pepe ID to add\r\n     */\r\n    function addToWallet(address _owner, uint256 _tokenId) private {\r\n        uint256[] storage wallet = wallets[_owner];\r\n        uint256 balance = balances[_owner];\r\n        if (balance < wallet.length) {\r\n            wallet[balance] = _tokenId;\r\n        } else {\r\n            wallet.push(_tokenId);\r\n        }\r\n        //increase owner balance\r\n        //overflow is not likely to happen(need very large amount of pepes)\r\n        balances[_owner] += 1;\r\n    }\r\n\r\n    /**\r\n     * @dev Remove a token from a address's wallet\r\n     * @param _owner Address of the owner\r\n     * @param _tokenId Token to remove from the wallet\r\n     */\r\n    function removeFromWallet(address _owner, uint256 _tokenId) private {\r\n        uint256[] storage wallet = wallets[_owner];\r\n        uint256 i = 0;\r\n        // solhint-disable-next-line no-empty-blocks\r\n        for (; wallet[i] != _tokenId; i++) {\r\n            // not the pepe we are looking for\r\n        }\r\n        if (wallet[i] == _tokenId) {\r\n            //found it!\r\n            uint256 last = balances[_owner] - 1;\r\n            if (last > 0) {\r\n                //move the last item to this spot, the last will become inaccessible\r\n                wallet[i] = wallet[last];\r\n            }\r\n            //else: no last item to move, the balance is 0, making everything inaccessible.\r\n\r\n            //only decrease balance if _tokenId was in the wallet\r\n            balances[_owner] -= 1;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Internal transfer function\r\n     * @param _from Address sending the token\r\n     * @param _to Address to token is send to\r\n     * @param _tokenId ID of the token to send\r\n     */\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n        pepes[_tokenId].master = _to;\r\n        approved[_tokenId] = address(0);//reset approved of pepe on every transfer\r\n\r\n        //remove the token from the _from wallet\r\n        removeFromWallet(_from, _tokenId);\r\n\r\n        //add the token to the _to wallet\r\n        addToWallet(_to, _tokenId);\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev transfer a token. Can only be called by the owner of the token\r\n     * @param  _to Addres to send the token to\r\n     * @param  _tokenId ID of the token to send\r\n     */\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    function transfer(address _to, uint256 _tokenId) public stopWhenHalted\r\n        onlyPepeMaster(_tokenId) //check if msg.sender is the master of this pepe\r\n        returns(bool)\r\n    {\r\n        _transfer(msg.sender, _to, _tokenId);//after master modifier invoke internal transfer\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve a address to send a token\r\n     * @param _to Address to approve\r\n     * @param _tokenId Token to set approval for\r\n     */\r\n    function approve(address _to, uint256 _tokenId) external stopWhenHalted\r\n        onlyPepeMaster(_tokenId)\r\n    {\r\n        approved[_tokenId] = _to;\r\n        emit Approval(msg.sender, _to, _tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Approve or revoke approval an address for al tokens of a user\r\n     * @param _operator Address to (un)approve\r\n     * @param _approved Approving or revoking indicator\r\n     */\r\n    function setApprovalForAll(address _operator, bool _approved) external stopWhenHalted {\r\n        if (_approved) {\r\n            approvedForAll[msg.sender][_operator] = true;\r\n        } else {\r\n            approvedForAll[msg.sender][_operator] = false;\r\n        }\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    /**\r\n     * @dev Get approved address for a token\r\n     * @param _tokenId Token ID to get the approved address for\r\n     * @return The address that is approved for this token\r\n     */\r\n    function getApproved(uint256 _tokenId) external view returns (address) {\r\n        return approved[_tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get if an operator is approved for all tokens of that owner\r\n     * @param _owner Owner to check the approval for\r\n     * @param _operator Operator to check approval for\r\n     * @return Boolean indicating if the operator is approved for that owner\r\n     */\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        return approvedForAll[_owner][_operator];\r\n    }\r\n\r\n    /**\r\n     * @dev Function to signal support for an interface\r\n     * @param interfaceID the ID of the interface to check for\r\n     * @return Boolean indicating support\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) external pure returns (bool) {\r\n        if (interfaceID == 0x80ac58cd || interfaceID == 0x01ffc9a7) { //TODO: add more interfaces the contract supports\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * @dev Safe transferFrom function\r\n     * @param _from Address currently owning the token\r\n     * @param _to Address to send token to\r\n     * @param _tokenId ID of the token to send\r\n     */\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external stopWhenHalted {\r\n        _safeTransferFromInternal(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    /**\r\n     * @dev Safe transferFrom function with aditional data attribute\r\n     * @param _from Address currently owning the token\r\n     * @param _to Address to send token to\r\n     * @param _tokenId ID of the token to send\r\n     * @param _data Data to pass along call\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external stopWhenHalted {\r\n        _safeTransferFromInternal(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    /**\r\n     * @dev Internal Safe transferFrom function with aditional data attribute\r\n     * @param _from Address currently owning the token\r\n     * @param _to Address to send token to\r\n     * @param _tokenId ID of the token to send\r\n     * @param _data Data to pass along call\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function _safeTransferFromInternal(address _from, address _to, uint256 _tokenId, bytes _data) internal onlyAllowed(_tokenId) {\r\n        require(pepes[_tokenId].master == _from);//check if from is current owner\r\n        require(_to != address(0));//throw on zero address\r\n\r\n        _transfer(_from, _to, _tokenId); //transfer token\r\n\r\n        if (isContract(_to)) { //check if is contract\r\n            // solhint-disable-next-line max-line-length\r\n            require(ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, _data) == bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev TransferFrom function\r\n     * @param _from Address currently owning the token\r\n     * @param _to Address to send token to\r\n     * @param _tokenId ID of the token to send\r\n     * @return If it was successful\r\n     */\r\n    // solhint-disable-next-line max-line-length\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public stopWhenHalted onlyAllowed(_tokenId) returns(bool) {\r\n        require(pepes[_tokenId].master == _from);//check if _from is really the master.\r\n        require(_to != address(0));\r\n        _transfer(_from, _to, _tokenId);//handles event, balances and approval reset;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Utility method to check if an address is a contract\r\n     * @param _address Address to check\r\n     * @return Boolean indicating if the address is a contract\r\n     */\r\n    function isContract(address _address) internal view returns (bool) {\r\n        uint size;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { size := extcodesize(_address) }\r\n        return size > 0;\r\n    }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/PepToken.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.24;\r\n\r\n\r\n\r\ncontract PepToken is StandardToken {\r\n\r\n    string public name = \"PEP Token\";\r\n    string public symbol = \"PEP\";\r\n    uint8 public decimals = 18;\r\n    uint256 public constant INITIAL_BALANCE = 45000000 ether;\r\n\r\n    constructor() public {\r\n        balances[msg.sender] = INITIAL_BALANCE;\r\n        totalSupply_ = INITIAL_BALANCE;\r\n    }\r\n\r\n    /**\r\n     * @dev Allow spender to revoke its own allowance\r\n     * @param _from Address from which allowance should be revoked\r\n     */\r\n    function revokeAllowance(address _from) public {\r\n        allowed[_from][msg.sender] = 0;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/PepeGrinder.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.4;\r\n\r\n\r\n\r\n\r\n\r\ncontract PepeGrinder is StandardToken, Ownable {\r\n\r\n    address public pepeContract;\r\n    address public miner;\r\n    uint256[] public pepes;\r\n    mapping(address => bool) public dusting;\r\n\r\n    string public name = \"CryptoPepes DUST\";\r\n    string public symbol = \"DPEP\";\r\n    uint8 public decimals = 18;\r\n\r\n    uint256 public constant DUST_PER_PEPE = 100 ether;\r\n\r\n    constructor(address _pepeContract) public {\r\n        pepeContract = _pepeContract;\r\n    }\r\n\r\n    /**\r\n     * Set the mining contract. Can only be set once\r\n     * @param _miner The address of the miner contract\r\n     */\r\n    function setMiner(address _miner) public onlyOwner {\r\n        require(miner == address(0));// can only be set once\r\n        miner = _miner;\r\n    }\r\n\r\n    /**\r\n     * Gets called by miners who wanna dust their mined Pepes\r\n     */\r\n    function setDusting() public {\r\n        dusting[msg.sender] = true;\r\n    }\r\n\r\n    /**\r\n     * Dust a pepe to pepeDust\r\n     * @param _pepeId Pepe to dust\r\n     * @param _miner address of the miner\r\n     */\r\n    function dustPepe(uint256 _pepeId, address _miner) public {\r\n        require(msg.sender == miner);\r\n        balances[_miner] += DUST_PER_PEPE;\r\n        pepes.push(_pepeId);\r\n        totalSupply_ += DUST_PER_PEPE;\r\n        emit Transfer(address(0), _miner, DUST_PER_PEPE);\r\n    }\r\n\r\n    /**\r\n     * Convert dust into a Pepe\r\n     */\r\n    function claimPepe() public {\r\n        require(balances[msg.sender] >= DUST_PER_PEPE);\r\n\r\n        balances[msg.sender] -= DUST_PER_PEPE; //change balance and total supply\r\n        totalSupply_ -= DUST_PER_PEPE;\r\n\r\n        PepeBase(pepeContract).transfer(msg.sender, pepes[pepes.length-1]);//transfer pepe\r\n        pepes.length -= 1;\r\n        emit Transfer(msg.sender, address(0), DUST_PER_PEPE);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/Math/ExtendedMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary ExtendedMath {\r\n  //return the smaller of the two inputs (a or b)\r\n  function limitLessThan(uint a, uint b) internal pure returns (uint c) {\r\n    if(a > b) return b;\r\n    return a;\r\n  }\r\n}\r\n\r\n// File: contracts/Mining.sol\r\n\r\n// solhint-disable-next-line\r\npragma solidity ^0.4.4;\r\n\r\n// solhint-disable max-line-length\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// solhint-disable-next-line\r\ncontract Mining is Beneficiary {\r\n\r\n    using SafeMath for uint;\r\n    using ExtendedMath for uint;\r\n\r\n    uint public latestDifficultyPeriodStarted = block.number;\r\n    uint public epochCount = 0;//number of 'blocks' mined\r\n    uint public constant MAX_EPOCH_COUNT = 16000;\r\n    uint public baseMiningReward = 2500 ether;\r\n    uint public blocksPerReadjustment = 20;\r\n    uint public tokensMinted;\r\n\r\n    // solhint-disable var-name-mixedcase\r\n    uint public _MINIMUM_TARGET = 2**16;\r\n    uint public _MAXIMUM_TARGET = 2**250; //Testing setting!\r\n    //uint public _MAXIMUM_TARGET = 2**230; //SHOULD MAKE THIS HARDER IN PRODUCTION\r\n\r\n    uint public constant STARTING_DIFFICULTY = 0x00000000000b4963208fc24a4a15e9ea7c1556f9583f1941a7515fabbd194584;\r\n\r\n    bytes32 public challengeNumber;\r\n    uint public difficulty;\r\n    uint public MINING_RATE_FACTOR = 31; //mint the token 31 times less often than ether\r\n    //difficulty adjustment parameters- be careful modifying these\r\n    uint public MAX_ADJUSTMENT_PERCENT = 100;\r\n    uint public TARGET_DIVISOR = 2000;\r\n    uint public QUOTIENT_LIMIT = TARGET_DIVISOR.div(2);\r\n    mapping(bytes32 => bytes32) public solutionForChallenge;\r\n\r\n    Statistics public statistics;\r\n\r\n    PepeBase public pepeContract;\r\n    PepToken public pepToken;\r\n    PepeGrinder public pepeGrinder;\r\n\r\n    uint256 public miningStart;//timestamp when mining starts\r\n\r\n    event Mint(address indexed from, uint rewardAmount, uint epochCount, bytes32 newChallengeNumber);\r\n\r\n    // track read only minting statistics\r\n    struct Statistics {\r\n        address lastRewardTo;\r\n        uint lastRewardAmount;\r\n        uint lastRewardEthBlockNumber;\r\n        uint lastRewardTimestamp;\r\n    }\r\n\r\n    constructor(address _pepeContract, address _pepToken, address _pepeGrinder, uint256 _miningStart) public {\r\n        pepeContract = PepeBase(_pepeContract);\r\n        pepToken = PepToken(_pepToken);\r\n        pepeGrinder = PepeGrinder(_pepeGrinder);\r\n        difficulty = STARTING_DIFFICULTY;\r\n        miningStart = _miningStart;\r\n    }\r\n\r\n    /**\r\n     * Mint a new pepe if noce is correct\r\n     * @param nonce The nonce to submit\r\n     * @param challengeDigest The resulting digest\r\n     * @return success Boolean indicating if mint was successful\r\n     */\r\n    // solhint-disable-next-line\r\n    function mint(uint256 nonce, bytes32 challengeDigest) public returns (bool success) {\r\n        require(epochCount < MAX_EPOCH_COUNT);//max 16k blocks\r\n        // solhint-disable-next-line not-rely-on-time\r\n        require(now > miningStart);\r\n        // perform the hash function validation\r\n        _hash(nonce, challengeDigest);\r\n\r\n        // calculate the current reward\r\n        uint rewardAmount = _reward(nonce);\r\n\r\n        // increment the minted tokens amount\r\n        tokensMinted += rewardAmount;\r\n\r\n        epochCount += 1;\r\n        challengeNumber = blockhash(block.number - 1);\r\n\r\n        _adjustDifficulty();\r\n\r\n        //populate read only diagnostics data\r\n        // solhint-disable-next-line not-rely-on-time\r\n        statistics = Statistics(msg.sender, rewardAmount, block.number, now);\r\n\r\n        // send Mint event indicating a successful implementation\r\n        emit Mint(msg.sender, rewardAmount, epochCount, challengeNumber);\r\n\r\n        if (epochCount == MAX_EPOCH_COUNT) { //destroy this smart contract on the latest block\r\n            selfdestruct(msg.sender);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Get the current challengeNumber\r\n     * @return bytes32 challengeNumber\r\n     */\r\n    function getChallengeNumber() public constant returns (bytes32) {\r\n        return challengeNumber;\r\n    }\r\n\r\n    /**\r\n     * Get the current mining difficulty\r\n     * @return the current difficulty\r\n     */\r\n    function getMiningDifficulty() public constant returns (uint) {\r\n        return _MAXIMUM_TARGET.div(difficulty);\r\n    }\r\n\r\n    /**\r\n     * Get the mining target\r\n     * @return The current mining target\r\n     */\r\n    function getMiningTarget() public constant returns (uint256) {\r\n        return difficulty;\r\n    }\r\n\r\n    /**\r\n     * Get the mining reward\r\n     * @return The current mining reward. Always 2500PEP\r\n     */\r\n    function getMiningReward() public constant returns (uint256) {\r\n        return baseMiningReward;\r\n    }\r\n\r\n    /**\r\n     * Helper method to check a nonce\r\n     * @param nonce The nonce to check\r\n     * @param challengeDigest the digest to check\r\n     * @param challengeNumber to check\r\n     * @return digesttest The resulting digest\r\n     */\r\n    // solhint-disable-next-line\r\n    function getMintDigest(uint256 nonce, bytes32 challengeDigest, bytes32 challengeNumber) public view returns (bytes32 digesttest) {\r\n        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\r\n        return digest;\r\n    }\r\n\r\n    /**\r\n     * Helper method to check if a nonce meets the difficulty\r\n     * @param nonce The nonce to check\r\n     * @param challengeDigest the digest to check\r\n     * @param challengeNumber the challenge number to check\r\n     * @param testTarget the difficulty to check\r\n     * @return success Boolean indicating success\r\n     */\r\n    function checkMintSolution(uint256 nonce, bytes32 challengeDigest, bytes32 challengeNumber, uint testTarget) public view returns (bool success) {\r\n        bytes32 digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\r\n        if (uint256(digest) > testTarget) revert();\r\n        return (digest == challengeDigest);\r\n    }\r\n\r\n    /**\r\n     * Internal function to check a hash\r\n     * @param nonce The nonce to check\r\n     * @param challengeDigest it should create\r\n     * @return digest The digest created\r\n     */\r\n    function _hash(uint256 nonce, bytes32 challengeDigest) internal returns (bytes32 digest) {\r\n        digest = keccak256(abi.encodePacked(challengeNumber, msg.sender, nonce));\r\n        //the challenge digest must match the expected\r\n        if (digest != challengeDigest) revert();\r\n        //the digest must be smaller than the target\r\n        if (uint256(digest) > difficulty) revert();\r\n        //only allow one reward for each challenge\r\n        bytes32 solution = solutionForChallenge[challengeNumber];\r\n        solutionForChallenge[challengeNumber] = digest;\r\n        if (solution != 0x0) revert();  //prevent the same answer from awarding twice\r\n    }\r\n\r\n    /**\r\n     * Reward a miner Pep tokens\r\n     * @param nonce Nonce to use as seed for Pepe dna creation\r\n     * @return The amount of PEP tokens rewarded\r\n     */\r\n    function _reward(uint256 nonce) internal returns (uint) {\r\n        uint reward_amount = getMiningReward();\r\n        pepToken.transfer(msg.sender, reward_amount);\r\n\r\n        if (epochCount % 16 == 0) { //every 16th block reward a pepe\r\n            if (pepeGrinder.dusting(msg.sender)) { //if miner is pool mining send it through the grinder\r\n                uint256 newPepe = pepeContract.minePepe(nonce, address(pepeGrinder));\r\n                pepeGrinder.dustPepe(newPepe, msg.sender);\r\n            } else {\r\n                pepeContract.minePepe(nonce, msg.sender);\r\n            }\r\n            //every 16th block send part of the block reward\r\n            pepToken.transfer(beneficiary, reward_amount);\r\n        }\r\n\r\n        return reward_amount;\r\n    }\r\n\r\n    /**\r\n     * Internal method to readjust difficulty\r\n     * @return The new difficulty\r\n     */\r\n    function _adjustDifficulty() internal returns (uint) {\r\n        //every so often, readjust difficulty. Dont readjust when deploying\r\n        if (epochCount % blocksPerReadjustment != 0) {\r\n            return difficulty;\r\n        }\r\n\r\n        uint ethBlocksSinceLastDifficultyPeriod = block.number - latestDifficultyPeriodStarted;\r\n        //assume 360 ethereum blocks per hour\r\n        //we want miners to spend 8 minutes to mine each 'block', about 31 ethereum blocks = one CryptoPepes block\r\n        uint epochsMined = blocksPerReadjustment;\r\n        uint targetEthBlocksPerDiffPeriod = epochsMined * MINING_RATE_FACTOR;\r\n        //if there were less eth blocks passed in time than expected\r\n        if (ethBlocksSinceLastDifficultyPeriod < targetEthBlocksPerDiffPeriod) {\r\n            uint excess_block_pct = (targetEthBlocksPerDiffPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(ethBlocksSinceLastDifficultyPeriod);\r\n            uint excess_block_pct_extra = excess_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT);\r\n            // If there were 5% more blocks mined than expected then this is 5.  If there were 100% more blocks mined than expected then this is 100.\r\n            //make it harder\r\n            difficulty = difficulty.sub(difficulty.div(TARGET_DIVISOR).mul(excess_block_pct_extra));   //by up to 50 %\r\n        } else {\r\n            uint shortage_block_pct = (ethBlocksSinceLastDifficultyPeriod.mul(MAX_ADJUSTMENT_PERCENT)).div(targetEthBlocksPerDiffPeriod);\r\n            uint shortage_block_pct_extra = shortage_block_pct.sub(100).limitLessThan(QUOTIENT_LIMIT); //always between 0 and 1000\r\n            //make it easier\r\n            difficulty = difficulty.add(difficulty.div(TARGET_DIVISOR).mul(shortage_block_pct_extra));   //by up to 50 %\r\n        }\r\n        latestDifficultyPeriodStarted = block.number;\r\n        if (difficulty < _MINIMUM_TARGET) { //very dificult\r\n            difficulty = _MINIMUM_TARGET;\r\n        }\r\n        if (difficulty > _MAXIMUM_TARGET) { //very easy\r\n            difficulty = _MAXIMUM_TARGET;\r\n        }\r\n\r\n        return difficulty;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"TARGET_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pepToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningDifficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challengeDigest\",\"type\":\"bytes32\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pepeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"difficulty\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_ADJUSTMENT_PERCENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningTarget\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINING_RATE_FACTOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_EPOCH_COUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMiningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getChallengeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"baseMiningReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pepeGrinder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensMinted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challengeDigest\",\"type\":\"bytes32\"},{\"name\":\"challengeNumber\",\"type\":\"bytes32\"},{\"name\":\"testTarget\",\"type\":\"uint256\"}],\"name\":\"checkMintSolution\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"epochCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_MAXIMUM_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"challengeNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"miningStart\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"statistics\",\"outputs\":[{\"name\":\"lastRewardTo\",\"type\":\"address\"},{\"name\":\"lastRewardAmount\",\"type\":\"uint256\"},{\"name\":\"lastRewardEthBlockNumber\",\"type\":\"uint256\"},{\"name\":\"lastRewardTimestamp\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"challengeDigest\",\"type\":\"bytes32\"},{\"name\":\"challengeNumber\",\"type\":\"bytes32\"}],\"name\":\"getMintDigest\",\"outputs\":[{\"name\":\"digesttest\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STARTING_DIFFICULTY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"solutionForChallenge\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"QUOTIENT_LIMIT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestDifficultyPeriodStarted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksPerReadjustment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_MINIMUM_TARGET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_pepeContract\",\"type\":\"address\"},{\"name\":\"_pepToken\",\"type\":\"address\"},{\"name\":\"_pepeGrinder\",\"type\":\"address\"},{\"name\":\"_miningStart\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"epochCount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newChallengeNumber\",\"type\":\"bytes32\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Mining","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000084ac94f17622241f313511b629e5e98f489ad6e4000000000000000000000000bb0ef9e617faddf54b8d16e29046f72b4d3ec77f000000000000000000000000d4dd63d658f603e9a0aa381e103e05457cd5e609000000000000000000000000000000000000000000000000000000005bbe05e0","Library":"","SwarmSource":"bzzr://9a140a24fa673e7197cb940d0651c1a32cac4ce25697f216198dc351cac3a607"}]}