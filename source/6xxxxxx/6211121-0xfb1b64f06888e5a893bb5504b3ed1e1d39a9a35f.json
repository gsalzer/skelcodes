{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary CheckOverflows {\r\n    function add(uint256 n1, uint256 n2) internal pure returns(uint256 n3) {\r\n        n3 = n1 + n2;\r\n        require(n3 >= n1);\r\n        return n3;\r\n    }\r\n\r\n    function sub(uint256 n1, uint256 n2) internal pure returns(uint256) {\r\n        require(n2 <= n1);\r\n        return n1 - n2;\r\n    }\r\n\r\n    function mul(uint256 n1, uint256 n2) internal pure returns(uint256 n3) {\r\n        if (n1 == 0 || n2 == 0) {\r\n            return 0;\r\n        }\r\n\r\n        n3 = n1 * n2;\r\n        require(n3 / n1 == n2);\r\n        return n3;\r\n    }\r\n\r\n    function div(uint256 n1, uint256 n2) internal pure returns(uint256) {\r\n        return n1 / n2;\r\n    }\r\n}\r\n\r\n// PolynomialBonding curve\r\n// Each meme is independent on its own on the eth blockchain\r\ncontract Meme {\r\n    string public ipfsHash;\r\n    address public creator; // aka owner\r\n    uint256 exponent;\r\n    uint256 PRECISION;\r\n    uint256 public totalSupply;\r\n    string public name;\r\n    uint256 public decimals;\r\n\r\n    // amount of wei the smart contract holds\r\n    uint256 public poolBalance;\r\n\r\n    using CheckOverflows for uint256;\r\n\r\n    constructor(string _ipfsHash, address _creator, string _name, uint256 _decimals, uint256 _exponent, uint256 _precision) public {\r\n        ipfsHash = _ipfsHash;\r\n        creator = _creator;\r\n        name = _name;\r\n        decimals = _decimals;        // 18\r\n        exponent = _exponent;        // 1\r\n        PRECISION = _precision;      // experimenting with: 10 billion > 10000000000\r\n\r\n        // to reward creators automatically give tokens 100 * 1000\r\n        totalSupply = 100000;\r\n        tokenBalances[msg.sender] = 100000;\r\n    }\r\n\r\n    // tokens owned by each address\r\n    mapping(address => uint256) public tokenBalances;\r\n\r\n    // Calculate the integral from 0 to t (number to integrate to)\r\n    // https://github.com/CryptoAgainstHumanity/crypto-against-humanity/blob/master/ethereum/contracts/WhiteCard.sol#L249\r\n    function curveIntegral(uint256 _t) internal returns(uint256) {\r\n        uint256 nexp = exponent.add(1);\r\n        // calculate integral t^exponent\r\n        return PRECISION.div(nexp).mul(_t ** nexp).div(PRECISION);\r\n    }\r\n\r\n    // minting new tokens > aka voting\r\n    function mint(uint256 _numTokens) public payable {\r\n        uint256 priceForTokens = getMintingPrice(_numTokens);\r\n        require(msg.value >= priceForTokens, \"Not enough value for total price of tokens\");\r\n\r\n        totalSupply = totalSupply.add(_numTokens);\r\n        tokenBalances[msg.sender] = tokenBalances[msg.sender].add(_numTokens);\r\n        poolBalance = poolBalance.add(priceForTokens);\r\n\r\n        // send back the change\r\n        if (msg.value > priceForTokens) {\r\n            msg.sender.transfer(msg.value.sub(priceForTokens));\r\n        }\r\n    }\r\n\r\n    function getMintingPrice(uint256 _numTokens) public view returns(uint256) {\r\n        return curveIntegral(totalSupply.add(_numTokens)).sub(poolBalance);\r\n    }\r\n\r\n    // burning tokens >> eth to return\r\n    function burn(uint256 _numTokens) public {\r\n        require(tokenBalances[msg.sender] >= _numTokens, \"Not enough owned tokens to burn\");\r\n\r\n        uint256 ethToReturn = getBurningReward(_numTokens);\r\n\r\n        totalSupply = totalSupply.sub(_numTokens);\r\n        poolBalance = poolBalance.sub(ethToReturn);\r\n\r\n        // 3% fee go to site creators, the rest to former tokens owner\r\n        uint256 fee = ethToReturn.div(100).mul(3);\r\n\r\n        address(0x45405DAa47EFf12Bc225ddcAC932Ce5ef965B39b).transfer(fee);\r\n        msg.sender.transfer(ethToReturn.sub(fee));\r\n    }\r\n\r\n    function getBurningReward(uint256 _numTokens) public view returns(uint256) {\r\n        return poolBalance.sub(curveIntegral(totalSupply.sub(_numTokens)));\r\n    }\r\n\r\n    function kill() public {\r\n        // I give myself the ability to kill any contracts, though will only do so with duplicates aka cheaters\r\n        require(msg.sender == address(0x45405DAa47EFf12Bc225ddcAC932Ce5ef965B39b));\r\n        selfdestruct(this);\r\n    }\r\n}\r\n\r\n// Factory contract: keeps track of meme for only leaderboard and view purposes\r\ncontract MemeRecorder {\r\n    address[] public memeContracts;\r\n\r\n    constructor() public {}\r\n\r\n    function addMeme(string _ipfsHash, string _name) public {\r\n        Meme newMeme;\r\n        newMeme = new Meme(_ipfsHash, msg.sender, _name, 18, 1, 10000000000);\r\n        memeContracts.push(newMeme);\r\n    }\r\n\r\n    function getMemes() public view returns(address[]) {\r\n        return memeContracts;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getMemes\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"memeContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ipfsHash\",\"type\":\"string\"},{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"addMeme\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"MemeRecorder","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://be12edd4864fa5df4cc485a58273534d85e110f7268192b9d167476d23489383"}]}