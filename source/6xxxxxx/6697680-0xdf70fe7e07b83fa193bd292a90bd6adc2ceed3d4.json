{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ExchangeArbitrage token contract\r\n//\r\n// Symbol      : EXARB\r\n// Name        : Exchange Arbitrage Token\r\n// Decimals    : 18\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ExchangeArbitrageToken is Owned {\r\n    using SafeMath for uint;\r\n\r\n    string public symbol = \"EXARB\";\r\n    string public name = \"Exchange Arbitrage Token\";\r\n    uint8 public decimals = 18;\r\n\r\n    uint minted_tokens;\r\n    uint exchange_rate;\r\n    uint max_minted_supply;\r\n    uint cash_out_rate;\r\n\r\n    mapping(address => mapping (address => uint)) allowed;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event MintTokens(address from, uint amount);\r\n\r\n    event ExchangeRateSet(uint exchange_rate);\r\n    event CashOutRateSet(uint exchange_rate);\r\n    event MaxMintedSupplySet(uint max_minted_supply);\r\n    event Approval(address tokenOwner, address spender, uint tokens);\r\n\r\n    // historical tracking of balances at a particular block\r\n    mapping(address => BlockBalance[]) block_balances;\r\n    struct BlockBalance {\r\n        uint block_id;\r\n        uint balance;\r\n    }\r\n\r\n    // keep track of which token owners picked up their payout amounts\r\n    // ( token_owner => ( payout_id => paid_out_amount ) )\r\n    mapping(address => mapping(uint16 => uint)) collected_payouts;\r\n\r\n    // basic array that has all of the payout ids\r\n    uint16[] payout_ids;\r\n\r\n    // mapping that has the payout details.\r\n    mapping(uint16 => PayoutBlock) payouts;\r\n    struct PayoutBlock {\r\n        uint block_id;\r\n        uint amount;\r\n        uint minted_tokens;\r\n    }\r\n\r\n    constructor() public payable {\r\n        minted_tokens = 0;\r\n        exchange_rate = 210;\r\n        cash_out_rate = 50000000000000;\r\n        max_minted_supply = 450000000000000000000000;\r\n        emit MaxMintedSupplySet(max_minted_supply);\r\n        emit CashOutRateSet(cash_out_rate);\r\n        emit ExchangeRateSet(exchange_rate);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return minted_tokens;\r\n    }\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return getTokenBalanceOf(tokenOwner);\r\n    }\r\n\r\n    function allowance(address tokenOwner, address spender) public constant returns(uint remaining){\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        require(tokens > 0, \"Transfer must be positive.\");\r\n        require(allowed[from][msg.sender] >= tokens, \"Not enough allowed tokens.\");\r\n        subtractTokenBalanceFrom(from, tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        addTokenBalanceTo(to, tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function ownershipPercentageOf(address tokenOwner) public view returns (uint percentage_8_decimals) {\r\n        return balanceOf(tokenOwner).mul(10000000000).div(minted_tokens);\r\n    }\r\n\r\n    function allPayoutIds() public view returns (uint16[]) {\r\n        return payout_ids;\r\n    }\r\n\r\n    function getPayoutAmountForId(uint16 payout_id) public view returns (uint) {\r\n        return payouts[payout_id].amount;\r\n    }\r\n\r\n    function getPayoutBlockForId(uint16 payout_id) public view returns (uint) {\r\n        return payouts[payout_id].block_id;\r\n    }\r\n\r\n    function ethToTokenExchangeRate() public view returns (uint) {\r\n        return exchange_rate;\r\n    }\r\n\r\n    function limitMintedSupply() public view returns (uint) {\r\n        return max_minted_supply;\r\n    }\r\n\r\n    function limitCashOutRate() public view returns (uint) {\r\n        return cash_out_rate;\r\n    }\r\n\r\n    function payoutAmountFor(uint16 payout_id) public view returns (uint) {\r\n        require(payouts[payout_id].block_id > 0, \"Invalid payout_id\");\r\n        require(block_balances[msg.sender].length > 0, \"This address has no history on this contract.\");\r\n\r\n        PayoutBlock storage payout_block = payouts[payout_id];\r\n        BlockBalance memory relevant_block;\r\n        for(uint i = 0; i < block_balances[msg.sender].length; i++) {\r\n            if (block_balances[msg.sender][i].block_id < payout_block.block_id  ) {\r\n                relevant_block = block_balances[msg.sender][i];\r\n            }\r\n        }\r\n        return relevant_block.balance.mul(payout_block.amount).div(payout_block.minted_tokens);\r\n    }\r\n\r\n    function payoutCollected(uint16 payout_id) public view returns (bool) {\r\n        return collected_payouts[msg.sender][payout_id] > 0;\r\n    }\r\n\r\n    function payoutCollect(uint16 payout_id) public returns (bool success) {\r\n        require(collected_payouts[msg.sender][payout_id] == 0, \"Payment already collected\");\r\n        uint payout = payoutAmountFor(payout_id);\r\n        require(address(this).balance >= payout, \"Balance is too low.\");\r\n        collected_payouts[msg.sender][payout_id] = payout;\r\n        msg.sender.transfer(payout);\r\n        return true;\r\n    }\r\n\r\n    function calculateCashOut() public view returns (uint amount) {\r\n        uint current_token_balance = getTokenBalanceOf(msg.sender);\r\n        uint payout = current_token_balance.mul(cash_out_rate).div(1000000000000000000);\r\n        return payout;\r\n    }\r\n\r\n    function cashOut() public returns (bool success) {\r\n        uint current_token_balance = getTokenBalanceOf(msg.sender);\r\n        require(current_token_balance > 0, 'Address has no balance');\r\n        uint payout = current_token_balance.mul(cash_out_rate).div(1000000000000000000);\r\n        subtractTokenBalanceFrom(msg.sender, current_token_balance);\r\n        minted_tokens = minted_tokens.sub(current_token_balance);\r\n        msg.sender.transfer(payout);\r\n        return true;\r\n    }\r\n\r\n    // Allow anyone to transfer to anyone else as long as they have enough balance.\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        require(tokens > 0, \"Transfer must be positive.\");\r\n\r\n        subtractTokenBalanceFrom(msg.sender, tokens);\r\n        addTokenBalanceTo(to, tokens);\r\n\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function () public payable {\r\n        if (msg.sender != owner){\r\n            require(msg.value.mul(exchange_rate) + minted_tokens < max_minted_supply, \"Contract Fully Funded.  Try again later.\");\r\n            mint(msg.sender, msg.value);\r\n            if (!owner.send(msg.value)) { revert(); }\r\n        } else {\r\n            require(msg.value > 0);  // owner sent funds.  keep on contract for payouts.\r\n        }\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    //   private functions\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function mint(address sender, uint value) private {\r\n        uint tokens = value.mul(exchange_rate);\r\n        addTokenBalanceTo(sender, tokens);\r\n        minted_tokens = minted_tokens.add(tokens);\r\n        emit MintTokens(sender, tokens);\r\n    }\r\n\r\n    function getTokenBalanceOf(address tokenOwner) private view returns (uint tokens) {\r\n        uint owner_block_balance_length = block_balances[tokenOwner].length;\r\n        if (owner_block_balance_length == 0) {\r\n            return 0;\r\n        } else {\r\n            return block_balances[tokenOwner][owner_block_balance_length-1].balance;\r\n        }\r\n    }\r\n\r\n    function addTokenBalanceTo(address tokenOwner, uint value) private {\r\n        uint owner_block_balance_length = block_balances[tokenOwner].length;\r\n        if (owner_block_balance_length == 0) {\r\n            block_balances[tokenOwner].push(BlockBalance({ block_id: block.number, balance: value }));\r\n        } else {\r\n            BlockBalance storage owner_last_block_balance = block_balances[tokenOwner][owner_block_balance_length-1];\r\n\r\n            uint owner_current_balance = getTokenBalanceOf(tokenOwner);\r\n\r\n            // if we have never had any payouts or there has been no payout since the last time the user sent eth.\r\n            //   --> reuse the last location\r\n            // else --> create a new location\r\n            if (payout_ids.length == 0 || owner_last_block_balance.block_id > payouts[payout_ids[payout_ids.length-1]].block_id ) {\r\n                // overwrite last item in the array.\r\n                block_balances[tokenOwner][owner_block_balance_length-1] = BlockBalance({ block_id: block.number, balance: owner_current_balance.add(value) });\r\n            } else {\r\n                block_balances[tokenOwner].push(BlockBalance({ block_id: block.number, balance: owner_current_balance.add(value) }));\r\n            }\r\n        }\r\n    }\r\n\r\n    function subtractTokenBalanceFrom(address tokenOwner, uint value) private {\r\n        uint owner_block_balance_length = block_balances[tokenOwner].length;\r\n        if (owner_block_balance_length == 0) {\r\n            revert('Can not remove balance from an address with no history.');\r\n        } else {\r\n            BlockBalance storage owner_last_block_balance = block_balances[tokenOwner][owner_block_balance_length-1];\r\n\r\n            uint owner_current_balance = getTokenBalanceOf(tokenOwner);\r\n\r\n            // if we have never had any payouts or there has been no payout since the last time the user sent eth.\r\n            //   --> reuse the last location\r\n            // else --> create a new location\r\n            if (payout_ids.length == 0 || owner_last_block_balance.block_id > payouts[payout_ids[payout_ids.length-1]].block_id ) {\r\n                // overwrite last item in the array.\r\n                block_balances[tokenOwner][owner_block_balance_length-1] = BlockBalance({ block_id: block.number, balance: owner_current_balance.sub(value) });\r\n            } else {\r\n                block_balances[tokenOwner].push(BlockBalance({ block_id: block.number, balance: owner_current_balance.sub(value) }));\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    //   onlyOwner functions.\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function payout(uint16 payout_id, uint amount) public onlyOwner returns (bool success) {\r\n        require(payouts[payout_id].block_id == 0);\r\n        payouts[payout_id] = PayoutBlock({ block_id: block.number, amount: amount, minted_tokens: minted_tokens });\r\n        payout_ids.push(payout_id);\r\n        return true;\r\n    }\r\n\r\n    function setExchangeRate(uint newRate) public onlyOwner returns (bool success) {\r\n        exchange_rate = newRate;\r\n        emit ExchangeRateSet(newRate);\r\n        return true;\r\n    }\r\n\r\n    function setCashOutRate(uint newRate) public onlyOwner returns (bool success) {\r\n        cash_out_rate = newRate;\r\n        emit CashOutRateSet(newRate);\r\n        return true;\r\n    }\r\n\r\n    function setMaxMintedSupply(uint newMaxMintedSupply) public onlyOwner returns (bool success) {\r\n        max_minted_supply = newMaxMintedSupply;\r\n        emit MaxMintedSupplySet(max_minted_supply);\r\n        return true;\r\n    }\r\n\r\n    function ownerTransfer(address from, address to, uint tokens) public onlyOwner returns (bool success) {\r\n        require(tokens > 0, \"Transfer must be positive.\");\r\n\r\n        subtractTokenBalanceFrom(from, tokens);\r\n        addTokenBalanceTo(to, tokens);\r\n\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function ownerMint(address to, uint tokens) public onlyOwner returns (bool success) {\r\n        addTokenBalanceTo(to, tokens);\r\n        minted_tokens = minted_tokens.add(tokens);\r\n        emit MintTokens(to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function destroy() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitMintedSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"getPayoutAmountForId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ownerMint\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateCashOut\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setCashOutRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashOut\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitCashOutRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"ownershipPercentageOf\",\"outputs\":[{\"name\":\"percentage_8_decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"payoutCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ownerTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"getPayoutBlockForId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allPayoutIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"payoutCollect\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxMintedSupply\",\"type\":\"uint256\"}],\"name\":\"setMaxMintedSupply\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"payoutAmountFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethToTokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"exchange_rate\",\"type\":\"uint256\"}],\"name\":\"ExchangeRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"exchange_rate\",\"type\":\"uint256\"}],\"name\":\"CashOutRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"max_minted_supply\",\"type\":\"uint256\"}],\"name\":\"MaxMintedSupplySet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ExchangeArbitrageToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5e9c93be1efbd6c2fcb062075f797edd9d77396e7040e233a26918c6e6182833"}]}