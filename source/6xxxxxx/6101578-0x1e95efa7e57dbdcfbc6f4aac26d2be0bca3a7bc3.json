{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n// Interface for burning tokens\r\ncontract Burnable {\r\n  // @dev Destroys tokens for an account\r\n  // @param account Account whose tokens are destroyed\r\n  // @param value Amount of tokens to destroy\r\n  function _burnTokens(address account, uint value) internal;\r\n  event Burned(address account, uint value);\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  event Error(string _t);\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract HoldAssistant is Ownable {\r\n\r\n\tstruct stholdPeriod {\r\n        uint256 startsAtTime;\r\n        uint256 endsAtTime;\r\n\t\tuint256 balance;\r\n    }\r\n    mapping (address => stholdPeriod) private holdPeriod;\r\n\r\n\tevent Log_AdminHold(address _holder, uint _balance, bool _status);\r\n\tfunction adminHold(address _holder, uint _balance, bool _status) public returns (bool) {\r\n\t\temit Log_AdminHold(_holder, _balance, _status);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tevent Log_Hold(address _holder, uint _balance, bool _status);\r\n\tfunction hold(address _holder, uint _balance, bool _status) public returns (bool) {\r\n\t\temit Log_Hold(_holder, _balance, _status);\r\n\t\treturn true;\r\n\t}\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\ncontract StandardToken is Burnable, Pausable {\r\n    using SafeMath for uint;\r\n\r\n    uint private total_supply;\r\n    uint public decimals;\r\n\r\n    // This creates an array with all balances\r\n    mapping (address => uint) private balances;\r\n    mapping (address => mapping (address => uint)) private allowed;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n\r\n    //Constructor\r\n    constructor(uint supply, uint token_decimals, address token_retriever) public {\r\n        decimals                    = token_decimals;\r\n        total_supply                = supply * uint(10) ** decimals ; // 10 ** 9,  1000 millions\r\n        balances[token_retriever]   = total_supply;                   // Give to the creator all initial tokens\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return total_supply;\r\n    }\r\n\r\n    //Public interface for balances\r\n    function balanceOf(address account) public view returns (uint balance) {\r\n        return balances[account];\r\n    }\r\n\r\n    //Public interface for allowances\r\n    function allowance(address account, address spender) public view returns (uint remaining) {\r\n        return allowed[account][spender];\r\n    }\r\n\r\n    //Internal transfer, only can be called by this contract\r\n    function _transfer(address _from, address _to, uint _value) internal {\r\n        require(_to != 0x0);                        //Burn is an specific op\r\n        require(balances[_from] >= _value);        //Enough ?\r\n        require(balances[_to].add(_value) >= balances[_to]);\r\n\r\n        // Save this for an assertion in the future\r\n        uint previousBalances = balances[_from].add(balances[_to]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to]  = balances[_to].add(_value);\r\n\r\n        emit Transfer(_from, _to, _value);\r\n\r\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\r\n        assert(balances[_from].add(balances[_to]) == previousBalances);\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public whenNotPaused returns (bool success){\r\n        _transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public whenNotPaused returns (bool success) {\r\n        require(_value <= allowed[_from][msg.sender]);     // Check allowance\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub( _value);\r\n        _transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function _approve(address _holder, address _spender, uint _value) internal {\r\n        require(_value <= total_supply);\r\n        require(_value >= 0);\r\n        allowed[_holder][_spender] = _value;\r\n        emit Approval(_holder, _spender,_value);\r\n    }\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        _approve(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function safeApprove(address _spender, uint _currentValue, uint _value)  public returns (bool success) {\r\n        require(allowed[msg.sender][_spender] == _currentValue);\r\n        _approve(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     */\r\n    function _burnTokens(address from, uint _value) internal {\r\n        require(balances[from] >= _value);                    // Check if the sender has enough\r\n        balances[from] = balances[from].sub(_value);    // Subtract from the sender\r\n        total_supply = total_supply.sub(_value);                    // Updates totalSupply\r\n        emit  Burned(from, _value);\r\n    }\r\n\r\n    function burn(uint _value) public whenNotPaused returns (bool success) {\r\n        _burnTokens(msg.sender,_value);\r\n        return true;\r\n    }\r\n}\r\n\r\n//Define interface for releasing the token transfer after a successful crowdsale.\r\ncontract HoldableToken is StandardToken {\r\n\r\n\t//Specific block to support holdwallet\r\n    mapping (address => bool) private holdFlag;\r\n\r\n    //Another contract can do a finer track of the hold\r\n    address public holdAssistantAddr = address(0);\r\n\r\n\tfunction holded(address _account) public view returns(bool) {\r\n\t\treturn holdFlag[_account];\r\n\t}\r\n\r\n    function adminHold(bool _status) public onlyOwner returns (bool) {\r\n        holdFlag[msg.sender] = _status;\r\n\r\n        //Just in case that fine tracker exists\r\n        if (address(0) != holdAssistantAddr) {\r\n            HoldAssistant(holdAssistantAddr).adminHold(msg.sender, balanceOf(msg.sender), _status);\r\n        }\r\n        emit Log_AdminHold(msg.sender, block.number, balanceOf(msg.sender), _status);\r\n\t\treturn true;\r\n    }\r\n    function hold(bool _status) public returns (bool) {\r\n        holdFlag[msg.sender] = _status;\r\n\r\n        //Just in case that fine tracker exists\r\n        if (address(0) != holdAssistantAddr) {\r\n            require(HoldAssistant(holdAssistantAddr).hold(msg.sender, balanceOf(msg.sender), _status));\r\n        }\r\n        emit Log_Hold(msg.sender, block.number, balanceOf(msg.sender), _status);\r\n\t\treturn true;\r\n    }\r\n    event Log_Hold(address indexed _account, uint _holdBlock, uint _balance, bool _holded);\r\n    event Log_AdminHold(address indexed _account, uint _holdBlock, uint _balance, bool _holded);\r\n\r\n    function setHoldAssistant(address _newHoldAssistant) public onlyOwner returns(bool) {\r\n        holdAssistantAddr = _newHoldAssistant;\r\n        emit Log_SetHoldAssistant(holdAssistantAddr);\r\n\t\treturn true;\r\n    }\r\n    event Log_SetHoldAssistant(address);\r\n\r\n    modifier notHolded(address _account) {\r\n        require(! holdFlag[_account]);\r\n        _;\r\n    }\r\n\r\n\r\n  \t//We restrict transfers by overriding it\r\n  \tfunction transfer(address to, uint value) public notHolded(msg.sender) returns (bool success) {\r\n  \t\treturn super.transfer(to, value);\r\n  \t}\r\n\r\n  \t//We restrict transferFrom by overriding it\r\n  \t//\"from\" must be an agent before released\r\n  \tfunction transferFrom(address from, address to, uint value) public notHolded(from) returns (bool success) {\r\n   \t \treturn super.transferFrom(from, to, value);\r\n  \t}\r\n\r\n  \t//We restrict burn by overriding it\r\n  \tfunction burn(uint value) public notHolded(msg.sender) returns (bool success) {\r\n    \treturn super.burn(value);\r\n  \t}\r\n\r\n}\r\n\r\n/**\r\n * Math operations with safety checks\r\n */\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a && c>=b);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\n\r\n//Define interface for Manage + release a resource normal operation after an external trigger\r\ncontract Releasable is Ownable {\r\n\r\n  address public releaseAgent;\r\n  bool public released = false;\r\n  mapping (address => bool) public Agents;\r\n\r\n  event ReleaseAgent(address previous, address newAgent);\r\n\r\n  //Set the contract that can call release and make the resource operative\r\n  function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public {\r\n    releaseAgent = addr;\r\n    emit ReleaseAgent(releaseAgent, addr);\r\n  }\r\n\r\n  // Owner can allow a particular address (e.g. a crowdsale contract) to be Agent to manage the resource\r\n  function setAgent(address addr) onlyOwner inReleaseState(false) public returns(bool){\r\n    Agents[addr] = true;\r\n    emit Agent(addr,true);\r\n    return true;\r\n  }\r\n\r\n  // Owner forbids a particular address (e.g. a crowdsale contract) to be Agent to manage the resource\r\n  function resetAgent(address addr) onlyOwner inReleaseState(false) public returns(bool){\r\n    Agents[addr] = false;\r\n    emit Agent(addr,false);\r\n    return true;\r\n  }\r\n    event Agent(address addr, bool status);\r\n\r\n  function amIAgent() public view returns (bool) {\r\n    return Agents[msg.sender];\r\n  }\r\n\r\n  function isAgent(address addr) public view /*onlyOwner */ returns(bool) {\r\n    return Agents[addr];\r\n  }\r\n\r\n  //From now the resource is free\r\n  function releaseOperation() public onlyReleaseAgent {\r\n        released = true;\r\n\t\temit Released();\r\n  }\r\n  event Released();\r\n\r\n  // Limit resource operative until the release\r\n  modifier canOperate(address sender) {\r\n    require(released || Agents[sender]);\r\n    _;\r\n  }\r\n\r\n  //The function can be called only before or after the tokens have been released\r\n  modifier inReleaseState(bool releaseState) {\r\n    require(releaseState == released);\r\n    _;\r\n  }\r\n\r\n  //The function can be called only by a whitelisted release agent.\r\n  modifier onlyReleaseAgent() {\r\n    require(msg.sender == releaseAgent);\r\n    _;\r\n  }\r\n}\r\n\r\n//Define interface for releasing the token transfer after a successful crowdsale.\r\ncontract ReleasableToken is Releasable, HoldableToken {\r\n\r\n  //We restrict transfer by overriding it\r\n  function transfer(address to, uint value) public canOperate(msg.sender) returns (bool success) {\r\n   return super.transfer(to, value);\r\n  }\r\n\r\n  //We restrict transferFrom by overriding it\r\n  //\"from\" must be an agent before released\r\n  function transferFrom(address from, address to, uint value) public canOperate(from) returns (bool success) {\r\n    return super.transferFrom(from, to, value);\r\n  }\r\n\r\n  //We restrict burn by overriding it\r\n  function burn(uint value) public canOperate(msg.sender) returns (bool success) {\r\n    return super.burn(value);\r\n  }\r\n}\r\n\r\n\r\ncontract ALIVE is ReleasableToken {\r\n\r\n    string public name = \"ALIVE\";\r\n    string public symbol = \"AL \";\r\n\r\n    //    Constructor\r\n    constructor (uint supply, uint token_decimals, address token_retriever) StandardToken(supply, token_decimals, token_retriever) public { }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"resetAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_account\",\"type\":\"address\"}],\"name\":\"holded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"adminHold\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"isAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setReleaseAgent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amIAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newHoldAssistant\",\"type\":\"address\"}],\"name\":\"setHoldAssistant\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"hold\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"Agents\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"holdAssistantAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"released\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_currentValue\",\"type\":\"uint256\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"safeApprove\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseOperation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"supply\",\"type\":\"uint256\"},{\"name\":\"token_decimals\",\"type\":\"uint256\"},{\"name\":\"token_retriever\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_holdBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_holded\",\"type\":\"bool\"}],\"name\":\"Log_Hold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_holdBlock\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_balance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_holded\",\"type\":\"bool\"}],\"name\":\"Log_AdminHold\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"\",\"type\":\"address\"}],\"name\":\"Log_SetHoldAssistant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previous\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newAgent\",\"type\":\"address\"}],\"name\":\"ReleaseAgent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"bool\"}],\"name\":\"Agent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Released\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_t\",\"type\":\"string\"}],\"name\":\"Error\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burned\",\"type\":\"event\"}]","ContractName":"ALIVE","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000003b9aca000000000000000000000000000000000000000000000000000000000000000004000000000000000000000000a6cca6f189cd00e7092ddcb8d95937d9d2f59801","Library":"","SwarmSource":"bzzr://f94e5a06946e99e5158895c39468047433704c98527ca06b7c5b7e78d86fa727"}]}