{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\ninterface StorageInterface {\r\n  function getTarget(bytes32 exec_id, bytes4 selector)\r\n      external view returns (address implementation);\r\n  function getIndex(bytes32 exec_id) external view returns (address index);\r\n  function createInstance(address sender, bytes32 app_name, address provider, bytes32 registry_exec_id, bytes calldata)\r\n      external payable returns (bytes32 instance_exec_id, bytes32 version);\r\n  function createRegistry(address index, address implementation) external returns (bytes32 exec_id);\r\n  function exec(address sender, bytes32 exec_id, bytes calldata)\r\n      external payable returns (uint emitted, uint paid, uint stored);\r\n}\r\n\r\ninterface RegistryInterface {\r\n  function getLatestVersion(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name)\r\n      external view returns (bytes32 latest_name);\r\n  function getVersionImplementation(address stor_addr, bytes32 exec_id, address provider, bytes32 app_name, bytes32 version_name)\r\n      external view returns (address index, bytes4[] selectors, address[] implementations);\r\n}\r\n\r\ncontract ScriptExec {\r\n\r\n  /// DEFAULT VALUES ///\r\n\r\n  address public app_storage;\r\n  address public provider;\r\n  bytes32 public registry_exec_id;\r\n  address public exec_admin;\r\n\r\n  /// APPLICATION INSTANCE METADATA ///\r\n\r\n  struct Instance {\r\n    address current_provider;\r\n    bytes32 current_registry_exec_id;\r\n    bytes32 app_exec_id;\r\n    bytes32 app_name;\r\n    bytes32 version_name;\r\n  }\r\n\r\n  // Maps the execution ids of deployed instances to the address that deployed them -\r\n  mapping (bytes32 => address) public deployed_by;\r\n  // Maps the execution ids of deployed instances to a struct containing their metadata -\r\n  mapping (bytes32 => Instance) public instance_info;\r\n  // Maps an address that deployed app instances to metadata about the deployed instance -\r\n  mapping (address => Instance[]) public deployed_instances;\r\n  // Maps an application name to the exec ids under which it is deployed -\r\n  mapping (bytes32 => bytes32[]) public app_instances;\r\n\r\n  /// EVENTS ///\r\n\r\n  event AppInstanceCreated(address indexed creator, bytes32 indexed execution_id, bytes32 app_name, bytes32 version_name);\r\n  event StorageException(bytes32 indexed execution_id, string message);\r\n\r\n  // Modifier - The sender must be the contract administrator\r\n  modifier onlyAdmin() {\r\n    require(msg.sender == exec_admin);\r\n    _;\r\n  }\r\n\r\n  // Payable function - for abstract storage refunds\r\n  function () public payable { }\r\n\r\n  /*\r\n  Configure various defaults for a script exec contract\r\n  @param _exec_admin: A privileged address, able to set the target provider and registry exec id\r\n  @param _app_storage: The address to which applications will be stored\r\n  @param _provider: The address under which applications have been initialized\r\n  */\r\n  function configure(address _exec_admin, address _app_storage, address _provider) public {\r\n    require(app_storage == 0, \"ScriptExec already configured\");\r\n    require(_app_storage != 0, 'Invalid input');\r\n    exec_admin = _exec_admin;\r\n    app_storage = _app_storage;\r\n    provider = _provider;\r\n\r\n    if (exec_admin == 0)\r\n      exec_admin = msg.sender;\r\n  }\r\n\r\n  /// APPLICATION EXECUTION ///\r\n\r\n  bytes4 internal constant EXEC_SEL = bytes4(keccak256('exec(address,bytes32,bytes)'));\r\n\r\n  /*\r\n  Executes an application using its execution id and storage address.\r\n\r\n  @param _exec_id: The instance exec id, which will route the calldata to the appropriate destination\r\n  @param _calldata: The calldata to forward to the application\r\n  @return success: Whether execution succeeded or not\r\n  */\r\n  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success);\r\n\r\n  bytes4 internal constant ERR = bytes4(keccak256('Error(string)'));\r\n\r\n  // Return the bytes4 action requestor stored at the pointer, and cleans the remaining bytes\r\n  function getAction(uint _ptr) internal pure returns (bytes4 action) {\r\n    assembly {\r\n      // Get the first 4 bytes stored at the pointer, and clean the rest of the bytes remaining\r\n      action := and(mload(_ptr), 0xffffffff00000000000000000000000000000000000000000000000000000000)\r\n    }\r\n  }\r\n\r\n  // Checks to see if an error message was returned with the failed call, and emits it if so -\r\n  function checkErrors(bytes32 _exec_id) internal {\r\n    // If the returned data begins with selector 'Error(string)', get the contained message -\r\n    string memory message;\r\n    bytes4 err_sel = ERR;\r\n    assembly {\r\n      // Get pointer to free memory, place returned data at pointer, and update free memory pointer\r\n      let ptr := mload(0x40)\r\n      returndatacopy(ptr, 0, returndatasize)\r\n      mstore(0x40, add(ptr, returndatasize))\r\n\r\n      // Check value at pointer for equality with Error selector -\r\n      if eq(mload(ptr), and(err_sel, 0xffffffff00000000000000000000000000000000000000000000000000000000)) {\r\n        message := add(0x24, ptr)\r\n      }\r\n    }\r\n    // If no returned message exists, emit a default error message. Otherwise, emit the error message\r\n    if (bytes(message).length == 0)\r\n      emit StorageException(_exec_id, \"No error recieved\");\r\n    else\r\n      emit StorageException(_exec_id, message);\r\n  }\r\n\r\n  // Checks data returned by an application and returns whether or not the execution changed state\r\n  function checkReturn() internal pure returns (bool success) {\r\n    success = false;\r\n    assembly {\r\n      // returndata size must be 0x60 bytes\r\n      if eq(returndatasize, 0x60) {\r\n        // Copy returned data to pointer and check that at least one value is nonzero\r\n        let ptr := mload(0x40)\r\n        returndatacopy(ptr, 0, returndatasize)\r\n        if iszero(iszero(mload(ptr))) { success := 1 }\r\n        if iszero(iszero(mload(add(0x20, ptr)))) { success := 1 }\r\n        if iszero(iszero(mload(add(0x40, ptr)))) { success := 1 }\r\n      }\r\n    }\r\n    return success;\r\n  }\r\n\r\n  /// APPLICATION INITIALIZATION ///\r\n\r\n  /*\r\n  Initializes an instance of an application. Uses default app provider and registry app.\r\n  Uses latest app version by default.\r\n  @param _app_name: The name of the application to initialize\r\n  @param _init_calldata: Calldata to be forwarded to the application's initialization function\r\n  @return exec_id: The execution id (within the application's storage) of the created application instance\r\n  @return version: The name of the version of the instance\r\n  */\r\n  function createAppInstance(bytes32 _app_name, bytes _init_calldata) external returns (bytes32 exec_id, bytes32 version) {\r\n    require(_app_name != 0 && _init_calldata.length >= 4, 'invalid input');\r\n    (exec_id, version) = StorageInterface(app_storage).createInstance(\r\n      msg.sender, _app_name, provider, registry_exec_id, _init_calldata\r\n    );\r\n    // Set various app metadata values -\r\n    deployed_by[exec_id] = msg.sender;\r\n    app_instances[_app_name].push(exec_id);\r\n    Instance memory inst = Instance(\r\n      provider, registry_exec_id, exec_id, _app_name, version\r\n    );\r\n    instance_info[exec_id] = inst;\r\n    deployed_instances[msg.sender].push(inst);\r\n    // Emit event -\r\n    emit AppInstanceCreated(msg.sender, exec_id, _app_name, version);\r\n  }\r\n\r\n  /// ADMIN FUNCTIONS ///\r\n\r\n  /*\r\n  Allows the exec admin to set the registry exec id from which applications will be initialized -\r\n  @param _exec_id: The new exec id from which applications will be initialized\r\n  */\r\n  function setRegistryExecID(bytes32 _exec_id) public onlyAdmin() {\r\n    registry_exec_id = _exec_id;\r\n  }\r\n\r\n  /*\r\n  Allows the exec admin to set the provider from which applications will be initialized in the given registry exec id\r\n  @param _provider: The address under which applications to initialize are registered\r\n  */\r\n  function setProvider(address _provider) public onlyAdmin() {\r\n    provider = _provider;\r\n  }\r\n\r\n  // Allows the admin to set a new admin address\r\n  function setAdmin(address _admin) public onlyAdmin() {\r\n    require(_admin != 0);\r\n    exec_admin = _admin;\r\n  }\r\n\r\n  /// STORAGE GETTERS ///\r\n\r\n  // Returns a list of execution ids under which the given app name was deployed\r\n  function getInstances(bytes32 _app_name) public view returns (bytes32[] memory) {\r\n    return app_instances[_app_name];\r\n  }\r\n\r\n  /*\r\n  Returns the number of instances an address has created\r\n  @param _deployer: The address that deployed the instances\r\n  @return uint: The number of instances deployed by the deployer\r\n  */\r\n  function getDeployedLength(address _deployer) public view returns (uint) {\r\n    return deployed_instances[_deployer].length;\r\n  }\r\n\r\n  // The function selector for a simple registry 'registerApp' function\r\n  bytes4 internal constant REGISTER_APP_SEL = bytes4(keccak256('registerApp(bytes32,address,bytes4[],address[])'));\r\n\r\n  /*\r\n  Returns the index address and implementing address for the simple registry app set as the default\r\n  @return indx: The index address for the registry application - contains getters for the Registry, as well as its init funciton\r\n  @return implementation: The address implementing the registry's functions\r\n  */\r\n  function getRegistryImplementation() public view returns (address index, address implementation) {\r\n    index = StorageInterface(app_storage).getIndex(registry_exec_id);\r\n    implementation = StorageInterface(app_storage).getTarget(registry_exec_id, REGISTER_APP_SEL);\r\n  }\r\n\r\n  /*\r\n  Returns the functions and addresses implementing those functions that make up an application under the give execution id\r\n  @param _exec_id: The execution id that represents the application in storage\r\n  @return index: The index address of the instance - holds the app's getter functions and init functions\r\n  @return functions: A list of function selectors supported by the application\r\n  @return implementations: A list of addresses corresponding to the function selectors, where those selectors are implemented\r\n  */\r\n  function getInstanceImplementation(bytes32 _exec_id) public view\r\n  returns (address index, bytes4[] memory functions, address[] memory implementations) {\r\n    Instance memory app = instance_info[_exec_id];\r\n    index = StorageInterface(app_storage).getIndex(app.current_registry_exec_id);\r\n    (index, functions, implementations) = RegistryInterface(index).getVersionImplementation(\r\n      app_storage, app.current_registry_exec_id, app.current_provider, app.app_name, app.version_name\r\n    );\r\n  }\r\n}\r\n\r\ncontract RegistryExec is ScriptExec {\r\n\r\n  struct Registry {\r\n    address index;\r\n    address implementation;\r\n  }\r\n\r\n  // Maps execution ids to its registry app metadata\r\n  mapping (bytes32 => Registry) public registry_instance_info;\r\n  // Maps address to list of deployed Registry instances\r\n  mapping (address => Registry[]) public deployed_registry_instances;\r\n\r\n  /// EVENTS ///\r\n\r\n  event RegistryInstanceCreated(address indexed creator, bytes32 indexed execution_id, address index, address implementation);\r\n\r\n  /// APPLICATION EXECUTION ///\r\n\r\n  bytes4 internal constant EXEC_SEL = bytes4(keccak256('exec(address,bytes32,bytes)'));\r\n\r\n  /*\r\n  Executes an application using its execution id and storage address.\r\n\r\n  @param _exec_id: The instance exec id, which will route the calldata to the appropriate destination\r\n  @param _calldata: The calldata to forward to the application\r\n  @return success: Whether execution succeeded or not\r\n  */\r\n  function exec(bytes32 _exec_id, bytes _calldata) external payable returns (bool success) {\r\n    // Get function selector from calldata -\r\n    bytes4 sel = getSelector(_calldata);\r\n    // Ensure no registry functions are being called -\r\n    require(\r\n      sel != this.registerApp.selector &&\r\n      sel != this.registerAppVersion.selector &&\r\n      sel != UPDATE_INST_SEL &&\r\n      sel != UPDATE_EXEC_SEL\r\n    );\r\n\r\n    // Call 'exec' in AbstractStorage, passing in the sender's address, the app exec id, and the calldata to forward -\r\n    if (address(app_storage).call.value(msg.value)(abi.encodeWithSelector(\r\n      EXEC_SEL, msg.sender, _exec_id, _calldata\r\n    )) == false) {\r\n      // Call failed - emit error message from storage and return 'false'\r\n      checkErrors(_exec_id);\r\n      // Return unspent wei to sender\r\n      address(msg.sender).transfer(address(this).balance);\r\n      return false;\r\n    }\r\n\r\n    // Get returned data\r\n    success = checkReturn();\r\n    // If execution failed,\r\n    require(success, 'Execution failed');\r\n\r\n    // Transfer any returned wei back to the sender\r\n    address(msg.sender).transfer(address(this).balance);\r\n  }\r\n\r\n  // Returns the first 4 bytes of calldata\r\n  function getSelector(bytes memory _calldata) internal pure returns (bytes4 selector) {\r\n    assembly {\r\n      selector := and(\r\n        mload(add(0x20, _calldata)),\r\n        0xffffffff00000000000000000000000000000000000000000000000000000000\r\n      )\r\n    }\r\n  }\r\n\r\n  /// REGISTRY FUNCTIONS ///\r\n\r\n  /*\r\n  Creates an instance of a registry application and returns its execution id\r\n  @param _index: The index file of the registry app (holds getters and init functions)\r\n  @param _implementation: The file implementing the registry's functionality\r\n  @return exec_id: The execution id under which the registry will store data\r\n  */\r\n  function createRegistryInstance(address _index, address _implementation) external onlyAdmin() returns (bytes32 exec_id) {\r\n    // Validate input -\r\n    require(_index != 0 && _implementation != 0, 'Invalid input');\r\n\r\n    // Creates a registry from storage and returns the registry exec id -\r\n    exec_id = StorageInterface(app_storage).createRegistry(_index, _implementation);\r\n\r\n    // Ensure a valid execution id returned from storage -\r\n    require(exec_id != 0, 'Invalid response from storage');\r\n\r\n    // If there is not already a default registry exec id set, set it\r\n    if (registry_exec_id == 0)\r\n      registry_exec_id = exec_id;\r\n\r\n    // Create Registry struct in memory -\r\n    Registry memory reg = Registry(_index, _implementation);\r\n\r\n    // Set various app metadata values -\r\n    deployed_by[exec_id] = msg.sender;\r\n    registry_instance_info[exec_id] = reg;\r\n    deployed_registry_instances[msg.sender].push(reg);\r\n    // Emit event -\r\n    emit RegistryInstanceCreated(msg.sender, exec_id, _index, _implementation);\r\n  }\r\n\r\n  /*\r\n  Registers an application as the admin under the provider and registry exec id\r\n  @param _app_name: The name of the application to register\r\n  @param _index: The index file of the application - holds the getters and init functions\r\n  @param _selectors: The selectors of the functions which the app implements\r\n  @param _implementations: The addresses at which each function is located\r\n  */\r\n  function registerApp(bytes32 _app_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\r\n    // Validate input\r\n    require(_app_name != 0 && _index != 0, 'Invalid input');\r\n    require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\r\n    // Check contract variables for valid initialization\r\n    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\r\n\r\n    // Execute registerApp through AbstractStorage -\r\n    uint emitted;\r\n    uint paid;\r\n    uint stored;\r\n    (emitted, paid, stored) = StorageInterface(app_storage).exec(msg.sender, registry_exec_id, msg.data);\r\n\r\n    // Ensure zero values for emitted and paid, and nonzero value for stored -\r\n    require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\r\n  }\r\n\r\n  /*\r\n  Registers a version of an application as the admin under the provider and registry exec id\r\n  @param _app_name: The name of the application under which the version will be registered\r\n  @param _version_name: The name of the version to register\r\n  @param _index: The index file of the application - holds the getters and init functions\r\n  @param _selectors: The selectors of the functions which the app implements\r\n  @param _implementations: The addresses at which each function is located\r\n  */\r\n  function registerAppVersion(bytes32 _app_name, bytes32 _version_name, address _index, bytes4[] _selectors, address[] _implementations) external onlyAdmin() {\r\n    // Validate input\r\n    require(_app_name != 0 && _version_name != 0 && _index != 0, 'Invalid input');\r\n    require(_selectors.length == _implementations.length && _selectors.length != 0, 'Invalid input');\r\n    // Check contract variables for valid initialization\r\n    require(app_storage != 0 && registry_exec_id != 0 && provider != 0, 'Invalid state');\r\n\r\n    // Execute registerApp through AbstractStorage -\r\n    uint emitted;\r\n    uint paid;\r\n    uint stored;\r\n    (emitted, paid, stored) = StorageInterface(app_storage).exec(msg.sender, registry_exec_id, msg.data);\r\n\r\n    // Ensure zero values for emitted and paid, and nonzero value for stored -\r\n    require(emitted == 0 && paid == 0 && stored != 0, 'Invalid state change');\r\n  }\r\n\r\n  // Update instance selectors, index, and addresses\r\n  bytes4 internal constant UPDATE_INST_SEL = bytes4(keccak256('updateInstance(bytes32,bytes32,bytes32)'));\r\n\r\n  /*\r\n  Updates an application's implementations, selectors, and index address. Uses default app provider and registry app.\r\n  Uses latest app version by default.\r\n\r\n  @param _exec_id: The execution id of the application instance to be updated\r\n  @return success: The success of the call to the application's updateInstance function\r\n  */\r\n  function updateAppInstance(bytes32 _exec_id) external returns (bool success) {\r\n    // Validate input. Only the original deployer can update an application -\r\n    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id], 'invalid sender or input');\r\n\r\n    // Get instance metadata from exec id -\r\n    Instance memory inst = instance_info[_exec_id];\r\n\r\n    // Call 'exec' in AbstractStorage, passing in the sender's address, the execution id, and\r\n    // the calldata to update the application -\r\n    if(address(app_storage).call(\r\n      abi.encodeWithSelector(EXEC_SEL,            // 'exec' selector\r\n        inst.current_provider,                    // application provider address\r\n        _exec_id,                                 // execution id to update\r\n        abi.encodeWithSelector(UPDATE_INST_SEL,   // calldata for Registry updateInstance function\r\n          inst.app_name,                          // name of the applcation used by the instance\r\n          inst.version_name,                      // name of the current version of the application\r\n          inst.current_registry_exec_id           // registry exec id when the instance was instantiated\r\n        )\r\n      )\r\n    ) == false) {\r\n      // Call failed - emit error message from storage and return 'false'\r\n      checkErrors(_exec_id);\r\n      return false;\r\n    }\r\n    // Check returned data to ensure state was correctly changed in AbstractStorage -\r\n    success = checkReturn();\r\n    // If execution failed, revert state and return an error message -\r\n    require(success, 'Execution failed');\r\n\r\n    // If execution was successful, the version was updated. Get the latest version\r\n    // and set the exec id instance info -\r\n    address registry_idx = StorageInterface(app_storage).getIndex(inst.current_registry_exec_id);\r\n    bytes32 latest_version  = RegistryInterface(registry_idx).getLatestVersion(\r\n      app_storage,\r\n      inst.current_registry_exec_id,\r\n      inst.current_provider,\r\n      inst.app_name\r\n    );\r\n    // Ensure nonzero latest version -\r\n    require(latest_version != 0, 'invalid latest version');\r\n    // Set current version -\r\n    instance_info[_exec_id].version_name = latest_version;\r\n  }\r\n\r\n  // Update instance script exec contract\r\n  bytes4 internal constant UPDATE_EXEC_SEL = bytes4(keccak256('updateExec(address)'));\r\n\r\n  /*\r\n  Updates an application's script executor from this Script Exec to a new address\r\n\r\n  @param _exec_id: The execution id of the application instance to be updated\r\n  @param _new_exec_addr: The new script exec address for this exec id\r\n  @returns success: The success of the call to the application's updateExec function\r\n  */\r\n  function updateAppExec(bytes32 _exec_id, address _new_exec_addr) external returns (bool success) {\r\n    // Validate input. Only the original deployer can migrate the script exec address -\r\n    require(_exec_id != 0 && msg.sender == deployed_by[_exec_id] && address(this) != _new_exec_addr && _new_exec_addr != 0, 'invalid input');\r\n\r\n    // Call 'exec' in AbstractStorage, passing in the sender's address, the execution id, and\r\n    // the calldata to migrate the script exec address -\r\n    if(address(app_storage).call(\r\n      abi.encodeWithSelector(EXEC_SEL,                            // 'exec' selector\r\n        msg.sender,                                               // sender address\r\n        _exec_id,                                                 // execution id to update\r\n        abi.encodeWithSelector(UPDATE_EXEC_SEL, _new_exec_addr)   // calldata for Registry updateExec\r\n      )\r\n    ) == false) {\r\n      // Call failed - emit error message from storage and return 'false'\r\n      checkErrors(_exec_id);\r\n      return false;\r\n    }\r\n    // Check returned data to ensure state was correctly changed in AbstractStorage -\r\n    success = checkReturn();\r\n    // If execution failed, revert state and return an error message -\r\n    require(success, 'Execution failed');\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"provider\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"deployed_by\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_deployer\",\"type\":\"address\"}],\"name\":\"getDeployedLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_app_name\",\"type\":\"bytes32\"},{\"name\":\"_version_name\",\"type\":\"bytes32\"},{\"name\":\"_index\",\"type\":\"address\"},{\"name\":\"_selectors\",\"type\":\"bytes4[]\"},{\"name\":\"_implementations\",\"type\":\"address[]\"}],\"name\":\"registerAppVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"setRegistryExecID\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exec_admin\",\"type\":\"address\"},{\"name\":\"_app_storage\",\"type\":\"address\"},{\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"configure\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry_exec_id\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"updateAppInstance\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_index\",\"type\":\"address\"},{\"name\":\"_implementation\",\"type\":\"address\"}],\"name\":\"createRegistryInstance\",\"outputs\":[{\"name\":\"exec_id\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"registry_instance_info\",\"outputs\":[{\"name\":\"index\",\"type\":\"address\"},{\"name\":\"implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"app_storage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_calldata\",\"type\":\"bytes\"}],\"name\":\"exec\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"instance_info\",\"outputs\":[{\"name\":\"current_provider\",\"type\":\"address\"},{\"name\":\"current_registry_exec_id\",\"type\":\"bytes32\"},{\"name\":\"app_exec_id\",\"type\":\"bytes32\"},{\"name\":\"app_name\",\"type\":\"bytes32\"},{\"name\":\"version_name\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_app_name\",\"type\":\"bytes32\"},{\"name\":\"_index\",\"type\":\"address\"},{\"name\":\"_selectors\",\"type\":\"bytes4[]\"},{\"name\":\"_implementations\",\"type\":\"address[]\"}],\"name\":\"registerApp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exec_admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deployed_registry_instances\",\"outputs\":[{\"name\":\"index\",\"type\":\"address\"},{\"name\":\"implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRegistryImplementation\",\"outputs\":[{\"name\":\"index\",\"type\":\"address\"},{\"name\":\"implementation\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_provider\",\"type\":\"address\"}],\"name\":\"setProvider\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_app_name\",\"type\":\"bytes32\"},{\"name\":\"_init_calldata\",\"type\":\"bytes\"}],\"name\":\"createAppInstance\",\"outputs\":[{\"name\":\"exec_id\",\"type\":\"bytes32\"},{\"name\":\"version\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"deployed_instances\",\"outputs\":[{\"name\":\"current_provider\",\"type\":\"address\"},{\"name\":\"current_registry_exec_id\",\"type\":\"bytes32\"},{\"name\":\"app_exec_id\",\"type\":\"bytes32\"},{\"name\":\"app_name\",\"type\":\"bytes32\"},{\"name\":\"version_name\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exec_id\",\"type\":\"bytes32\"},{\"name\":\"_new_exec_addr\",\"type\":\"address\"}],\"name\":\"updateAppExec\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"app_instances\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_exec_id\",\"type\":\"bytes32\"}],\"name\":\"getInstanceImplementation\",\"outputs\":[{\"name\":\"index\",\"type\":\"address\"},{\"name\":\"functions\",\"type\":\"bytes4[]\"},{\"name\":\"implementations\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_app_name\",\"type\":\"bytes32\"}],\"name\":\"getInstances\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"execution_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"index\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"RegistryInstanceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"creator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"execution_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"app_name\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"version_name\",\"type\":\"bytes32\"}],\"name\":\"AppInstanceCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"execution_id\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"StorageException\",\"type\":\"event\"}]","ContractName":"RegistryExec","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://7032e53f95f04a17b8be2c27dedf4b2ff098103745b347f17462a458235ff4d5"}]}