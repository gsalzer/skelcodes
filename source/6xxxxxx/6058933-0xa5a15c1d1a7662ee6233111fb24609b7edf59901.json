{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n//test rinkeby address: {ec8d36aec0ee4105b7a36b9aafaa2b6c18585637}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n*/\r\n \r\nlibrary SafeMath \r\n{\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) \r\n  {\r\n      if (a==0)\r\n      {\r\n          return 0;\r\n      }\r\n      \r\n    uint256 c = a * b;\r\n    assert(c / a == b); // assert on overflow\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) \r\n  {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) \r\n  {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256)\r\n  {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic\r\n{\r\n  uint256 public totalSupply;\r\n  function balanceOf(address who) public constant returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic\r\n{\r\n    // founder details\r\n    address public constant FOUNDER_ADDRESS1 = 0xcb8Fb8Bf927e748c0679375B26fb9f2F12f3D5eE;\r\n    address public constant FOUNDER_ADDRESS2 = 0x1Ebfe7c17a22E223965f7B80c02D3d2805DFbE5F;\r\n    address public constant FOUNDER_ADDRESS3 = 0x9C5076C3e95C0421699A6D9d66a219BF5Ba5D826;\r\n    \r\n    address public constant FOUNDER_FUND_1 = 9000000000;\r\n    address public constant FOUNDER_FUND_2 = 9000000000;\r\n    address public constant FOUNDER_FUND_3 = 7000000000;\r\n    \r\n    // deposit address for reserve / crowdsale\r\n    address public constant MEW_RESERVE_FUND = 0xD11ffBea1cE043a8d8dDDb85F258b1b164AF3da4; // multisig\r\n    address public constant MEW_CROWDSALE_FUND = 0x842C4EA879050742b42c8b2E43f1C558AD0d1741; // multisig\r\n    \r\n    uint256 public constant decimals = 18;\r\n    \r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n  \r\n  // all initialised to false - do we want multi-state? maybe... \r\n  mapping(address => uint256) public mCanSpend;\r\n  mapping(address => uint256) public mEtherSpent;\r\n  \r\n  int256 public mEtherValid;\r\n  int256 public mEtherInvalid;\r\n  \r\n  // real\r\n  // standard unlocked tokens will vest immediately on the prime vesting date\r\n  // founder tokens will vest at a rate per day\r\n  uint256 public constant TOTAL_RESERVE_FUND =  40 * (10**9) * 10**decimals;  // 40B reserve created before sale\r\n  uint256 public constant TOTAL_CROWDSALE_FUND =  60 * (10**9) * 10**decimals;  // 40B reserve created before sale\r\n  uint256 public PRIME_VESTING_DATE = 0xffffffffffffffff; // will set to rough dates then fix at end of sale\r\n  uint256 public FINAL_AML_DATE = 0xffffffffffffffff; // will set to rough date + 3 months then fix at end of sale\r\n  uint256 public constant FINAL_AML_DAYS = 90;\r\n  uint256 public constant DAYSECONDS = 24*60*60;//86400; // 1 day in seconds // 1 minute vesting\r\n  \r\n  mapping(address => uint256) public mVestingDays;  // number of days to fully vest\r\n  mapping(address => uint256) public mVestingBalance; // total balance which will vest\r\n  mapping(address => uint256) public mVestingSpent; // total spent\r\n  mapping(address => uint256) public mVestingBegins; // total spent\r\n  \r\n  mapping(address => uint256) public mVestingAllowed; // really just for checking\r\n  \r\n  // used to enquire about the ether spent to buy the tokens\r\n  function GetEtherSpent(address from) view public returns (uint256)\r\n  {\r\n      return mEtherSpent[from];\r\n  }\r\n  \r\n  // removes tokens and returns them to the main pool\r\n  // this is called if \r\n  function RevokeTokens(address target) internal\r\n  {\r\n      //require(mCanSpend[from]==0),\"Can only call this if AML hasn't been completed correctly\");\r\n      // block this address from further spending\r\n      require(mCanSpend[target]!=9);\r\n      mCanSpend[target]=9;\r\n      \r\n      uint256 _value = balances[target];\r\n      \r\n      balances[target] = 0;//just wipe the balance\r\n      \r\n      balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(_value);\r\n      \r\n      // let the blockchain know its been revoked\r\n      emit Transfer(target, MEW_RESERVE_FUND, _value);\r\n  }\r\n  \r\n  function LockedCrowdSale(address target) view internal returns (bool)\r\n  {\r\n      if (mCanSpend[target]==0 && mEtherSpent[target]>0)\r\n      {\r\n          return true;\r\n      }\r\n      return false;\r\n  }\r\n  \r\n  function CheckRevoke(address target) internal returns (bool)\r\n  {\r\n      // roll vesting / dates and AML in to a single function\r\n      // this will stop coins being spent on new addresses until after \r\n      // we know if they took part in the crowdsale by checking if they spent ether\r\n      if (LockedCrowdSale(target))\r\n      {\r\n         if (block.timestamp>FINAL_AML_DATE)\r\n         {\r\n             RevokeTokens(target);\r\n             return true;\r\n         }\r\n      }\r\n      \r\n      return false;\r\n  }\r\n  \r\n  function ComputeVestSpend(address target) public returns (uint256)\r\n  {\r\n      require(mCanSpend[target]==2); // only compute for vestable accounts\r\n      int256 vestingDays = int256(mVestingDays[target]);\r\n      int256 vestingProgress = (int256(block.timestamp)-int256(mVestingBegins[target]))/(int256(DAYSECONDS));\r\n      \r\n      // cap the vesting\r\n      if (vestingProgress>vestingDays)\r\n      {\r\n          vestingProgress=vestingDays;\r\n      }\r\n          \r\n      // whole day vesting e.g. day 0 nothing vested, day 1 = 1 day vested    \r\n      if (vestingProgress>0)\r\n      {\r\n              \r\n        int256 allowedVest = ((int256(mVestingBalance[target])*vestingProgress))/vestingDays;\r\n                  \r\n        int256 combined = allowedVest-int256(mVestingSpent[target]);\r\n        \r\n        // store the combined value so people can see their vesting (useful for debug too)\r\n        mVestingAllowed[target] = uint256(combined);\r\n        \r\n        return uint256(combined);\r\n      }\r\n      \r\n      // no vesting allowed\r\n      mVestingAllowed[target]=0;\r\n      \r\n      // cannot spend anything\r\n      return 0;\r\n  }\r\n  \r\n  // 0 locked \r\n  // 1 unlocked\r\n  // 2 vestable\r\n  function canSpend(address from, uint256 amount) internal returns (bool permitted)\r\n  {\r\n      uint256 currentTime = block.timestamp;\r\n      \r\n      // refunded / blocked\r\n      if (mCanSpend[from]==8)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      // revoked / blocked\r\n      if (mCanSpend[from]==9)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      // roll vesting / dates and AML in to a single function\r\n      // this will stop coins being spent on new addresses until after \r\n      if (LockedCrowdSale(from))\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      if (mCanSpend[from]==1)\r\n      {\r\n          // tokens can only move when sale is finished\r\n          if (currentTime>PRIME_VESTING_DATE)\r\n          {\r\n             return true;\r\n          }\r\n          return false;\r\n      }\r\n      \r\n      // special vestable tokens\r\n      if (mCanSpend[from]==2)\r\n      {\r\n              \r\n        if (ComputeVestSpend(from)>=amount)\r\n            {\r\n              return true;\r\n            }\r\n            else\r\n            {\r\n              return false;   \r\n            }\r\n      }\r\n      \r\n      return false;\r\n  }\r\n  \r\n   // 0 locked \r\n  // 1 unlocked\r\n  // 2 vestable\r\n  function canTake(address from) view public returns (bool permitted)\r\n  {\r\n      uint256 currentTime = block.timestamp;\r\n      \r\n      // refunded / blocked\r\n      if (mCanSpend[from]==8)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      // revoked / blocked\r\n      if (mCanSpend[from]==9)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      // roll vesting / dates and AML in to a single function\r\n      // this will stop coins being spent on new addresses until after \r\n      if (LockedCrowdSale(from))\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      if (mCanSpend[from]==1)\r\n      {\r\n          // tokens can only move when sale is finished\r\n          if (currentTime>PRIME_VESTING_DATE)\r\n          {\r\n             return true;\r\n          }\r\n          return false;\r\n      }\r\n      \r\n      // special vestable tokens\r\n      if (mCanSpend[from]==2)\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      return true;\r\n  }\r\n  \r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool success) \r\n  {\r\n       // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender)||CheckRevoke(_to))\r\n      {\r\n          return false;\r\n      }\r\n     \r\n    require(canSpend(msg.sender, _value)==true);//, \"Cannot spend this amount - AML or not vested\")\r\n    require(canTake(_to)==true); // must be aml checked or unlocked wallet no vesting\r\n    \r\n    if (balances[msg.sender] >= _value) \r\n    {\r\n      // deduct the spend first (this is unlikely attack vector as only a few people will have vesting tokens)\r\n      // special tracker for vestable funds - if have a date up\r\n      if (mCanSpend[msg.sender]==2)\r\n      {\r\n        mVestingSpent[msg.sender] = mVestingSpent[msg.sender].add(_value);\r\n      }\r\n      \r\n      balances[msg.sender] = balances[msg.sender].sub(_value);\r\n      balances[_to] = balances[_to].add(_value);\r\n      emit Transfer(msg.sender, _to, _value);\r\n      \r\n      \r\n      // set can spend on destination as it will be transferred from approved wallet\r\n      mCanSpend[_to]=1;\r\n      \r\n      return true;\r\n    } \r\n    else\r\n    {\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  // in the light of our sanity allow a utility to whole number of tokens and 1/10000 token transfer\r\n  function simpletransfer(address _to, uint256 _whole, uint256 _fraction) public returns (bool success) \r\n  {\r\n    require(_fraction<10000);//, \"Fractional part must be less than 10000\");\r\n    \r\n    uint256 main = _whole.mul(10**decimals); // works fine now i've removed the retarded divide by 0 assert in safemath\r\n    uint256 part = _fraction.mul(10**14);\r\n    uint256 value = main + part;\r\n    \r\n    // just call the transfer\r\n    return transfer(_to, value);\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public constant returns (uint256 returnbalance) \r\n  {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic \r\n{\r\n  function allowance(address owner, address spender) public constant returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken \r\n{\r\n  // need to add\r\n  // also need\r\n  // invalidate - used to drop all unauthorised buyers, return their tokens to reserve\r\n  // freespend - all transactions now allowed - this could be used to vest tokens?\r\n  mapping (address => mapping (address => uint256)) allowed;\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n   function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) \r\n   {\r\n      // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender)||CheckRevoke(_to))\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      require(canSpend(_from, _value)== true);//, \"Cannot spend this amount - AML or not vested\")\r\n      require(canTake(_to)==true); // must be aml checked or unlocked wallet no vesting\r\n     \r\n    if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) \r\n    {\r\n      balances[_to] = balances[_to].add(_value);\r\n      balances[_from] = balances[_from].sub(_value);\r\n      allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n      emit Transfer(_from, _to, _value);\r\n      \r\n      \r\n      // set can spend on destination as it will be transferred from approved wallet\r\n      mCanSpend[_to]=1;\r\n      \r\n      // special tracker for vestable funds - if have a date set\r\n      if (mCanSpend[msg.sender]==2)\r\n      {\r\n        mVestingSpent[msg.sender] = mVestingSpent[msg.sender].add(_value);\r\n      }\r\n      return true;\r\n    } \r\n    else \r\n    {\r\n     //   endsigning();\r\n      return false;\r\n    }\r\n  }\r\n  \r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool)\r\n  {\r\n      // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender))\r\n      {\r\n          return false;\r\n      }\r\n      \r\n      require(canSpend(msg.sender, _value)==true);//, \"Cannot spend this amount - AML or not vested\");\r\n      \r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   */\r\n  function increaseApproval (address _spender, uint _addedValue) public returns (bool success) \r\n  {\r\n      // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender))\r\n      {\r\n          return false;\r\n      }\r\n      require(canSpend(msg.sender, _addedValue)==true);//, \"Cannot spend this amount - AML or not vested\");\r\n      \r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success)\r\n  {\r\n      // check to see if we should revoke (and revoke if so)\r\n      if (CheckRevoke(msg.sender))\r\n      {\r\n          return false;\r\n      }\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of 'user permissions'.\r\n */\r\ncontract Ownable\r\n{\r\n  address public owner;\r\n  address internal auxOwner;\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public\r\n  {\r\n      \r\n        address newOwner = msg.sender;\r\n        owner = 0;\r\n        owner = newOwner;\r\n    \r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() \r\n  {\r\n    require(msg.sender == owner || msg.sender==auxOwner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) onlyOwner public \r\n  {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\n\r\ncontract MintableToken is StandardToken, Ownable\r\n{\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n  uint256 internal mCanPurchase = 1;\r\n  uint256 internal mSetupReserve = 0;\r\n  uint256 internal mSetupCrowd = 0;\r\n  \r\n  //test\r\n  uint256 public constant MINIMUM_ETHER_SPEND = (250 * 10**(decimals-3));\r\n  uint256 public constant MAXIMUM_ETHER_SPEND = 300 * 10**decimals;\r\n\r\n  //real\r\n  //uint256 public constant MINIMUM_ETHER_SPEND = (250 * 10**(decimals-3));\r\n  //uint256 public constant MAXIMUM_ETHER_SPEND = 300 * 10**decimals;\r\n\r\n\r\n  modifier canMint() \r\n  {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n  \r\n  function allocateVestable(address target, uint256 amount, uint256 vestdays, uint256 vestingdate) public onlyOwner\r\n  {\r\n      //require(msg.sender==CONTRACT_CREATOR, \"You are not authorised to create vestable token users\");\r\n      // check if we have permission to get in here\r\n      //checksigning();\r\n      \r\n      // prevent anyone except contract signatories from creating their own vestable\r\n      \r\n      // essentially set up a final vesting date\r\n      uint256 vestingAmount = amount * 10**decimals;\r\n    \r\n      // set up the vesting params\r\n      mCanSpend[target]=2;\r\n      mVestingBalance[target] = vestingAmount;\r\n      mVestingDays[target] = vestdays;\r\n      mVestingBegins[target] = vestingdate;\r\n      mVestingSpent[target] = 0;\r\n      \r\n      // load the balance of the actual token fund\r\n      balances[target] = vestingAmount;\r\n      \r\n      // if the tokensale is finalised then use the crowdsale fund which SHOULD be empty.\r\n      // this means we can create new vesting tokens if necessary but only if crowdsale fund has been preload with MEW using multisig wallet\r\n      if (mCanPurchase==0)\r\n      {\r\n        require(vestingAmount <= balances[MEW_CROWDSALE_FUND]);//, \"Not enough MEW to allocate vesting post crowdsale\");\r\n        balances[MEW_CROWDSALE_FUND] = balances[MEW_CROWDSALE_FUND].sub(vestingAmount); \r\n        // log transfer\r\n        emit Transfer(MEW_CROWDSALE_FUND, target, vestingAmount);\r\n      }\r\n      else\r\n      {\r\n        // deduct tokens from reserve before crowdsale\r\n        require(vestingAmount <= balances[MEW_RESERVE_FUND]);//, \"Not enough MEW to allocate vesting during setup\");\r\n        balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].sub(vestingAmount);\r\n        // log transfer\r\n        emit Transfer(MEW_RESERVE_FUND, target, vestingAmount);\r\n      }\r\n  }\r\n  \r\n  function SetAuxOwner(address aux) onlyOwner public\r\n  {\r\n      require(auxOwner == 0);//, \"Cannot replace aux owner once it has been set\");\r\n      // sets the auxilliary owner as the contract owns this address not the creator\r\n      auxOwner = aux;\r\n  }\r\n \r\n  function Purchase(address _to, uint256 _ether, uint256 _amount, uint256 exchange) onlyOwner public returns (bool) \r\n  {\r\n    require(mCanSpend[_to]==0); // cannot purchase to a validated or vesting wallet (probably works but more debug checks)\r\n    require(mSetupCrowd==1);//, \"Only purchase during crowdsale\");\r\n    require(mCanPurchase==1);//,\"Can only purchase during a sale\");\r\n      \r\n    require( _amount >= MINIMUM_ETHER_SPEND * exchange);//, \"Must spend at least minimum ether\");\r\n    require( (_amount+balances[_to]) <= MAXIMUM_ETHER_SPEND * exchange);//, \"Must not spend more than maximum ether\");\r\n   \r\n    // bail if we're out of tokens (will be amazing if this happens but hey!)\r\n    if (balances[MEW_CROWDSALE_FUND]<_amount)\r\n    {\r\n         return false;\r\n    }\r\n\r\n    // lock the tokens for AML - early to prevent transact hack\r\n    mCanSpend[_to] = 0;\r\n    \r\n    // add these ether to the invalid count unless checked\r\n    if (mCanSpend[_to]==0)\r\n    {\r\n        mEtherInvalid = mEtherInvalid + int256(_ether);\r\n    }\r\n    else\r\n    {\r\n        // valid AML checked ether\r\n        mEtherValid = mEtherValid + int256(_ether);\r\n    }\r\n    \r\n    // store how much ether was spent\r\n    mEtherSpent[_to] = _ether;\r\n      \r\n    // broken up to prevent recursive spend hacks (safemath probably does but just in case)\r\n    uint256 newBalance = balances[_to].add(_amount);\r\n    uint256 newCrowdBalance = balances[MEW_CROWDSALE_FUND].sub(_amount);\r\n    \r\n    balances[_to]=0;\r\n    balances[MEW_CROWDSALE_FUND] = 0;\r\n      \r\n    // add in to personal fund\r\n    balances[_to] = newBalance;\r\n    balances[MEW_CROWDSALE_FUND] = newCrowdBalance;\r\n   \r\n    emit Transfer(MEW_CROWDSALE_FUND, _to, _amount);\r\n    \r\n    return true;\r\n  }\r\n  \r\n  function Unlock_Tokens(address target) public onlyOwner\r\n  {\r\n      \r\n      require(mCanSpend[target]==0);//,\"Unlocking would fail\");\r\n      \r\n      // unlocks locked tokens - must be called on every token wallet after AML check\r\n      //unlocktokens(target);\r\n      \r\n      mCanSpend[target]=1;\r\n      \r\n      \r\n    // get how much ether this person spent on their tokens\r\n    uint256 etherToken = mEtherSpent[target];\r\n    \r\n    // if this is called the ether are now valid and can be spent\r\n    mEtherInvalid = mEtherInvalid - int256(etherToken);\r\n    mEtherValid = mEtherValid + int256(etherToken);\r\n    \r\n  }\r\n  \r\n  \r\n  function Revoke(address target) public onlyOwner\r\n  {\r\n      // revokes tokens and returns to the reserve\r\n      // designed to be used for refunds or to try to reverse theft via phishing etc\r\n      RevokeTokens(target);\r\n  }\r\n  \r\n  function BlockRefunded(address target) public onlyOwner\r\n  {\r\n      require(mCanSpend[target]!=8);\r\n      // clear the spent ether\r\n      //mEtherSpent[target]=0;\r\n      \r\n      // refund marker\r\n      mCanSpend[target]=8;\r\n      \r\n      // does not refund just blocks account from being used for tokens ever again\r\n      mEtherInvalid = mEtherInvalid-int256(mEtherSpent[target]);\r\n  }\r\n  \r\n  function SetupReserve(address multiSig) public onlyOwner\r\n  {\r\n      require(mSetupReserve==0);//, \"Reserve has already been initialised\");\r\n      require(multiSig>0);//, \"Wallet is not valid\");\r\n      \r\n      // address the mew reserve fund as the multisig wallet\r\n      //MEW_RESERVE_FUND = multiSig;\r\n      \r\n      // create the reserve\r\n      mint(MEW_RESERVE_FUND, TOTAL_RESERVE_FUND);\r\n     \r\n       // vesting allocates from the reserve fund\r\n      allocateVestable(FOUNDER_ADDRESS1, 9000000000, 365, PRIME_VESTING_DATE);\r\n      allocateVestable(FOUNDER_ADDRESS2, 9000000000, 365, PRIME_VESTING_DATE);\r\n      allocateVestable(FOUNDER_ADDRESS3, 7000000000, 365, PRIME_VESTING_DATE);\r\n  }\r\n  \r\n  function SetupCrowdSale() public onlyOwner\r\n  {\r\n      require(mSetupCrowd==0);//, \"Crowdsale has already been initalised\");\r\n      // create the reserve\r\n      mint(MEW_CROWDSALE_FUND, TOTAL_CROWDSALE_FUND);\r\n      \r\n      // crowd initialised\r\n      mSetupCrowd=1;\r\n  }\r\n  \r\n  function CloseSaleFund() public onlyOwner\r\n  {\r\n      uint256 remainingFund;\r\n      \r\n      remainingFund = balances[MEW_CROWDSALE_FUND];\r\n      \r\n      balances[MEW_CROWDSALE_FUND] = 0;\r\n      \r\n      balances[MEW_RESERVE_FUND] = balances[MEW_RESERVE_FUND].add(remainingFund);\r\n      \r\n      // notify the network\r\n      emit Transfer(MEW_CROWDSALE_FUND, MEW_RESERVE_FUND, remainingFund);\r\n      \r\n      // set up the prime vesting date - ie immediate\r\n      // set up the aml date\r\n      PRIME_VESTING_DATE = block.timestamp;\r\n      FINAL_AML_DATE = PRIME_VESTING_DATE + FINAL_AML_DAYS*DAYSECONDS;\r\n      \r\n      // update vesting date (sale end)\r\n      mVestingBegins[FOUNDER_ADDRESS1]=PRIME_VESTING_DATE;\r\n      mVestingBegins[FOUNDER_ADDRESS2]=PRIME_VESTING_DATE;\r\n      mVestingBegins[FOUNDER_ADDRESS3]=PRIME_VESTING_DATE;\r\n      \r\n      // block further token purchasing (forever)\r\n      mCanPurchase = 0;\r\n  }\r\n  \r\n  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) \r\n  {\r\n    totalSupply = totalSupply.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    \r\n    // allow this minted money to be spent immediately\r\n    mCanSpend[_to] = 1;\r\n    \r\n    emit Mint(_to, _amount);\r\n    emit Transfer(0x0, _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() onlyOwner public returns (bool) \r\n  {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\ncontract MEWcoin is MintableToken \r\n{\r\n    string public constant name = \"MEWcoin (Official vFloorplan Ltd 30/07/18)\";\r\n    string public constant symbol = \"MEW\";\r\n    string public version = \"1.0\";\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"multiSig\",\"type\":\"address\"}],\"name\":\"SetupReserve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mVestingAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"canTake\",\"outputs\":[{\"name\":\"permitted\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mEtherInvalid\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MEW_RESERVE_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mVestingBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXIMUM_ETHER_SPEND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DAYSECONDS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDER_FUND_3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MEW_CROWDSALE_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDER_ADDRESS2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDER_FUND_2\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_ether\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"exchange\",\"type\":\"uint256\"}],\"name\":\"Purchase\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"CloseSaleFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mEtherSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FINAL_AML_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"returnbalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MINIMUM_ETHER_SPEND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mEtherValid\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"vestdays\",\"type\":\"uint256\"},{\"name\":\"vestingdate\",\"type\":\"uint256\"}],\"name\":\"allocateVestable\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_whole\",\"type\":\"uint256\"},{\"name\":\"_fraction\",\"type\":\"uint256\"}],\"name\":\"simpletransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mVestingDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDER_FUND_1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mVestingBegins\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"Revoke\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"ComputeVestSpend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"Unlock_Tokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRIME_VESTING_DATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDER_ADDRESS1\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mCanSpend\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_CROWDSALE_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"aux\",\"type\":\"address\"}],\"name\":\"SetAuxOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"}],\"name\":\"BlockRefunded\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TOTAL_RESERVE_FUND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mVestingSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FOUNDER_ADDRESS3\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"GetEtherSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FINAL_AML_DAYS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"SetupCrowdSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"MEWcoin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://efceca4f2b8923d44e71c144e2217d981dd24f96851a87700bf5b07f98fb990c"}]}