{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract ERC20 {\r\n  function totalSupply() public view returns (uint256);\r\n\r\n  function balanceOf(address _who) public view returns (uint256);\r\n\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function burn(uint256 _value)\r\n    public returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n\r\n  event Burn(\r\n    address indexed burner,\r\n    uint256 value\r\n  );\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    require(_b <= _a);\r\n    uint256 c = _a - _b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract LoligoToken is ERC20, Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  string public constant name = \"Loligo Token\";\r\n  string public constant symbol = \"LLG\";\r\n  uint8 public constant decimals = 18;\r\n  uint256 private totalSupply_ = 16000000 * (10 ** uint256(decimals));\r\n  bool public locked = true;\r\n  mapping (address => uint256) private balances;\r\n\r\n  mapping (address => mapping (address => uint256)) private allowed;\r\n\r\n  modifier onlyWhenUnlocked() {\r\n    require(!locked || msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  constructor() public {\r\n      balances[msg.sender] = totalSupply_;\r\n  }\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public onlyWhenUnlocked returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    onlyWhenUnlocked\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  function burn(uint256 _value) public returns (bool success){\r\n    require(_value > 0);\r\n    require(_value <= balances[msg.sender]);\r\n    address burner = msg.sender;\r\n    balances[burner] = balances[burner].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(burner, _value);\r\n    return true;\r\n  }\r\n\r\n  function unlock() public onlyOwner {\r\n    locked = false;\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\ncontract Whitelist is Ownable{\r\n\r\n  // Whitelisted address\r\n  mapping(address => bool) public whitelist;\r\n  // evants\r\n  event LogAddedBeneficiary(address indexed _beneficiary);\r\n  event LogRemovedBeneficiary(address indexed _beneficiary);\r\n\r\n  /**\r\n   * @dev Adds list of addresses to whitelist. Not overloaded due to limitations with truffle testing.\r\n   * @param _beneficiaries Addresses to be added to the whitelist\r\n   */\r\n  function addManyToWhitelist(address[] _beneficiaries) public onlyOwner {\r\n    for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n      whitelist[_beneficiaries[i]] = true;\r\n      emit LogAddedBeneficiary(_beneficiaries[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Removes single address from whitelist.\r\n   * @param _beneficiary Address to be removed to the whitelist\r\n   */\r\n  function removeFromWhitelist(address _beneficiary) public onlyOwner {\r\n    whitelist[_beneficiary] = false;\r\n    emit LogRemovedBeneficiary(_beneficiary);\r\n  }\r\n\r\n  function isWhitelisted(address _beneficiary) public view returns (bool) {\r\n    return (whitelist[_beneficiary]);\r\n  }\r\n\r\n}\r\n\r\ncontract TokenBonus is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    mapping (address => uint256) public bonusBalances;   // visible to the public or not ???\r\n    address[] public bonusList;\r\n    uint256 public savedBonusToken;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function distributeBonusToken(address _token, uint256 _percent) public onlyOwner {\r\n        for (uint256 i = 0; i < bonusList.length; i++) {\r\n            require(LoligoToken(_token).balanceOf(address(this)) >= savedBonusToken);\r\n\r\n            uint256 amountToTransfer = bonusBalances[bonusList[i]].mul(_percent).div(100);\r\n            bonusBalances[bonusList[i]] = bonusBalances[bonusList[i]].sub(amountToTransfer);\r\n            savedBonusToken = savedBonusToken.sub(amountToTransfer);\r\n            LoligoToken(_token).transfer(bonusList[i], amountToTransfer);\r\n        }\r\n    }\r\n}\r\n\r\ncontract Presale is Pausable, Whitelist, TokenBonus {\r\n    using SafeMath for uint256;\r\n\r\n    // addresse for testing to change\r\n    address private wallet = 0xE2a5B96B6C1280cfd93b57bcd3fDeAf73691D3f3;     // ETH wallet\r\n\r\n    // LLG token\r\n    LoligoToken public token;\r\n\r\n    // Presale period\r\n    uint256 public presaleRate;                                          // Rate presale LLG token per ether\r\n    uint256 public totalTokensForPresale;                                // LLG tokens allocated for the Presale\r\n    bool public presale1;                                                // Presale first period\r\n    bool public presale2;                                                // Presale second period\r\n\r\n    // presale params\r\n    uint256 public savedBalance;                                        // Total amount raised in ETH\r\n    uint256 public savedPresaleTokenBalance;                            // Total sold tokens for presale\r\n    mapping (address => uint256) balances;                              // Balances in incoming Ether\r\n\r\n    // Events\r\n    event Contribution(address indexed _contributor, uint256 indexed _value, uint256 indexed _tokens);     // Event to record new contributions\r\n    event PayEther(address indexed _receiver, uint256 indexed _value, uint256 indexed _timestamp);         // Event to record each time Ether is paid out\r\n    event BurnTokens(uint256 indexed _value, uint256 indexed _timestamp);                                  // Event to record when tokens are burned.\r\n\r\n\r\n    // Initialization\r\n    constructor(address _token) public {\r\n        // add address of the specific contract\r\n        token = LoligoToken(_token);\r\n    }\r\n\r\n\r\n    // Fallbck function for contribution\r\n    function () external payable whenNotPaused {\r\n        _buyPresaleTokens(msg.sender);\r\n    }\r\n    \r\n    // Contribute Function, accepts incoming payments and tracks balances for each contributors\r\n    function _buyPresaleTokens(address _beneficiary) public payable  {\r\n        require(presale1 || presale2);\r\n        require(msg.value >= 0.25 ether);\r\n        require(isWhitelisted(_beneficiary));\r\n        require(savedPresaleTokenBalance.add(_getTokensAmount(msg.value)) <= totalTokensForPresale);\r\n\r\n        if (msg.value >= 10 ether) {\r\n          _deliverBlockedTokens(_beneficiary);\r\n        }else {\r\n          _deliverTokens(_beneficiary);\r\n        }\r\n    }\r\n\r\n    /***********************************\r\n    *       Public functions for the   *\r\n    *           Presale period         *\r\n    ************************************/\r\n\r\n    // Function to set Rate & tokens to sell for presale (period1)\r\n    function startPresale(uint256 _rate, uint256 _totalTokensForPresale) public onlyOwner {\r\n        require(_rate != 0 && _totalTokensForPresale != 0);\r\n        presaleRate = _rate;\r\n        totalTokensForPresale = _totalTokensForPresale;\r\n        presale1 = true;\r\n        presale2 = false;\r\n    }\r\n\r\n    // Function to move to the second period for presale (period2)\r\n    function updatePresale() public onlyOwner {\r\n        require(presale1);\r\n        presale1 = false;\r\n        presale2 = true;\r\n    }\r\n\r\n    // Function to close the presale period2\r\n    function closePresale() public onlyOwner {\r\n        require(presale2 || presale1);\r\n        presale1 = false;\r\n        presale2 = false;\r\n    }\r\n\r\n    // Function to transferOwnership of the LLG token\r\n    function transferTokenOwnership(address _newOwner) public onlyOwner {\r\n        token.transferOwnership(_newOwner);\r\n    }\r\n\r\n    // Function to transfer the rest of tokens not sold\r\n    function transferToken(address _crowdsale) public onlyOwner {\r\n        require(!presale1 && !presale2);\r\n        require(token.balanceOf(address(this)) > savedBonusToken);\r\n        uint256 tokensToTransfer =  token.balanceOf(address(this)).sub(savedBonusToken);\r\n        token.transfer(_crowdsale, tokensToTransfer);\r\n    }\r\n    /***************************************\r\n    *          internal functions          *\r\n    ****************************************/\r\n\r\n    function _deliverBlockedTokens(address _beneficiary) internal {\r\n        uint256 tokensAmount = msg.value.mul(presaleRate);\r\n        uint256 bonus = tokensAmount.mul(_checkPresaleBonus(msg.value)).div(100);\r\n\r\n        savedPresaleTokenBalance = savedPresaleTokenBalance.add(tokensAmount.add(bonus));\r\n        token.transfer(_beneficiary, tokensAmount);\r\n        savedBonusToken = savedBonusToken.add(bonus);\r\n        bonusBalances[_beneficiary] = bonusBalances[_beneficiary].add(bonus);\r\n        bonusList.push(_beneficiary);\r\n        wallet.transfer(msg.value);\r\n        emit PayEther(wallet, msg.value, now);\r\n    }\r\n\r\n    function _deliverTokens(address _beneficiary) internal {\r\n      uint256 tokensAmount = msg.value.mul(presaleRate);\r\n      uint256 tokensToTransfer = tokensAmount.add((tokensAmount.mul(_checkPresaleBonus(msg.value))).div(100));\r\n\r\n      savedPresaleTokenBalance = savedPresaleTokenBalance.add(tokensToTransfer);\r\n      token.transfer(_beneficiary, tokensToTransfer);\r\n      wallet.transfer(msg.value);\r\n      emit PayEther(wallet, msg.value, now);\r\n    }\r\n\r\n    function _checkPresaleBonus(uint256 _value) internal view returns (uint256){\r\n        if(presale1 && _value >= 0.25 ether){\r\n          return 40;\r\n        }else if(presale2 && _value >= 0.25 ether){\r\n          return 30;\r\n        }else{\r\n          return 0;\r\n        }\r\n    }\r\n\r\n    function _getTokensAmount(uint256 _value) internal view returns (uint256){\r\n       uint256 tokensAmount = _value.mul(presaleRate);\r\n       uint256 tokensToTransfer = tokensAmount.add((tokensAmount.mul(_checkPresaleBonus(_value))).div(100));\r\n       return tokensToTransfer;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"presale1\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bonusBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensForPresale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonusList\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"isWhitelisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savedPresaleTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closePresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savedBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_totalTokensForPresale\",\"type\":\"uint256\"}],\"name\":\"startPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"removeFromWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_percent\",\"type\":\"uint256\"}],\"name\":\"distributeBonusToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"addManyToWhitelist\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"_buyPresaleTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presale2\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"savedBonusToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"updatePresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contributor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Contribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_receiver\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"PayEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_timestamp\",\"type\":\"uint256\"}],\"name\":\"BurnTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"LogAddedBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"LogRemovedBeneficiary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Presale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009806f88f86bf701d4a43b7b82732be80c4773f17","Library":"","SwarmSource":"bzzr://3f5edb87980fc6b0eb56739436793058a2513c4927bc0ac8be54fe6ea4c1a6e4"}]}