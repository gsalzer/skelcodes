{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title MerkleProof\r\n * @dev Merkle proof verification based on\r\n * https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\nlibrary MerkleProof {\r\n    /**\r\n    * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\r\n    * and each pair of pre-images are sorted.\r\n    * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\r\n    * @param _root Merkle root\r\n    * @param _leaf Leaf of Merkle tree\r\n    */\r\n    function verifyProof(\r\n        bytes32[] _proof,\r\n        bytes32 _root,\r\n        bytes32 _leaf\r\n    )\r\n        internal\r\n        pure\r\n        returns (bool)\r\n    {\r\n        bytes32 computedHash = _leaf;\r\n\r\n        for (uint256 i = 0; i < _proof.length; i++) {\r\n            bytes32 proofElement = _proof[i];\r\n\r\n            if (computedHash < proofElement) {\r\n                // Hash(current computed hash + current element of the proof)\r\n                computedHash = keccak256(abi.encodePacked(computedHash, proofElement));\r\n            } else {\r\n                // Hash(current element of the proof + current computed hash)\r\n                computedHash = keccak256(abi.encodePacked(proofElement, computedHash));\r\n            }\r\n        }\r\n\r\n        // Check if the computed hash (root) is equal to the provided root\r\n        return computedHash == _root;\r\n    }\r\n}\r\n\r\ncontract Controlled {\r\n    /// @notice The address of the controller is the only address that can call\r\n    ///  a function with this modifier\r\n    modifier onlyController { \r\n        require(msg.sender == controller); \r\n        _; \r\n    }\r\n\r\n    address public controller;\r\n\r\n    constructor() internal { \r\n        controller = msg.sender; \r\n    }\r\n\r\n    /// @notice Changes the controller of the contract\r\n    /// @param _newController The new controller of the contract\r\n    function changeController(address _newController) public onlyController {\r\n        controller = _newController;\r\n    }\r\n}\r\n\r\n\r\n// Abstract contract for the full ERC 20 Token standard\r\n// https://github.com/ethereum/EIPs/issues/20\r\n\r\ninterface ERC20Token {\r\n\r\n    /**\r\n     * @notice send `_value` token to `_to` from `msg.sender`\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @param _value The amount of tokens to be approved for transfer\r\n     * @return Whether the approval was successful or not\r\n     */\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n     * @param _from The address of the sender\r\n     * @param _to The address of the recipient\r\n     * @param _value The amount of token to be transferred\r\n     * @return Whether the transfer was successful or not\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n\r\n    /**\r\n     * @param _owner The address from which the balance will be retrieved\r\n     * @return The balance\r\n     */\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    /**\r\n     * @param _owner The address of the account owning tokens\r\n     * @param _spender The address of the account able to transfer the tokens\r\n     * @return Amount of remaining tokens allowed to spent\r\n     */\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n\r\n    /**\r\n     * @notice return total supply of tokens\r\n     */\r\n    function totalSupply() external view returns (uint256 supply);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 _amount, address _token, bytes _data) public;\r\n}\r\n\r\ninterface ENS {\r\n\r\n  // Logged when the owner of a node assigns a new owner to a subnode.\r\n  event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner);\r\n\r\n  // Logged when the owner of a node transfers ownership to a new account.\r\n  event Transfer(bytes32 indexed node, address owner);\r\n\r\n  // Logged when the resolver for a node changes.\r\n  event NewResolver(bytes32 indexed node, address resolver);\r\n\r\n  // Logged when the TTL of a node changes\r\n  event NewTTL(bytes32 indexed node, uint64 ttl);\r\n\r\n\r\n  function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public;\r\n  function setResolver(bytes32 node, address resolver) public;\r\n  function setOwner(bytes32 node, address owner) public;\r\n  function setTTL(bytes32 node, uint64 ttl) public;\r\n  function owner(bytes32 node) public view returns (address);\r\n  function resolver(bytes32 node) public view returns (address);\r\n  function ttl(bytes32 node) public view returns (uint64);\r\n\r\n}\r\n\r\n\r\n/**\r\n * A simple resolver anyone can use; only allows the owner of a node to set its\r\n * address.\r\n */\r\ncontract PublicResolver {\r\n\r\n    bytes4 constant INTERFACE_META_ID = 0x01ffc9a7;\r\n    bytes4 constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n    bytes4 constant CONTENT_INTERFACE_ID = 0xd8389dc5;\r\n    bytes4 constant NAME_INTERFACE_ID = 0x691f3431;\r\n    bytes4 constant ABI_INTERFACE_ID = 0x2203ab56;\r\n    bytes4 constant PUBKEY_INTERFACE_ID = 0xc8690233;\r\n    bytes4 constant TEXT_INTERFACE_ID = 0x59d1d43c;\r\n    bytes4 constant MULTIHASH_INTERFACE_ID = 0xe89401a1;\r\n\r\n    event AddrChanged(bytes32 indexed node, address a);\r\n    event ContentChanged(bytes32 indexed node, bytes32 hash);\r\n    event NameChanged(bytes32 indexed node, string name);\r\n    event ABIChanged(bytes32 indexed node, uint256 indexed contentType);\r\n    event PubkeyChanged(bytes32 indexed node, bytes32 x, bytes32 y);\r\n    event TextChanged(bytes32 indexed node, string indexedKey, string key);\r\n    event MultihashChanged(bytes32 indexed node, bytes hash);\r\n\r\n    struct PublicKey {\r\n        bytes32 x;\r\n        bytes32 y;\r\n    }\r\n\r\n    struct Record {\r\n        address addr;\r\n        bytes32 content;\r\n        string name;\r\n        PublicKey pubkey;\r\n        mapping(string=>string) text;\r\n        mapping(uint256=>bytes) abis;\r\n        bytes multihash;\r\n    }\r\n\r\n    ENS ens;\r\n\r\n    mapping (bytes32 => Record) records;\r\n\r\n    modifier only_owner(bytes32 node) {\r\n        require(ens.owner(node) == msg.sender);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param ensAddr The ENS registrar contract.\r\n     */\r\n    constructor(ENS ensAddr) public {\r\n        ens = ensAddr;\r\n    }\r\n\r\n    /**\r\n     * Sets the address associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param addr The address to set.\r\n     */\r\n    function setAddr(bytes32 node, address addr) public only_owner(node) {\r\n        records[node].addr = addr;\r\n        emit AddrChanged(node, addr);\r\n    }\r\n\r\n    /**\r\n     * Sets the content hash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The node to update.\r\n     * @param hash The content hash to set\r\n     */\r\n    function setContent(bytes32 node, bytes32 hash) public only_owner(node) {\r\n        records[node].content = hash;\r\n        emit ContentChanged(node, hash);\r\n    }\r\n\r\n    /**\r\n     * Sets the multihash associated with an ENS node.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param hash The multihash to set\r\n     */\r\n    function setMultihash(bytes32 node, bytes hash) public only_owner(node) {\r\n        records[node].multihash = hash;\r\n        emit MultihashChanged(node, hash);\r\n    }\r\n    \r\n    /**\r\n     * Sets the name associated with an ENS node, for reverse records.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param name The name to set.\r\n     */\r\n    function setName(bytes32 node, string name) public only_owner(node) {\r\n        records[node].name = name;\r\n        emit NameChanged(node, name);\r\n    }\r\n\r\n    /**\r\n     * Sets the ABI associated with an ENS node.\r\n     * Nodes may have one ABI of each content type. To remove an ABI, set it to\r\n     * the empty string.\r\n     * @param node The node to update.\r\n     * @param contentType The content type of the ABI\r\n     * @param data The ABI data.\r\n     */\r\n    function setABI(bytes32 node, uint256 contentType, bytes data) public only_owner(node) {\r\n        // Content types must be powers of 2\r\n        require(((contentType - 1) & contentType) == 0);\r\n        \r\n        records[node].abis[contentType] = data;\r\n        emit ABIChanged(node, contentType);\r\n    }\r\n    \r\n    /**\r\n     * Sets the SECP256k1 public key associated with an ENS node.\r\n     * @param node The ENS node to query\r\n     * @param x the X coordinate of the curve point for the public key.\r\n     * @param y the Y coordinate of the curve point for the public key.\r\n     */\r\n    function setPubkey(bytes32 node, bytes32 x, bytes32 y) public only_owner(node) {\r\n        records[node].pubkey = PublicKey(x, y);\r\n        emit PubkeyChanged(node, x, y);\r\n    }\r\n\r\n    /**\r\n     * Sets the text data associated with an ENS node and key.\r\n     * May only be called by the owner of that node in the ENS registry.\r\n     * @param node The node to update.\r\n     * @param key The key to set.\r\n     * @param value The text data value to set.\r\n     */\r\n    function setText(bytes32 node, string key, string value) public only_owner(node) {\r\n        records[node].text[key] = value;\r\n        emit TextChanged(node, key, key);\r\n    }\r\n\r\n    /**\r\n     * Returns the text data associated with an ENS node and key.\r\n     * @param node The ENS node to query.\r\n     * @param key The text data key to query.\r\n     * @return The associated text data.\r\n     */\r\n    function text(bytes32 node, string key) public view returns (string) {\r\n        return records[node].text[key];\r\n    }\r\n\r\n    /**\r\n     * Returns the SECP256k1 public key associated with an ENS node.\r\n     * Defined in EIP 619.\r\n     * @param node The ENS node to query\r\n     * @return x, y the X and Y coordinates of the curve point for the public key.\r\n     */\r\n    function pubkey(bytes32 node) public view returns (bytes32 x, bytes32 y) {\r\n        return (records[node].pubkey.x, records[node].pubkey.y);\r\n    }\r\n\r\n    /**\r\n     * Returns the ABI associated with an ENS node.\r\n     * Defined in EIP205.\r\n     * @param node The ENS node to query\r\n     * @param contentTypes A bitwise OR of the ABI formats accepted by the caller.\r\n     * @return contentType The content type of the return value\r\n     * @return data The ABI data\r\n     */\r\n    function ABI(bytes32 node, uint256 contentTypes) public view returns (uint256 contentType, bytes data) {\r\n        Record storage record = records[node];\r\n        for (contentType = 1; contentType <= contentTypes; contentType <<= 1) {\r\n            if ((contentType & contentTypes) != 0 && record.abis[contentType].length > 0) {\r\n                data = record.abis[contentType];\r\n                return;\r\n            }\r\n        }\r\n        contentType = 0;\r\n    }\r\n\r\n    /**\r\n     * Returns the name associated with an ENS node, for reverse records.\r\n     * Defined in EIP181.\r\n     * @param node The ENS node to query.\r\n     * @return The associated name.\r\n     */\r\n    function name(bytes32 node) public view returns (string) {\r\n        return records[node].name;\r\n    }\r\n\r\n    /**\r\n     * Returns the content hash associated with an ENS node.\r\n     * Note that this resource type is not standardized, and will likely change\r\n     * in future to a resource type based on multihash.\r\n     * @param node The ENS node to query.\r\n     * @return The associated content hash.\r\n     */\r\n    function content(bytes32 node) public view returns (bytes32) {\r\n        return records[node].content;\r\n    }\r\n\r\n    /**\r\n     * Returns the multihash associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated multihash.\r\n     */\r\n    function multihash(bytes32 node) public view returns (bytes) {\r\n        return records[node].multihash;\r\n    }\r\n\r\n    /**\r\n     * Returns the address associated with an ENS node.\r\n     * @param node The ENS node to query.\r\n     * @return The associated address.\r\n     */\r\n    function addr(bytes32 node) public view returns (address) {\r\n        return records[node].addr;\r\n    }\r\n\r\n    /**\r\n     * Returns true if the resolver implements the interface specified by the provided hash.\r\n     * @param interfaceID The ID of the interface to check for.\r\n     * @return True if the contract implements the requested interface.\r\n     */\r\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n        return interfaceID == ADDR_INTERFACE_ID ||\r\n        interfaceID == CONTENT_INTERFACE_ID ||\r\n        interfaceID == NAME_INTERFACE_ID ||\r\n        interfaceID == ABI_INTERFACE_ID ||\r\n        interfaceID == PUBKEY_INTERFACE_ID ||\r\n        interfaceID == TEXT_INTERFACE_ID ||\r\n        interfaceID == MULTIHASH_INTERFACE_ID ||\r\n        interfaceID == INTERFACE_META_ID;\r\n    }\r\n}\r\n\r\n\r\n/** \r\n * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH) \r\n * @notice Registers usernames as ENS subnodes of the domain `ensNode`\r\n */\r\ncontract UsernameRegistrar is Controlled, ApproveAndCallFallBack {\r\n    \r\n    ERC20Token public token;\r\n    ENS public ensRegistry;\r\n    PublicResolver public resolver;\r\n    address public parentRegistry;\r\n\r\n    uint256 public constant releaseDelay = 365 days;\r\n    mapping (bytes32 => Account) public accounts;\r\n    mapping (bytes32 => SlashReserve) reservedSlashers;\r\n\r\n    //Slashing conditions\r\n    uint256 public usernameMinLength;\r\n    bytes32 public reservedUsernamesMerkleRoot;\r\n    \r\n    event RegistryState(RegistrarState state);\r\n    event RegistryPrice(uint256 price);\r\n    event RegistryMoved(address newRegistry);\r\n    event UsernameOwner(bytes32 indexed nameHash, address owner);\r\n\r\n    enum RegistrarState { Inactive, Active, Moved }\r\n    bytes32 public ensNode;\r\n    uint256 public price;\r\n    RegistrarState public state;\r\n    uint256 public reserveAmount;\r\n\r\n    struct Account {\r\n        uint256 balance;\r\n        uint256 creationTime;\r\n        address owner;\r\n    }\r\n\r\n    struct SlashReserve {\r\n        address reserver;\r\n        uint256 blockNumber;\r\n    }\r\n\r\n    /**\r\n     * @notice Callable only by `parentRegistry()` to continue migration of ENSSubdomainRegistry.\r\n     */\r\n    modifier onlyParentRegistry {\r\n        require(msg.sender == parentRegistry, \"Migration only.\");\r\n        _;\r\n    }\r\n\r\n    /** \r\n     * @notice Initializes UsernameRegistrar contract. \r\n     * The only parameter from this list that can be changed later is `_resolver`.\r\n     * Other updates require a new contract and migration of domain.\r\n     * @param _token ERC20 token with optional `approveAndCall(address,uint256,bytes)` for locking fee.\r\n     * @param _ensRegistry Ethereum Name Service root contract address.\r\n     * @param _resolver Public Resolver for resolving usernames.\r\n     * @param _ensNode ENS node (domain) being used for usernames subnodes (subdomain)\r\n     * @param _usernameMinLength Minimum length of usernames \r\n     * @param _reservedUsernamesMerkleRoot Merkle root of reserved usernames\r\n     * @param _parentRegistry Address of old registry (if any) for optional account migration.\r\n     */\r\n    constructor(\r\n        ERC20Token _token,\r\n        ENS _ensRegistry,\r\n        PublicResolver _resolver,\r\n        bytes32 _ensNode,\r\n        uint256 _usernameMinLength,\r\n        bytes32 _reservedUsernamesMerkleRoot,\r\n        address _parentRegistry\r\n    ) \r\n        public \r\n    {\r\n        require(address(_token) != address(0), \"No ERC20Token address defined.\");\r\n        require(address(_ensRegistry) != address(0), \"No ENS address defined.\");\r\n        require(address(_resolver) != address(0), \"No Resolver address defined.\");\r\n        require(_ensNode != bytes32(0), \"No ENS node defined.\");\r\n        token = _token;\r\n        ensRegistry = _ensRegistry;\r\n        resolver = _resolver;\r\n        ensNode = _ensNode;\r\n        usernameMinLength = _usernameMinLength;\r\n        reservedUsernamesMerkleRoot = _reservedUsernamesMerkleRoot;\r\n        parentRegistry = _parentRegistry;\r\n        setState(RegistrarState.Inactive);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers `_label` username to `ensNode` setting msg.sender as owner.\r\n     * Terms of name registration:\r\n     * - SNT is deposited, not spent; the amount is locked up for 1 year.\r\n     * - After 1 year, the user can release the name and receive their deposit back (at any time).\r\n     * - User deposits are completely protected. The contract controller cannot access them.\r\n     * - User's address(es) will be publicly associated with the ENS name.\r\n     * - User must authorise the contract to transfer `price` `token.name()`  on their behalf.\r\n     * - Usernames registered with less then `usernameMinLength` characters can be slashed.\r\n     * - Usernames contained in the merkle tree of root `reservedUsernamesMerkleRoot` can be slashed.\r\n     * - Usernames starting with `0x` and bigger then 12 characters can be slashed.\r\n     * - If terms of the contract change—e.g. Status makes contract upgrades—the user has the right to release the username and get their deposit back.\r\n     * @param _label Choosen unowned username hash.\r\n     * @param _account Optional address to set at public resolver.\r\n     * @param _pubkeyA Optional pubkey part A to set at public resolver.\r\n     * @param _pubkeyB Optional pubkey part B to set at public resolver.\r\n     */\r\n    function register(\r\n        bytes32 _label,\r\n        address _account,\r\n        bytes32 _pubkeyA,\r\n        bytes32 _pubkeyB\r\n    ) \r\n        external \r\n        returns(bytes32 namehash) \r\n    {\r\n        return registerUser(msg.sender, _label, _account, _pubkeyA, _pubkeyB);\r\n    }\r\n    \r\n    /** \r\n     * @notice Release username and retrieve locked fee, needs to be called \r\n     * after `releasePeriod` from creation time by ENS registry owner of domain \r\n     * or anytime by account owner when domain migrated to a new registry.\r\n     * @param _label Username hash.\r\n     */\r\n    function release(\r\n        bytes32 _label\r\n    )\r\n        external \r\n    {\r\n        bytes32 namehash = keccak256(abi.encodePacked(ensNode, _label));\r\n        Account memory account = accounts[_label];\r\n        require(account.creationTime > 0, \"Username not registered.\");\r\n        if (state == RegistrarState.Active) {\r\n            require(msg.sender == ensRegistry.owner(namehash), \"Not owner of ENS node.\");\r\n            require(block.timestamp > account.creationTime + releaseDelay, \"Release period not reached.\");\r\n        } else {\r\n            require(msg.sender == account.owner, \"Not the former account owner.\");\r\n        }\r\n        delete accounts[_label];\r\n        if (account.balance > 0) {\r\n            reserveAmount -= account.balance;\r\n            require(token.transfer(msg.sender, account.balance), \"Transfer failed\");\r\n        }\r\n        if (state == RegistrarState.Active) {\r\n            ensRegistry.setSubnodeOwner(ensNode, _label, address(this));\r\n            ensRegistry.setResolver(namehash, address(0));\r\n            ensRegistry.setOwner(namehash, address(0));\r\n        } else {\r\n            address newOwner = ensRegistry.owner(ensNode);\r\n            //Low level call, case dropUsername not implemented or failing, proceed release. \r\n            //Invert (!) to supress warning, return of this call have no use.\r\n            !newOwner.call.gas(80000)(\r\n                abi.encodeWithSignature(\r\n                    \"dropUsername(bytes32)\",\r\n                    _label\r\n                )\r\n            );\r\n        }\r\n        emit UsernameOwner(namehash, address(0));   \r\n    }\r\n\r\n    /** \r\n     * @notice update account owner, should be called by new ens node owner \r\n     * to update this contract registry, otherwise former owner can release \r\n     * if domain is moved to a new registry. \r\n     * @param _label Username hash.\r\n     **/\r\n    function updateAccountOwner(\r\n        bytes32 _label\r\n    ) \r\n        external \r\n    {\r\n        bytes32 namehash = keccak256(abi.encodePacked(ensNode, _label));\r\n        require(msg.sender == ensRegistry.owner(namehash), \"Caller not owner of ENS node.\");\r\n        require(accounts[_label].creationTime > 0, \"Username not registered.\");\r\n        require(ensRegistry.owner(ensNode) == address(this), \"Registry not owner of registry.\");\r\n        accounts[_label].owner = msg.sender;\r\n        emit UsernameOwner(namehash, msg.sender);\r\n    }  \r\n\r\n    /**\r\n     * @notice secretly reserve the slashing reward to `msg.sender`\r\n     * @param _secret keccak256(abi.encodePacked(namehash, creationTime, reserveSecret)) \r\n     */\r\n    function reserveSlash(bytes32 _secret) external {\r\n        require(reservedSlashers[_secret].blockNumber == 0, \"Already Reserved\");\r\n        reservedSlashers[_secret] = SlashReserve(msg.sender, block.number);\r\n    }\r\n\r\n    /**\r\n     * @notice Slash username smaller then `usernameMinLength`.\r\n     * @param _username Raw value of offending username.\r\n     */\r\n    function slashSmallUsername(\r\n        string _username,\r\n        uint256 _reserveSecret\r\n    ) \r\n        external \r\n    {\r\n        bytes memory username = bytes(_username);\r\n        require(username.length < usernameMinLength, \"Not a small username.\");\r\n        slashUsername(username, _reserveSecret);\r\n    }\r\n\r\n    /**\r\n     * @notice Slash username starting with \"0x\" and with length greater than 12.\r\n     * @param _username Raw value of offending username.\r\n     */\r\n    function slashAddressLikeUsername(\r\n        string _username,\r\n        uint256 _reserveSecret\r\n    ) \r\n        external \r\n    {\r\n        bytes memory username = bytes(_username);\r\n        require(username.length > 12, \"Too small to look like an address.\");\r\n        require(username[0] == byte(\"0\"), \"First character need to be 0\");\r\n        require(username[1] == byte(\"x\"), \"Second character need to be x\");\r\n        for(uint i = 2; i < 7; i++){\r\n            byte b = username[i];\r\n            require((b >= 48 && b <= 57) || (b >= 97 && b <= 102), \"Does not look like an address\");\r\n        }\r\n        slashUsername(username, _reserveSecret);\r\n    }  \r\n\r\n    /**\r\n     * @notice Slash username that is exactly a reserved name.\r\n     * @param _username Raw value of offending username.\r\n     * @param _proof Merkle proof that name is listed on merkle tree.\r\n     */\r\n    function slashReservedUsername(\r\n        string _username,\r\n        bytes32[] _proof,\r\n        uint256 _reserveSecret\r\n    ) \r\n        external \r\n    {   \r\n        bytes memory username = bytes(_username);\r\n        require(\r\n            MerkleProof.verifyProof(\r\n                _proof,\r\n                reservedUsernamesMerkleRoot,\r\n                keccak256(username)\r\n            ),\r\n            \"Invalid Proof.\"\r\n        );\r\n        slashUsername(username, _reserveSecret);\r\n    }\r\n\r\n    /**\r\n     * @notice Slash username that contains a non alphanumeric character.\r\n     * @param _username Raw value of offending username.\r\n     * @param _offendingPos Position of non alphanumeric character.\r\n     */\r\n    function slashInvalidUsername(\r\n        string _username,\r\n        uint256 _offendingPos,\r\n        uint256 _reserveSecret\r\n    ) \r\n        external\r\n    { \r\n        bytes memory username = bytes(_username);\r\n        require(username.length > _offendingPos, \"Invalid position.\");\r\n        byte b = username[_offendingPos];\r\n        \r\n        require(!((b >= 48 && b <= 57) || (b >= 97 && b <= 122)), \"Not invalid character.\");\r\n    \r\n        slashUsername(username, _reserveSecret);\r\n    }\r\n\r\n    /**\r\n     * @notice Clear resolver and ownership of unowned subdomians.\r\n     * @param _labels Sequence to erase.\r\n     */\r\n    function eraseNode(\r\n        bytes32[] _labels\r\n    ) \r\n        external \r\n    {\r\n        uint len = _labels.length;\r\n        require(len != 0, \"Nothing to erase\");\r\n        bytes32 label = _labels[len - 1];\r\n        bytes32 subnode = keccak256(abi.encodePacked(ensNode, label));\r\n        require(ensRegistry.owner(subnode) == address(0), \"First slash/release top level subdomain\");\r\n        ensRegistry.setSubnodeOwner(ensNode, label, address(this));\r\n        if(len > 1) {\r\n            eraseNodeHierarchy(len - 2, _labels, subnode);\r\n        }\r\n        ensRegistry.setResolver(subnode, 0);\r\n        ensRegistry.setOwner(subnode, 0);\r\n    }\r\n\r\n    /**\r\n     * @notice Migrate account to new registry, opt-in to new contract.\r\n     * @param _label Username hash.\r\n     **/\r\n    function moveAccount(\r\n        bytes32 _label,\r\n        UsernameRegistrar _newRegistry\r\n    ) \r\n        external \r\n    {\r\n        require(state == RegistrarState.Moved, \"Wrong contract state\");\r\n        require(msg.sender == accounts[_label].owner, \"Callable only by account owner.\");\r\n        require(ensRegistry.owner(ensNode) == address(_newRegistry), \"Wrong update\");\r\n        Account memory account = accounts[_label];\r\n        delete accounts[_label];\r\n\r\n        token.approve(_newRegistry, account.balance);\r\n        _newRegistry.migrateUsername(\r\n            _label,\r\n            account.balance,\r\n            account.creationTime,\r\n            account.owner\r\n        );\r\n    }\r\n\r\n    /** \r\n     * @notice Activate registration.\r\n     * @param _price The price of registration.\r\n     */\r\n    function activate(\r\n        uint256 _price\r\n    ) \r\n        external\r\n        onlyController\r\n    {\r\n        require(state == RegistrarState.Inactive, \"Registry state is not Inactive\");\r\n        require(ensRegistry.owner(ensNode) == address(this), \"Registry does not own registry\");\r\n        price = _price;\r\n        setState(RegistrarState.Active);\r\n        emit RegistryPrice(_price);\r\n    }\r\n\r\n    /** \r\n     * @notice Updates Public Resolver for resolving users.\r\n     * @param _resolver New PublicResolver.\r\n     */\r\n    function setResolver(\r\n        address _resolver\r\n    ) \r\n        external\r\n        onlyController\r\n    {\r\n        resolver = PublicResolver(_resolver);\r\n    }\r\n\r\n    /**\r\n     * @notice Updates registration price.\r\n     * @param _price New registration price.\r\n     */\r\n    function updateRegistryPrice(\r\n        uint256 _price\r\n    ) \r\n        external\r\n        onlyController\r\n    {\r\n        require(state == RegistrarState.Active, \"Registry not owned\");\r\n        price = _price;\r\n        emit RegistryPrice(_price);\r\n    }\r\n  \r\n    /**\r\n     * @notice Transfer ownership of ensNode to `_newRegistry`.\r\n     * Usernames registered are not affected, but they would be able to instantly release.\r\n     * @param _newRegistry New UsernameRegistrar for hodling `ensNode` node.\r\n     */\r\n    function moveRegistry(\r\n        UsernameRegistrar _newRegistry\r\n    ) \r\n        external\r\n        onlyController\r\n    {\r\n        require(_newRegistry != this, \"Cannot move to self.\");\r\n        require(ensRegistry.owner(ensNode) == address(this), \"Registry not owned anymore.\");\r\n        setState(RegistrarState.Moved);\r\n        ensRegistry.setOwner(ensNode, _newRegistry);\r\n        _newRegistry.migrateRegistry(price);\r\n        emit RegistryMoved(_newRegistry);\r\n    }\r\n\r\n    /** \r\n     * @notice Opt-out migration of username from `parentRegistry()`.\r\n     * Clear ENS resolver and subnode owner.\r\n     * @param _label Username hash.\r\n     */\r\n    function dropUsername(\r\n        bytes32 _label\r\n    ) \r\n        external \r\n        onlyParentRegistry\r\n    {\r\n        require(accounts[_label].creationTime == 0, \"Already migrated\");\r\n        bytes32 namehash = keccak256(abi.encodePacked(ensNode, _label));\r\n        ensRegistry.setSubnodeOwner(ensNode, _label, address(this));\r\n        ensRegistry.setResolver(namehash, address(0));\r\n        ensRegistry.setOwner(namehash, address(0));\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw not reserved tokens\r\n     * @param _token Address of ERC20 withdrawing excess, or address(0) if want ETH.\r\n     * @param _beneficiary Address to send the funds.\r\n     **/\r\n    function withdrawExcessBalance(\r\n        address _token,\r\n        address _beneficiary\r\n    )\r\n        external \r\n        onlyController \r\n    {\r\n        require(_beneficiary != address(0), \"Cannot burn token\");\r\n        if (_token == address(0)) {\r\n            _beneficiary.transfer(address(this).balance);\r\n        } else {\r\n            ERC20Token excessToken = ERC20Token(_token);\r\n            uint256 amount = excessToken.balanceOf(address(this));\r\n            if(_token == address(token)){\r\n                require(amount > reserveAmount, \"Is not excess\");\r\n                amount -= reserveAmount;\r\n            } else {\r\n                require(amount > 0, \"No balance\");\r\n            }\r\n            excessToken.transfer(_beneficiary, amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw ens nodes not belonging to this contract.\r\n     * @param _domainHash Ens node namehash.\r\n     * @param _beneficiary New owner of ens node.\r\n     **/\r\n    function withdrawWrongNode(\r\n        bytes32 _domainHash,\r\n        address _beneficiary\r\n    ) \r\n        external\r\n        onlyController\r\n    {\r\n        require(_beneficiary != address(0), \"Cannot burn node\");\r\n        require(_domainHash != ensNode, \"Cannot withdraw main node\");   \r\n        require(ensRegistry.owner(_domainHash) == address(this), \"Not owner of this node\");   \r\n        ensRegistry.setOwner(_domainHash, _beneficiary);\r\n    }\r\n\r\n    /**\r\n     * @notice Gets registration price.\r\n     * @return Registration price.\r\n     **/\r\n    function getPrice() \r\n        external \r\n        view \r\n        returns(uint256 registryPrice) \r\n    {\r\n        return price;\r\n    }\r\n    \r\n    /**\r\n     * @notice reads amount tokens locked in username \r\n     * @param _label Username hash.\r\n     * @return Locked username balance.\r\n     **/\r\n    function getAccountBalance(bytes32 _label)\r\n        external\r\n        view\r\n        returns(uint256 accountBalance) \r\n    {\r\n        accountBalance = accounts[_label].balance;\r\n    }\r\n\r\n    /**\r\n     * @notice reads username account owner at this contract, \r\n     * which can release or migrate in case of upgrade.\r\n     * @param _label Username hash.\r\n     * @return Username account owner.\r\n     **/\r\n    function getAccountOwner(bytes32 _label)\r\n        external\r\n        view\r\n        returns(address owner) \r\n    {\r\n        owner = accounts[_label].owner;\r\n    }\r\n\r\n    /**\r\n     * @notice reads when the account was registered \r\n     * @param _label Username hash.\r\n     * @return Registration time.\r\n     **/\r\n    function getCreationTime(bytes32 _label)\r\n        external\r\n        view\r\n        returns(uint256 creationTime) \r\n    {\r\n        creationTime = accounts[_label].creationTime;\r\n    }\r\n\r\n    /**\r\n     * @notice calculate time where username can be released \r\n     * @param _label Username hash.\r\n     * @return Exact time when username can be released.\r\n     **/\r\n    function getExpirationTime(bytes32 _label)\r\n        external\r\n        view\r\n        returns(uint256 releaseTime)\r\n    {\r\n        uint256 creationTime = accounts[_label].creationTime;\r\n        if (creationTime > 0){\r\n            releaseTime = creationTime + releaseDelay;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice calculate reward part an account could payout on slash \r\n     * @param _label Username hash.\r\n     * @return Part of reward\r\n     **/\r\n    function getSlashRewardPart(bytes32 _label)\r\n        external\r\n        view\r\n        returns(uint256 partReward)\r\n    {\r\n        uint256 balance = accounts[_label].balance;\r\n        if (balance > 0) {\r\n            partReward = balance / 3;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Support for \"approveAndCall\". Callable only by `token()`.  \r\n     * @param _from Who approved.\r\n     * @param _amount Amount being approved, need to be equal `getPrice()`.\r\n     * @param _token Token being approved, need to be equal `token()`.\r\n     * @param _data Abi encoded data with selector of `register(bytes32,address,bytes32,bytes32)`.\r\n     */\r\n    function receiveApproval(\r\n        address _from,\r\n        uint256 _amount,\r\n        address _token,\r\n        bytes _data\r\n    ) \r\n        public\r\n    {\r\n        require(_amount == price, \"Wrong value\");\r\n        require(_token == address(token), \"Wrong token\");\r\n        require(_token == address(msg.sender), \"Wrong call\");\r\n        require(_data.length <= 132, \"Wrong data length\");\r\n        bytes4 sig;\r\n        bytes32 label;\r\n        address account;\r\n        bytes32 pubkeyA;\r\n        bytes32 pubkeyB;\r\n        (sig, label, account, pubkeyA, pubkeyB) = abiDecodeRegister(_data);\r\n        require(\r\n            sig == bytes4(0xb82fedbb), //bytes4(keccak256(\"register(bytes32,address,bytes32,bytes32)\"))\r\n            \"Wrong method selector\"\r\n        );\r\n        registerUser(_from, label, account, pubkeyA, pubkeyB);\r\n    }\r\n   \r\n    /**\r\n     * @notice Continues migration of username to new registry.\r\n     * @param _label Username hash.\r\n     * @param _tokenBalance Amount being transfered from `parentRegistry()`.\r\n     * @param _creationTime Time user registrated in `parentRegistry()` is preserved. \r\n     * @param _accountOwner Account owner which migrated the account.\r\n     **/\r\n    function migrateUsername(\r\n        bytes32 _label,\r\n        uint256 _tokenBalance,\r\n        uint256 _creationTime,\r\n        address _accountOwner\r\n    )\r\n        external\r\n        onlyParentRegistry\r\n    {\r\n        if (_tokenBalance > 0) {\r\n            require(\r\n                token.transferFrom(\r\n                    parentRegistry,\r\n                    address(this),\r\n                    _tokenBalance\r\n                ), \r\n                \"Error moving funds from old registar.\"\r\n            );\r\n            reserveAmount += _tokenBalance;\r\n        }\r\n        accounts[_label] = Account(_tokenBalance, _creationTime, _accountOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev callable only by parent registry to continue migration\r\n     * of registry and activate registration.\r\n     * @param _price The price of registration.\r\n     **/\r\n    function migrateRegistry(\r\n        uint256 _price\r\n    ) \r\n        external\r\n        onlyParentRegistry\r\n    {\r\n        require(state == RegistrarState.Inactive, \"Not Inactive\");\r\n        require(ensRegistry.owner(ensNode) == address(this), \"ENS registry owner not transfered.\");\r\n        price = _price;\r\n        setState(RegistrarState.Active);\r\n        emit RegistryPrice(_price);\r\n    }\r\n\r\n    /**\r\n     * @notice Registers `_label` username to `ensNode` setting msg.sender as owner.\r\n     * @param _owner Address registering the user and paying registry price.\r\n     * @param _label Choosen unowned username hash.\r\n     * @param _account Optional address to set at public resolver.\r\n     * @param _pubkeyA Optional pubkey part A to set at public resolver.\r\n     * @param _pubkeyB Optional pubkey part B to set at public resolver.\r\n     */\r\n    function registerUser(\r\n        address _owner,\r\n        bytes32 _label,\r\n        address _account,\r\n        bytes32 _pubkeyA,\r\n        bytes32 _pubkeyB\r\n    ) \r\n        internal \r\n        returns(bytes32 namehash)\r\n    {\r\n        require(state == RegistrarState.Active, \"Registry unavailable.\");\r\n        namehash = keccak256(abi.encodePacked(ensNode, _label));\r\n        require(ensRegistry.owner(namehash) == address(0), \"ENS node already owned.\");\r\n        require(accounts[_label].creationTime == 0, \"Username already registered.\");\r\n        accounts[_label] = Account(price, block.timestamp, _owner);\r\n        if(price > 0) {\r\n            require(token.allowance(_owner, address(this)) >= price, \"Unallowed to spend.\");\r\n            require(\r\n                token.transferFrom(\r\n                    _owner,\r\n                    address(this),\r\n                    price\r\n                ),\r\n                \"Transfer failed\"\r\n            );\r\n            reserveAmount += price;\r\n        } \r\n    \r\n        bool resolvePubkey = _pubkeyA != 0 || _pubkeyB != 0;\r\n        bool resolveAccount = _account != address(0);\r\n        if (resolvePubkey || resolveAccount) {\r\n            //set to self the ownership to setup initial resolver\r\n            ensRegistry.setSubnodeOwner(ensNode, _label, address(this));\r\n            ensRegistry.setResolver(namehash, resolver); //default resolver\r\n            if (resolveAccount) {\r\n                resolver.setAddr(namehash, _account);\r\n            }\r\n            if (resolvePubkey) {\r\n                resolver.setPubkey(namehash, _pubkeyA, _pubkeyB);\r\n            }\r\n            ensRegistry.setOwner(namehash, _owner);\r\n        } else {\r\n            //transfer ownership of subdone directly to registrant\r\n            ensRegistry.setSubnodeOwner(ensNode, _label, _owner);\r\n        }\r\n        emit UsernameOwner(namehash, _owner);\r\n    }\r\n    \r\n    /**\r\n     * @dev Removes account hash of `_username` and send account.balance to msg.sender.\r\n     * @param _username Username being slashed.\r\n     */\r\n    function slashUsername(\r\n        bytes _username,\r\n        uint256 _reserveSecret\r\n    ) \r\n        internal \r\n    {\r\n        bytes32 label = keccak256(_username);\r\n        bytes32 namehash = keccak256(abi.encodePacked(ensNode, label));\r\n        uint256 amountToTransfer = 0;\r\n        uint256 creationTime = accounts[label].creationTime;\r\n        address owner = ensRegistry.owner(namehash);\r\n        if(creationTime == 0) {\r\n            require(\r\n                owner != address(0) ||\r\n                ensRegistry.resolver(namehash) != address(0),\r\n                \"Nothing to slash.\"\r\n            );\r\n        } else {\r\n            assert(creationTime != block.timestamp);\r\n            amountToTransfer = accounts[label].balance;\r\n            delete accounts[label];\r\n        }\r\n\r\n        ensRegistry.setSubnodeOwner(ensNode, label, address(this));\r\n        ensRegistry.setResolver(namehash, address(0));\r\n        ensRegistry.setOwner(namehash, address(0));\r\n        \r\n        if (amountToTransfer > 0) {\r\n            reserveAmount -= amountToTransfer;\r\n            uint256 partialDeposit = amountToTransfer / 3;\r\n            amountToTransfer = partialDeposit * 2; // reserve 1/3 to network (controller)\r\n            bytes32 secret = keccak256(abi.encodePacked(namehash, creationTime, _reserveSecret));\r\n            SlashReserve memory reserve = reservedSlashers[secret];\r\n            require(reserve.reserver != address(0), \"Not reserved.\");\r\n            require(reserve.blockNumber < block.number, \"Cannot reveal in same block\");\r\n            delete reservedSlashers[secret];\r\n\r\n            require(token.transfer(reserve.reserver, amountToTransfer), \"Error in transfer.\");\r\n        }\r\n        emit UsernameOwner(namehash, address(0));\r\n    }\r\n\r\n    function setState(RegistrarState _state) private {\r\n        state = _state;\r\n        emit RegistryState(_state);\r\n    }\r\n\r\n    /**\r\n     * @notice recursively erase all _labels in _subnode\r\n     * @param _idx recursive position of _labels to erase\r\n     * @param _labels list of subnode labes\r\n     * @param _subnode subnode being erased\r\n     */\r\n    function eraseNodeHierarchy(\r\n        uint _idx,\r\n        bytes32[] _labels,\r\n        bytes32 _subnode\r\n    ) \r\n        private \r\n    {\r\n        // Take ownership of the node\r\n        ensRegistry.setSubnodeOwner(_subnode, _labels[_idx], address(this));\r\n        bytes32 subnode = keccak256(abi.encodePacked(_subnode, _labels[_idx]));\r\n\r\n        // Recurse if there are more labels\r\n        if (_idx > 0) {\r\n            eraseNodeHierarchy(_idx - 1, _labels, subnode);\r\n        }\r\n\r\n        // Erase the resolver and owner records\r\n        ensRegistry.setResolver(subnode, 0);\r\n        ensRegistry.setOwner(subnode, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev Decodes abi encoded data with selector for \"register(bytes32,address,bytes32,bytes32)\".\r\n     * @param _data Abi encoded data.\r\n     * @return Decoded registry call.\r\n     */\r\n    function abiDecodeRegister(\r\n        bytes _data\r\n    ) \r\n        private \r\n        pure \r\n        returns(\r\n            bytes4 sig,\r\n            bytes32 label,\r\n            address account,\r\n            bytes32 pubkeyA,\r\n            bytes32 pubkeyB\r\n        )\r\n    {\r\n        assembly {\r\n            sig := mload(add(_data, add(0x20, 0)))\r\n            label := mload(add(_data, 36))\r\n            account := mload(add(_data, 68))\r\n            pubkeyA := mload(add(_data, 100))\r\n            pubkeyB := mload(add(_data, 132))\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"resolver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_secret\",\"type\":\"bytes32\"}],\"name\":\"reserveSlash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedUsernamesMerkleRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawExcessBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"}],\"name\":\"updateAccountOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newController\",\"type\":\"address\"}],\"name\":\"changeController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"},{\"name\":\"_offendingPos\",\"type\":\"uint256\"},{\"name\":\"_reserveSecret\",\"type\":\"uint256\"}],\"name\":\"slashInvalidUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"},{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_reserveSecret\",\"type\":\"uint256\"}],\"name\":\"slashReservedUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"setResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usernameMinLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"}],\"name\":\"getCreationTime\",\"outputs\":[{\"name\":\"creationTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"releaseDelay\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ensRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"},{\"name\":\"_tokenBalance\",\"type\":\"uint256\"},{\"name\":\"_creationTime\",\"type\":\"uint256\"},{\"name\":\"_accountOwner\",\"type\":\"address\"}],\"name\":\"migrateUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"}],\"name\":\"getSlashRewardPart\",\"outputs\":[{\"name\":\"partReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"updateRegistryPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"},{\"name\":\"_reserveSecret\",\"type\":\"uint256\"}],\"name\":\"slashAddressLikeUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_username\",\"type\":\"string\"},{\"name\":\"_reserveSecret\",\"type\":\"uint256\"}],\"name\":\"slashSmallUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getPrice\",\"outputs\":[{\"name\":\"registryPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"migrateRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"}],\"name\":\"getExpirationTime\",\"outputs\":[{\"name\":\"releaseTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"}],\"name\":\"getAccountOwner\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_domainHash\",\"type\":\"bytes32\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawWrongNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"},{\"name\":\"_account\",\"type\":\"address\"},{\"name\":\"_pubkeyA\",\"type\":\"bytes32\"},{\"name\":\"_pubkeyB\",\"type\":\"bytes32\"}],\"name\":\"register\",\"outputs\":[{\"name\":\"namehash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"accounts\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"creationTime\",\"type\":\"uint256\"},{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"},{\"name\":\"_newRegistry\",\"type\":\"address\"}],\"name\":\"moveAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"parentRegistry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ensNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_labels\",\"type\":\"bytes32[]\"}],\"name\":\"eraseNode\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRegistry\",\"type\":\"address\"}],\"name\":\"moveRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"}],\"name\":\"getAccountBalance\",\"outputs\":[{\"name\":\"accountBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"controller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_label\",\"type\":\"bytes32\"}],\"name\":\"dropUsername\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_ensRegistry\",\"type\":\"address\"},{\"name\":\"_resolver\",\"type\":\"address\"},{\"name\":\"_ensNode\",\"type\":\"bytes32\"},{\"name\":\"_usernameMinLength\",\"type\":\"uint256\"},{\"name\":\"_reservedUsernamesMerkleRoot\",\"type\":\"bytes32\"},{\"name\":\"_parentRegistry\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"state\",\"type\":\"uint8\"}],\"name\":\"RegistryState\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"RegistryPrice\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRegistry\",\"type\":\"address\"}],\"name\":\"RegistryMoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"nameHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"UsernameOwner\",\"type\":\"event\"}]","ContractName":"UsernameRegistrar","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000744d70fdbe2ba4cf95131626614a1763df805b9e000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b0000000000000000000000005ffc014343cd971b7eb70732021e26c35b744cc4a9b5c92757edc45765dcdfbb101c37f1cdd06425a96eeb067d73cb4ec2c96e540000000000000000000000000000000000000000000000000000000000000003631ed59b5e3491557773f5a948344a0c7d873f5acaec8208caa1d01b9b8c375c0000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://c991778bf7278b650783a8c735f2610651176ed072d1b1b90ce50017c72a5468"}]}