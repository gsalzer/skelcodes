{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\ncontract owned {\r\n    address public owner;\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _who) public view returns (uint256);\r\n\r\n    function transfer(address _to, uint256 _value) public returns (bool);\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 value\r\n    );\r\n}\r\n\r\n\r\ncontract StandardToken is ERC20 {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) internal balances;\r\n\r\n    uint256 internal totalSupply_;\r\n\r\n    /**\r\n     * @dev Total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_value <= balances[msg.sender]);\r\n        require(_to != address(0));\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\ncontract ioeXTokenERC20 is StandardToken, owned {\r\n    using SafeMath for uint256;\r\n\r\n    // Public variables of the token\r\n    bytes internal name_ = \"Internet of Everything X\";\r\n\r\n    bytes internal symbol_ = \"IOEX\";\r\n\r\n    uint256 public decimals = 8;\r\n\r\n    uint256 private constant LOCK_TYPE_MAX = 3;\r\n    uint256 private constant LOCK_STAGE_MAX = 4;\r\n\r\n    mapping (address => bool) public frozenAccount;\r\n\r\n    //Save lock type and amount of init tokens\r\n    struct StructLockAccountInfo {\r\n        uint256 lockType;\r\n        uint256 initBalance;\r\n        uint256 startTime;\r\n    }\r\n\r\n    mapping (address => StructLockAccountInfo) public lockAccountInfo;\r\n \r\n    //Save 4 set of time and percent of unlocked tokens\r\n    struct StructLockType {\r\n        uint256[LOCK_STAGE_MAX] time;\r\n        uint256[LOCK_STAGE_MAX] freePercent;\r\n    }\r\n\r\n    StructLockType[LOCK_TYPE_MAX] private lockType;\r\n\r\n    // This generates a public event on the blockchain that will notify clients\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n    // This notifies clients about the amount burnt\r\n    event Burn(address indexed from, uint256 value);\r\n\r\n    // This generates a public event that record info about locked account,\r\n    // including amount of init tokens and lock type\r\n    event SetLockData(address indexed account, uint256 initBalance, uint256 lockType, uint256 startDate);\r\n\r\n    /* This generates a public event on the blockchain that will notify clients */\r\n    event FrozenFunds(address target, bool frozen);\r\n\r\n    /**\r\n     * Constructor function\r\n     *\r\n     * Initializes contract with initial supply tokens to the creator of the contract\r\n     */\r\n    constructor() public {\r\n        totalSupply_ = 20000000000000000;\r\n        balances[msg.sender] = totalSupply_;  // Give the creator all initial tokens\r\n\r\n        //init all lock data\r\n        //Lock type 1\r\n        lockType[0].time[0] = 30;\r\n        lockType[0].freePercent[0] = 40;     //40%\r\n        lockType[0].time[1] = 60;\r\n        lockType[0].freePercent[1] = 20;     //20%\r\n        lockType[0].time[2] = 120;\r\n        lockType[0].freePercent[2] = 20;     //20%\r\n        lockType[0].time[3] = 180;\r\n        lockType[0].freePercent[3] = 20;     //20%\r\n\r\n        //Lock type 2\r\n        lockType[1].time[0] = 30;\r\n        lockType[1].freePercent[0] = 25;     //25%\r\n        lockType[1].time[1] = 60;\r\n        lockType[1].freePercent[1] = 25;     //25%\r\n        lockType[1].time[2] = 120;\r\n        lockType[1].freePercent[2] = 25;     //25%\r\n        lockType[1].time[3] = 180;\r\n        lockType[1].freePercent[3] = 25;     //25%\r\n\r\n        //Lock type 3\r\n        lockType[2].time[0] = 180;\r\n        lockType[2].freePercent[0] = 25;     //25%\r\n        lockType[2].time[1] = 360;\r\n        lockType[2].freePercent[1] = 25;     //25%\r\n        lockType[2].time[2] = 540;\r\n        lockType[2].freePercent[2] = 25;     //25%\r\n        lockType[2].time[3] = 720;\r\n        lockType[2].freePercent[3] = 25;     //25%\r\n\r\n        //init all lock data\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token name\r\n    * @return string representing the token name\r\n    */\r\n    function name() external view returns (string) {\r\n        return string(name_);\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the token symbol\r\n    * @return string representing the token symbol\r\n    */\r\n    function symbol() external view returns (string) {\r\n        return string(symbol_);\r\n    }\r\n\r\n    /**\r\n     * Calculate how much tokens must be locked\r\n     * return the amount of locked tokens\r\n     */\r\n    function getLockBalance(address account) internal returns (uint256) {\r\n        uint256 lockTypeIndex;\r\n        uint256 amountLockedTokens = 0;\r\n        uint256 resultFreePercent = 0;\r\n        uint256 duration = 0;\r\n        uint256 i;\r\n\r\n        lockTypeIndex = lockAccountInfo[account].lockType;\r\n\r\n        if (lockTypeIndex >= 1) {\r\n            if (lockTypeIndex <= LOCK_TYPE_MAX) {\r\n                lockTypeIndex = lockTypeIndex.sub(1);\r\n                for (i = 0; i < LOCK_STAGE_MAX; i++) {\r\n                    duration = (lockType[lockTypeIndex].time[i]).mul(1 days);\r\n                    if (lockAccountInfo[account].startTime.add(duration) >= now) {\r\n                        resultFreePercent = resultFreePercent.add(lockType[lockTypeIndex].freePercent[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            amountLockedTokens = (lockAccountInfo[account].initBalance.mul(resultFreePercent)).div(100);\r\n\r\n            if (amountLockedTokens == 0){\r\n                lockAccountInfo[account].lockType = 0;\r\n            }\r\n        }\r\n\r\n        return amountLockedTokens;\r\n    }\r\n\r\n    /**\r\n     * Internal transfer, only can be called by this contract\r\n     * Transfer toekns, and lock time and balance by selectType\r\n     */\r\n    function _transferForLock(address _to, uint256 _value, uint256 selectType) internal {\r\n        require(selectType >= 1);\r\n        require(selectType <= LOCK_TYPE_MAX);\r\n\r\n        if ((lockAccountInfo[_to].lockType == 0) && \r\n            (lockAccountInfo[_to].initBalance == 0)) {\r\n            require(_value <= balances[msg.sender]);\r\n            require(_to != address(0));\r\n\r\n            //write data\r\n            lockAccountInfo[_to].lockType = selectType;\r\n            lockAccountInfo[_to].initBalance = _value;\r\n            lockAccountInfo[_to].startTime = now;\r\n            emit SetLockData(_to,_value, lockAccountInfo[_to].lockType, lockAccountInfo[_to].startTime);\r\n            //write data\r\n\r\n            balances[msg.sender] = balances[msg.sender].sub(_value);\r\n            balances[_to] = balances[_to].add(_value);\r\n            emit Transfer(msg.sender, _to, _value);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        //check\r\n        uint256 freeBalance;\r\n\r\n        if (lockAccountInfo[msg.sender].lockType > 0) {\r\n            freeBalance = balances[msg.sender].sub(getLockBalance(msg.sender));\r\n            require(freeBalance >=_value);\r\n        }\r\n        //check\r\n\r\n        require(_value <= balances[msg.sender]);\r\n        require(_to != address(0));\r\n        require(!frozenAccount[msg.sender]);        // Check if sender is frozen\r\n        require(!frozenAccount[_to]);               // Check if recipient is frozen\r\n\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\r\n    /// @param target Address to be frozen\r\n    /// @param freeze either to freeze it or not\r\n    function freezeAccount(address target, bool freeze) public onlyOwner {\r\n        frozenAccount[target] = freeze;\r\n        emit FrozenFunds(target, freeze);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     * Lock time and token by lock_type 1\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferLockBalance_1(address _to, uint256 _value) public onlyOwner {\r\n        _transferForLock(_to, _value, 1);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     * Lock time and token by lock_type 2\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferLockBalance_2(address _to, uint256 _value) public onlyOwner {\r\n        _transferForLock(_to, _value, 2);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens\r\n     * Lock time and token by lock_type 3\r\n     *\r\n     * Send `_value` tokens to `_to` from your account\r\n     *\r\n     * @param _to The address of the recipient\r\n     * @param _value the amount to send\r\n     */\r\n    function transferLockBalance_3(address _to, uint256 _value) public onlyOwner {\r\n        _transferForLock(_to, _value, 3);\r\n    }\r\n\r\n    /**\r\n     * Destroy tokens\r\n     *\r\n     * Remove `_value` tokens from the system irreversibly\r\n     *\r\n     * @param _value the amount of money to burn\r\n     */\r\n    function burn(uint256 _value) public onlyOwner {\r\n        _burn(msg.sender, _value);\r\n    }\r\n\r\n    function _burn(address _who, uint256 _value) internal {\r\n        require(_value <= balances[_who]);\r\n        // no need to require value <= totalSupply, since that would imply the\r\n        // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n        balances[_who] = balances[_who].sub(_value);\r\n        totalSupply_ = totalSupply_.sub(_value);\r\n        emit Burn(_who, _value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferLockBalance_1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferLockBalance_2\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"lockAccountInfo\",\"outputs\":[{\"name\":\"lockType\",\"type\":\"uint256\"},{\"name\":\"initBalance\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferLockBalance_3\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"frozenAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"target\",\"type\":\"address\"},{\"name\":\"freeze\",\"type\":\"bool\"}],\"name\":\"freezeAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"initBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lockType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"SetLockData\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"target\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"frozen\",\"type\":\"bool\"}],\"name\":\"FrozenFunds\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ioeXTokenERC20","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://382f432f239366ab587b2d01a7221ae48043284b37b06a7483adbdc1cb0fc449"}]}