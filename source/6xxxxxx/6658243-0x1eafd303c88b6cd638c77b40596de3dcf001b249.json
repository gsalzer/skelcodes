{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n\r\nlibrary Attribute {\r\n  enum AttributeType {\r\n    ROLE_MANAGER,                   // 0\r\n    ROLE_OPERATOR,                  // 1\r\n    IS_BLACKLISTED,                 // 2\r\n    HAS_PASSED_KYC_AML,             // 3\r\n    NO_FEES,                        // 4\r\n    /* Additional user-defined later */\r\n    USER_DEFINED\r\n  }\r\n\r\n  function toUint256(AttributeType _type) internal pure returns (uint256) {\r\n    return uint256(_type);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\nlibrary BitManipulation {\r\n  uint256 constant internal ONE = uint256(1);\r\n\r\n  function setBit(uint256 _num, uint256 _pos) internal pure returns (uint256) {\r\n    return _num | (ONE << _pos);\r\n  }\r\n\r\n  function clearBit(uint256 _num, uint256 _pos) internal pure returns (uint256) {\r\n    return _num & ~(ONE << _pos);\r\n  }\r\n\r\n  function toggleBit(uint256 _num, uint256 _pos) internal pure returns (uint256) {\r\n    return _num ^ (ONE << _pos);\r\n  }\r\n\r\n  function checkBit(uint256 _num, uint256 _pos) internal pure returns (bool) {\r\n    return (_num >> _pos & ONE == ONE);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Claimable\r\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\r\n * This allows the new owner to accept the transfer.\r\n */\r\ncontract Claimable is Ownable {\r\n  address public pendingOwner;\r\n\r\n  /**\r\n   * @dev Modifier throws if called by any account other than the pendingOwner.\r\n   */\r\n  modifier onlyPendingOwner() {\r\n    require(msg.sender == pendingOwner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to set the pendingOwner address.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    pendingOwner = newOwner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the pendingOwner address to finalize the transfer.\r\n   */\r\n  function claimOwnership() public onlyPendingOwner {\r\n    emit OwnershipTransferred(owner, pendingOwner);\r\n    owner = pendingOwner;\r\n    pendingOwner = address(0);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Claimable Ex\r\n * @dev Extension for the Claimable contract, where the ownership transfer can be canceled.\r\n */\r\ncontract ClaimableEx is Claimable {\r\n  /*\r\n   * @dev Cancels the ownership transfer.\r\n   */\r\n  function cancelOwnershipTransfer() onlyOwner public {\r\n    pendingOwner = owner;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this Ether.\r\n * @notice Ether can still be sent to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n */\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  constructor() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by setting a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    owner.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param _token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic _token) external onlyOwner {\r\n    uint256 balance = _token.balanceOf(this);\r\n    _token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Tokens\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\r\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\r\n * owner to reclaim the tokens.\r\n */\r\ncontract HasNoTokens is CanReclaimToken {\r\n\r\n /**\r\n  * @dev Reject all ERC223 compatible tokens\r\n  * @param _from address The address that is transferring the tokens\r\n  * @param _value uint256 the amount of the specified token\r\n  * @param _data Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(\r\n    address _from,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    external\r\n    pure\r\n  {\r\n    _from;\r\n    _value;\r\n    _data;\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param _contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address _contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(_contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Base contract for contracts that should not own things.\r\n * @author Remco Bloemen <remco@2Ï€.com>\r\n * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or\r\n * Owned contracts. See respective base contracts for details.\r\n */\r\ncontract NoOwner is HasNoEther, HasNoTokens, HasNoContracts {\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title NoOwner Ex\r\n * @dev Extension for the NoOwner contract, to support a case where\r\n * this contract's owner can't own ether or tokens.\r\n * Note that we *do* inherit reclaimContract from NoOwner: This contract\r\n * does have to own contracts, but it also has to be able to relinquish them\r\n **/\r\ncontract NoOwnerEx is NoOwner {\r\n  function reclaimEther(address _to) external onlyOwner {\r\n    _to.transfer(address(this).balance);\r\n  }\r\n\r\n  function reclaimToken(ERC20Basic token, address _to) external onlyOwner {\r\n    uint256 balance = token.balanceOf(this);\r\n    token.safeTransfer(_to, balance);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Address Set.\r\n * @dev This contract allows to store addresses in a set and\r\n * owner can run a loop through all elements.\r\n **/\r\ncontract AddressSet is Ownable {\r\n  mapping(address => bool) exist;\r\n  address[] elements;\r\n\r\n  /**\r\n   * @dev Adds a new address to the set.\r\n   * @param _addr Address to add.\r\n   * @return True if succeed, otherwise false.\r\n   */\r\n  function add(address _addr) onlyOwner public returns (bool) {\r\n    if (contains(_addr)) {\r\n      return false;\r\n    }\r\n\r\n    exist[_addr] = true;\r\n    elements.push(_addr);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the set contains a specified address or not.\r\n   * @param _addr Address to check.\r\n   * @return True if the address exists in the set, otherwise false.\r\n   */\r\n  function contains(address _addr) public view returns (bool) {\r\n    return exist[_addr];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets an element at a specified index in the set.\r\n   * @param _index Index.\r\n   * @return A relevant address.\r\n   */\r\n  function elementAt(uint256 _index) onlyOwner public view returns (address) {\r\n    require(_index < elements.length);\r\n\r\n    return elements[_index];\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the number of elements in the set.\r\n   * @return The number of elements.\r\n   */\r\n  function getTheNumberOfElements() onlyOwner public view returns (uint256) {\r\n    return elements.length;\r\n  }\r\n}\r\n\r\n\r\n\r\n// A wrapper around the balances mapping.\r\ncontract BalanceSheet is ClaimableEx {\r\n  using SafeMath for uint256;\r\n\r\n  mapping (address => uint256) private balances;\r\n\r\n  AddressSet private holderSet;\r\n\r\n  constructor() public {\r\n    holderSet = new AddressSet();\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n  function addBalance(address _addr, uint256 _value) public onlyOwner {\r\n    balances[_addr] = balances[_addr].add(_value);\r\n\r\n    _checkHolderSet(_addr);\r\n  }\r\n\r\n  function subBalance(address _addr, uint256 _value) public onlyOwner {\r\n    balances[_addr] = balances[_addr].sub(_value);\r\n  }\r\n\r\n  function setBalance(address _addr, uint256 _value) public onlyOwner {\r\n    balances[_addr] = _value;\r\n\r\n    _checkHolderSet(_addr);\r\n  }\r\n\r\n  function setBalanceBatch(\r\n    address[] _addrs,\r\n    uint256[] _values\r\n  )\r\n    public\r\n    onlyOwner\r\n  {\r\n    uint256 _count = _addrs.length;\r\n    require(_count == _values.length);\r\n\r\n    for(uint256 _i = 0; _i < _count; _i++) {\r\n      setBalance(_addrs[_i], _values[_i]);\r\n    }\r\n  }\r\n\r\n  function getTheNumberOfHolders() public view returns (uint256) {\r\n    return holderSet.getTheNumberOfElements();\r\n  }\r\n\r\n  function getHolder(uint256 _index) public view returns (address) {\r\n    return holderSet.elementAt(_index);\r\n  }\r\n\r\n  function _checkHolderSet(address _addr) internal {\r\n    if (!holderSet.contains(_addr)) {\r\n      holderSet.add(_addr);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * A version of OpenZeppelin's StandardToken whose balances mapping has been replaced\r\n * with a separate BalanceSheet contract. Most useful in combination with e.g.\r\n * HasNoContracts because then it can relinquish its balance sheet to a new\r\n * version of the token, removing the need to copy over balances.\r\n **/\r\ncontract StandardToken is ClaimableEx, NoOwnerEx, ERC20 {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  BalanceSheet private balances;\r\n  event BalanceSheetSet(address indexed sheet);\r\n\r\n  mapping (address => mapping (address => uint256)) private allowed;\r\n\r\n  constructor() public {\r\n    totalSupply_ = 0;\r\n  }\r\n\r\n  /**\r\n   * @dev Total number of tokens in existence\r\n   */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n   * @dev Gets the balance of the specified address.\r\n   * @param _owner The address to query the the balance of.\r\n   * @return An uint256 representing the amount owned by the passed address.\r\n   */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances.balanceOf(_owner);\r\n  }\r\n\r\n  /**\r\n   * @dev Claim ownership of the BalanceSheet contract\r\n   * @param _sheet The address of the BalanceSheet to claim.\r\n   */\r\n  function setBalanceSheet(address _sheet) public onlyOwner returns (bool) {\r\n    balances = BalanceSheet(_sheet);\r\n    balances.claimOwnership();\r\n    emit BalanceSheetSet(_sheet);\r\n    return true;\r\n  }\r\n\r\n  function getTheNumberOfHolders() public view returns (uint256) {\r\n    return balances.getTheNumberOfHolders();\r\n  }\r\n\r\n  function getHolder(uint256 _index) public view returns (address) {\r\n    return balances.getHolder(_index);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer token for a specified address\r\n   * @param _to The address to transfer to.\r\n   * @param _value The amount to be transferred.\r\n   */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    _transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from The address which you want to send tokens from\r\n   * @param _to The address which you want to transfer to\r\n   * @param _value The amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    _transferFrom(_from, _to, _value, msg.sender);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    _approve(_spender, _value, msg.sender);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    _increaseApproval(_spender, _addedValue, msg.sender);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    _decreaseApproval(_spender, _subtractedValue, msg.sender);\r\n    return true;\r\n  }\r\n\r\n  function _approve(\r\n    address _spender,\r\n    uint256 _value,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n  {\r\n    allowed[_tokenHolder][_spender] = _value;\r\n\r\n    emit Approval(_tokenHolder, _spender, _value);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that burns an amount of the token of a given\r\n   * account.\r\n   * @param _burner The account whose tokens will be burnt.\r\n   * @param _value The amount that will be burnt.\r\n   */\r\n  function _burn(address _burner, uint256 _value) internal {\r\n    require(_burner != 0);\r\n    require(_value <= balanceOf(_burner), \"not enough balance to burn\");\r\n\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n    balances.subBalance(_burner, _value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n\r\n    emit Transfer(_burner, address(0), _value);\r\n  }\r\n\r\n  function _decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n  {\r\n    uint256 _oldValue = allowed[_tokenHolder][_spender];\r\n    if (_subtractedValue >= _oldValue) {\r\n      allowed[_tokenHolder][_spender] = 0;\r\n    } else {\r\n      allowed[_tokenHolder][_spender] = _oldValue.sub(_subtractedValue);\r\n    }\r\n\r\n    emit Approval(_tokenHolder, _spender, allowed[_tokenHolder][_spender]);\r\n  }\r\n\r\n  function _increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n  {\r\n    allowed[_tokenHolder][_spender] = (\r\n      allowed[_tokenHolder][_spender].add(_addedValue));\r\n\r\n    emit Approval(_tokenHolder, _spender, allowed[_tokenHolder][_spender]);\r\n  }\r\n\r\n  /**\r\n   * @dev Internal function that mints an amount of the token and assigns it to\r\n   * an account. This encapsulates the modification of balances such that the\r\n   * proper events are emitted.\r\n   * @param _account The account that will receive the created tokens.\r\n   * @param _amount The amount that will be created.\r\n   */\r\n  function _mint(address _account, uint256 _amount) internal {\r\n    require(_account != 0);\r\n\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances.addBalance(_account, _amount);\r\n\r\n    emit Transfer(address(0), _account, _amount);\r\n  }\r\n\r\n  function _transfer(address _from, address _to, uint256 _value) internal {\r\n    require(_to != address(0), \"to address cannot be 0x0\");\r\n    require(_from != address(0),\"from address cannot be 0x0\");\r\n    require(_value <= balanceOf(_from), \"not enough balance to transfer\");\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances.subBalance(_from, _value);\r\n    balances.addBalance(_to, _value);\r\n\r\n    emit Transfer(_from, _to, _value);\r\n  }\r\n\r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    address _spender\r\n  )\r\n    internal\r\n  {\r\n    uint256 _allowed = allowed[_from][_spender];\r\n    require(_value <= _allowed, \"not enough allowance to transfer\");\r\n\r\n    allowed[_from][_spender] = allowed[_from][_spender].sub(_value);\r\n    _transfer(_from, _to, _value);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n **/\r\ncontract BurnableToken is StandardToken {\r\n  event Burn(address indexed burner, uint256 value, string note);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   * @param _note a note that burner can attach.\r\n   */\r\n  function burn(uint256 _value, string _note) public returns (bool) {\r\n    _burn(msg.sender, _value, _note);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens of an user.\r\n   * @param _burner Who has tokens to be burned.\r\n   * @param _value The amount of tokens to be burned.\r\n   * @param _note a note that the manager can attach.\r\n   */\r\n  function _burn(\r\n    address _burner,\r\n    uint256 _value,\r\n    string _note\r\n  )\r\n    internal\r\n  {\r\n    _burn(_burner, _value);\r\n\r\n    emit Burn(_burner, _value, _note);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Interface for logic governing write access to a Registry.\r\ncontract RegistryAccessManager {\r\n  // Called when _admin attempts to write _value for _who's _attribute.\r\n  // Returns true if the write is allowed to proceed.\r\n  function confirmWrite(\r\n    address _who,\r\n    Attribute.AttributeType _attribute,\r\n    address _admin\r\n  )\r\n    public returns (bool);\r\n}\r\n\r\n\r\n\r\ncontract DefaultRegistryAccessManager is RegistryAccessManager {\r\n  function confirmWrite(\r\n    address /*_who*/,\r\n    Attribute.AttributeType _attribute,\r\n    address _operator\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    Registry _client = Registry(msg.sender);\r\n    if (_operator == _client.owner()) {\r\n      return true;\r\n    } else if (_client.hasAttribute(_operator, Attribute.AttributeType.ROLE_MANAGER)) {\r\n      return (_attribute == Attribute.AttributeType.ROLE_OPERATOR);\r\n    } else if (_client.hasAttribute(_operator, Attribute.AttributeType.ROLE_OPERATOR)) {\r\n      return (_attribute != Attribute.AttributeType.ROLE_OPERATOR &&\r\n              _attribute != Attribute.AttributeType.ROLE_MANAGER);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ncontract Registry is ClaimableEx {\r\n  using BitManipulation for uint256;\r\n\r\n  struct AttributeData {\r\n    uint256 value;\r\n  }\r\n\r\n  // Stores arbitrary attributes for users. An example use case is an ERC20\r\n  // token that requires its users to go through a KYC/AML check - in this case\r\n  // a validator can set an account's \"hasPassedKYC/AML\" attribute to 1 to indicate\r\n  // that account can use the token. This mapping stores that value (1, in the\r\n  // example) as well as which validator last set the value and at what time,\r\n  // so that e.g. the check can be renewed at appropriate intervals.\r\n  mapping(address => AttributeData) private attributes;\r\n\r\n  // The logic governing who is allowed to set what attributes is abstracted as\r\n  // this accessManager, so that it may be replaced by the owner as needed.\r\n  RegistryAccessManager public accessManager;\r\n\r\n  event SetAttribute(\r\n    address indexed who,\r\n    Attribute.AttributeType attribute,\r\n    bool enable,\r\n    string notes,\r\n    address indexed adminAddr\r\n  );\r\n\r\n  event SetManager(\r\n    address indexed oldManager,\r\n    address indexed newManager\r\n  );\r\n\r\n  constructor() public {\r\n    accessManager = new DefaultRegistryAccessManager();\r\n  }\r\n\r\n  // Writes are allowed only if the accessManager approves\r\n  function setAttribute(\r\n    address _who,\r\n    Attribute.AttributeType _attribute,\r\n    string _notes\r\n  )\r\n    public\r\n  {\r\n    bool _canWrite = accessManager.confirmWrite(\r\n      _who,\r\n      _attribute,\r\n      msg.sender\r\n    );\r\n    require(_canWrite);\r\n\r\n    // Get value of previous attribute before setting new attribute\r\n    uint256 _tempVal = attributes[_who].value;\r\n\r\n    attributes[_who] = AttributeData(\r\n      _tempVal.setBit(Attribute.toUint256(_attribute))\r\n    );\r\n\r\n    emit SetAttribute(_who, _attribute, true, _notes, msg.sender);\r\n  }\r\n\r\n  function clearAttribute(\r\n    address _who,\r\n    Attribute.AttributeType _attribute,\r\n    string _notes\r\n  )\r\n    public\r\n  {\r\n    bool _canWrite = accessManager.confirmWrite(\r\n      _who,\r\n      _attribute,\r\n      msg.sender\r\n    );\r\n    require(_canWrite);\r\n\r\n    // Get value of previous attribute before setting new attribute\r\n    uint256 _tempVal = attributes[_who].value;\r\n\r\n    attributes[_who] = AttributeData(\r\n      _tempVal.clearBit(Attribute.toUint256(_attribute))\r\n    );\r\n\r\n    emit SetAttribute(_who, _attribute, false, _notes, msg.sender);\r\n  }\r\n\r\n  // Returns true if the uint256 value stored for this attribute is non-zero\r\n  function hasAttribute(\r\n    address _who,\r\n    Attribute.AttributeType _attribute\r\n  )\r\n    public\r\n    view\r\n    returns (bool)\r\n  {\r\n    return attributes[_who].value.checkBit(Attribute.toUint256(_attribute));\r\n  }\r\n\r\n  // Returns the exact value of the attribute, as well as its metadata\r\n  function getAttributes(\r\n    address _who\r\n  )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    AttributeData memory _data = attributes[_who];\r\n    return _data.value;\r\n  }\r\n\r\n  function setManager(RegistryAccessManager _accessManager) public onlyOwner {\r\n    emit SetManager(accessManager, _accessManager);\r\n    accessManager = _accessManager;\r\n  }\r\n}\r\n\r\n\r\n\r\n// Superclass for contracts that have a registry that can be set by their owners\r\ncontract HasRegistry is Ownable {\r\n  Registry public registry;\r\n\r\n  event SetRegistry(address indexed registry);\r\n\r\n  function setRegistry(Registry _registry) public onlyOwner {\r\n    registry = _registry;\r\n    emit SetRegistry(registry);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Manageable\r\n * @dev The Manageable contract provides basic authorization control functions\r\n * for managers. This simplifies the implementation of \"manager permissions\".\r\n */\r\ncontract Manageable is HasRegistry {\r\n  /**\r\n   * @dev Throws if called by any account that is not in the managers list.\r\n   */\r\n  modifier onlyManager() {\r\n    require(\r\n      registry.hasAttribute(\r\n        msg.sender,\r\n        Attribute.AttributeType.ROLE_MANAGER\r\n      )\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Getter to determine if address is a manager\r\n   */\r\n  function isManager(address _operator) public view returns (bool) {\r\n    return registry.hasAttribute(\r\n      _operator,\r\n      Attribute.AttributeType.ROLE_MANAGER\r\n    );\r\n  }\r\n}\r\n\r\n\r\n\r\n// Interface implemented by tokens that are the *target* of a BurnableToken's\r\n// delegation. That is, if we want to replace BurnableToken X by\r\n// Y but for convenience we'd like users of X\r\n// to be able to keep using it and it will just forward calls to Y,\r\n// then X should extend CanDelegate and Y should extend DelegateBurnable.\r\n// Most ERC20 calls use the value of msg.sender to figure out e.g. whose\r\n// balance to update; since X becomes the msg.sender of all such calls\r\n// that it forwards to Y, we add the origSender parameter to those calls.\r\n// Delegation is intended as a convenience for legacy users of X since\r\n// we do not expect all regular users to learn about Y and change accordingly,\r\n// but we do require the *owner* of X to now use Y instead so ownerOnly\r\n// functions are not delegated and should be disabled instead.\r\n// This delegation system is intended to work with the modified versions of\r\n// the standard ERC20 token contracts, allowing the balances\r\n// to be moved over to a new contract.\r\n// NOTE: To maintain backwards compatibility, these function signatures\r\n// cannot be changed\r\ncontract DelegateBurnable {\r\n  function delegateTotalSupply() public view returns (uint256);\r\n\r\n  function delegateBalanceOf(address _who) public view returns (uint256);\r\n\r\n  function delegateTransfer(address _to, uint256 _value, address _origSender)\r\n    public returns (bool);\r\n\r\n  function delegateAllowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function delegateTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    address _origSender\r\n  )\r\n    public returns (bool);\r\n\r\n  function delegateApprove(\r\n    address _spender,\r\n    uint256 _value,\r\n    address _origSender\r\n  )\r\n    public returns (bool);\r\n\r\n  function delegateIncreaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue,\r\n    address _origSender\r\n  )\r\n    public returns (bool);\r\n\r\n  function delegateDecreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue,\r\n    address _origSender\r\n  )\r\n    public returns (bool);\r\n\r\n  function delegateBurn(\r\n    address _origSender,\r\n    uint256 _value,\r\n    string _note\r\n  )\r\n    public;\r\n\r\n  function delegateGetTheNumberOfHolders() public view returns (uint256);\r\n\r\n  function delegateGetHolder(uint256 _index) public view returns (address);\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Contactable token\r\n * @dev Basic version of a contactable contract, allowing the owner to provide a string with their\r\n * contact information.\r\n */\r\ncontract Contactable is Ownable {\r\n\r\n  string public contactInformation;\r\n\r\n  /**\r\n    * @dev Allows the owner to set a string with their contact information.\r\n    * @param _info The contact information to attach to the contract.\r\n    */\r\n  function setContactInformation(string _info) public onlyOwner {\r\n    contactInformation = _info;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function _transfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n    whenNotPaused\r\n  {\r\n    super._transfer(_from, _to, _value);\r\n  }\r\n\r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    address _spender\r\n  )\r\n    internal\r\n    whenNotPaused\r\n  {\r\n    super._transferFrom(_from, _to, _value, _spender);\r\n  }\r\n\r\n  function _approve(\r\n    address _spender,\r\n    uint256 _value,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n    whenNotPaused\r\n  {\r\n    super._approve(_spender, _value, _tokenHolder);\r\n  }\r\n\r\n  function _increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n    whenNotPaused\r\n  {\r\n    super._increaseApproval(_spender, _addedValue, _tokenHolder);\r\n  }\r\n\r\n  function _decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n    whenNotPaused\r\n  {\r\n    super._decreaseApproval(_spender, _subtractedValue, _tokenHolder);\r\n  }\r\n\r\n  function _burn(\r\n    address _burner,\r\n    uint256 _value\r\n  )\r\n    internal\r\n    whenNotPaused\r\n  {\r\n    super._burn(_burner, _value);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// See DelegateBurnable.sol for more on the delegation system.\r\ncontract CanDelegateToken is BurnableToken {\r\n  // If this contract needs to be upgraded, the new contract will be stored\r\n  // in 'delegate' and any BurnableToken calls to this contract will be delegated to that one.\r\n  DelegateBurnable public delegate;\r\n\r\n  event DelegateToNewContract(address indexed newContract);\r\n\r\n  // Can undelegate by passing in _newContract = address(0)\r\n  function delegateToNewContract(\r\n    DelegateBurnable _newContract\r\n  )\r\n    public\r\n    onlyOwner\r\n  {\r\n    delegate = _newContract;\r\n    emit DelegateToNewContract(delegate);\r\n  }\r\n\r\n  // If a delegate has been designated, all ERC20 calls are forwarded to it\r\n  function _transfer(address _from, address _to, uint256 _value) internal {\r\n    if (!_hasDelegate()) {\r\n      super._transfer(_from, _to, _value);\r\n    } else {\r\n      require(delegate.delegateTransfer(_to, _value, _from));\r\n    }\r\n  }\r\n\r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    address _spender\r\n  )\r\n    internal\r\n  {\r\n    if (!_hasDelegate()) {\r\n      super._transferFrom(_from, _to, _value, _spender);\r\n    } else {\r\n      require(delegate.delegateTransferFrom(_from, _to, _value, _spender));\r\n    }\r\n  }\r\n\r\n  function totalSupply() public view returns (uint256) {\r\n    if (!_hasDelegate()) {\r\n      return super.totalSupply();\r\n    } else {\r\n      return delegate.delegateTotalSupply();\r\n    }\r\n  }\r\n\r\n  function balanceOf(address _who) public view returns (uint256) {\r\n    if (!_hasDelegate()) {\r\n      return super.balanceOf(_who);\r\n    } else {\r\n      return delegate.delegateBalanceOf(_who);\r\n    }\r\n  }\r\n\r\n  function getTheNumberOfHolders() public view returns (uint256) {\r\n    if (!_hasDelegate()) {\r\n      return super.getTheNumberOfHolders();\r\n    } else {\r\n      return delegate.delegateGetTheNumberOfHolders();\r\n    }\r\n  }\r\n\r\n  function getHolder(uint256 _index) public view returns (address) {\r\n    if (!_hasDelegate()) {\r\n      return super.getHolder(_index);\r\n    } else {\r\n      return delegate.delegateGetHolder(_index);\r\n    }\r\n  }\r\n\r\n  function _approve(\r\n    address _spender,\r\n    uint256 _value,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n  {\r\n    if (!_hasDelegate()) {\r\n      super._approve(_spender, _value, _tokenHolder);\r\n    } else {\r\n      require(delegate.delegateApprove(_spender, _value, _tokenHolder));\r\n    }\r\n  }\r\n\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    if (!_hasDelegate()) {\r\n      return super.allowance(_owner, _spender);\r\n    } else {\r\n      return delegate.delegateAllowance(_owner, _spender);\r\n    }\r\n  }\r\n\r\n  function _increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n  {\r\n    if (!_hasDelegate()) {\r\n      super._increaseApproval(_spender, _addedValue, _tokenHolder);\r\n    } else {\r\n      require(\r\n        delegate.delegateIncreaseApproval(_spender, _addedValue, _tokenHolder)\r\n      );\r\n    }\r\n  }\r\n\r\n  function _decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue,\r\n    address _tokenHolder\r\n  )\r\n    internal\r\n  {\r\n    if (!_hasDelegate()) {\r\n      super._decreaseApproval(_spender, _subtractedValue, _tokenHolder);\r\n    } else {\r\n      require(\r\n        delegate.delegateDecreaseApproval(\r\n          _spender,\r\n          _subtractedValue,\r\n          _tokenHolder)\r\n      );\r\n    }\r\n  }\r\n\r\n  function _burn(address _burner, uint256 _value, string _note) internal {\r\n    if (!_hasDelegate()) {\r\n      super._burn(_burner, _value, _note);\r\n    } else {\r\n      delegate.delegateBurn(_burner, _value , _note);\r\n    }\r\n  }\r\n\r\n  function _hasDelegate() internal view returns (bool) {\r\n    return !(delegate == address(0));\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n// Treats all delegate functions exactly like the corresponding normal functions,\r\n// e.g. delegateTransfer is just like transfer. See DelegateBurnable.sol for more on\r\n// the delegation system.\r\ncontract DelegateToken is DelegateBurnable, BurnableToken {\r\n  address public delegatedFrom;\r\n\r\n  event DelegatedFromSet(address addr);\r\n\r\n  // Only calls from appointed address will be processed\r\n  modifier onlyMandator() {\r\n    require(msg.sender == delegatedFrom);\r\n    _;\r\n  }\r\n\r\n  function setDelegatedFrom(address _addr) public onlyOwner {\r\n    delegatedFrom = _addr;\r\n    emit DelegatedFromSet(_addr);\r\n  }\r\n\r\n  // each function delegateX is simply forwarded to function X\r\n  function delegateTotalSupply(\r\n  )\r\n    public\r\n    onlyMandator\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return totalSupply();\r\n  }\r\n\r\n  function delegateBalanceOf(\r\n    address _who\r\n  )\r\n    public\r\n    onlyMandator\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return balanceOf(_who);\r\n  }\r\n\r\n  function delegateTransfer(\r\n    address _to,\r\n    uint256 _value,\r\n    address _origSender\r\n  )\r\n    public\r\n    onlyMandator\r\n    returns (bool)\r\n  {\r\n    _transfer(_origSender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  function delegateAllowance(\r\n    address _owner,\r\n    address _spender\r\n  )\r\n    public\r\n    onlyMandator\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowance(_owner, _spender);\r\n  }\r\n\r\n  function delegateTransferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    address _origSender\r\n  )\r\n    public\r\n    onlyMandator\r\n    returns (bool)\r\n  {\r\n    _transferFrom(_from, _to, _value, _origSender);\r\n    return true;\r\n  }\r\n\r\n  function delegateApprove(\r\n    address _spender,\r\n    uint256 _value,\r\n    address _origSender\r\n  )\r\n    public\r\n    onlyMandator\r\n    returns (bool)\r\n  {\r\n    _approve(_spender, _value, _origSender);\r\n    return true;\r\n  }\r\n\r\n  function delegateIncreaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue,\r\n    address _origSender\r\n  )\r\n    public\r\n    onlyMandator\r\n    returns (bool)\r\n  {\r\n    _increaseApproval(_spender, _addedValue, _origSender);\r\n    return true;\r\n  }\r\n\r\n  function delegateDecreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue,\r\n    address _origSender\r\n  )\r\n    public\r\n    onlyMandator\r\n    returns (bool)\r\n  {\r\n    _decreaseApproval(_spender, _subtractedValue, _origSender);\r\n    return true;\r\n  }\r\n\r\n  function delegateBurn(\r\n    address _origSender,\r\n    uint256 _value,\r\n    string _note\r\n  )\r\n    public\r\n    onlyMandator\r\n  {\r\n    _burn(_origSender, _value , _note);\r\n  }\r\n\r\n  function delegateGetTheNumberOfHolders() public view returns (uint256) {\r\n    return getTheNumberOfHolders();\r\n  }\r\n\r\n  function delegateGetHolder(uint256 _index) public view returns (address) {\r\n    return getHolder(_index);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Asset information.\r\n * @dev Stores information about a specified real asset.\r\n */\r\ncontract AssetInfo is Manageable {\r\n  string public publicDocument;\r\n\r\n  /**\r\n   * Event for updated running documents logging.\r\n   * @param newLink New link.\r\n   */\r\n  event UpdateDocument(\r\n    string newLink\r\n  );\r\n\r\n  /**\r\n   * @param _publicDocument A link to a zip file containing running documents of the asset.\r\n   */\r\n  constructor(string _publicDocument) public {\r\n    publicDocument = _publicDocument;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates information about where to find new running documents of this asset.\r\n   * @param _link A link to a zip file containing running documents of the asset.\r\n   */\r\n  function setPublicDocument(string _link) public onlyManager {\r\n    publicDocument = _link;\r\n\r\n    emit UpdateDocument(publicDocument);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title BurnableExToken.\r\n * @dev Extension for the BurnableToken contract, to support\r\n * some manager to enforce burning all tokens of all holders.\r\n **/\r\ncontract BurnableExToken is Manageable, BurnableToken {\r\n\r\n  /**\r\n   * @dev Burns all remaining tokens of all holders.\r\n   * @param _note a note that the manager can attach.\r\n   */\r\n  function burnAll(string _note) external onlyManager {\r\n    uint256 _holdersCount = getTheNumberOfHolders();\r\n    for (uint256 _i = 0; _i < _holdersCount; ++_i) {\r\n      address _holder = getHolder(_i);\r\n      uint256 _balance = balanceOf(_holder);\r\n      if (_balance == 0) continue;\r\n\r\n      _burn(_holder, _balance, _note);\r\n    }\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n **/\r\ncontract MintableToken is StandardToken {\r\n  event Mint(address indexed to, uint256 value);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _value The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    hasMintPermission\r\n    canMint\r\n    returns (bool)\r\n  {\r\n    _mint(_to, _value);\r\n\r\n    emit Mint(_to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() public onlyOwner canMint returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\ncontract CompliantToken is HasRegistry, MintableToken {\r\n  // Addresses can also be blacklisted, preventing them from sending or receiving\r\n  // PAT tokens. This can be used to prevent the use of PAT by bad actors in\r\n  // accordance with law enforcement.\r\n\r\n  modifier onlyIfNotBlacklisted(address _addr) {\r\n    require(\r\n      !registry.hasAttribute(\r\n        _addr,\r\n        Attribute.AttributeType.IS_BLACKLISTED\r\n      )\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyIfBlacklisted(address _addr) {\r\n    require(\r\n      registry.hasAttribute(\r\n        _addr,\r\n        Attribute.AttributeType.IS_BLACKLISTED\r\n      )\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier onlyIfPassedKYC_AML(address _addr) {\r\n    require(\r\n      registry.hasAttribute(\r\n        _addr,\r\n        Attribute.AttributeType.HAS_PASSED_KYC_AML\r\n      )\r\n    );\r\n    _;\r\n  }\r\n\r\n  function _mint(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n    onlyIfPassedKYC_AML(_to)\r\n    onlyIfNotBlacklisted(_to)\r\n  {\r\n    super._mint(_to, _value);\r\n  }\r\n\r\n  // transfer and transferFrom both call this function, so check blacklist here.\r\n  function _transfer(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n    onlyIfNotBlacklisted(_from)\r\n    onlyIfNotBlacklisted(_to)\r\n    onlyIfPassedKYC_AML(_to)\r\n  {\r\n    super._transfer(_from, _to, _value);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title TokenWithFees.\r\n * @dev This contract allows for transaction fees to be assessed on transfer.\r\n **/\r\ncontract TokenWithFees is Manageable, StandardToken {\r\n  uint8 public transferFeeNumerator = 0;\r\n  uint8 public transferFeeDenominator = 100;\r\n  // All transaction fees are paid to this address.\r\n  address public beneficiary;\r\n\r\n  event ChangeWallet(address indexed addr);\r\n  event ChangeFees(uint8 transferFeeNumerator,\r\n                   uint8 transferFeeDenominator);\r\n\r\n  constructor(address _wallet) public {\r\n    beneficiary = _wallet;\r\n  }\r\n\r\n  // transfer and transferFrom both call this function, so pay fee here.\r\n  // E.g. if A transfers 1000 tokens to B, B will receive 999 tokens,\r\n  // and the system wallet will receive 1 token.\r\n  function _transfer(address _from, address _to, uint256 _value) internal {\r\n    uint256 _fee = _payFee(_from, _value, _to);\r\n    uint256 _remaining = _value.sub(_fee);\r\n    super._transfer(_from, _to, _remaining);\r\n  }\r\n\r\n  function _payFee(\r\n    address _payer,\r\n    uint256 _value,\r\n    address _otherParticipant\r\n  )\r\n    internal\r\n    returns (uint256)\r\n  {\r\n    // This check allows accounts to be whitelisted and not have to pay transaction fees.\r\n    bool _shouldBeFree = (\r\n      registry.hasAttribute(_payer, Attribute.AttributeType.NO_FEES) ||\r\n      registry.hasAttribute(_otherParticipant, Attribute.AttributeType.NO_FEES)\r\n    );\r\n    if (_shouldBeFree) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 _fee = _value.mul(transferFeeNumerator).div(transferFeeDenominator);\r\n    if (_fee > 0) {\r\n      super._transfer(_payer, beneficiary, _fee);\r\n    }\r\n    return _fee;\r\n  }\r\n\r\n  function checkTransferFee(uint256 _value) public view returns (uint256) {\r\n    return _value.mul(transferFeeNumerator).div(transferFeeDenominator);\r\n  }\r\n\r\n  function changeFees(\r\n    uint8 _transferFeeNumerator,\r\n    uint8 _transferFeeDenominator\r\n  )\r\n    public\r\n    onlyManager\r\n  {\r\n    require(_transferFeeNumerator < _transferFeeDenominator);\r\n    transferFeeNumerator = _transferFeeNumerator;\r\n    transferFeeDenominator = _transferFeeDenominator;\r\n\r\n    emit ChangeFees(transferFeeNumerator, transferFeeDenominator);\r\n  }\r\n\r\n  /**\r\n   * @dev Change address of the wallet where the fees will be sent to.\r\n   * @param _beneficiary The new wallet address.\r\n   */\r\n  function changeWallet(address _beneficiary) public onlyManager {\r\n    require(_beneficiary != address(0), \"new wallet cannot be 0x0\");\r\n    beneficiary = _beneficiary;\r\n\r\n    emit ChangeWallet(_beneficiary);\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n// This allows a token to treat transfer(redeemAddress, value) as burn(value).\r\n// This is useful for users of standard wallet programs which have transfer\r\n// functionality built in but not the ability to burn.\r\ncontract WithdrawalToken is BurnableToken {\r\n  address public constant redeemAddress = 0xfacecafe01facecafe02facecafe03facecafe04;\r\n\r\n  function _transfer(address _from, address _to, uint256 _value) internal {\r\n    if (_to == redeemAddress) {\r\n      burn(_value, '');\r\n    } else {\r\n      super._transfer(_from, _to, _value);\r\n    }\r\n  }\r\n\r\n  // StandardToken's transferFrom doesn't have to check for _to != redeemAddress,\r\n  // but we do because we redirect redeemAddress transfers to burns, but\r\n  // we do not redirect transferFrom\r\n  function _transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value,\r\n    address _spender\r\n  ) internal {\r\n    require(_to != redeemAddress, \"_to is redeem address\");\r\n\r\n    super._transferFrom(_from, _to, _value, _spender);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title PAT token.\r\n * @dev PAT is a ERC20 token that:\r\n *  - has no tokens limit.\r\n *  - mints new tokens for each new property (real asset).\r\n *  - can pause and unpause token transfer (and authorization) actions.\r\n *  - token holders can be distributed profit from asset manager.\r\n *  - contains real asset information.\r\n *  - can delegate to a new contract.\r\n *  - can enforce burning all tokens.\r\n *  - transferring tokens to 0x0 address is treated as burning.\r\n *  - transferring tokens with fees are sent to the system wallet.\r\n *  - attempts to check KYC/AML and Blacklist using Registry.\r\n *  - attempts to reject ERC20 token transfers to itself and allows token transfer out.\r\n *  - attempts to reject ether sent and allows any ether held to be transferred out.\r\n *  - allows the new owner to accept the ownership transfer, the owner can cancel the transfer if needed.\r\n **/\r\ncontract PATToken is Contactable, AssetInfo, BurnableExToken, CanDelegateToken, DelegateToken, TokenWithFees, CompliantToken, WithdrawalToken, PausableToken {\r\n  string public name = \"RAX Mt.Fuji\";\r\n  string public symbol = \"FUJI\";\r\n  uint8 public constant decimals = 18;\r\n\r\n  event ChangeTokenName(string newName, string newSymbol);\r\n\r\n  /**\r\n   * @param _name Name of this token.\r\n   * @param _symbol Symbol of this token.\r\n   */\r\n  constructor(\r\n    string _name,\r\n    string _symbol,\r\n    string _publicDocument,\r\n    address _wallet\r\n  )\r\n    public\r\n    AssetInfo(_publicDocument)\r\n    TokenWithFees(_wallet)\r\n  {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    contactInformation = 'https://rax.exchange/';\r\n  }\r\n\r\n  function changeTokenName(string _name, string _symbol) public onlyOwner {\r\n    name = _name;\r\n    symbol = _symbol;\r\n    emit ChangeTokenName(_name, _symbol);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a new owner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) onlyOwner public {\r\n    // do not allow self ownership\r\n    require(_newOwner != address(this));\r\n    super.transferOwnership(_newOwner);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"mintingFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegateGetTheNumberOfHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"delegateAllowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newContract\",\"type\":\"address\"}],\"name\":\"delegateToNewContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"delegateGetHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancelOwnershipTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"redeemAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegatedFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_origSender\",\"type\":\"address\"}],\"name\":\"delegateApprove\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddr\",\"type\":\"address\"}],\"name\":\"reclaimContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contactInformation\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"delegateBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"changeTokenName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_origSender\",\"type\":\"address\"}],\"name\":\"delegateTransferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sheet\",\"type\":\"address\"}],\"name\":\"setBalanceSheet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"},{\"name\":\"_origSender\",\"type\":\"address\"}],\"name\":\"delegateIncreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setDelegatedFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTheNumberOfHolders\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_origSender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_note\",\"type\":\"string\"}],\"name\":\"delegateBurn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_who\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_note\",\"type\":\"string\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegateTotalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_note\",\"type\":\"string\"}],\"name\":\"burnAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMinting\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"checkTransferFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"reclaimToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeNumerator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"},{\"name\":\"_origSender\",\"type\":\"address\"}],\"name\":\"delegateDecreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"changeWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_origSender\",\"type\":\"address\"}],\"name\":\"delegateTransfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_link\",\"type\":\"string\"}],\"name\":\"setPublicDocument\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"}],\"name\":\"setRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_transferFeeNumerator\",\"type\":\"uint8\"},{\"name\":\"_transferFeeDenominator\",\"type\":\"uint8\"}],\"name\":\"changeFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_info\",\"type\":\"string\"}],\"name\":\"setContactInformation\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"delegate\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transferFeeDenominator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicDocument\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isManager\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_symbol\",\"type\":\"string\"},{\"name\":\"_publicDocument\",\"type\":\"string\"},{\"name\":\"_wallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"newSymbol\",\"type\":\"string\"}],\"name\":\"ChangeTokenName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"MintFinished\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"ChangeWallet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"transferFeeNumerator\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"transferFeeDenominator\",\"type\":\"uint8\"}],\"name\":\"ChangeFees\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"DelegatedFromSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"DelegateToNewContract\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"burner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"note\",\"type\":\"string\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sheet\",\"type\":\"address\"}],\"name\":\"BalanceSheetSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newLink\",\"type\":\"string\"}],\"name\":\"UpdateDocument\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"registry\",\"type\":\"address\"}],\"name\":\"SetRegistry\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"PATToken","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000ee2eb910f1adeeb1df99d4f07a014f483072c377000000000000000000000000000000000000000000000000000000000000000946554a49546f6b656e0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000446554a4900000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001b68747470733a2f2f74696e7975726c2e636f6d2f52415846756a690000000000","Library":"","SwarmSource":"bzzr://170a0f6e2eca196109e223da4d49afe9e9b41d2e0a14ab68d3b60d875b80a535"}]}