{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n  Zethr | https://zethr.io\r\n  (c) Copyright 2018 | All Rights Reserved\r\n  This smart contract was developed by the Zethr Dev Team and its source code remains property of the Zethr Project.\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\n// File: contracts/Libraries/SafeMath.sol\r\n\r\nlibrary SafeMath {\r\n  function mul(uint a, uint b) internal pure returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint a, uint b) internal pure returns (uint) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/Libraries/ZethrTierLibrary.sol\r\n\r\nlibrary ZethrTierLibrary {\r\n  uint constant internal magnitude = 2 ** 64;\r\n\r\n  // Gets the tier (1-7) of the divs sent based off of average dividend rate\r\n  // This is an index used to call into the correct sub-bankroll to withdraw tokens\r\n  function getTier(uint divRate) internal pure returns (uint8) {\r\n\r\n    // Divide the average dividned rate by magnitude\r\n    // Remainder doesn't matter because of the below logic\r\n    uint actualDiv = divRate / magnitude;\r\n    if (actualDiv >= 30) {\r\n      return 6;\r\n    } else if (actualDiv >= 25) {\r\n      return 5;\r\n    } else if (actualDiv >= 20) {\r\n      return 4;\r\n    } else if (actualDiv >= 15) {\r\n      return 3;\r\n    } else if (actualDiv >= 10) {\r\n      return 2;\r\n    } else if (actualDiv >= 5) {\r\n      return 1;\r\n    } else if (actualDiv >= 2) {\r\n      return 0;\r\n    } else {\r\n      // Impossible\r\n      revert();\r\n    }\r\n  }\r\n\r\n  function getDivRate(uint _tier)\r\n  internal pure\r\n  returns (uint8)\r\n  {\r\n    if (_tier == 0) {\r\n      return 2;\r\n    } else if (_tier == 1) {\r\n      return 5;\r\n    } else if (_tier == 2) {\r\n      return 10;\r\n    } else if (_tier == 3) {\r\n      return 15;\r\n    } else if (_tier == 4) {\r\n      return 20;\r\n    } else if (_tier == 5) {\r\n      return 25;\r\n    } else if (_tier == 6) {\r\n      return 33;\r\n    } else {\r\n      revert();\r\n    }\r\n  }\r\n}\r\n\r\n// File: contracts/ERC/ERC223Receiving.sol\r\n\r\ncontract ERC223Receiving {\r\n  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\r\n}\r\n\r\n// File: contracts/ZethrMultiSigWallet.sol\r\n\r\n/* Zethr MultisigWallet\r\n *\r\n * Standard multisig wallet\r\n * Holds the bankroll ETH, as well as the bankroll 33% ZTH tokens.\r\n*/ \r\ncontract ZethrMultiSigWallet is ERC223Receiving {\r\n  using SafeMath for uint;\r\n\r\n  /*=================================\r\n  =              EVENTS            =\r\n  =================================*/\r\n\r\n  event Confirmation(address indexed sender, uint indexed transactionId);\r\n  event Revocation(address indexed sender, uint indexed transactionId);\r\n  event Submission(uint indexed transactionId);\r\n  event Execution(uint indexed transactionId);\r\n  event ExecutionFailure(uint indexed transactionId);\r\n  event Deposit(address indexed sender, uint value);\r\n  event OwnerAddition(address indexed owner);\r\n  event OwnerRemoval(address indexed owner);\r\n  event WhiteListAddition(address indexed contractAddress);\r\n  event WhiteListRemoval(address indexed contractAddress);\r\n  event RequirementChange(uint required);\r\n  event BankrollInvest(uint amountReceived);\r\n\r\n  /*=================================\r\n  =             VARIABLES           =\r\n  =================================*/\r\n\r\n  mapping (uint => Transaction) public transactions;\r\n  mapping (uint => mapping (address => bool)) public confirmations;\r\n  mapping (address => bool) public isOwner;\r\n  address[] public owners;\r\n  uint public required;\r\n  uint public transactionCount;\r\n  bool internal reEntered = false;\r\n  uint constant public MAX_OWNER_COUNT = 15;\r\n\r\n  /*=================================\r\n  =         CUSTOM CONSTRUCTS       =\r\n  =================================*/\r\n\r\n  struct Transaction {\r\n    address destination;\r\n    uint value;\r\n    bytes data;\r\n    bool executed;\r\n  }\r\n\r\n  struct TKN {\r\n    address sender;\r\n    uint value;\r\n  }\r\n\r\n  /*=================================\r\n  =            MODIFIERS            =\r\n  =================================*/\r\n\r\n  modifier onlyWallet() {\r\n    if (msg.sender != address(this))\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier isAnOwner() {\r\n    address caller = msg.sender;\r\n    if (isOwner[caller])\r\n      _;\r\n    else\r\n      revert();\r\n  }\r\n\r\n  modifier ownerDoesNotExist(address owner) {\r\n    if (isOwner[owner]) \r\n      revert();\r\n      _;\r\n  }\r\n\r\n  modifier ownerExists(address owner) {\r\n    if (!isOwner[owner])\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier transactionExists(uint transactionId) {\r\n    if (transactions[transactionId].destination == 0)\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier confirmed(uint transactionId, address owner) {\r\n    if (!confirmations[transactionId][owner])\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier notConfirmed(uint transactionId, address owner) {\r\n    if (confirmations[transactionId][owner])\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier notExecuted(uint transactionId) {\r\n    if (transactions[transactionId].executed)\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier notNull(address _address) {\r\n    if (_address == 0)\r\n      revert();\r\n    _;\r\n  }\r\n\r\n  modifier validRequirement(uint ownerCount, uint _required) {\r\n    if ( ownerCount > MAX_OWNER_COUNT\r\n      || _required > ownerCount\r\n      || _required == 0\r\n      || ownerCount == 0)\r\n      revert();\r\n    _;\r\n  }\r\n\r\n\r\n  /*=================================\r\n  =         PUBLIC FUNCTIONS        =\r\n  =================================*/\r\n\r\n  /// @dev Contract constructor sets initial owners and required number of confirmations.\r\n  /// @param _owners List of initial owners.\r\n  /// @param _required Number of required confirmations.\r\n  constructor (address[] _owners, uint _required)\r\n    public\r\n    validRequirement(_owners.length, _required)\r\n  {\r\n    // Add owners\r\n    for (uint i=0; i<_owners.length; i++) {\r\n      if (isOwner[_owners[i]] || _owners[i] == 0)\r\n        revert();\r\n      isOwner[_owners[i]] = true;\r\n    }\r\n\r\n    // Set owners\r\n    owners = _owners;\r\n\r\n    // Set required\r\n    required = _required;\r\n  }\r\n\r\n  /** Testing only.\r\n  function exitAll()\r\n    public\r\n  {\r\n    uint tokenBalance = ZTHTKN.balanceOf(address(this));\r\n    ZTHTKN.sell(tokenBalance - 1e18);\r\n    ZTHTKN.sell(1e18);\r\n    ZTHTKN.withdraw(address(0x0));\r\n  }\r\n  **/\r\n\r\n  /// @dev Fallback function allows Ether to be deposited.\r\n  function()\r\n    public\r\n    payable\r\n  {\r\n\r\n  }\r\n    \r\n  /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\r\n  /// @param owner Address of new owner.\r\n  function addOwner(address owner)\r\n    public\r\n    onlyWallet\r\n    ownerDoesNotExist(owner)\r\n    notNull(owner)\r\n    validRequirement(owners.length + 1, required)\r\n  {\r\n    isOwner[owner] = true;\r\n    owners.push(owner);\r\n    emit OwnerAddition(owner);\r\n  }\r\n\r\n  /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\r\n  /// @param owner Address of owner.\r\n  function removeOwner(address owner)\r\n    public\r\n    onlyWallet\r\n    ownerExists(owner)\r\n    validRequirement(owners.length, required)\r\n  {\r\n    isOwner[owner] = false;\r\n    for (uint i=0; i<owners.length - 1; i++)\r\n      if (owners[i] == owner) {\r\n        owners[i] = owners[owners.length - 1];\r\n        break;\r\n      }\r\n\r\n    owners.length -= 1;\r\n    if (required > owners.length)\r\n      changeRequirement(owners.length);\r\n    emit OwnerRemoval(owner);\r\n  }\r\n\r\n  /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\r\n  /// @param owner Address of owner to be replaced.\r\n  /// @param owner Address of new owner.\r\n  function replaceOwner(address owner, address newOwner)\r\n    public\r\n    onlyWallet\r\n    ownerExists(owner)\r\n    ownerDoesNotExist(newOwner)\r\n  {\r\n    for (uint i=0; i<owners.length; i++)\r\n      if (owners[i] == owner) {\r\n        owners[i] = newOwner;\r\n        break;\r\n      }\r\n\r\n    isOwner[owner] = false;\r\n    isOwner[newOwner] = true;\r\n    emit OwnerRemoval(owner);\r\n    emit OwnerAddition(newOwner);\r\n  }\r\n\r\n  /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\r\n  /// @param _required Number of required confirmations.\r\n  function changeRequirement(uint _required)\r\n    public\r\n    onlyWallet\r\n    validRequirement(owners.length, _required)\r\n  {\r\n    required = _required;\r\n    emit RequirementChange(_required);\r\n  }\r\n\r\n  /// @dev Allows an owner to submit and confirm a transaction.\r\n  /// @param destination Transaction target address.\r\n  /// @param value Transaction ether value.\r\n  /// @param data Transaction data payload.\r\n  /// @return Returns transaction ID.\r\n  function submitTransaction(address destination, uint value, bytes data)\r\n    public\r\n    returns (uint transactionId)\r\n  {\r\n    transactionId = addTransaction(destination, value, data);\r\n    confirmTransaction(transactionId);\r\n  }\r\n\r\n  /// @dev Allows an owner to confirm a transaction.\r\n  /// @param transactionId Transaction ID.\r\n  function confirmTransaction(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    transactionExists(transactionId)\r\n    notConfirmed(transactionId, msg.sender)\r\n  {\r\n    confirmations[transactionId][msg.sender] = true;\r\n    emit Confirmation(msg.sender, transactionId);\r\n    executeTransaction(transactionId);\r\n  }\r\n\r\n  /// @dev Allows an owner to revoke a confirmation for a transaction.\r\n  /// @param transactionId Transaction ID.\r\n  function revokeConfirmation(uint transactionId)\r\n    public\r\n    ownerExists(msg.sender)\r\n    confirmed(transactionId, msg.sender)\r\n    notExecuted(transactionId)\r\n  {\r\n    confirmations[transactionId][msg.sender] = false;\r\n    emit Revocation(msg.sender, transactionId);\r\n  }\r\n\r\n  /// @dev Allows anyone to execute a confirmed transaction.\r\n  /// @param transactionId Transaction ID.\r\n  function executeTransaction(uint transactionId)\r\n    public\r\n    notExecuted(transactionId)\r\n  {\r\n    if (isConfirmed(transactionId)) {\r\n      Transaction storage txToExecute = transactions[transactionId];\r\n      txToExecute.executed = true;\r\n      if (txToExecute.destination.call.value(txToExecute.value)(txToExecute.data))\r\n        emit Execution(transactionId);\r\n      else {\r\n        emit ExecutionFailure(transactionId);\r\n        txToExecute.executed = false;\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the confirmation status of a transaction.\r\n  /// @param transactionId Transaction ID.\r\n  /// @return Confirmation status.\r\n  function isConfirmed(uint transactionId)\r\n    public\r\n    constant\r\n    returns (bool)\r\n  {\r\n    uint count = 0;\r\n    for (uint i=0; i<owners.length; i++) {\r\n      if (confirmations[transactionId][owners[i]])\r\n        count += 1;\r\n      if (count == required)\r\n        return true;\r\n    }\r\n  }\r\n\r\n  /*=================================\r\n  =        OPERATOR FUNCTIONS       =\r\n  =================================*/\r\n\r\n  /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet.\r\n  /// @param destination Transaction target address.\r\n  /// @param value Transaction ether value.\r\n  /// @param data Transaction data payload.\r\n  /// @return Returns transaction ID.\r\n  function addTransaction(address destination, uint value, bytes data)\r\n    internal\r\n    notNull(destination)\r\n    returns (uint transactionId)\r\n  {\r\n    transactionId = transactionCount;\r\n\r\n    transactions[transactionId] = Transaction({\r\n        destination: destination,\r\n        value: value,\r\n        data: data,\r\n        executed: false\r\n    });\r\n\r\n    transactionCount += 1;\r\n    emit Submission(transactionId);\r\n  }\r\n\r\n  /*\r\n   * Web3 call functions\r\n   */\r\n  /// @dev Returns number of confirmations of a transaction.\r\n  /// @param transactionId Transaction ID.\r\n  /// @return Number of confirmations.\r\n  function getConfirmationCount(uint transactionId)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n  {\r\n    for (uint i=0; i<owners.length; i++)\r\n      if (confirmations[transactionId][owners[i]])\r\n        count += 1;\r\n  }\r\n\r\n  /// @dev Returns total number of transactions after filers are applied.\r\n  /// @param pending Include pending transactions.\r\n  /// @param executed Include executed transactions.\r\n  /// @return Total number of transactions after filters are applied.\r\n  function getTransactionCount(bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint count)\r\n  {\r\n    for (uint i=0; i<transactionCount; i++)\r\n      if (pending && !transactions[i].executed || executed && transactions[i].executed)\r\n        count += 1;\r\n  }\r\n\r\n  /// @dev Returns list of owners.\r\n  /// @return List of owner addresses.\r\n  function getOwners()\r\n    public\r\n    constant\r\n    returns (address[])\r\n  {\r\n    return owners;\r\n  }\r\n\r\n  /// @dev Returns array with owner addresses, which confirmed transaction.\r\n  /// @param transactionId Transaction ID.\r\n  /// @return Returns array of owner addresses.\r\n  function getConfirmations(uint transactionId)\r\n    public\r\n    constant\r\n    returns (address[] _confirmations)\r\n  {\r\n    address[] memory confirmationsTemp = new address[](owners.length);\r\n    uint count = 0;\r\n    uint i;\r\n    for (i=0; i<owners.length; i++)\r\n      if (confirmations[transactionId][owners[i]]) {\r\n        confirmationsTemp[count] = owners[i];\r\n        count += 1;\r\n      }\r\n\r\n      _confirmations = new address[](count);\r\n\r\n      for (i=0; i<count; i++)\r\n        _confirmations[i] = confirmationsTemp[i];\r\n  }\r\n\r\n  /// @dev Returns list of transaction IDs in defined range.\r\n  /// @param from Index start position of transaction array.\r\n  /// @param to Index end position of transaction array.\r\n  /// @param pending Include pending transactions.\r\n  /// @param executed Include executed transactions.\r\n  /// @return Returns array of transaction IDs.\r\n  function getTransactionIds(uint from, uint to, bool pending, bool executed)\r\n    public\r\n    constant\r\n    returns (uint[] _transactionIds)\r\n  {\r\n    uint[] memory transactionIdsTemp = new uint[](transactionCount);\r\n    uint count = 0;\r\n    uint i;\r\n\r\n    for (i=0; i<transactionCount; i++)\r\n      if (pending && !transactions[i].executed || executed && transactions[i].executed) {\r\n        transactionIdsTemp[count] = i;\r\n        count += 1;\r\n      }\r\n\r\n      _transactionIds = new uint[](to - from);\r\n\r\n    for (i=from; i<to; i++)\r\n      _transactionIds[i - from] = transactionIdsTemp[i];\r\n  }\r\n\r\n  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes /*_data*/)\r\n  public\r\n  returns (bool)\r\n  {\r\n    return true;\r\n  }\r\n}\r\n\r\n// File: contracts/Bankroll/Interfaces/ZethrTokenBankrollInterface.sol\r\n\r\n// Zethr token bankroll function prototypes\r\ncontract ZethrTokenBankrollInterface is ERC223Receiving {\r\n  uint public jackpotBalance;\r\n  \r\n  function getMaxProfit(address) public view returns (uint);\r\n  function gameTokenResolution(uint _toWinnerAmount, address _winnerAddress, uint _toJackpotAmount, address _jackpotAddress, uint _originalBetSize) external;\r\n  function payJackpotToWinner(address _winnerAddress, uint payoutDivisor) public;\r\n}\r\n\r\n// File: contracts/Bankroll/Interfaces/ZethrBankrollControllerInterface.sol\r\n\r\ncontract ZethrBankrollControllerInterface is ERC223Receiving {\r\n  address public jackpotAddress;\r\n\r\n  ZethrTokenBankrollInterface[7] public tokenBankrolls; \r\n  \r\n  ZethrMultiSigWallet public multiSigWallet;\r\n\r\n  mapping(address => bool) public validGameAddresses;\r\n\r\n  function gamePayoutResolver(address _resolver, uint _tokenAmount) public;\r\n\r\n  function isTokenBankroll(address _address) public view returns (bool);\r\n\r\n  function getTokenBankrollAddressFromTier(uint8 _tier) public view returns (address);\r\n\r\n  function tokenFallback(address _from, uint _amountOfTokens, bytes _data) public returns (bool);\r\n}\r\n\r\n// File: contracts/ERC/ERC721Interface.sol\r\n\r\ncontract ERC721Interface {\r\n  function approve(address _to, uint _tokenId) public;\r\n  function balanceOf(address _owner) public view returns (uint balance);\r\n  function implementsERC721() public pure returns (bool);\r\n  function ownerOf(uint _tokenId) public view returns (address addr);\r\n  function takeOwnership(uint _tokenId) public;\r\n  function totalSupply() public view returns (uint total);\r\n  function transferFrom(address _from, address _to, uint _tokenId) public;\r\n  function transfer(address _to, uint _tokenId) public;\r\n\r\n  event Transfer(address indexed from, address indexed to, uint tokenId);\r\n  event Approval(address indexed owner, address indexed approved, uint tokenId);\r\n}\r\n\r\n// File: contracts/Libraries/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n}\r\n\r\n// File: contracts/Games/ZethrDividendCards.sol\r\n\r\ncontract ZethrDividendCards is ERC721Interface {\r\n    using SafeMath for uint;\r\n\r\n  /*** EVENTS ***/\r\n\r\n  /// @dev The Birth event is fired whenever a new dividend card comes into existence.\r\n  event Birth(uint tokenId, string name, address owner);\r\n\r\n  /// @dev The TokenSold event is fired whenever a token (dividend card, in this case) is sold.\r\n  event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name);\r\n\r\n  /// @dev Transfer event as defined in current draft of ERC721.\r\n  ///  Ownership is assigned, including births.\r\n  event Transfer(address from, address to, uint tokenId);\r\n\r\n  // Events for calculating card profits / errors\r\n  event BankrollDivCardProfit(uint bankrollProfit, uint percentIncrease, address oldOwner);\r\n  event BankrollProfitFailure(uint bankrollProfit, uint percentIncrease, address oldOwner);\r\n  event UserDivCardProfit(uint divCardProfit, uint percentIncrease, address oldOwner);\r\n  event DivCardProfitFailure(uint divCardProfit, uint percentIncrease, address oldOwner);\r\n  event masterCardProfit(uint toMaster, address _masterAddress, uint _divCardId);\r\n  event masterCardProfitFailure(uint toMaster, address _masterAddress, uint _divCardId);\r\n  event regularCardProfit(uint toRegular, address _regularAddress, uint _divCardId);\r\n  event regularCardProfitFailure(uint toRegular, address _regularAddress, uint _divCardId);\r\n\r\n  /*** CONSTANTS ***/\r\n\r\n  /// @notice Name and symbol of the non fungible token, as defined in ERC721.\r\n  string public constant NAME           = \"ZethrDividendCard\";\r\n  string public constant SYMBOL         = \"ZDC\";\r\n  address public         BANKROLL;\r\n\r\n  /*** STORAGE ***/\r\n\r\n  /// @dev A mapping from dividend card indices to the address that owns them.\r\n  ///  All dividend cards have a valid owner address.\r\n\r\n  mapping (uint => address) public      divCardIndexToOwner;\r\n\r\n  // A mapping from a dividend rate to the card index.\r\n\r\n  mapping (uint => uint) public         divCardRateToIndex;\r\n\r\n  // @dev A mapping from owner address to the number of dividend cards that address owns.\r\n  //  Used internally inside balanceOf() to resolve ownership count.\r\n\r\n  mapping (address => uint) private     ownershipDivCardCount;\r\n\r\n  /// @dev A mapping from dividend card indices to an address that has been approved to call\r\n  ///  transferFrom(). Each dividend card can only have one approved address for transfer\r\n  ///  at any time. A zero value means no approval is outstanding.\r\n\r\n  mapping (uint => address) public      divCardIndexToApproved;\r\n\r\n  // @dev A mapping from dividend card indices to the price of the dividend card.\r\n\r\n  mapping (uint => uint) private        divCardIndexToPrice;\r\n\r\n  mapping (address => bool) internal    administrators;\r\n\r\n  address public                        creator;\r\n  bool    public                        onSale;\r\n\r\n  /*** DATATYPES ***/\r\n\r\n  struct Card {\r\n    string name;\r\n    uint percentIncrease;\r\n  }\r\n\r\n  Card[] private divCards;\r\n\r\n  modifier onlyCreator() {\r\n    require(msg.sender == creator);\r\n    _;\r\n  }\r\n\r\n  constructor (address _bankroll) public {\r\n    creator = msg.sender;\r\n    BANKROLL = _bankroll;\r\n\r\n    createDivCard(\"2%\", 1 ether, 2);\r\n    divCardRateToIndex[2] = 0;\r\n\r\n    createDivCard(\"5%\", 1 ether, 5);\r\n    divCardRateToIndex[5] = 1;\r\n\r\n    createDivCard(\"10%\", 1 ether, 10);\r\n    divCardRateToIndex[10] = 2;\r\n\r\n    createDivCard(\"15%\", 1 ether, 15);\r\n    divCardRateToIndex[15] = 3;\r\n\r\n    createDivCard(\"20%\", 1 ether, 20);\r\n    divCardRateToIndex[20] = 4;\r\n\r\n    createDivCard(\"25%\", 1 ether, 25);\r\n    divCardRateToIndex[25] = 5;\r\n\r\n    createDivCard(\"33%\", 1 ether, 33);\r\n    divCardRateToIndex[33] = 6;\r\n\r\n    createDivCard(\"MASTER\", 5 ether, 10);\r\n    divCardRateToIndex[999] = 7;\r\n\r\n\t  onSale = true;\r\n\r\n    administrators[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true; // Norsefire\r\n    administrators[0x11e52c75998fe2E7928B191bfc5B25937Ca16741] = true; // klob\r\n    administrators[0x20C945800de43394F70D789874a4daC9cFA57451] = true; // Etherguy\r\n    administrators[0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB] = true; // blurr\r\n\r\n    administrators[msg.sender] = true; // Helps with debugging\r\n  }\r\n\r\n  /*** MODIFIERS ***/\r\n\r\n  // Modifier to prevent contracts from interacting with the flip cards\r\n  modifier isNotContract()\r\n  {\r\n    require (msg.sender == tx.origin);\r\n    _;\r\n  }\r\n\r\n\t// Modifier to prevent purchases before we open them up to everyone\r\n\tmodifier hasStarted()\r\n  {\r\n\t\trequire (onSale == true);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier isAdmin()\r\n  {\r\n\t  require(administrators[msg.sender]);\r\n\t  _;\r\n  }\r\n\r\n  /*** PUBLIC FUNCTIONS ***/\r\n  // Administrative update of the bankroll contract address\r\n  function setBankroll(address where)\r\n    public\r\n    isAdmin\r\n  {\r\n    BANKROLL = where;\r\n  }\r\n\r\n  /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom().\r\n  /// @param _to The address to be granted transfer approval. Pass address(0) to\r\n  ///  clear all approvals.\r\n  /// @param _tokenId The ID of the Token that can be transferred if this call succeeds.\r\n  /// @dev Required for ERC-721 compliance.\r\n  function approve(address _to, uint _tokenId)\r\n    public\r\n    isNotContract\r\n  {\r\n    // Caller must own token.\r\n    require(_owns(msg.sender, _tokenId));\r\n\r\n    divCardIndexToApproved[_tokenId] = _to;\r\n\r\n    emit Approval(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /// For querying balance of a particular account\r\n  /// @param _owner The address for balance query\r\n  /// @dev Required for ERC-721 compliance.\r\n  function balanceOf(address _owner)\r\n    public\r\n    view\r\n    returns (uint balance)\r\n  {\r\n    return ownershipDivCardCount[_owner];\r\n  }\r\n\r\n  // Creates a div card with bankroll as the owner\r\n  function createDivCard(string _name, uint _price, uint _percentIncrease)\r\n    public\r\n    onlyCreator\r\n  {\r\n    _createDivCard(_name, BANKROLL, _price, _percentIncrease);\r\n  }\r\n\r\n\t// Opens the dividend cards up for sale.\r\n\tfunction startCardSale()\r\n        public\r\n        isAdmin\r\n  {\r\n\t\tonSale = true;\r\n\t}\r\n\r\n  /// @notice Returns all the relevant information about a specific div card\r\n  /// @param _divCardId The tokenId of the div card of interest.\r\n  function getDivCard(uint _divCardId)\r\n    public\r\n    view\r\n    returns (string divCardName, uint sellingPrice, address owner)\r\n  {\r\n    Card storage divCard = divCards[_divCardId];\r\n    divCardName = divCard.name;\r\n    sellingPrice = divCardIndexToPrice[_divCardId];\r\n    owner = divCardIndexToOwner[_divCardId];\r\n  }\r\n\r\n  function implementsERC721()\r\n    public\r\n    pure\r\n    returns (bool)\r\n  {\r\n    return true;\r\n  }\r\n\r\n  /// @dev Required for ERC-721 compliance.\r\n  function name()\r\n    public\r\n    pure\r\n    returns (string)\r\n  {\r\n    return NAME;\r\n  }\r\n\r\n  /// For querying owner of token\r\n  /// @param _divCardId The tokenID for owner inquiry\r\n  /// @dev Required for ERC-721 compliance.\r\n  function ownerOf(uint _divCardId)\r\n    public\r\n    view\r\n    returns (address owner)\r\n  {\r\n    owner = divCardIndexToOwner[_divCardId];\r\n    require(owner != address(0));\r\n\treturn owner;\r\n  }\r\n\r\n  // Allows someone to send Ether and obtain a card\r\n  function purchase(uint _divCardId)\r\n    public\r\n    payable\r\n    hasStarted\r\n    isNotContract\r\n  {\r\n    address oldOwner  = divCardIndexToOwner[_divCardId];\r\n    address newOwner  = msg.sender;\r\n\r\n    // Get the current price of the card\r\n    uint currentPrice = divCardIndexToPrice[_divCardId];\r\n\r\n    // Making sure token owner is not sending to self\r\n    require(oldOwner != newOwner);\r\n\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_addressNotNull(newOwner));\r\n\r\n    // Making sure sent amount is greater than or equal to the sellingPrice\r\n    require(msg.value >= currentPrice);\r\n\r\n    // To find the total profit, we need to know the previous price\r\n    // currentPrice      = previousPrice * (100 + percentIncrease);\r\n    // previousPrice     = currentPrice / (100 + percentIncrease);\r\n    uint percentIncrease = divCards[_divCardId].percentIncrease;\r\n    uint previousPrice   = SafeMath.mul(currentPrice, 100).div(100 + percentIncrease);\r\n\r\n    // Calculate total profit and allocate 50% to old owner, 50% to bankroll\r\n    uint totalProfit     = SafeMath.sub(currentPrice, previousPrice);\r\n    uint oldOwnerProfit  = SafeMath.div(totalProfit, 2);\r\n    uint bankrollProfit  = SafeMath.sub(totalProfit, oldOwnerProfit);\r\n    oldOwnerProfit       = SafeMath.add(oldOwnerProfit, previousPrice);\r\n\r\n    // Refund the sender the excess he sent\r\n    uint purchaseExcess  = SafeMath.sub(msg.value, currentPrice);\r\n\r\n    // Raise the price by the percentage specified by the card\r\n    divCardIndexToPrice[_divCardId] = SafeMath.div(SafeMath.mul(currentPrice, (100 + percentIncrease)), 100);\r\n\r\n    // Transfer ownership\r\n    _transfer(oldOwner, newOwner, _divCardId);\r\n\r\n    // Using send rather than transfer to prevent contract exploitability.\r\n    if(BANKROLL.send(bankrollProfit)) {\r\n      emit BankrollDivCardProfit(bankrollProfit, percentIncrease, oldOwner);\r\n    } else {\r\n      emit BankrollProfitFailure(bankrollProfit, percentIncrease, oldOwner);\r\n    }\r\n\r\n    if(oldOwner.send(oldOwnerProfit)) {\r\n      emit UserDivCardProfit(oldOwnerProfit, percentIncrease, oldOwner);\r\n    } else {\r\n      emit DivCardProfitFailure(oldOwnerProfit, percentIncrease, oldOwner);\r\n    }\r\n\r\n    msg.sender.transfer(purchaseExcess);\r\n  }\r\n\r\n  function priceOf(uint _divCardId)\r\n    public\r\n    view\r\n    returns (uint price)\r\n  {\r\n    return divCardIndexToPrice[_divCardId];\r\n  }\r\n\r\n  function setCreator(address _creator)\r\n    public\r\n    onlyCreator\r\n  {\r\n    require(_creator != address(0));\r\n\r\n    creator = _creator;\r\n  }\r\n\r\n  /// @dev Required for ERC-721 compliance.\r\n  function symbol()\r\n    public\r\n    pure\r\n    returns (string)\r\n  {\r\n    return SYMBOL;\r\n  }\r\n\r\n  /// @notice Allow pre-approved user to take ownership of a dividend card.\r\n  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\r\n  /// @dev Required for ERC-721 compliance.\r\n  function takeOwnership(uint _divCardId)\r\n    public\r\n    isNotContract\r\n  {\r\n    address newOwner = msg.sender;\r\n    address oldOwner = divCardIndexToOwner[_divCardId];\r\n\r\n    // Safety check to prevent against an unexpected 0x0 default.\r\n    require(_addressNotNull(newOwner));\r\n\r\n    // Making sure transfer is approved\r\n    require(_approved(newOwner, _divCardId));\r\n\r\n    _transfer(oldOwner, newOwner, _divCardId);\r\n  }\r\n\r\n  /// For querying totalSupply of token\r\n  /// @dev Required for ERC-721 compliance.\r\n  function totalSupply()\r\n    public\r\n    view\r\n    returns (uint total)\r\n  {\r\n    return divCards.length;\r\n  }\r\n\r\n  /// Owner initates the transfer of the card to another account\r\n  /// @param _to The address for the card to be transferred to.\r\n  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\r\n  /// @dev Required for ERC-721 compliance.\r\n  function transfer(address _to, uint _divCardId)\r\n    public\r\n    isNotContract\r\n  {\r\n    require(_owns(msg.sender, _divCardId));\r\n    require(_addressNotNull(_to));\r\n\r\n    _transfer(msg.sender, _to, _divCardId);\r\n  }\r\n\r\n  /// Third-party initiates transfer of a card from address _from to address _to\r\n  /// @param _from The address for the card to be transferred from.\r\n  /// @param _to The address for the card to be transferred to.\r\n  /// @param _divCardId The ID of the card that can be transferred if this call succeeds.\r\n  /// @dev Required for ERC-721 compliance.\r\n  function transferFrom(address _from, address _to, uint _divCardId)\r\n    public\r\n    isNotContract\r\n  {\r\n    require(_owns(_from, _divCardId));\r\n    require(_approved(_to, _divCardId));\r\n    require(_addressNotNull(_to));\r\n\r\n    _transfer(_from, _to, _divCardId);\r\n  }\r\n\r\n  function receiveDividends(uint _divCardRate)\r\n    public\r\n    payable\r\n  {\r\n    uint _divCardId = divCardRateToIndex[_divCardRate];\r\n    address _regularAddress = divCardIndexToOwner[_divCardId];\r\n    address _masterAddress = divCardIndexToOwner[7];\r\n\r\n    uint toMaster = msg.value.div(2);\r\n    uint toRegular = msg.value.sub(toMaster);\r\n\r\n    if(_masterAddress.send(toMaster)){\r\n      emit masterCardProfit(toMaster, _masterAddress, _divCardId);\r\n    } else {\r\n      emit masterCardProfitFailure(toMaster, _masterAddress, _divCardId);\r\n    }\r\n\r\n    if(_regularAddress.send(toRegular)) {\r\n      emit regularCardProfit(toRegular, _regularAddress, _divCardId);\r\n    } else {\r\n      emit regularCardProfitFailure(toRegular, _regularAddress, _divCardId);\r\n    }\r\n  }\r\n\r\n  /*** PRIVATE FUNCTIONS ***/\r\n  /// Safety check on _to address to prevent against an unexpected 0x0 default.\r\n  function _addressNotNull(address _to)\r\n    private\r\n    pure\r\n    returns (bool)\r\n  {\r\n    return _to != address(0);\r\n  }\r\n\r\n  /// For checking approval of transfer for address _to\r\n  function _approved(address _to, uint _divCardId)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return divCardIndexToApproved[_divCardId] == _to;\r\n  }\r\n\r\n  /// For creating a dividend card\r\n  function _createDivCard(string _name, address _owner, uint _price, uint _percentIncrease)\r\n    private\r\n  {\r\n    Card memory _divcard = Card({\r\n      name: _name,\r\n      percentIncrease: _percentIncrease\r\n    });\r\n    uint newCardId = divCards.push(_divcard) - 1;\r\n\r\n    // It's probably never going to happen, 4 billion tokens are A LOT, but\r\n    // let's just be 100% sure we never let this happen.\r\n    require(newCardId == uint(uint32(newCardId)));\r\n\r\n    emit Birth(newCardId, _name, _owner);\r\n\r\n    divCardIndexToPrice[newCardId] = _price;\r\n\r\n    // This will assign ownership, and also emit the Transfer event as per ERC721 draft\r\n    _transfer(BANKROLL, _owner, newCardId);\r\n  }\r\n\r\n  /// Check for token ownership\r\n  function _owns(address claimant, uint _divCardId)\r\n    private\r\n    view\r\n    returns (bool)\r\n  {\r\n    return claimant == divCardIndexToOwner[_divCardId];\r\n  }\r\n\r\n  /// @dev Assigns ownership of a specific Card to an address.\r\n  function _transfer(address _from, address _to, uint _divCardId)\r\n    private\r\n  {\r\n    // Since the number of cards is capped to 2^32 we can't overflow this\r\n    ownershipDivCardCount[_to]++;\r\n    //transfer ownership\r\n    divCardIndexToOwner[_divCardId] = _to;\r\n\r\n    // When creating new div cards _from is 0x0, but we can't account that address.\r\n    if (_from != address(0)) {\r\n      ownershipDivCardCount[_from]--;\r\n      // clear any previously approved ownership exchange\r\n      delete divCardIndexToApproved[_divCardId];\r\n    }\r\n\r\n    // Emit the transfer event.\r\n    emit Transfer(_from, _to, _divCardId);\r\n  }\r\n}\r\n\r\n// File: contracts/Zethr.sol\r\n\r\ncontract Zethr {\r\n  using SafeMath for uint;\r\n\r\n  /*=================================\r\n  =            MODIFIERS            =\r\n  =================================*/\r\n\r\n  modifier onlyHolders() {\r\n    require(myFrontEndTokens() > 0);\r\n    _;\r\n  }\r\n\r\n  modifier dividendHolder() {\r\n    require(myDividends(true) > 0);\r\n    _;\r\n  }\r\n\r\n  modifier onlyAdministrator(){\r\n    address _customerAddress = msg.sender;\r\n    require(administrators[_customerAddress]);\r\n    _;\r\n  }\r\n\r\n  /*==============================\r\n  =            EVENTS            =\r\n  ==============================*/\r\n\r\n  event onTokenPurchase(\r\n    address indexed customerAddress,\r\n    uint incomingEthereum,\r\n    uint tokensMinted,\r\n    address indexed referredBy\r\n  );\r\n\r\n  event UserDividendRate(\r\n    address user,\r\n    uint divRate\r\n  );\r\n\r\n  event onTokenSell(\r\n    address indexed customerAddress,\r\n    uint tokensBurned,\r\n    uint ethereumEarned\r\n  );\r\n\r\n  event onReinvestment(\r\n    address indexed customerAddress,\r\n    uint ethereumReinvested,\r\n    uint tokensMinted\r\n  );\r\n\r\n  event onWithdraw(\r\n    address indexed customerAddress,\r\n    uint ethereumWithdrawn\r\n  );\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint tokens\r\n  );\r\n\r\n  event Approval(\r\n    address indexed tokenOwner,\r\n    address indexed spender,\r\n    uint tokens\r\n  );\r\n\r\n  event Allocation(\r\n    uint toBankRoll,\r\n    uint toReferrer,\r\n    uint toTokenHolders,\r\n    uint toDivCardHolders,\r\n    uint forTokens\r\n  );\r\n\r\n  event Referral(\r\n    address referrer,\r\n    uint amountReceived\r\n  );\r\n\r\n  /*=====================================\r\n  =            CONSTANTS                =\r\n  =====================================*/\r\n\r\n  uint8 constant public                decimals = 18;\r\n\r\n  uint constant internal               tokenPriceInitial_ = 0.000653 ether;\r\n  uint constant internal               magnitude = 2 ** 64;\r\n\r\n  uint constant internal               icoHardCap = 250 ether;\r\n  uint constant internal               addressICOLimit = 1   ether;\r\n  uint constant internal               icoMinBuyIn = 0.1 finney;\r\n  uint constant internal               icoMaxGasPrice = 50000000000 wei;\r\n\r\n  uint constant internal               MULTIPLIER = 9615;\r\n\r\n  uint constant internal               MIN_ETH_BUYIN = 0.0001 ether;\r\n  uint constant internal               MIN_TOKEN_SELL_AMOUNT = 0.0001 ether;\r\n  uint constant internal               MIN_TOKEN_TRANSFER = 1e10;\r\n  uint constant internal               referrer_percentage = 25;\r\n\r\n  uint public                          stakingRequirement = 100e18;\r\n\r\n  /*================================\r\n   =          CONFIGURABLES         =\r\n   ================================*/\r\n\r\n  string public                        name = \"Zethr\";\r\n  string public                        symbol = \"ZTH\";\r\n\r\n  //bytes32 constant public              icoHashedPass      = bytes32(0x5ddcde33b94b19bdef79dd9ea75be591942b9ec78286d64b44a356280fb6a262); // public\r\n  bytes32 constant public              icoHashedPass = bytes32(0x8a6ddee3fb2508ff4a5b02b48e9bc4566d0f3e11f306b0f75341bf235662a9e3); // test hunter2\r\n\r\n  address internal                     bankrollAddress;\r\n\r\n  ZethrDividendCards                   divCardContract;\r\n\r\n  /*================================\r\n   =            DATASETS            =\r\n   ================================*/\r\n\r\n  // Tracks front & backend tokens\r\n  mapping(address => uint) internal    frontTokenBalanceLedger_;\r\n  mapping(address => uint) internal    dividendTokenBalanceLedger_;\r\n  mapping(address =>\r\n  mapping(address => uint))\r\n  public      allowed;\r\n\r\n  // Tracks dividend rates for users\r\n  mapping(uint8 => bool)    internal validDividendRates_;\r\n  mapping(address => bool)    internal userSelectedRate;\r\n  mapping(address => uint8)   internal userDividendRate;\r\n\r\n  // Payout tracking\r\n  mapping(address => uint)    internal referralBalance_;\r\n  mapping(address => int256)  internal payoutsTo_;\r\n\r\n  // ICO per-address limit tracking\r\n  mapping(address => uint)    internal ICOBuyIn;\r\n\r\n  uint public                          tokensMintedDuringICO;\r\n  uint public                          ethInvestedDuringICO;\r\n\r\n  uint public                          currentEthInvested;\r\n\r\n  uint internal                        tokenSupply = 0;\r\n  uint internal                        divTokenSupply = 0;\r\n\r\n  uint internal                        profitPerDivToken;\r\n\r\n  mapping(address => bool) public      administrators;\r\n\r\n  bool public                          icoPhase = false;\r\n  bool public                          regularPhase = false;\r\n\r\n  uint                                 icoOpenTime;\r\n\r\n  /*=======================================\r\n  =            PUBLIC FUNCTIONS           =\r\n  =======================================*/\r\n  constructor (address _bankrollAddress, address _divCardAddress)\r\n  public\r\n  {\r\n    bankrollAddress = _bankrollAddress;\r\n    divCardContract = ZethrDividendCards(_divCardAddress);\r\n\r\n    administrators[0x4F4eBF556CFDc21c3424F85ff6572C77c514Fcae] = true;\r\n    // Norsefire\r\n    administrators[0x11e52c75998fe2E7928B191bfc5B25937Ca16741] = true;\r\n    // klob\r\n    administrators[0x20C945800de43394F70D789874a4daC9cFA57451] = true;\r\n    // Etherguy\r\n    administrators[0xef764BAC8a438E7E498c2E5fcCf0f174c3E3F8dB] = true;\r\n    // blurr\r\n    administrators[0x8537aa2911b193e5B377938A723D805bb0865670] = true;\r\n    // oguzhanox\r\n    administrators[0x9D221b2100CbE5F05a0d2048E2556a6Df6f9a6C3] = true;\r\n    // Randall\r\n    administrators[0xDa83156106c4dba7A26E9bF2Ca91E273350aa551] = true;\r\n    // TropicalRogue\r\n    administrators[0x71009e9E4e5e68e77ECc7ef2f2E95cbD98c6E696] = true;\r\n    // cryptodude\r\n\r\n    administrators[msg.sender] = true;\r\n    // Helps with debugging!\r\n\r\n    validDividendRates_[2] = true;\r\n    validDividendRates_[5] = true;\r\n    validDividendRates_[10] = true;\r\n    validDividendRates_[15] = true;\r\n    validDividendRates_[20] = true;\r\n    validDividendRates_[25] = true;\r\n    validDividendRates_[33] = true;\r\n\r\n    userSelectedRate[bankrollAddress] = true;\r\n    userDividendRate[bankrollAddress] = 33;\r\n\r\n  }\r\n\r\n  /**\r\n   * Same as buy, but explicitly sets your dividend percentage.\r\n   * If this has been called before, it will update your `default' dividend\r\n   *   percentage for regular buy transactions going forward.\r\n   */\r\n  function buyAndSetDivPercentage(address _referredBy, uint8 _divChoice, string /*providedUnhashedPass*/)\r\n  public\r\n  payable\r\n  returns (uint)\r\n  {\r\n    require(icoPhase || regularPhase);\r\n\r\n    if (icoPhase) {\r\n\r\n      // Anti-bot measures - not perfect, but should help some.\r\n      // bytes32 hashedProvidedPass = keccak256(providedUnhashedPass);\r\n      //require(hashedProvidedPass == icoHashedPass || msg.sender == bankrollAddress); // test; remove\r\n\r\n      uint gasPrice = tx.gasprice;\r\n\r\n      // Prevents ICO buyers from getting substantially burned if the ICO is reached\r\n      //   before their transaction is processed.\r\n      require(gasPrice <= icoMaxGasPrice && ethInvestedDuringICO <= icoHardCap);\r\n\r\n    }\r\n\r\n    // Dividend percentage should be a currently accepted value.\r\n    require(validDividendRates_[_divChoice]);\r\n\r\n    // Set the dividend fee percentage denominator.\r\n    userSelectedRate[msg.sender] = true;\r\n    userDividendRate[msg.sender] = _divChoice;\r\n    emit UserDividendRate(msg.sender, _divChoice);\r\n\r\n    // Finally, purchase tokens.\r\n    purchaseTokens(msg.value, _referredBy);\r\n  }\r\n\r\n  // All buys except for the above one require regular phase.\r\n\r\n  function buy(address _referredBy)\r\n  public\r\n  payable\r\n  returns (uint)\r\n  {\r\n    require(regularPhase);\r\n    address _customerAddress = msg.sender;\r\n    require(userSelectedRate[_customerAddress]);\r\n    purchaseTokens(msg.value, _referredBy);\r\n  }\r\n\r\n  function buyAndTransfer(address _referredBy, address target)\r\n  public\r\n  payable\r\n  {\r\n    bytes memory empty;\r\n    buyAndTransfer(_referredBy, target, empty, 20);\r\n  }\r\n\r\n  function buyAndTransfer(address _referredBy, address target, bytes _data)\r\n  public\r\n  payable\r\n  {\r\n    buyAndTransfer(_referredBy, target, _data, 20);\r\n  }\r\n\r\n  // Overload\r\n  function buyAndTransfer(address _referredBy, address target, bytes _data, uint8 divChoice)\r\n  public\r\n  payable\r\n  {\r\n    require(regularPhase);\r\n    address _customerAddress = msg.sender;\r\n    uint256 frontendBalance = frontTokenBalanceLedger_[msg.sender];\r\n    if (userSelectedRate[_customerAddress] && divChoice == 0) {\r\n      purchaseTokens(msg.value, _referredBy);\r\n    } else {\r\n      buyAndSetDivPercentage(_referredBy, divChoice, \"0x0\");\r\n    }\r\n    uint256 difference = SafeMath.sub(frontTokenBalanceLedger_[msg.sender], frontendBalance);\r\n    transferTo(msg.sender, target, difference, _data);\r\n  }\r\n\r\n  // Fallback function only works during regular phase - part of anti-bot protection.\r\n  function()\r\n  payable\r\n  public\r\n  {\r\n    /**\r\n    / If the user has previously set a dividend rate, sending\r\n    /   Ether directly to the contract simply purchases more at\r\n    /   the most recent rate. If this is their first time, they\r\n    /   are automatically placed into the 20% rate `bucket'.\r\n    **/\r\n    require(regularPhase);\r\n    address _customerAddress = msg.sender;\r\n    if (userSelectedRate[_customerAddress]) {\r\n      purchaseTokens(msg.value, 0x0);\r\n    } else {\r\n      buyAndSetDivPercentage(0x0, 20, \"0x0\");\r\n    }\r\n  }\r\n\r\n  function reinvest()\r\n  dividendHolder()\r\n  public\r\n  {\r\n    require(regularPhase);\r\n    uint _dividends = myDividends(false);\r\n\r\n    // Pay out requisite `virtual' dividends.\r\n    address _customerAddress = msg.sender;\r\n    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n    _dividends += referralBalance_[_customerAddress];\r\n    referralBalance_[_customerAddress] = 0;\r\n\r\n    uint _tokens = purchaseTokens(_dividends, 0x0);\r\n\r\n    // Fire logging event.\r\n    emit onReinvestment(_customerAddress, _dividends, _tokens);\r\n  }\r\n\r\n  function exit()\r\n  public\r\n  {\r\n    require(regularPhase);\r\n    // Retrieve token balance for caller, then sell them all.\r\n    address _customerAddress = msg.sender;\r\n    uint _tokens = frontTokenBalanceLedger_[_customerAddress];\r\n\r\n    if (_tokens > 0) sell(_tokens);\r\n\r\n    withdraw(_customerAddress);\r\n  }\r\n\r\n  function withdraw(address _recipient)\r\n  dividendHolder()\r\n  public\r\n  {\r\n    require(regularPhase);\r\n    // Setup data\r\n    address _customerAddress = msg.sender;\r\n    uint _dividends = myDividends(false);\r\n\r\n    // update dividend tracker\r\n    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n    // add ref. bonus\r\n    _dividends += referralBalance_[_customerAddress];\r\n    referralBalance_[_customerAddress] = 0;\r\n\r\n    if (_recipient == address(0x0)) {\r\n      _recipient = msg.sender;\r\n    }\r\n    _recipient.transfer(_dividends);\r\n\r\n    // Fire logging event.\r\n    emit onWithdraw(_recipient, _dividends);\r\n  }\r\n\r\n  // Sells front-end tokens.\r\n  // Logic concerning step-pricing of tokens pre/post-ICO is encapsulated in tokensToEthereum_.\r\n  function sell(uint _amountOfTokens)\r\n  onlyHolders()\r\n  public\r\n  {\r\n    // No selling during the ICO. You don't get to flip that fast, sorry!\r\n    require(!icoPhase);\r\n    require(regularPhase);\r\n\r\n    require(_amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\r\n\r\n    uint _frontEndTokensToBurn = _amountOfTokens;\r\n\r\n    // Calculate how many dividend tokens this action burns.\r\n    // Computed as the caller's average dividend rate multiplied by the number of front-end tokens held.\r\n    // As an additional guard, we ensure that the dividend rate is between 2 and 50 inclusive.\r\n    uint userDivRate = getUserAverageDividendRate(msg.sender);\r\n    require((2 * magnitude) <= userDivRate && (50 * magnitude) >= userDivRate);\r\n    uint _divTokensToBurn = (_frontEndTokensToBurn.mul(userDivRate)).div(magnitude);\r\n\r\n    // Calculate ethereum received before dividends\r\n    uint _ethereum = tokensToEthereum_(_frontEndTokensToBurn);\r\n\r\n    if (_ethereum > currentEthInvested) {\r\n      // Well, congratulations, you've emptied the coffers.\r\n      currentEthInvested = 0;\r\n    } else {currentEthInvested = currentEthInvested - _ethereum;}\r\n\r\n    // Calculate dividends generated from the sale.\r\n    uint _dividends = (_ethereum.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude);\r\n\r\n    // Calculate Ethereum receivable net of dividends.\r\n    uint _taxedEthereum = _ethereum.sub(_dividends);\r\n\r\n    // Burn the sold tokens (both front-end and back-end variants).\r\n    tokenSupply = tokenSupply.sub(_frontEndTokensToBurn);\r\n    divTokenSupply = divTokenSupply.sub(_divTokensToBurn);\r\n\r\n    // Subtract the token balances for the seller\r\n    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].sub(_frontEndTokensToBurn);\r\n    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].sub(_divTokensToBurn);\r\n\r\n    // Update dividends tracker\r\n    int256 _updatedPayouts = (int256) (profitPerDivToken * _divTokensToBurn + (_taxedEthereum * magnitude));\r\n    payoutsTo_[msg.sender] -= _updatedPayouts;\r\n\r\n    // Let's avoid breaking arithmetic where we can, eh?\r\n    if (divTokenSupply > 0) {\r\n      // Update the value of each remaining back-end dividend token.\r\n      profitPerDivToken = profitPerDivToken.add((_dividends * magnitude) / divTokenSupply);\r\n    }\r\n\r\n    // Fire logging event.\r\n    emit onTokenSell(msg.sender, _frontEndTokensToBurn, _taxedEthereum);\r\n  }\r\n\r\n  /**\r\n   * Transfer tokens from the caller to a new holder.\r\n   * No charge incurred for the transfer. We'd make a terrible bank.\r\n   */\r\n  function transfer(address _toAddress, uint _amountOfTokens)\r\n  onlyHolders()\r\n  public\r\n  returns (bool)\r\n  {\r\n    require(_amountOfTokens >= MIN_TOKEN_TRANSFER && _amountOfTokens <= frontTokenBalanceLedger_[msg.sender]);\r\n    bytes memory empty;\r\n    transferFromInternal(msg.sender, _toAddress, _amountOfTokens, empty);\r\n    return true;\r\n  }\r\n\r\n  function approve(address spender, uint tokens)\r\n  public\r\n  returns (bool)\r\n  {\r\n    address _customerAddress = msg.sender;\r\n    allowed[_customerAddress][spender] = tokens;\r\n\r\n    // Fire logging event.\r\n    emit Approval(_customerAddress, spender, tokens);\r\n\r\n    // Good old ERC20.\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Transfer tokens from the caller to a new holder: the Used By Smart Contracts edition.\r\n   * No charge incurred for the transfer. No seriously, we'd make a terrible bank.\r\n   */\r\n  function transferFrom(address _from, address _toAddress, uint _amountOfTokens)\r\n  public\r\n  returns (bool)\r\n  {\r\n    // Setup variables\r\n    address _customerAddress = _from;\r\n    bytes memory empty;\r\n    // Make sure we own the tokens we're transferring, are ALLOWED to transfer that many tokens,\r\n    // and are transferring at least one full token.\r\n    require(_amountOfTokens >= MIN_TOKEN_TRANSFER\r\n    && _amountOfTokens <= frontTokenBalanceLedger_[_customerAddress]\r\n    && _amountOfTokens <= allowed[_customerAddress][msg.sender]);\r\n\r\n    transferFromInternal(_from, _toAddress, _amountOfTokens, empty);\r\n\r\n    // Good old ERC20.\r\n    return true;\r\n\r\n  }\r\n\r\n  function transferTo(address _from, address _to, uint _amountOfTokens, bytes _data)\r\n  public\r\n  {\r\n    if (_from != msg.sender) {\r\n      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\r\n      && _amountOfTokens <= frontTokenBalanceLedger_[_from]\r\n      && _amountOfTokens <= allowed[_from][msg.sender]);\r\n    }\r\n    else {\r\n      require(_amountOfTokens >= MIN_TOKEN_TRANSFER\r\n      && _amountOfTokens <= frontTokenBalanceLedger_[_from]);\r\n    }\r\n\r\n    transferFromInternal(_from, _to, _amountOfTokens, _data);\r\n  }\r\n\r\n  // Who'd have thought we'd need this thing floating around?\r\n  function totalSupply()\r\n  public\r\n  view\r\n  returns (uint256)\r\n  {\r\n    return tokenSupply;\r\n  }\r\n\r\n  // Anyone can start the regular phase 2 weeks after the ICO phase starts.\r\n  // In case the devs die. Or something.\r\n  function publicStartRegularPhase()\r\n  public\r\n  {\r\n    require(now > (icoOpenTime + 2 weeks) && icoOpenTime != 0);\r\n\r\n    icoPhase = false;\r\n    regularPhase = true;\r\n  }\r\n\r\n  /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n\r\n\r\n  // Fire the starting gun and then duck for cover.\r\n  function startICOPhase()\r\n  onlyAdministrator()\r\n  public\r\n  {\r\n    // Prevent us from startaring the ICO phase again\r\n    require(icoOpenTime == 0);\r\n    icoPhase = true;\r\n    icoOpenTime = now;\r\n  }\r\n\r\n  // Fire the ... ending gun?\r\n  function endICOPhase()\r\n  onlyAdministrator()\r\n  public\r\n  {\r\n    icoPhase = false;\r\n  }\r\n\r\n  function startRegularPhase()\r\n  onlyAdministrator\r\n  public\r\n  {\r\n    // disable ico phase in case if that was not disabled yet\r\n    icoPhase = false;\r\n    regularPhase = true;\r\n  }\r\n\r\n  // The death of a great man demands the birth of a great son.\r\n  function setAdministrator(address _newAdmin, bool _status)\r\n  onlyAdministrator()\r\n  public\r\n  {\r\n    administrators[_newAdmin] = _status;\r\n  }\r\n\r\n  function setStakingRequirement(uint _amountOfTokens)\r\n  onlyAdministrator()\r\n  public\r\n  {\r\n    // This plane only goes one way, lads. Never below the initial.\r\n    require(_amountOfTokens >= 100e18);\r\n    stakingRequirement = _amountOfTokens;\r\n  }\r\n\r\n  function setName(string _name)\r\n  onlyAdministrator()\r\n  public\r\n  {\r\n    name = _name;\r\n  }\r\n\r\n  function setSymbol(string _symbol)\r\n  onlyAdministrator()\r\n  public\r\n  {\r\n    symbol = _symbol;\r\n  }\r\n\r\n  function changeBankroll(address _newBankrollAddress)\r\n  onlyAdministrator\r\n  public\r\n  {\r\n    bankrollAddress = _newBankrollAddress;\r\n  }\r\n\r\n  /*----------  HELPERS AND CALCULATORS  ----------*/\r\n\r\n  function totalEthereumBalance()\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    return address(this).balance;\r\n  }\r\n\r\n  function totalEthereumICOReceived()\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    return ethInvestedDuringICO;\r\n  }\r\n\r\n  /**\r\n   * Retrieves your currently selected dividend rate.\r\n   */\r\n  function getMyDividendRate()\r\n  public\r\n  view\r\n  returns (uint8)\r\n  {\r\n    address _customerAddress = msg.sender;\r\n    require(userSelectedRate[_customerAddress]);\r\n    return userDividendRate[_customerAddress];\r\n  }\r\n\r\n  /**\r\n   * Retrieve the total frontend token supply\r\n   */\r\n  function getFrontEndTokenSupply()\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    return tokenSupply;\r\n  }\r\n\r\n  /**\r\n   * Retreive the total dividend token supply\r\n   */\r\n  function getDividendTokenSupply()\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    return divTokenSupply;\r\n  }\r\n\r\n  /**\r\n   * Retrieve the frontend tokens owned by the caller\r\n   */\r\n  function myFrontEndTokens()\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    address _customerAddress = msg.sender;\r\n    return getFrontEndTokenBalanceOf(_customerAddress);\r\n  }\r\n\r\n  /**\r\n   * Retrieve the dividend tokens owned by the caller\r\n   */\r\n  function myDividendTokens()\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    address _customerAddress = msg.sender;\r\n    return getDividendTokenBalanceOf(_customerAddress);\r\n  }\r\n\r\n  function myReferralDividends()\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    return myDividends(true) - myDividends(false);\r\n  }\r\n\r\n  function myDividends(bool _includeReferralBonus)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    address _customerAddress = msg.sender;\r\n    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\r\n  }\r\n\r\n  function theDividendsOf(bool _includeReferralBonus, address _customerAddress)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress);\r\n  }\r\n\r\n  function getFrontEndTokenBalanceOf(address _customerAddress)\r\n  view\r\n  public\r\n  returns (uint)\r\n  {\r\n    return frontTokenBalanceLedger_[_customerAddress];\r\n  }\r\n\r\n  function balanceOf(address _owner)\r\n  view\r\n  public\r\n  returns (uint)\r\n  {\r\n    return getFrontEndTokenBalanceOf(_owner);\r\n  }\r\n\r\n  function getDividendTokenBalanceOf(address _customerAddress)\r\n  view\r\n  public\r\n  returns (uint)\r\n  {\r\n    return dividendTokenBalanceLedger_[_customerAddress];\r\n  }\r\n\r\n  function dividendsOf(address _customerAddress)\r\n  view\r\n  public\r\n  returns (uint)\r\n  {\r\n    return (uint) ((int256)(profitPerDivToken * dividendTokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n  }\r\n\r\n  // Get the sell price at the user's average dividend rate\r\n  function sellPrice()\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    uint price;\r\n\r\n    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\r\n      price = tokenPriceInitial_;\r\n    } else {\r\n\r\n      // Calculate the tokens received for 100 finney.\r\n      // Divide to find the average, to calculate the price.\r\n      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\r\n\r\n      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\r\n    }\r\n\r\n    // Factor in the user's average dividend rate\r\n    uint theSellPrice = price.sub((price.mul(getUserAverageDividendRate(msg.sender)).div(100)).div(magnitude));\r\n\r\n    return theSellPrice;\r\n  }\r\n\r\n  // Get the buy price at a particular dividend rate\r\n  function buyPrice(uint dividendRate)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    uint price;\r\n\r\n    if (icoPhase || currentEthInvested < ethInvestedDuringICO) {\r\n      price = tokenPriceInitial_;\r\n    } else {\r\n\r\n      // Calculate the tokens received for 100 finney.\r\n      // Divide to find the average, to calculate the price.\r\n      uint tokensReceivedForEth = ethereumToTokens_(0.001 ether);\r\n\r\n      price = (1e18 * 0.001 ether) / tokensReceivedForEth;\r\n    }\r\n\r\n    // Factor in the user's selected dividend rate\r\n    uint theBuyPrice = (price.mul(dividendRate).div(100)).add(price);\r\n\r\n    return theBuyPrice;\r\n  }\r\n\r\n  function calculateTokensReceived(uint _ethereumToSpend)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    uint _dividends = (_ethereumToSpend.mul(userDividendRate[msg.sender])).div(100);\r\n    uint _taxedEthereum = _ethereumToSpend.sub(_dividends);\r\n    uint _amountOfTokens = ethereumToTokens_(_taxedEthereum);\r\n    return _amountOfTokens;\r\n  }\r\n\r\n  // When selling tokens, we need to calculate the user's current dividend rate.\r\n  // This is different from their selected dividend rate.\r\n  function calculateEthereumReceived(uint _tokensToSell)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    require(_tokensToSell <= tokenSupply);\r\n    uint _ethereum = tokensToEthereum_(_tokensToSell);\r\n    uint userAverageDividendRate = getUserAverageDividendRate(msg.sender);\r\n    uint _dividends = (_ethereum.mul(userAverageDividendRate).div(100)).div(magnitude);\r\n    uint _taxedEthereum = _ethereum.sub(_dividends);\r\n    return _taxedEthereum;\r\n  }\r\n\r\n  /*\r\n   * Get's a user's average dividend rate - which is just their divTokenBalance / tokenBalance\r\n   * We multiply by magnitude to avoid precision errors.\r\n   */\r\n\r\n  function getUserAverageDividendRate(address user) public view returns (uint) {\r\n    return (magnitude * dividendTokenBalanceLedger_[user]).div(frontTokenBalanceLedger_[user]);\r\n  }\r\n\r\n  function getMyAverageDividendRate() public view returns (uint) {\r\n    return getUserAverageDividendRate(msg.sender);\r\n  }\r\n\r\n  /*==========================================\r\n  =            INTERNAL FUNCTIONS            =\r\n  ==========================================*/\r\n\r\n  /* Purchase tokens with Ether.\r\n     During ICO phase, dividends should go to the bankroll\r\n     During normal operation:\r\n       0.5% should go to the master dividend card\r\n       0.5% should go to the matching dividend card\r\n       25% of dividends should go to the referrer, if any is provided. */\r\n  function purchaseTokens(uint _incomingEthereum, address _referredBy)\r\n  internal\r\n  returns (uint)\r\n  {\r\n    require(_incomingEthereum >= MIN_ETH_BUYIN || msg.sender == bankrollAddress, \"Tried to buy below the min eth buyin threshold.\");\r\n\r\n    uint toBankRoll;\r\n    uint toReferrer;\r\n    uint toTokenHolders;\r\n    uint toDivCardHolders;\r\n\r\n    uint dividendAmount;\r\n\r\n    uint tokensBought;\r\n    uint dividendTokensBought;\r\n\r\n    uint remainingEth = _incomingEthereum;\r\n\r\n    uint fee;\r\n\r\n    // 1% for dividend card holders is taken off before anything else\r\n    if (regularPhase) {\r\n      toDivCardHolders = _incomingEthereum.div(100);\r\n      remainingEth = remainingEth.sub(toDivCardHolders);\r\n    }\r\n\r\n    /* Next, we tax for dividends:\r\n       Dividends = (ethereum * div%) / 100\r\n       Important note: if we're out of the ICO phase, the 1% sent to div-card holders\r\n                       is handled prior to any dividend taxes are considered. */\r\n\r\n    // Grab the user's dividend rate\r\n    uint dividendRate = userDividendRate[msg.sender];\r\n\r\n    // Calculate the total dividends on this buy\r\n    dividendAmount = (remainingEth.mul(dividendRate)).div(100);\r\n\r\n    remainingEth = remainingEth.sub(dividendAmount);\r\n\r\n    // If we're in the ICO and bankroll is buying, don't tax\r\n    if (icoPhase && msg.sender == bankrollAddress) {\r\n      remainingEth = remainingEth + dividendAmount;\r\n    }\r\n\r\n    // Calculate how many tokens to buy:\r\n    tokensBought = ethereumToTokens_(remainingEth);\r\n    dividendTokensBought = tokensBought.mul(dividendRate);\r\n\r\n    // This is where we actually mint tokens:\r\n    tokenSupply = tokenSupply.add(tokensBought);\r\n    divTokenSupply = divTokenSupply.add(dividendTokensBought);\r\n\r\n    /* Update the total investment tracker\r\n       Note that this must be done AFTER we calculate how many tokens are bought -\r\n       because ethereumToTokens needs to know the amount *before* investment, not *after* investment. */\r\n\r\n    currentEthInvested = currentEthInvested + remainingEth;\r\n\r\n    // If ICO phase, all the dividends go to the bankroll\r\n    if (icoPhase) {\r\n      toBankRoll = dividendAmount;\r\n\r\n      // If the bankroll is buying, we don't want to send eth back to the bankroll\r\n      // Instead, let's just give it the tokens it would get in an infinite recursive buy\r\n      if (msg.sender == bankrollAddress) {\r\n        toBankRoll = 0;\r\n      }\r\n\r\n      toReferrer = 0;\r\n      toTokenHolders = 0;\r\n\r\n      /* ethInvestedDuringICO tracks how much Ether goes straight to tokens,\r\n         not how much Ether we get total.\r\n         this is so that our calculation using \"investment\" is accurate. */\r\n      ethInvestedDuringICO = ethInvestedDuringICO + remainingEth;\r\n      tokensMintedDuringICO = tokensMintedDuringICO + tokensBought;\r\n\r\n      // Cannot purchase more than the hard cap during ICO.\r\n      require(ethInvestedDuringICO <= icoHardCap);\r\n      // Contracts aren't allowed to participate in the ICO.\r\n      require(tx.origin == msg.sender || msg.sender == bankrollAddress);\r\n\r\n      // Cannot purchase more then the limit per address during the ICO.\r\n      ICOBuyIn[msg.sender] += remainingEth;\r\n      //require(ICOBuyIn[msg.sender] <= addressICOLimit || msg.sender == bankrollAddress); // test:remove\r\n\r\n      // Stop the ICO phase if we reach the hard cap\r\n      if (ethInvestedDuringICO == icoHardCap) {\r\n        icoPhase = false;\r\n      }\r\n\r\n    } else {\r\n      // Not ICO phase, check for referrals\r\n\r\n      // 25% goes to referrers, if set\r\n      // toReferrer = (dividends * 25)/100\r\n      if (_referredBy != 0x0000000000000000000000000000000000000000 &&\r\n      _referredBy != msg.sender &&\r\n      frontTokenBalanceLedger_[_referredBy] >= stakingRequirement)\r\n      {\r\n        toReferrer = (dividendAmount.mul(referrer_percentage)).div(100);\r\n        referralBalance_[_referredBy] += toReferrer;\r\n        emit Referral(_referredBy, toReferrer);\r\n      }\r\n\r\n      // The rest of the dividends go to token holders\r\n      toTokenHolders = dividendAmount.sub(toReferrer);\r\n\r\n      fee = toTokenHolders * magnitude;\r\n      fee = fee - (fee - (dividendTokensBought * (toTokenHolders * magnitude / (divTokenSupply))));\r\n\r\n      // Finally, increase the divToken value\r\n      profitPerDivToken = profitPerDivToken.add((toTokenHolders.mul(magnitude)).div(divTokenSupply));\r\n      payoutsTo_[msg.sender] += (int256) ((profitPerDivToken * dividendTokensBought) - fee);\r\n    }\r\n\r\n    // Update the buyer's token amounts\r\n    frontTokenBalanceLedger_[msg.sender] = frontTokenBalanceLedger_[msg.sender].add(tokensBought);\r\n    dividendTokenBalanceLedger_[msg.sender] = dividendTokenBalanceLedger_[msg.sender].add(dividendTokensBought);\r\n\r\n    // Transfer to bankroll and div cards\r\n    if (toBankRoll != 0) {ZethrBankroll(bankrollAddress).receiveDividends.value(toBankRoll)();}\r\n    if (regularPhase) {divCardContract.receiveDividends.value(toDivCardHolders)(dividendRate);}\r\n\r\n    // This event should help us track where all the eth is going\r\n    emit Allocation(toBankRoll, toReferrer, toTokenHolders, toDivCardHolders, remainingEth);\r\n\r\n    // Sanity checking\r\n    uint sum = toBankRoll + toReferrer + toTokenHolders + toDivCardHolders + remainingEth - _incomingEthereum;\r\n    assert(sum == 0);\r\n  }\r\n\r\n  // How many tokens one gets from a certain amount of ethereum.\r\n  function ethereumToTokens_(uint _ethereumAmount)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    require(_ethereumAmount > MIN_ETH_BUYIN, \"Tried to buy tokens with too little eth.\");\r\n\r\n    if (icoPhase) {\r\n      return _ethereumAmount.div(tokenPriceInitial_) * 1e18;\r\n    }\r\n\r\n    /*\r\n     *  i = investment, p = price, t = number of tokens\r\n     *\r\n     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\r\n     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\r\n     *\r\n     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\r\n     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\r\n     */\r\n\r\n    // First, separate out the buy into two segments:\r\n    //  1) the amount of eth going towards ico-price tokens\r\n    //  2) the amount of eth going towards pyramid-price (variable) tokens\r\n    uint ethTowardsICOPriceTokens = 0;\r\n    uint ethTowardsVariablePriceTokens = 0;\r\n\r\n    if (currentEthInvested >= ethInvestedDuringICO) {\r\n      // Option One: All the ETH goes towards variable-price tokens\r\n      ethTowardsVariablePriceTokens = _ethereumAmount;\r\n\r\n    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount <= ethInvestedDuringICO) {\r\n      // Option Two: All the ETH goes towards ICO-price tokens\r\n      ethTowardsICOPriceTokens = _ethereumAmount;\r\n\r\n    } else if (currentEthInvested < ethInvestedDuringICO && currentEthInvested + _ethereumAmount > ethInvestedDuringICO) {\r\n      // Option Three: Some ETH goes towards ICO-price tokens, some goes towards variable-price tokens\r\n      ethTowardsICOPriceTokens = ethInvestedDuringICO.sub(currentEthInvested);\r\n      ethTowardsVariablePriceTokens = _ethereumAmount.sub(ethTowardsICOPriceTokens);\r\n    } else {\r\n      // Option Four: Should be impossible, and compiler should optimize it out of existence.\r\n      revert();\r\n    }\r\n\r\n    // Sanity check:\r\n    assert(ethTowardsICOPriceTokens + ethTowardsVariablePriceTokens == _ethereumAmount);\r\n\r\n    // Separate out the number of tokens of each type this will buy:\r\n    uint icoPriceTokens = 0;\r\n    uint varPriceTokens = 0;\r\n\r\n    // Now calculate each one per the above formulas.\r\n    // Note: since tokens have 18 decimals of precision we multiply the result by 1e18.\r\n    if (ethTowardsICOPriceTokens != 0) {\r\n      icoPriceTokens = ethTowardsICOPriceTokens.mul(1e18).div(tokenPriceInitial_);\r\n    }\r\n\r\n    if (ethTowardsVariablePriceTokens != 0) {\r\n      // Note: we can't use \"currentEthInvested\" for this calculation, we must use:\r\n      //  currentEthInvested + ethTowardsICOPriceTokens\r\n      // This is because a split-buy essentially needs to simulate two separate buys -\r\n      // including the currentEthInvested update that comes BEFORE variable price tokens are bought!\r\n\r\n      uint simulatedEthBeforeInvested = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3) + ethTowardsICOPriceTokens;\r\n      uint simulatedEthAfterInvested = simulatedEthBeforeInvested + ethTowardsVariablePriceTokens;\r\n\r\n      /* We have the equations for total tokens above; note that this is for TOTAL.\r\n         To get the number of tokens this purchase buys, use the simulatedEthInvestedBefore\r\n         and the simulatedEthInvestedAfter and calculate the difference in tokens.\r\n         This is how many we get. */\r\n\r\n      uint tokensBefore = toPowerOfTwoThirds(simulatedEthBeforeInvested.mul(3).div(2)).mul(MULTIPLIER);\r\n      uint tokensAfter = toPowerOfTwoThirds(simulatedEthAfterInvested.mul(3).div(2)).mul(MULTIPLIER);\r\n\r\n      /* Note that we could use tokensBefore = tokenSupply + icoPriceTokens instead of dynamically calculating tokensBefore;\r\n         either should work.\r\n\r\n         Investment IS already multiplied by 1e18; however, because this is taken to a power of (2/3),\r\n         we need to multiply the result by 1e6 to get back to the correct number of decimals. */\r\n\r\n      varPriceTokens = (1e6) * tokensAfter.sub(tokensBefore);\r\n    }\r\n\r\n    uint totalTokensReceived = icoPriceTokens + varPriceTokens;\r\n\r\n    assert(totalTokensReceived > 0);\r\n    return totalTokensReceived;\r\n  }\r\n\r\n  // How much Ether we get from selling N tokens\r\n  function tokensToEthereum_(uint _tokens)\r\n  public\r\n  view\r\n  returns (uint)\r\n  {\r\n    require(_tokens >= MIN_TOKEN_SELL_AMOUNT, \"Tried to sell too few tokens.\");\r\n\r\n    /*\r\n     *  i = investment, p = price, t = number of tokens\r\n     *\r\n     *  i_current = p_initial * t_current                   (for t_current <= t_initial)\r\n     *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial)\r\n     *\r\n     *  t_current = i_current / p_initial                   (for i_current <= i_initial)\r\n     *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial)\r\n     */\r\n\r\n    // First, separate out the sell into two segments:\r\n    //  1) the amount of tokens selling at the ICO price.\r\n    //  2) the amount of tokens selling at the variable (pyramid) price\r\n    uint tokensToSellAtICOPrice = 0;\r\n    uint tokensToSellAtVariablePrice = 0;\r\n\r\n    if (tokenSupply <= tokensMintedDuringICO) {\r\n      // Option One: All the tokens sell at the ICO price.\r\n      tokensToSellAtICOPrice = _tokens;\r\n\r\n    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens >= tokensMintedDuringICO) {\r\n      // Option Two: All the tokens sell at the variable price.\r\n      tokensToSellAtVariablePrice = _tokens;\r\n\r\n    } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens < tokensMintedDuringICO) {\r\n      // Option Three: Some tokens sell at the ICO price, and some sell at the variable price.\r\n      tokensToSellAtVariablePrice = tokenSupply.sub(tokensMintedDuringICO);\r\n      tokensToSellAtICOPrice = _tokens.sub(tokensToSellAtVariablePrice);\r\n\r\n    } else {\r\n      // Option Four: Should be impossible, and the compiler should optimize it out of existence.\r\n      revert();\r\n    }\r\n\r\n    // Sanity check:\r\n    assert(tokensToSellAtVariablePrice + tokensToSellAtICOPrice == _tokens);\r\n\r\n    // Track how much Ether we get from selling at each price function:\r\n    uint ethFromICOPriceTokens;\r\n    uint ethFromVarPriceTokens;\r\n\r\n    // Now, actually calculate:\r\n\r\n    if (tokensToSellAtICOPrice != 0) {\r\n\r\n      /* Here, unlike the sister equation in ethereumToTokens, we DON'T need to multiply by 1e18, since\r\n         we will be passed in an amount of tokens to sell that's already at the 18-decimal precision.\r\n         We need to divide by 1e18 or we'll have too much Ether. */\r\n\r\n      ethFromICOPriceTokens = tokensToSellAtICOPrice.mul(tokenPriceInitial_).div(1e18);\r\n    }\r\n\r\n    if (tokensToSellAtVariablePrice != 0) {\r\n\r\n      /* Note: Unlike the sister function in ethereumToTokens, we don't have to calculate any \"virtual\" token count.\r\n         This is because in sells, we sell the variable price tokens **first**, and then we sell the ICO-price tokens.\r\n         Thus there isn't any weird stuff going on with the token supply.\r\n\r\n         We have the equations for total investment above; note that this is for TOTAL.\r\n         To get the eth received from this sell, we calculate the new total investment after this sell.\r\n         Note that we divide by 1e6 here as the inverse of multiplying by 1e6 in ethereumToTokens. */\r\n\r\n      uint investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3);\r\n      uint investmentAfter = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3);\r\n\r\n      ethFromVarPriceTokens = investmentBefore.sub(investmentAfter);\r\n    }\r\n\r\n    uint totalEthReceived = ethFromVarPriceTokens + ethFromICOPriceTokens;\r\n\r\n    assert(totalEthReceived > 0);\r\n    return totalEthReceived;\r\n  }\r\n\r\n  function transferFromInternal(address _from, address _toAddress, uint _amountOfTokens, bytes _data)\r\n  internal\r\n  {\r\n    require(regularPhase);\r\n    require(_toAddress != address(0x0));\r\n    address _customerAddress = _from;\r\n    uint _amountOfFrontEndTokens = _amountOfTokens;\r\n\r\n    // Withdraw all outstanding dividends first (including those generated from referrals).\r\n    if (theDividendsOf(true, _customerAddress) > 0) withdrawFrom(_customerAddress);\r\n\r\n    // Calculate how many back-end dividend tokens to transfer.\r\n    // This amount is proportional to the caller's average dividend rate multiplied by the proportion of tokens being transferred.\r\n    uint _amountOfDivTokens = _amountOfFrontEndTokens.mul(getUserAverageDividendRate(_customerAddress)).div(magnitude);\r\n\r\n    if (_customerAddress != msg.sender) {\r\n      // Update the allowed balance.\r\n      // Don't update this if we are transferring our own tokens (via transfer or buyAndTransfer)\r\n      allowed[_customerAddress][msg.sender] -= _amountOfTokens;\r\n    }\r\n\r\n    // Exchange tokens\r\n    frontTokenBalanceLedger_[_customerAddress] = frontTokenBalanceLedger_[_customerAddress].sub(_amountOfFrontEndTokens);\r\n    frontTokenBalanceLedger_[_toAddress] = frontTokenBalanceLedger_[_toAddress].add(_amountOfFrontEndTokens);\r\n    dividendTokenBalanceLedger_[_customerAddress] = dividendTokenBalanceLedger_[_customerAddress].sub(_amountOfDivTokens);\r\n    dividendTokenBalanceLedger_[_toAddress] = dividendTokenBalanceLedger_[_toAddress].add(_amountOfDivTokens);\r\n\r\n    // Recipient inherits dividend percentage if they have not already selected one.\r\n    if (!userSelectedRate[_toAddress])\r\n    {\r\n      userSelectedRate[_toAddress] = true;\r\n      userDividendRate[_toAddress] = userDividendRate[_customerAddress];\r\n    }\r\n\r\n    // Update dividend trackers\r\n    payoutsTo_[_customerAddress] -= (int256) (profitPerDivToken * _amountOfDivTokens);\r\n    payoutsTo_[_toAddress] += (int256) (profitPerDivToken * _amountOfDivTokens);\r\n\r\n    uint length;\r\n\r\n    assembly {\r\n      length := extcodesize(_toAddress)\r\n    }\r\n\r\n    if (length > 0) {\r\n      // its a contract\r\n      // note: at ethereum update ALL addresses are contracts\r\n      ERC223Receiving receiver = ERC223Receiving(_toAddress);\r\n      receiver.tokenFallback(_from, _amountOfTokens, _data);\r\n    }\r\n\r\n    // Fire logging event.\r\n    emit Transfer(_customerAddress, _toAddress, _amountOfFrontEndTokens);\r\n  }\r\n\r\n  // Called from transferFrom. Always checks if _customerAddress has dividends.\r\n  function withdrawFrom(address _customerAddress)\r\n  internal\r\n  {\r\n    // Setup data\r\n    uint _dividends = theDividendsOf(false, _customerAddress);\r\n\r\n    // update dividend tracker\r\n    payoutsTo_[_customerAddress] += (int256) (_dividends * magnitude);\r\n\r\n    // add ref. bonus\r\n    _dividends += referralBalance_[_customerAddress];\r\n    referralBalance_[_customerAddress] = 0;\r\n\r\n    _customerAddress.transfer(_dividends);\r\n\r\n    // Fire logging event.\r\n    emit onWithdraw(_customerAddress, _dividends);\r\n  }\r\n\r\n\r\n  /*=======================\r\n   =    RESET FUNCTIONS   =\r\n   ======================*/\r\n\r\n  function injectEther()\r\n  public\r\n  payable\r\n  onlyAdministrator\r\n  {\r\n\r\n  }\r\n\r\n  /*=======================\r\n   =   MATHS FUNCTIONS    =\r\n   ======================*/\r\n\r\n  function toPowerOfThreeHalves(uint x) public pure returns (uint) {\r\n    // m = 3, n = 2\r\n    // sqrt(x^3)\r\n    return sqrt(x ** 3);\r\n  }\r\n\r\n  function toPowerOfTwoThirds(uint x) public pure returns (uint) {\r\n    // m = 2, n = 3\r\n    // cbrt(x^2)\r\n    return cbrt(x ** 2);\r\n  }\r\n\r\n  function sqrt(uint x) public pure returns (uint y) {\r\n    uint z = (x + 1) / 2;\r\n    y = x;\r\n    while (z < y) {\r\n      y = z;\r\n      z = (x / z + z) / 2;\r\n    }\r\n  }\r\n\r\n  function cbrt(uint x) public pure returns (uint y) {\r\n    uint z = (x + 1) / 3;\r\n    y = x;\r\n    while (z < y) {\r\n      y = z;\r\n      z = (x / (z * z) + 2 * z) / 3;\r\n    }\r\n  }\r\n}\r\n\r\n/*=======================\r\n =     INTERFACES       =\r\n ======================*/\r\n\r\ncontract ZethrBankroll {\r\n  function receiveDividends() public payable {}\r\n}\r\n\r\n// File: contracts/Games/JackpotHolding.sol\r\n\r\n/*\r\n*\r\n* Jackpot holding contract.\r\n*  \r\n* This accepts token payouts from a game for every player loss,\r\n* and on a win, pays out *half* of the jackpot to the winner.\r\n*\r\n* Jackpot payout should only be called from the game.\r\n*\r\n*/\r\ncontract JackpotHolding is ERC223Receiving {\r\n\r\n  /****************************\r\n   * FIELDS\r\n   ****************************/\r\n\r\n  // How many times we've paid out the jackpot\r\n  uint public payOutNumber = 0;\r\n\r\n  // The amount to divide the token balance by for a pay out (defaults to half the token balance)\r\n  uint public payOutDivisor = 2;\r\n\r\n  // Holds the bankroll controller info\r\n  ZethrBankrollControllerInterface controller;\r\n\r\n  // Zethr contract\r\n  Zethr zethr;\r\n\r\n  /****************************\r\n   * CONSTRUCTOR\r\n   ****************************/\r\n\r\n  constructor (address _controllerAddress, address _zethrAddress) public {\r\n    controller = ZethrBankrollControllerInterface(_controllerAddress);\r\n    zethr = Zethr(_zethrAddress);\r\n  }\r\n\r\n  function() public payable {}\r\n\r\n  function tokenFallback(address /*_from*/, uint /*_amountOfTokens*/, bytes/*_data*/)\r\n  public\r\n  returns (bool)\r\n  {\r\n    // Do nothing, we can track the jackpot by this balance\r\n  }\r\n\r\n  /****************************\r\n   * VIEWS\r\n   ****************************/\r\n  function getJackpotBalance()\r\n  public view\r\n  returns (uint)\r\n  {\r\n    // Half of this balance + half of jackpotBalance in each token bankroll\r\n    uint tempBalance;\r\n\r\n    for (uint i=0; i<7; i++) {\r\n      tempBalance += controller.tokenBankrolls(i).jackpotBalance() > 0 ? controller.tokenBankrolls(i).jackpotBalance() / payOutDivisor : 0;\r\n    }\r\n\r\n    tempBalance += zethr.balanceOf(address(this)) > 0 ? zethr.balanceOf(address(this)) / payOutDivisor : 0;\r\n\r\n    return tempBalance;\r\n  }\r\n\r\n  /****************************\r\n   * OWNER FUNCTIONS\r\n   ****************************/\r\n\r\n  /** @dev Sets the pay out divisor\r\n    * @param _divisor The value to set the new divisor to\r\n    */\r\n  function ownerSetPayOutDivisor(uint _divisor)\r\n  public\r\n  ownerOnly\r\n  {\r\n    require(_divisor != 0);\r\n\r\n    payOutDivisor = _divisor;\r\n  }\r\n\r\n  /** @dev Sets the address of the game controller\r\n    * @param _controllerAddress The new address of the controller\r\n    */\r\n  function ownerSetControllerAddress(address _controllerAddress)\r\n  public\r\n  ownerOnly\r\n  {\r\n    controller = ZethrBankrollControllerInterface(_controllerAddress);\r\n  }\r\n\r\n  /** @dev Transfers the jackpot to _to\r\n    * @param _to Address to send the jackpot tokens to\r\n    */\r\n  function ownerWithdrawZth(address _to)\r\n  public\r\n  ownerOnly\r\n  {\r\n    uint balance = zethr.balanceOf(address(this));\r\n    zethr.transfer(_to, balance);\r\n  }\r\n\r\n  /** @dev Transfers any ETH received from dividends to _to\r\n    * @param _to Address to send the ETH to\r\n    */\r\n  function ownerWithdrawEth(address _to)\r\n  public\r\n  ownerOnly\r\n  {\r\n    _to.transfer(address(this).balance);\r\n  }\r\n\r\n  /****************************\r\n   * GAME FUNCTIONS\r\n   ****************************/\r\n\r\n  function gamePayOutWinner(address _winner)\r\n  public\r\n  gameOnly\r\n  {\r\n    // Call the payout function on all 7 token bankrolls\r\n    for (uint i=0; i<7; i++) {\r\n      controller.tokenBankrolls(i).payJackpotToWinner(_winner, payOutDivisor);\r\n    }\r\n\r\n    uint payOutAmount;\r\n\r\n    // Calculate pay out & pay out\r\n    if (zethr.balanceOf(address(this)) >= 1e10) {\r\n      payOutAmount = zethr.balanceOf(address(this)) / payOutDivisor;\r\n    }\r\n\r\n    if (payOutAmount >= 1e10) {\r\n      zethr.transfer(_winner, payOutAmount);\r\n    }\r\n\r\n    // Increment the statistics fields\r\n    payOutNumber += 1;\r\n\r\n    // Emit jackpot event\r\n    emit JackpotPayOut(_winner, payOutNumber);\r\n  }\r\n\r\n  /****************************\r\n   * EVENTS\r\n   ****************************/\r\n\r\n  event JackpotPayOut(\r\n    address winner,\r\n    uint payOutNumber\r\n  );\r\n\r\n  /****************************\r\n   * MODIFIERS\r\n   ****************************/\r\n\r\n  // Only an owner can call this method (controller is always an owner)\r\n  modifier ownerOnly()\r\n  {\r\n    require(msg.sender == address(controller) || controller.multiSigWallet().isOwner(msg.sender));\r\n    _;\r\n  }\r\n\r\n  // Only a game can call this method\r\n  modifier gameOnly()\r\n  {\r\n    require(controller.validGameAddresses(msg.sender));\r\n    _;\r\n  }\r\n}\r\n\r\n// File: contracts/Bankroll/ZethrGame.sol\r\n\r\n/* Zethr Game Interface\r\n *\r\n * Contains the necessary functions to integrate with\r\n * the Zethr Token bankrolls & the Zethr game ecosystem.\r\n *\r\n * Token Bankroll Functions:\r\n *  - execute\r\n *\r\n * Player Functions:\r\n *  - finish\r\n *\r\n * Bankroll Controller / Owner Functions:\r\n *  - pauseGame\r\n *  - resumeGame\r\n *  - set resolver percentage\r\n *  - set controller address\r\n *\r\n * Player/Token Bankroll Functions:\r\n *  - resolvePendingBets\r\n*/\r\ncontract ZethrGame {\r\n  using SafeMath for uint;\r\n  using SafeMath for uint56;\r\n\r\n  // Default events:\r\n  event Result (address player, uint amountWagered, int amountOffset);\r\n  event Wager (address player, uint amount, bytes data);\r\n\r\n  // Queue of pending/unresolved bets\r\n  address[] pendingBetsQueue;\r\n  uint queueHead = 0;\r\n  uint queueTail = 0;\r\n\r\n  // Store each player's latest bet via mapping\r\n  mapping(address => BetBase) bets;\r\n\r\n  // Bet structures must start with this layout\r\n  struct BetBase {\r\n    // Must contain these in this order\r\n    uint56 tokenValue;    // Multiply by 1e14 to get tokens\r\n    uint48 blockNumber;\r\n    uint8 tier;\r\n    // Game specific structures can add more after this\r\n  }\r\n\r\n  // Mapping of addresses to their *position* in the queue\r\n  // Zero = they aren't in the queue\r\n  mapping(address => uint) pendingBetsMapping;\r\n\r\n  // Holds the bankroll controller info\r\n  ZethrBankrollControllerInterface controller;\r\n\r\n  // Is the game paused?\r\n  bool paused;\r\n\r\n  // Minimum bet should always be >= 1\r\n  uint minBet = 1e18;\r\n\r\n  // Percentage that a resolver gets when he resolves bets for the house\r\n  uint resolverPercentage;\r\n\r\n  // Every game has a name\r\n  string gameName;\r\n\r\n  constructor (address _controllerAddress, uint _resolverPercentage, string _name) public {\r\n    controller = ZethrBankrollControllerInterface(_controllerAddress);\r\n    resolverPercentage = _resolverPercentage;\r\n    gameName = _name;\r\n  }\r\n\r\n  /** @dev Gets the max profit of this game as decided by the token bankroll\r\n    * @return uint The maximum profit\r\n    */\r\n  function getMaxProfit()\r\n  public view\r\n  returns (uint)\r\n  {\r\n    return ZethrTokenBankrollInterface(msg.sender).getMaxProfit(address(this));\r\n  }\r\n\r\n  /** @dev Pauses the game, preventing anyone from placing bets\r\n    */\r\n  function ownerPauseGame()\r\n  public\r\n  ownerOnly\r\n  {\r\n    paused = true;\r\n  }\r\n\r\n  /** @dev Resumes the game, allowing bets\r\n    */\r\n  function ownerResumeGame()\r\n  public\r\n  ownerOnly\r\n  {\r\n    paused = false;\r\n  }\r\n\r\n  /** @dev Sets the percentage of the bets that a resolver gets when resolving tokens.\r\n    * @param _percentage The percentage as x/1,000,000 that the resolver gets\r\n    */\r\n  function ownerSetResolverPercentage(uint _percentage)\r\n  public\r\n  ownerOnly\r\n  {\r\n    require(_percentage <= 1000000);\r\n    resolverPercentage = _percentage;\r\n  }\r\n\r\n  /** @dev Sets the address of the game controller\r\n    * @param _controllerAddress The new address of the controller\r\n    */\r\n  function ownerSetControllerAddress(address _controllerAddress)\r\n  public\r\n  ownerOnly\r\n  {\r\n    controller = ZethrBankrollControllerInterface(_controllerAddress);\r\n  }\r\n\r\n  // Every game should have a name\r\n  /** @dev Sets the name of the game\r\n    * @param _name The name of the game\r\n    */\r\n  function ownerSetGameName(string _name)\r\n  ownerOnly\r\n  public\r\n  {\r\n    gameName = _name;\r\n  }\r\n\r\n  /** @dev Gets the game name\r\n    * @return The name of the game\r\n    */\r\n  function getGameName()\r\n  public view\r\n  returns (string)\r\n  {\r\n    return gameName;\r\n  }\r\n\r\n  /** @dev Resolve expired bets in the queue. Gives a percentage of the house edge to the resolver as ZTH\r\n    * @param _numToResolve The number of bets to resolve.\r\n    * @return tokensEarned The number of tokens earned\r\n    * @return queueHead The new head of the queue\r\n    */\r\n  function resolveExpiredBets(uint _numToResolve)\r\n  public\r\n  returns (uint tokensEarned_, uint queueHead_)\r\n  {\r\n    uint mQueue = queueHead;\r\n    uint head;\r\n    uint tail = (mQueue + _numToResolve) > pendingBetsQueue.length ? pendingBetsQueue.length : (mQueue + _numToResolve);\r\n    uint tokensEarned = 0;\r\n\r\n    for (head = mQueue; head < tail; head++) {\r\n      // Check the head of the queue to see if there is a resolvable bet\r\n      // This means the bet at the queue head is older than 255 blocks AND is not 0\r\n      // (However, if the address at the head is null, skip it, it's already been resolved)\r\n      if (pendingBetsQueue[head] == address(0x0)) {\r\n        continue;\r\n      }\r\n\r\n      if (bets[pendingBetsQueue[head]].blockNumber != 0 && block.number > 256 + bets[pendingBetsQueue[head]].blockNumber) {\r\n        // Resolve the bet\r\n        // finishBetfrom returns the *player* profit\r\n        // this will be negative if the player lost and the house won\r\n        // so flip it to get the house profit, if any\r\n        int sum = - finishBetFrom(pendingBetsQueue[head]);\r\n\r\n        // Tokens earned is a percentage of the loss\r\n        if (sum > 0) {\r\n          tokensEarned += (uint(sum).mul(resolverPercentage)).div(1000000);\r\n        }\r\n\r\n        // Queue-tail is always the \"next\" open spot, so queue head and tail will never overlap\r\n      } else {\r\n        // If we can't resolve a bet, stop going down the queue\r\n        break;\r\n      }\r\n    }\r\n\r\n    queueHead = head;\r\n\r\n    // Send the earned tokens to the resolver\r\n    if (tokensEarned >= 1e14) {\r\n      controller.gamePayoutResolver(msg.sender, tokensEarned);\r\n    }\r\n\r\n    return (tokensEarned, head);\r\n  }\r\n\r\n  /** @dev Finishes the bet of the sender, if it exists.\r\n    * @return int The total profit (positive or negative) earned by the sender\r\n    */\r\n  function finishBet()\r\n  public\r\n  hasNotBetThisBlock(msg.sender)\r\n  returns (int)\r\n  {\r\n    return finishBetFrom(msg.sender);\r\n  }\r\n\r\n  /** @dev Resturns a random number\r\n    * @param _blockn The block number to base the random number off of\r\n    * @param _entropy Data to use in the random generation\r\n    * @param _index Data to use in the random generation\r\n    * @return randomNumber The random number to return\r\n    */\r\n  function maxRandom(uint _blockn, address _entropy, uint _index)\r\n  private view\r\n  returns (uint256 randomNumber)\r\n  {\r\n    return uint256(keccak256(\r\n        abi.encodePacked(\r\n          blockhash(_blockn),\r\n          _entropy,\r\n          _index\r\n        )));\r\n  }\r\n\r\n  /** @dev Returns a random number\r\n    * @param _upper The upper end of the range, exclusive\r\n    * @param _blockn The block number to use for the random number\r\n    * @param _entropy An address to be used for entropy\r\n    * @param _index A number to get the next random number\r\n    * @return randomNumber The random number\r\n    */\r\n  function random(uint256 _upper, uint256 _blockn, address _entropy, uint _index)\r\n  internal view\r\n  returns (uint256 randomNumber)\r\n  {\r\n    return maxRandom(_blockn, _entropy, _index) % _upper;\r\n  }\r\n\r\n  // Prevents the user from placing two bets in one block\r\n  modifier hasNotBetThisBlock(address _sender)\r\n  {\r\n    require(bets[_sender].blockNumber != block.number);\r\n    _;\r\n  }\r\n\r\n  // Requires that msg.sender is one of the token bankrolls\r\n  modifier bankrollOnly {\r\n    require(controller.isTokenBankroll(msg.sender));\r\n    _;\r\n  }\r\n\r\n  // Requires that the game is not paused\r\n  modifier isNotPaused {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  // Requires that the bet given has max profit low enough\r\n  modifier betIsValid(uint _betSize, uint _tier, bytes _data) {\r\n    uint divRate = ZethrTierLibrary.getDivRate(_tier);\r\n    require(isBetValid(_betSize, divRate, _data));\r\n    _;\r\n  }\r\n\r\n  // Only an owner can call this method (controller is always an owner)\r\n  modifier ownerOnly()\r\n  {\r\n    require(msg.sender == address(controller) || controller.multiSigWallet().isOwner(msg.sender));\r\n    _;\r\n  }\r\n\r\n  /** @dev Places a bet. Callable only by token bankrolls\r\n    * @param _player The player that is placing the bet\r\n    * @param _tokenCount The total number of tokens bet\r\n    * @param _divRate The dividend rate of the player\r\n    * @param _data The game-specific data, encoded in bytes-form\r\n    */\r\n  function execute(address _player, uint _tokenCount, uint _divRate, bytes _data) public;\r\n\r\n  /** @dev Resolves the bet of the supplied player.\r\n    * @param _playerAddress The address of the player whos bet we are resolving\r\n    * @return int The total profit the player earned, positive or negative\r\n    */\r\n  function finishBetFrom(address _playerAddress) internal returns (int);\r\n\r\n  /** @dev Determines if a supplied bet is valid\r\n    * @param _tokenCount The total number of tokens bet\r\n    * @param _divRate The dividend rate of the bet\r\n    * @param _data The game-specific bet data\r\n    * @return bool Whether or not the bet is valid\r\n    */\r\n  function isBetValid(uint _tokenCount, uint _divRate, bytes _data) public view returns (bool);\r\n}\r\n\r\n// File: contracts/Games/ZethrBigWheel.sol\r\n\r\n/* The actual game contract.\r\n *\r\n * This contract contains the actual game logic,\r\n * including placing bets (execute), resolving bets,\r\n * and resolving expired bets.\r\n*/\r\ncontract ZethrBigWheel is ZethrGame {\r\n  using SafeMath for uint8;\r\n\r\n  /****************************\r\n   * GAME SPECIFIC\r\n   ****************************/\r\n\r\n  // Slots-specific bet structure\r\n  struct Bet {\r\n    // Must contain these in this order\r\n    uint56 tokenValue;\r\n    uint48 blockNumber;\r\n    uint8 tier;\r\n    // Game specific\r\n    uint bets; // this is actually a uint40[5] array but because solidity fucks us over with storage writes we will explicitly convert this for solidity so we write to a single storage ONCE not 5 times\r\n  }\r\n\r\n  /****************************\r\n   * FIELDS\r\n   ****************************/\r\n\r\n  // The holding contract for jackpot tokens\r\n  JackpotHolding public jackpotHoldingContract;\r\n\r\n  /****************************\r\n   * CONSTRUCTOR\r\n   ****************************/\r\n\r\n  constructor (address _controllerAddress, uint _resolverPercentage, string _name)\r\n  ZethrGame(_controllerAddress, _resolverPercentage, _name)\r\n  public\r\n  {\r\n  }\r\n\r\n  /****************************\r\n   * USER METHODS\r\n   ****************************/\r\n\r\n  /** @dev Retrieve the results of the last spin of a plyer, for web3 calls.\r\n    * @param _playerAddress The address of the player\r\n    */\r\n  function getLastSpinOutput(address _playerAddress)\r\n  public view\r\n  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins, uint output)\r\n  {\r\n    // Cast to Bet and read from storage\r\n    Bet storage playerBetInStorage = getBet(_playerAddress);\r\n    Bet memory playerBet = playerBetInStorage;\r\n\r\n    // Safety check\r\n    require(playerBet.blockNumber != 0);\r\n\r\n    (winAmount, lossAmount, jackpotAmount, jackpotWins, output) = getSpinOutput(playerBet.blockNumber, _playerAddress, playerBet.bets);\r\n\r\n    return (winAmount, lossAmount, jackpotAmount, jackpotWins, output);\r\n  }\r\n\r\n  /** @dev Retrieve the results of the spin, for web3 calls.\r\n    * @param _blockNumber The block number of the spin\r\n    * @param _target The address of the better\r\n    * @param _bets_notconverted Array (declared as uint as read from storage) of bets to place on x2,4x,8x,12x,24x\r\n    * @return winAmount The total number of tokens won\r\n    * @return lossAmount The total number of tokens lost\r\n    * @return jackpotAmount The total amount of tokens won in the jackpot\r\n    * @return output An array of all of the results of a multispin\r\n    */\r\n  function getSpinOutput(uint _blockNumber, address _target, uint _bets_notconverted)\r\n  public view\r\n  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins, uint output)\r\n  {\r\n    uint40[5] memory _bets = uintToBetsArray(_bets_notconverted);\r\n    // If the block is more than 255 blocks old, we can't get the result\r\n    uint result;\r\n    if (block.number - _blockNumber > 255) {\r\n      // Can't win: default to an impossible number\r\n      result = 999997;\r\n    } else {\r\n      // Generate a result - random based ONLY on a past block (future when submitted).\r\n      result = random(999996, _blockNumber, _target, 0) + 1;\r\n    }\r\n\r\n    uint[5] memory betsMul;\r\n    betsMul[0] = uint(_bets[0]).mul(1e14);\r\n    betsMul[1] = uint(_bets[1]).mul(1e14);\r\n    betsMul[2] = uint(_bets[2]).mul(1e14);\r\n    betsMul[3] = uint(_bets[3]).mul(1e14);\r\n    betsMul[4] = uint(_bets[4]).mul(1e14);\r\n\r\n    lossAmount = betsMul[0] + betsMul[1] + betsMul[2] + betsMul[3] + betsMul[4];\r\n\r\n    // Result is between 1 and 999996\r\n    // 1        -   1         Jackpot \r\n    // 2        -   27027     25x   \r\n    // 27028    -   108107    10x   \r\n    // 108108   -   270269    6x     \r\n    // 270270   -   513511    4x   \r\n    // 513512   -   999996    2x        \r\n\r\n    if (result < 2) {\r\n      jackpotWins++;\r\n    } else {\r\n      if (result < 27028) {\r\n        if (betsMul[4] > 0) {\r\n          // Player has won the 25x multiplier category!\r\n          winAmount = SafeMath.mul(betsMul[4], 25);\r\n          lossAmount -= betsMul[4];\r\n        }\r\n      } else if (result < 108108) {\r\n        if (betsMul[3] > 0) {\r\n          // Player has won the 10x multiplier category!\r\n          winAmount = SafeMath.mul(betsMul[3], 10);\r\n          lossAmount -= betsMul[3];\r\n        }\r\n      } else if (result < 270269) {\r\n        if (betsMul[2] > 0) {\r\n          // Player has won the 6x multiplier category!\r\n          winAmount = SafeMath.mul(betsMul[2], 6);\r\n          lossAmount -= betsMul[2];\r\n        }\r\n      } else if (result < 513512) {\r\n        if (betsMul[1] > 0) {\r\n          // Player has won the 4x multiplier category!\r\n          winAmount = SafeMath.mul(betsMul[1], 4);\r\n          lossAmount -= betsMul[1];\r\n        }\r\n      } else if (result < 999997) {\r\n        if (betsMul[0] > 0) {\r\n          // Player has won the 2x multiplier category!\r\n          winAmount = SafeMath.mul(betsMul[0], 2);\r\n          lossAmount -= betsMul[0];\r\n        }\r\n      }\r\n\r\n      jackpotAmount = lossAmount.div(100);\r\n      lossAmount -= jackpotAmount;\r\n    }\r\n\r\n    return (winAmount, lossAmount, jackpotAmount, jackpotWins, result);\r\n  }\r\n\r\n  /** @dev Retrieve the results of the spin, for contract calls.\r\n    * @param _blockNumber The block number of the spin\r\n    * @param _target The address of the better\r\n    * @param _bets Array of bets to place on x2,4x,8x,12x,24x\r\n    * @return winAmount The total number of tokens won\r\n    * @return lossAmount The total number of tokens lost\r\n    * @return jackpotAmount The total amount of tokens won in the jackpot\r\n    */\r\n  function getSpinResults(uint _blockNumber, address _target, uint _bets)\r\n  public\r\n  returns (uint winAmount, uint lossAmount, uint jackpotAmount, uint jackpotWins)\r\n  {\r\n    (winAmount, lossAmount, jackpotAmount, jackpotWins,) = getSpinOutput(_blockNumber, _target, _bets);\r\n  }\r\n\r\n  /****************************\r\n   * OWNER METHODS\r\n   ****************************/\r\n\r\n  /** @dev Set the address of the jackpot contract\r\n    * @param _jackpotAddress The address of the jackpot contract\r\n    */\r\n  function ownerSetJackpotAddress(address _jackpotAddress)\r\n  public\r\n  ownerOnly\r\n  {\r\n    jackpotHoldingContract = JackpotHolding(_jackpotAddress);\r\n  }\r\n\r\n  /****************************\r\n   * INTERNALS\r\n   ****************************/\r\n\r\n  /** @dev Returs the bet struct of a player\r\n    * @param _playerAddress The address of the player\r\n    * @return Bet The bet of the player\r\n    */\r\n  function getBet(address _playerAddress)\r\n  internal view\r\n  returns (Bet storage)\r\n  {\r\n    // Cast BetBase to Bet\r\n    BetBase storage betBase = bets[_playerAddress];\r\n\r\n    Bet storage playerBet;\r\n    assembly {\r\n    // tmp is pushed onto stack and points to betBase slot in storage\r\n      let tmp := betBase_slot\r\n\r\n    // swap1 swaps tmp and playerBet pointers\r\n      swap1\r\n    }\r\n    // tmp is popped off the stack\r\n\r\n    // playerBet now points to betBase\r\n    return playerBet;\r\n  }\r\n\r\n  /** @dev Resturns a random number\r\n    * @param _blockn The block number to base the random number off of\r\n    * @param _entropy Data to use in the random generation\r\n    * @param _index Data to use in the random generation\r\n    * @return randomNumber The random number to return\r\n    */\r\n  function maxRandom(uint _blockn, address _entropy, uint _index)\r\n  private view\r\n  returns (uint256 randomNumber)\r\n  {\r\n    return uint256(keccak256(\r\n        abi.encodePacked(\r\n          blockhash(_blockn),\r\n          _entropy,\r\n          _index\r\n        )));\r\n  }\r\n\r\n  /** @dev Returns a random number\r\n    * @param _upper The upper end of the range, exclusive\r\n    * @param _blockn The block number to use for the random number\r\n    * @param _entropy An address to be used for entropy\r\n    * @param _index A number to get the next random number\r\n    * @return randomNumber The random number\r\n    */\r\n  function random(uint256 _upper, uint256 _blockn, address _entropy, uint _index)\r\n  internal view\r\n  returns (uint256 randomNumber)\r\n  {\r\n    return maxRandom(_blockn, _entropy, _index) % _upper;\r\n  }\r\n\r\n  /****************************\r\n   * OVERRIDDEN METHODS\r\n   ****************************/\r\n\r\n  /** @dev Resolves the bet of the supplied player.\r\n    * @param _playerAddress The address of the player whos bet we are resolving\r\n    * @return totalProfit The total profit the player earned, positive or negative\r\n    */\r\n  function finishBetFrom(address _playerAddress)\r\n  internal\r\n  returns (int /*totalProfit*/)\r\n  {\r\n    // Memory vars to hold data as we compute it\r\n    uint winAmount;\r\n    uint lossAmount;\r\n    uint jackpotAmount;\r\n    uint jackpotWins;\r\n\r\n    // Cast to Bet and read from storage\r\n    Bet storage playerBetInStorage = getBet(_playerAddress);\r\n    Bet memory playerBet = playerBetInStorage;\r\n\r\n    // Player should not be able to resolve twice!\r\n    require(playerBet.blockNumber != 0);\r\n\r\n    // Safety check\r\n    require(playerBet.blockNumber != 0);\r\n    playerBetInStorage.blockNumber = 0;\r\n\r\n    // Iterate over the number of spins and calculate totals:\r\n    //  - player win amount\r\n    //  - bankroll win amount\r\n    //  - jackpot wins\r\n    (winAmount, lossAmount, jackpotAmount, jackpotWins) = getSpinResults(playerBet.blockNumber, _playerAddress, playerBet.bets);\r\n\r\n    // Figure out the token bankroll address\r\n    address tokenBankrollAddress = controller.getTokenBankrollAddressFromTier(playerBet.tier);\r\n    ZethrTokenBankrollInterface bankroll = ZethrTokenBankrollInterface(tokenBankrollAddress);\r\n\r\n    // Call into the bankroll to do some token accounting\r\n    bankroll.gameTokenResolution(winAmount, _playerAddress, jackpotAmount, address(jackpotHoldingContract), playerBet.tokenValue.mul(1e14));\r\n\r\n    // Pay out jackpot if won\r\n    if (jackpotWins > 0) {\r\n      for (uint x = 0; x < jackpotWins; x++) {\r\n        jackpotHoldingContract.gamePayOutWinner(_playerAddress);\r\n      }\r\n    }\r\n\r\n    // Grab the position of the player in the pending bets queue\r\n    uint index = pendingBetsMapping[_playerAddress];\r\n\r\n    // Remove the player from the pending bets queue by setting the address to 0x0\r\n    pendingBetsQueue[index] = address(0x0);\r\n\r\n    // Delete the player's bet by setting the mapping to zero\r\n    pendingBetsMapping[_playerAddress] = 0;\r\n\r\n    emit Result(_playerAddress, playerBet.tokenValue.mul(1e14), int(winAmount) - int(lossAmount) - int(jackpotAmount));\r\n\r\n    // Return all bet results + total *player* profit\r\n    return (int(winAmount) - int(lossAmount) - int(jackpotAmount));\r\n  }\r\n\r\n  /** @dev Places a bet. Callable only by token bankrolls\r\n    * @param _player The player that is placing the bet\r\n    * @param _tokenCount The total number of tokens bet\r\n    * @param _tier The div rate tier the player falls in\r\n    * @param _data The game-specific data, encoded in bytes-form\r\n    */\r\n  function execute(address _player, uint _tokenCount, uint _tier, bytes _data)\r\n  isNotPaused\r\n  bankrollOnly\r\n  betIsValid(_tokenCount, _tier, _data)\r\n  hasNotBetThisBlock(_player)\r\n  public\r\n  {\r\n    Bet storage playerBet = getBet(_player);\r\n\r\n    // Check for a player bet and resolve if necessary\r\n    if (playerBet.blockNumber != 0) {\r\n      finishBetFrom(_player);\r\n    }\r\n\r\n    // Set bet information\r\n    playerBet.tokenValue = uint56(_tokenCount.div(1e14));\r\n    playerBet.blockNumber = uint48(block.number);\r\n    playerBet.tier = uint8(_tier);\r\n    \r\n    require(_data.length == 32);\r\n    \r\n    uint actual_data;\r\n    \r\n    assembly{\r\n        actual_data := mload(add(_data, 0x20))\r\n    }\r\n    \r\n    playerBet.bets = actual_data;\r\n\r\n    uint40[5] memory actual_bets = uintToBetsArray(actual_data);\r\n\r\n    // Sum of all bets should be the amount of tokens transferred\r\n    require((uint(actual_bets[0]) + uint(actual_bets[1]) + uint(actual_bets[2]) + uint(actual_bets[3]) + uint(actual_bets[4])).mul(1e14) == _tokenCount);\r\n\r\n    // Add player to the pending bets queue\r\n    pendingBetsQueue.length++;\r\n    pendingBetsQueue[queueTail] = _player;\r\n    queueTail++;\r\n\r\n    // Add the player's position in the queue to the pending bets mapping\r\n    pendingBetsMapping[_player] = queueTail - 1;\r\n\r\n    // Emit event\r\n    emit Wager(_player, _tokenCount, _data);\r\n  }\r\n\r\n  /** @dev Determines if a supplied bet is valid\r\n    * @param _tokenCount The total number of tokens bet\r\n    * @param _divRate The dividend rate of the bet\r\n    * @param _data The game-specific bet data\r\n    * @return bool Whether or not the bet is valid\r\n    */\r\n  function isBetValid(uint _tokenCount, uint _divRate, bytes _data)\r\n  public view\r\n  returns (bool)\r\n  {\r\n    uint actual_data;\r\n    \r\n    assembly{\r\n        actual_data := mload(add(_data, 0x20))\r\n    }\r\n\r\n    uint40[5] memory bets = uintToBetsArray(actual_data);\r\n    uint bet2Max = bets[0] * 2;\r\n    uint bet4Max = bets[1] * 4;\r\n    uint bet6Max = bets[2] * 6;\r\n    uint bet10Max = bets[3] * 10;\r\n    uint bet25Max = bets[4] * 25;\r\n\r\n    uint max = bet2Max;\r\n\r\n    if (bet4Max > max) {\r\n      max = bet4Max;\r\n    }\r\n\r\n    if (bet6Max > max) {\r\n      max = bet6Max;\r\n    }\r\n\r\n    if (bet10Max > max) {\r\n      max = bet10Max;\r\n    }\r\n\r\n    if (bet25Max > max) {\r\n      max = bet25Max;\r\n    }\r\n\r\n    uint minBetDiv = minBet.div(1e14);\r\n\r\n    return (max*1e14 <= getMaxProfit())\r\n    && ((bets[0]) >= minBetDiv || (bets[0]) == 0)\r\n    && ((bets[1]) >= minBetDiv || (bets[1]) == 0)\r\n    && ((bets[2]) >= minBetDiv || (bets[2]) == 0)\r\n    && ((bets[3]) >= minBetDiv || (bets[3]) == 0)\r\n    && ((bets[4]) >= minBetDiv || (bets[4]) == 0);\r\n  }\r\n  \r\n  \r\n  function betInputToBytes(uint40 bet1, uint40 bet2, uint40 bet3, uint40 bet4, uint40 bet5) public view returns (bytes32){\r\n    bytes memory concat = (abi.encodePacked(uint56(0), bet1, bet2, bet3, bet4, bet5));\r\n    bytes32 output;\r\n        \r\n    assembly{\r\n      output := mload(add(concat, 0x20))\r\n    }\r\n    return output;\r\n  }\r\n  \r\n  function uintToBetsArray(uint input) public view returns (uint40[5]){\r\n    uint40[5] memory output;\r\n    uint trackme = (input);\r\n    for (uint i=4;; i--){\r\n      output[i] = uint40(trackme); // auto take the last 40 bits in memory \r\n      trackme /= 0x0000000000000000000000000000000000000000000000000000010000000000; // left shift 40 bits \r\n      if (i==0){\r\n        break;\r\n      }\r\n    }\r\n    return output;     \r\n  }\r\n  \r\n  function getPlayerBetData(address player) public view returns(uint40[5]){\r\n      uint betData = getBet(player).bets;\r\n      return (uintToBetsArray(betData));\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_bets\",\"type\":\"uint256\"}],\"name\":\"getSpinResults\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"lossAmount\",\"type\":\"uint256\"},{\"name\":\"jackpotAmount\",\"type\":\"uint256\"},{\"name\":\"jackpotWins\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotHoldingContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_percentage\",\"type\":\"uint256\"}],\"name\":\"ownerSetResolverPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerPauseGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"getLastSpinOutput\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"lossAmount\",\"type\":\"uint256\"},{\"name\":\"jackpotAmount\",\"type\":\"uint256\"},{\"name\":\"jackpotWins\",\"type\":\"uint256\"},{\"name\":\"output\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"ownerResumeGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_numToResolve\",\"type\":\"uint256\"}],\"name\":\"resolveExpiredBets\",\"outputs\":[{\"name\":\"tokensEarned_\",\"type\":\"uint256\"},{\"name\":\"queueHead_\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"ownerSetGameName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_blockNumber\",\"type\":\"uint256\"},{\"name\":\"_target\",\"type\":\"address\"},{\"name\":\"_bets_notconverted\",\"type\":\"uint256\"}],\"name\":\"getSpinOutput\",\"outputs\":[{\"name\":\"winAmount\",\"type\":\"uint256\"},{\"name\":\"lossAmount\",\"type\":\"uint256\"},{\"name\":\"jackpotAmount\",\"type\":\"uint256\"},{\"name\":\"jackpotWins\",\"type\":\"uint256\"},{\"name\":\"output\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"},{\"name\":\"_tokenCount\",\"type\":\"uint256\"},{\"name\":\"_tier\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishBet\",\"outputs\":[{\"name\":\"\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"input\",\"type\":\"uint256\"}],\"name\":\"uintToBetsArray\",\"outputs\":[{\"name\":\"\",\"type\":\"uint40[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_controllerAddress\",\"type\":\"address\"}],\"name\":\"ownerSetControllerAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"player\",\"type\":\"address\"}],\"name\":\"getPlayerBetData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint40[5]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenCount\",\"type\":\"uint256\"},{\"name\":\"_divRate\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"isBetValid\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"bet1\",\"type\":\"uint40\"},{\"name\":\"bet2\",\"type\":\"uint40\"},{\"name\":\"bet3\",\"type\":\"uint40\"},{\"name\":\"bet4\",\"type\":\"uint40\"},{\"name\":\"bet5\",\"type\":\"uint40\"}],\"name\":\"betInputToBytes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMaxProfit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_jackpotAddress\",\"type\":\"address\"}],\"name\":\"ownerSetJackpotAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_controllerAddress\",\"type\":\"address\"},{\"name\":\"_resolverPercentage\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountWagered\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountOffset\",\"type\":\"int256\"}],\"name\":\"Result\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Wager\",\"type\":\"event\"}]","ContractName":"ZethrBigWheel","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008ad129fa24f169f3dd06e67bb1e795d57c7d83e700000000000000000000000000000000000000000000000000000000000000640000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000942696720576865656c0000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://443fcd76f4e5431f2402066a78c3ab9a15e9c2ab58efcdf83afd8294a4aa136c"}]}