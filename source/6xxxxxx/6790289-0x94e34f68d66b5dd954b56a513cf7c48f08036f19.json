{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath8 {\r\n\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint8 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint8 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath16 {\r\n\r\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint16 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        uint16 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint16 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath32 {\r\n\r\n    function mul(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint32 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        uint32 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint32 a, uint32 b) internal pure returns (uint32) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint32 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused, \"contract is paused\");\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused() {\r\n        require(paused, \"contract is not paused\");\r\n        _;\r\n    }\r\n\r\n    function pause() public onlyOwner whenNotPaused {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    function unpause() public onlyOwner whenPaused {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\ncontract Getter {\r\n    function getDragonProfile(uint256) external view returns (bytes32, uint16, uint256, uint8, uint8, uint16, bool, uint32);\r\n    function getDragonStrength(uint256) external view returns (uint32);\r\n    function getDragonCurrentHealthAndMana(uint256) external view returns (uint32, uint32, uint8, uint8);\r\n    function getDragonHealthAndMana(uint256) external view returns (uint256, uint32, uint32, uint32, uint32);\r\n    function getDragonsAmount() external view returns (uint256);\r\n    function isDragonOwner(address, uint256) external view returns (bool);\r\n    function ownerOfDragon(uint256) public view returns (address);\r\n    function isDragonInGladiatorBattle(uint256) public view returns (bool);\r\n}\r\n\r\ncontract Core is Upgradable {\r\n    function setDragonRemainingHealthAndMana(uint256, uint32, uint32) external;\r\n    function increaseDragonExperience(uint256, uint256) external;\r\n    function increaseDragonWins(uint256) external;\r\n    function increaseDragonDefeats(uint256) external;\r\n    function resetDragonBuffs(uint256) external;\r\n    function getDragonFullRegenerationTime(uint256) external view returns (uint32);\r\n}\r\n\r\ncontract Battle {\r\n    function start(uint256, uint256, uint8[2], uint8[2], uint256, bool) external returns (uint256[2], uint32, uint32, uint32, uint32, uint256);\r\n}\r\n\r\ncontract Treasury {\r\n    uint256 public hatchingPrice;\r\n    function giveGold(address, uint256) external;\r\n    function remainingGold() external view returns (uint256);\r\n}\r\n\r\ncontract Random {\r\n    function random(uint256) external view returns (uint256);\r\n}\r\n\r\n\r\n\r\n\r\n//////////////CONTRACT//////////////\r\n\r\n\r\n\r\n\r\ncontract BattleController is Upgradable {\r\n    using SafeMath8 for uint8;\r\n    using SafeMath16 for uint16;\r\n    using SafeMath32 for uint32;\r\n    using SafeMath256 for uint256;\r\n\r\n    Core core;\r\n    Battle battle;\r\n    Treasury treasury;\r\n    Getter getter;\r\n    Random random;\r\n\r\n    // stores date to which dragon is untouchable as opponent for the battle\r\n    mapping (uint256 => uint256) lastBattleDate;\r\n\r\n    uint8 constant MAX_PERCENTAGE = 100;\r\n    uint8 constant MIN_HEALTH_PERCENTAGE = 50;\r\n    uint8 constant MAX_TACTICS_PERCENTAGE = 80;\r\n    uint8 constant MIN_TACTICS_PERCENTAGE = 20;\r\n    uint8 constant PERCENT_MULTIPLIER = 100;\r\n    uint8 constant DRAGON_STRENGTH_DIFFERENCE_PERCENTAGE = 10;\r\n\r\n    uint256 constant GOLD_REWARD_MULTIPLIER = 10 ** 18;\r\n\r\n    function _min(uint256 lth, uint256 rth) internal pure returns (uint256) {\r\n        return lth > rth ? rth : lth;\r\n    }\r\n\r\n    function _isTouchable(uint256 _id) internal view returns (bool) {\r\n        uint32 _regenerationTime = core.getDragonFullRegenerationTime(_id);\r\n        return lastBattleDate[_id].add(_regenerationTime.mul(4)) < now;\r\n    }\r\n\r\n    function _checkBattlePossibility(\r\n        address _sender,\r\n        uint256 _id,\r\n        uint256 _opponentId,\r\n        uint8[2] _tactics\r\n    ) internal view {\r\n        require(getter.isDragonOwner(_sender, _id), \"not an owner\");\r\n        require(!getter.isDragonOwner(_sender, _opponentId), \"can't be owner of opponent dragon\");\r\n        require(!getter.isDragonOwner(address(0), _opponentId), \"opponent dragon has no owner\");\r\n\r\n        require(!getter.isDragonInGladiatorBattle(_id), \"your dragon participates in gladiator battle\");\r\n        require(!getter.isDragonInGladiatorBattle(_opponentId), \"opponent dragon participates in gladiator battle\");\r\n\r\n        require(_isTouchable(_opponentId), \"opponent dragon is untouchable\");\r\n\r\n        require(\r\n            _tactics[0] >= MIN_TACTICS_PERCENTAGE &&\r\n            _tactics[0] <= MAX_TACTICS_PERCENTAGE &&\r\n            _tactics[1] >= MIN_TACTICS_PERCENTAGE &&\r\n            _tactics[1] <= MAX_TACTICS_PERCENTAGE,\r\n            \"tactics value must be between 20 and 80\"\r\n        );\r\n\r\n        uint8 _attackerHealthPercentage;\r\n        uint8 _attackerManaPercentage;\r\n        ( , , _attackerHealthPercentage, _attackerManaPercentage) = getter.getDragonCurrentHealthAndMana(_id);\r\n        require(\r\n            _attackerHealthPercentage >= MIN_HEALTH_PERCENTAGE,\r\n            \"dragon's health less than 50%\"\r\n        );\r\n        uint8 _opponentHealthPercentage;\r\n        uint8 _opponentManaPercentage;\r\n        ( , , _opponentHealthPercentage, _opponentManaPercentage) = getter.getDragonCurrentHealthAndMana(_opponentId);\r\n        require(\r\n            _opponentHealthPercentage == MAX_PERCENTAGE &&\r\n            _opponentManaPercentage == MAX_PERCENTAGE,\r\n            \"opponent health and/or mana is not full\"\r\n        );\r\n    }\r\n\r\n    function startBattle(\r\n        address _sender,\r\n        uint256 _id,\r\n        uint256 _opponentId,\r\n        uint8[2] _tactics\r\n    ) external onlyController returns (\r\n        uint256 battleId,\r\n        uint256 seed,\r\n        uint256[2] winnerLooserIds\r\n    ) {\r\n        _checkBattlePossibility(_sender, _id, _opponentId, _tactics);\r\n\r\n        seed = random.random(2**256 - 1);\r\n\r\n        uint32 _winnerHealth;\r\n        uint32 _winnerMana;\r\n        uint32 _looserHealth;\r\n        uint32 _looserMana;\r\n\r\n        (\r\n            winnerLooserIds,\r\n            _winnerHealth, _winnerMana,\r\n            _looserHealth, _looserMana,\r\n            battleId\r\n        ) = battle.start(\r\n            _id,\r\n            _opponentId,\r\n            _tactics,\r\n            [0, 0],\r\n            seed,\r\n            false\r\n        );\r\n\r\n        core.setDragonRemainingHealthAndMana(winnerLooserIds[0], _winnerHealth, _winnerMana);\r\n        core.setDragonRemainingHealthAndMana(winnerLooserIds[1], _looserHealth, _looserMana);\r\n\r\n        core.increaseDragonWins(winnerLooserIds[0]);\r\n        core.increaseDragonDefeats(winnerLooserIds[1]);\r\n\r\n        lastBattleDate[_opponentId] = now;\r\n\r\n        _payBattleRewards(\r\n            _sender,\r\n            _id,\r\n            _opponentId,\r\n            winnerLooserIds[0]\r\n        );\r\n    }\r\n\r\n    function _payBattleRewards(\r\n        address _sender,\r\n        uint256 _id,\r\n        uint256 _opponentId,\r\n        uint256 _winnerId\r\n    ) internal {\r\n        uint32 _strength = getter.getDragonStrength(_id);\r\n        uint32 _opponentStrength = getter.getDragonStrength(_opponentId);\r\n        bool _isAttackerWinner = _id == _winnerId;\r\n\r\n        uint256 _xpFactor = _calculateExperience(_isAttackerWinner, _strength, _opponentStrength);\r\n        core.increaseDragonExperience(_winnerId, _xpFactor);\r\n\r\n        if (_isAttackerWinner) {\r\n            uint256 _factor = _calculateGoldRewardFactor(_strength, _opponentStrength);\r\n            _payGoldReward(_sender, _id, _factor);\r\n        }\r\n    }\r\n\r\n    function _calculateExperience(\r\n        bool _isAttackerWinner,\r\n        uint32 _attackerStrength,\r\n        uint32 _opponentStrength\r\n    ) internal pure returns (uint256) {\r\n\r\n        uint8 _attackerFactor;\r\n        uint256 _winnerStrength;\r\n        uint256 _looserStrength;\r\n\r\n        uint8 _degree;\r\n\r\n        if (_isAttackerWinner) {\r\n            _attackerFactor = 10;\r\n            _winnerStrength = _attackerStrength;\r\n            _looserStrength = _opponentStrength;\r\n            _degree = _winnerStrength <= _looserStrength ? 2 : 5;\r\n        } else {\r\n            _attackerFactor = 5;\r\n            _winnerStrength = _opponentStrength;\r\n            _looserStrength = _attackerStrength;\r\n            _degree = _winnerStrength <= _looserStrength ? 1 : 5;\r\n        }\r\n\r\n        uint256 _factor = _looserStrength.pow(_degree).mul(_attackerFactor).div(_winnerStrength.pow(_degree));\r\n\r\n        if (_isAttackerWinner) {\r\n            return _factor;\r\n        }\r\n        return _min(_factor, 10); // 1\r\n    }\r\n\r\n    function _calculateGoldRewardFactor(\r\n        uint256 _winnerStrength,\r\n        uint256 _looserStrength\r\n    ) internal pure returns (uint256) {\r\n        uint8 _degree = _winnerStrength <= _looserStrength ? 1 : 8;\r\n        return _looserStrength.pow(_degree).mul(GOLD_REWARD_MULTIPLIER).div(_winnerStrength.pow(_degree));\r\n    }\r\n\r\n    function _getMaxGoldReward(\r\n        uint256 _hatchingPrice,\r\n        uint256 _dragonsAmount\r\n    ) internal pure returns (uint256) {\r\n        uint8 _factor;\r\n\r\n        if (_dragonsAmount < 15000) _factor = 20;\r\n        else if (_dragonsAmount < 30000) _factor = 10;\r\n        else _factor = 5;\r\n\r\n        return _hatchingPrice.mul(_factor).div(PERCENT_MULTIPLIER);\r\n    }\r\n\r\n    function _payGoldReward(\r\n        address _sender,\r\n        uint256 _id,\r\n        uint256 _factor\r\n    ) internal {\r\n        uint256 _goldRemain = treasury.remainingGold();\r\n        uint256 _dragonsAmount = getter.getDragonsAmount();\r\n        uint32 _coolness;\r\n        (, , , , , , , _coolness) = getter.getDragonProfile(_id);\r\n        uint256 _hatchingPrice = treasury.hatchingPrice();\r\n        // dragon coolness is multyplied by 100\r\n        uint256 _value = _goldRemain.mul(_coolness).mul(10).div(_dragonsAmount.pow(2)).div(100);\r\n        _value = _value.mul(_factor).div(GOLD_REWARD_MULTIPLIER);\r\n\r\n        uint256 _maxReward = _getMaxGoldReward(_hatchingPrice, _dragonsAmount);\r\n        if (_value > _maxReward) _value = _maxReward;\r\n        if (_value > _goldRemain) _value = _goldRemain;\r\n        treasury.giveGold(_sender, _value);\r\n    }\r\n\r\n    struct Opponent {\r\n        uint256 id;\r\n        uint256 timestamp;\r\n        uint32 strength;\r\n    }\r\n\r\n    function _iterateTimestampIndex(uint8 _index) internal pure returns (uint8) {\r\n        return _index < 5 ? _index.add(1) : 0;\r\n    }\r\n\r\n    function _getPercentOfValue(uint32 _value, uint8 _percent) internal pure returns (uint32) {\r\n        return _value.mul(_percent).div(PERCENT_MULTIPLIER);\r\n    }\r\n\r\n    function matchOpponents(uint256 _attackerId) external view returns (uint256[6]) {\r\n        uint32 _attackerStrength = getter.getDragonStrength(_attackerId);\r\n        uint32 _strengthDiff = _getPercentOfValue(_attackerStrength, DRAGON_STRENGTH_DIFFERENCE_PERCENTAGE);\r\n        uint32 _minStrength = _attackerStrength.sub(_strengthDiff);\r\n        uint32 _maxStrength = _attackerStrength.add(_strengthDiff);\r\n        uint32 _strength;\r\n        uint256 _timestamp; // usually the date of the last battle\r\n        uint8 _timestampIndex;\r\n        uint8 _healthPercentage;\r\n        uint8 _manaPercentage;\r\n\r\n        address _owner = getter.ownerOfDragon(_attackerId);\r\n\r\n        Opponent[6] memory _opponents;\r\n        _opponents[0].timestamp =\r\n        _opponents[1].timestamp =\r\n        _opponents[2].timestamp =\r\n        _opponents[3].timestamp =\r\n        _opponents[4].timestamp =\r\n        _opponents[5].timestamp = now;\r\n\r\n        for (uint256 _id = 1; _id <= getter.getDragonsAmount(); _id++) { // no dragon with id = 0\r\n\r\n            if (\r\n                _attackerId != _id\r\n                && !getter.isDragonOwner(_owner, _id)\r\n                && !getter.isDragonInGladiatorBattle(_id)\r\n                && _isTouchable(_id)\r\n            ) {\r\n                _strength = getter.getDragonStrength(_id);\r\n                if (_strength >= _minStrength && _strength <= _maxStrength) {\r\n\r\n                    ( , , _healthPercentage, _manaPercentage) = getter.getDragonCurrentHealthAndMana(_id);\r\n                    if (_healthPercentage == MAX_PERCENTAGE && _manaPercentage == MAX_PERCENTAGE) {\r\n\r\n                        (_timestamp, , , , ) = getter.getDragonHealthAndMana(_id);\r\n                        if (_timestamp < _opponents[_timestampIndex].timestamp) {\r\n\r\n                            _opponents[_timestampIndex] = Opponent(_id, _timestamp, _strength);\r\n                            _timestampIndex = _iterateTimestampIndex(_timestampIndex);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return [\r\n            _opponents[0].id,\r\n            _opponents[1].id,\r\n            _opponents[2].id,\r\n            _opponents[3].id,\r\n            _opponents[4].id,\r\n            _opponents[5].id\r\n        ];\r\n    }\r\n\r\n    function resetDragonBuffs(uint256 _id) external onlyController {\r\n        core.resetDragonBuffs(_id);\r\n    }\r\n\r\n    // UPDATE CONTRACT\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        super.setInternalDependencies(_newDependencies);\r\n\r\n        core = Core(_newDependencies[0]);\r\n        battle = Battle(_newDependencies[1]);\r\n        treasury = Treasury(_newDependencies[2]);\r\n        getter = Getter(_newDependencies[3]);\r\n        random = Random(_newDependencies[4]);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_attackerId\",\"type\":\"uint256\"}],\"name\":\"matchOpponents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[6]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"resetDragonBuffs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_opponentId\",\"type\":\"uint256\"},{\"name\":\"_tactics\",\"type\":\"uint8[2]\"}],\"name\":\"startBattle\",\"outputs\":[{\"name\":\"battleId\",\"type\":\"uint256\"},{\"name\":\"seed\",\"type\":\"uint256\"},{\"name\":\"winnerLooserIds\",\"type\":\"uint256[2]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"BattleController","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://4463819678926bbd25a0ede9dce48ef0fde766e33eac252c9666baad6c5f59a0"}]}