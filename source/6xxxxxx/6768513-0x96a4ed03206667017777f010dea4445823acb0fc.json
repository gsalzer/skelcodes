{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/*===========================================================================================*\r\n*************************************** https://p4d.io ***************************************\r\n*============================================================================================*\r\n*   \r\n*                            ,-.----.           ,--,              \r\n*                            \\    /  \\        ,--.'|    ,---,     \r\n*                            |   :    \\    ,--,  | :  .'  .' `\\   \r\n*                            |   |  .\\ :,---.'|  : ',---.'     \\  \r\n*                            .   :  |: |;   : |  | ;|   |  .`\\  | \r\n*                            |   |   \\ :|   | : _' |:   : |  '  | \r\n*                            |   : .   /:   : |.'  ||   ' '  ;  : \r\n*                            ;   | |`-' |   ' '  ; :'   | ;  .  | \r\n*                            |   | ;    \\   \\  .'. ||   | :  |  ' \r\n*                            :   ' |     `---`:  | ''   : | /  ;  \r\n*                            :   : :          '  ; ||   | '` ,/   \r\n*                            |   | :          |  : ;;   :  .'     \r\n*                            `---'.|          '  ,/ |   ,.'       \r\n*                              `---`          '--'  '---'         \r\n*                _____ _            _   _              __  __ _      _       _     \r\n*               |_   _| |          | | | |            / _|/ _(_)    (_)     | |    \r\n*                 | | | |__   ___  | | | |_ __   ___ | |_| |_ _  ___ _  __ _| |    \r\n*                 | | | '_ \\ / _ \\ | | | | '_ \\ / _ \\|  _|  _| |/ __| |/ _` | |    \r\n*                 | | | | | |  __/ | |_| | | | | (_) | | | | | | (__| | (_| | |    \r\n*                 \\_/ |_| |_|\\___|  \\___/|_| |_|\\___/|_| |_| |_|\\___|_|\\__,_|_|    \r\n*                                                                                  \r\n*               ______ ___________   _____                           _             \r\n*               | ___ \\____ |  _  \\ |  ___|                         (_)            \r\n*               | |_/ /   / / | | | | |____  ___ __   __ _ _ __  ___ _  ___  _ __  \r\n*               |  __/    \\ \\ | | | |  __\\ \\/ / '_ \\ / _` | '_ \\/ __| |/ _ \\| '_ \\ \r\n*               | |   .___/ / |/ /  | |___>  <| |_) | (_| | | | \\__ \\ | (_) | | | |\r\n*               \\_|   \\____/|___/   \\____/_/\\_\\ .__/ \\__,_|_| |_|___/_|\\___/|_| |_|\r\n*                                             | |                                  \r\n*                                             |_| \r\n*                                                       _L/L\r\n*                                                     _LT/l_L_\r\n*                                                   _LLl/L_T_lL_\r\n*                               _T/L              _LT|L/_|__L_|_L_\r\n*                             _Ll/l_L_          _TL|_T/_L_|__T__|_l_\r\n*                           _TLl/T_l|_L_      _LL|_Tl/_|__l___L__L_|L_\r\n*                         _LT_L/L_|_L_l_L_  _'|_|_|T/_L_l__T _ l__|__|L_\r\n*                       _Tl_L|/_|__|_|__T _LlT_|_Ll/_l_ _|__[ ]__|__|_l_L_\r\n*                ..__ _LT_l_l/|__|__l_T _T_L|_|_|l/___|__ | _l__|_ |__|_T_L_  __\r\n*                   _       ___            _                  _       ___       \r\n*                  /_\\     / __\\___  _ __ | |_ _ __ __ _  ___| |_    / __\\_   _ \r\n*                 //_\\\\   / /  / _ \\| '_ \\| __| '__/ _` |/ __| __|  /__\\// | | |\r\n*                /  _  \\ / /__| (_) | | | | |_| | | (_| | (__| |_  / \\/  \\ |_| |\r\n*                \\_/ \\_/ \\____/\\___/|_| |_|\\__|_|  \\__,_|\\___|\\__| \\_____/\\__, |\r\n*                                   ╔═╗╔═╗╦      ╔╦╗╔═╗╦  ╦               |___/ \r\n*                                   ╚═╗║ ║║       ║║║╣ ╚╗╔╝\r\n*                                   ╚═╝╚═╝╩═╝────═╩╝╚═╝ ╚╝ \r\n*                                      0x736f6c5f646576\r\n*                                      ‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\r\n* \r\n* -> What?\r\n* The original autonomous pyramid, improved (again!):\r\n*  [x] Developer optimized to include utility functions:\r\n*      -> approve(): allow others to transfer on your behalf\r\n*      -> approveAndCall(): callback for contracts that want to use approve()\r\n*      -> transferFrom(): use your approval allowance to transfer P4D on anothers behalf\r\n*      -> transferAndCall(): callback for contracts that want to use transfer()\r\n*  [x] Designed to be a bridge for P3D to make the token functional for use in external contracts\r\n*  [x] Masternodes are also used in P4D as well as when it buys P3D:\r\n*      -> If the referrer has more than 10,000 P4D tokens, they will get 1/3 of the 10% divs\r\n*      -> If the referrer also has more than 100 P3D tokens, they will be used as the ref\r\n*         on the buy order to P3D and receive 1/3 of the 10% P3D divs upon purchase\r\n*  [x] As this contract holds P3D, it will receive ETH dividends proportional to it's\r\n*      holdings, this ETH is then distributed to all P4D token holders proportionally\r\n*  [x] On top of the ETH divs from P3D, you will also receive P3D divs from buys and sells\r\n*      in the P4D exchange\r\n*  [x] There's a 10% div tax for buys, a 5% div tax on sells and a 0% tax on transfers\r\n*  [x] No auto-transfers for dividends or subdividends, they will all be stored until\r\n*      either withdraw() or reinvest() are called, this makes it easier for external\r\n*      contracts to calculate how much they received upon a withdraw/reinvest\r\n*  [x] Partial withdraws and reinvests for both dividends and subdividends\r\n*  [x] Global name registry for all external contracts to use:\r\n*      -> Names cost 0.01 ETH to register\r\n*      -> Names must be unique and not already owned\r\n*      -> You can set an active name out of all the ones you own\r\n*      -> You can change your name at any time but still be referred by an old name\r\n*      -> All ETH from registrations will be distributed to all P4D holders proportionally\r\n*\r\n*/\r\n\r\n\r\n// P3D interface\r\ninterface P3D {\r\n    function buy(address) external payable returns(uint256);\r\n    function transfer(address, uint256) external returns(bool);\r\n    function myTokens() external view returns(uint256);\r\n    function balanceOf(address) external view returns(uint256);\r\n    function myDividends(bool) external view returns(uint256);\r\n    function withdraw() external;\r\n    function calculateTokensReceived(uint256) external view returns(uint256);\r\n    function stakingRequirement() external view returns(uint256);\r\n}\r\n\r\n// ERC-677 style token transfer callback\r\ninterface usingP4D {\r\n    function tokenCallback(address _from, uint256 _value, bytes _data) external returns (bool);\r\n}\r\n\r\n// ERC-20 style approval callback\r\ninterface controllingP4D {\r\n    function approvalCallback(address _from, uint256 _value, bytes _data) external returns (bool);\r\n}\r\n\r\ncontract P4D {\r\n\r\n    /*=================================\r\n    =            MODIFIERS            =\r\n    =================================*/\r\n    // only people with tokens\r\n    modifier onlyBagholders() {\r\n        require(myTokens() > 0);\r\n        _;\r\n    }\r\n\r\n    // administrators can:\r\n    // -> change the name of the contract\r\n    // -> change the name of the token\r\n    // -> change the PoS difficulty (how many tokens it costs to hold a masternode, in case it gets crazy high later)\r\n    // -> allow a contract to accept P4D tokens\r\n    // they CANNOT:\r\n    // -> take funds\r\n    // -> disable withdrawals\r\n    // -> kill the contract\r\n    // -> change the price of tokens\r\n    modifier onlyAdministrator() {\r\n        require(administrators[msg.sender] || msg.sender == _dev);\r\n        _;\r\n    }\r\n\r\n    // ensures that the first tokens in the contract will be equally distributed\r\n    // meaning, no divine dump will be ever possible\r\n    // result: healthy longevity.\r\n    modifier purchaseFilter(address _sender, uint256 _amountETH) {\r\n\r\n        require(!isContract(_sender) || canAcceptTokens_[_sender]);\r\n        \r\n        if (now >= ACTIVATION_TIME) {\r\n            onlyAmbassadors = false;\r\n        }\r\n\r\n        // are we still in the vulnerable phase?\r\n        // if so, enact anti early whale protocol\r\n        if (onlyAmbassadors && ((totalAmbassadorQuotaSpent_ + _amountETH) <= ambassadorQuota_)) {\r\n            require(\r\n                // is the customer in the ambassador list?\r\n                ambassadors_[_sender] == true &&\r\n\r\n                // does the customer purchase exceed the max ambassador quota?\r\n                (ambassadorAccumulatedQuota_[_sender] + _amountETH) <= ambassadorMaxPurchase_\r\n            );\r\n\r\n            // updated the accumulated quota\r\n            ambassadorAccumulatedQuota_[_sender] = SafeMath.add(ambassadorAccumulatedQuota_[_sender], _amountETH);\r\n            totalAmbassadorQuotaSpent_ = SafeMath.add(totalAmbassadorQuotaSpent_, _amountETH);\r\n\r\n            // execute\r\n            _;\r\n        } else {\r\n            require(!onlyAmbassadors);\r\n            _;\r\n        }\r\n\r\n    }\r\n\r\n    /*==============================\r\n    =            EVENTS            =\r\n    ==============================*/\r\n    event onTokenPurchase(\r\n        address indexed _customerAddress,\r\n        uint256 _incomingP3D,\r\n        uint256 _tokensMinted,\r\n        address indexed _referredBy\r\n    );\r\n\r\n    event onTokenSell(\r\n        address indexed _customerAddress,\r\n        uint256 _tokensBurned,\r\n        uint256 _P3D_received\r\n    );\r\n\r\n    event onReinvestment(\r\n        address indexed _customerAddress,\r\n        uint256 _P3D_reinvested,\r\n        uint256 _tokensMinted\r\n    );\r\n\r\n    event onSubdivsReinvestment(\r\n        address indexed _customerAddress,\r\n        uint256 _ETH_reinvested,\r\n        uint256 _tokensMinted\r\n    );\r\n\r\n    event onWithdraw(\r\n        address indexed _customerAddress,\r\n        uint256 _P3D_withdrawn\r\n    );\r\n\r\n    event onSubdivsWithdraw(\r\n        address indexed _customerAddress,\r\n        uint256 _ETH_withdrawn\r\n    );\r\n\r\n    event onNameRegistration(\r\n        address indexed _customerAddress,\r\n        string _registeredName\r\n    );\r\n\r\n    // ERC-20\r\n    event Transfer(\r\n        address indexed _from,\r\n        address indexed _to,\r\n        uint256 _tokens\r\n    );\r\n\r\n    event Approval(\r\n        address indexed _tokenOwner,\r\n        address indexed _spender,\r\n        uint256 _tokens\r\n    );\r\n\r\n\r\n    /*=====================================\r\n    =            CONFIGURABLES            =\r\n    =====================================*/\r\n    string public name = \"PoWH4D\";\r\n    string public symbol = \"P4D\";\r\n    uint256 constant public decimals = 18;\r\n    uint256 constant internal buyDividendFee_ = 10; // 10% dividend tax on each buy\r\n    uint256 constant internal sellDividendFee_ = 5; // 5% dividend tax on each sell\r\n    uint256 internal tokenPriceInitial_; // set in the constructor\r\n    uint256 constant internal tokenPriceIncremental_ = 1e9; // 1/10th the incremental of P3D\r\n    uint256 constant internal magnitude = 2**64;\r\n    uint256 public stakingRequirement = 1e22; // 10,000 P4D\r\n    uint256 constant internal initialBuyLimitPerTx_ = 1 ether;\r\n    uint256 constant internal initialBuyLimitCap_ = 100 ether;\r\n    uint256 internal totalInputETH_ = 0;\r\n\r\n\r\n    // ambassador program\r\n    mapping(address => bool) internal ambassadors_;\r\n    uint256 constant internal ambassadorMaxPurchase_ = 1 ether;\r\n    uint256 constant internal ambassadorQuota_ = 12 ether;\r\n    uint256 internal totalAmbassadorQuotaSpent_ = 0;\r\n    address internal _dev;\r\n\r\n\r\n    uint256 public ACTIVATION_TIME;\r\n\r\n\r\n   /*================================\r\n    =            DATASETS            =\r\n    ================================*/\r\n    // amount of shares for each address (scaled number)\r\n    mapping(address => uint256) internal tokenBalanceLedger_;\r\n    mapping(address => uint256) internal referralBalance_;\r\n    mapping(address => int256) internal payoutsTo_;\r\n    mapping(address => uint256) internal dividendsStored_;\r\n    mapping(address => uint256) internal ambassadorAccumulatedQuota_;\r\n    uint256 internal tokenSupply_ = 0;\r\n    uint256 internal profitPerShare_;\r\n\r\n    // administrator list (see above on what they can do)\r\n    mapping(address => bool) public administrators;\r\n\r\n    // when this is set to true, only ambassadors can purchase tokens (this prevents a whale premine, it ensures a fairly distributed upper pyramid)\r\n    bool public onlyAmbassadors = true;\r\n\r\n    // contracts can interact with the exchange but only approved ones\r\n    mapping(address => bool) public canAcceptTokens_;\r\n\r\n    // ERC-20 standard\r\n    mapping(address => mapping (address => uint256)) public allowed;\r\n\r\n    // P3D contract reference\r\n    P3D internal _P3D;\r\n\r\n    // structure to handle the distribution of ETH divs paid out by the P3D contract\r\n    struct P3D_dividends {\r\n        uint256 balance;\r\n        uint256 lastDividendPoints;\r\n    }\r\n    mapping(address => P3D_dividends) internal divsMap_;\r\n    uint256 internal totalDividendPoints_;\r\n    uint256 internal lastContractBalance_;\r\n\r\n    // structure to handle the global unique name/vanity registration\r\n    struct NameRegistry {\r\n        uint256 activeIndex;\r\n        bytes32[] registeredNames;\r\n    }\r\n    mapping(address => NameRegistry) internal customerNameMap_;\r\n    mapping(bytes32 => address) internal globalNameMap_;\r\n    uint256 constant internal nameRegistrationFee = 0.01 ether;\r\n\r\n\r\n    /*=======================================\r\n    =            PUBLIC FUNCTIONS            =\r\n    =======================================*/\r\n    /*\r\n    * -- APPLICATION ENTRY POINTS --\r\n    */\r\n    constructor(uint256 _activationTime, address _P3D_address) public {\r\n\r\n        _dev = msg.sender;\r\n\r\n        ACTIVATION_TIME = _activationTime;\r\n\r\n        totalDividendPoints_ = 1; // non-zero value\r\n\r\n        _P3D = P3D(_P3D_address);\r\n\r\n        // virtualized purchase of the entire ambassador quota\r\n        // calculateTokensReceived() for this contract will return how many tokens can be bought starting at 1e9 P3D per P4D\r\n        // as the price increases by the incremental each time we can just multiply it out and scale it back to e18\r\n        //\r\n        // this is used as the initial P3D-P4D price as it makes it fairer on other investors that aren't ambassadors\r\n        uint256 _P4D_received;\r\n        (, _P4D_received) = calculateTokensReceived(ambassadorQuota_);\r\n        tokenPriceInitial_ = tokenPriceIncremental_ * _P4D_received / 1e18;\r\n\r\n        // admins\r\n        administrators[_dev] = true;\r\n        \r\n        // ambassadors\r\n        ambassadors_[_dev] = true;\r\n    }\r\n\r\n\r\n    /**\r\n     * Converts all incoming ethereum to tokens for the caller, and passes down the referral address\r\n     */\r\n    function buy(address _referredBy)\r\n        payable\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return purchaseInternal(msg.sender, msg.value, _referredBy);\r\n    }\r\n\r\n    /**\r\n     * Buy with a registered name as the referrer.\r\n     * If the name is unregistered, address(0x0) will be the ref\r\n     */\r\n    function buyWithNameRef(string memory _nameOfReferrer)\r\n        payable\r\n        public\r\n        returns(uint256)\r\n    {\r\n        return purchaseInternal(msg.sender, msg.value, ownerOfName(_nameOfReferrer));\r\n    }\r\n\r\n    /**\r\n     * Fallback function to handle ethereum that was sent straight to the contract\r\n     * Unfortunately we cannot use a referral address this way.\r\n     */\r\n    function()\r\n        payable\r\n        public\r\n    {\r\n        if (msg.sender != address(_P3D)) {\r\n            purchaseInternal(msg.sender, msg.value, address(0x0));\r\n        }\r\n\r\n        // all other ETH is from the withdrawn dividends from\r\n        // the P3D contract, this is distributed out via the\r\n        // updateSubdivsFor() method\r\n        // no more computation can be done inside this function\r\n        // as when you call address.transfer(uint256), only\r\n        // 2,300 gas is forwarded to this function so no variables\r\n        // can be mutated with that limit\r\n        // address(this).balance will represent the total amount\r\n        // of ETH dividends from the P3D contract (minus the amount\r\n        // that's already been withdrawn)\r\n    }\r\n\r\n    /**\r\n     * Distribute any ETH sent to this method out to all token holders\r\n     */\r\n    function donate()\r\n        payable\r\n        public\r\n    {\r\n        // nothing happens here in order to save gas\r\n        // all of the ETH sent to this function will be distributed out\r\n        // via the updateSubdivsFor() method\r\n        // \r\n        // this method is designed for external contracts that have \r\n        // extra ETH that they want to evenly distribute to all\r\n        // P4D token holders\r\n    }\r\n\r\n    /**\r\n     * Allows a customer to pay for a global name on the P4D network\r\n     * There's a 0.01 ETH registration fee per name\r\n     * All ETH is distributed to P4D token holders via updateSubdivsFor()\r\n     */\r\n    function registerName(string memory _name)\r\n        payable\r\n        public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(!onlyAmbassadors || ambassadors_[_customerAddress]);\r\n\r\n        require(bytes(_name).length > 0);\r\n        require(msg.value >= nameRegistrationFee);\r\n        uint256 excess = SafeMath.sub(msg.value, nameRegistrationFee);\r\n\r\n        bytes32 bytesName = stringToBytes32(_name);\r\n        require(globalNameMap_[bytesName] == address(0x0));\r\n\r\n        NameRegistry storage customerNamesInfo = customerNameMap_[_customerAddress];\r\n        customerNamesInfo.registeredNames.push(bytesName);\r\n        customerNamesInfo.activeIndex = customerNamesInfo.registeredNames.length - 1;\r\n\r\n        globalNameMap_[bytesName] = _customerAddress;\r\n\r\n        if (excess > 0) {\r\n            _customerAddress.transfer(excess);\r\n        }\r\n\r\n        // fire event\r\n        emit onNameRegistration(_customerAddress, _name);\r\n\r\n        // similar to the fallback and donate functions, the ETH cost of\r\n        // the name registration fee (0.01 ETH) will be distributed out\r\n        // to all P4D tokens holders via the updateSubdivsFor() method\r\n    }\r\n\r\n    /**\r\n     * Change your active name to a name that you've already purchased\r\n     */\r\n    function changeActiveNameTo(string memory _name)\r\n        public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        require(_customerAddress == ownerOfName(_name));\r\n\r\n        bytes32 bytesName = stringToBytes32(_name);\r\n        NameRegistry storage customerNamesInfo = customerNameMap_[_customerAddress];\r\n\r\n        uint256 newActiveIndex = 0;\r\n        for (uint256 i = 0; i < customerNamesInfo.registeredNames.length; i++) {\r\n            if (bytesName == customerNamesInfo.registeredNames[i]) {\r\n                newActiveIndex = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        customerNamesInfo.activeIndex = newActiveIndex;\r\n    }\r\n\r\n    /**\r\n     * Similar to changeActiveNameTo() without the need to iterate through your name list\r\n     */\r\n    function changeActiveNameIndexTo(uint256 _newActiveIndex)\r\n        public\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        NameRegistry storage customerNamesInfo = customerNameMap_[_customerAddress];\r\n\r\n        require(_newActiveIndex < customerNamesInfo.registeredNames.length);\r\n        customerNamesInfo.activeIndex = _newActiveIndex;\r\n    }\r\n\r\n    /**\r\n     * Converts all of caller's dividends to tokens.\r\n     * The argument is not used but it allows MetaMask to render\r\n     * 'Reinvest' in your transactions list once the function sig\r\n     * is registered to the contract at;\r\n     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\r\n     */\r\n    function reinvest(bool)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        withdrawInternal(_customerAddress);\r\n\r\n        uint256 reinvestableDividends = dividendsStored_[_customerAddress];\r\n        reinvestAmount(reinvestableDividends);\r\n    }\r\n\r\n    /**\r\n     * Converts a portion of caller's dividends to tokens.\r\n     */\r\n    function reinvestAmount(uint256 _amountOfP3D)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        withdrawInternal(_customerAddress);\r\n\r\n        if (_amountOfP3D > 0 && _amountOfP3D <= dividendsStored_[_customerAddress]) {\r\n            dividendsStored_[_customerAddress] = SafeMath.sub(dividendsStored_[_customerAddress], _amountOfP3D);\r\n\r\n            // dispatch a buy order with the virtualized \"withdrawn dividends\"\r\n            uint256 _tokens = purchaseTokens(_customerAddress, _amountOfP3D, address(0x0));\r\n\r\n            // fire event\r\n            emit onReinvestment(_customerAddress, _amountOfP3D, _tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Converts all of caller's subdividends to tokens.\r\n     * The argument is not used but it allows MetaMask to render\r\n     * 'Reinvest Subdivs' in your transactions list once the function sig\r\n     * is registered to the contract at;\r\n     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\r\n     */\r\n    function reinvestSubdivs(bool)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        updateSubdivsFor(_customerAddress);\r\n\r\n        uint256 reinvestableSubdividends = divsMap_[_customerAddress].balance;\r\n        reinvestSubdivsAmount(reinvestableSubdividends);\r\n    }\r\n\r\n    /**\r\n     * Converts a portion of caller's subdividends to tokens.\r\n     */\r\n    function reinvestSubdivsAmount(uint256 _amountOfETH)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        updateSubdivsFor(_customerAddress);\r\n\r\n        if (_amountOfETH > 0 && _amountOfETH <= divsMap_[_customerAddress].balance) {\r\n            divsMap_[_customerAddress].balance = SafeMath.sub(divsMap_[_customerAddress].balance, _amountOfETH);\r\n            lastContractBalance_ = SafeMath.sub(lastContractBalance_, _amountOfETH);\r\n\r\n            // purchase tokens with the ETH subdividends\r\n            uint256 _tokens = purchaseInternal(_customerAddress, _amountOfETH, address(0x0));\r\n\r\n            // fire event\r\n            emit onSubdivsReinvestment(_customerAddress, _amountOfETH, _tokens);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Alias of sell(), withdraw() and withdrawSubdivs().\r\n     * The argument is not used but it allows MetaMask to render\r\n     * 'Exit' in your transactions list once the function sig\r\n     * is registered to the contract at;\r\n     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\r\n     */\r\n    function exit(bool)\r\n        public\r\n    {\r\n        // get token count for caller & sell them all\r\n        address _customerAddress = msg.sender;\r\n        uint256 _tokens = tokenBalanceLedger_[_customerAddress];\r\n        if(_tokens > 0) sell(_tokens);\r\n\r\n        // lambo delivery service\r\n        withdraw(true);\r\n        withdrawSubdivs(true);\r\n    }\r\n\r\n    /**\r\n     * Withdraws all of the callers dividend earnings.\r\n     * The argument is not used but it allows MetaMask to render\r\n     * 'Withdraw' in your transactions list once the function sig\r\n     * is registered to the contract at;\r\n     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\r\n     */\r\n    function withdraw(bool)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        withdrawInternal(_customerAddress);\r\n\r\n        uint256 withdrawableDividends = dividendsStored_[_customerAddress];\r\n        withdrawAmount(withdrawableDividends);\r\n    }\r\n\r\n    /**\r\n     * Withdraws a portion of the callers dividend earnings.\r\n     */\r\n    function withdrawAmount(uint256 _amountOfP3D)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        withdrawInternal(_customerAddress);\r\n\r\n        if (_amountOfP3D > 0 && _amountOfP3D <= dividendsStored_[_customerAddress]) {\r\n            dividendsStored_[_customerAddress] = SafeMath.sub(dividendsStored_[_customerAddress], _amountOfP3D);\r\n            \r\n            // lambo delivery service\r\n            require(_P3D.transfer(_customerAddress, _amountOfP3D));\r\n            // NOTE!\r\n            // P3D has a 10% transfer tax so even though this is sending your entire\r\n            // dividend count to you, you will only actually receive 90%.\r\n\r\n            // fire event\r\n            emit onWithdraw(_customerAddress, _amountOfP3D);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Withdraws all of the callers subdividend earnings.\r\n     * The argument is not used but it allows MetaMask to render\r\n     * 'Withdraw Subdivs' in your transactions list once the function sig\r\n     * is registered to the contract at;\r\n     * https://etherscan.io/address/0x44691B39d1a75dC4E0A0346CBB15E310e6ED1E86#writeContract\r\n     */\r\n    function withdrawSubdivs(bool)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        updateSubdivsFor(_customerAddress);\r\n\r\n        uint256 withdrawableSubdividends = divsMap_[_customerAddress].balance;\r\n        withdrawSubdivsAmount(withdrawableSubdividends);\r\n    }\r\n\r\n    /**\r\n     * Withdraws a portion of the callers subdividend earnings.\r\n     */\r\n    function withdrawSubdivsAmount(uint256 _amountOfETH)\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        updateSubdivsFor(_customerAddress);\r\n\r\n        if (_amountOfETH > 0 && _amountOfETH <= divsMap_[_customerAddress].balance) {\r\n            divsMap_[_customerAddress].balance = SafeMath.sub(divsMap_[_customerAddress].balance, _amountOfETH);\r\n            lastContractBalance_ = SafeMath.sub(lastContractBalance_, _amountOfETH);\r\n\r\n            // transfer all withdrawable subdividends\r\n            _customerAddress.transfer(_amountOfETH);\r\n\r\n            // fire event\r\n            emit onSubdivsWithdraw(_customerAddress, _amountOfETH);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Liquifies tokens to P3D.\r\n     */\r\n    function sell(uint256 _amountOfTokens)\r\n        onlyBagholders()\r\n        public\r\n    {\r\n        // setup data\r\n        address _customerAddress = msg.sender;\r\n        updateSubdivsFor(_customerAddress);\r\n\r\n        // russian hackers BTFO\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        uint256 _tokens = _amountOfTokens;\r\n        uint256 _P3D_amount = tokensToP3D_(_tokens);\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_P3D_amount, sellDividendFee_), 100);\r\n        uint256 _taxedP3D = SafeMath.sub(_P3D_amount, _dividends);\r\n\r\n        // burn the sold tokens\r\n        tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens);\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens);\r\n\r\n        // update dividends tracker\r\n        int256 _updatedPayouts = (int256)(profitPerShare_ * _tokens + (_taxedP3D * magnitude));\r\n        payoutsTo_[_customerAddress] -= _updatedPayouts;\r\n\r\n        // dividing by zero is a bad idea\r\n        if (tokenSupply_ > 0) {\r\n            // update the amount of dividends per token\r\n            profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_);\r\n        }\r\n\r\n        // fire events\r\n        emit onTokenSell(_customerAddress, _tokens, _taxedP3D);\r\n        emit Transfer(_customerAddress, address(0x0), _tokens);\r\n    }\r\n\r\n    /**\r\n     * Transfer tokens from the caller to a new holder.\r\n     * REMEMBER THIS IS 0% TRANSFER FEE\r\n     */\r\n    function transfer(address _toAddress, uint256 _amountOfTokens)\r\n        onlyBagholders()\r\n        public\r\n        returns(bool)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return transferInternal(_customerAddress, _toAddress, _amountOfTokens);\r\n    }\r\n\r\n    /**\r\n     * Transfer token to a specified address and forward the data to recipient\r\n     * ERC-677 standard\r\n     * https://github.com/ethereum/EIPs/issues/677\r\n     * @param _to    Receiver address.\r\n     * @param _value Amount of tokens that will be transferred.\r\n     * @param _data  Transaction metadata.\r\n     */\r\n    function transferAndCall(address _to, uint256 _value, bytes _data)\r\n        external\r\n        returns(bool)\r\n    {\r\n        require(canAcceptTokens_[_to]); // approved contracts only\r\n        require(transfer(_to, _value)); // do a normal token transfer to the contract\r\n\r\n        if (isContract(_to)) {\r\n            usingP4D receiver = usingP4D(_to);\r\n            require(receiver.tokenCallback(msg.sender, _value, _data));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * ERC-20 token standard for transferring tokens on anothers behalf\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _amountOfTokens)\r\n        public\r\n        returns(bool)\r\n    {\r\n        require(allowed[_from][msg.sender] >= _amountOfTokens);\r\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _amountOfTokens);\r\n\r\n        return transferInternal(_from, _to, _amountOfTokens);\r\n    }\r\n\r\n    /**\r\n     * ERC-20 token standard for allowing another address to transfer your tokens\r\n     * on your behalf up to a certain limit\r\n     */\r\n    function approve(address _spender, uint256 _tokens)\r\n        public\r\n        returns(bool)\r\n    {\r\n        allowed[msg.sender][_spender] = _tokens;\r\n        emit Approval(msg.sender, _spender, _tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * ERC-20 token standard for approving and calling an external\r\n     * contract with data\r\n     */\r\n    function approveAndCall(address _to, uint256 _value, bytes _data)\r\n        external\r\n        returns(bool)\r\n    {\r\n        require(approve(_to, _value)); // do a normal approval\r\n\r\n        if (isContract(_to)) {\r\n            controllingP4D receiver = controllingP4D(_to);\r\n            require(receiver.approvalCallback(msg.sender, _value, _data));\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n\r\n    /*----------  ADMINISTRATOR ONLY FUNCTIONS  ----------*/\r\n    /**\r\n     * In case one of us dies, we need to replace ourselves.\r\n     */\r\n    function setAdministrator(address _identifier, bool _status)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        administrators[_identifier] = _status;\r\n    }\r\n\r\n    /**\r\n     * Add a new ambassador to the exchange\r\n     */\r\n    function setAmbassador(address _identifier, bool _status)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        ambassadors_[_identifier] = _status;\r\n    }\r\n\r\n    /**\r\n     * Precautionary measures in case we need to adjust the masternode rate.\r\n     */\r\n    function setStakingRequirement(uint256 _amountOfTokens)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        stakingRequirement = _amountOfTokens;\r\n    }\r\n\r\n    /**\r\n     * Add a sub-contract, which can accept P4D tokens\r\n     */\r\n    function setCanAcceptTokens(address _address)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        require(isContract(_address));\r\n        canAcceptTokens_[_address] = true; // one way switch\r\n    }\r\n\r\n    /**\r\n     * If we want to rebrand, we can.\r\n     */\r\n    function setName(string _name)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        name = _name;\r\n    }\r\n\r\n    /**\r\n     * If we want to rebrand, we can.\r\n     */\r\n    function setSymbol(string _symbol)\r\n        onlyAdministrator()\r\n        public\r\n    {\r\n        symbol = _symbol;\r\n    }\r\n\r\n\r\n    /*----------  HELPERS AND CALCULATORS  ----------*/\r\n    /**\r\n     * Method to view the current P3D tokens stored in the contract\r\n     */\r\n    function totalBalance()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return _P3D.myTokens();\r\n    }\r\n\r\n    /**\r\n     * Retrieve the total token supply.\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenSupply_;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the tokens owned by the caller.\r\n     */\r\n    function myTokens()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return balanceOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the dividends owned by the caller.\r\n     * If `_includeReferralBonus` is set to true, the referral bonus will be included in the calculations.\r\n     * The reason for this, is that in the frontend, we will want to get the total divs (global + ref)\r\n     * But in the internal calculations, we want them separate.\r\n     */\r\n    function myDividends(bool _includeReferralBonus)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return (_includeReferralBonus ? dividendsOf(_customerAddress) + referralDividendsOf(_customerAddress) : dividendsOf(_customerAddress));\r\n    }\r\n\r\n    /**\r\n     * Retrieve the subdividend owned by the caller.\r\n     */\r\n    function myStoredDividends()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return storedDividendsOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the subdividend owned by the caller.\r\n     */\r\n    function mySubdividends()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        address _customerAddress = msg.sender;\r\n        return subdividendsOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the token balance of any single address.\r\n     */\r\n    function balanceOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return tokenBalanceLedger_[_customerAddress];\r\n    }\r\n\r\n    /**\r\n     * Retrieve the dividend balance of any single address.\r\n     */\r\n    function dividendsOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (uint256)((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude;\r\n    }\r\n\r\n    /**\r\n     * Retrieve the referred dividend balance of any single address.\r\n     */\r\n    function referralDividendsOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return referralBalance_[_customerAddress];\r\n    }\r\n\r\n    /**\r\n     * Retrieve the stored dividend balance of any single address.\r\n     */\r\n    function storedDividendsOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return dividendsStored_[_customerAddress] + dividendsOf(_customerAddress) + referralDividendsOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the subdividend balance owing of any single address.\r\n     */\r\n    function subdividendsOwing(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (divsMap_[_customerAddress].lastDividendPoints == 0 ? 0 : (balanceOf(_customerAddress) * (totalDividendPoints_ - divsMap_[_customerAddress].lastDividendPoints)) / magnitude);\r\n    }\r\n\r\n    /**\r\n     * Retrieve the subdividend balance of any single address.\r\n     */\r\n    function subdividendsOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return SafeMath.add(divsMap_[_customerAddress].balance, subdividendsOwing(_customerAddress));\r\n    }\r\n\r\n    /**\r\n     * Retrieve the allowance of an owner and spender.\r\n     */\r\n    function allowance(address _tokenOwner, address _spender) \r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return allowed[_tokenOwner][_spender];\r\n    }\r\n\r\n    /**\r\n     * Retrieve all name information about a customer\r\n     */\r\n    function namesOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256 activeIndex, string activeName, bytes32[] customerNames)\r\n    {\r\n        NameRegistry memory customerNamesInfo = customerNameMap_[_customerAddress];\r\n\r\n        uint256 length = customerNamesInfo.registeredNames.length;\r\n        customerNames = new bytes32[](length);\r\n\r\n        for (uint256 i = 0; i < length; i++) {\r\n            customerNames[i] = customerNamesInfo.registeredNames[i];\r\n        }\r\n\r\n        activeIndex = customerNamesInfo.activeIndex;\r\n        activeName = activeNameOf(_customerAddress);\r\n    }\r\n\r\n    /**\r\n     * Retrieves the address of the owner from the name\r\n     */\r\n    function ownerOfName(string memory _name)\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        if (bytes(_name).length > 0) {\r\n            bytes32 bytesName = stringToBytes32(_name);\r\n            return globalNameMap_[bytesName];\r\n        } else {\r\n            return address(0x0);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Retrieves the active name of a customer\r\n     */\r\n    function activeNameOf(address _customerAddress)\r\n        public\r\n        view\r\n        returns(string)\r\n    {\r\n        NameRegistry memory customerNamesInfo = customerNameMap_[_customerAddress];\r\n        if (customerNamesInfo.registeredNames.length > 0) {\r\n            bytes32 activeBytesName = customerNamesInfo.registeredNames[customerNamesInfo.activeIndex];\r\n            return bytes32ToString(activeBytesName);\r\n        } else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the buy price of 1 individual token.\r\n     */\r\n    function sellPrice()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ - tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _P3D_received = tokensToP3D_(1e18);\r\n            uint256 _dividends = SafeMath.div(SafeMath.mul(_P3D_received, sellDividendFee_), 100);\r\n            uint256 _taxedP3D = SafeMath.sub(_P3D_received, _dividends);\r\n\r\n            return _taxedP3D;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Return the sell price of 1 individual token.\r\n     */\r\n    function buyPrice()\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        // our calculation relies on the token supply, so we need supply. Doh.\r\n        if(tokenSupply_ == 0){\r\n            return tokenPriceInitial_ + tokenPriceIncremental_;\r\n        } else {\r\n            uint256 _P3D_received = tokensToP3D_(1e18);\r\n            uint256 _dividends = SafeMath.div(SafeMath.mul(_P3D_received, buyDividendFee_), 100);\r\n            uint256 _taxedP3D =  SafeMath.add(_P3D_received, _dividends);\r\n            \r\n            return _taxedP3D;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price scaling of buy orders.\r\n     */\r\n    function calculateTokensReceived(uint256 _amountOfETH)\r\n        public\r\n        view\r\n        returns(uint256 _P3D_received, uint256 _P4D_received)\r\n    {\r\n        uint256 P3D_received = _P3D.calculateTokensReceived(_amountOfETH);\r\n\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(P3D_received, buyDividendFee_), 100);\r\n        uint256 _taxedP3D = SafeMath.sub(P3D_received, _dividends);\r\n        uint256 _amountOfTokens = P3DtoTokens_(_taxedP3D);\r\n        \r\n        return (P3D_received, _amountOfTokens);\r\n    }\r\n\r\n    /**\r\n     * Function for the frontend to dynamically retrieve the price scaling of sell orders.\r\n     */\r\n    function calculateAmountReceived(uint256 _tokensToSell)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        require(_tokensToSell <= tokenSupply_);\r\n        uint256 _P3D_received = tokensToP3D_(_tokensToSell);\r\n        uint256 _dividends = SafeMath.div(SafeMath.mul(_P3D_received, sellDividendFee_), 100);\r\n        uint256 _taxedP3D = SafeMath.sub(_P3D_received, _dividends);\r\n        \r\n        return _taxedP3D;\r\n    }\r\n\r\n    /**\r\n    * Utility method to expose the P3D address for any child contracts to use\r\n    */\r\n    function P3D_address()\r\n        public\r\n        view\r\n        returns(address)\r\n    {\r\n        return address(_P3D);\r\n    }\r\n\r\n    /**\r\n    * Utility method to return all of the data needed for the front end in 1 call\r\n    */\r\n    function fetchAllDataForCustomer(address _customerAddress)\r\n        public\r\n        view\r\n        returns(uint256 _totalSupply, uint256 _totalBalance, uint256 _buyPrice, uint256 _sellPrice, uint256 _activationTime,\r\n                uint256 _customerTokens, uint256 _customerUnclaimedDividends, uint256 _customerStoredDividends, uint256 _customerSubdividends)\r\n    {\r\n        _totalSupply = totalSupply();\r\n        _totalBalance = totalBalance();\r\n        _buyPrice = buyPrice();\r\n        _sellPrice = sellPrice();\r\n        _activationTime = ACTIVATION_TIME;\r\n        _customerTokens = balanceOf(_customerAddress);\r\n        _customerUnclaimedDividends = dividendsOf(_customerAddress) + referralDividendsOf(_customerAddress);\r\n        _customerStoredDividends = storedDividendsOf(_customerAddress);\r\n        _customerSubdividends = subdividendsOf(_customerAddress);\r\n    }\r\n\r\n\r\n    /*==========================================\r\n    =            INTERNAL FUNCTIONS            =\r\n    ==========================================*/\r\n\r\n    // This function should always be called before a customers P4D balance changes.\r\n    // It's responsible for withdrawing any outstanding ETH dividends from the P3D exchange\r\n    // as well as distrubuting all of the additional ETH balance since the last update to\r\n    // all of the P4D token holders proportionally.\r\n    // After this it will move any owed subdividends into the customers withdrawable subdividend balance.\r\n    function updateSubdivsFor(address _customerAddress)\r\n        internal\r\n    {   \r\n        // withdraw the P3D dividends first\r\n        if (_P3D.myDividends(true) > 0) {\r\n            _P3D.withdraw();\r\n        }\r\n\r\n        // check if we have additional ETH in the contract since the last update\r\n        uint256 contractBalance = address(this).balance;\r\n        if (contractBalance > lastContractBalance_ && totalSupply() != 0) {\r\n            uint256 additionalDivsFromP3D = SafeMath.sub(contractBalance, lastContractBalance_);\r\n            totalDividendPoints_ = SafeMath.add(totalDividendPoints_, SafeMath.div(SafeMath.mul(additionalDivsFromP3D, magnitude), totalSupply()));\r\n            lastContractBalance_ = contractBalance;\r\n        }\r\n\r\n        // if this is the very first time this is called for a customer, set their starting point\r\n        if (divsMap_[_customerAddress].lastDividendPoints == 0) {\r\n            divsMap_[_customerAddress].lastDividendPoints = totalDividendPoints_;\r\n        }\r\n\r\n        // move any owing subdividends into the customers subdividend balance\r\n        uint256 owing = subdividendsOwing(_customerAddress);\r\n        if (owing > 0) {\r\n            divsMap_[_customerAddress].balance = SafeMath.add(divsMap_[_customerAddress].balance, owing);\r\n            divsMap_[_customerAddress].lastDividendPoints = totalDividendPoints_;\r\n        }\r\n    }\r\n\r\n    function withdrawInternal(address _customerAddress)\r\n        internal\r\n    {\r\n        // setup data\r\n        // dividendsOf() will return only divs, not the ref. bonus\r\n        uint256 _dividends = dividendsOf(_customerAddress); // get ref. bonus later in the code\r\n\r\n        // update dividend tracker\r\n        payoutsTo_[_customerAddress] += (int256)(_dividends * magnitude);\r\n\r\n        // add ref. bonus\r\n        _dividends += referralBalance_[_customerAddress];\r\n        referralBalance_[_customerAddress] = 0;\r\n\r\n        // store the divs\r\n        dividendsStored_[_customerAddress] = SafeMath.add(dividendsStored_[_customerAddress], _dividends);\r\n    }\r\n\r\n    function transferInternal(address _customerAddress, address _toAddress, uint256 _amountOfTokens)\r\n        internal\r\n        returns(bool)\r\n    {\r\n        // make sure we have the requested tokens\r\n        require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]);\r\n        updateSubdivsFor(_customerAddress);\r\n        updateSubdivsFor(_toAddress);\r\n\r\n        // withdraw and store all outstanding dividends first (if there is any)\r\n        if ((dividendsOf(_customerAddress) + referralDividendsOf(_customerAddress)) > 0) withdrawInternal(_customerAddress);\r\n\r\n        // exchange tokens\r\n        tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens);\r\n        tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _amountOfTokens);\r\n\r\n        // update dividend trackers\r\n        payoutsTo_[_customerAddress] -= (int256)(profitPerShare_ * _amountOfTokens);\r\n        payoutsTo_[_toAddress] += (int256)(profitPerShare_ * _amountOfTokens);\r\n\r\n        // fire event\r\n        emit Transfer(_customerAddress, _toAddress, _amountOfTokens);\r\n\r\n        // ERC20\r\n        return true;\r\n    }\r\n\r\n    function purchaseInternal(address _sender, uint256 _incomingEthereum, address _referredBy)\r\n        purchaseFilter(_sender, _incomingEthereum)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 purchaseAmount = _incomingEthereum;\r\n        uint256 excess = 0;\r\n        if (totalInputETH_ <= initialBuyLimitCap_) { // check if the total input ETH is less than the cap\r\n            if (purchaseAmount > initialBuyLimitPerTx_) { // if so check if the transaction is over the initial buy limit per transaction\r\n                purchaseAmount = initialBuyLimitPerTx_;\r\n                excess = SafeMath.sub(_incomingEthereum, purchaseAmount);\r\n            }\r\n            totalInputETH_ = SafeMath.add(totalInputETH_, purchaseAmount);\r\n        }\r\n\r\n        // return the excess if there is any\r\n        if (excess > 0) {\r\n             _sender.transfer(excess);\r\n        }\r\n\r\n        // buy P3D tokens with the entire purchase amount\r\n        // even though _P3D.buy() returns uint256, it was never implemented properly inside the P3D contract\r\n        // so in order to find out how much P3D was purchased, you need to check the balance first then compare\r\n        // the balance after the purchase and the difference will be the amount purchased\r\n        uint256 tmpBalanceBefore = _P3D.myTokens();\r\n        _P3D.buy.value(purchaseAmount)(_referredBy);\r\n        uint256 purchasedP3D = SafeMath.sub(_P3D.myTokens(), tmpBalanceBefore);\r\n\r\n        return purchaseTokens(_sender, purchasedP3D, _referredBy);\r\n    }\r\n\r\n\r\n    function purchaseTokens(address _sender, uint256 _incomingP3D, address _referredBy)\r\n        internal\r\n        returns(uint256)\r\n    {\r\n        updateSubdivsFor(_sender);\r\n\r\n        // data setup\r\n        uint256 _undividedDividends = SafeMath.div(SafeMath.mul(_incomingP3D, buyDividendFee_), 100);\r\n        uint256 _referralBonus = SafeMath.div(_undividedDividends, 3);\r\n        uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus);\r\n        uint256 _taxedP3D = SafeMath.sub(_incomingP3D, _undividedDividends);\r\n        uint256 _amountOfTokens = P3DtoTokens_(_taxedP3D);\r\n        uint256 _fee = _dividends * magnitude;\r\n\r\n        // no point in continuing execution if OP is a poorfag russian hacker\r\n        // prevents overflow in the case that the pyramid somehow magically starts being used by everyone in the world\r\n        // (or hackers)\r\n        // and yes we know that the safemath function automatically rules out the \"greater then\" equasion.\r\n        require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens, tokenSupply_) > tokenSupply_));\r\n\r\n        // is the user referred by a masternode?\r\n        if (\r\n            // is this a referred purchase?\r\n            _referredBy != address(0x0) &&\r\n\r\n            // no cheating!\r\n            _referredBy != _sender &&\r\n\r\n            // does the referrer have at least X whole tokens?\r\n            // i.e is the referrer a godly chad masternode\r\n            tokenBalanceLedger_[_referredBy] >= stakingRequirement\r\n        ) {\r\n            // wealth redistribution\r\n            referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus);\r\n        } else {\r\n            // no ref purchase\r\n            // add the referral bonus back to the global dividends cake\r\n            _dividends = SafeMath.add(_dividends, _referralBonus);\r\n            _fee = _dividends * magnitude;\r\n        }\r\n\r\n        // we can't give people infinite P3D\r\n        if(tokenSupply_ > 0){\r\n\r\n            // add tokens to the pool\r\n            tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens);\r\n\r\n            // take the amount of dividends gained through this transaction, and allocates them evenly to each shareholder\r\n            profitPerShare_ += (_dividends * magnitude / (tokenSupply_));\r\n\r\n            // calculate the amount of tokens the customer receives over their purchase\r\n            _fee = _fee - (_fee - (_amountOfTokens * (_dividends * magnitude / (tokenSupply_))));\r\n\r\n        } else {\r\n            // add tokens to the pool\r\n            tokenSupply_ = _amountOfTokens;\r\n        }\r\n\r\n        // update circulating supply & the ledger address for the customer\r\n        tokenBalanceLedger_[_sender] = SafeMath.add(tokenBalanceLedger_[_sender], _amountOfTokens);\r\n\r\n        // Tells the contract that the buyer doesn't deserve dividends for the tokens before they owned them;\r\n        // really I know you think you do but you don't\r\n        payoutsTo_[_sender] += (int256)((profitPerShare_ * _amountOfTokens) - _fee);\r\n\r\n        // fire events\r\n        emit onTokenPurchase(_sender, _incomingP3D, _amountOfTokens, _referredBy);\r\n        emit Transfer(address(0x0), _sender, _amountOfTokens);\r\n\r\n        return _amountOfTokens;\r\n    }\r\n\r\n    /**\r\n     * Calculate token price based on an amount of incoming P3D\r\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function P3DtoTokens_(uint256 _P3D_received)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18;\r\n        uint256 _tokensReceived =\r\n         (\r\n            (\r\n                // underflow attempts BTFO\r\n                SafeMath.sub(\r\n                    (sqrt\r\n                        (\r\n                            (_tokenPriceInitial**2)\r\n                            +\r\n                            (2 * (tokenPriceIncremental_ * 1e18)*(_P3D_received * 1e18))\r\n                            +\r\n                            (((tokenPriceIncremental_)**2) * (tokenSupply_**2))\r\n                            +\r\n                            (2 * (tokenPriceIncremental_) * _tokenPriceInitial * tokenSupply_)\r\n                        )\r\n                    ), _tokenPriceInitial\r\n                )\r\n            ) / (tokenPriceIncremental_)\r\n        ) - (tokenSupply_);\r\n\r\n        return _tokensReceived;\r\n    }\r\n\r\n    /**\r\n     * Calculate token sell value.\r\n     * It's an algorithm, hopefully we gave you the whitepaper with it in scientific notation;\r\n     * Some conversions occurred to prevent decimal errors or underflows / overflows in solidity code.\r\n     */\r\n    function tokensToP3D_(uint256 _P4D_tokens)\r\n        internal\r\n        view\r\n        returns(uint256)\r\n    {\r\n\r\n        uint256 tokens_ = (_P4D_tokens + 1e18);\r\n        uint256 _tokenSupply = (tokenSupply_ + 1e18);\r\n        uint256 _P3D_received =\r\n        (\r\n            // underflow attempts BTFO\r\n            SafeMath.sub(\r\n                (\r\n                    (\r\n                        (\r\n                            tokenPriceInitial_ + (tokenPriceIncremental_ * (_tokenSupply / 1e18))\r\n                        ) - tokenPriceIncremental_\r\n                    ) * (tokens_ - 1e18)\r\n                ), (tokenPriceIncremental_ * ((tokens_**2 - tokens_) / 1e18)) / 2\r\n            )\r\n        / 1e18);\r\n\r\n        return _P3D_received;\r\n    }\r\n\r\n\r\n    // This is where all your gas goes, sorry\r\n    // Not sorry, you probably only paid 1 gwei\r\n    function sqrt(uint x) internal pure returns (uint y) {\r\n        uint z = (x + 1) / 2;\r\n        y = x;\r\n        while (z < y) {\r\n            y = z;\r\n            z = (x / z + z) / 2;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Additional check that the address we are sending tokens to is a contract\r\n     * assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n     */\r\n    function isContract(address _addr)\r\n        internal\r\n        constant\r\n        returns(bool)\r\n    {\r\n        // retrieve the size of the code on target address, this needs assembly\r\n        uint length;\r\n        assembly { length := extcodesize(_addr) }\r\n        return length > 0;\r\n    }\r\n\r\n    /**\r\n     * Utility method to help store the registered names\r\n     */\r\n    function stringToBytes32(string memory _s)\r\n        internal\r\n        pure\r\n        returns(bytes32 result)\r\n    {\r\n        bytes memory tmpEmptyStringTest = bytes(_s);\r\n        if (tmpEmptyStringTest.length == 0) {\r\n            return 0x0;\r\n        }\r\n        assembly { result := mload(add(_s, 32)) }\r\n    }\r\n\r\n    /**\r\n     * Utility method to help read the registered names\r\n     */\r\n    function bytes32ToString(bytes32 _b)\r\n        internal\r\n        pure\r\n        returns(string)\r\n    {\r\n        bytes memory bytesString = new bytes(32);\r\n        uint charCount = 0;\r\n        for (uint256 i = 0; i < 32; i++) {\r\n            byte char = byte(bytes32(uint(_b) * 2 ** (8 * i)));\r\n            if (char != 0) {\r\n                bytesString[charCount++] = char;\r\n            }\r\n        }\r\n        bytes memory bytesStringTrimmed = new bytes(charCount);\r\n        for (i = 0; i < charCount; i++) {\r\n            bytesStringTrimmed[i] = bytesString[i];\r\n        }\r\n        return string(bytesStringTrimmed);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n// \r\n// pragma solidity ^0.4.25;\r\n// \r\n// interface P4D {\r\n//     function buy(address) external payable returns(uint256);\r\n//     function sell(uint256) external;\r\n//     function transfer(address, uint256) external returns(bool);\r\n//     function myTokens() external view returns(uint256);\r\n//     function myStoredDividends() external view returns(uint256);\r\n//     function mySubdividends() external view returns(uint256);\r\n//     function reinvest(bool) external;\r\n//     function reinvestSubdivs(bool) external;\r\n//     function withdraw(bool) external;\r\n//     function withdrawSubdivs(bool) external;\r\n//     function exit(bool) external; // sell + withdraw + withdrawSubdivs\r\n//     function P3D_address() external view returns(address);\r\n// }\r\n// \r\n// contract usingP4D {\r\n// \r\n//     P4D public tokenContract;\r\n// \r\n//     constructor(address _P4D_address) public {\r\n//         tokenContract = P4D(_P4D_address);\r\n//     }\r\n// \r\n//     modifier onlyTokenContract {\r\n//         require(msg.sender == address(tokenContract));\r\n//         _;\r\n//     }\r\n// \r\n//     function tokenCallback(address _from, uint256 _value, bytes _data) external returns (bool);\r\n// }\r\n// \r\n// contract YourDapp is usingP4D {\r\n// \r\n//     constructor(address _P4D_address)\r\n//         public\r\n//         usingP4D(_P4D_address)\r\n//     {\r\n//         //...\r\n//     }\r\n// \r\n//     function tokenCallback(address _from, uint256 _value, bytes _data)\r\n//         external\r\n//         onlyTokenContract\r\n//         returns (bool)\r\n//     {\r\n//         //...\r\n//         return true;\r\n//     }\r\n//\r\n//     function()\r\n//         payable\r\n//         public\r\n//     {\r\n//         if (msg.sender != address(tokenContract)) {\r\n//             //...\r\n//         }\r\n//     }\r\n// }\r\n//\r\n/*===========================================================================================*\r\n*************************************** https://p4d.io ***************************************\r\n*===========================================================================================*/","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"dividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"activeNameOf\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfP3D\",\"type\":\"uint256\"}],\"name\":\"withdrawAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"registerName\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"canAcceptTokens_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_amountOfETH\",\"type\":\"uint256\"}],\"name\":\"calculateTokensReceived\",\"outputs\":[{\"name\":\"_P3D_received\",\"type\":\"uint256\"},{\"name\":\"_P4D_received\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myStoredDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"onlyAmbassadors\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"storedDividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAmbassador\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"changeActiveNameTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newActiveIndex\",\"type\":\"uint256\"}],\"name\":\"changeActiveNameIndexTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_includeReferralBonus\",\"type\":\"bool\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"name\":\"withdrawSubdivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfP3D\",\"type\":\"uint256\"}],\"name\":\"reinvestAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokensToSell\",\"type\":\"uint256\"}],\"name\":\"calculateAmountReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"administrators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"ownerOfName\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ACTIVATION_TIME\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"setStakingRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"namesOf\",\"outputs\":[{\"name\":\"activeIndex\",\"type\":\"uint256\"},{\"name\":\"activeName\",\"type\":\"string\"},{\"name\":\"customerNames\",\"type\":\"bytes32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"buyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"P3D_address\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_identifier\",\"type\":\"address\"},{\"name\":\"_status\",\"type\":\"bool\"}],\"name\":\"setAdministrator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toAddress\",\"type\":\"address\"},{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfETH\",\"type\":\"uint256\"}],\"name\":\"reinvestSubdivsAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"name\":\"setSymbol\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mySubdividends\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameOfReferrer\",\"type\":\"string\"}],\"name\":\"buyWithNameRef\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"name\":\"setName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfETH\",\"type\":\"uint256\"}],\"name\":\"withdrawSubdivsAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"name\":\"reinvestSubdivs\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setCanAcceptTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"referralDividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountOfTokens\",\"type\":\"uint256\"}],\"name\":\"sell\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"subdividendsOwing\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"name\":\"exit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"donate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"fetchAllDataForCustomer\",\"outputs\":[{\"name\":\"_totalSupply\",\"type\":\"uint256\"},{\"name\":\"_totalBalance\",\"type\":\"uint256\"},{\"name\":\"_buyPrice\",\"type\":\"uint256\"},{\"name\":\"_sellPrice\",\"type\":\"uint256\"},{\"name\":\"_activationTime\",\"type\":\"uint256\"},{\"name\":\"_customerTokens\",\"type\":\"uint256\"},{\"name\":\"_customerUnclaimedDividends\",\"type\":\"uint256\"},{\"name\":\"_customerStoredDividends\",\"type\":\"uint256\"},{\"name\":\"_customerSubdividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_customerAddress\",\"type\":\"address\"}],\"name\":\"subdividendsOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_activationTime\",\"type\":\"uint256\"},{\"name\":\"_P3D_address\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_incomingP3D\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensMinted\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"_referredBy\",\"type\":\"address\"}],\"name\":\"onTokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokensBurned\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_P3D_received\",\"type\":\"uint256\"}],\"name\":\"onTokenSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_P3D_reinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ETH_reinvested\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokensMinted\",\"type\":\"uint256\"}],\"name\":\"onSubdivsReinvestment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_P3D_withdrawn\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_ETH_withdrawn\",\"type\":\"uint256\"}],\"name\":\"onSubdivsWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_customerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_registeredName\",\"type\":\"string\"}],\"name\":\"onNameRegistration\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"P4D","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005bff4820000000000000000000000000b3775fb83f7d12a36e0475abdd1fca35c091efbe","Library":"","SwarmSource":"bzzr://a97d163bc012d67a66350ff5dbfae0a464d39535e7d4319cb913b2a1cd18ecdf"}]}