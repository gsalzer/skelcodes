{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * This contract is used to publish hashed contribution agreements for disclosures\r\n * already published in the DisclosureManager contract. These agreements require\r\n * multi party sign off which this contract facilitates.\r\n */\r\ncontract DisclosureAgreementTracker {\r\n\r\n    /**\r\n     * Represents a contribution agreement for a disclosure. An agreement is\r\n     * referenced by the sha256 hash of its contract in `agreementMap`.\r\n     */\r\n    struct Agreement {\r\n        // previous version of an agreement for this disclosure\r\n        bytes32 previous;\r\n        // index of the disclosure in disclosureManager\r\n        uint disclosureIndex;\r\n        // block this agreement was created in\r\n        uint blockNumber;\r\n        // total signatures obtained so far\r\n        uint signedCount;\r\n        // addresses from which signatures are required\r\n        address[] signatories;\r\n        // map of signatory address to true, if signature not yet obtained\r\n        mapping(address => bool) requiredSignatures;\r\n    }\r\n\r\n    /**\r\n     * Tracks the latest agreement and total agreements for a disclosure.\r\n     * Referenced by disclosure index in `latestAgreementMap`.\r\n     */\r\n    struct Latest {\r\n        bytes32 agreementHash;\r\n        uint agreementCount;\r\n    }\r\n\r\n    /** Contract creator */\r\n    address public owner;\r\n\r\n    /** Address of the DisclosureManager contract these agreements apply to */\r\n    address public disclosureManager;\r\n\r\n    /** Total agreements tracked */\r\n    uint public agreementCount;\r\n\r\n    /** Total disclosures with agreements */\r\n    uint public disclosureCount;\r\n\r\n    /** Map of agreements by contract sha256 hash */\r\n    mapping(bytes32 => Agreement) public agreementMap;\r\n\r\n    /** Map disclosure index to latest agreement */\r\n    mapping(uint => Latest) public latestMap;\r\n\r\n    /** Emitted when agreement is added */\r\n    event agreementAdded(\r\n        bytes32 agreementHash,\r\n        uint disclosureIndex,\r\n        address[] signatories);\r\n\r\n    /** Emitted when agreement is signed */\r\n    event agreementSigned(\r\n        bytes32 agreementHash,\r\n        uint disclosureIndex,\r\n        address signatory);\r\n\r\n    /** Emitted when an agreement is signed by all signatories */\r\n    event agreementFullySigned(\r\n        bytes32 agreementHash,\r\n        uint disclosureIndex);\r\n\r\n    constructor(address disclosureManagerAddress) public {\r\n        owner = msg.sender;\r\n        disclosureManager = disclosureManagerAddress;\r\n    }\r\n\r\n    /** Enforce function caller is contract owner */\r\n    modifier isOwner() {\r\n        if (msg.sender != owner) revert(\"sender must be owner\");\r\n        _;\r\n    }\r\n\r\n    function _hasAgreement(Agreement agreement) private pure returns(bool) {\r\n        return agreement.disclosureIndex != 0;\r\n    }\r\n\r\n    /** Return true if the agreement exists */\r\n    function hasAgreement(bytes32 agreementHash) public view returns(bool) {\r\n        return _hasAgreement(agreementMap[agreementHash]);\r\n    }\r\n\r\n    function _hasDisclosureAgreement(Latest latest) private pure returns(bool) {\r\n        return latest.agreementCount != 0;\r\n    }\r\n\r\n    /** Return true if the disclosure has an agreement */\r\n    function hasDisclosureAgreement(uint disclosureIndex) public view returns(bool) {\r\n        return _hasDisclosureAgreement(latestMap[disclosureIndex]);\r\n    }\r\n\r\n    function _isAgreementFullySigned(Agreement agreement)\r\n    private pure returns(bool) {\r\n        return agreement.signedCount == agreement.signatories.length;\r\n    }\r\n\r\n    /** Return true if the agreement exists and is fully signed */\r\n    function isAgreementFullySigned(bytes32 agreementHash)\r\n    public view returns(bool) {\r\n        Agreement storage agreement = agreementMap[agreementHash];\r\n        return _hasAgreement(agreement)\r\n            && _isAgreementFullySigned(agreement);\r\n    }\r\n\r\n    /** Return true if disclosures latest agreement is fully signed. */\r\n    function isDisclosureFullySigned(uint disclosureIndex)\r\n    public view returns(bool) {\r\n        return isAgreementFullySigned(\r\n            latestMap[disclosureIndex].agreementHash\r\n        );\r\n    }\r\n    \r\n    /**\r\n     * Get the Agreement requiredSignatures map as an array of bools parallel\r\n     * to its signatories array.\r\n     */\r\n    function _getRequiredSignaturesArray(Agreement storage agreement)\r\n    private view returns (bool[]) {\r\n        address[] storage signatories = agreement.signatories;\r\n        bool[] memory requiredSignatureArray = new bool[](signatories.length);\r\n        for (uint i = 0; i < signatories.length; i++) {\r\n            address signatory = signatories[i];\r\n            requiredSignatureArray[i] = agreement.requiredSignatures[signatory];\r\n        }\r\n        return requiredSignatureArray;\r\n    }\r\n\r\n    /** Get the agreement with the provided hash */\r\n    function getAgreement(bytes32 agreementHash)\r\n    public view returns(\r\n        bytes32 previous, uint disclosureIndex, uint blockNumber,\r\n        uint signedCount, address[] signatories, bool[] requiredSignatures\r\n    ) {\r\n        Agreement storage agreement = agreementMap[agreementHash];\r\n        previous = agreement.previous;\r\n        disclosureIndex = agreement.disclosureIndex;\r\n        blockNumber = agreement.blockNumber;\r\n        signedCount = agreement.signedCount;\r\n        signatories = agreement.signatories;\r\n        requiredSignatures = _getRequiredSignaturesArray(agreement);\r\n    }\r\n\r\n    /**\r\n     * Add an agreement for the provided disclosure. If an agreement already\r\n     * exists that disclosures latestAgreement will be updated and\r\n     * the existing agreement will not be removed.\r\n     */\r\n    function addAgreement(\r\n        bytes32 agreementHash,\r\n        uint disclosureIndex,\r\n        address[] signatories\r\n    ) public isOwner {\r\n        require(disclosureIndex > 0, \"disclosureIndex must be greater than 0\");\r\n        require(agreementHash != 0, \"agreementHash must not be 0\");\r\n        require(signatories.length > 0, \"signatories must not be empty\");\r\n\r\n        Agreement storage agreement = agreementMap[agreementHash];\r\n        if (_hasAgreement(agreement)) {\r\n            revert(\"Agreement already exists\");\r\n        }\r\n        agreementCount++;\r\n        agreement.disclosureIndex = disclosureIndex;\r\n        agreement.blockNumber = block.number;\r\n        agreement.signatories = signatories;\r\n\r\n        Latest storage latest = latestMap[disclosureIndex];\r\n        if (!_hasDisclosureAgreement(latest)) {\r\n            disclosureCount++;\r\n        }\r\n        agreement.previous = latest.agreementHash;\r\n        latest.agreementHash = agreementHash;\r\n        latest.agreementCount++;\r\n\r\n        for (uint i = 0; i < signatories.length; i++) {\r\n            address signatory = signatories[i];\r\n            if (agreement.requiredSignatures[signatory]) {\r\n                revert(\"signatories must not contain duplicates\");\r\n            }\r\n            agreement.requiredSignatures[signatory] = true;\r\n        }\r\n        \r\n        emit agreementAdded(agreementHash, disclosureIndex, signatories);\r\n    }\r\n\r\n    /**\r\n     * Sign an agreement.\r\n     * Returns true if signature applied, false if not a signatory or already\r\n     * signed.\r\n     */\r\n    function signAgreement(bytes32 agreementHash) public {\r\n        require(hasAgreement(agreementHash), \"agreeement must exist\");\r\n\r\n        Agreement storage agreement = agreementMap[agreementHash];\r\n        bool signed = agreement.requiredSignatures[msg.sender];\r\n        require(signed, \"sender already signed or not a signatory\");\r\n\r\n        agreement.requiredSignatures[msg.sender] = false;\r\n        agreement.signedCount++;\r\n\r\n        emit agreementSigned(\r\n            agreementHash,\r\n            agreement.disclosureIndex,\r\n            msg.sender);\r\n\r\n        if (_isAgreementFullySigned(agreement)) {\r\n            emit agreementFullySigned(\r\n                agreementHash,\r\n                agreement.disclosureIndex);\r\n        }\r\n    }\r\n\r\n    /** This contract does not accept payments */\r\n    function () public payable {\r\n        revert(\"payment not supported\");\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"agreementHash\",\"type\":\"bytes32\"}],\"name\":\"isAgreementFullySigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"disclosureIndex\",\"type\":\"uint256\"}],\"name\":\"hasDisclosureAgreement\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementHash\",\"type\":\"bytes32\"}],\"name\":\"hasAgreement\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"disclosureIndex\",\"type\":\"uint256\"}],\"name\":\"isDisclosureFullySigned\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disclosureManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"name\":\"disclosureIndex\",\"type\":\"uint256\"},{\"name\":\"signatories\",\"type\":\"address[]\"}],\"name\":\"addAgreement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"latestMap\",\"outputs\":[{\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"name\":\"agreementCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"agreementMap\",\"outputs\":[{\"name\":\"previous\",\"type\":\"bytes32\"},{\"name\":\"disclosureIndex\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"signedCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"agreementCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agreementHash\",\"type\":\"bytes32\"}],\"name\":\"signAgreement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"disclosureCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"agreementHash\",\"type\":\"bytes32\"}],\"name\":\"getAgreement\",\"outputs\":[{\"name\":\"previous\",\"type\":\"bytes32\"},{\"name\":\"disclosureIndex\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"signedCount\",\"type\":\"uint256\"},{\"name\":\"signatories\",\"type\":\"address[]\"},{\"name\":\"requiredSignatures\",\"type\":\"bool[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"disclosureManagerAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"disclosureIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"signatories\",\"type\":\"address[]\"}],\"name\":\"agreementAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"disclosureIndex\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"signatory\",\"type\":\"address\"}],\"name\":\"agreementSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"agreementHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"disclosureIndex\",\"type\":\"uint256\"}],\"name\":\"agreementFullySigned\",\"type\":\"event\"}]","ContractName":"DisclosureAgreementTracker","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ff77e51f2c6473f72392865e0a0000de19af774a","Library":"","SwarmSource":"bzzr://f405b6ba80de4fc06399a3a11f69de40a768ce0a10fe7a50073ad1e1b63b00d1"}]}