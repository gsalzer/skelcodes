{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: zos-lib/contracts/migrations/Migratable.sol\r\n\r\n/**\r\n * @title Migratable\r\n * Helper contract to support intialization and migration schemes between\r\n * different implementations of a contract in the context of upgradeability.\r\n * To use it, replace the constructor with a function that has the\r\n * `isInitializer` modifier starting with `\"0\"` as `migrationId`.\r\n * When you want to apply some migration code during an upgrade, increase\r\n * the `migrationId`. Or, if the migration code must be applied only after\r\n * another migration has been already applied, use the `isMigration` modifier.\r\n * This helper supports multiple inheritance.\r\n * WARNING: It is the developer's responsibility to ensure that migrations are\r\n * applied in a correct order, or that they are run at all.\r\n * See `Initializable` for a simpler version.\r\n */\r\ncontract Migratable {\r\n  /**\r\n   * @dev Emitted when the contract applies a migration.\r\n   * @param contractName Name of the Contract.\r\n   * @param migrationId Identifier of the migration applied.\r\n   */\r\n  event Migrated(string contractName, string migrationId);\r\n\r\n  /**\r\n   * @dev Mapping of the already applied migrations.\r\n   * (contractName => (migrationId => bool))\r\n   */\r\n  mapping (string => mapping (string => bool)) internal migrated;\r\n\r\n  /**\r\n   * @dev Internal migration id used to specify that a contract has already been initialized.\r\n   */\r\n  string constant private INITIALIZED_ID = \"initialized\";\r\n\r\n\r\n  /**\r\n   * @dev Modifier to use in the initialization function of a contract.\r\n   * @param contractName Name of the contract.\r\n   * @param migrationId Identifier of the migration.\r\n   */\r\n  modifier isInitializer(string contractName, string migrationId) {\r\n    validateMigrationIsPending(contractName, INITIALIZED_ID);\r\n    validateMigrationIsPending(contractName, migrationId);\r\n    _;\r\n    emit Migrated(contractName, migrationId);\r\n    migrated[contractName][migrationId] = true;\r\n    migrated[contractName][INITIALIZED_ID] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to use in the migration of a contract.\r\n   * @param contractName Name of the contract.\r\n   * @param requiredMigrationId Identifier of the previous migration, required\r\n   * to apply new one.\r\n   * @param newMigrationId Identifier of the new migration to be applied.\r\n   */\r\n  modifier isMigration(string contractName, string requiredMigrationId, string newMigrationId) {\r\n    require(isMigrated(contractName, requiredMigrationId), \"Prerequisite migration ID has not been run yet\");\r\n    validateMigrationIsPending(contractName, newMigrationId);\r\n    _;\r\n    emit Migrated(contractName, newMigrationId);\r\n    migrated[contractName][newMigrationId] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns true if the contract migration was applied.\r\n   * @param contractName Name of the contract.\r\n   * @param migrationId Identifier of the migration.\r\n   * @return true if the contract migration was applied, false otherwise.\r\n   */\r\n  function isMigrated(string contractName, string migrationId) public view returns(bool) {\r\n    return migrated[contractName][migrationId];\r\n  }\r\n\r\n  /**\r\n   * @dev Initializer that marks the contract as initialized.\r\n   * It is important to run this if you had deployed a previous version of a Migratable contract.\r\n   * For more information see https://github.com/zeppelinos/zos-lib/issues/158.\r\n   */\r\n  function initialize() isInitializer(\"Migratable\", \"1.2.1\") public {\r\n  }\r\n\r\n  /**\r\n   * @dev Reverts if the requested migration was already executed.\r\n   * @param contractName Name of the contract.\r\n   * @param migrationId Identifier of the migration.\r\n   */\r\n  function validateMigrationIsPending(string contractName, string migrationId) private view {\r\n    require(!isMigrated(contractName, migrationId), \"Requested target migration ID has already been run\");\r\n  }\r\n}\r\n\r\n// File: openzeppelin-zos/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable is Migratable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function initialize(address _sender) public isInitializer(\"Ownable\", \"1.9.0\") {\r\n    owner = _sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    emit OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-zos/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Migratable, Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  function initialize(address _sender) isInitializer(\"Pausable\", \"1.9.0\")  public {\r\n    Ownable.initialize(_sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-zos/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-zos/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/marketplace/MarketplaceStorage.sol\r\n\r\n/**\r\n * @title Interface for contracts conforming to ERC-20\r\n */\r\ncontract ERC20Interface {\r\n  function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n}\r\n\r\n\r\n/**\r\n * @title Interface for contracts conforming to ERC-721\r\n */\r\ncontract ERC721Interface {\r\n  function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n  function approve(address _to, uint256 _tokenId) public;\r\n  function getApproved(uint256 _tokenId) public view returns (address);\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n  function supportsInterface(bytes4) public view returns (bool);\r\n}\r\n\r\n\r\ncontract ERC721Verifiable is ERC721Interface {\r\n  function verifyFingerprint(uint256, bytes) public view returns (bool);\r\n}\r\n\r\n\r\ncontract MarketplaceStorage {\r\n  ERC20Interface public acceptedToken;\r\n\r\n  struct Order {\r\n    // Order ID\r\n    bytes32 id;\r\n    // Owner of the NFT\r\n    address seller;\r\n    // NFT registry address\r\n    address nftAddress;\r\n    // Price (in wei) for the published item\r\n    uint256 price;\r\n    // Time when this sale ends\r\n    uint256 expiresAt;\r\n  }\r\n\r\n  // From ERC721 registry assetId to Order (to avoid asset collision)\r\n  mapping (address => mapping(uint256 => Order)) public orderByAssetId;\r\n\r\n  uint256 public ownerCutPercentage;\r\n  uint256 public publicationFeeInWei;\r\n\r\n  address public legacyNFTAddress;\r\n\r\n  bytes4 public constant InterfaceId_ValidateFingerprint = bytes4(\r\n    keccak256(\"verifyFingerprint(uint256,bytes)\")\r\n  );\r\n\r\n  bytes4 public constant ERC721_Interface = bytes4(0x80ac58cd);\r\n\r\n  // EVENTS\r\n  event OrderCreated(\r\n    bytes32 id,\r\n    uint256 indexed assetId,\r\n    address indexed seller,\r\n    address nftAddress,\r\n    uint256 priceInWei,\r\n    uint256 expiresAt\r\n  );\r\n  event OrderSuccessful(\r\n    bytes32 id,\r\n    uint256 indexed assetId,\r\n    address indexed seller,\r\n    address nftAddress,\r\n    uint256 totalPrice,\r\n    address indexed buyer\r\n  );\r\n  event OrderCancelled(\r\n    bytes32 id,\r\n    uint256 indexed assetId,\r\n    address indexed seller,\r\n    address nftAddress\r\n  );\r\n\r\n  event ChangedPublicationFee(uint256 publicationFee);\r\n  event ChangedOwnerCutPercentage(uint256 ownerCutPercentage);\r\n  event ChangeLegacyNFTAddress(address indexed legacyNFTAddress);\r\n\r\n  // [LEGACY] Auction events\r\n  event AuctionCreated(\r\n    bytes32 id,\r\n    uint256 indexed assetId,\r\n    address indexed seller,\r\n    uint256 priceInWei,\r\n    uint256 expiresAt\r\n  );\r\n  event AuctionSuccessful(\r\n    bytes32 id,\r\n    uint256 indexed assetId,\r\n    address indexed seller,\r\n    uint256 totalPrice,\r\n    address indexed winner\r\n  );\r\n  event AuctionCancelled(\r\n    bytes32 id,\r\n    uint256 indexed assetId,\r\n    address indexed seller\r\n  );\r\n}\r\n\r\n// File: contracts/marketplace/Marketplace.sol\r\n\r\ncontract Marketplace is Migratable, Ownable, Pausable, MarketplaceStorage {\r\n  using SafeMath for uint256;\r\n  using AddressUtils for address;\r\n\r\n  /**\r\n    * @dev Sets the publication fee that's charged to users to publish items\r\n    * @param _publicationFee - Fee amount in wei this contract charges to publish an item\r\n    */\r\n  function setPublicationFee(uint256 _publicationFee) external onlyOwner {\r\n    publicationFeeInWei = _publicationFee;\r\n    emit ChangedPublicationFee(publicationFeeInWei);\r\n  }\r\n\r\n  /**\r\n    * @dev Sets the share cut for the owner of the contract that's\r\n    *  charged to the seller on a successful sale\r\n    * @param _ownerCutPercentage - Share amount, from 0 to 99\r\n    */\r\n  function setOwnerCutPercentage(uint256 _ownerCutPercentage) external onlyOwner {\r\n    require(_ownerCutPercentage < 100, \"The owner cut should be between 0 and 99\");\r\n\r\n    ownerCutPercentage = _ownerCutPercentage;\r\n    emit ChangedOwnerCutPercentage(ownerCutPercentage);\r\n  }\r\n\r\n  /**\r\n    * @dev Sets the legacy NFT address to be used\r\n    * @param _legacyNFTAddress - Address of the NFT address used for legacy methods that don't have nftAddress as parameter\r\n    */\r\n  function setLegacyNFTAddress(address _legacyNFTAddress) external onlyOwner {\r\n    _requireERC721(_legacyNFTAddress);\r\n\r\n    legacyNFTAddress = _legacyNFTAddress;\r\n    emit ChangeLegacyNFTAddress(legacyNFTAddress);\r\n  }\r\n\r\n  /**\r\n    * @dev Initialize this contract. Acts as a constructor\r\n    * @param _acceptedToken - Address of the ERC20 accepted for this marketplace\r\n    * @param _legacyNFTAddress - Address of the NFT address used for legacy methods that don't have nftAddress as parameter\r\n    */\r\n  function initialize(\r\n    address _acceptedToken,\r\n    address _legacyNFTAddress,\r\n    address _owner\r\n  )\r\n    public\r\n    isInitializer(\"Marketplace\", \"0.0.1\")\r\n  {\r\n\r\n    // msg.sender is the App contract not the real owner. Calls ownable behind the scenes...sigh\r\n    require(_owner != address(0), \"Invalid owner\");\r\n    Pausable.initialize(_owner); \r\n    \r\n    require(_acceptedToken.isContract(), \"The accepted token address must be a deployed contract\");\r\n    acceptedToken = ERC20Interface(_acceptedToken);\r\n\r\n    _requireERC721(_legacyNFTAddress);\r\n    legacyNFTAddress = _legacyNFTAddress;\r\n  }\r\n\r\n  /**\r\n    * @dev Creates a new order\r\n    * @param nftAddress - Non fungible registry address\r\n    * @param assetId - ID of the published NFT\r\n    * @param priceInWei - Price in Wei for the supported coin\r\n    * @param expiresAt - Duration of the order (in hours)\r\n    */\r\n  function createOrder(\r\n    address nftAddress,\r\n    uint256 assetId,\r\n    uint256 priceInWei,\r\n    uint256 expiresAt\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    _createOrder(\r\n      nftAddress,\r\n      assetId,\r\n      priceInWei,\r\n      expiresAt\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev [LEGACY] Creates a new order\r\n    * @param assetId - ID of the published NFT\r\n    * @param priceInWei - Price in Wei for the supported coin\r\n    * @param expiresAt - Duration of the order (in hours)\r\n    */\r\n  function createOrder(\r\n    uint256 assetId,\r\n    uint256 priceInWei,\r\n    uint256 expiresAt\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    _createOrder(\r\n      legacyNFTAddress,\r\n      assetId,\r\n      priceInWei,\r\n      expiresAt\r\n    );\r\n\r\n    Order memory order = orderByAssetId[legacyNFTAddress][assetId];\r\n    emit AuctionCreated(\r\n      order.id,\r\n      assetId,\r\n      order.seller,\r\n      order.price,\r\n      order.expiresAt\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev Cancel an already published order\r\n    *  can only be canceled by seller or the contract owner\r\n    * @param nftAddress - Address of the NFT registry\r\n    * @param assetId - ID of the published NFT\r\n    */\r\n  function cancelOrder(address nftAddress, uint256 assetId) public whenNotPaused {\r\n    _cancelOrder(nftAddress, assetId);\r\n  }\r\n\r\n  /**\r\n    * @dev [LEGACY] Cancel an already published order\r\n    *  can only be canceled by seller or the contract owner\r\n    * @param assetId - ID of the published NFT\r\n    */\r\n  function cancelOrder(uint256 assetId) public whenNotPaused {\r\n    Order memory order = _cancelOrder(legacyNFTAddress, assetId);\r\n\r\n    emit AuctionCancelled(\r\n      order.id,\r\n      assetId,\r\n      order.seller\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev Executes the sale for a published NFT and checks for the asset fingerprint\r\n    * @param nftAddress - Address of the NFT registry\r\n    * @param assetId - ID of the published NFT\r\n    * @param price - Order price\r\n    * @param fingerprint - Verification info for the asset\r\n    */\r\n  function safeExecuteOrder(\r\n    address nftAddress,\r\n    uint256 assetId,\r\n    uint256 price,\r\n    bytes fingerprint\r\n  )\r\n   public\r\n   whenNotPaused\r\n  {\r\n    _executeOrder(\r\n      nftAddress,\r\n      assetId,\r\n      price,\r\n      fingerprint\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev Executes the sale for a published NFT\r\n    * @param nftAddress - Address of the NFT registry\r\n    * @param assetId - ID of the published NFT\r\n    * @param price - Order price\r\n    */\r\n  function executeOrder(\r\n    address nftAddress,\r\n    uint256 assetId,\r\n    uint256 price\r\n  )\r\n   public\r\n   whenNotPaused\r\n  {\r\n    _executeOrder(\r\n      nftAddress,\r\n      assetId,\r\n      price,\r\n      \"\"\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev [LEGACY] Executes the sale for a published NFT\r\n    * @param assetId - ID of the published NFT\r\n    * @param price - Order price\r\n    */\r\n  function executeOrder(\r\n    uint256 assetId,\r\n    uint256 price\r\n  )\r\n   public\r\n   whenNotPaused\r\n  {\r\n    Order memory order = _executeOrder(\r\n      legacyNFTAddress,\r\n      assetId,\r\n      price,\r\n      \"\"\r\n    );\r\n\r\n    emit AuctionSuccessful(\r\n      order.id,\r\n      assetId,\r\n      order.seller,\r\n      price,\r\n      msg.sender\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev [LEGACY] Gets an order using the legacy NFT address.\r\n    * @dev It's equivalent to orderByAssetId[legacyNFTAddress][assetId] but returns same structure as the old Auction\r\n    * @param assetId - ID of the published NFT\r\n    */\r\n  function auctionByAssetId(\r\n    uint256 assetId\r\n  )\r\n    public\r\n    view\r\n    returns\r\n    (bytes32, address, uint256, uint256)\r\n  {\r\n    Order memory order = orderByAssetId[legacyNFTAddress][assetId];\r\n    return (order.id, order.seller, order.price, order.expiresAt);\r\n  }\r\n\r\n  /**\r\n    * @dev Creates a new order\r\n    * @param nftAddress - Non fungible registry address\r\n    * @param assetId - ID of the published NFT\r\n    * @param priceInWei - Price in Wei for the supported coin\r\n    * @param expiresAt - Duration of the order (in hours)\r\n    */\r\n  function _createOrder(\r\n    address nftAddress,\r\n    uint256 assetId,\r\n    uint256 priceInWei,\r\n    uint256 expiresAt\r\n  )\r\n    internal\r\n  {\r\n    _requireERC721(nftAddress);\r\n\r\n    ERC721Interface nftRegistry = ERC721Interface(nftAddress);\r\n    address assetOwner = nftRegistry.ownerOf(assetId);\r\n\r\n    require(msg.sender == assetOwner, \"Only the owner can create orders\");\r\n    require(\r\n      nftRegistry.getApproved(assetId) == address(this) || nftRegistry.isApprovedForAll(assetOwner, address(this)),\r\n      \"The contract is not authorized to manage the asset\"\r\n    );\r\n    require(priceInWei > 0, \"Price should be bigger than 0\");\r\n    require(expiresAt > block.timestamp.add(1 minutes), \"Expires should be bigger than 1 minute\");\r\n\r\n    bytes32 orderId = keccak256(\r\n      abi.encodePacked(\r\n        block.timestamp,\r\n        assetOwner,\r\n        assetId,\r\n        nftAddress,\r\n        priceInWei\r\n      )\r\n    );\r\n\r\n    orderByAssetId[nftAddress][assetId] = Order({\r\n      id: orderId,\r\n      seller: assetOwner,\r\n      nftAddress: nftAddress,\r\n      price: priceInWei,\r\n      expiresAt: expiresAt\r\n    });\r\n\r\n    // Check if there's a publication fee and\r\n    // transfer the amount to marketplace owner\r\n    if (publicationFeeInWei > 0) {\r\n      require(\r\n        acceptedToken.transferFrom(msg.sender, owner, publicationFeeInWei),\r\n        \"Transfering the publication fee to the Marketplace owner failed\"\r\n      );\r\n    }\r\n\r\n    emit OrderCreated(\r\n      orderId,\r\n      assetId,\r\n      assetOwner,\r\n      nftAddress,\r\n      priceInWei,\r\n      expiresAt\r\n    );\r\n  }\r\n\r\n  /**\r\n    * @dev Cancel an already published order\r\n    *  can only be canceled by seller or the contract owner\r\n    * @param nftAddress - Address of the NFT registry\r\n    * @param assetId - ID of the published NFT\r\n    */\r\n  function _cancelOrder(address nftAddress, uint256 assetId) internal returns (Order) {\r\n    Order memory order = orderByAssetId[nftAddress][assetId];\r\n\r\n    require(order.id != 0, \"Asset not published\");\r\n    require(order.seller == msg.sender || msg.sender == owner, \"Unauthorized user\");\r\n\r\n    bytes32 orderId = order.id;\r\n    address orderSeller = order.seller;\r\n    address orderNftAddress = order.nftAddress;\r\n    delete orderByAssetId[nftAddress][assetId];\r\n\r\n    emit OrderCancelled(\r\n      orderId,\r\n      assetId,\r\n      orderSeller,\r\n      orderNftAddress\r\n    );\r\n\r\n    return order;\r\n  }\r\n\r\n  /**\r\n    * @dev Executes the sale for a published NFT\r\n    * @param nftAddress - Address of the NFT registry\r\n    * @param assetId - ID of the published NFT\r\n    * @param price - Order price\r\n    * @param fingerprint - Verification info for the asset\r\n    */\r\n  function _executeOrder(\r\n    address nftAddress,\r\n    uint256 assetId,\r\n    uint256 price,\r\n    bytes fingerprint\r\n  )\r\n   internal returns (Order)\r\n  {\r\n    _requireERC721(nftAddress);\r\n\r\n    ERC721Verifiable nftRegistry = ERC721Verifiable(nftAddress);\r\n\r\n    if (nftRegistry.supportsInterface(InterfaceId_ValidateFingerprint)) {\r\n      require(\r\n        nftRegistry.verifyFingerprint(assetId, fingerprint),\r\n        \"The asset fingerprint is not valid\"\r\n      );\r\n    }\r\n    Order memory order = orderByAssetId[nftAddress][assetId];\r\n\r\n    require(order.id != 0, \"Asset not published\");\r\n\r\n    address seller = order.seller;\r\n\r\n    require(seller != address(0), \"Invalid address\");\r\n    require(seller != msg.sender, \"Unauthorized user\");\r\n    require(order.price == price, \"The price is not correct\");\r\n    require(block.timestamp < order.expiresAt, \"The order expired\");\r\n    require(seller == nftRegistry.ownerOf(assetId), \"The seller is no longer the owner\");\r\n\r\n    uint saleShareAmount = 0;\r\n\r\n    bytes32 orderId = order.id;\r\n    delete orderByAssetId[nftAddress][assetId];\r\n\r\n    if (ownerCutPercentage > 0) {\r\n      // Calculate sale share\r\n      saleShareAmount = price.mul(ownerCutPercentage).div(100);\r\n\r\n      // Transfer share amount for marketplace Owner\r\n      require(\r\n        acceptedToken.transferFrom(msg.sender, owner, saleShareAmount),\r\n        \"Transfering the cut to the Marketplace owner failed\"\r\n      );\r\n    }\r\n\r\n    // Transfer sale amount to seller\r\n    require(\r\n      acceptedToken.transferFrom(msg.sender, seller, price.sub(saleShareAmount)),\r\n      \"Transfering the sale amount to the seller failed\"\r\n    );\r\n\r\n    // Transfer asset owner\r\n    nftRegistry.safeTransferFrom(\r\n      seller,\r\n      msg.sender,\r\n      assetId\r\n    );\r\n\r\n    emit OrderSuccessful(\r\n      orderId,\r\n      assetId,\r\n      seller,\r\n      nftAddress,\r\n      price,\r\n      msg.sender\r\n    );\r\n\r\n    return order;\r\n  }\r\n\r\n  function _requireERC721(address nftAddress) internal view {\r\n    require(nftAddress.isContract(), \"The NFT Address should be a contract\");\r\n\r\n    ERC721Interface nftRegistry = ERC721Interface(nftAddress);\r\n    require(\r\n      nftRegistry.supportsInterface(ERC721_Interface),\r\n      \"The NFT contract has an invalid ERC721 implementation\"\r\n    );\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_legacyNFTAddress\",\"type\":\"address\"}],\"name\":\"setLegacyNFTAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ownerCutPercentage\",\"type\":\"uint256\"}],\"name\":\"setOwnerCutPercentage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ERC721_Interface\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ValidateFingerprint\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"acceptedToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nftAddress\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"cancelOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nftAddress\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCutPercentage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nftAddress\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"fingerprint\",\"type\":\"bytes\"}],\"name\":\"safeExecuteOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"createOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"publicationFeeInWei\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nftAddress\",\"type\":\"address\"},{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"executeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_publicationFee\",\"type\":\"uint256\"}],\"name\":\"setPublicationFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"isMigrated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_acceptedToken\",\"type\":\"address\"},{\"name\":\"_legacyNFTAddress\",\"type\":\"address\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sender\",\"type\":\"address\"}],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"legacyNFTAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"}],\"name\":\"auctionByAssetId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"orderByAssetId\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"nftAddress\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"assetId\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"executeOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"OrderCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nftAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"}],\"name\":\"OrderSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nftAddress\",\"type\":\"address\"}],\"name\":\"OrderCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"publicationFee\",\"type\":\"uint256\"}],\"name\":\"ChangedPublicationFee\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ownerCutPercentage\",\"type\":\"uint256\"}],\"name\":\"ChangedOwnerCutPercentage\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"legacyNFTAddress\",\"type\":\"address\"}],\"name\":\"ChangeLegacyNFTAddress\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"priceInWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expiresAt\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"assetId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"migrationId\",\"type\":\"string\"}],\"name\":\"Migrated\",\"type\":\"event\"}]","ContractName":"Marketplace","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9a88f78d8a780f1d40b9ad61ce6f0317a237c6451e3266d5f1b8ab6dbc060782"}]}