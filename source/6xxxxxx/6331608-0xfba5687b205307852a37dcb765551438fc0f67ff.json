{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.17;\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\nlibrary HolderLib {\r\n    using SafeMath for uint256;\r\n\r\n    struct HolderValue {\r\n      uint256 value;\r\n      uint256[] relatedRoundIds;\r\n      uint256 fromIndex;\r\n      string refCode;\r\n    }\r\n\r\n    struct Holder {\r\n        mapping (address => HolderValue) holderMap;\r\n    }\r\n\r\n    function getNum(Holder storage holder, address adrs) internal view returns (uint256 num) {\r\n        return holder.holderMap[adrs].value;\r\n    }\r\n\r\n    function setRefCode(Holder storage holder, address adrs, string refCode) internal {\r\n        holder.holderMap[adrs].refCode = refCode;\r\n    }\r\n\r\n    function getRefCode(Holder storage holder, address adrs) internal view returns (string refCode) {\r\n        return holder.holderMap[adrs].refCode;\r\n    }\r\n\r\n    function add(Holder storage holder, address adrs, uint256 num) internal {\r\n        holder.holderMap[adrs].value = holder.holderMap[adrs].value.add(num);\r\n    }\r\n\r\n    function sub(Holder storage holder, address adrs, uint256 num) internal {\r\n        holder.holderMap[adrs].value = holder.holderMap[adrs].value.sub(num);\r\n    }\r\n\r\n    function setNum(Holder storage holder, address adrs, uint256 num) internal {\r\n        holder.holderMap[adrs].value = num;\r\n    }\r\n\r\n    function addRelatedRoundId(Holder storage holder, address adrs, uint256 roundId) internal {\r\n        uint256[] storage ids = holder.holderMap[adrs].relatedRoundIds;\r\n        if (ids.length > 0 && ids[ids.length - 1] == roundId) {\r\n          return;\r\n        }\r\n        ids.push(roundId);\r\n    }\r\n\r\n    function removeRelatedRoundId(Holder storage holder, address adrs, uint256 roundId) internal {\r\n        HolderValue storage value = holder.holderMap[adrs];\r\n        require(value.relatedRoundIds[value.fromIndex] == roundId, 'only the fromIndex element can be removed');\r\n        value.fromIndex++;\r\n    }\r\n}\r\n\r\nlibrary TableLib {\r\n    using SafeMath for uint256;\r\n\r\n    struct TableValue {\r\n      bool exists;\r\n      uint256 value;\r\n    }\r\n\r\n    struct Table {\r\n        mapping (address => TableValue) tableMapping;\r\n        address[] addressList;\r\n    }\r\n\r\n    function getNum(Table storage tbl, address adrs) internal view returns (uint256 num) {\r\n      return tbl.tableMapping[adrs].value;\r\n    }\r\n\r\n    function add(Table storage tbl, address adrs, uint256 num) internal {\r\n        if (!tbl.tableMapping[adrs].exists) {\r\n          tbl.addressList.push(adrs);\r\n          tbl.tableMapping[adrs].exists = true;\r\n        }\r\n        tbl.tableMapping[adrs].value = tbl.tableMapping[adrs].value.add(num);\r\n    }\r\n\r\n    function getValues(Table storage tbl, uint256 page) internal view\r\n    returns (uint256 count, address[] addressList, uint256[] numList) {\r\n      count = tbl.addressList.length;\r\n      uint256 maxPageSize = 50;\r\n      uint256 index = 0;\r\n      uint256 pageSize = maxPageSize;\r\n      if ( page*maxPageSize > count ) {\r\n        pageSize = count - (page-1)*maxPageSize;\r\n      }\r\n      addressList = new address[](pageSize);\r\n      numList = new uint256[](pageSize);\r\n      for (uint256 i = (page - 1) * maxPageSize; i < count && index < pageSize; i++) {\r\n        address adrs = tbl.addressList[i];\r\n        addressList[index] = adrs;\r\n        numList[index] = tbl.tableMapping[adrs].value;\r\n        index++;\r\n      }\r\n    }\r\n}\r\n\r\nlibrary RoundLib {\r\n    using SafeMath for uint256;\r\n    using HolderLib for HolderLib.Holder;\r\n    using TableLib for TableLib.Table;\r\n\r\n    event Log(string str, uint256 v1, uint256 v2, uint256 v3);\r\n\r\n    uint256 constant private roundSizeIncreasePercent = 160;\r\n\r\n    struct Round {\r\n        uint256 roundId;      // 一直累加，永不重复\r\n        uint256 roundNum;     // 轮次，数字会重复\r\n        uint256 max;          // 本轮应募集数量\r\n        TableLib.Table investers;  // 投资者数据\r\n        uint256 raised;       // 本轮已募集\r\n        uint256 pot;          // 本轮需要分配的金额\r\n    }\r\n\r\n    function getInitRound(uint256 initSize) internal pure returns (Round) {\r\n        TableLib.Table memory investers;\r\n        return Round({\r\n          roundId: 1,\r\n          roundNum: 1,\r\n          max: initSize,\r\n          investers: investers,\r\n          raised: 0,\r\n          pot: 0\r\n        });\r\n    }\r\n\r\n    function getNextRound(Round storage round, uint256 initSize) internal view returns (Round) {\r\n      TableLib.Table memory investers;\r\n      bool isFinished = round.max == round.raised;\r\n      return Round({\r\n        roundId: round.roundId + 1,\r\n        roundNum: isFinished ? round.roundNum + 1 : 1,\r\n        max: isFinished ? round.max * roundSizeIncreasePercent / 100 : initSize,\r\n        investers: investers,\r\n        raised: 0,\r\n        pot: 0\r\n      });\r\n    }\r\n\r\n    function add (Round storage round, address adrs, uint256 amount) internal\r\n    returns (bool isFinished, uint256 amountUsed) {\r\n        if (round.raised + amount >= round.max) {\r\n            isFinished = true;\r\n            amountUsed = round.max - round.raised;\r\n        } else {\r\n            isFinished = false;\r\n            amountUsed = amount;\r\n        }\r\n        round.investers.add(adrs, amountUsed);\r\n        round.raised = round.raised.add(amountUsed);\r\n    }\r\n\r\n    function getNum(Round storage round, address adrs) internal view returns (uint256) {\r\n        return round.investers.getNum(adrs);\r\n    }\r\n\r\n    function getBalance(Round storage round, address adrs)\r\n    internal view returns (uint256) {\r\n        uint256 balance = round.investers.getNum(adrs);\r\n        if (balance == 0) {\r\n          return balance;\r\n        }\r\n        return balance * round.pot / round.raised;\r\n    }\r\n\r\n    function moveToHolder(Round storage round, address adrs, HolderLib.Holder storage coinHolders) internal {\r\n        if (round.pot == 0) {\r\n          return;\r\n        }\r\n        uint256 amount = getBalance(round, adrs);\r\n        if (amount > 0) {\r\n            coinHolders.add(adrs, amount);\r\n            coinHolders.removeRelatedRoundId(adrs, round.roundId);\r\n        }\r\n    }\r\n\r\n    function getInvestList(Round storage round, uint256 page) internal view\r\n    returns (uint256 count, address[] addressList, uint256[] numList) {\r\n        return round.investers.getValues(page);\r\n    }\r\n}\r\n\r\nlibrary DealerLib {\r\n    using SafeMath for uint256;\r\n\r\n    struct DealerInfo {\r\n        address addr;\r\n        uint256 amount;\r\n        uint256 rate; // 万分之，必须不大于 200，即 2%\r\n    }\r\n\r\n    struct Dealers {\r\n        mapping (string => DealerInfo) dealerMap;\r\n        mapping (address => string) addressToCodeMap;\r\n    }\r\n\r\n    function query(Dealers storage dealers, string code) internal view returns (DealerInfo storage) {\r\n        return dealers.dealerMap[code];\r\n    }\r\n\r\n    function queryCodeByAddress(Dealers storage dealers, address adrs) internal view returns (string code) {\r\n        return dealers.addressToCodeMap[adrs];\r\n    }\r\n\r\n    function dealerExisted(Dealers storage dealers, string code) internal view returns (bool value) {\r\n        return dealers.dealerMap[code].addr != 0x0;\r\n    }\r\n\r\n    function insert(Dealers storage dealers, string code, address addr, uint256 rate) internal {\r\n        require(!dealerExisted(dealers, code), \"code existed\");\r\n        require(bytes(queryCodeByAddress(dealers, addr)).length == 0, \"address existed in dealers\");\r\n        setDealer(dealers, code, addr, rate);\r\n    }\r\n\r\n    function update(Dealers storage dealers, string code, address addr, uint256 rate) internal {\r\n        address oldAddr = dealers.dealerMap[code].addr;\r\n\r\n        require(oldAddr != 0x0, \"code not exist\");\r\n        require(bytes(queryCodeByAddress(dealers, addr)).length == 0, \"address existed in dealers\");\r\n\r\n        delete dealers.addressToCodeMap[oldAddr];\r\n        setDealer(dealers, code, addr, rate);\r\n    }\r\n\r\n    function setDealer(Dealers storage dealers, string code, address addr, uint256 rate) private {\r\n        require(addr != 0x0, \"invalid address\");\r\n        require(rate <= 300, \"invalid rate\");\r\n        dealers.addressToCodeMap[addr] = code;\r\n        dealers.dealerMap[code].addr = addr;\r\n        dealers.dealerMap[code].rate = rate;\r\n    }\r\n\r\n    function addAmount(Dealers storage dealers, string code, uint256 amountUsed) internal\r\n    returns (uint256 amountToDealer) {\r\n        require(amountUsed > 0, \"amount must be greater than 0\");\r\n        require(dealerExisted(dealers, code), \"code not exist\");\r\n        amountToDealer = amountUsed * dealers.dealerMap[code].rate / 10000;\r\n        dealers.dealerMap[code].amount = dealers.dealerMap[code].amount.add(amountToDealer);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\ncontract Cox is Ownable {\r\n    using SafeMath for uint256;\r\n    using HolderLib for HolderLib.Holder;\r\n    using RoundLib for RoundLib.Round;\r\n    using DealerLib for DealerLib.Dealers;\r\n\r\n    event RoundIn(address addr, uint256 amt, uint256 currentRoundRaised, uint256 round, uint256 bigRound, string refCode);\r\n    event Log(string str, uint256 value);\r\n    event PoolAdd(uint256 value);\r\n    event PoolSub(uint256 value);\r\n\r\n    // 可配置参数\r\n    uint256 private roundDuration = 1 days;\r\n    uint256 private initSize = 10 ether;       // 首轮募集数量\r\n    uint256 private minRecharge = 0.01 ether;  // 最小充值数量\r\n    bool private mIsActive = false;      // 游戏是否接受充值和提现\r\n    bool private isAutoRestart = true;   // 最后一轮结束后，是否马上重新开始第一轮\r\n    uint256 private rate = 300;           // 万分之，300 即 3%\r\n    string private defaultRefCode = \"owner\";\r\n\r\n    DealerLib.Dealers private dealers;    // 渠道商信息\r\n    HolderLib.Holder private coinHolders; // 投资人信息\r\n    RoundLib.Round[] private roundList;\r\n\r\n    uint256 private fundPoolSize;            // 奖池金额\r\n    uint256 private roundStartTime;\r\n    uint256 private roundEndTime;\r\n    uint256 private bigRound = 1;\r\n    uint256 private totalAmountInvested = 0;\r\n\r\n    constructor() public {\r\n        roundList.push(RoundLib.getInitRound(initSize));\r\n        dealers.insert(defaultRefCode, msg.sender, 100);\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        Ownable.transferOwnership(_newOwner);\r\n        dealers.update(defaultRefCode, _newOwner, 100);\r\n    }\r\n\r\n    function poolAdd(uint256 value) private {\r\n      fundPoolSize = fundPoolSize.add(value);\r\n      emit PoolAdd(value);\r\n    }\r\n\r\n    function poolSub(uint256 value) private {\r\n      fundPoolSize = fundPoolSize.sub(value);\r\n      emit PoolSub(value);\r\n    }\r\n\r\n    modifier isActive() {\r\n        require(mIsActive == true, \"it's not ready yet.\");\r\n        require(now >= roundStartTime, \"it's not started yet.\");\r\n        _;\r\n    }\r\n\r\n    modifier callFromHuman(address addr) {\r\n        uint size;\r\n        assembly {size := extcodesize(addr)}\r\n        require(size == 0, \"not human\");\r\n        _;\r\n    }\r\n\r\n    // 充值\r\n    function recharge(string code) public isActive callFromHuman(msg.sender) payable {\r\n        require(msg.value >= minRecharge, \"not enough fund\");\r\n\r\n        string memory _code = coinHolders.getRefCode(msg.sender);\r\n        if (bytes(_code).length > 0) {\r\n            code = _code;\r\n        } else {\r\n            if (!dealers.dealerExisted(code)) {\r\n                code = defaultRefCode;\r\n            }\r\n            coinHolders.setRefCode(msg.sender, code);\r\n        }\r\n\r\n        coinHolders.add(msg.sender, msg.value);\r\n        roundIn(msg.value, code);\r\n    }\r\n\r\n    function moveRoundsToHolder(address adrs) internal {\r\n      HolderLib.HolderValue storage holderValue = coinHolders.holderMap[adrs];\r\n      uint256[] memory roundIds = holderValue.relatedRoundIds;\r\n      uint256 roundId;\r\n\r\n      for (uint256 i = holderValue.fromIndex; i < roundIds.length; i++) {\r\n        roundId = roundIds[i];\r\n        roundList[roundId - 1].moveToHolder(adrs, coinHolders);\r\n      }\r\n    }\r\n\r\n    // 提现\r\n    function withdraw() public callFromHuman(msg.sender) {\r\n        moveRoundsToHolder(msg.sender);\r\n        uint256 amount = coinHolders.getNum(msg.sender);\r\n        if (amount > 0) {\r\n            coinHolders.sub(msg.sender, amount);\r\n            //transfer\r\n            msg.sender.transfer(amount);\r\n        }\r\n    }\r\n\r\n    // 余额再投资\r\n    function roundIn() public isActive {\r\n        string memory code = coinHolders.getRefCode(msg.sender);\r\n        require(bytes(code).length > 0, \"code must not be empty\");\r\n        require(dealers.dealerExisted(code), \"dealer not exist\");\r\n\r\n        moveRoundsToHolder(msg.sender);\r\n        uint256 amount = coinHolders.getNum(msg.sender);\r\n        require(amount > 0, \"your balance is 0\");\r\n        roundIn(amount, code);\r\n    }\r\n\r\n    // 结束本局\r\n    function endRound() public isActive {\r\n      RoundLib.Round storage curRound = roundList[roundList.length - 1];\r\n      endRoundWhenTimeout(curRound);\r\n    }\r\n\r\n    function endRoundWhenTimeout(RoundLib.Round storage curRound) private isActive {\r\n      if (now >= roundEndTime) {\r\n          uint256 preRoundMax = 0;\r\n          if (curRound.roundNum > 1) {\r\n              RoundLib.Round storage preRound = roundList[roundList.length - 2];\r\n              preRoundMax = preRound.max;\r\n          }\r\n          uint256 last2RoundsRaised = preRoundMax + curRound.raised;\r\n\r\n          if (last2RoundsRaised > 0) {\r\n              curRound.pot = curRound.raised * fundPoolSize / last2RoundsRaised;\r\n              if (curRound.roundNum > 1) {\r\n                  preRound.pot = preRound.raised * fundPoolSize / last2RoundsRaised;\r\n                  poolSub(preRound.pot);\r\n              }\r\n              poolSub(curRound.pot);\r\n          }\r\n\r\n          mIsActive = isAutoRestart;\r\n          startNextRound(curRound);\r\n          bigRound++;\r\n      }\r\n    }\r\n\r\n    function startNextRound(RoundLib.Round storage curRound) private {\r\n        roundList.push(curRound.getNextRound(initSize));\r\n        roundStartTime = now;\r\n        roundEndTime = now + roundDuration;\r\n    }\r\n\r\n    function roundIn(uint256 amt, string code) private isActive {\r\n        require(coinHolders.getNum(msg.sender) >= amt, \"not enough coin\");\r\n        RoundLib.Round storage curRound = roundList[roundList.length - 1];\r\n\r\n        if (now >= roundEndTime) {\r\n            endRoundWhenTimeout(curRound);\r\n            return;\r\n        }\r\n\r\n        (bool isFinished, uint256 amountUsed) = curRound.add(msg.sender, amt);\r\n        totalAmountInvested = totalAmountInvested.add(amountUsed);\r\n\r\n        require(amountUsed > 0, 'amountUsed must greater than 0');\r\n\r\n        emit RoundIn(msg.sender, amountUsed, curRound.raised, curRound.roundNum, bigRound, code);\r\n\r\n        // 添加关联 roundId\r\n        coinHolders.addRelatedRoundId(msg.sender, curRound.roundId);\r\n\r\n        coinHolders.sub(msg.sender, amountUsed);\r\n\r\n        // 分配维护资金和代理商\r\n        uint256 amountToDealer = dealers.addAmount(code, amountUsed);\r\n        uint256 amountToOwner = (amountUsed * rate / 10000).sub(amountToDealer);\r\n        coinHolders.add(owner, amountToOwner);\r\n        coinHolders.add(dealers.query(code).addr, amountToDealer);\r\n        poolAdd(amountUsed.sub(amountToDealer).sub(amountToOwner));\r\n\r\n        if (isFinished) {\r\n            if (curRound.roundNum > 1) {\r\n                RoundLib.Round storage preRound2 = roundList[roundList.length - 2];\r\n                preRound2.pot = preRound2.max * 11 / 10;\r\n                poolSub(preRound2.pot);\r\n            }\r\n\r\n            startNextRound(curRound);\r\n        }\r\n    }\r\n\r\n    function verifyCodeLength(string code) public pure returns (bool) {\r\n        return bytes(code).length >= 4 && bytes(code).length <= 20;\r\n    }\r\n\r\n    function addDealer(string code, address addr, uint256 _rate) public onlyOwner {\r\n        require(verifyCodeLength(code), \"code length should between 4 and 20\");\r\n        dealers.insert(code, addr, _rate);\r\n    }\r\n\r\n    function addDealerForSender(string code) public {\r\n        require(verifyCodeLength(code), \"code length should between 4 and 20\");\r\n        dealers.insert(code, msg.sender, 100);\r\n    }\r\n\r\n    function getDealerInfo(string code) public view returns (string _code, address adrs, uint256 amount, uint256 _rate) {\r\n        DealerLib.DealerInfo storage dealer = dealers.query(code);\r\n        return (code, dealer.addr, dealer.amount, dealer.rate);\r\n    }\r\n\r\n    function updateDealer(string code, address addr, uint256 _rate) public onlyOwner {\r\n        dealers.update(code, addr, _rate);\r\n    }\r\n\r\n    function setIsAutoRestart(bool isAuto) public onlyOwner {\r\n        isAutoRestart = isAuto;\r\n    }\r\n\r\n    function setMinRecharge(uint256 a) public onlyOwner {\r\n        minRecharge = a;\r\n    }\r\n\r\n    function setRoundDuration(uint256 a) public onlyOwner {\r\n        roundDuration = a;\r\n    }\r\n\r\n    function setInitSize(uint256 size) public onlyOwner {\r\n        initSize = size;\r\n        RoundLib.Round storage curRound = roundList[roundList.length - 1];\r\n        if (curRound.roundNum == 1 && curRound.raised < size) {\r\n            curRound.max = size;\r\n        }\r\n    }\r\n\r\n    function activate() public onlyOwner {\r\n        // can only be ran once\r\n        require(mIsActive == false, \"already activated\");\r\n        // activate the contract\r\n        mIsActive = true;\r\n        roundStartTime = now;\r\n        roundEndTime = now + roundDuration;\r\n    }\r\n\r\n    function setStartTime(uint256 startTime) public onlyOwner {\r\n        roundStartTime = startTime;\r\n        roundEndTime = roundStartTime + roundDuration;\r\n    }\r\n\r\n    function deactivate() public onlyOwner {\r\n        require(mIsActive == true, \"already deactivated\");\r\n        mIsActive = false;\r\n    }\r\n\r\n    function getGlobalInfo() public view returns\r\n    (bool _isActive, bool _isAutoRestart, uint256 _round, uint256 _bigRound,\r\n      uint256 _curRoundSize, uint256 _curRoundRaised, uint256 _fundPoolSize,\r\n      uint256 _roundStartTime, uint256 _roundEndTime, uint256 _totalAmountInvested) {\r\n        RoundLib.Round storage curRound = roundList[roundList.length - 1];\r\n        return (mIsActive, isAutoRestart, curRound.roundNum, bigRound,\r\n          curRound.max, curRound.raised, fundPoolSize,\r\n          roundStartTime, roundEndTime, totalAmountInvested);\r\n    }\r\n\r\n    function getMyInfo() public view\r\n      returns (address ethAddress, uint256 balance, uint256 preRoundAmount, uint256 curRoundAmount,\r\n        string dealerCode, uint256 dealerAmount, uint256 dealerRate) {\r\n      return getAddressInfo(msg.sender);\r\n    }\r\n\r\n    function getAddressInfo(address _address) public view\r\n    returns (address ethAddress, uint256 balance, uint256 preRoundAmount, uint256 curRoundAmount,\r\n      string dealerCode, uint256 dealerAmount, uint256 dealerRate) {\r\n        RoundLib.Round storage curRound = roundList[roundList.length - 1];\r\n        preRoundAmount = 0;\r\n        if (curRound.roundNum > 1) {\r\n            RoundLib.Round storage preRound = roundList[roundList.length - 2];\r\n            preRoundAmount = preRound.getNum(_address);\r\n        }\r\n\r\n        (dealerCode, , dealerAmount, dealerRate) = getDealerInfo(dealers.queryCodeByAddress(_address));\r\n\r\n        return (_address, coinHolders.getNum(_address) + getBalanceFromRound(_address),\r\n        preRoundAmount, curRound.getNum(_address), dealerCode, dealerAmount, dealerRate);\r\n    }\r\n\r\n    function getBalanceFromRound(address adrs) internal view returns (uint256) {\r\n        HolderLib.HolderValue storage holderValue = coinHolders.holderMap[adrs];\r\n        uint256[] storage roundIds = holderValue.relatedRoundIds;\r\n        uint256 roundId;\r\n\r\n        uint256 balance = 0;\r\n        for (uint256 i = holderValue.fromIndex; i < roundIds.length; i++) {\r\n          roundId = roundIds[i];\r\n          balance += roundList[roundId - 1].getBalance(adrs);\r\n        }\r\n        return balance;\r\n    }\r\n\r\n    function getRoundInfo(uint256 roundId, uint256 page) public view\r\n    returns (uint256 _roundId, uint256 roundNum, uint256 max, uint256 raised, uint256 pot,\r\n      uint256 count, address[] addressList, uint256[] numList) {\r\n        RoundLib.Round storage round = roundList[roundId - 1];\r\n        _roundId = round.roundId;\r\n        roundNum = round.roundNum;\r\n        max = round.max;\r\n        raised = round.raised;\r\n        pot = round.pot;\r\n        (count, addressList, numList) = round.getInvestList(page);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"setMinRecharge\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"a\",\"type\":\"uint256\"}],\"name\":\"setRoundDuration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startTime\",\"type\":\"uint256\"}],\"name\":\"setStartTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"isAuto\",\"type\":\"bool\"}],\"name\":\"setIsAutoRestart\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deactivate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"addDealerForSender\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"addDealer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"roundIn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyInfo\",\"outputs\":[{\"name\":\"ethAddress\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"preRoundAmount\",\"type\":\"uint256\"},{\"name\":\"curRoundAmount\",\"type\":\"uint256\"},{\"name\":\"dealerCode\",\"type\":\"string\"},{\"name\":\"dealerAmount\",\"type\":\"uint256\"},{\"name\":\"dealerRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"page\",\"type\":\"uint256\"}],\"name\":\"getRoundInfo\",\"outputs\":[{\"name\":\"_roundId\",\"type\":\"uint256\"},{\"name\":\"roundNum\",\"type\":\"uint256\"},{\"name\":\"max\",\"type\":\"uint256\"},{\"name\":\"raised\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"count\",\"type\":\"uint256\"},{\"name\":\"addressList\",\"type\":\"address[]\"},{\"name\":\"numList\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"recharge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"verifyCodeLength\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"updateDealer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"name\":\"setInitSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGlobalInfo\",\"outputs\":[{\"name\":\"_isActive\",\"type\":\"bool\"},{\"name\":\"_isAutoRestart\",\"type\":\"bool\"},{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_bigRound\",\"type\":\"uint256\"},{\"name\":\"_curRoundSize\",\"type\":\"uint256\"},{\"name\":\"_curRoundRaised\",\"type\":\"uint256\"},{\"name\":\"_fundPoolSize\",\"type\":\"uint256\"},{\"name\":\"_roundStartTime\",\"type\":\"uint256\"},{\"name\":\"_roundEndTime\",\"type\":\"uint256\"},{\"name\":\"_totalAmountInvested\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getAddressInfo\",\"outputs\":[{\"name\":\"ethAddress\",\"type\":\"address\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"preRoundAmount\",\"type\":\"uint256\"},{\"name\":\"curRoundAmount\",\"type\":\"uint256\"},{\"name\":\"dealerCode\",\"type\":\"string\"},{\"name\":\"dealerAmount\",\"type\":\"uint256\"},{\"name\":\"dealerRate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"code\",\"type\":\"string\"}],\"name\":\"getDealerInfo\",\"outputs\":[{\"name\":\"_code\",\"type\":\"string\"},{\"name\":\"adrs\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"currentRoundRaised\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bigRound\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refCode\",\"type\":\"string\"}],\"name\":\"RoundIn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"str\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PoolAdd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"PoolSub\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Cox","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://74dea226a3901fc675f196fe4216f361f366c77e15abbd77ae8ba2e0c2dfec49"}]}