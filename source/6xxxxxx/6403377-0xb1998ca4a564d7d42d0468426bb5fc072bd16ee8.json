{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Whitelist contract\r\n * @dev Whitelist for wallets.\r\n*/\r\ncontract Whitelist is Ownable {\r\n    mapping(address => bool) whitelist;\r\n\r\n    uint256 public whitelistLength = 0;\r\n\r\n    address private addressApi;\r\n\r\n    modifier onlyPrivilegeAddresses {\r\n        require(msg.sender == addressApi || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Set backend Api address.\r\n    * @dev Accept request from the owner only.\r\n    * @param _api The address of backend API to set.\r\n    */\r\n    function setApiAddress(address _api) public onlyOwner {\r\n        require(_api != address(0));\r\n        addressApi = _api;\r\n    }\r\n\r\n    /**\r\n    * @dev Add wallet to whitelist.\r\n    * @dev Accept request from the privileged addresses only.\r\n    * @param _wallet The address of wallet to add.\r\n    */  \r\n    function addWallet(address _wallet) public onlyPrivilegeAddresses {\r\n        require(_wallet != address(0));\r\n        require(!isWhitelisted(_wallet));\r\n        whitelist[_wallet] = true;\r\n        whitelistLength++;\r\n    }\r\n\r\n    /**\r\n    * @dev Remove wallet from whitelist.\r\n    * @dev Accept request from the owner only.\r\n    * @param _wallet The address of whitelisted wallet to remove.\r\n    */  \r\n    function removeWallet(address _wallet) public onlyOwner {\r\n        require(_wallet != address(0));\r\n        require(isWhitelisted(_wallet));\r\n        whitelist[_wallet] = false;\r\n        whitelistLength--;\r\n    }\r\n\r\n    /**\r\n    * @dev Check the specified wallet whether it is in the whitelist.\r\n    * @param _wallet The address of wallet to check.\r\n    */ \r\n    function isWhitelisted(address _wallet) public view returns (bool) {\r\n        return whitelist[_wallet];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract VeiagToken is StandardToken, Ownable, Pausable {\r\n    string constant public name = \"Veiag Token\";\r\n    string constant public symbol = \"VEIAG\";\r\n    uint8 constant public decimals = 18;\r\n\r\n    uint256 constant public INITIAL_TOTAL_SUPPLY = 1e9 * (uint256(10) ** decimals);\r\n\r\n    address private addressIco;\r\n\r\n    modifier onlyIco() {\r\n        require(msg.sender == addressIco);\r\n        _;\r\n    }\r\n    \r\n    /**\r\n    * @dev Create VeiagToken contract and set pause\r\n    * @param _ico The address of ICO contract.\r\n    */\r\n    function VeiagToken (address _ico) public {\r\n        require(_ico != address(0));\r\n\r\n        addressIco = _ico;\r\n\r\n        totalSupply_ = totalSupply_.add(INITIAL_TOTAL_SUPPLY);\r\n        balances[_ico] = balances[_ico].add(INITIAL_TOTAL_SUPPLY);\r\n        Transfer(address(0), _ico, INITIAL_TOTAL_SUPPLY);\r\n\r\n        pause();\r\n    }\r\n\r\n     /**\r\n    * @dev Transfer token for a specified address with pause feature for owner.\r\n    * @dev Only applies when the transfer is allowed by the owner.\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        super.transfer(_to, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from one address to another with pause feature for owner.\r\n    * @dev Only applies when the transfer is allowed by the owner.\r\n    * @param _from address The address which you want to send tokens from\r\n    * @param _to address The address which you want to transfer to\r\n    * @param _value uint256 the amount of tokens to be transferred\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfer tokens from ICO address to another address.\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transferFromIco(address _to, uint256 _value) public onlyIco returns (bool) {\r\n        super.transfer(_to, _value);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title TokenTimelock\r\n * @dev TokenTimelock is a token holder contract that will allow a\r\n * beneficiary to extract the tokens after a given release time\r\n */\r\ncontract TokenTimelock {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  // ERC20 basic token contract being held\r\n  ERC20Basic public token;\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  // timestamp when token release is enabled\r\n  uint256 public releaseTime;\r\n\r\n  constructor(\r\n    ERC20Basic _token,\r\n    address _beneficiary,\r\n    uint256 _releaseTime\r\n  )\r\n    public\r\n  {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_releaseTime > block.timestamp);\r\n    token = _token;\r\n    beneficiary = _beneficiary;\r\n    releaseTime = _releaseTime;\r\n  }\r\n\r\n  /**\r\n   * @notice Transfers tokens held by timelock to beneficiary.\r\n   */\r\n  function release() public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= releaseTime);\r\n\r\n    uint256 amount = token.balanceOf(address(this));\r\n    require(amount > 0);\r\n\r\n    token.transfer(beneficiary, amount);\r\n  }\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    public\r\n    hasMintPermission\r\n    canMint\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() public onlyOwner canMint returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n\r\ncontract LockedOutTokens is TokenTimelock {\r\n    function LockedOutTokens(\r\n        ERC20Basic _token,\r\n        address _beneficiary,\r\n        uint256 _releaseTime\r\n    ) public TokenTimelock(_token, _beneficiary, _releaseTime)\r\n    {\r\n    }\r\n\r\n    function release() public {\r\n        require(beneficiary == msg.sender);\r\n\r\n        super.release();\r\n    }\r\n}\r\n/* solium-disable security/no-block-members */\r\n\r\n\r\n/**\r\n * @title TokenVesting\r\n * @dev A token holder contract that can release its token balance gradually like a\r\n * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the\r\n * owner.\r\n */\r\ncontract TokenVesting is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  event Released(uint256 amount);\r\n  event Revoked();\r\n\r\n  // beneficiary of tokens after they are released\r\n  address public beneficiary;\r\n\r\n  uint256 public cliff;\r\n  uint256 public start;\r\n  uint256 public duration;\r\n\r\n  bool public revocable;\r\n\r\n  mapping (address => uint256) public released;\r\n  mapping (address => bool) public revoked;\r\n\r\n  /**\r\n   * @dev Creates a vesting contract that vests its balance of any ERC20 token to the\r\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n   * of the balance will have vested.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _start the time (as Unix time) at which point vesting starts\r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @param _revocable whether the vesting is revocable or not\r\n   */\r\n  constructor(\r\n    address _beneficiary,\r\n    uint256 _start,\r\n    uint256 _cliff,\r\n    uint256 _duration,\r\n    bool _revocable\r\n  )\r\n    public\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_cliff <= _duration);\r\n\r\n    beneficiary = _beneficiary;\r\n    revocable = _revocable;\r\n    duration = _duration;\r\n    cliff = _start.add(_cliff);\r\n    start = _start;\r\n  }\r\n\r\n  function setStart(uint256 _start) onlyOwner public {\r\n    start = _start;  \r\n  }\r\n  /**\r\n   * @notice Transfers vested tokens to beneficiary.\r\n   * @param _token ERC20 token which is being vested\r\n   */\r\n  function release(ERC20Basic _token) public {\r\n    uint256 unreleased = releasableAmount(_token);\r\n\r\n    require(unreleased > 0);\r\n\r\n    released[_token] = released[_token].add(unreleased);\r\n\r\n    _token.transfer(beneficiary, unreleased);\r\n\r\n    emit Released(unreleased);\r\n  }\r\n\r\n  /**\r\n   * @notice Allows the owner to revoke the vesting. Tokens already vested\r\n   * remain in the contract, the rest are returned to the owner.\r\n   * @param _token ERC20 token which is being vested\r\n   */\r\n  function revoke(ERC20Basic _token) public onlyOwner {\r\n    require(revocable);\r\n    require(!revoked[_token]);\r\n\r\n    uint256 balance = _token.balanceOf(address(this));\r\n\r\n    uint256 unreleased = releasableAmount(_token);\r\n    uint256 refund = balance.sub(unreleased);\r\n\r\n    revoked[_token] = true;\r\n\r\n    _token.transfer(owner, refund);\r\n\r\n    emit Revoked();\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested but hasn't been released yet.\r\n   * @param _token ERC20 token which is being vested\r\n   */\r\n  function releasableAmount(ERC20Basic _token) public view returns (uint256) {\r\n    return vestedAmount(_token).sub(released[_token]);\r\n  }\r\n\r\n  /**\r\n   * @dev Calculates the amount that has already vested.\r\n   * @param _token ERC20 token which is being vested\r\n   */\r\n  function vestedAmount(ERC20Basic _token) public view returns (uint256) {\r\n    uint256 currentBalance = _token.balanceOf(address(this));\r\n    uint256 totalBalance = currentBalance.add(released[_token]);\r\n\r\n    if (block.timestamp < cliff) {\r\n      return 0;\r\n    } else if (block.timestamp >= start.add(duration) || revoked[_token]) {\r\n      return totalBalance;\r\n    } else {\r\n      return totalBalance.mul(block.timestamp.sub(start)).div(duration);\r\n    }\r\n  }\r\n}\r\n\r\ncontract VeiagTokenVesting is TokenVesting {\r\n    ERC20Basic public token;\r\n\r\n    function VeiagTokenVesting(\r\n        ERC20Basic _token,\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        bool _revocable\r\n    ) TokenVesting(_beneficiary, _start, _cliff, _duration, _revocable) public\r\n    {\r\n        require(_token != address(0));\r\n\r\n        token = _token;\r\n    }\r\n\r\n    function grant() public {\r\n        release(token);\r\n    }\r\n\r\n    function release(ERC20Basic _token) public {\r\n        require(beneficiary == msg.sender);\r\n        super.release(_token);\r\n    }\r\n}\r\n\r\ncontract Whitelistable {\r\n    Whitelist public whitelist;\r\n\r\n    modifier whenWhitelisted(address _wallet) {\r\n   //     require(whitelist.isWhitelisted(_wallet));\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor for Whitelistable contract.\r\n    */\r\n    function Whitelistable() public {\r\n        whitelist = new Whitelist();\r\n    }\r\n}\r\n\r\ncontract VeiagCrowdsale is Pausable, Whitelistable {\r\n    using SafeMath for uint256;\r\n\r\n    uint256 constant private DECIMALS = 18;\r\n\r\n    uint256 constant public RESERVED_LOCKED_TOKENS = 250e6 * (10 ** DECIMALS);\r\n    uint256 constant public RESERVED_TEAMS_TOKENS = 100e6 * (10 ** DECIMALS);\r\n    uint256 constant public RESERVED_FOUNDERS_TOKENS = 100e6 * (10 ** DECIMALS);\r\n    uint256 constant public RESERVED_MARKETING_TOKENS = 50e6 * (10 ** DECIMALS);\r\n\r\n    uint256 constant public MAXCAP_TOKENS_PRE_ICO = 100e6 * (10 ** DECIMALS);\r\n    \r\n    uint256 constant public MAXCAP_TOKENS_ICO = 400e6 * (10 ** DECIMALS);\r\n\r\n    uint256 constant public MIN_INVESTMENT = (10 ** 16);   // 0.01  ETH\r\n\r\n    uint256 constant public MAX_INVESTMENT = 100 * (10 ** DECIMALS); // 100  ETH\r\n\r\n    uint256 public startTimePreIco = 0;\r\n    uint256 public endTimePreIco = 0;\r\n\r\n    uint256 public startTimeIco = 0;\r\n    uint256 public endTimeIco = 0;\r\n\r\n    // rate = 0.005 ETH, 1 ETH = 200 tokens\r\n    uint256 public exchangeRatePreIco = 200;\r\n\r\n    uint256 public icoFirstWeekRate = 150;\r\n    uint256 public icoSecondWeekRate = 125;\r\n    uint256 public icoThirdWeekRate = 110;\r\n    // rate = 0.01 ETH, 1 ETH = 100 tokens\r\n    uint256 public icoRate = 100;\r\n\r\n    uint256 public tokensRemainingPreIco = MAXCAP_TOKENS_PRE_ICO;\r\n    uint256 public tokensRemainingIco = MAXCAP_TOKENS_ICO;\r\n\r\n    uint256 public tokensSoldPreIco = 0;\r\n    uint256 public tokensSoldIco = 0;\r\n    uint256 public tokensSoldTotal = 0;\r\n\r\n    uint256 public weiRaisedPreIco = 0;\r\n    uint256 public weiRaisedIco = 0;\r\n    uint256 public weiRaisedTotal = 0;\r\n\r\n    VeiagToken public token = new VeiagToken(this);\r\n    LockedOutTokens public lockedTokens;\r\n    VeiagTokenVesting public teamsTokenVesting;\r\n    VeiagTokenVesting public foundersTokenVesting;\r\n\r\n    mapping (address => uint256) private totalInvestedAmount;\r\n\r\n    modifier beforeReachingPreIcoMaxCap() {\r\n        require(tokensRemainingPreIco > 0);\r\n        _;\r\n    }\r\n\r\n    modifier beforeReachingIcoMaxCap() {\r\n        require(tokensRemainingIco > 0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Constructor for VeiagCrowdsale contract.\r\n    * @dev Set the owner who can manage whitelist and token.\r\n    * @param _startTimePreIco The pre-ICO start time.\r\n    * @param _endTimePreIco The pre-ICO end time.\r\n    * @param _startTimeIco The ICO start time.\r\n    * @param _endTimeIco The ICO end time.\r\n    * @param _lockedWallet The address for future sale.\r\n    * @param _teamsWallet The address for reserved tokens for teams.\r\n    * @param _foundersWallet The address for reserved tokens for founders.\r\n    * @param _marketingWallet The address for reserved tokens for marketing.\r\n    */\r\n    function VeiagCrowdsale(\r\n        uint256 _startTimePreIco,\r\n        uint256 _endTimePreIco, \r\n        uint256 _startTimeIco,\r\n        uint256 _endTimeIco,\r\n        address _lockedWallet,\r\n        address _teamsWallet,\r\n        address _foundersWallet,\r\n        address _marketingWallet\r\n    ) public Whitelistable()\r\n    {\r\n        require(_lockedWallet != address(0) && _teamsWallet != address(0) && _foundersWallet != address(0) && _marketingWallet != address(0));\r\n        require(_startTimePreIco > now && _endTimePreIco > _startTimePreIco);\r\n        require(_startTimeIco > _endTimePreIco && _endTimeIco > _startTimeIco);\r\n        startTimePreIco = _startTimePreIco;\r\n        endTimePreIco = _endTimePreIco;\r\n\r\n        startTimeIco = _startTimeIco;\r\n        endTimeIco = _endTimeIco;\r\n\r\n        lockedTokens = new LockedOutTokens(token, _lockedWallet, RESERVED_LOCKED_TOKENS);\r\n        teamsTokenVesting = new VeiagTokenVesting(token, _teamsWallet, 0, 1 days, 365 days, false);\r\n        foundersTokenVesting = new VeiagTokenVesting(token, _foundersWallet, 0, 1 days, 100 days, false);\r\n\r\n        token.transferFromIco(lockedTokens, RESERVED_LOCKED_TOKENS);\r\n        token.transferFromIco(teamsTokenVesting, RESERVED_TEAMS_TOKENS);\r\n        token.transferFromIco(foundersTokenVesting, RESERVED_FOUNDERS_TOKENS);\r\n        token.transferFromIco(_marketingWallet, RESERVED_MARKETING_TOKENS);\r\n        teamsTokenVesting.transferOwnership(this);\r\n        foundersTokenVesting.transferOwnership(this);        \r\n        \r\n        whitelist.transferOwnership(msg.sender);\r\n        token.transferOwnership(msg.sender);\r\n    }\r\n\tfunction SetStartVesting(uint256 _startTimeVestingForFounders) public onlyOwner{\r\n\t    require(now > endTimeIco);\r\n\t    require(_startTimeVestingForFounders > endTimeIco);\r\n\t    teamsTokenVesting.setStart(_startTimeVestingForFounders);\r\n\t    foundersTokenVesting.setStart(endTimeIco);\r\n        teamsTokenVesting.transferOwnership(msg.sender);\r\n        foundersTokenVesting.transferOwnership(msg.sender);\t    \r\n\t}\r\n\r\n\tfunction SetStartTimeIco(uint256 _startTimeIco) public onlyOwner{\r\n        uint256 deltaTime;  \r\n        require(_startTimeIco > now && startTimeIco > now);\r\n        if (_startTimeIco > startTimeIco){\r\n          deltaTime = _startTimeIco.sub(startTimeIco);\r\n\t      endTimePreIco = endTimePreIco.add(deltaTime);\r\n\t      startTimeIco = startTimeIco.add(deltaTime);\r\n\t      endTimeIco = endTimeIco.add(deltaTime);\r\n        }\r\n        if (_startTimeIco < startTimeIco){\r\n          deltaTime = startTimeIco.sub(_startTimeIco);\r\n          endTimePreIco = endTimePreIco.sub(deltaTime);\r\n\t      startTimeIco = startTimeIco.sub(deltaTime);\r\n\t      endTimeIco = endTimeIco.sub(deltaTime);\r\n        }  \r\n    }\r\n\t\r\n\t\r\n    \r\n    /**\r\n    * @dev Fallback function can be used to buy tokens.\r\n    */\r\n    function() public payable {\r\n        if (isPreIco()) {\r\n            sellTokensPreIco();\r\n        } else if (isIco()) {\r\n            sellTokensIco();\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Check whether the pre-ICO is active at the moment.\r\n    */\r\n    function isPreIco() public view returns (bool) {\r\n        return now >= startTimePreIco && now <= endTimePreIco;\r\n    }\r\n\r\n    /**\r\n    * @dev Check whether the ICO is active at the moment.\r\n    */\r\n    function isIco() public view returns (bool) {\r\n        return now >= startTimeIco && now <= endTimeIco;\r\n    }\r\n\r\n    /**\r\n    * @dev Calculate rate for ICO phase.\r\n    */\r\n    function exchangeRateIco() public view returns(uint256) {\r\n        require(now >= startTimeIco && now <= endTimeIco);\r\n\r\n        if (now < startTimeIco + 1 weeks)\r\n            return icoFirstWeekRate;\r\n\r\n        if (now < startTimeIco + 2 weeks)\r\n            return icoSecondWeekRate;\r\n\r\n        if (now < startTimeIco + 3 weeks)\r\n            return icoThirdWeekRate;\r\n\r\n        return icoRate;\r\n    }\r\n\t\r\n    function setExchangeRatePreIco(uint256 _exchangeRatePreIco) public onlyOwner{\r\n\t  exchangeRatePreIco = _exchangeRatePreIco;\r\n\t} \r\n\t\r\n    function setIcoFirstWeekRate(uint256 _icoFirstWeekRate) public onlyOwner{\r\n\t  icoFirstWeekRate = _icoFirstWeekRate;\r\n\t} \t\r\n\t\r\n    function setIcoSecondWeekRate(uint256 _icoSecondWeekRate) public onlyOwner{\r\n\t  icoSecondWeekRate = _icoSecondWeekRate;\r\n\t} \r\n\t\r\n    function setIcoThirdWeekRate(uint256 _icoThirdWeekRate) public onlyOwner{\r\n\t  icoThirdWeekRate = _icoThirdWeekRate;\r\n\t}\r\n\t\r\n    function setIcoRate(uint256 _icoRate) public onlyOwner{\r\n\t  icoRate = _icoRate;\r\n\t}\r\n\t\r\n    /**\r\n    * @dev Sell tokens during Pre-ICO stage.\r\n    */\r\n    function sellTokensPreIco() public payable whenWhitelisted(msg.sender) beforeReachingPreIcoMaxCap whenNotPaused {\r\n        require(isPreIco());\r\n        require(msg.value >= MIN_INVESTMENT);\r\n        uint256 senderTotalInvestment = totalInvestedAmount[msg.sender].add(msg.value);\r\n        require(senderTotalInvestment <= MAX_INVESTMENT);\r\n\r\n        uint256 weiAmount = msg.value;\r\n        uint256 excessiveFunds = 0;\r\n\r\n        uint256 tokensAmount = weiAmount.mul(exchangeRatePreIco);\r\n\r\n        if (tokensAmount > tokensRemainingPreIco) {\r\n            uint256 weiToAccept = tokensRemainingPreIco.div(exchangeRatePreIco);\r\n            excessiveFunds = weiAmount.sub(weiToAccept);\r\n\r\n            tokensAmount = tokensRemainingPreIco;\r\n            weiAmount = weiToAccept;\r\n        }\r\n\r\n        addPreIcoPurchaseInfo(weiAmount, tokensAmount);\r\n\r\n        owner.transfer(weiAmount);\r\n\r\n        token.transferFromIco(msg.sender, tokensAmount);\r\n\r\n        if (excessiveFunds > 0) {\r\n            msg.sender.transfer(excessiveFunds);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Sell tokens during ICO stage.\r\n    */\r\n    function sellTokensIco() public payable whenWhitelisted(msg.sender) beforeReachingIcoMaxCap whenNotPaused {\r\n        require(isIco());\r\n        require(msg.value >= MIN_INVESTMENT);\r\n        uint256 senderTotalInvestment = totalInvestedAmount[msg.sender].add(msg.value);\r\n        require(senderTotalInvestment <= MAX_INVESTMENT);\r\n\r\n        uint256 weiAmount = msg.value;\r\n        uint256 excessiveFunds = 0;\r\n\r\n        uint256 tokensAmount = weiAmount.mul(exchangeRateIco());\r\n\r\n        if (tokensAmount > tokensRemainingIco) {\r\n            uint256 weiToAccept = tokensRemainingIco.div(exchangeRateIco());\r\n            excessiveFunds = weiAmount.sub(weiToAccept);\r\n\r\n            tokensAmount = tokensRemainingIco;\r\n            weiAmount = weiToAccept;\r\n        }\r\n\r\n        addIcoPurchaseInfo(weiAmount, tokensAmount);\r\n\r\n        owner.transfer(weiAmount);\r\n\r\n        token.transferFromIco(msg.sender, tokensAmount);\r\n\r\n        if (excessiveFunds > 0) {\r\n            msg.sender.transfer(excessiveFunds);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Manual send tokens to the specified address.\r\n    * @param _address The address of a investor.\r\n    * @param _tokensAmount Amount of tokens.\r\n    */\r\n    function manualSendTokens(address _address, uint256 _tokensAmount) public whenWhitelisted(_address) onlyOwner {\r\n        require(_address != address(0));\r\n        require(_tokensAmount > 0);\r\n        \r\n        if (isPreIco() && _tokensAmount <= tokensRemainingPreIco) {\r\n            token.transferFromIco(_address, _tokensAmount);\r\n            addPreIcoPurchaseInfo(0, _tokensAmount);\r\n        } else if (isIco() && _tokensAmount <= tokensRemainingIco) {\r\n            token.transferFromIco(_address, _tokensAmount);\r\n            addIcoPurchaseInfo(0, _tokensAmount);\r\n        } else {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Update the pre-ICO investments statistic.\r\n    * @param _weiAmount The investment received from a pre-ICO investor.\r\n    * @param _tokensAmount The tokens that will be sent to pre-ICO investor.\r\n    */\r\n    function addPreIcoPurchaseInfo(uint256 _weiAmount, uint256 _tokensAmount) internal {\r\n        totalInvestedAmount[msg.sender] = totalInvestedAmount[msg.sender].add(_weiAmount);\r\n\r\n        tokensSoldPreIco = tokensSoldPreIco.add(_tokensAmount);\r\n        tokensSoldTotal = tokensSoldTotal.add(_tokensAmount);\r\n        tokensRemainingPreIco = tokensRemainingPreIco.sub(_tokensAmount);\r\n\r\n        weiRaisedPreIco = weiRaisedPreIco.add(_weiAmount);\r\n        weiRaisedTotal = weiRaisedTotal.add(_weiAmount);\r\n    }\r\n\r\n    /**\r\n    * @dev Update the ICO investments statistic.\r\n    * @param _weiAmount The investment received from a ICO investor.\r\n    * @param _tokensAmount The tokens that will be sent to ICO investor.\r\n    */\r\n    function addIcoPurchaseInfo(uint256 _weiAmount, uint256 _tokensAmount) internal {\r\n        totalInvestedAmount[msg.sender] = totalInvestedAmount[msg.sender].add(_weiAmount);\r\n\r\n        tokensSoldIco = tokensSoldIco.add(_tokensAmount);\r\n        tokensSoldTotal = tokensSoldTotal.add(_tokensAmount);\r\n        tokensRemainingIco = tokensRemainingIco.sub(_tokensAmount);\r\n\r\n        weiRaisedIco = weiRaisedIco.add(_weiAmount);\r\n        weiRaisedTotal = weiRaisedTotal.add(_weiAmount);\r\n    }\r\n}\r\ncontract Factory {\r\n    VeiagCrowdsale public crowdsale;\r\n\r\n    function createCrowdsale (\r\n        uint256 _startTimePreIco,\r\n        uint256 _endTimePreIco,\r\n        uint256 _startTimeIco,\r\n        uint256 _endTimeIco,\r\n        address _lockedWallet,\r\n        address _teamsWallet,\r\n        address _foundersWallet,\r\n        address _marketingWallet\r\n    ) public\r\n    {\r\n        crowdsale = new VeiagCrowdsale(\r\n            _startTimePreIco,\r\n            _endTimePreIco,\r\n            _startTimeIco,\r\n            _endTimeIco,\r\n            _lockedWallet,\r\n            _teamsWallet,\r\n            _foundersWallet,\r\n            _marketingWallet\r\n        );\r\n\r\n        Whitelist whitelist = crowdsale.whitelist();\r\n        whitelist.transferOwnership(msg.sender);\r\n\r\n        VeiagToken token = crowdsale.token();\r\n        token.transferOwnership(msg.sender);\r\n        crowdsale.transferOwnership(msg.sender);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"},{\"name\":\"_tokensAmount\",\"type\":\"uint256\"}],\"name\":\"manualSendTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRateIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoRate\",\"type\":\"uint256\"}],\"name\":\"setIcoRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXCAP_TOKENS_ICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVED_LOCKED_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellTokensPreIco\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAXCAP_TOKENS_PRE_ICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoFirstWeekRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTimeIco\",\"type\":\"uint256\"}],\"name\":\"SetStartTimeIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimeIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRatePreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimeIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSoldTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_INVESTMENT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaisedPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSoldPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"foundersTokenVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSoldIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRemainingIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVED_MARKETING_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaisedIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRatePreIco\",\"type\":\"uint256\"}],\"name\":\"setExchangeRatePreIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"sellTokensIco\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoSecondWeekRate\",\"type\":\"uint256\"}],\"name\":\"setIcoSecondWeekRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensRemainingPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaisedTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVED_TEAMS_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RESERVED_FOUNDERS_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoFirstWeekRate\",\"type\":\"uint256\"}],\"name\":\"setIcoFirstWeekRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoThirdWeekRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_startTimeVestingForFounders\",\"type\":\"uint256\"}],\"name\":\"SetStartVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoSecondWeekRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoThirdWeekRate\",\"type\":\"uint256\"}],\"name\":\"setIcoThirdWeekRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTimePreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamsTokenVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTimePreIco\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isIco\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_startTimePreIco\",\"type\":\"uint256\"},{\"name\":\"_endTimePreIco\",\"type\":\"uint256\"},{\"name\":\"_startTimeIco\",\"type\":\"uint256\"},{\"name\":\"_endTimeIco\",\"type\":\"uint256\"},{\"name\":\"_lockedWallet\",\"type\":\"address\"},{\"name\":\"_teamsWallet\",\"type\":\"address\"},{\"name\":\"_foundersWallet\",\"type\":\"address\"},{\"name\":\"_marketingWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"VeiagCrowdsale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005baf6940000000000000000000000000000000000000000000000000000000005c2a04c0000000000000000000000000000000000000000000000000000000005c2b5640000000000000000000000000000000000000000000000000000000005ca2a600000000000000000000000000386b8b8f72d466fda1512672d47793bfbd201e250000000000000000000000009966b0a750b64dc6abe7c9a65a321223d15ec397000000000000000000000000282edc45f39af2d976c8fb47cb032ee3eb0a8d6100000000000000000000000058a36dfa52d78f95397bdb87488f76e3e27d9906","Library":"","SwarmSource":"bzzr://1089eaeeffd671fd0001ab65870fd3a5b1078c3d9d03aa7bb4b21d2fbd500f88"}]}