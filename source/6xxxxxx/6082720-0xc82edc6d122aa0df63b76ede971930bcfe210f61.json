{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\nlibrary DateTimeUtility {\r\n    \r\n    function toGMT(uint256 _unixtime) \r\n        pure \r\n        internal \r\n        returns(uint32, uint8, uint8, uint8, uint8, uint8)\r\n    {\r\n        // http://ptspts.blogspot.com/2009/11/how-to-convert-unix-timestamp-to-civil.html\r\n        uint256 secs = _unixtime % 86400;\r\n        \r\n        _unixtime /= 86400;\r\n        uint256 e = (_unixtime * 4 + 102032) / 146097 + 15;\r\n        e = _unixtime + 2442113 + e - (e / 4);\r\n        uint256 c = (e * 20 - 2442) / 7305;\r\n        uint256 d = e - 365 * c - c / 4;\r\n        e = d * 1000 / 30601;\r\n        \r\n        if (e < 14) {\r\n            return (uint32(c - 4716)\r\n                , uint8(e - 1)\r\n                , uint8(d - e * 30 - e * 601 / 1000)\r\n                , uint8(secs / 3600)\r\n                , uint8(secs / 60 % 60)\r\n                , uint8(secs % 60));\r\n        } else {\r\n            return (uint32(c - 4715)\r\n                , uint8(e - 13)\r\n                , uint8(d - e * 30 - e * 601 / 1000)\r\n                , uint8(secs / 3600)\r\n                , uint8(secs / 60 % 60)\r\n                , uint8(secs % 60));\r\n        }\r\n    } \r\n    \r\n    function toUnixtime(uint32 _year, uint8 _month, uint8 _mday, uint8 _hour, uint8 _minute, uint8 _second) \r\n        pure \r\n        internal \r\n        returns (uint256)\r\n    {\r\n        // http://ptspts.blogspot.com/2009/11/how-to-convert-unix-timestamp-to-civil.html\r\n        \r\n        uint256 m = uint256(_month);\r\n        uint256 y = uint256(_year);\r\n        if (m <= 2) {\r\n            y -= 1;\r\n            m += 12;\r\n        }\r\n        \r\n        return (365 * y + y / 4 -  y/ 100 + y / 400 + 3 * (m + 1) / 5 + 30 * m + uint256(_mday) - 719561) * 86400 \r\n            + 3600 * uint256(_hour) + 60 * uint256(_minute) + uint256(_second);\r\n    }\r\n}\r\n\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\ncontract StrayToken is StandardToken, BurnableToken, Ownable {\r\n\tusing SafeERC20 for ERC20;\r\n\t\r\n\tuint256 public INITIAL_SUPPLY = 1000000000;\r\n\t\r\n\tstring public name = \"Stray\";\r\n\tstring public symbol = \"ST\";\r\n\tuint8 public decimals = 18;\r\n\r\n\taddress public companyWallet;\r\n\taddress public privateWallet;\r\n\taddress public fund;\r\n\t\r\n\t/**\r\n\t * @param _companyWallet The company wallet which reserves 15% of the token.\r\n\t * @param _privateWallet Private wallet which reservers 25% of the token.\r\n\t */\r\n\tconstructor(address _companyWallet, address _privateWallet) public {\r\n\t\trequire(_companyWallet != address(0));\r\n\t\trequire(_privateWallet != address(0));\r\n\t\t\r\n\t\ttotalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals));\r\n\t\tcompanyWallet = _companyWallet;\r\n\t\tprivateWallet = _privateWallet;\r\n\t\t\r\n\t\t// 15% of tokens for company reserved.\r\n\t\t_preSale(companyWallet, totalSupply_.mul(15).div(100));\r\n\t\t\r\n\t\t// 25% of tokens for private funding.\r\n\t\t_preSale(privateWallet, totalSupply_.mul(25).div(100));\r\n\t\t\r\n\t\t// 60% of tokens for crowdsale.\r\n\t\tuint256 sold = balances[companyWallet].add(balances[privateWallet]);\r\n\t    balances[msg.sender] = balances[msg.sender].add(totalSupply_.sub(sold));\r\n\t    emit Transfer(address(0), msg.sender, balances[msg.sender]);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param _fund The DAICO fund contract address.\r\n\t */\r\n\tfunction setFundContract(address _fund) onlyOwner public {\r\n\t    require(_fund != address(0));\r\n\t    //require(_fund != owner);\r\n\t    //require(_fund != msg.sender);\r\n\t    require(_fund != address(this));\r\n\t    \r\n\t    fund = _fund;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev The DAICO fund contract calls this function to burn the user's token\r\n\t * to avoid over refund.\r\n\t * @param _from The address which just took its refund.\r\n\t */\r\n\tfunction burnAll(address _from) public {\r\n\t    require(fund == msg.sender);\r\n\t    require(0 != balances[_from]);\r\n\t    \r\n\t    _burn(_from, balances[_from]);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param _to The address which will get the token.\r\n\t * @param _value The token amount.\r\n\t */\r\n\tfunction _preSale(address _to, uint256 _value) internal onlyOwner {\r\n\t\tbalances[_to] = _value;\r\n\t\temit Transfer(address(0), _to, _value);\r\n\t}\r\n\t\r\n}\r\n\r\ncontract StrayFund is Ownable {\r\n\tusing SafeMath for uint256;\r\n\tusing DateTimeUtility for uint256;\r\n\t\r\n    // The fund state.\r\n\tenum State {\r\n\t    NotReady       // The fund is not ready for any operations.\r\n\t    , TeamWithdraw // The fund can be withdrawn and voting proposals.\r\n\t    , Refunding    // The fund only can be refund..\r\n\t    , Closed       // The fund is closed.\r\n\t}\r\n\t\r\n\r\n\t// @dev Proposal type for voting.\r\n\tenum ProposalType { \r\n\t    Tap          // Tap proposal sponsored by token holder out of company.\r\n\t    , OfficalTap // Tap proposal sponsored by company.\r\n\t    , Refund     // Refund proposal.\r\n\t}\r\n\t\r\n\t// A special number indicates that no valid id.\r\n\tuint256 NON_UINT256 = (2 ** 256) - 1;\r\n\t\r\n\t// Data type represent a vote.\r\n\tstruct Vote {\r\n\t\taddress tokeHolder; // Voter address.\r\n\t\tbool inSupport;     // Support or not.\r\n\t}\r\n\t\r\n\t// Voting proposal.\r\n\tstruct Proposal {              \r\n\t    ProposalType proposalType; // Proposal type.\r\n\t    address sponsor;           // Who proposed this vote.\r\n\t    uint256 openingTime;       // Opening time of the voting.\r\n\t    uint256 closingTime;       // Closing time of the voting.\r\n\t    Vote[] votes;              // All votes.\r\n\t\tmapping (address => bool) voted; // Prevent duplicate vote.\r\n\t\tbool isPassed;             // Final result.\r\n\t\tbool isFinialized;         // Proposal state.\r\n\t\tuint256 targetWei;         // Tap proposal target.\r\n\t}\r\n\t\r\n\t// Budget plan stands a budget period for the team to withdraw the funds.\r\n\tstruct BudgetPlan {\r\n\t    uint256 proposalId;       // The tap proposal id.\r\n\t    uint256 budgetInWei;      // Budget in wei.\r\n\t    uint256 withdrawnWei;     // Withdrawn wei.\r\n\t    uint256 startTime;        // Start time of this budget plan. \r\n\t    uint256 endTime;          // End time of this budget plan.\r\n\t    uint256 officalVotingTime; // The offical tap voting time in this period.\r\n\t}\r\n\t\r\n\t// Team wallet to receive the budget.\r\n\taddress public teamWallet;\r\n\t\r\n\t// Fund state.\r\n\tState public state;\r\n\t\r\n\t// Stary Token.\r\n\tStrayToken public token;\r\n\t\r\n\t// Proposal history.\r\n\tProposal[] public proposals;\r\n\t\r\n\t// Budget plan history.\r\n\tBudgetPlan[] public budgetPlans;\r\n\t\r\n\t// Current budget plan id.\r\n\tuint256 currentBudgetPlanId;\r\n\t\r\n\t// The mininum budget.\r\n\tuint256 public MIN_WITHDRAW_WEI = 1 ether;\r\n\t\r\n\t// The fist withdraw rate when the crowdsale was successed.\r\n\tuint256 public FIRST_WITHDRAW_RATE = 20;\r\n\t\r\n\t// The voting duration.\r\n\tuint256 public VOTING_DURATION = 1 weeks;\r\n\t\r\n\t// Offical voting day of the last month of budget period. \r\n\tuint8 public OFFICAL_VOTING_DAY_OF_MONTH = 23;\r\n\t\r\n\t// Refund lock duration.\r\n\tuint256 public REFUND_LOCK_DURATION = 30 days;\r\n\t\r\n\t// Refund lock date.\r\n\tuint256 public refundLockDate = 0;\r\n\t\r\n\tevent TeamWithdrawEnabled();\r\n\tevent RefundsEnabled();\r\n\tevent Closed();\r\n\t\r\n\tevent TapVoted(address indexed voter, bool isSupported);\r\n\tevent TapProposalAdded(uint256 openingTime, uint256 closingTime, uint256 targetWei);\r\n\tevent TapProposalClosed(uint256 closingTime, uint256 targetWei, bool isPassed);\r\n\t\r\n\tevent RefundVoted(address indexed voter, bool isSupported);\r\n\tevent RefundProposalAdded(uint256 openingTime, uint256 closingTime);\r\n\tevent RefundProposalClosed(uint256 closingTime, bool isPassed);\r\n\t\r\n\tevent Withdrew(uint256 weiAmount);\r\n\tevent Refund(address indexed holder, uint256 amount);\r\n\t\r\n\tmodifier onlyTokenHolders {\r\n\t\trequire(token.balanceOf(msg.sender) != 0);\r\n\t\t_;\r\n\t}\r\n\t\r\n\tmodifier inWithdrawState {\r\n\t    require(state == State.TeamWithdraw);\r\n\t    _;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @param _teamWallet The wallet which receives the funds.\r\n\t * @param _token Stray token address.\r\n\t */\r\n    constructor(address _teamWallet, address _token) public {\r\n\t\trequire(_teamWallet != address(0));\r\n\t\trequire(_token != address(0));\r\n\t\t\r\n\t\tteamWallet = _teamWallet;\r\n\t\tstate = State.NotReady;\r\n\t\ttoken = StrayToken(_token);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Enable the TeamWithdraw state.\r\n\t */\r\n\tfunction enableTeamWithdraw() onlyOwner public {\r\n\t\trequire(state == State.NotReady);\r\n\t\tstate = State.TeamWithdraw;\r\n\t\temit TeamWithdrawEnabled();\r\n\t\t\r\n\t\tbudgetPlans.length++;\r\n\t\tBudgetPlan storage plan = budgetPlans[0];\r\n\t\t\r\n\t    plan.proposalId = NON_UINT256;\r\n\t    plan.budgetInWei = address(this).balance.mul(FIRST_WITHDRAW_RATE).div(100);\r\n\t    plan.withdrawnWei = 0;\r\n\t    plan.startTime = now;\r\n\t    (plan.endTime, plan.officalVotingTime) = _budgetEndAndOfficalVotingTime(now);\r\n\t    \r\n\t    currentBudgetPlanId = 0;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Close the fund.\r\n\t */\r\n\tfunction close() onlyOwner inWithdrawState public {\r\n\t    require(address(this).balance < MIN_WITHDRAW_WEI);\r\n\t    \r\n\t\tstate = State.Closed;\r\n\t\temit Closed();\r\n\t\t\r\n\t\tteamWallet.transfer(address(this).balance);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Check if there is an ongoing proposal.\r\n\t */\r\n\tfunction isThereAnOnGoingProposal() public view returns (bool) {\r\n\t    if (proposals.length == 0 || state != State.TeamWithdraw) {\r\n\t        return false;\r\n\t    } else {\r\n\t        Proposal storage p = proposals[proposals.length - 1];\r\n\t        return now < p.closingTime;\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Check if next budget period plan has been made.\r\n\t */\r\n\tfunction isNextBudgetPlanMade() public view returns (bool) {\r\n\t    if (state != State.TeamWithdraw) {\r\n\t        return false;\r\n\t    } else {\r\n\t        return currentBudgetPlanId != budgetPlans.length - 1;\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Get number of proposals. \r\n\t */\r\n\tfunction numberOfProposals() public view returns (uint256) {\r\n\t    return proposals.length;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Get number of budget plans. \r\n\t */\r\n\tfunction numberOfBudgetPlan() public view returns (uint256) {\r\n\t    return budgetPlans.length;\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Try to finialize the last proposal.\r\n\t */\r\n\tfunction tryFinializeLastProposal() inWithdrawState public {\r\n\t    if (proposals.length == 0) {\r\n\t        return;\r\n\t    }\r\n\t    \r\n\t    uint256 id = proposals.length - 1;\r\n\t    Proposal storage p = proposals[id];\r\n\t    if (now > p.closingTime && !p.isFinialized) {\r\n\t        _countVotes(p);\r\n\t        if (p.isPassed) {\r\n\t            if (p.proposalType == ProposalType.Refund) {\r\n\t                _enableRefunds();\r\n\t            } else {\r\n\t                _makeBudgetPlan(p, id);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Create new tap proposal by address out of company.\r\n\t * @param _targetWei The voting target.\r\n\t */\r\n\tfunction newTapProposalFromTokenHolders(uint256 _targetWei)\r\n\t    onlyTokenHolders \r\n\t    inWithdrawState \r\n\t    public\r\n\t{\r\n\t    // Sponsor cannot be stuff of company.\r\n\t    require(msg.sender != owner);\r\n\t    require(msg.sender != teamWallet);\r\n\t    \r\n\t    // Check the last result.\r\n\t    tryFinializeLastProposal();\r\n\t    require(state == State.TeamWithdraw);\r\n\t    \r\n\t    // Proposal is disable when the budget plan has been made.\r\n\t    require(!isNextBudgetPlanMade());\r\n\t    \r\n\t    // Proposal voting is exclusive.\r\n\t    require(!isThereAnOnGoingProposal());\r\n\t    \r\n\t    // Validation of time restriction.\r\n\t    BudgetPlan storage b = budgetPlans[currentBudgetPlanId];\r\n\t\trequire(now <= b.officalVotingTime && now >= b.startTime);\r\n\t\t\r\n\t\t// Sponsor is not allowed to propose repeatly in the same budget period.\r\n\t\trequire(!_hasProposed(msg.sender, ProposalType.Tap));\r\n\t\t\r\n\t\t// Create a new proposal.\r\n\t\t_newTapProposal(ProposalType.Tap, _targetWei);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Create new tap proposal by company.\r\n\t * @param _targetWei The voting target.\r\n\t */\r\n\tfunction newTapProposalFromCompany(uint256 _targetWei)\r\n\t    onlyOwner \r\n\t    inWithdrawState \r\n\t    public\r\n\t{\r\n\t    // Check the last result.\r\n\t    tryFinializeLastProposal();\r\n\t    require(state == State.TeamWithdraw);\r\n\t    \r\n\t    // Proposal is disable when the budget plan has been made.\r\n\t    require(!isNextBudgetPlanMade());\r\n\t    \r\n\t    // Proposal voting is exclusive.\r\n\t    require(!isThereAnOnGoingProposal());\r\n\t    \r\n\t    // Validation of time restriction.\r\n\t    BudgetPlan storage b = budgetPlans[currentBudgetPlanId];\r\n\t\trequire(now >= b.officalVotingTime);\r\n\t\t\r\n\t\t// Create a new proposal.\r\n\t\t_newTapProposal(ProposalType.OfficalTap, _targetWei);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Create a refund proposal.\r\n\t */\r\n\tfunction newRefundProposal() onlyTokenHolders inWithdrawState public {\r\n\t    // Check the last result.\r\n\t    tryFinializeLastProposal();\r\n\t    require(state == State.TeamWithdraw);\r\n\t    \r\n\t    // Proposal voting is exclusive.\r\n\t    require(!isThereAnOnGoingProposal());\r\n\t    \r\n\t    // Sponsor is not allowed to propose repeatly in the same budget period.\r\n\t    require(!_hasProposed(msg.sender, ProposalType.Refund));\r\n\t    \r\n\t    // Create proposals.\r\n\t\tuint256 id = proposals.length++;\r\n\t\tProposal storage p = proposals[id];\r\n\t\tp.proposalType = ProposalType.Refund;\r\n\t\tp.sponsor = msg.sender;\r\n\t\tp.openingTime = now;\r\n\t\tp.closingTime = now + VOTING_DURATION;\r\n\t\tp.isPassed = false;\r\n\t\tp.isFinialized = false;\r\n\t\t\r\n\t\t// Signal the event.\r\n\t\temit RefundProposalAdded(p.openingTime, p.closingTime);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Vote for a tap proposal.\r\n\t * @param _supportsProposal True if the vote supports the proposal.\r\n\t */\r\n\tfunction voteForTap(bool _supportsProposal)\r\n\t    onlyTokenHolders\r\n\t    inWithdrawState\r\n\t    public\r\n\t{\r\n\t    // Check the last result.\r\n\t    tryFinializeLastProposal();\r\n\t\trequire(isThereAnOnGoingProposal());\r\n\t\t\r\n\t\t// Check the ongoing proposal's type and reject the voted address.\r\n\t\tProposal storage p = proposals[proposals.length - 1];\r\n\t\trequire(p.proposalType != ProposalType.Refund);\r\n\t\trequire(true != p.voted[msg.sender]);\r\n\t\t\r\n\t\t// Record the vote.\r\n\t\tuint256 voteId = p.votes.length++;\r\n\t\tp.votes[voteId].tokeHolder = msg.sender;\r\n\t\tp.votes[voteId].inSupport = _supportsProposal;\r\n\t\tp.voted[msg.sender] = true;\r\n\t\t\r\n\t\t// Signal the event.\r\n\t\temit TapVoted(msg.sender, _supportsProposal);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Vote for a tap proposal.\r\n\t * @param _supportsProposal True if the vote supports the proposal.\r\n\t */\r\n\tfunction voteForRefund(bool _supportsProposal)\r\n\t    onlyTokenHolders\r\n\t    inWithdrawState\r\n\t    public\r\n\t{\r\n\t    // Check the last result.\r\n\t    tryFinializeLastProposal();\r\n\t\trequire(isThereAnOnGoingProposal());\r\n\t\t\r\n\t\t// Check the ongoing proposal's type and reject the voted address.\r\n\t\tProposal storage p = proposals[proposals.length - 1];\r\n\t\trequire(p.proposalType == ProposalType.Refund);\r\n\t\trequire(true != p.voted[msg.sender]);\r\n\t\t\r\n\t\t// Record the vote.\r\n\t\tuint256 voteId = p.votes.length++;\r\n\t\tp.votes[voteId].tokeHolder = msg.sender;\r\n\t\tp.votes[voteId].inSupport = _supportsProposal;\r\n\t\tp.voted[msg.sender] = true;\r\n\t\t\r\n\t\t// Signal the event.\r\n\t\temit RefundVoted(msg.sender, _supportsProposal);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Withdraw the wei to team wallet.\r\n\t * @param _amount Withdraw wei.\r\n\t */\r\n\tfunction withdraw(uint256 _amount) onlyOwner inWithdrawState public {\r\n\t    // Check the last result.\r\n\t    tryFinializeLastProposal();\r\n\t    require(state == State.TeamWithdraw);\r\n\t    \r\n\t    // Try to update the budget plans.\r\n\t    BudgetPlan storage currentPlan = budgetPlans[currentBudgetPlanId];\r\n\t    if (now > currentPlan.endTime) {\r\n\t        require(isNextBudgetPlanMade());\r\n\t        ++currentBudgetPlanId;\r\n\t    }\r\n\t    \r\n\t    // Withdraw the weis.\r\n\t    _withdraw(_amount);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Withdraw when there is no budget plans.\r\n\t */\r\n\tfunction withdrawOnNoAvailablePlan() onlyOwner inWithdrawState public {\r\n\t    require(address(this).balance >= MIN_WITHDRAW_WEI);\r\n\t    \r\n\t    // Check the last result.\r\n\t    tryFinializeLastProposal();\r\n\t    require(state == State.TeamWithdraw);\r\n\t    \r\n\t    // Check if someone proposed a tap voting.\r\n\t    require(!_isThereAnOnGoingTapProposal());\r\n\t    \r\n\t    // There is no passed budget plan.\r\n\t    require(!isNextBudgetPlanMade());\r\n\t    \r\n\t    // Validate the time.\r\n\t    BudgetPlan storage currentPlan = budgetPlans[currentBudgetPlanId];\r\n\t    require(now > currentPlan.endTime);\r\n\t    \r\n\t    // Create plan.\r\n\t    uint256 planId = budgetPlans.length++;\r\n\t    BudgetPlan storage plan = budgetPlans[planId];\r\n\t    plan.proposalId = NON_UINT256;\r\n\t    plan.budgetInWei = MIN_WITHDRAW_WEI;\r\n\t    plan.withdrawnWei = 0;\r\n\t    plan.startTime = now;\r\n\t    (plan.endTime, plan.officalVotingTime) = _budgetEndAndOfficalVotingTime(now);\r\n\t    \r\n\t    ++currentBudgetPlanId;\r\n\t    \r\n\t    // Withdraw the weis.\r\n\t    _withdraw(MIN_WITHDRAW_WEI);\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Tokenholders can claim refunds here.\r\n     */\r\n\tfunction claimRefund() onlyTokenHolders public {\r\n\t    // Check the state.\r\n\t\trequire(state == State.Refunding);\r\n\t\t\r\n\t\t// Validate the time.\r\n\t\trequire(now > refundLockDate + REFUND_LOCK_DURATION);\r\n\t\t\r\n\t\t// Calculate the transfering wei and burn all the token of the refunder.\r\n\t\tuint256 amount = address(this).balance.mul(token.balanceOf(msg.sender)).div(token.totalSupply());\r\n\t\ttoken.burnAll(msg.sender);\r\n\t\t\r\n\t\t// Signal the event.\r\n\t\tmsg.sender.transfer(amount);\r\n\t}\r\n\t\r\n\t/**\r\n\t * @dev Check if refund is in lock period.\r\n\t */\r\n\t function isRefundLocked() public view returns (bool) {\r\n\t     return state == State.Refunding && now < refundLockDate + REFUND_LOCK_DURATION;\r\n\t }\r\n\t\r\n\t/**\r\n\t * @dev Get remaining funds.\r\n\t */\r\n\t function remainingFunds() public view returns (uint256) {\r\n\t     return address(this).balance;\r\n\t }\r\n\t\r\n\t/**\r\n     * @dev Receive the initial funds from crowdsale contract.\r\n     */\r\n\tfunction receiveInitialFunds() payable public {\r\n\t    require(state == State.NotReady);\r\n\t}\r\n\t\r\n\t/**\r\n     * @dev Fallback function to receive initial funds.\r\n     */\r\n\tfunction () payable public {\r\n\t    receiveInitialFunds();\r\n\t}\r\n\t\r\n\tfunction _withdraw(uint256 _amount) internal {\r\n\t    BudgetPlan storage plan = budgetPlans[currentBudgetPlanId];\r\n\t    \r\n\t    // Validate the time.\r\n\t    require(now <= plan.endTime);\r\n\t    \r\n\t    // Check the remaining wei.\r\n\t    require(_amount + plan.withdrawnWei <= plan.budgetInWei);\r\n\t       \r\n\t    // Transfer the wei.\r\n\t    plan.withdrawnWei += _amount;\r\n\t    teamWallet.transfer(_amount);\r\n\t    \r\n\t    // Signal the event.\r\n\t    emit Withdrew(_amount);\r\n\t}\r\n\t\r\n\tfunction _countVotes(Proposal storage p)\r\n\t    internal \r\n\t    returns (bool)\r\n\t{\r\n\t    require(!p.isFinialized);\r\n\t    require(now > p.closingTime);\r\n\t    \r\n\t\tuint256 yes = 0;\r\n\t\tuint256 no = 0;\r\n\t\t\r\n\t\tfor (uint256 i = 0; i < p.votes.length; ++i) {\r\n\t\t\tVote storage v = p.votes[i];\r\n\t\t\tuint256 voteWeight = token.balanceOf(v.tokeHolder);\r\n\t\t\tif (v.inSupport) {\r\n\t\t\t\tyes += voteWeight;\r\n\t\t\t} else {\r\n\t\t\t\tno += voteWeight;\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\tp.isPassed = (yes >= no);\r\n\t\tp.isFinialized = true;\r\n\t\t\r\n\t\temit TapProposalClosed(p.closingTime\r\n\t\t\t, p.targetWei\r\n\t\t\t, p.isPassed);\r\n\t\t\r\n\t\treturn p.isPassed;\r\n\t}\r\n\t\r\n\tfunction _enableRefunds() inWithdrawState internal {\r\n\t    state = State.Refunding;\r\n\t\temit RefundsEnabled();\r\n\t\t\r\n\t\trefundLockDate = now;\r\n\t}\r\n\t\r\n\tfunction _makeBudgetPlan(Proposal storage p, uint256 proposalId) \r\n\t    internal\r\n\t{\r\n\t    require(p.proposalType != ProposalType.Refund);\r\n\t    require(p.isFinialized);\r\n\t    require(p.isPassed);\r\n\t    require(!isNextBudgetPlanMade());\r\n\t    \r\n\t    uint256 planId = budgetPlans.length++;\r\n\t    BudgetPlan storage plan = budgetPlans[planId];\r\n\t    plan.proposalId = proposalId;\r\n\t    plan.budgetInWei = p.targetWei;\r\n\t    plan.withdrawnWei = 0;\r\n\t    \r\n\t    if (now > budgetPlans[currentBudgetPlanId].endTime) {\r\n\t        plan.startTime = now;\r\n\t        (plan.endTime, plan.officalVotingTime) = _budgetEndAndOfficalVotingTime(now);\r\n\t        ++currentBudgetPlanId;\r\n\t    } else {\r\n\t        (plan.startTime, plan.endTime, plan.officalVotingTime) = _nextBudgetStartAndEndAndOfficalVotingTime();\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction _newTapProposal(ProposalType _proposalType, uint256 _targetWei) internal {\r\n\t    // The minimum wei requirement.\r\n\t\trequire(_targetWei >= MIN_WITHDRAW_WEI && _targetWei <= address(this).balance);\r\n\t    \r\n\t    uint256 id = proposals.length++;\r\n        Proposal storage p = proposals[id];\r\n        p.proposalType = _proposalType;\r\n\t\tp.sponsor = msg.sender;\r\n\t\tp.openingTime = now;\r\n\t\tp.closingTime = now + VOTING_DURATION;\r\n\t\tp.isPassed = false;\r\n\t\tp.isFinialized = false;\r\n\t\tp.targetWei = _targetWei;\r\n\t\t\r\n\t\temit TapProposalAdded(p.openingTime\r\n\t\t\t, p.closingTime\r\n\t\t\t, p.targetWei);\r\n\t}\r\n\t\r\n\tfunction _isThereAnOnGoingTapProposal() internal view returns (bool) {\r\n\t    if (proposals.length == 0) {\r\n\t        return false;\r\n\t    } else {\r\n\t        Proposal storage p = proposals[proposals.length - 1];\r\n\t        return p.proposalType != ProposalType.Refund  && now < p.closingTime;\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction _budgetEndAndOfficalVotingTime(uint256 _startTime)\r\n\t    view\r\n\t    internal\r\n\t    returns (uint256, uint256)\r\n\t{\r\n\t    // Decompose to datetime.\r\n        uint32 year;\r\n        uint8 month;\r\n        uint8 mday;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        (year, month, mday, hour, minute, second) = _startTime.toGMT();\r\n        \r\n        // Calculate the next end time of budget period.\r\n        month = ((month - 1) / 3 + 1) * 3 + 1;\r\n        if (month > 12) {\r\n            month -= 12;\r\n            year += 1;\r\n        }\r\n        \r\n        mday = 1;\r\n        hour = 0;\r\n        minute = 0;\r\n        second = 0;\r\n        \r\n        uint256 end = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second) - 1;\r\n     \r\n         // Calculate the offical voting time of the budget period.\r\n        mday = OFFICAL_VOTING_DAY_OF_MONTH;\r\n        hour = 0;\r\n        minute = 0;\r\n        second = 0;\r\n        \r\n        uint256 votingTime = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second);\r\n        \r\n        return (end, votingTime);\r\n\t}\r\n    \r\n    function _nextBudgetStartAndEndAndOfficalVotingTime() \r\n        view \r\n        internal \r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        // Decompose to datetime.\r\n        uint32 year;\r\n        uint8 month;\r\n        uint8 mday;\r\n        uint8 hour;\r\n        uint8 minute;\r\n        uint8 second;\r\n        (year, month, mday, hour, minute, second) = now.toGMT();\r\n        \r\n        // Calculate the next start time of budget period. (1/1, 4/1, 7/1, 10/1)\r\n        month = ((month - 1) / 3 + 1) * 3 + 1;\r\n        if (month > 12) {\r\n            month -= 12;\r\n            year += 1;\r\n        }\r\n        \r\n        mday = 1;\r\n        hour = 0;\r\n        minute = 0;\r\n        second = 0;\r\n        \r\n        uint256 start = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second);\r\n        \r\n        // Calculate the next end time of budget period.\r\n        month = ((month - 1) / 3 + 1) * 3 + 1;\r\n        if (month > 12) {\r\n            month -= 12;\r\n            year += 1;\r\n        }\r\n        \r\n        uint256 end = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second) - 1;\r\n        \r\n        // Calculate the offical voting time of the budget period.\r\n        mday = OFFICAL_VOTING_DAY_OF_MONTH;\r\n        hour = 0;\r\n        minute = 0;\r\n        second = 0;\r\n        \r\n        uint256 votingTime = DateTimeUtility.toUnixtime(year, month, mday, hour, minute, second);\r\n        \r\n        return (start, end, votingTime);\r\n    } \r\n    \r\n    function _hasProposed(address _sponsor, ProposalType proposalType)\r\n        internal\r\n        view\r\n        returns (bool)\r\n    {\r\n        if (proposals.length == 0) {\r\n            return false;\r\n        } else {\r\n            BudgetPlan storage b = budgetPlans[currentBudgetPlanId];\r\n            for (uint256 i = proposals.length - 1;; --i) {\r\n                Proposal storage p = proposals[i];\r\n                if (p.openingTime < b.startTime) {\r\n                    return false;\r\n                } else if (p.openingTime <= b.endTime \r\n                            && p.sponsor == _sponsor \r\n                            && p.proposalType == proposalType\r\n                            && !p.isPassed) {\r\n                    return true;\r\n                }\r\n                \r\n                if (i == 0)\r\n                    break;\r\n            }\r\n            return false;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"proposals\",\"outputs\":[{\"name\":\"proposalType\",\"type\":\"uint8\"},{\"name\":\"sponsor\",\"type\":\"address\"},{\"name\":\"openingTime\",\"type\":\"uint256\"},{\"name\":\"closingTime\",\"type\":\"uint256\"},{\"name\":\"isPassed\",\"type\":\"bool\"},{\"name\":\"isFinialized\",\"type\":\"bool\"},{\"name\":\"targetWei\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isNextBudgetPlanMade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FIRST_WITHDRAW_RATE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfBudgetPlan\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFUND_LOCK_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"close\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targetWei\",\"type\":\"uint256\"}],\"name\":\"newTapProposalFromTokenHolders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"OFFICAL_VOTING_DAY_OF_MONTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"tryFinializeLastProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_supportsProposal\",\"type\":\"bool\"}],\"name\":\"voteForRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"enableTeamWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isThereAnOnGoingProposal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numberOfProposals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_WITHDRAW_WEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"budgetPlans\",\"outputs\":[{\"name\":\"proposalId\",\"type\":\"uint256\"},{\"name\":\"budgetInWei\",\"type\":\"uint256\"},{\"name\":\"withdrawnWei\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"officalVotingTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VOTING_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_supportsProposal\",\"type\":\"bool\"}],\"name\":\"voteForTap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawOnNoAvailablePlan\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_targetWei\",\"type\":\"uint256\"}],\"name\":\"newTapProposalFromCompany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"newRefundProposal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"refundLockDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRefundLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"receiveInitialFunds\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_teamWallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"TeamWithdrawEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"RefundsEnabled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Closed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isSupported\",\"type\":\"bool\"}],\"name\":\"TapVoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"openingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"targetWei\",\"type\":\"uint256\"}],\"name\":\"TapProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"closingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"targetWei\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isPassed\",\"type\":\"bool\"}],\"name\":\"TapProposalClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isSupported\",\"type\":\"bool\"}],\"name\":\"RefundVoted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"openingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closingTime\",\"type\":\"uint256\"}],\"name\":\"RefundProposalAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"closingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isPassed\",\"type\":\"bool\"}],\"name\":\"RefundProposalClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"Withdrew\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"holder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"StrayFund","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004f8a99fc9dde98dae12366461e18d9050068932f00000000000000000000000079703fcd68182a9ca2076b7b1516fc871c6d0c8b","Library":"","SwarmSource":"bzzr://7b5956a411e75f3c3ffad13a3598cf5a316f15c43c928d8f918550d0af0a9a47"}]}