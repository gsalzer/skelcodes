{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   *  as the code is not actually created until after the constructor finishes.\r\n   * @param addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\ninterface ERC165 {\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract SupportsInterface is ERC165 {\r\n    \r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n    constructor() public {\r\n        supportedInterfaces[0x01ffc9a7] = true; // ERC165\r\n    }\r\n\r\n    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {\r\n        return supportedInterfaces[_interfaceID];\r\n    }\r\n}\r\n\r\ninterface ERC721 {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n    \r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function transfer(address _to, uint256 _tokenId) external;\r\n    function approve(address _approved, uint256 _tokenId) external;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    \r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC721Enumerable {\r\n    function totalSupply() external view returns (uint256);\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\ninterface ERC721Metadata {\r\n    function name() external view returns (string _name);\r\n    function symbol() external view returns (string _symbol);\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\ncontract NFToken is ERC721, SupportsInterface {\r\n\r\n    using SafeMath for uint256;\r\n    using AddressUtils for address;\r\n    \r\n    // A mapping from NFT ID to the address that owns it.\r\n    mapping (uint256 => address) internal idToOwner;\r\n    \r\n    // Mapping from NFT ID to approved address.\r\n    mapping (uint256 => address) internal idToApprovals;\r\n    \r\n    // Mapping from owner address to count of his tokens.\r\n    mapping (address => uint256) internal ownerToNFTokenCount;\r\n    \r\n    // Mapping from owner address to mapping of operator addresses.\r\n    mapping (address => mapping (address => bool)) internal ownerToOperators;\r\n    \r\n    /**\r\n    * @dev Magic value of a smart contract that can recieve NFT.\r\n    * Equal to: bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\")).\r\n    */\r\n    bytes4 constant MAGIC_ON_ERC721_RECEIVED = 0x150b7a02;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    modifier canOperate(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier canTransfer(uint256 _tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender || getApproved(_tokenId) == msg.sender || ownerToOperators[tokenOwner][msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier validNFToken(uint256 _tokenId) {\r\n        require(idToOwner[_tokenId] != address(0));\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        supportedInterfaces[0x80ac58cd] = true; // ERC721\r\n    }\r\n\r\n\r\n    function balanceOf(address _owner) external view returns (uint256) {\r\n        require(_owner != address(0));\r\n        return ownerToNFTokenCount[_owner];\r\n    }\r\n\r\n    function ownerOf(uint256 _tokenId) external view returns (address _owner) {\r\n        _owner = idToOwner[_tokenId];\r\n        require(_owner != address(0));\r\n    }\r\n\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, _data);\r\n    }\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external {\r\n        _safeTransferFrom(_from, _to, _tokenId, \"\");\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != address(0));\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    function transfer(address _to, uint256 _tokenId) external canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == msg.sender);\r\n        require(_to != address(0));\r\n        _transfer(_to, _tokenId);\r\n    }\r\n\r\n    function approve(address _approved, uint256 _tokenId) external canOperate(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(_approved != tokenOwner);\r\n\r\n        idToApprovals[_tokenId] = _approved;\r\n        emit Approval(tokenOwner, _approved, _tokenId);\r\n    }\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) external {\r\n        require(_operator != address(0));\r\n        ownerToOperators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n    }\r\n\r\n    function getApproved(uint256 _tokenId) public view validNFToken(_tokenId) returns (address) {\r\n        return idToApprovals[_tokenId];\r\n    }\r\n\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool) {\r\n        require(_owner != address(0));\r\n        require(_operator != address(0));\r\n        return ownerToOperators[_owner][_operator];\r\n    }\r\n\r\n    function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) internal canTransfer(_tokenId) validNFToken(_tokenId) {\r\n        address tokenOwner = idToOwner[_tokenId];\r\n        require(tokenOwner == _from);\r\n        require(_to != address(0));\r\n\r\n        _transfer(_to, _tokenId);\r\n\r\n        if (_to.isContract()) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n            require(retval == MAGIC_ON_ERC721_RECEIVED);\r\n        }\r\n    }\r\n\r\n    function _transfer(address _to, uint256 _tokenId) private {\r\n        address from = idToOwner[_tokenId];\r\n        clearApproval(_tokenId);\r\n        removeNFToken(from, _tokenId);\r\n        addNFToken(_to, _tokenId);\r\n        emit Transfer(from, _to, _tokenId);\r\n    }\r\n   \r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        require(_to != address(0));\r\n        require(_tokenId != 0);\r\n        require(idToOwner[_tokenId] == address(0));\r\n\r\n        addNFToken(_to, _tokenId);\r\n\r\n        emit Transfer(address(0), _to, _tokenId);\r\n    }\r\n\r\n    function _burn(address _owner, uint256 _tokenId) validNFToken(_tokenId) internal { \r\n        clearApproval(_tokenId);\r\n        removeNFToken(_owner, _tokenId);\r\n        emit Transfer(_owner, address(0), _tokenId);\r\n    }\r\n\r\n    function clearApproval(uint256 _tokenId) private {\r\n        if(idToApprovals[_tokenId] != 0) {\r\n            delete idToApprovals[_tokenId];\r\n        }\r\n    }\r\n\r\n    function removeNFToken(address _from, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == _from);\r\n        assert(ownerToNFTokenCount[_from] > 0);\r\n        ownerToNFTokenCount[_from] = ownerToNFTokenCount[_from] - 1;\r\n        delete idToOwner[_tokenId];\r\n    }\r\n\r\n    function addNFToken(address _to, uint256 _tokenId) internal {\r\n        require(idToOwner[_tokenId] == address(0));\r\n\r\n        idToOwner[_tokenId] = _to;\r\n        ownerToNFTokenCount[_to] = ownerToNFTokenCount[_to].add(1);\r\n    }\r\n}\r\n\r\n\r\ncontract NFTokenEnumerable is NFToken, ERC721Enumerable {\r\n\r\n    // Array of all NFT IDs.\r\n    uint256[] internal tokens;\r\n\r\n    // Mapping from token ID its index in global tokens array.\r\n    mapping(uint256 => uint256) internal idToIndex;\r\n\r\n    // Mapping from owner to list of owned NFT IDs.\r\n    mapping(address => uint256[]) internal ownerToIds;\r\n\r\n    // Mapping from NFT ID to its index in the owner tokens list.\r\n    mapping(uint256 => uint256) internal idToOwnerIndex;\r\n\r\n    constructor() public {\r\n        supportedInterfaces[0x780e9d63] = true; // ERC721Enumerable\r\n    }\r\n\r\n    function _mint(address _to, uint256 _tokenId) internal {\r\n        super._mint(_to, _tokenId);\r\n        uint256 length = tokens.push(_tokenId);\r\n        idToIndex[_tokenId] = length - 1;\r\n    }\r\n\r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        super._burn(_owner, _tokenId);\r\n        assert(tokens.length > 0);\r\n\r\n        uint256 tokenIndex = idToIndex[_tokenId];\r\n        // Sanity check. This could be removed in the future.\r\n        assert(tokens[tokenIndex] == _tokenId);\r\n        uint256 lastTokenIndex = tokens.length - 1;\r\n        uint256 lastToken = tokens[lastTokenIndex];\r\n\r\n        tokens[tokenIndex] = lastToken;\r\n\r\n        tokens.length--;\r\n        // Consider adding a conditional check for the last token in order to save GAS.\r\n        idToIndex[lastToken] = tokenIndex;\r\n        idToIndex[_tokenId] = 0;\r\n    }\r\n\r\n    function removeNFToken(address _from, uint256 _tokenId) internal\r\n    {\r\n        super.removeNFToken(_from, _tokenId);\r\n        assert(ownerToIds[_from].length > 0);\r\n\r\n        uint256 tokenToRemoveIndex = idToOwnerIndex[_tokenId];\r\n        uint256 lastTokenIndex = ownerToIds[_from].length - 1;\r\n        uint256 lastToken = ownerToIds[_from][lastTokenIndex];\r\n\r\n        ownerToIds[_from][tokenToRemoveIndex] = lastToken;\r\n\r\n        ownerToIds[_from].length--;\r\n        // Consider adding a conditional check for the last token in order to save GAS.\r\n        idToOwnerIndex[lastToken] = tokenToRemoveIndex;\r\n        idToOwnerIndex[_tokenId] = 0;\r\n    }\r\n\r\n    function addNFToken(address _to, uint256 _tokenId) internal {\r\n        super.addNFToken(_to, _tokenId);\r\n\r\n        uint256 length = ownerToIds[_to].push(_tokenId);\r\n        idToOwnerIndex[_tokenId] = length - 1;\r\n    }\r\n\r\n    function totalSupply() external view returns (uint256) {\r\n        return tokens.length;\r\n    }\r\n\r\n    function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n        require(_index < tokens.length);\r\n        // Sanity check. This could be removed in the future.\r\n        assert(idToIndex[tokens[_index]] == _index);\r\n        return tokens[_index];\r\n    }\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n        require(_index < ownerToIds[_owner].length);\r\n        return ownerToIds[_owner][_index];\r\n    }\r\n\r\n}\r\n\r\ncontract NFTStandard is NFTokenEnumerable, ERC721Metadata {\r\n    string internal nftName;\r\n    string internal nftSymbol;\r\n    \r\n    mapping (uint256 => string) internal idToUri;\r\n    \r\n    constructor(string _name, string _symbol) public {\r\n        nftName = _name;\r\n        nftSymbol = _symbol;\r\n        supportedInterfaces[0x5b5e139f] = true; // ERC721Metadata\r\n    }\r\n    \r\n    function _burn(address _owner, uint256 _tokenId) internal {\r\n        super._burn(_owner, _tokenId);\r\n        if (bytes(idToUri[_tokenId]).length != 0) {\r\n        delete idToUri[_tokenId];\r\n        }\r\n    }\r\n    \r\n    function _setTokenUri(uint256 _tokenId, string _uri) validNFToken(_tokenId) internal {\r\n        idToUri[_tokenId] = _uri;\r\n    }\r\n    \r\n    function name() external view returns (string _name) {\r\n        _name = nftName;\r\n    }\r\n    \r\n    function symbol() external view returns (string _symbol) {\r\n        _symbol = nftSymbol;\r\n    }\r\n    \r\n    function tokenURI(uint256 _tokenId) validNFToken(_tokenId) external view returns (string) {\r\n        return idToUri[_tokenId];\r\n    }\r\n}\r\n\r\ncontract BasicAccessControl {\r\n    address public owner;\r\n    // address[] public moderators;\r\n    uint16 public totalModerators = 0;\r\n    mapping (address => bool) public moderators;\r\n    bool public isMaintaining = false;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyModerators() {\r\n        require(msg.sender == owner || moderators[msg.sender] == true);\r\n        _;\r\n    }\r\n\r\n    modifier isActive {\r\n        require(!isMaintaining);\r\n        _;\r\n    }\r\n\r\n    function ChangeOwner(address _newOwner) onlyOwner public {\r\n        if (_newOwner != address(0)) {\r\n            owner = _newOwner;\r\n        }\r\n    }\r\n\r\n\r\n    function AddModerator(address _newModerator) onlyOwner public {\r\n        if (moderators[_newModerator] == false) {\r\n            moderators[_newModerator] = true;\r\n            totalModerators += 1;\r\n        }\r\n    }\r\n    \r\n    function RemoveModerator(address _oldModerator) onlyOwner public {\r\n        if (moderators[_oldModerator] == true) {\r\n            moderators[_oldModerator] = false;\r\n            totalModerators -= 1;\r\n        }\r\n    }\r\n\r\n    function UpdateMaintaining(bool _isMaintaining) onlyOwner public {\r\n        isMaintaining = _isMaintaining;\r\n    }\r\n}\r\n\r\ncontract CubegonNFT is NFTStandard(\"Cubegon\", \"CUBEGON\"), BasicAccessControl {\r\n    struct CubegonData {\r\n        bytes32 hash;\r\n        uint mId1;\r\n        uint amount1;\r\n        uint mId2;\r\n        uint amount2;\r\n        uint mId3;\r\n        uint amount3;\r\n        uint mId4;\r\n        uint amount4;\r\n        uint energyLimit;\r\n    }\r\n    mapping (uint => CubegonData) public cubegons;\r\n    mapping (bytes32 => uint) public hashCubegons;\r\n    uint public totalCubegon = 0;\r\n    \r\n    event UpdateCubegon(address indexed _from, uint256 indexed _tokenId);\r\n    \r\n    function setTokenURI(uint256 _tokenId, string _uri) onlyModerators external {\r\n        _setTokenUri(_tokenId, _uri);\r\n    }\r\n    \r\n    function mineCubegon(address _owner, bytes32 _ch, uint _mId1, uint _amount1, uint _mId2, uint _amount2, \r\n        uint _mId3, uint _amount3, uint _mId4, uint _amount4, uint _energyLimit) onlyModerators external returns(uint) {\r\n        if (hashCubegons[_ch] > 0) revert();\r\n        \r\n        totalCubegon += 1;\r\n        hashCubegons[_ch] = totalCubegon;\r\n        CubegonData storage cubegon = cubegons[totalCubegon];\r\n        cubegon.hash = _ch;\r\n        cubegon.mId1 = _mId1;\r\n        cubegon.amount1 = _amount1;\r\n        cubegon.mId2 = _mId2;\r\n        cubegon.amount2 = _amount2;\r\n        cubegon.mId3 = _mId3;\r\n        cubegon.amount3 = _amount3;\r\n        cubegon.mId4 = _mId4;\r\n        cubegon.amount4 = _amount4;\r\n        cubegon.energyLimit = _energyLimit;\r\n        _mint(_owner, totalCubegon);\r\n        return totalCubegon;\r\n    }\r\n    \r\n    function updateCubegon(address _owner, uint _tokenId, uint _energyLimit) onlyModerators external {\r\n        if (_tokenId == 0 || idToOwner[_tokenId] != _owner) revert();\r\n        CubegonData storage cubegon = cubegons[_tokenId];\r\n        if (cubegon.energyLimit == 0) revert();\r\n        cubegon.energyLimit = _energyLimit;\r\n    }\r\n    \r\n    function dismantleCubegon(address _owner, uint _tokenId) onlyModerators external returns(uint mId1, uint amount1, uint mId2, uint amount2,\r\n        uint mId3, uint amount3, uint mId4, uint amount4) {\r\n        if (_tokenId == 0 || idToOwner[_tokenId] != _owner) revert();\r\n        \r\n        CubegonData storage cubegon = cubegons[_tokenId];\r\n        cubegon.energyLimit = 0;\r\n        hashCubegons[cubegon.hash] = 0;\r\n        \r\n        _burn(_owner, _tokenId);\r\n        \r\n        return (cubegon.mId1, cubegon.amount1, cubegon.mId2, cubegon.amount2, cubegon.mId3, cubegon.amount3, cubegon.mId4, cubegon.amount4);\r\n    }\r\n    \r\n    // public\r\n    function getCubegonDataById(uint _tokenId) constant external returns(bytes32 hash, uint mId1, uint amount1, uint mId2, uint amount2,\r\n        uint mId3, uint amount3, uint mId4, uint amount4, uint energyLimit) {\r\n        CubegonData storage cubegon = cubegons[_tokenId];\r\n        hash = cubegon.hash;\r\n        mId1 = cubegon.mId1;\r\n        amount1 = cubegon.amount1;\r\n        mId2 = cubegon.mId2;\r\n        amount2 = cubegon.amount2;\r\n        mId3 = cubegon.mId3;\r\n        amount3 = cubegon.amount3;\r\n        mId4 = cubegon.mId4;\r\n        amount4 = cubegon.amount4;\r\n        energyLimit = cubegon.energyLimit;\r\n    }\r\n    \r\n    function getCubegonByHash(bytes32 _hash) constant external returns(uint tokenId, uint mId1, uint amount1, uint mId2, uint amount2,\r\n        uint mId3, uint amount3, uint mId4, uint amount4, uint energyLimit) {\r\n        tokenId = hashCubegons[_hash];\r\n        CubegonData storage cubegon = cubegons[tokenId];\r\n        mId1 = cubegon.mId1;\r\n        amount1 = cubegon.amount1;\r\n        mId2 = cubegon.mId2;\r\n        amount2 = cubegon.amount2;\r\n        mId3 = cubegon.mId3;\r\n        amount3 = cubegon.amount3;\r\n        mId4 = cubegon.mId4;\r\n        amount4 = cubegon.amount4;\r\n        energyLimit = cubegon.energyLimit;\r\n    }\r\n    \r\n    function getCubegonIdByHash(bytes32 _hash) constant external returns(uint) {\r\n        return hashCubegons[_hash];\r\n    }\r\n    \r\n    function getCubegonHashById(uint _tokenId) constant external returns(bytes32) {\r\n        if (idToOwner[_tokenId] == address(0))\r\n            return 0;\r\n        return cubegons[_tokenId].hash;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"_name\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"dismantleCubegon\",\"outputs\":[{\"name\":\"mId1\",\"type\":\"uint256\"},{\"name\":\"amount1\",\"type\":\"uint256\"},{\"name\":\"mId2\",\"type\":\"uint256\"},{\"name\":\"amount2\",\"type\":\"uint256\"},{\"name\":\"mId3\",\"type\":\"uint256\"},{\"name\":\"amount3\",\"type\":\"uint256\"},{\"name\":\"mId4\",\"type\":\"uint256\"},{\"name\":\"amount4\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"moderators\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_energyLimit\",\"type\":\"uint256\"}],\"name\":\"updateCubegon\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_isMaintaining\",\"type\":\"bool\"}],\"name\":\"UpdateMaintaining\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalModerators\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_ch\",\"type\":\"bytes32\"},{\"name\":\"_mId1\",\"type\":\"uint256\"},{\"name\":\"_amount1\",\"type\":\"uint256\"},{\"name\":\"_mId2\",\"type\":\"uint256\"},{\"name\":\"_amount2\",\"type\":\"uint256\"},{\"name\":\"_mId3\",\"type\":\"uint256\"},{\"name\":\"_amount3\",\"type\":\"uint256\"},{\"name\":\"_mId4\",\"type\":\"uint256\"},{\"name\":\"_amount4\",\"type\":\"uint256\"},{\"name\":\"_energyLimit\",\"type\":\"uint256\"}],\"name\":\"mineCubegon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newModerator\",\"type\":\"address\"}],\"name\":\"AddModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalCubegon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"hashCubegons\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cubegons\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"mId1\",\"type\":\"uint256\"},{\"name\":\"amount1\",\"type\":\"uint256\"},{\"name\":\"mId2\",\"type\":\"uint256\"},{\"name\":\"amount2\",\"type\":\"uint256\"},{\"name\":\"mId3\",\"type\":\"uint256\"},{\"name\":\"amount3\",\"type\":\"uint256\"},{\"name\":\"mId4\",\"type\":\"uint256\"},{\"name\":\"amount4\",\"type\":\"uint256\"},{\"name\":\"energyLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"_symbol\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCubegonHashById\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCubegonDataById\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"},{\"name\":\"mId1\",\"type\":\"uint256\"},{\"name\":\"amount1\",\"type\":\"uint256\"},{\"name\":\"mId2\",\"type\":\"uint256\"},{\"name\":\"amount2\",\"type\":\"uint256\"},{\"name\":\"mId3\",\"type\":\"uint256\"},{\"name\":\"amount3\",\"type\":\"uint256\"},{\"name\":\"mId4\",\"type\":\"uint256\"},{\"name\":\"amount4\",\"type\":\"uint256\"},{\"name\":\"energyLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getCubegonIdByHash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_oldModerator\",\"type\":\"address\"}],\"name\":\"RemoveModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_hash\",\"type\":\"bytes32\"}],\"name\":\"getCubegonByHash\",\"outputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"mId1\",\"type\":\"uint256\"},{\"name\":\"amount1\",\"type\":\"uint256\"},{\"name\":\"mId2\",\"type\":\"uint256\"},{\"name\":\"amount2\",\"type\":\"uint256\"},{\"name\":\"mId3\",\"type\":\"uint256\"},{\"name\":\"amount3\",\"type\":\"uint256\"},{\"name\":\"mId4\",\"type\":\"uint256\"},{\"name\":\"amount4\",\"type\":\"uint256\"},{\"name\":\"energyLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMaintaining\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"ChangeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"UpdateCubegon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"CubegonNFT","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2c3fef4f318c4d21118cb8da1dc2a43553f2523c017903b7be6fcd7552fe41a1"}]}