{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n// produced by the Solididy File Flattener (c) David Appleton 2018\r\n// contact : dave@akomba.com\r\n// released under Apache 2.0 licence\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    OwnershipTransferred(owner, newOwner);\r\n    owner = newOwner;\r\n  }\r\n\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender) public view returns (uint256);\r\n  function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    // SafeMath.sub will throw if there is not enough balance.\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256 balance) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    Unpause();\r\n  }\r\n}\r\n\r\ncontract Relay is Ownable {\r\n    address public licenseSalesContractAddress;\r\n    address public registryContractAddress;\r\n    address public apiRegistryContractAddress;\r\n    address public apiCallsContractAddress;\r\n    uint public version;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor, establishes ownership because contract is owned\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        version = 4;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens (just in case)\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Sets the license sales contract address\r\n    // ------------------------------------------------------------------------\r\n    function setLicenseSalesContractAddress(address newAddress) public onlyOwner {\r\n        require(newAddress != address(0));\r\n        licenseSalesContractAddress = newAddress;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Sets the registry contract address\r\n    // ------------------------------------------------------------------------\r\n    function setRegistryContractAddress(address newAddress) public onlyOwner {\r\n        require(newAddress != address(0));\r\n        registryContractAddress = newAddress;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Sets the api registry contract address\r\n    // ------------------------------------------------------------------------\r\n    function setApiRegistryContractAddress(address newAddress) public onlyOwner {\r\n        require(newAddress != address(0));\r\n        apiRegistryContractAddress = newAddress;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Sets the api calls contract address\r\n    // ------------------------------------------------------------------------\r\n    function setApiCallsContractAddress(address newAddress) public onlyOwner {\r\n        require(newAddress != address(0));\r\n        apiCallsContractAddress = newAddress;\r\n    }\r\n}\r\ncontract APIRegistry is Ownable {\r\n\r\n    struct APIForSale {\r\n        uint pricePerCall;\r\n        bytes32 sellerUsername;\r\n        bytes32 apiName;\r\n        address sellerAddress;\r\n        string hostname;\r\n        string docsUrl;\r\n    }\r\n\r\n    mapping(string => uint) internal apiIds;\r\n    mapping(uint => APIForSale) public apis;\r\n\r\n    uint public numApis;\r\n    uint public version;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor, establishes ownership because contract is owned\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        numApis = 0;\r\n        version = 1;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens (just in case)\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Lets a user list an API to sell\r\n    // ------------------------------------------------------------------------\r\n    function listApi(uint pricePerCall, bytes32 sellerUsername, bytes32 apiName, string hostname, string docsUrl) public {\r\n        // make sure input params are valid\r\n        require(pricePerCall != 0 && sellerUsername != \"\" && apiName != \"\" && bytes(hostname).length != 0);\r\n        \r\n        // make sure the name isn't already taken\r\n        require(apiIds[hostname] == 0);\r\n\r\n        numApis += 1;\r\n        apiIds[hostname] = numApis;\r\n\r\n        APIForSale storage api = apis[numApis];\r\n\r\n        api.pricePerCall = pricePerCall;\r\n        api.sellerUsername = sellerUsername;\r\n        api.apiName = apiName;\r\n        api.sellerAddress = msg.sender;\r\n        api.hostname = hostname;\r\n        api.docsUrl = docsUrl;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the ID number of an API given it's hostname\r\n    // ------------------------------------------------------------------------\r\n    function getApiId(string hostname) public view returns (uint) {\r\n        return apiIds[hostname];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get info stored for the API but without the dynamic members, because solidity can't return dynamics to other smart contracts yet\r\n    // ------------------------------------------------------------------------\r\n    function getApiByIdWithoutDynamics(\r\n        uint apiId\r\n    ) \r\n        public\r\n        view \r\n        returns (\r\n            uint pricePerCall, \r\n            bytes32 sellerUsername,\r\n            bytes32 apiName, \r\n            address sellerAddress\r\n        ) \r\n    {\r\n        APIForSale storage api = apis[apiId];\r\n\r\n        pricePerCall = api.pricePerCall;\r\n        sellerUsername = api.sellerUsername;\r\n        apiName = api.apiName;\r\n        sellerAddress = api.sellerAddress;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get info stored for an API by id\r\n    // ------------------------------------------------------------------------\r\n    function getApiById(\r\n        uint apiId\r\n    ) \r\n        public \r\n        view \r\n        returns (\r\n            uint pricePerCall, \r\n            bytes32 sellerUsername, \r\n            bytes32 apiName, \r\n            address sellerAddress, \r\n            string hostname, \r\n            string docsUrl\r\n        ) \r\n    {\r\n        APIForSale storage api = apis[apiId];\r\n\r\n        pricePerCall = api.pricePerCall;\r\n        sellerUsername = api.sellerUsername;\r\n        apiName = api.apiName;\r\n        sellerAddress = api.sellerAddress;\r\n        hostname = api.hostname;\r\n        docsUrl = api.docsUrl;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get info stored for an API by hostname\r\n    // ------------------------------------------------------------------------\r\n    function getApiByName(\r\n        string _hostname\r\n    ) \r\n        public \r\n        view \r\n        returns (\r\n            uint pricePerCall, \r\n            bytes32 sellerUsername, \r\n            bytes32 apiName, \r\n            address sellerAddress, \r\n            string hostname, \r\n            string docsUrl\r\n        ) \r\n    {\r\n        uint apiId = apiIds[_hostname];\r\n        if (apiId == 0) {\r\n            return;\r\n        }\r\n        APIForSale storage api = apis[apiId];\r\n\r\n        pricePerCall = api.pricePerCall;\r\n        sellerUsername = api.sellerUsername;\r\n        apiName = api.apiName;\r\n        sellerAddress = api.sellerAddress;\r\n        hostname = api.hostname;\r\n        docsUrl = api.docsUrl;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Edit an API listing\r\n    // ------------------------------------------------------------------------\r\n    function editApi(uint apiId, uint pricePerCall, address sellerAddress, string docsUrl) public {\r\n        require(apiId != 0 && pricePerCall != 0 && sellerAddress != address(0));\r\n\r\n        APIForSale storage api = apis[apiId];\r\n\r\n        // prevent editing an empty api (effectively listing an api)\r\n        require(\r\n            api.pricePerCall != 0 && api.sellerUsername != \"\" && api.apiName != \"\" &&  bytes(api.hostname).length != 0 && api.sellerAddress != address(0)\r\n        );\r\n\r\n        // require that sender is the original api lister, or the contract owner\r\n        // the contract owner clause lets us recover a api listing if a dev loses access to their privkey\r\n        require(msg.sender == api.sellerAddress || msg.sender == owner);\r\n\r\n        api.pricePerCall = pricePerCall;\r\n        api.sellerAddress = sellerAddress;\r\n        api.docsUrl = docsUrl;\r\n    }\r\n}\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   *\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(address _owner, address _spender) public view returns (uint256) {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n    allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   *\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n    uint oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\ncontract DeconetToken is StandardToken, Ownable, Pausable {\r\n    // token naming etc\r\n    string public constant symbol = \"DCO\";\r\n    string public constant name = \"Deconet Token\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    // contract version\r\n    uint public constant version = 4;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        // 1 billion tokens (1,000,000,000)\r\n        totalSupply_ = 1000000000 * 10**uint(decimals);\r\n\r\n        // transfer initial supply to msg.sender who is also contract owner\r\n        balances[msg.sender] = totalSupply_;\r\n        Transfer(address(0), msg.sender, totalSupply_);\r\n\r\n        // pause contract until we're ready to allow transfers\r\n        paused = true;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens (just in case)\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Modifier to make a function callable only when called by the contract owner\r\n    // or if the contract is not paused.\r\n    // ------------------------------------------------------------------------\r\n    modifier whenOwnerOrNotPaused() {\r\n        require(msg.sender == owner || !paused);\r\n        _;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier\r\n    // ------------------------------------------------------------------------\r\n    function transfer(address _to, uint256 _value) public whenOwnerOrNotPaused returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier\r\n    // ------------------------------------------------------------------------\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenOwnerOrNotPaused returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier\r\n    // ------------------------------------------------------------------------\r\n    function approve(address _spender, uint256 _value) public whenOwnerOrNotPaused returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier\r\n    // ------------------------------------------------------------------------\r\n    function increaseApproval(address _spender, uint _addedValue) public whenOwnerOrNotPaused returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // overloaded openzepplin method to add whenOwnerOrNotPaused modifier\r\n    // ------------------------------------------------------------------------\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenOwnerOrNotPaused returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n}\r\n\r\ncontract APICalls is Ownable {\r\n    using SafeMath for uint;\r\n\r\n    // the amount rewarded to a seller for selling api calls per buyer\r\n    uint public tokenReward;\r\n\r\n    // the fee this contract takes from every sale.  expressed as percent.  so a value of 3 indicates a 3% txn fee\r\n    uint public saleFee;\r\n\r\n    // if the buyer has never paid, we need to pick a date for when they probably started using the API.  \r\n    // This is in seconds and will be subtracted from \"now\"\r\n    uint public defaultBuyerLastPaidAt;\r\n\r\n    // address of the relay contract which holds the address of the registry contract.\r\n    address public relayContractAddress;\r\n\r\n    // the token address\r\n    address public tokenContractAddress;\r\n\r\n    // this contract version\r\n    uint public version;\r\n\r\n    // the amount that can be safely withdrawn from the contract\r\n    uint public safeWithdrawAmount;\r\n\r\n    // the address that is authorized to withdraw eth\r\n    address private withdrawAddress;\r\n\r\n    // the address that is authorized to report usage on behalf of deconet\r\n    address private usageReportingAddress;\r\n\r\n    // maps apiId to a APIBalance which stores how much each address owes\r\n    mapping(uint => APIBalance) internal owed;\r\n\r\n    // maps buyer addresses to whether or not accounts are overdrafted and more\r\n    mapping(address => BuyerInfo) internal buyers;\r\n\r\n    // Stores amounts owed and when buyers last paid on a per-api and per-user basis\r\n    struct APIBalance {\r\n        // maps address -> amount owed in wei\r\n        mapping(address => uint) amounts;\r\n        // basically a list of keys for the above map\r\n        address[] nonzeroAddresses;\r\n        // maps address -> tiemstamp of when buyer last paid\r\n        mapping(address => uint) buyerLastPaidAt;\r\n    }\r\n\r\n    // Stores basic info about a buyer including their lifetime stats and reputation info\r\n    struct BuyerInfo {\r\n        // whether or not the account is overdrafted or not\r\n        bool overdrafted;\r\n        // total number of overdrafts, ever\r\n        uint lifetimeOverdraftCount;\r\n        // credits on file with this contract (wei)\r\n        uint credits;\r\n        // total amount of credits used / spent, ever (wei)\r\n        uint lifetimeCreditsUsed;\r\n        // maps apiId to approved spending balance for each API per second.\r\n        mapping(uint => uint) approvedAmounts;\r\n        // maps apiId to whether or not the user has exceeded their approved amount\r\n        mapping(uint => bool) exceededApprovedAmount;\r\n        // total number of times exceededApprovedAmount has happened\r\n        uint lifetimeExceededApprovalAmountCount;\r\n    }\r\n\r\n    // Logged when API call usage is reported\r\n    event LogAPICallsMade(\r\n        uint apiId,\r\n        address indexed sellerAddress,\r\n        address indexed buyerAddress,\r\n        uint pricePerCall,\r\n        uint numCalls,\r\n        uint totalPrice,\r\n        address reportingAddress\r\n    );\r\n\r\n    // Logged when seller is paid for API calls\r\n    event LogAPICallsPaid(\r\n        uint apiId,\r\n        address indexed sellerAddress,\r\n        uint totalPrice,\r\n        uint rewardedTokens,\r\n        uint networkFee\r\n    );\r\n\r\n    // Logged when the credits from a specific buyer are spent on a specific api\r\n    event LogSpendCredits(\r\n        address indexed buyerAddress,\r\n        uint apiId,\r\n        uint amount,\r\n        bool causedAnOverdraft\r\n    );\r\n\r\n    // Logged when a buyer deposits credits\r\n    event LogDepositCredits(\r\n        address indexed buyerAddress,\r\n        uint amount\r\n    );\r\n\r\n    // Logged whena  buyer withdraws credits\r\n    event LogWithdrawCredits(\r\n        address indexed buyerAddress,\r\n        uint amount\r\n    );\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Constructor\r\n    // ------------------------------------------------------------------------\r\n    constructor() public {\r\n        version = 1;\r\n\r\n        // default token reward of 100 tokens.  \r\n        // token has 18 decimal places so that's why 100 * 10^18\r\n        tokenReward = 100 * 10**18;\r\n\r\n        // default saleFee of 10%\r\n        saleFee = 10;\r\n\r\n        // 604,800 seconds = 1 week.  this is the default for when a user started using an api (1 week ago)\r\n        defaultBuyerLastPaidAt = 604800;\r\n\r\n        // default withdrawAddress is owner\r\n        withdrawAddress = msg.sender;\r\n        usageReportingAddress = msg.sender;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any accidentally sent ERC20 tokens (just in case)\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) {\r\n        return ERC20(tokenAddress).transfer(owner, tokens);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can transfer out any ETH\r\n    // ------------------------------------------------------------------------\r\n    function withdrawEther(uint amount) public {\r\n        require(msg.sender == withdrawAddress);\r\n        require(amount <= this.balance);\r\n        require(amount <= safeWithdrawAmount);\r\n        safeWithdrawAmount = safeWithdrawAmount.sub(amount);\r\n        withdrawAddress.transfer(amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can set address of who can withdraw\r\n    // ------------------------------------------------------------------------\r\n    function setWithdrawAddress(address _withdrawAddress) public onlyOwner {\r\n        require(_withdrawAddress != address(0));\r\n        withdrawAddress = _withdrawAddress;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can set address of who can report usage\r\n    // ------------------------------------------------------------------------\r\n    function setUsageReportingAddress(address _usageReportingAddress) public onlyOwner {\r\n        require(_usageReportingAddress != address(0));\r\n        usageReportingAddress = _usageReportingAddress;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can set address of relay contract\r\n    // ------------------------------------------------------------------------\r\n    function setRelayContractAddress(address _relayContractAddress) public onlyOwner {\r\n        require(_relayContractAddress != address(0));\r\n        relayContractAddress = _relayContractAddress;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can set address of token contract\r\n    // ------------------------------------------------------------------------\r\n    function setTokenContractAddress(address _tokenContractAddress) public onlyOwner {\r\n        require(_tokenContractAddress != address(0));\r\n        tokenContractAddress = _tokenContractAddress;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can set token reward\r\n    // ------------------------------------------------------------------------\r\n    function setTokenReward(uint _tokenReward) public onlyOwner {\r\n        tokenReward = _tokenReward;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can set the sale fee\r\n    // ------------------------------------------------------------------------\r\n    function setSaleFee(uint _saleFee) public onlyOwner {\r\n        saleFee = _saleFee;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Owner can set the default buyer last paid at\r\n    // ------------------------------------------------------------------------\r\n    function setDefaultBuyerLastPaidAt(uint _defaultBuyerLastPaidAt) public onlyOwner {\r\n        defaultBuyerLastPaidAt = _defaultBuyerLastPaidAt;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // The API owner or the authorized deconet usage reporting address may report usage\r\n    // ------------------------------------------------------------------------\r\n    function reportUsage(uint apiId, uint numCalls, address buyerAddress) public {\r\n        // look up the registry address from relay contract\r\n        Relay relay = Relay(relayContractAddress);\r\n        address apiRegistryAddress = relay.apiRegistryContractAddress();\r\n\r\n        // get the module info from registry\r\n        APIRegistry apiRegistry = APIRegistry(apiRegistryAddress);\r\n\r\n        uint pricePerCall;\r\n        bytes32 sellerUsername;\r\n        bytes32 apiName;\r\n        address sellerAddress;\r\n\r\n        (pricePerCall, sellerUsername, apiName, sellerAddress) = apiRegistry.getApiByIdWithoutDynamics(apiId);\r\n\r\n        // make sure the caller is either the api owner or the deconet reporting address\r\n        require(sellerAddress != address(0));\r\n        require(msg.sender == sellerAddress || msg.sender == usageReportingAddress);\r\n\r\n        // make sure the api is actually valid\r\n        require(sellerUsername != \"\" && apiName != \"\");\r\n\r\n        uint totalPrice = pricePerCall.mul(numCalls);\r\n\r\n        require(totalPrice > 0);\r\n\r\n        APIBalance storage apiBalance = owed[apiId];\r\n\r\n        if (apiBalance.amounts[buyerAddress] == 0) {\r\n            // add buyerAddress to list of addresses with nonzero balance for this api\r\n            apiBalance.nonzeroAddresses.push(buyerAddress);\r\n        }\r\n\r\n        apiBalance.amounts[buyerAddress] = apiBalance.amounts[buyerAddress].add(totalPrice);\r\n\r\n        emit LogAPICallsMade(\r\n            apiId,\r\n            sellerAddress,\r\n            buyerAddress,\r\n            pricePerCall,\r\n            numCalls,\r\n            totalPrice,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Function to pay the seller for a single API buyer.  \r\n    // Settles reported usage according to credits and approved amounts.\r\n    // ------------------------------------------------------------------------\r\n    function paySellerForBuyer(uint apiId, address buyerAddress) public {\r\n        // look up the registry address from relay contract\r\n        Relay relay = Relay(relayContractAddress);\r\n        address apiRegistryAddress = relay.apiRegistryContractAddress();\r\n\r\n        // get the module info from registry\r\n        APIRegistry apiRegistry = APIRegistry(apiRegistryAddress);\r\n\r\n        uint pricePerCall;\r\n        bytes32 sellerUsername;\r\n        bytes32 apiName;\r\n        address sellerAddress;\r\n\r\n        (pricePerCall, sellerUsername, apiName, sellerAddress) = apiRegistry.getApiByIdWithoutDynamics(apiId);\r\n\r\n        // make sure it's a legit real api\r\n        require(pricePerCall != 0 && sellerUsername != \"\" && apiName != \"\" && sellerAddress != address(0));\r\n\r\n        uint buyerPaid = processSalesForSingleBuyer(apiId, buyerAddress);\r\n\r\n        if (buyerPaid == 0) {\r\n            return; // buyer paid nothing, we are done.\r\n        }\r\n\r\n        // calculate fee and payout\r\n        uint fee = buyerPaid.mul(saleFee).div(100);\r\n        uint payout = buyerPaid.sub(fee);\r\n\r\n        // log that we stored the fee so we know we can take it out later\r\n        safeWithdrawAmount += fee;\r\n\r\n        emit LogAPICallsPaid(\r\n            apiId,\r\n            sellerAddress,\r\n            buyerPaid,\r\n            tokenReward,\r\n            fee\r\n        );\r\n\r\n        // give seller some tokens for the sale\r\n        rewardTokens(sellerAddress, tokenReward);\r\n\r\n        // transfer seller the eth\r\n        sellerAddress.transfer(payout);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Function to pay the seller for all buyers with nonzero balance.  \r\n    // Settles reported usage according to credits and approved amounts.\r\n    // ------------------------------------------------------------------------\r\n    function paySeller(uint apiId) public {\r\n        // look up the registry address from relay contract\r\n        Relay relay = Relay(relayContractAddress);\r\n        address apiRegistryAddress = relay.apiRegistryContractAddress();\r\n\r\n        // get the module info from registry\r\n        APIRegistry apiRegistry = APIRegistry(apiRegistryAddress);\r\n\r\n        uint pricePerCall;\r\n        bytes32 sellerUsername;\r\n        bytes32 apiName;\r\n        address sellerAddress;\r\n\r\n        (pricePerCall, sellerUsername, apiName, sellerAddress) = apiRegistry.getApiByIdWithoutDynamics(apiId);\r\n\r\n        // make sure it's a legit real api\r\n        require(pricePerCall != 0 && sellerUsername != \"\" && apiName != \"\" && sellerAddress != address(0));\r\n\r\n        // calculate totalPayable for the api\r\n        uint totalPayable = 0;\r\n        uint totalBuyers = 0;\r\n        (totalPayable, totalBuyers) = processSalesForAllBuyers(apiId);\r\n\r\n        if (totalPayable == 0) {\r\n            return; // if there's nothing to pay, we are done here.\r\n        }\r\n\r\n        // calculate fee and payout\r\n        uint fee = totalPayable.mul(saleFee).div(100);\r\n        uint payout = totalPayable.sub(fee);\r\n\r\n        // log that we stored the fee so we know we can take it out later\r\n        safeWithdrawAmount += fee;\r\n\r\n        // we reward token reward on a \"per buyer\" basis.  so multiply the reward to give by the number of actual buyers\r\n        uint totalTokenReward = tokenReward.mul(totalBuyers);\r\n\r\n        emit LogAPICallsPaid(\r\n            apiId,\r\n            sellerAddress,\r\n            totalPayable,\r\n            totalTokenReward,\r\n            fee\r\n        );\r\n\r\n        // give seller some tokens for the sale\r\n        rewardTokens(sellerAddress, totalTokenReward);\r\n\r\n        // transfer seller the eth\r\n        sellerAddress.transfer(payout);\r\n    } \r\n\r\n    // ------------------------------------------------------------------------\r\n    // Let anyone see when the buyer last paid for a given API\r\n    // ------------------------------------------------------------------------\r\n    function buyerLastPaidAt(uint apiId, address buyerAddress) public view returns (uint) {\r\n        APIBalance storage apiBalance = owed[apiId];\r\n        return apiBalance.buyerLastPaidAt[buyerAddress];\r\n    }   \r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get buyer info struct for a specific buyer address\r\n    // ------------------------------------------------------------------------\r\n    function buyerInfoOf(address addr) \r\n        public \r\n        view \r\n        returns (\r\n            bool overdrafted, \r\n            uint lifetimeOverdraftCount, \r\n            uint credits, \r\n            uint lifetimeCreditsUsed, \r\n            uint lifetimeExceededApprovalAmountCount\r\n        ) \r\n    {\r\n        BuyerInfo storage buyer = buyers[addr];\r\n        overdrafted = buyer.overdrafted;\r\n        lifetimeOverdraftCount = buyer.lifetimeOverdraftCount;\r\n        credits = buyer.credits;\r\n        lifetimeCreditsUsed = buyer.lifetimeCreditsUsed;\r\n        lifetimeExceededApprovalAmountCount = buyer.lifetimeExceededApprovalAmountCount;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Gets the credits balance of a buyer\r\n    // ------------------------------------------------------------------------\r\n    function creditsBalanceOf(address addr) public view returns (uint) {\r\n        BuyerInfo storage buyer = buyers[addr];\r\n        return buyer.credits;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Lets a buyer add credits\r\n    // ------------------------------------------------------------------------\r\n    function addCredits(address to) public payable {\r\n        BuyerInfo storage buyer = buyers[to];\r\n        buyer.credits = buyer.credits.add(msg.value);\r\n        emit LogDepositCredits(to, msg.value);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Lets a buyer withdraw credits\r\n    // ------------------------------------------------------------------------\r\n    function withdrawCredits(uint amount) public {\r\n        BuyerInfo storage buyer = buyers[msg.sender];\r\n        require(buyer.credits >= amount);\r\n        buyer.credits = buyer.credits.sub(amount);\r\n        msg.sender.transfer(amount);\r\n        emit LogWithdrawCredits(msg.sender, amount);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the length of array of buyers who have a nonzero balance for a given API\r\n    // ------------------------------------------------------------------------\r\n    function nonzeroAddressesElementForApi(uint apiId, uint index) public view returns (address) {\r\n        APIBalance storage apiBalance = owed[apiId];\r\n        return apiBalance.nonzeroAddresses[index];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get an element from the array of buyers who have a nonzero balance for a given API\r\n    // ------------------------------------------------------------------------\r\n    function nonzeroAddressesLengthForApi(uint apiId) public view returns (uint) {\r\n        APIBalance storage apiBalance = owed[apiId];\r\n        return apiBalance.nonzeroAddresses.length;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the amount owed for a specific api for a specific buyer\r\n    // ------------------------------------------------------------------------\r\n    function amountOwedForApiForBuyer(uint apiId, address buyerAddress) public view returns (uint) {\r\n        APIBalance storage apiBalance = owed[apiId];\r\n        return apiBalance.amounts[buyerAddress];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Get the total owed for an entire api for all nonzero buyers\r\n    // ------------------------------------------------------------------------\r\n    function totalOwedForApi(uint apiId) public view returns (uint) {\r\n        APIBalance storage apiBalance = owed[apiId];\r\n\r\n        uint totalOwed = 0;\r\n        for (uint i = 0; i < apiBalance.nonzeroAddresses.length; i++) {\r\n            address buyerAddress = apiBalance.nonzeroAddresses[i];\r\n            uint buyerOwes = apiBalance.amounts[buyerAddress];\r\n            totalOwed = totalOwed.add(buyerOwes);\r\n        }\r\n\r\n        return totalOwed;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Gets the amount of wei per second a buyer has approved for a specific api\r\n    // ------------------------------------------------------------------------\r\n    function approvedAmount(uint apiId, address buyerAddress) public view returns (uint) {\r\n        return buyers[buyerAddress].approvedAmounts[apiId];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Let the buyer set an approved amount of wei per second for a specific api\r\n    // ------------------------------------------------------------------------\r\n    function approveAmount(uint apiId, address buyerAddress, uint newAmount) public {\r\n        require(buyerAddress != address(0) && apiId != 0);\r\n\r\n        // only the buyer or the usage reporing system can change the buyers approval amount\r\n        require(msg.sender == buyerAddress || msg.sender == usageReportingAddress);\r\n\r\n        BuyerInfo storage buyer = buyers[buyerAddress];\r\n        buyer.approvedAmounts[apiId] = newAmount;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // function to let the buyer set their approved amount of wei per second for an api\r\n    // this function also lets the buyer set the time they last paid for an API if they've never paid that API before.  \r\n    // this is important because the total amount approved for a given transaction is based on a wei per second spending limit\r\n    // but the smart contract doesn't know when the buyer started using the API\r\n    // so with this function, a buyer can et the time they first used the API and the approved amount calculations will be accurate when the seller requests payment.\r\n    // ------------------------------------------------------------------------\r\n    function approveAmountAndSetFirstUseTime(\r\n        uint apiId, \r\n        address buyerAddress, \r\n        uint newAmount, \r\n        uint firstUseTime\r\n    ) \r\n        public \r\n    {\r\n        require(buyerAddress != address(0) && apiId != 0);\r\n\r\n        // only the buyer or the usage reporing system can change the buyers approval amount\r\n        require(msg.sender == buyerAddress || msg.sender == usageReportingAddress);\r\n\r\n        APIBalance storage apiBalance = owed[apiId];\r\n        require(apiBalance.buyerLastPaidAt[buyerAddress] == 0);\r\n\r\n        apiBalance.buyerLastPaidAt[buyerAddress] = firstUseTime;\r\n        \r\n        BuyerInfo storage buyer = buyers[buyerAddress];\r\n        buyer.approvedAmounts[apiId] = newAmount;\r\n\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Gets whether or not a buyer exceeded their approved amount in the last seller payout\r\n    // ------------------------------------------------------------------------\r\n    function buyerExceededApprovedAmount(uint apiId, address buyerAddress) public view returns (bool) {\r\n        return buyers[buyerAddress].exceededApprovedAmount[apiId];\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Reward user with tokens IF the contract has them in it's allowance\r\n    // ------------------------------------------------------------------------\r\n    function rewardTokens(address toReward, uint amount) private {\r\n        DeconetToken token = DeconetToken(tokenContractAddress);\r\n        address tokenOwner = token.owner();\r\n\r\n        // check balance of tokenOwner\r\n        uint tokenOwnerBalance = token.balanceOf(tokenOwner);\r\n        uint tokenOwnerAllowance = token.allowance(tokenOwner, address(this));\r\n        if (tokenOwnerBalance >= amount && tokenOwnerAllowance >= amount) {\r\n            token.transferFrom(tokenOwner, toReward, amount);\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Process and settle balances for a single buyer for a specific api\r\n    // ------------------------------------------------------------------------\r\n    function processSalesForSingleBuyer(uint apiId, address buyerAddress) private returns (uint) {\r\n        APIBalance storage apiBalance = owed[apiId];\r\n\r\n        uint buyerOwes = apiBalance.amounts[buyerAddress];\r\n        uint buyerLastPaidAtTime = apiBalance.buyerLastPaidAt[buyerAddress];\r\n        if (buyerLastPaidAtTime == 0) {\r\n            // if buyer has never paid, assume they paid a week ago.  or whatever now - defaultBuyerLastPaidAt is.\r\n            buyerLastPaidAtTime = now - defaultBuyerLastPaidAt; // default is 604,800 = 7 days of seconds\r\n        }\r\n        uint elapsedSecondsSinceLastPayout = now - buyerLastPaidAtTime;\r\n        uint buyerNowOwes = buyerOwes;\r\n        uint buyerPaid = 0;\r\n        bool overdrafted = false;\r\n\r\n        (buyerPaid, overdrafted) = chargeBuyer(apiId, buyerAddress, elapsedSecondsSinceLastPayout, buyerOwes);\r\n\r\n        buyerNowOwes = buyerOwes.sub(buyerPaid);\r\n        apiBalance.amounts[buyerAddress] = buyerNowOwes;\r\n\r\n        // if the buyer now owes zero, then remove them from nonzeroAddresses\r\n        if (buyerNowOwes != 0) {\r\n            removeAddressFromNonzeroBalancesArray(apiId, buyerAddress);\r\n        }\r\n        // if the buyer paid nothing, we are done here.\r\n        if (buyerPaid == 0) {\r\n            return 0;\r\n        }\r\n\r\n        // log the event\r\n        emit LogSpendCredits(buyerAddress, apiId, buyerPaid, overdrafted);\r\n\r\n        // log that they paid\r\n        apiBalance.buyerLastPaidAt[buyerAddress] = now;\r\n        \r\n        return buyerPaid;\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Process and settle balances for all buyers with a nonzero balance for a specific api\r\n    // ------------------------------------------------------------------------\r\n    function processSalesForAllBuyers(uint apiId) private returns (uint totalPayable, uint totalBuyers) {\r\n        APIBalance storage apiBalance = owed[apiId];\r\n\r\n        uint currentTime = now;\r\n        address[] memory oldNonzeroAddresses = apiBalance.nonzeroAddresses;\r\n        apiBalance.nonzeroAddresses = new address[](0);\r\n\r\n        for (uint i = 0; i < oldNonzeroAddresses.length; i++) {\r\n            address buyerAddress = oldNonzeroAddresses[i];\r\n            uint buyerOwes = apiBalance.amounts[buyerAddress];\r\n            uint buyerLastPaidAtTime = apiBalance.buyerLastPaidAt[buyerAddress];\r\n            if (buyerLastPaidAtTime == 0) {\r\n                // if buyer has never paid, assume they paid a week ago.  or whatever now - defaultBuyerLastPaidAt is.\r\n                buyerLastPaidAtTime = now - defaultBuyerLastPaidAt; // default is 604,800 = 7 days of seconds\r\n            }\r\n            uint elapsedSecondsSinceLastPayout = currentTime - buyerLastPaidAtTime;\r\n            uint buyerNowOwes = buyerOwes;\r\n            uint buyerPaid = 0;\r\n            bool overdrafted = false;\r\n\r\n            (buyerPaid, overdrafted) = chargeBuyer(apiId, buyerAddress, elapsedSecondsSinceLastPayout, buyerOwes);\r\n\r\n            totalPayable = totalPayable.add(buyerPaid);\r\n            buyerNowOwes = buyerOwes.sub(buyerPaid);\r\n            apiBalance.amounts[buyerAddress] = buyerNowOwes;\r\n\r\n            // if the buyer still owes something, make sure we keep them in the nonzeroAddresses array\r\n            if (buyerNowOwes != 0) {\r\n                apiBalance.nonzeroAddresses.push(buyerAddress);\r\n            }\r\n            // if the buyer paid more than 0, log the spend.\r\n            if (buyerPaid != 0) {\r\n                // log the event\r\n                emit LogSpendCredits(buyerAddress, apiId, buyerPaid, overdrafted);\r\n\r\n                // log that they paid\r\n                apiBalance.buyerLastPaidAt[buyerAddress] = now;\r\n\r\n                // add to total buyer count\r\n                totalBuyers += 1;\r\n            }\r\n        }\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // given a specific buyer, api, and the amount they owe, we need to figure out how much to pay\r\n    // the final amount paid is based on the chart below:\r\n    // if credits >= approved >= owed then pay owed\r\n    // if credits >= owed > approved then pay approved and mark as exceeded approved amount\r\n    // if owed > credits >= approved then pay approved and mark as overdrafted\r\n    // if owed > approved > credits then pay credits and mark as overdrafted\r\n    // ------------------------------------------------------------------------\r\n    function chargeBuyer(\r\n        uint apiId, \r\n        address buyerAddress, \r\n        uint elapsedSecondsSinceLastPayout, \r\n        uint buyerOwes\r\n    ) \r\n        private \r\n        returns (\r\n            uint paid, \r\n            bool overdrafted\r\n        ) \r\n    {\r\n        BuyerInfo storage buyer = buyers[buyerAddress];\r\n        uint approvedAmountPerSecond = buyer.approvedAmounts[apiId];\r\n        uint approvedAmountSinceLastPayout = approvedAmountPerSecond.mul(elapsedSecondsSinceLastPayout);\r\n        \r\n        // do we have the credits to pay owed?\r\n        if (buyer.credits >= buyerOwes) {\r\n            // yay, buyer can pay their debits\r\n            overdrafted = false;\r\n            buyer.overdrafted = false;\r\n\r\n            // has buyer approved enough to pay what they owe?\r\n            if (approvedAmountSinceLastPayout >= buyerOwes) {\r\n                // approved is greater than owed.  \r\n                // mark as not exceeded approved amount\r\n                buyer.exceededApprovedAmount[apiId] = false;\r\n\r\n                // we can pay the entire debt\r\n                paid = buyerOwes;\r\n\r\n            } else {\r\n                // they have no approved enough\r\n                // mark as exceeded\r\n                buyer.exceededApprovedAmount[apiId] = true;\r\n                buyer.lifetimeExceededApprovalAmountCount += 1;\r\n\r\n                // we can only pay the approved portion of the debt\r\n                paid = approvedAmountSinceLastPayout;\r\n            }\r\n        } else {\r\n            // buyer spent more than they have.  mark as overdrafted\r\n            overdrafted = true;\r\n            buyer.overdrafted = true;\r\n            buyer.lifetimeOverdraftCount += 1;\r\n\r\n            // does buyer have more credits than the amount they've approved?\r\n            if (buyer.credits >= approvedAmountSinceLastPayout) {\r\n                // they have enough credits to pay approvedAmountSinceLastPayout, so pay that\r\n                paid = approvedAmountSinceLastPayout;\r\n\r\n            } else {\r\n                // the don't have enough credits to pay approvedAmountSinceLastPayout\r\n                // so just pay whatever credits they have\r\n                paid = buyer.credits;\r\n            }\r\n        }\r\n\r\n        buyer.credits = buyer.credits.sub(paid);\r\n        buyer.lifetimeCreditsUsed = buyer.lifetimeCreditsUsed.add(paid);\r\n    }\r\n\r\n    function removeAddressFromNonzeroBalancesArray(uint apiId, address toRemove) private {\r\n        APIBalance storage apiBalance = owed[apiId];\r\n\r\n        bool foundElement = false;\r\n\r\n        for (uint i = 0; i < apiBalance.nonzeroAddresses.length-1; i++) {\r\n            if (apiBalance.nonzeroAddresses[i] == toRemove) {\r\n                foundElement = true;\r\n            }\r\n            if (foundElement == true) {\r\n                apiBalance.nonzeroAddresses[i] = apiBalance.nonzeroAddresses[i+1];\r\n            }\r\n        }\r\n        if (foundElement == true) {\r\n            apiBalance.nonzeroAddresses.length--;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"safeWithdrawAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawCredits\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"paySellerForBuyer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"buyerLastPaidAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_relayContractAddress\",\"type\":\"address\"}],\"name\":\"setRelayContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"nonzeroAddressesElementForApi\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_withdrawAddress\",\"type\":\"address\"}],\"name\":\"setWithdrawAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"buyerInfoOf\",\"outputs\":[{\"name\":\"overdrafted\",\"type\":\"bool\"},{\"name\":\"lifetimeOverdraftCount\",\"type\":\"uint256\"},{\"name\":\"credits\",\"type\":\"uint256\"},{\"name\":\"lifetimeCreditsUsed\",\"type\":\"uint256\"},{\"name\":\"lifetimeExceededApprovalAmountCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"newAmount\",\"type\":\"uint256\"},{\"name\":\"firstUseTime\",\"type\":\"uint256\"}],\"name\":\"approveAmountAndSetFirstUseTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_defaultBuyerLastPaidAt\",\"type\":\"uint256\"}],\"name\":\"setDefaultBuyerLastPaidAt\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenReward\",\"type\":\"uint256\"}],\"name\":\"setTokenReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"}],\"name\":\"paySeller\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_usageReportingAddress\",\"type\":\"address\"}],\"name\":\"setUsageReportingAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"}],\"name\":\"totalOwedForApi\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defaultBuyerLastPaidAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"approvedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"buyerExceededApprovedAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"numCalls\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"reportUsage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"}],\"name\":\"nonzeroAddressesLengthForApi\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenContractAddress\",\"type\":\"address\"}],\"name\":\"setTokenContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saleFee\",\"type\":\"uint256\"}],\"name\":\"setSaleFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"addCredits\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"}],\"name\":\"amountOwedForApiForBuyer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenAddress\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"relayContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"apiId\",\"type\":\"uint256\"},{\"name\":\"buyerAddress\",\"type\":\"address\"},{\"name\":\"newAmount\",\"type\":\"uint256\"}],\"name\":\"approveAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"creditsBalanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"apiId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sellerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"pricePerCall\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"numCalls\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reportingAddress\",\"type\":\"address\"}],\"name\":\"LogAPICallsMade\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"apiId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sellerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rewardedTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"networkFee\",\"type\":\"uint256\"}],\"name\":\"LogAPICallsPaid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"apiId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"causedAnOverdraft\",\"type\":\"bool\"}],\"name\":\"LogSpendCredits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDepositCredits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawCredits\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"APICalls","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6561a85a63d0312f2bf13c70ed383b7c10e73bf040d119f7e3946564f059368c"}]}