{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/interfaces/Token.sol\r\n\r\ncontract Token {\r\n    function transfer(address _to, uint _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n}\r\n\r\n// File: contracts/interfaces/TokenConverter.sol\r\n\r\ncontract TokenConverter {\r\n    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n    function getReturn(Token _fromToken, Token _toToken, uint256 _fromAmount) external view returns (uint256 amount);\r\n    function convert(Token _fromToken, Token _toToken, uint256 _fromAmount, uint256 _minReturn) external payable returns (uint256 amount);\r\n}\r\n\r\n// File: contracts/vendors/rcn/NanoLoanEngine.sol\r\n\r\ncontract Engine {\r\n    uint256 public VERSION;\r\n    string public VERSION_NAME;\r\n\r\n    enum Status { initial, lent, paid, destroyed }\r\n    struct Approbation {\r\n        bool approved;\r\n        bytes data;\r\n        bytes32 checksum;\r\n    }\r\n\r\n    function getTotalLoans() public view returns (uint256);\r\n    function getOracle(uint index) public view returns (Oracle);\r\n    function getBorrower(uint index) public view returns (address);\r\n    function getCosigner(uint index) public view returns (address);\r\n    function ownerOf(uint256) public view returns (address owner);\r\n    function getCreator(uint index) public view returns (address);\r\n    function getAmount(uint index) public view returns (uint256);\r\n    function getPaid(uint index) public view returns (uint256);\r\n    function getDueTime(uint index) public view returns (uint256);\r\n    function getApprobation(uint index, address _address) public view returns (bool);\r\n    function getStatus(uint index) public view returns (Status);\r\n    function isApproved(uint index) public view returns (bool);\r\n    function getPendingAmount(uint index) public returns (uint256);\r\n    function getCurrency(uint index) public view returns (bytes32);\r\n    function cosign(uint index, uint256 cost) external returns (bool);\r\n    function approveLoan(uint index) public returns (bool);\r\n    function transfer(address to, uint256 index) public returns (bool);\r\n    function takeOwnership(uint256 index) public returns (bool);\r\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool);\r\n}\r\n\r\n/**\r\n    @dev Defines the interface of a standard RCN cosigner.\r\n\r\n    The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions\r\n    of the insurance and the cost of the given are defined by the cosigner. \r\n\r\n    The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the\r\n    agent should be passed as params when the lender calls the \"lend\" method on the engine.\r\n    \r\n    When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine\r\n    should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to\r\n    call this method, like the transfer of the ownership of the loan.\r\n*/\r\ncontract Cosigner {\r\n    uint256 public constant VERSION = 2;\r\n    \r\n    /**\r\n        @return the url of the endpoint that exposes the insurance offers.\r\n    */\r\n    function url() public view returns (string);\r\n    \r\n    /**\r\n        @dev Retrieves the cost of a given insurance, this amount should be exact.\r\n\r\n        @return the cost of the cosign, in RCN wei\r\n    */\r\n    function cost(address engine, uint256 index, bytes data, bytes oracleData) public view returns (uint256);\r\n    \r\n    /**\r\n        @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of\r\n        the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or\r\n        does not return true to this method, the operation fails.\r\n\r\n        @return true if the cosigner accepts the liability\r\n    */\r\n    function requestCosign(address engine, uint256 index, bytes data, bytes oracleData) public returns (bool);\r\n    \r\n    /**\r\n        @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the\r\n        current lender of the loan.\r\n\r\n        @return true if the claim was done correctly.\r\n    */\r\n    function claim(address engine, uint256 index, bytes oracleData) public returns (bool);\r\n}\r\n\r\ncontract ERC721 {\r\n   // ERC20 compatible functions\r\n   function name() public view returns (string _name);\r\n   function symbol() public view returns (string _symbol);\r\n   function totalSupply() public view returns (uint256 _totalSupply);\r\n   function balanceOf(address _owner) public view returns (uint _balance);\r\n   // Functions that define ownership\r\n   function ownerOf(uint256) public view returns (address owner);\r\n   function approve(address, uint256) public returns (bool);\r\n   function takeOwnership(uint256) public returns (bool);\r\n   function transfer(address, uint256) public returns (bool);\r\n   function setApprovalForAll(address _operator, bool _approved) public returns (bool);\r\n   function getApproved(uint256 _tokenId) public view returns (address);\r\n   function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n   // Token metadata\r\n   function tokenMetadata(uint256 _tokenId) public view returns (string info);\r\n   // Events\r\n   event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n   event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n   event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function Ownable() public {\r\n        owner = msg.sender; \r\n    }\r\n\r\n    /**\r\n        @dev Transfers the ownership of the contract.\r\n\r\n        @param _to Address of the new owner\r\n    */\r\n    function transferTo(address _to) public onlyOwner returns (bool) {\r\n        require(_to != address(0));\r\n        owner = _to;\r\n        return true;\r\n    } \r\n} \r\n\r\n/**\r\n    @dev Defines the interface of a standard RCN oracle.\r\n\r\n    The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency,\r\n    it's primarily used by the exchange but could be used by any other agent.\r\n*/\r\ncontract Oracle is Ownable {\r\n    uint256 public constant VERSION = 3;\r\n\r\n    event NewSymbol(bytes32 _currency, string _ticker);\r\n    \r\n    struct Symbol {\r\n        string ticker;\r\n        bool supported;\r\n    }\r\n\r\n    mapping(bytes32 => Symbol) public currencies;\r\n\r\n    /**\r\n        @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed\r\n    */\r\n    function url() public view returns (string);\r\n\r\n    /**\r\n        @dev Returns a valid convertion rate from the currency given to RCN\r\n\r\n        @param symbol Symbol of the currency\r\n        @param data Generic data field, could be used for off-chain signing\r\n    */\r\n    function getRate(bytes32 symbol, bytes data) public returns (uint256 rate, uint256 decimals);\r\n\r\n    /**\r\n        @dev Adds a currency to the oracle, once added it cannot be removed\r\n\r\n        @param ticker Symbol of the currency\r\n\r\n        @return the hash of the currency, calculated keccak256(ticker)\r\n    */\r\n    function addCurrency(string ticker) public onlyOwner returns (bytes32) {\r\n        NewSymbol(currency, ticker);\r\n        bytes32 currency = keccak256(ticker);\r\n        currencies[currency] = Symbol(ticker, true);\r\n        return currency;\r\n    }\r\n\r\n    /**\r\n        @return true If the currency is supported\r\n    */\r\n    function supported(bytes32 symbol) public view returns (bool) {\r\n        return currencies[symbol].supported;\r\n    }\r\n}\r\n\r\ncontract RpSafeMath {\r\n    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\r\n      uint256 z = x + y;\r\n      require((z >= x) && (z >= y));\r\n      return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\r\n      require(x >= y);\r\n      uint256 z = x - y;\r\n      return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\r\n      uint256 z = x * y;\r\n      require((x == 0)||(z/x == y));\r\n      return z;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if (a < b) { \r\n          return a;\r\n        } else { \r\n          return b; \r\n        }\r\n    }\r\n    \r\n    function max(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if (a > b) { \r\n          return a;\r\n        } else { \r\n          return b; \r\n        }\r\n    }\r\n}\r\n\r\ncontract TokenLockable is RpSafeMath, Ownable {\r\n    mapping(address => uint256) public lockedTokens;\r\n\r\n    /**\r\n        @dev Locked tokens cannot be withdrawn using the withdrawTokens function.\r\n    */\r\n    function lockTokens(address token, uint256 amount) internal {\r\n        lockedTokens[token] = safeAdd(lockedTokens[token], amount);\r\n    }\r\n\r\n    /**\r\n        @dev Unlocks previusly locked tokens.\r\n    */\r\n    function unlockTokens(address token, uint256 amount) internal {\r\n        lockedTokens[token] = safeSubtract(lockedTokens[token], amount);\r\n    }\r\n\r\n    /**\r\n        @dev Withdraws tokens from the contract.\r\n\r\n        @param token Token to withdraw\r\n        @param to Destination of the tokens\r\n        @param amount Amount to withdraw \r\n    */\r\n    function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) {\r\n        require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount);\r\n        require(to != address(0));\r\n        return token.transfer(to, amount);\r\n    }\r\n}\r\n\r\ncontract NanoLoanEngine is Ownable, TokenLockable {\r\n    uint256 constant internal PRECISION = (10**18);\r\n    uint256 constant internal RCN_DECIMALS = 18;\r\n\r\n    uint256 public constant VERSION = 232;\r\n    string public constant VERSION_NAME = \"Basalt\";\r\n\r\n    uint256 private activeLoans = 0;\r\n    mapping(address => uint256) private lendersBalance;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function name() public view returns (string _name) {\r\n        _name = \"RCN - Nano loan engine - Basalt 232\";\r\n    }\r\n\r\n    function symbol() public view returns (string _symbol) {\r\n        _symbol = \"RCN-NLE-232\";\r\n    }\r\n\r\n    /**\r\n        @notice Returns the number of active loans in total, active loans are the loans with \"lent\" status.\r\n        @dev Required for ERC-721 compliance\r\n\r\n        @return _totalSupply Total amount of loans\r\n    */\r\n    function totalSupply() public view returns (uint _totalSupply) {\r\n        _totalSupply = activeLoans;\r\n    }\r\n\r\n    /**\r\n        @notice Returns the number of active loans that a lender possess; active loans are the loans with \"lent\" status.\r\n        @dev Required for ERC-721 compliance\r\n\r\n        @param _owner The owner address to search\r\n        \r\n        @return _balance Amount of loans  \r\n    */\r\n    function balanceOf(address _owner) public view returns (uint _balance) {\r\n        _balance = lendersBalance[_owner];\r\n    }\r\n\r\n    /**\r\n        @notice Returns all the loans that a lender possess\r\n        @dev This method MUST NEVER be called by smart contract code; \r\n            it walks the entire loans array, and will probably create a transaction bigger than the gas limit.\r\n\r\n        @param _owner The owner address\r\n\r\n        @return ownerTokens List of all the loans of the _owner\r\n    */\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\r\n        uint256 tokenCount = balanceOf(_owner);\r\n\r\n        if (tokenCount == 0) {\r\n            // Return an empty array\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](tokenCount);\r\n            uint256 totalLoans = loans.length - 1;\r\n            uint256 resultIndex = 0;\r\n\r\n            uint256 loanId;\r\n\r\n            for (loanId = 0; loanId <= totalLoans; loanId++) {\r\n                if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) {\r\n                    result[resultIndex] = loanId;\r\n                    resultIndex++;\r\n                }\r\n            }\r\n\r\n            return result;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Returns the loan metadata, this field can be set by the creator of the loan with his own criteria.\r\n\r\n        @param index Index of the loan\r\n\r\n        @return The string with the metadata\r\n    */\r\n    function tokenMetadata(uint256 index) public view returns (string) {\r\n        return loans[index].metadata;\r\n    }\r\n\r\n    /**\r\n        @notice Returns the loan metadata, hashed with keccak256.\r\n        @dev This emthod is useful to evaluate metadata from a smart contract.\r\n\r\n        @param index Index of the loan\r\n\r\n        @return The metadata hashed with keccak256\r\n    */\r\n    function tokenMetadataHash(uint256 index) public view returns (bytes32) {\r\n        return keccak256(loans[index].metadata);\r\n    }\r\n\r\n    Token public rcn;\r\n    bool public deprecated;\r\n\r\n    event CreatedLoan(uint _index, address _borrower, address _creator);\r\n    event ApprovedBy(uint _index, address _address);\r\n    event Lent(uint _index, address _lender, address _cosigner);\r\n    event DestroyedBy(uint _index, address _address);\r\n    event PartialPayment(uint _index, address _sender, address _from, uint256 _amount);\r\n    event TotalPayment(uint _index);\r\n\r\n    function NanoLoanEngine(Token _rcn) public {\r\n        owner = msg.sender;\r\n        rcn = _rcn;\r\n        // The loan 0 is a Invalid loan\r\n        loans.length++;\r\n    }\r\n    enum Status { initial, lent, paid, destroyed }\r\n\r\n    struct Loan {\r\n        Status status;\r\n        Oracle oracle;\r\n\r\n        address borrower;\r\n        address lender;\r\n        address creator;\r\n        address cosigner;\r\n        \r\n        uint256 amount;\r\n        uint256 interest;\r\n        uint256 punitoryInterest;\r\n        uint256 interestTimestamp;\r\n        uint256 paid;\r\n        uint256 interestRate;\r\n        uint256 interestRatePunitory;\r\n        uint256 dueTime;\r\n        uint256 duesIn;\r\n\r\n        bytes32 currency;\r\n        uint256 cancelableAt;\r\n        uint256 lenderBalance;\r\n\r\n        address approvedTransfer;\r\n        uint256 expirationRequest;\r\n\r\n        string metadata;\r\n        mapping(address => bool) approbations;\r\n    }\r\n\r\n    mapping(bytes32 => uint256) public identifierToIndex;\r\n    Loan[] private loans;\r\n\r\n    /**\r\n        @notice Creates a loan request, the loan can be generated with any borrower and conditions; if the borrower agrees\r\n        it must call the \"approve\" function. If the creator of the loan is the borrower the approve is done automatically.\r\n\r\n        @dev The creator of the loan is the caller of this function; this is useful to track which wallet created the loan.\r\n            Two identical loans cannot exist, a clone of another loan will fail.\r\n\r\n        @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0.\r\n        @param _borrower Address of the borrower\r\n        @param _currency The currency to use with the oracle, the currency code is generated with the following formula,\r\n            keccak256(ticker), is always stored as the minimum divisible amount. (Ej: ETH Wei, USD Cents)\r\n        @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present\r\n            the currency is RCN, and the unit is wei.\r\n        @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000.\r\n        @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000.\r\n            Ej: interestRate 11108571428571 = 28% Anual interest\r\n        @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money.\r\n        @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays \r\n        entirely or partially the loan before this term, no extra interest will be deducted.\r\n        @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, \r\n            the request is no longer valid.\r\n        @param _metadata String with loan metadata.\r\n    */\r\n    function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate,\r\n        uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest, string _metadata) public returns (uint256) {\r\n\r\n        require(!deprecated);\r\n        require(_cancelableAt <= _duesIn);\r\n        require(_oracleContract != address(0) || _currency == 0x0);\r\n        require(_borrower != address(0));\r\n        require(_amount != 0);\r\n        require(_interestRatePunitory != 0);\r\n        require(_interestRate != 0);\r\n        require(_expirationRequest > block.timestamp);\r\n\r\n        var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate,\r\n            _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest, _metadata);\r\n\r\n        uint index = loans.push(loan) - 1;\r\n        CreatedLoan(index, _borrower, msg.sender);\r\n\r\n        bytes32 identifier = getIdentifier(index);\r\n        require(identifierToIndex[identifier] == 0);\r\n        identifierToIndex[identifier] = index;\r\n\r\n        if (msg.sender == _borrower) {\r\n            approveLoan(index);\r\n        }\r\n\r\n        return index;\r\n    }\r\n    \r\n    function ownerOf(uint256 index) public view returns (address owner) { owner = loans[index].lender; }\r\n    function getTotalLoans() public view returns (uint256) { return loans.length; }\r\n    function getOracle(uint index) public view returns (Oracle) { return loans[index].oracle; }\r\n    function getBorrower(uint index) public view returns (address) { return loans[index].borrower; }\r\n    function getCosigner(uint index) public view returns (address) { return loans[index].cosigner; }\r\n    function getCreator(uint index) public view returns (address) { return loans[index].creator; }\r\n    function getAmount(uint index) public view returns (uint256) { return loans[index].amount; }\r\n    function getPunitoryInterest(uint index) public view returns (uint256) { return loans[index].punitoryInterest; }\r\n    function getInterestTimestamp(uint index) public view returns (uint256) { return loans[index].interestTimestamp; }\r\n    function getPaid(uint index) public view returns (uint256) { return loans[index].paid; }\r\n    function getInterestRate(uint index) public view returns (uint256) { return loans[index].interestRate; }\r\n    function getInterestRatePunitory(uint index) public view returns (uint256) { return loans[index].interestRatePunitory; }\r\n    function getDueTime(uint index) public view returns (uint256) { return loans[index].dueTime; }\r\n    function getDuesIn(uint index) public view returns (uint256) { return loans[index].duesIn; }\r\n    function getCancelableAt(uint index) public view returns (uint256) { return loans[index].cancelableAt; }\r\n    function getApprobation(uint index, address _address) public view returns (bool) { return loans[index].approbations[_address]; }\r\n    function getStatus(uint index) public view returns (Status) { return loans[index].status; }\r\n    function getLenderBalance(uint index) public view returns (uint256) { return loans[index].lenderBalance; }\r\n    function getApproved(uint index) public view returns (address) {return loans[index].approvedTransfer; }\r\n    function getCurrency(uint index) public view returns (bytes32) { return loans[index].currency; }\r\n    function getExpirationRequest(uint index) public view returns (uint256) { return loans[index].expirationRequest; }\r\n    function getInterest(uint index) public view returns (uint256) { return loans[index].interest; }\r\n\r\n    function getIdentifier(uint index) public view returns (bytes32) {\r\n        Loan memory loan = loans[index];\r\n        return buildIdentifier(loan.oracle, loan.borrower, loan.creator, loan.currency, loan.amount, loan.interestRate,\r\n            loan.interestRatePunitory, loan.duesIn, loan.cancelableAt, loan.expirationRequest, loan.metadata);\r\n    }\r\n\r\n    /**\r\n        @notice Used to reference a loan that is not yet created, and by that does not have an index\r\n\r\n        @dev Two identical loans cannot exist, only one loan per signature is allowed\r\n\r\n        @return The signature hash of the loan configuration\r\n    */\r\n    function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate,\r\n        uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string metadata) view returns (bytes32) {\r\n        return keccak256(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn,\r\n                        cancelableAt, expirationRequest, metadata); \r\n    }\r\n\r\n    /**\r\n        @notice Used to know if a loan is ready to lend\r\n\r\n        @param index Index of the loan\r\n\r\n        @return true if the loan has been approved by the borrower and cosigner.\r\n    */\r\n    function isApproved(uint index) public view returns (bool) {\r\n        Loan storage loan = loans[index];\r\n        return loan.approbations[loan.borrower];\r\n    }\r\n\r\n    /**\r\n        @notice Called by the members of the loan to show that they agree with the terms of the loan; the borrower\r\n        must call this method before any lender could call the method \"lend\".\r\n            \r\n        @dev Any address can call this method to be added to the \"approbations\" mapping.\r\n\r\n        @param index Index of the loan\r\n\r\n        @return true if the approve was done successfully\r\n    */\r\n    function approveLoan(uint index) public returns(bool) {\r\n        Loan storage loan = loans[index];\r\n        require(loan.status == Status.initial);\r\n        loan.approbations[msg.sender] = true;\r\n        ApprovedBy(index, msg.sender);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @notice Approves a loan using the Identifier and not the index\r\n\r\n        @param identifier Identifier of the loan\r\n\r\n        @return true if the approve was done successfully\r\n    */\r\n    function approveLoanIdentifier(bytes32 identifier) public returns (bool) {\r\n        uint256 index = identifierToIndex[identifier];\r\n        require(index != 0);\r\n        return approveLoan(index);\r\n    }\r\n\r\n    /**\r\n        @notice Register an approvation made by a borrower in the past\r\n\r\n        @dev The loan should exist and have an index\r\n\r\n        @param identifier Identifier of the loan\r\n\r\n        @return true if the approve was done successfully\r\n    */\r\n    function registerApprove(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) public returns (bool) {\r\n        uint256 index = identifierToIndex[identifier];\r\n        require(index != 0);\r\n        Loan storage loan = loans[index];\r\n        require(loan.borrower == ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", identifier), v, r, s));\r\n        loan.approbations[loan.borrower] = true;\r\n        ApprovedBy(index, loan.borrower);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @notice Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender.\r\n\r\n        @dev The loan must be previously approved by the borrower; before calling this function, the lender candidate must \r\n        call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of\r\n        the requested amount, and the cosigner fee.\r\n        \r\n        @param index Index of the loan\r\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\r\n            by the url exposed in the url() method of the oracle.\r\n        @param cosigner Address of the cosigner, 0x0 for lending without cosigner.\r\n        @param cosignerData Data required by the cosigner to process the request.\r\n\r\n        @return true if the lend was done successfully\r\n    */\r\n    function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) {\r\n        Loan storage loan = loans[index];\r\n\r\n        require(loan.status == Status.initial);\r\n        require(isApproved(index));\r\n        require(block.timestamp <= loan.expirationRequest);\r\n\r\n        loan.lender = msg.sender;\r\n        loan.dueTime = safeAdd(block.timestamp, loan.duesIn);\r\n        loan.interestTimestamp = block.timestamp;\r\n        loan.status = Status.lent;\r\n\r\n        // ERC721, create new loan and transfer it to the lender\r\n        Transfer(0x0, loan.lender, index);\r\n        activeLoans += 1;\r\n        lendersBalance[loan.lender] += 1;\r\n        \r\n        if (loan.cancelableAt > 0)\r\n            internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt));\r\n\r\n        // Transfer the money to the borrower before handling the cosigner\r\n        // so the cosigner could require a specific usage for that money.\r\n        uint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, loan.amount);\r\n        require(rcn.transferFrom(msg.sender, loan.borrower, transferValue));\r\n        \r\n        if (cosigner != address(0)) {\r\n            // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will\r\n            // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right\r\n            // address. If that does not happen, the transaction fails.\r\n            loan.cosigner = address(uint256(cosigner) + 2);\r\n            require(cosigner.requestCosign(this, index, cosignerData, oracleData));\r\n            require(loan.cosigner == address(cosigner));\r\n        }\r\n                \r\n        Lent(index, loan.lender, cosigner);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @notice The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee.\r\n        \r\n        @dev If the cosigner does not call this method the whole \"lend\" call fails.\r\n\r\n        @param index Index of the loan\r\n        @param cost Fee set by the cosigner\r\n\r\n        @return true If the cosign was successfull\r\n    */\r\n    function cosign(uint index, uint256 cost) external returns (bool) {\r\n        Loan storage loan = loans[index];\r\n        require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp);\r\n        require(loan.cosigner != address(0));\r\n        require(loan.cosigner == address(uint256(msg.sender) + 2));\r\n        loan.cosigner = msg.sender;\r\n        require(rcn.transferFrom(loan.lender, msg.sender, cost));\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @notice Destroys a loan, the borrower could call this method if they performed an accidental or regretted \r\n        \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status.\r\n\r\n        The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning \r\n        the debt. \r\n\r\n        @param index Index of the loan\r\n\r\n        @return true if the destroy was done successfully\r\n    */\r\n    function destroy(uint index) public returns (bool) {\r\n        Loan storage loan = loans[index];\r\n        require(loan.status != Status.destroyed);\r\n        require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial));\r\n        DestroyedBy(index, msg.sender);\r\n\r\n        // ERC721, remove loan from circulation\r\n        if (loan.status != Status.initial) {\r\n            lendersBalance[loan.lender] -= 1;\r\n            activeLoans -= 1;\r\n            Transfer(loan.lender, 0x0, index);\r\n        }\r\n\r\n        loan.status = Status.destroyed;\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @notice Destroys a loan using the signature and not the Index\r\n\r\n        @param identifier Identifier of the loan\r\n\r\n        @return true if the destroy was done successfully\r\n    */\r\n    function destroyIdentifier(bytes32 identifier) public returns (bool) {\r\n        uint256 index = identifierToIndex[identifier];\r\n        require(index != 0);\r\n        return destroy(index);\r\n    }\r\n\r\n    /**\r\n        @notice Transfers a loan to a different lender, the caller must be the current lender or previously being\r\n        approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered.\r\n\r\n        @dev Required for ERC-721 compliance\r\n\r\n        @param index Index of the loan\r\n        @param to New lender\r\n\r\n        @return true if the transfer was done successfully\r\n    */\r\n    function transfer(address to, uint256 index) public returns (bool) {\r\n        Loan storage loan = loans[index];\r\n        \r\n        require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer);\r\n        require(to != address(0));\r\n        loan.lender = to;\r\n        loan.approvedTransfer = address(0);\r\n\r\n        // ERC721, transfer loan to another address\r\n        lendersBalance[msg.sender] -= 1;\r\n        lendersBalance[to] += 1;\r\n        Transfer(loan.lender, to, index);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @notice Transfers the loan to the msg.sender, the msg.sender must be approved using the \"approve\" method.\r\n\r\n        @dev Required for ERC-721 compliance\r\n\r\n        @param _index Index of the loan\r\n\r\n        @return true if the transfer was successfull\r\n    */\r\n    function takeOwnership(uint256 _index) public returns (bool) {\r\n        return transfer(msg.sender, _index);\r\n    }\r\n\r\n    /**\r\n        @notice Transfers the loan to an address, only if the current owner is the \"from\" address\r\n\r\n        @dev Required for ERC-721 compliance\r\n\r\n        @param from Current owner of the loan\r\n        @param to New owner of the loan\r\n        @param index Index of the loan\r\n\r\n        @return true if the transfer was successfull\r\n    */\r\n    function transferFrom(address from, address to, uint256 index) public returns (bool) {\r\n        require(loans[index].lender == from);\r\n        return transfer(to, index);\r\n    }\r\n\r\n    /**\r\n        @notice Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to\r\n        \"approve\" in the ERC20 standard, but only one approved address is allowed at a time.\r\n\r\n        The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address.\r\n\r\n        @dev Required for ERC-721 compliance\r\n\r\n        @param to Address allowed to transfer the loan or 0x0 to delete\r\n        @param index Index of the loan\r\n\r\n        @return true if the approve was done successfully\r\n    */\r\n    function approve(address to, uint256 index) public returns (bool) {\r\n        Loan storage loan = loans[index];\r\n        require(msg.sender == loan.lender);\r\n        loan.approvedTransfer = to;\r\n        Approval(msg.sender, to, index);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @notice Returns the pending amount to complete de payment of the loan, keep in mind that this number increases \r\n        every second.\r\n\r\n        @dev This method also computes the interest and updates the loan\r\n\r\n        @param index Index of the loan\r\n\r\n        @return Aprox pending payment amount\r\n    */\r\n    function getPendingAmount(uint index) public returns (uint256) {\r\n        addInterest(index);\r\n        return getRawPendingAmount(index);\r\n    }\r\n\r\n    /**\r\n        @notice Returns the pending amount up to the last time of the interest update. This is not the real pending amount\r\n\r\n        @dev This method is exact only if \"addInterest(loan)\" was before and in the same block.\r\n\r\n        @param index Index of the loan\r\n\r\n        @return The past pending amount\r\n    */\r\n    function getRawPendingAmount(uint index) public view returns (uint256) {\r\n        Loan memory loan = loans[index];\r\n        return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid);\r\n    }\r\n\r\n    /**\r\n        @notice Calculates the interest of a given amount, interest rate and delta time.\r\n\r\n        @param timeDelta Elapsed time\r\n        @param interestRate Interest rate expressed as the denominator of 10 000 000.\r\n        @param amount Amount to apply interest\r\n\r\n        @return realDelta The real timeDelta applied\r\n        @return interest The interest gained in the realDelta time\r\n    */\r\n    function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) internal pure returns (uint256 realDelta, uint256 interest) {\r\n        if (amount == 0) {\r\n            interest = 0;\r\n            realDelta = timeDelta;\r\n        } else {\r\n            interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate;\r\n            realDelta = safeMult(interest, interestRate) / (amount * 100000);\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Computes loan interest\r\n\r\n        Computes the punitory and non-punitory interest of a given loan and only applies the change.\r\n        \r\n        @param loan Loan to compute interest\r\n        @param timestamp Target absolute unix time to calculate interest.\r\n    */\r\n    function internalAddInterest(Loan storage loan, uint256 timestamp) internal {\r\n        if (timestamp > loan.interestTimestamp) {\r\n            uint256 newInterest = loan.interest;\r\n            uint256 newPunitoryInterest = loan.punitoryInterest;\r\n\r\n            uint256 newTimestamp;\r\n            uint256 realDelta;\r\n            uint256 calculatedInterest;\r\n\r\n            uint256 deltaTime;\r\n            uint256 pending;\r\n\r\n            uint256 endNonPunitory = min(timestamp, loan.dueTime);\r\n            if (endNonPunitory > loan.interestTimestamp) {\r\n                deltaTime = endNonPunitory - loan.interestTimestamp;\r\n\r\n                if (loan.paid < loan.amount) {\r\n                    pending = loan.amount - loan.paid;\r\n                } else {\r\n                    pending = 0;\r\n                }\r\n\r\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending);\r\n                newInterest = safeAdd(calculatedInterest, newInterest);\r\n                newTimestamp = loan.interestTimestamp + realDelta;\r\n            }\r\n\r\n            if (timestamp > loan.dueTime) {\r\n                uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp);\r\n                deltaTime = timestamp - startPunitory;\r\n\r\n                uint256 debt = safeAdd(loan.amount, newInterest);\r\n                pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid));\r\n\r\n                (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending);\r\n                newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest);\r\n                newTimestamp = startPunitory + realDelta;\r\n            }\r\n            \r\n            if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) {\r\n                loan.interestTimestamp = newTimestamp;\r\n                loan.interest = newInterest;\r\n                loan.punitoryInterest = newPunitoryInterest;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Updates the loan accumulated interests up to the current Unix time.\r\n        \r\n        @param index Index of the loan\r\n    \r\n        @return true If the interest was updated\r\n    */\r\n    function addInterest(uint index) public returns (bool) {\r\n        Loan storage loan = loans[index];\r\n        require(loan.status == Status.lent);\r\n        internalAddInterest(loan, block.timestamp);\r\n    }\r\n    \r\n    /**\r\n        @notice Pay loan\r\n\r\n        Does a payment of a given Loan, before performing the payment the accumulated\r\n        interest is computed and added to the total pending amount.\r\n\r\n        Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount\r\n        sufficient enough to pay the equivalent of the desired payment and the oracle fee.\r\n\r\n        If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed.\r\n\r\n        @dev Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the\r\n        transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated\r\n        spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender.\r\n\r\n        * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the\r\n        confirmation of the transaction. \r\n\r\n        @param index Index of the loan\r\n        @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle\r\n        @param _from The identity of the payer\r\n        @param oracleData Data required by the oracle to return the rate, the content of this field must be provided\r\n            by the url exposed in the url() method of the oracle.\r\n            \r\n        @return true if the payment was executed successfully\r\n    */\r\n    function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) {\r\n        Loan storage loan = loans[index];\r\n\r\n        require(loan.status == Status.lent);\r\n        addInterest(index);\r\n        uint256 toPay = min(getPendingAmount(index), _amount);\r\n        PartialPayment(index, msg.sender, _from, toPay);\r\n\r\n        loan.paid = safeAdd(loan.paid, toPay);\r\n\r\n        if (getRawPendingAmount(index) == 0) {\r\n            TotalPayment(index);\r\n            loan.status = Status.paid;\r\n\r\n            // ERC721, remove loan from circulation\r\n            lendersBalance[loan.lender] -= 1;\r\n            activeLoans -= 1;\r\n            Transfer(loan.lender, 0x0, index);\r\n        }\r\n\r\n        uint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, toPay);\r\n        require(transferValue > 0 || toPay < _amount);\r\n\r\n        lockTokens(rcn, transferValue);\r\n        require(rcn.transferFrom(msg.sender, this, transferValue));\r\n        loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n        @notice Converts an amount to RCN using the loan oracle.\r\n        \r\n        @dev If the loan has no oracle the currency must be RCN so the rate is 1\r\n\r\n        @return The result of the convertion\r\n    */\r\n    function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) public view returns (uint256) {\r\n        if (oracle == address(0)) {\r\n            return amount;\r\n        } else {\r\n            uint256 rate;\r\n            uint256 decimals;\r\n            \r\n            (rate, decimals) = oracle.getRate(currency, data);\r\n\r\n            require(decimals <= RCN_DECIMALS);\r\n            return (safeMult(safeMult(amount, rate), (10**(RCN_DECIMALS-decimals)))) / PRECISION;\r\n        }\r\n    }\r\n\r\n    /**\r\n        @notice Withdraw lender funds\r\n\r\n        When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the\r\n        engine contract, and the lender must call this function specifying the amount desired to transfer and the \r\n        destination.\r\n\r\n        @dev This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that\r\n        the contract will receive tokens that are not traceable; and it allows the development of decentralized \r\n        autonomous organizations.\r\n\r\n        @param index Index of the loan\r\n        @param to Destination of the wiwthdraw funds\r\n        @param amount Amount to withdraw, in RCN\r\n\r\n        @return true if the withdraw was executed successfully\r\n    */\r\n    function withdrawal(uint index, address to, uint256 amount) public returns (bool) {\r\n        Loan storage loan = loans[index];\r\n        require(msg.sender == loan.lender);\r\n        loan.lenderBalance = safeSubtract(loan.lenderBalance, amount);\r\n        require(rcn.transfer(to, amount));\r\n        unlockTokens(rcn, amount);\r\n        return true;\r\n    }\r\n    \r\n    /**\r\n        @dev Deprecates the engine, locks the creation of new loans.\r\n    */\r\n    function setDeprecated(bool _deprecated) public onlyOwner {\r\n        deprecated = _deprecated;\r\n    }\r\n}\r\n\r\n// File: contracts/utils/LrpSafeMath.sol\r\n\r\nlibrary LrpSafeMath {\r\n    function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        uint256 z = x + y;\r\n        require((z >= x) && (z >= y));\r\n        return z;\r\n    }\r\n\r\n    function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        require(x >= y);\r\n        uint256 z = x - y;\r\n        return z;\r\n    }\r\n\r\n    function safeMult(uint256 x, uint256 y) internal pure returns(uint256) {\r\n        uint256 z = x * y;\r\n        require((x == 0)||(z/x == y));\r\n        return z;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if (a < b) { \r\n            return a;\r\n        } else { \r\n            return b; \r\n        }\r\n    }\r\n    \r\n    function max(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        if (a > b) { \r\n            return a;\r\n        } else { \r\n            return b; \r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/ConverterRamp.sol\r\n\r\ncontract ConverterRamp is Ownable {\r\n    using LrpSafeMath for uint256;\r\n\r\n    address public constant ETH_ADDRESS = 0x00eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee;\r\n    uint256 public constant AUTO_MARGIN = 1000001;\r\n    // index of convert rules for pay and lend\r\n    uint256 public constant I_MARGIN_SPEND = 0;    // Extra sell percent of amount, 100.000 = 100%\r\n    uint256 public constant I_MAX_SPEND = 1;       // Max spend on perform a sell, 0 = maximum\r\n    uint256 public constant I_REBUY_THRESHOLD = 2; // Threshold of rebuy change, 0 if want to rebuy always\r\n    // index of loan parameters for pay and lend\r\n    uint256 public constant I_ENGINE = 0;     // NanoLoanEngine contract\r\n    uint256 public constant I_INDEX = 1;      // Loan index on Loans array of NanoLoanEngine\r\n    // for pay\r\n    uint256 public constant I_PAY_AMOUNT = 2; // Amount to pay of the loan\r\n    uint256 public constant I_PAY_FROM = 3;   // The identity of the payer of loan\r\n    // for lend\r\n    uint256 public constant I_LEND_COSIGNER = 2; // Cosigner contract\r\n\r\n    event RequiredRebuy(address token, uint256 amount);\r\n    event Return(address token, address to, uint256 amount);\r\n    event OptimalSell(address token, uint256 amount);\r\n    event RequiredRcn(uint256 required);\r\n    event RunAutoMargin(uint256 loops, uint256 increment);\r\n\r\n    function pay(\r\n        TokenConverter converter,\r\n        Token fromToken,\r\n        bytes32[4] loanParams,\r\n        bytes oracleData,\r\n        uint256[3] convertRules\r\n    ) external payable returns (bool) {\r\n        Token rcn = NanoLoanEngine(address(loanParams[I_ENGINE])).rcn();\r\n\r\n        uint256 initialBalance = rcn.balanceOf(this);\r\n        uint256 requiredRcn = getRequiredRcnPay(loanParams, oracleData);\r\n        emit RequiredRcn(requiredRcn);\r\n\r\n        uint256 optimalSell = getOptimalSell(converter, fromToken, rcn, requiredRcn, convertRules[I_MARGIN_SPEND]);\r\n        emit OptimalSell(fromToken, optimalSell);\r\n\r\n        pullAmount(fromToken, optimalSell);\r\n        uint256 bought = convertSafe(converter, fromToken, rcn, optimalSell);\r\n\r\n        // Pay loan\r\n        require(\r\n            executeOptimalPay({\r\n                params: loanParams,\r\n                oracleData: oracleData,\r\n                rcnToPay: bought\r\n            }),\r\n            \"Error paying the loan\"\r\n        );\r\n\r\n        require(\r\n            rebuyAndReturn({\r\n                converter: converter,\r\n                fromToken: rcn,\r\n                toToken: fromToken,\r\n                amount: rcn.balanceOf(this) - initialBalance,\r\n                spentAmount: optimalSell,\r\n                convertRules: convertRules\r\n            }),\r\n            \"Error rebuying the tokens\"\r\n        );\r\n\r\n        require(rcn.balanceOf(this) == initialBalance, \"Converter balance has incremented\");\r\n        return true;\r\n    }\r\n\r\n    function requiredLendSell(\r\n        TokenConverter converter,\r\n        Token fromToken,\r\n        bytes32[3] loanParams,\r\n        bytes oracleData,\r\n        bytes cosignerData,\r\n        uint256[3] convertRules\r\n    ) external view returns (uint256) {\r\n        Token rcn = NanoLoanEngine(address(loanParams[I_ENGINE])).rcn();\r\n        return getOptimalSell(\r\n            converter,\r\n            fromToken,\r\n            rcn,\r\n            getRequiredRcnLend(loanParams, oracleData, cosignerData),\r\n            convertRules[I_MARGIN_SPEND]\r\n        );\r\n    }\r\n\r\n    function requiredPaySell(\r\n        TokenConverter converter,\r\n        Token fromToken,\r\n        bytes32[4] loanParams,\r\n        bytes oracleData,\r\n        uint256[3] convertRules\r\n    ) external view returns (uint256) {\r\n        Token rcn = NanoLoanEngine(address(loanParams[I_ENGINE])).rcn();\r\n        return getOptimalSell(\r\n            converter,\r\n            fromToken,\r\n            rcn,\r\n            getRequiredRcnPay(loanParams, oracleData),\r\n            convertRules[I_MARGIN_SPEND]\r\n        );\r\n    }\r\n\r\n    function lend(\r\n        TokenConverter converter,\r\n        Token fromToken,\r\n        bytes32[3] loanParams,\r\n        bytes oracleData,\r\n        bytes cosignerData,\r\n        uint256[3] convertRules\r\n    ) external payable returns (bool) {\r\n        Token rcn = NanoLoanEngine(address(loanParams[I_ENGINE])).rcn();\r\n        uint256 initialBalance = rcn.balanceOf(this);\r\n        uint256 requiredRcn = getRequiredRcnLend(loanParams, oracleData, cosignerData);\r\n        emit RequiredRcn(requiredRcn);\r\n        \r\n        uint256 optimalSell = getOptimalSell(converter, fromToken, rcn, requiredRcn, convertRules[I_MARGIN_SPEND]);\r\n        emit OptimalSell(fromToken, optimalSell);\r\n        \r\n        pullAmount(fromToken, optimalSell);\r\n        uint256 bought = convertSafe(converter, fromToken, rcn, optimalSell);\r\n\r\n        // Lend loan\r\n        require(rcn.approve(address(loanParams[0]), bought), \"Error approving lend token transfer\");\r\n        require(executeLend(loanParams, oracleData, cosignerData), \"Error lending the loan\");\r\n        require(rcn.approve(address(loanParams[0]), 0), \"Error removing approve\");\r\n        require(executeTransfer(loanParams, msg.sender), \"Error transfering the loan\");\r\n\r\n        require(\r\n            rebuyAndReturn({\r\n                converter: converter,\r\n                fromToken: rcn,\r\n                toToken: fromToken,\r\n                amount: rcn.balanceOf(this) - initialBalance,\r\n                spentAmount: optimalSell,\r\n                convertRules: convertRules\r\n            }),\r\n            \"Error rebuying the tokens\"\r\n        );\r\n\r\n        require(rcn.balanceOf(this) == initialBalance, \"The contract balance should not change\");\r\n        \r\n        return true;\r\n    }\r\n\r\n    function pullAmount(\r\n        Token token,\r\n        uint256 amount\r\n    ) private {\r\n        if (token == ETH_ADDRESS) {\r\n            require(msg.value >= amount, \"Error pulling ETH amount\");\r\n            if (msg.value > amount) {\r\n                msg.sender.transfer(msg.value - amount);\r\n            }\r\n        } else {\r\n            require(token.transferFrom(msg.sender, this, amount), \"Error pulling Token amount\");\r\n        }\r\n    }\r\n\r\n    function transfer(\r\n        Token token,\r\n        address to,\r\n        uint256 amount\r\n    ) private {\r\n        if (token == ETH_ADDRESS) {\r\n            to.transfer(amount);\r\n        } else {\r\n            require(token.transfer(to, amount), \"Error sending tokens\");\r\n        }\r\n    }\r\n\r\n    function rebuyAndReturn(\r\n        TokenConverter converter,\r\n        Token fromToken,\r\n        Token toToken,\r\n        uint256 amount,\r\n        uint256 spentAmount,\r\n        uint256[3] memory convertRules\r\n    ) internal returns (bool) {\r\n        uint256 threshold = convertRules[I_REBUY_THRESHOLD];\r\n        uint256 bought = 0;\r\n\r\n        if (amount != 0) {\r\n            if (amount > threshold) {\r\n                bought = convertSafe(converter, fromToken, toToken, amount);\r\n                emit RequiredRebuy(toToken, amount);\r\n                emit Return(toToken, msg.sender, bought);\r\n                transfer(toToken, msg.sender, bought);\r\n            } else {\r\n                emit Return(fromToken, msg.sender, amount);\r\n                transfer(fromToken, msg.sender, amount);\r\n            }\r\n        }\r\n\r\n        uint256 maxSpend = convertRules[I_MAX_SPEND];\r\n        require(spentAmount.safeSubtract(bought) <= maxSpend || maxSpend == 0, \"Max spend exceeded\");\r\n        \r\n        return true;\r\n    }\r\n\r\n    function getOptimalSell(\r\n        TokenConverter converter,\r\n        Token fromToken,\r\n        Token toToken,\r\n        uint256 requiredTo,\r\n        uint256 extraSell\r\n    ) internal returns (uint256 sellAmount) {\r\n        uint256 sellRate = (10 ** 18 * converter.getReturn(toToken, fromToken, requiredTo)) / requiredTo;\r\n        if (extraSell == AUTO_MARGIN) {\r\n            uint256 expectedReturn = 0;\r\n            uint256 optimalSell = applyRate(requiredTo, sellRate);\r\n            uint256 increment = applyRate(requiredTo / 100000, sellRate);\r\n            uint256 returnRebuy;\r\n            uint256 cl;\r\n\r\n            while (expectedReturn < requiredTo && cl < 10) {\r\n                optimalSell += increment;\r\n                returnRebuy = converter.getReturn(fromToken, toToken, optimalSell);\r\n                optimalSell = (optimalSell * requiredTo) / returnRebuy;\r\n                expectedReturn = returnRebuy;\r\n                cl++;\r\n            }\r\n            emit RunAutoMargin(cl, increment);\r\n\r\n            return optimalSell;\r\n        } else {\r\n            return applyRate(requiredTo, sellRate).safeMult(uint256(100000).safeAdd(extraSell)) / 100000;\r\n        }\r\n    }\r\n\r\n    function convertSafe(\r\n        TokenConverter converter,\r\n        Token fromToken,\r\n        Token toToken,\r\n        uint256 amount\r\n    ) internal returns (uint256 bought) {\r\n        if (fromToken != ETH_ADDRESS) require(fromToken.approve(converter, amount), \"Error approving token transfer\");\r\n        uint256 prevBalance = toToken != ETH_ADDRESS ? toToken.balanceOf(this) : address(this).balance;\r\n        uint256 sendEth = fromToken == ETH_ADDRESS ? amount : 0;\r\n        uint256 boughtAmount = converter.convert.value(sendEth)(fromToken, toToken, amount, 1);\r\n        require(\r\n            boughtAmount == (toToken != ETH_ADDRESS ? toToken.balanceOf(this) : address(this).balance) - prevBalance,\r\n            \"Bought amound does does not match\"\r\n        );\r\n        if (fromToken != ETH_ADDRESS) require(fromToken.approve(converter, 0), \"Error removing token approve\");\r\n        return boughtAmount;\r\n    }\r\n\r\n    function executeOptimalPay(\r\n        bytes32[4] memory params,\r\n        bytes oracleData,\r\n        uint256 rcnToPay\r\n    ) internal returns (bool) {\r\n        NanoLoanEngine engine = NanoLoanEngine(address(params[I_ENGINE]));\r\n        uint256 index = uint256(params[I_INDEX]);\r\n        Oracle oracle = engine.getOracle(index);\r\n\r\n        uint256 toPay;\r\n\r\n        if (oracle == address(0)) {\r\n            toPay = rcnToPay;\r\n        } else {\r\n            uint256 rate;\r\n            uint256 decimals;\r\n            bytes32 currency = engine.getCurrency(index);\r\n\r\n            (rate, decimals) = oracle.getRate(currency, oracleData);\r\n            toPay = ((rcnToPay * 1000000000000000000) / rate) / 10 ** (18 - decimals);\r\n        }\r\n\r\n        Token rcn = engine.rcn();\r\n        require(rcn.approve(engine, rcnToPay), \"Error on payment approve\");\r\n        require(engine.pay(index, toPay, address(params[I_PAY_FROM]), oracleData), \"Error paying the loan\");\r\n        require(rcn.approve(engine, 0), \"Error removing the payment approve\");\r\n        \r\n        return true;\r\n    }\r\n\r\n    function executeLend(\r\n        bytes32[3] memory params,\r\n        bytes oracleData,\r\n        bytes cosignerData\r\n    ) internal returns (bool) {\r\n        NanoLoanEngine engine = NanoLoanEngine(address(params[I_ENGINE]));\r\n        uint256 index = uint256(params[I_INDEX]);\r\n        return engine.lend(index, oracleData, Cosigner(address(params[I_LEND_COSIGNER])), cosignerData);\r\n    }\r\n\r\n    function executeTransfer(\r\n        bytes32[3] memory params,\r\n        address to\r\n    ) internal returns (bool) {\r\n        return NanoLoanEngine(address(params[I_ENGINE])).transfer(to, uint256(params[1]));\r\n    }\r\n\r\n    function applyRate(\r\n        uint256 amount,\r\n        uint256 rate\r\n    ) internal pure returns (uint256) {\r\n        return amount.safeMult(rate) / 10 ** 18;\r\n    }\r\n\r\n    function getRequiredRcnLend(\r\n        bytes32[3] memory params,\r\n        bytes oracleData,\r\n        bytes cosignerData\r\n    ) internal view returns (uint256 required) {\r\n        NanoLoanEngine engine = NanoLoanEngine(address(params[I_ENGINE]));\r\n        uint256 index = uint256(params[I_INDEX]);\r\n        Cosigner cosigner = Cosigner(address(params[I_LEND_COSIGNER]));\r\n\r\n        if (cosigner != address(0)) {\r\n            required += cosigner.cost(engine, index, cosignerData, oracleData);\r\n        }\r\n        required += engine.convertRate(engine.getOracle(index), engine.getCurrency(index), oracleData, engine.getAmount(index));\r\n    }\r\n    \r\n    function getRequiredRcnPay(\r\n        bytes32[4] memory params,\r\n        bytes oracleData\r\n    ) internal view returns (uint256) {\r\n        NanoLoanEngine engine = NanoLoanEngine(address(params[I_ENGINE]));\r\n        uint256 index = uint256(params[I_INDEX]);\r\n        uint256 amount = uint256(params[I_PAY_AMOUNT]);\r\n        return engine.convertRate(engine.getOracle(index), engine.getCurrency(index), oracleData, amount);\r\n    }\r\n\r\n    function withdrawTokens(\r\n        Token _token,\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner returns (bool) {\r\n        return _token.transfer(_to, _amount);\r\n    }\r\n\r\n    function withdrawEther(\r\n        address _to,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        _to.transfer(_amount);\r\n    }\r\n\r\n    function() external payable {}\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"converter\",\"type\":\"address\"},{\"name\":\"fromToken\",\"type\":\"address\"},{\"name\":\"loanParams\",\"type\":\"bytes32[3]\"},{\"name\":\"oracleData\",\"type\":\"bytes\"},{\"name\":\"cosignerData\",\"type\":\"bytes\"},{\"name\":\"convertRules\",\"type\":\"uint256[3]\"}],\"name\":\"lend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"converter\",\"type\":\"address\"},{\"name\":\"fromToken\",\"type\":\"address\"},{\"name\":\"loanParams\",\"type\":\"bytes32[3]\"},{\"name\":\"oracleData\",\"type\":\"bytes\"},{\"name\":\"cosignerData\",\"type\":\"bytes\"},{\"name\":\"convertRules\",\"type\":\"uint256[3]\"}],\"name\":\"requiredLendSell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"I_INDEX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"I_PAY_AMOUNT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"I_PAY_FROM\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"converter\",\"type\":\"address\"},{\"name\":\"fromToken\",\"type\":\"address\"},{\"name\":\"loanParams\",\"type\":\"bytes32[4]\"},{\"name\":\"oracleData\",\"type\":\"bytes\"},{\"name\":\"convertRules\",\"type\":\"uint256[3]\"}],\"name\":\"requiredPaySell\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"converter\",\"type\":\"address\"},{\"name\":\"fromToken\",\"type\":\"address\"},{\"name\":\"loanParams\",\"type\":\"bytes32[4]\"},{\"name\":\"oracleData\",\"type\":\"bytes\"},{\"name\":\"convertRules\",\"type\":\"uint256[3]\"}],\"name\":\"pay\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"I_MAX_SPEND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"I_ENGINE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferTo\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETH_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"I_LEND_COSIGNER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AUTO_MARGIN\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"I_MARGIN_SPEND\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"I_REBUY_THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"RequiredRebuy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Return\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"OptimalSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"required\",\"type\":\"uint256\"}],\"name\":\"RequiredRcn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"loops\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"increment\",\"type\":\"uint256\"}],\"name\":\"RunAutoMargin\",\"type\":\"event\"}]","ContractName":"ConverterRamp","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e7c57dbf00f0915a09099e28b9124940901fdb105723fbd3a3909b1a707bc604"}]}