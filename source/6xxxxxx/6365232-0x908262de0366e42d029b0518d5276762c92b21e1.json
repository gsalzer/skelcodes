{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n    function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a >= b ? a : b;\r\n    }\r\n\r\n    function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipRenounced(address indexed previousOwner);\r\n    event OwnershipTransferred(\r\n        address indexed previousOwner,\r\n        address indexed newOwner\r\n    );\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to relinquish control of the contract.\r\n    * @notice Renouncing to ownership will leave the contract without an owner.\r\n    * It will not be possible to call the functions with the `onlyOwner`\r\n    * modifier anymore.\r\n    */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipRenounced(owner);\r\n        owner = address(0);\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        _transferOwnership(_newOwner);\r\n    }\r\n\r\n    /**\r\n    * @dev Transfers control of the contract to a newOwner.\r\n    * @param _newOwner The address to transfer ownership to.\r\n    */\r\n    function _transferOwnership(address _newOwner) internal {\r\n        require(_newOwner != address(0));\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/// @notice The Orderbook contract stores the state and priority of orders and\r\n/// allows the Darknodes to easily reach consensus. Eventually, this contract\r\n/// will only store a subset of order states, such as cancellation, to improve\r\n/// the throughput of orders.\r\ncontract Orderbook  {\r\n    /// @notice OrderState enumerates the possible states of an order. All\r\n    /// orders default to the Undefined state.\r\n    enum OrderState {Undefined, Open, Confirmed, Canceled}\r\n\r\n    /// @notice returns a list of matched orders to the given orderID.\r\n    function orderMatch(bytes32 _orderID) external view returns (bytes32);\r\n\r\n    /// @notice returns the trader of the given orderID.\r\n    /// Trader is the one who signs the message and does the actual trading.\r\n    function orderTrader(bytes32 _orderID) external view returns (address);\r\n\r\n    /// @notice returns status of the given orderID.\r\n    function orderState(bytes32 _orderID) external view returns (OrderState);\r\n\r\n    /// @notice returns the darknode address which confirms the given orderID.\r\n    function orderConfirmer(bytes32 _orderID) external view returns (address);\r\n}\r\n\r\n\r\n/// @notice RenExTokens is a registry of tokens that can be traded on RenEx.\r\ncontract RenExTokens is Ownable {\r\n    struct TokenDetails {\r\n        address addr;\r\n        uint8 decimals;\r\n        bool registered;\r\n    }\r\n\r\n    mapping(uint32 => TokenDetails) public tokens;\r\n\r\n    /// @notice Allows the owner to register and the details for a token.\r\n    /// Once details have been submitted, they cannot be overwritten.\r\n    /// To re-register the same token with different details (e.g. if the address\r\n    /// has changed), a different token identifier should be used and the\r\n    /// previous token identifier should be deregistered.\r\n    /// If a token is not Ethereum-based, the address will be set to 0x0.\r\n    ///\r\n    /// @param _tokenCode A unique 32-bit token identifier.\r\n    /// @param _tokenAddress The address of the token.\r\n    /// @param _tokenDecimals The decimals to use for the token.\r\n    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner;\r\n\r\n    /// @notice Sets a token as being deregistered. The details are still stored\r\n    /// to prevent the token from being re-registered with different details.\r\n    ///\r\n    /// @param _tokenCode The unique 32-bit token identifier.\r\n    function deregisterToken(uint32 _tokenCode) external onlyOwner;\r\n}\r\n\r\n\r\n/// @notice RenExBalances is responsible for holding RenEx trader funds.\r\ncontract RenExBalances {\r\n    address public settlementContract;\r\n\r\n    /// @notice Restricts a function to only being called by the RenExSettlement\r\n    /// contract.\r\n    modifier onlyRenExSettlementContract() {\r\n        require(msg.sender == address(settlementContract), \"not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Transfer a token value from one trader to another, transferring\r\n    /// a fee to the RewardVault. Can only be called by the RenExSettlement\r\n    /// contract.\r\n    ///\r\n    /// @param _traderFrom The address of the trader to decrement the balance of.\r\n    /// @param _traderTo The address of the trader to increment the balance of.\r\n    /// @param _token The token's address.\r\n    /// @param _value The number of tokens to decrement the balance by (in the\r\n    ///        token's smallest unit).\r\n    /// @param _fee The fee amount to forward on to the RewardVault.\r\n    /// @param _feePayee The recipient of the fee.\r\n    function transferBalanceWithFee(address _traderFrom, address _traderTo, address _token, uint256 _value, uint256 _fee, address _feePayee)\r\n    external onlyRenExSettlementContract;\r\n}\r\n\r\n\r\n/// @notice A library for calculating and verifying order match details\r\nlibrary SettlementUtils {\r\n\r\n    struct OrderDetails {\r\n        uint64 settlementID;\r\n        uint64 tokens;\r\n        uint256 price;\r\n        uint256 volume;\r\n        uint256 minimumVolume;\r\n    }\r\n\r\n    /// @notice Calculates the ID of the order.\r\n    /// @param details Order details that are not required for settlement\r\n    ///        execution. They are combined as a single byte array.\r\n    /// @param order The order details required for settlement execution.\r\n    function hashOrder(bytes details, OrderDetails memory order) internal pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                details,\r\n                order.settlementID,\r\n                order.tokens,\r\n                order.price,\r\n                order.volume,\r\n                order.minimumVolume\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice Verifies that two orders match when considering the tokens,\r\n    /// price, volumes / minimum volumes and settlement IDs. verifyMatchDetails is used\r\n    /// my the DarknodeSlasher to verify challenges. Settlement layers may also\r\n    /// use this function.\r\n    /// @dev When verifying two orders for settlement, you should also:\r\n    ///   1) verify the orders have been confirmed together\r\n    ///   2) verify the orders' traders are distinct\r\n    /// @param _buy The buy order details.\r\n    /// @param _sell The sell order details.\r\n    function verifyMatchDetails(OrderDetails memory _buy, OrderDetails memory _sell) internal pure returns (bool) {\r\n\r\n        // Buy and sell tokens should match\r\n        if (!verifyTokens(_buy.tokens, _sell.tokens)) {\r\n            return false;\r\n        }\r\n\r\n        // Buy price should be greater than sell price\r\n        if (_buy.price < _sell.price) {\r\n            return false;\r\n        }\r\n\r\n        // // Buy volume should be greater than sell minimum volume\r\n        if (_buy.volume < _sell.minimumVolume) {\r\n            return false;\r\n        }\r\n\r\n        // Sell volume should be greater than buy minimum volume\r\n        if (_sell.volume < _buy.minimumVolume) {\r\n            return false;\r\n        }\r\n\r\n        // Require that the orders were submitted to the same settlement layer\r\n        if (_buy.settlementID != _sell.settlementID) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Verifies that two token requirements can be matched and that the\r\n    /// tokens are formatted correctly.\r\n    /// @param _buyTokens The buy token details.\r\n    /// @param _sellToken The sell token details.\r\n    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) internal pure returns (bool) {\r\n        return ((\r\n                uint32(_buyTokens) == uint32(_sellToken >> 32)) && (\r\n                uint32(_sellToken) == uint32(_buyTokens >> 32)) && (\r\n                uint32(_buyTokens >> 32) <= uint32(_buyTokens))\r\n        );\r\n    }\r\n}\r\n\r\n/// @notice RenExSettlement implements the Settlement interface. It implements\r\n/// the on-chain settlement for the RenEx settlement layer, and the fee payment\r\n/// for the RenExAtomic settlement layer.\r\ncontract RenExSettlement is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    // This contract handles the settlements with ID 1 and 2.\r\n    uint32 constant public RENEX_SETTLEMENT_ID = 1;\r\n    uint32 constant public RENEX_ATOMIC_SETTLEMENT_ID = 2;\r\n\r\n    // Fees in RenEx are 0.2%. To represent this as integers, it is broken into\r\n    // a numerator and denominator.\r\n    uint256 constant public DARKNODE_FEES_NUMERATOR = 2;\r\n    uint256 constant public DARKNODE_FEES_DENOMINATOR = 1000;\r\n\r\n    // Constants used in the price / volume inputs.\r\n    int16 constant private PRICE_OFFSET = 12;\r\n    int16 constant private VOLUME_OFFSET = 12;\r\n\r\n    // Constructor parameters, updatable by the owner\r\n    Orderbook public orderbookContract;\r\n    RenExTokens public renExTokensContract;\r\n    RenExBalances public renExBalancesContract;\r\n    address public slasherAddress;\r\n    uint256 public submissionGasPriceLimit;\r\n\r\n    enum OrderStatus {None, Submitted, Settled, Slashed}\r\n\r\n    struct TokenPair {\r\n        RenExTokens.TokenDetails priorityToken;\r\n        RenExTokens.TokenDetails secondaryToken;\r\n    }\r\n\r\n    // A uint256 tuple representing a value and an associated fee\r\n    struct ValueWithFees {\r\n        uint256 value;\r\n        uint256 fees;\r\n    }\r\n\r\n    // A uint256 tuple representing a fraction\r\n    struct Fraction {\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n    }\r\n\r\n    // We use left and right because the tokens do not always represent the\r\n    // priority and secondary tokens.\r\n    struct SettlementDetails {\r\n        uint256 leftVolume;\r\n        uint256 rightVolume;\r\n        uint256 leftTokenFee;\r\n        uint256 rightTokenFee;\r\n        address leftTokenAddress;\r\n        address rightTokenAddress;\r\n    }\r\n\r\n    // Events\r\n    event LogOrderbookUpdated(Orderbook previousOrderbook, Orderbook nextOrderbook);\r\n    event LogRenExTokensUpdated(RenExTokens previousRenExTokens, RenExTokens nextRenExTokens);\r\n    event LogRenExBalancesUpdated(RenExBalances previousRenExBalances, RenExBalances nextRenExBalances);\r\n    event LogSubmissionGasPriceLimitUpdated(uint256 previousSubmissionGasPriceLimit, uint256 nextSubmissionGasPriceLimit);\r\n    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\r\n\r\n    // Order Storage\r\n    mapping(bytes32 => SettlementUtils.OrderDetails) public orderDetails;\r\n    mapping(bytes32 => address) public orderSubmitter;\r\n    mapping(bytes32 => OrderStatus) public orderStatus;\r\n\r\n    // Match storage (match details are indexed by [buyID][sellID])\r\n    mapping(bytes32 => mapping(bytes32 => uint256)) public matchTimestamp;\r\n\r\n    /// @notice Prevents a function from being called with a gas price higher\r\n    /// than the specified limit.\r\n    ///\r\n    /// @param _gasPriceLimit The gas price upper-limit in Wei.\r\n    modifier withGasPriceLimit(uint256 _gasPriceLimit) {\r\n        require(tx.gasprice <= _gasPriceLimit, \"gas price too high\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Restricts a function to only being called by the slasher\r\n    /// address.\r\n    modifier onlySlasher() {\r\n        require(msg.sender == slasherAddress, \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _orderbookContract The address of the Orderbook contract.\r\n    /// @param _renExBalancesContract The address of the RenExBalances\r\n    ///        contract.\r\n    /// @param _renExTokensContract The address of the RenExTokens contract.\r\n    constructor(\r\n        string _VERSION,\r\n        Orderbook _orderbookContract,\r\n        RenExTokens _renExTokensContract,\r\n        RenExBalances _renExBalancesContract,\r\n        address _slasherAddress,\r\n        uint256 _submissionGasPriceLimit\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        orderbookContract = _orderbookContract;\r\n        renExTokensContract = _renExTokensContract;\r\n        renExBalancesContract = _renExBalancesContract;\r\n        slasherAddress = _slasherAddress;\r\n        submissionGasPriceLimit = _submissionGasPriceLimit;\r\n    }\r\n\r\n    /// @notice The owner of the contract can update the Orderbook address.\r\n    /// @param _newOrderbookContract The address of the new Orderbook contract.\r\n    function updateOrderbook(Orderbook _newOrderbookContract) external onlyOwner {\r\n        emit LogOrderbookUpdated(orderbookContract, _newOrderbookContract);\r\n        orderbookContract = _newOrderbookContract;\r\n    }\r\n\r\n    /// @notice The owner of the contract can update the RenExTokens address.\r\n    /// @param _newRenExTokensContract The address of the new RenExTokens\r\n    ///       contract.\r\n    function updateRenExTokens(RenExTokens _newRenExTokensContract) external onlyOwner {\r\n        emit LogRenExTokensUpdated(renExTokensContract, _newRenExTokensContract);\r\n        renExTokensContract = _newRenExTokensContract;\r\n    }\r\n    \r\n    /// @notice The owner of the contract can update the RenExBalances address.\r\n    /// @param _newRenExBalancesContract The address of the new RenExBalances\r\n    ///       contract.\r\n    function updateRenExBalances(RenExBalances _newRenExBalancesContract) external onlyOwner {\r\n        emit LogRenExBalancesUpdated(renExBalancesContract, _newRenExBalancesContract);\r\n        renExBalancesContract = _newRenExBalancesContract;\r\n    }\r\n\r\n    /// @notice The owner of the contract can update the order submission gas\r\n    /// price limit.\r\n    /// @param _newSubmissionGasPriceLimit The new gas price limit.\r\n    function updateSubmissionGasPriceLimit(uint256 _newSubmissionGasPriceLimit) external onlyOwner {\r\n        emit LogSubmissionGasPriceLimitUpdated(submissionGasPriceLimit, _newSubmissionGasPriceLimit);\r\n        submissionGasPriceLimit = _newSubmissionGasPriceLimit;\r\n    }\r\n\r\n    /// @notice The owner of the contract can update the slasher address.\r\n    /// @param _newSlasherAddress The new slasher address.\r\n    function updateSlasher(address _newSlasherAddress) external onlyOwner {\r\n        emit LogSlasherUpdated(slasherAddress, _newSlasherAddress);\r\n        slasherAddress = _newSlasherAddress;\r\n    }\r\n\r\n    /// @notice Stores the details of an order.\r\n    ///\r\n    /// @param _prefix The miscellaneous details of the order required for\r\n    ///        calculating the order id.\r\n    /// @param _settlementID The settlement identifier.\r\n    /// @param _tokens The encoding of the token pair (buy token is encoded as\r\n    ///        the first 32 bytes and sell token is encoded as the last 32\r\n    ///        bytes).\r\n    /// @param _price The price of the order. Interpreted as the cost for 1\r\n    ///        standard unit of the non-priority token, in 1e12 (i.e.\r\n    ///        PRICE_OFFSET) units of the priority token).\r\n    /// @param _volume The volume of the order. Interpreted as the maximum\r\n    ///        number of 1e-12 (i.e. VOLUME_OFFSET) units of the non-priority\r\n    ///        token that can be traded by this order.\r\n    /// @param _minimumVolume The minimum volume the trader is willing to\r\n    ///        accept. Encoded the same as the volume.\r\n    function submitOrder(\r\n        bytes _prefix,\r\n        uint64 _settlementID,\r\n        uint64 _tokens,\r\n        uint256 _price,\r\n        uint256 _volume,\r\n        uint256 _minimumVolume\r\n    ) external withGasPriceLimit(submissionGasPriceLimit) {\r\n\r\n        SettlementUtils.OrderDetails memory order = SettlementUtils.OrderDetails({\r\n            settlementID: _settlementID,\r\n            tokens: _tokens,\r\n            price: _price,\r\n            volume: _volume,\r\n            minimumVolume: _minimumVolume\r\n        });\r\n        bytes32 orderID = SettlementUtils.hashOrder(_prefix, order);\r\n\r\n        require(orderStatus[orderID] == OrderStatus.None, \"order already submitted\");\r\n        require(orderbookContract.orderState(orderID) == Orderbook.OrderState.Confirmed, \"unconfirmed order\");\r\n\r\n        orderSubmitter[orderID] = msg.sender;\r\n        orderStatus[orderID] = OrderStatus.Submitted;\r\n        orderDetails[orderID] = order;\r\n    }\r\n\r\n    /// @notice Settles two orders that are matched. `submitOrder` must have been\r\n    /// called for each order before this function is called.\r\n    ///\r\n    /// @param _buyID The 32 byte ID of the buy order.\r\n    /// @param _sellID The 32 byte ID of the sell order.\r\n    function settle(bytes32 _buyID, bytes32 _sellID) external {\r\n        require(orderStatus[_buyID] == OrderStatus.Submitted, \"invalid buy status\");\r\n        require(orderStatus[_sellID] == OrderStatus.Submitted, \"invalid sell status\");\r\n\r\n        // Check the settlement ID (only have to check for one, since\r\n        // `verifyMatchDetails` checks that they are the same)\r\n        require(\r\n            orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID ||\r\n            orderDetails[_buyID].settlementID == RENEX_SETTLEMENT_ID,\r\n            \"invalid settlement id\"\r\n        );\r\n\r\n        // Verify that the two order details are compatible.\r\n        require(SettlementUtils.verifyMatchDetails(orderDetails[_buyID], orderDetails[_sellID]), \"incompatible orders\");\r\n\r\n        // Verify that the two orders have been confirmed to one another.\r\n        require(orderbookContract.orderMatch(_buyID) == _sellID, \"unconfirmed orders\");\r\n\r\n        // Retrieve token details.\r\n        TokenPair memory tokens = getTokenDetails(orderDetails[_buyID].tokens);\r\n\r\n        // Require that the tokens have been registered.\r\n        require(tokens.priorityToken.registered, \"unregistered priority token\");\r\n        require(tokens.secondaryToken.registered, \"unregistered secondary token\");\r\n\r\n        address buyer = orderbookContract.orderTrader(_buyID);\r\n        address seller = orderbookContract.orderTrader(_sellID);\r\n\r\n        require(buyer != seller, \"orders from same trader\");\r\n\r\n        execute(_buyID, _sellID, buyer, seller, tokens);\r\n\r\n        /* solium-disable-next-line security/no-block-members */\r\n        matchTimestamp[_buyID][_sellID] = now;\r\n\r\n        // Store that the orders have been settled.\r\n        orderStatus[_buyID] = OrderStatus.Settled;\r\n        orderStatus[_sellID] = OrderStatus.Settled;\r\n    }\r\n\r\n    /// @notice Slashes the bond of a guilty trader. This is called when an\r\n    /// atomic swap is not executed successfully.\r\n    /// To open an atomic order, a trader must have a balance equivalent to\r\n    /// 0.6% of the trade in the Ethereum-based token. 0.2% is always paid in\r\n    /// darknode fees when the order is matched. If the remaining amount is\r\n    /// is slashed, it is distributed as follows:\r\n    ///   1) 0.2% goes to the other trader, covering their fee\r\n    ///   2) 0.2% goes to the slasher address\r\n    /// Only one order in a match can be slashed.\r\n    ///\r\n    /// @param _guiltyOrderID The 32 byte ID of the order of the guilty trader.\r\n    function slash(bytes32 _guiltyOrderID) external onlySlasher {\r\n        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, \"slashing non-atomic trade\");\r\n\r\n        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);\r\n\r\n        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, \"invalid order status\");\r\n        require(orderStatus[innocentOrderID] == OrderStatus.Settled, \"invalid order status\");\r\n        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;\r\n\r\n        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ?\r\n            (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);\r\n\r\n        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);\r\n\r\n        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);\r\n\r\n        // Transfer the fee amount to the other trader\r\n        renExBalancesContract.transferBalanceWithFee(\r\n            orderbookContract.orderTrader(_guiltyOrderID),\r\n            orderbookContract.orderTrader(innocentOrderID),\r\n            settlementDetails.leftTokenAddress,\r\n            settlementDetails.leftTokenFee,\r\n            0,\r\n            0x0\r\n        );\r\n\r\n        // Transfer the fee amount to the slasher\r\n        renExBalancesContract.transferBalanceWithFee(\r\n            orderbookContract.orderTrader(_guiltyOrderID),\r\n            slasherAddress,\r\n            settlementDetails.leftTokenAddress,\r\n            settlementDetails.leftTokenFee,\r\n            0,\r\n            0x0\r\n        );\r\n    }\r\n\r\n    /// @notice Retrieves the settlement details of an order.\r\n    /// For atomic swaps, it returns the full volumes, not the settled fees.\r\n    ///\r\n    /// @param _orderID The order to lookup the details of. Can be the ID of a\r\n    ///        buy or a sell order.\r\n    /// @return [\r\n    ///     a boolean representing whether or not the order has been settled,\r\n    ///     a boolean representing whether or not the order is a buy\r\n    ///     the 32-byte order ID of the matched order\r\n    ///     the volume of the priority token,\r\n    ///     the volume of the secondary token,\r\n    ///     the fee paid in the priority token,\r\n    ///     the fee paid in the secondary token,\r\n    ///     the token code of the priority token,\r\n    ///     the token code of the secondary token\r\n    /// ]\r\n    function getMatchDetails(bytes32 _orderID)\r\n    external view returns (\r\n        bool settled,\r\n        bool orderIsBuy,\r\n        bytes32 matchedID,\r\n        uint256 priorityVolume,\r\n        uint256 secondaryVolume,\r\n        uint256 priorityFee,\r\n        uint256 secondaryFee,\r\n        uint32 priorityToken,\r\n        uint32 secondaryToken\r\n    ) {\r\n        matchedID = orderbookContract.orderMatch(_orderID);\r\n\r\n        orderIsBuy = isBuyOrder(_orderID);\r\n\r\n        (bytes32 buyID, bytes32 sellID) = orderIsBuy ?\r\n            (_orderID, matchedID) : (matchedID, _orderID);\r\n\r\n        SettlementDetails memory settlementDetails = calculateSettlementDetails(\r\n            buyID,\r\n            sellID,\r\n            getTokenDetails(orderDetails[buyID].tokens)\r\n        );\r\n\r\n        return (\r\n            orderStatus[_orderID] == OrderStatus.Settled || orderStatus[_orderID] == OrderStatus.Slashed,\r\n            orderIsBuy,\r\n            matchedID,\r\n            settlementDetails.leftVolume,\r\n            settlementDetails.rightVolume,\r\n            settlementDetails.leftTokenFee,\r\n            settlementDetails.rightTokenFee,\r\n            uint32(orderDetails[buyID].tokens >> 32),\r\n            uint32(orderDetails[buyID].tokens)\r\n        );\r\n    }\r\n\r\n    /// @notice Exposes the hashOrder function for computing a hash of an\r\n    /// order's details. An order hash is used as its ID. See `submitOrder`\r\n    /// for the parameter descriptions.\r\n    ///\r\n    /// @return The 32-byte hash of the order.\r\n    function hashOrder(\r\n        bytes _prefix,\r\n        uint64 _settlementID,\r\n        uint64 _tokens,\r\n        uint256 _price,\r\n        uint256 _volume,\r\n        uint256 _minimumVolume\r\n    ) external pure returns (bytes32) {\r\n        return SettlementUtils.hashOrder(_prefix, SettlementUtils.OrderDetails({\r\n            settlementID: _settlementID,\r\n            tokens: _tokens,\r\n            price: _price,\r\n            volume: _volume,\r\n            minimumVolume: _minimumVolume\r\n        }));\r\n    }\r\n\r\n    /// @notice Called by `settle`, executes the settlement for a RenEx order\r\n    /// or distributes the fees for a RenExAtomic swap.\r\n    ///\r\n    /// @param _buyID The 32 byte ID of the buy order.\r\n    /// @param _sellID The 32 byte ID of the sell order.\r\n    /// @param _buyer The address of the buy trader.\r\n    /// @param _seller The address of the sell trader.\r\n    /// @param _tokens The details of the priority and secondary tokens.\r\n    function execute(\r\n        bytes32 _buyID,\r\n        bytes32 _sellID,\r\n        address _buyer,\r\n        address _seller,\r\n        TokenPair memory _tokens\r\n    ) private {\r\n        // Calculate the fees for atomic swaps, and the settlement details\r\n        // otherwise.\r\n        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ?\r\n            settlementDetails = calculateAtomicFees(_buyID, _sellID, _tokens) :\r\n            settlementDetails = calculateSettlementDetails(_buyID, _sellID, _tokens);\r\n\r\n        // Transfer priority token value\r\n        renExBalancesContract.transferBalanceWithFee(\r\n            _buyer,\r\n            _seller,\r\n            settlementDetails.leftTokenAddress,\r\n            settlementDetails.leftVolume,\r\n            settlementDetails.leftTokenFee,\r\n            orderSubmitter[_buyID]\r\n        );\r\n\r\n        // Transfer secondary token value\r\n        renExBalancesContract.transferBalanceWithFee(\r\n            _seller,\r\n            _buyer,\r\n            settlementDetails.rightTokenAddress,\r\n            settlementDetails.rightVolume,\r\n            settlementDetails.rightTokenFee,\r\n            orderSubmitter[_sellID]\r\n        );\r\n    }\r\n\r\n    /// @notice Calculates the details required to execute two matched orders.\r\n    ///\r\n    /// @param _buyID The 32 byte ID of the buy order.\r\n    /// @param _sellID The 32 byte ID of the sell order.\r\n    /// @param _tokens The details of the priority and secondary tokens.\r\n    /// @return A struct containing the settlement details.\r\n    function calculateSettlementDetails(\r\n        bytes32 _buyID,\r\n        bytes32 _sellID,\r\n        TokenPair memory _tokens\r\n    ) private view returns (SettlementDetails memory) {\r\n\r\n        // Calculate the mid-price (using numerator and denominator to not loose\r\n        // precision).\r\n        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\r\n\r\n        // Calculate the lower of the two max volumes of each trader\r\n        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\r\n\r\n        uint256 priorityTokenVolume = joinFraction(\r\n            commonVolume.mul(midPrice.numerator),\r\n            midPrice.denominator,\r\n            int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\r\n        );\r\n        uint256 secondaryTokenVolume = joinFraction(\r\n            commonVolume,\r\n            1,\r\n            int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\r\n        );\r\n\r\n        // Calculate darknode fees\r\n        ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\r\n        ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\r\n\r\n        return SettlementDetails({\r\n            leftVolume: priorityVwF.value,\r\n            rightVolume: secondaryVwF.value,\r\n            leftTokenFee: priorityVwF.fees,\r\n            rightTokenFee: secondaryVwF.fees,\r\n            leftTokenAddress: _tokens.priorityToken.addr,\r\n            rightTokenAddress: _tokens.secondaryToken.addr\r\n        });\r\n    }\r\n\r\n    /// @notice Calculates the fees to be transferred for an atomic swap.\r\n    ///\r\n    /// @param _buyID The 32 byte ID of the buy order.\r\n    /// @param _sellID The 32 byte ID of the sell order.\r\n    /// @param _tokens The details of the priority and secondary tokens.\r\n    /// @return A struct containing the fee details.\r\n    function calculateAtomicFees(\r\n        bytes32 _buyID,\r\n        bytes32 _sellID,\r\n        TokenPair memory _tokens\r\n    ) private view returns (SettlementDetails memory) {\r\n\r\n        // Calculate the mid-price (using numerator and denominator to not loose\r\n        // precision).\r\n        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\r\n\r\n        // Calculate the lower of the two max volumes of each trader\r\n        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\r\n\r\n        if (isEthereumBased(_tokens.secondaryToken.addr)) {\r\n            uint256 secondaryTokenVolume = joinFraction(\r\n                commonVolume,\r\n                1,\r\n                int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\r\n            );\r\n\r\n            // Calculate darknode fees\r\n            ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\r\n\r\n            return SettlementDetails({\r\n                leftVolume: 0,\r\n                rightVolume: 0,\r\n                leftTokenFee: secondaryVwF.fees,\r\n                rightTokenFee: secondaryVwF.fees,\r\n                leftTokenAddress: _tokens.secondaryToken.addr,\r\n                rightTokenAddress: _tokens.secondaryToken.addr\r\n            });\r\n        } else if (isEthereumBased(_tokens.priorityToken.addr)) {\r\n            uint256 priorityTokenVolume = joinFraction(\r\n                commonVolume.mul(midPrice.numerator),\r\n                midPrice.denominator,\r\n                int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\r\n            );\r\n\r\n            // Calculate darknode fees\r\n            ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\r\n\r\n            return SettlementDetails({\r\n                leftVolume: 0,\r\n                rightVolume: 0,\r\n                leftTokenFee: priorityVwF.fees,\r\n                rightTokenFee: priorityVwF.fees,\r\n                leftTokenAddress: _tokens.priorityToken.addr,\r\n                rightTokenAddress: _tokens.priorityToken.addr\r\n            });\r\n        } else {\r\n            // Currently, at least one token must be Ethereum-based.\r\n            // This will be implemented in the future.\r\n            revert(\"non-eth atomic swaps are not supported\");\r\n        }\r\n    }\r\n\r\n    /// @notice Order parity is set by the order tokens are listed. This returns\r\n    /// whether an order is a buy or a sell.\r\n    /// @return true if _orderID is a buy order.\r\n    function isBuyOrder(bytes32 _orderID) private view returns (bool) {\r\n        uint64 tokens = orderDetails[_orderID].tokens;\r\n        uint32 firstToken = uint32(tokens >> 32);\r\n        uint32 secondaryToken = uint32(tokens);\r\n        return (firstToken < secondaryToken);\r\n    }\r\n\r\n    /// @return (value - fee, fee) where fee is 0.2% of value\r\n    function subtractDarknodeFee(uint256 _value) private pure returns (ValueWithFees memory) {\r\n        uint256 newValue = (_value * (DARKNODE_FEES_DENOMINATOR - DARKNODE_FEES_NUMERATOR)) / DARKNODE_FEES_DENOMINATOR;\r\n        return ValueWithFees(newValue, _value - newValue);\r\n    }\r\n\r\n    /// @notice Gets the order details of the priority and secondary token from\r\n    /// the RenExTokens contract and returns them as a single struct.\r\n    ///\r\n    /// @param _tokens The 64-bit combined token identifiers.\r\n    /// @return A TokenPair struct containing two TokenDetails structs.\r\n    function getTokenDetails(uint64 _tokens) private view returns (TokenPair memory) {\r\n        (\r\n            address priorityAddress,\r\n            uint8 priorityDecimals,\r\n            bool priorityRegistered\r\n        ) = renExTokensContract.tokens(uint32(_tokens >> 32));\r\n\r\n        (\r\n            address secondaryAddress,\r\n            uint8 secondaryDecimals,\r\n            bool secondaryRegistered\r\n        ) = renExTokensContract.tokens(uint32(_tokens));\r\n\r\n        return TokenPair({\r\n            priorityToken: RenExTokens.TokenDetails(priorityAddress, priorityDecimals, priorityRegistered),\r\n            secondaryToken: RenExTokens.TokenDetails(secondaryAddress, secondaryDecimals, secondaryRegistered)\r\n        });\r\n    }\r\n\r\n    /// @return true if _tokenAddress is 0x0, representing a token that is not\r\n    /// on Ethereum\r\n    function isEthereumBased(address _tokenAddress) private pure returns (bool) {\r\n        return (_tokenAddress != address(0x0));\r\n    }\r\n\r\n    /// @notice Computes (_numerator / _denominator) * 10 ** _scale\r\n    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {\r\n        if (_scale >= 0) {\r\n            // Check that (10**_scale) doesn't overflow\r\n            assert(_scale <= 77); // log10(2**256) = 77.06\r\n            return _numerator.mul(10 ** uint256(_scale)) / _denominator;\r\n        } else {\r\n            /// @dev If _scale is less than -77, 10**-_scale would overflow.\r\n            // For now, -_scale > -24 (when a token has 0 decimals and\r\n            // VOLUME_OFFSET and PRICE_OFFSET are each 12). It is unlikely these\r\n            // will be increased to add to more than 77.\r\n            // assert((-_scale) <= 77); // log10(2**256) = 77.06\r\n            return (_numerator / _denominator) / 10 ** uint256(-_scale);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRenExTokensContract\",\"type\":\"address\"}],\"name\":\"updateRenExTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"renExTokensContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"submissionGasPriceLimit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_orderID\",\"type\":\"bytes32\"}],\"name\":\"getMatchDetails\",\"outputs\":[{\"name\":\"settled\",\"type\":\"bool\"},{\"name\":\"orderIsBuy\",\"type\":\"bool\"},{\"name\":\"matchedID\",\"type\":\"bytes32\"},{\"name\":\"priorityVolume\",\"type\":\"uint256\"},{\"name\":\"secondaryVolume\",\"type\":\"uint256\"},{\"name\":\"priorityFee\",\"type\":\"uint256\"},{\"name\":\"secondaryFee\",\"type\":\"uint256\"},{\"name\":\"priorityToken\",\"type\":\"uint32\"},{\"name\":\"secondaryToken\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOrderbookContract\",\"type\":\"address\"}],\"name\":\"updateOrderbook\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSubmissionGasPriceLimit\",\"type\":\"uint256\"}],\"name\":\"updateSubmissionGasPriceLimit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DARKNODE_FEES_DENOMINATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderSubmitter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RENEX_ATOMIC_SETTLEMENT_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"orderDetails\",\"outputs\":[{\"name\":\"settlementID\",\"type\":\"uint64\"},{\"name\":\"tokens\",\"type\":\"uint64\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"volume\",\"type\":\"uint256\"},{\"name\":\"minimumVolume\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"matchTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DARKNODE_FEES_NUMERATOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSlasherAddress\",\"type\":\"address\"}],\"name\":\"updateSlasher\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_prefix\",\"type\":\"bytes\"},{\"name\":\"_settlementID\",\"type\":\"uint64\"},{\"name\":\"_tokens\",\"type\":\"uint64\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_volume\",\"type\":\"uint256\"},{\"name\":\"_minimumVolume\",\"type\":\"uint256\"}],\"name\":\"submitOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orderbookContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_prefix\",\"type\":\"bytes\"},{\"name\":\"_settlementID\",\"type\":\"uint64\"},{\"name\":\"_tokens\",\"type\":\"uint64\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_volume\",\"type\":\"uint256\"},{\"name\":\"_minimumVolume\",\"type\":\"uint256\"}],\"name\":\"hashOrder\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RENEX_SETTLEMENT_ID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyID\",\"type\":\"bytes32\"},{\"name\":\"_sellID\",\"type\":\"bytes32\"}],\"name\":\"settle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"slasherAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"renExBalancesContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRenExBalancesContract\",\"type\":\"address\"}],\"name\":\"updateRenExBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_guiltyOrderID\",\"type\":\"bytes32\"}],\"name\":\"slash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_VERSION\",\"type\":\"string\"},{\"name\":\"_orderbookContract\",\"type\":\"address\"},{\"name\":\"_renExTokensContract\",\"type\":\"address\"},{\"name\":\"_renExBalancesContract\",\"type\":\"address\"},{\"name\":\"_slasherAddress\",\"type\":\"address\"},{\"name\":\"_submissionGasPriceLimit\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousOrderbook\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nextOrderbook\",\"type\":\"address\"}],\"name\":\"LogOrderbookUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousRenExTokens\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nextRenExTokens\",\"type\":\"address\"}],\"name\":\"LogRenExTokensUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousRenExBalances\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nextRenExBalances\",\"type\":\"address\"}],\"name\":\"LogRenExBalancesUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousSubmissionGasPriceLimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nextSubmissionGasPriceLimit\",\"type\":\"uint256\"}],\"name\":\"LogSubmissionGasPriceLimitUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousSlasher\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nextSlasher\",\"type\":\"address\"}],\"name\":\"LogSlasherUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RenExSettlement","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000006b8bb175c092de7d81860b18db360b734a2598e00000000000000000000000007cade4fbc8761817bb62a080733d1b6cad744ec40000000000000000000000009636f9ac371ca0965b7c2b4ad13c4cc64d0ff2dc000000000000000000000000565839e16bac459884b0f0d7377ac04e04be150d00000000000000000000000000000000000000000000000000000002540be400000000000000000000000000000000000000000000000000000000000000000d6d61696e6e65742d312e302e3000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://de892bc3a482724b1414c2f8261454662d228dc9bf8c4e15a45d98e69f29278f"}]}