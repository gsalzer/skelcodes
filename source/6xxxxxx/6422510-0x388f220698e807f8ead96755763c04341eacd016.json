{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/// @title A facet of CSportsCore that holds all important constants and modifiers\r\n/// @author CryptoSports, Inc. (https://cryptosports.team))\r\n/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\r\ncontract CSportsConstants {\r\n\r\n    /// @dev The maximum # of marketing tokens that can ever be created\r\n    /// by the commissioner.\r\n    uint16 public MAX_MARKETING_TOKENS = 2500;\r\n\r\n    /// @dev The starting price for commissioner auctions (if the average\r\n    ///   of the last 2 is less than this, we will use this value)\r\n    ///   A finney is 1/1000 of an ether.\r\n    uint256 public COMMISSIONER_AUCTION_FLOOR_PRICE = 5 finney; // 5 finney for production, 15 for script testing and 1 finney for Rinkeby\r\n\r\n    /// @dev The duration of commissioner auctions\r\n    uint256 public COMMISSIONER_AUCTION_DURATION = 14 days; // 30 days for testing;\r\n\r\n    /// @dev Number of seconds in a week\r\n    uint32 constant WEEK_SECS = 1 weeks;\r\n\r\n}\r\n\r\n/// @title A facet of CSportsCore that manages an individual's authorized role against access privileges.\r\n/// @author CryptoSports, Inc. (https://cryptosports.team))\r\n/// @dev See the CSportsCore contract documentation to understand how the various CSports contract facets are arranged.\r\ncontract CSportsAuth is CSportsConstants {\r\n    // This facet controls access control for CryptoSports. There are four roles managed here:\r\n    //\r\n    //     - The CEO: The CEO can reassign other roles and change the addresses of our dependent smart\r\n    //         contracts. It is also the only role that can unpause the smart contract. It is initially\r\n    //         set to the address that created the smart contract in the CSportsCore constructor.\r\n    //\r\n    //     - The CFO: The CFO can withdraw funds from CSportsCore and its auction contracts.\r\n    //\r\n    //     - The COO: The COO can perform administrative functions.\r\n    //\r\n    //     - The Commisioner can perform \"oracle\" functions like adding new real world players,\r\n    //       setting players active/inactive, and scoring contests.\r\n    //\r\n\r\n    /// @dev Emited when contract is upgraded - See README.md for updgrade plan\r\n    event ContractUpgrade(address newContract);\r\n\r\n    /// The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n    address public cooAddress;\r\n    address public commissionerAddress;\r\n\r\n    /// @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    /// @dev Flag that identifies whether or not we are in development and should allow development\r\n    /// only functions to be called.\r\n    bool public isDevelopment = true;\r\n\r\n    /// @dev Access modifier to allow access to development mode functions\r\n    modifier onlyUnderDevelopment() {\r\n      require(isDevelopment == true);\r\n      _;\r\n    }\r\n\r\n    /// @dev Access modifier for CEO-only functionality\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for CFO-only functionality\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for COO-only functionality\r\n    modifier onlyCOO() {\r\n        require(msg.sender == cooAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Access modifier for Commissioner-only functionality\r\n    modifier onlyCommissioner() {\r\n        require(msg.sender == commissionerAddress);\r\n        _;\r\n    }\r\n\r\n    /// @dev Requires any one of the C level addresses\r\n    modifier onlyCLevel() {\r\n        require(\r\n            msg.sender == cooAddress ||\r\n            msg.sender == ceoAddress ||\r\n            msg.sender == cfoAddress ||\r\n            msg.sender == commissionerAddress\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev prevents contracts from hitting the method\r\n    modifier notContract() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0);\r\n        _;\r\n    }\r\n\r\n    /// @dev One way switch to set the contract into prodution mode. This is one\r\n    /// way in that the contract can never be set back into development mode. Calling\r\n    /// this function will block all future calls to functions that are meant for\r\n    /// access only while we are under development. It will also enable more strict\r\n    /// additional checking on various parameters and settings.\r\n    function setProduction() public onlyCEO onlyUnderDevelopment {\r\n      isDevelopment = false;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CEO. Only available to the current CEO.\r\n    /// @param _newCEO The address of the new CEO\r\n    function setCEO(address _newCEO) public onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the CFO. Only available to the current CEO.\r\n    /// @param _newCFO The address of the new CFO\r\n    function setCFO(address _newCFO) public onlyCEO {\r\n        require(_newCFO != address(0));\r\n\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the COO. Only available to the current CEO.\r\n    /// @param _newCOO The address of the new COO\r\n    function setCOO(address _newCOO) public onlyCEO {\r\n        require(_newCOO != address(0));\r\n\r\n        cooAddress = _newCOO;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Commissioner. Only available to the current CEO.\r\n    /// @param _newCommissioner The address of the new COO\r\n    function setCommissioner(address _newCommissioner) public onlyCEO {\r\n        require(_newCommissioner != address(0));\r\n\r\n        commissionerAddress = _newCommissioner;\r\n    }\r\n\r\n    /// @dev Assigns all C-Level addresses\r\n    /// @param _ceo CEO address\r\n    /// @param _cfo CFO address\r\n    /// @param _coo COO address\r\n    /// @param _commish Commissioner address\r\n    function setCLevelAddresses(address _ceo, address _cfo, address _coo, address _commish) public onlyCEO {\r\n        require(_ceo != address(0));\r\n        require(_cfo != address(0));\r\n        require(_coo != address(0));\r\n        require(_commish != address(0));\r\n        ceoAddress = _ceo;\r\n        cfoAddress = _cfo;\r\n        cooAddress = _coo;\r\n        commissionerAddress = _commish;\r\n    }\r\n\r\n    /// @dev Transfers the balance of this contract to the CFO\r\n    function withdrawBalance() external onlyCFO {\r\n        cfoAddress.transfer(address(this).balance);\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any \"C-level\" role to pause the contract. Used only when\r\n    ///  a bug or exploit is detected and we need to limit damage.\r\n    function pause() public onlyCLevel whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the CEO, since\r\n    ///  one reason we may pause the contract is when CFO or COO accounts are\r\n    ///  compromised.\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\n/// @dev Interface required by league roster contract to access\r\n/// the mintPlayers(...) function\r\ninterface CSportsRosterInterface {\r\n\r\n    /// @dev Called by core contract as a sanity check\r\n    function isLeagueRosterContract() external pure returns (bool);\r\n\r\n    /// @dev Called to indicate that a commissioner auction has completed\r\n    function commissionerAuctionComplete(uint32 _rosterIndex, uint128 _price) external;\r\n\r\n    /// @dev Called to indicate that a commissioner auction was canceled\r\n    function commissionerAuctionCancelled(uint32 _rosterIndex) external view;\r\n\r\n    /// @dev Returns the metadata for a specific real world player token\r\n    function getMetadata(uint128 _md5Token) external view returns (string);\r\n\r\n    /// @dev Called to return a roster index given the MD5\r\n    function getRealWorldPlayerRosterIndex(uint128 _md5Token) external view returns (uint128);\r\n\r\n    /// @dev Returns a player structure given its index\r\n    function realWorldPlayerFromIndex(uint128 idx) external view returns (uint128 md5Token, uint128 prevCommissionerSalePrice, uint64 lastMintedTime, uint32 mintedCount, bool hasActiveCommissionerAuction, bool mintingEnabled);\r\n\r\n    /// @dev Called to update a real world player entry - only used dureing development\r\n    function updateRealWorldPlayer(uint32 _rosterIndex, uint128 _prevCommissionerSalePrice, uint64 _lastMintedTime, uint32 _mintedCount, bool _hasActiveCommissionerAuction, bool _mintingEnabled) external;\r\n\r\n}\r\n\r\n/// @dev This is the data structure that holds a roster player in the CSportsLeagueRoster\r\n/// contract. Also referenced by CSportsCore.\r\n/// @author CryptoSports, Inc. (http://cryptosports.team)\r\ncontract CSportsRosterPlayer {\r\n\r\n    struct RealWorldPlayer {\r\n\r\n        // The player's certified identification. This is the md5 hash of\r\n        // {player's last name}-{player's first name}-{player's birthday in YYYY-MM-DD format}-{serial number}\r\n        // where the serial number is usually 0, but gives us an ability to deal with making\r\n        // sure all MD5s are unique.\r\n        uint128 md5Token;\r\n\r\n        // Stores the average sale price of the most recent 2 commissioner sales\r\n        uint128 prevCommissionerSalePrice;\r\n\r\n        // The last time this real world player was minted.\r\n        uint64 lastMintedTime;\r\n\r\n        // The number of PlayerTokens minted for this real world player\r\n        uint32 mintedCount;\r\n\r\n        // When true, there is an active auction for this player owned by\r\n        // the commissioner (indicating a gen0 minting auction is in progress)\r\n        bool hasActiveCommissionerAuction;\r\n\r\n        // Indicates this real world player can be actively minted\r\n        bool mintingEnabled;\r\n\r\n        // Any metadata we want to attach to this player (in JSON format)\r\n        string metadata;\r\n\r\n    }\r\n\r\n}\r\n\r\n/// @title CSportsTeam Interface\r\n/// @dev This interface defines methods required by the CSportsContestCore\r\n///   in implementing a contest.\r\n/// @author CryptoSports\r\ncontract CSportsTeam {\r\n\r\n    bool public isTeamContract;\r\n\r\n    /// @dev Define team events\r\n    event TeamCreated(uint256 teamId, address owner);\r\n    event TeamUpdated(uint256 teamId);\r\n    event TeamReleased(uint256 teamId);\r\n    event TeamScored(uint256 teamId, int32 score, uint32 place);\r\n    event TeamPaid(uint256 teamId);\r\n\r\n    function setCoreContractAddress(address _address) public;\r\n    function setLeagueRosterContractAddress(address _address) public;\r\n    function setContestContractAddress(address _address) public;\r\n    function createTeam(address _owner, uint32[] _tokenIds) public returns (uint32);\r\n    function updateTeam(address _owner, uint32 _teamId, uint8[] _indices, uint32[] _tokenIds) public;\r\n    function releaseTeam(uint32 _teamId) public;\r\n    function getTeamOwner(uint32 _teamId) public view returns (address);\r\n    function scoreTeams(uint32[] _teamIds, int32[] _scores, uint32[] _places) public;\r\n    function getScore(uint32 _teamId) public view returns (int32);\r\n    function getPlace(uint32 _teamId) public view returns (uint32);\r\n    function ownsPlayerTokens(uint32 _teamId) public view returns (bool);\r\n    function refunded(uint32 _teamId) public;\r\n    function tokenIdsForTeam(uint32 _teamId) public view returns (uint32, uint32[50]);\r\n    function getTeam(uint32 _teamId) public view returns (\r\n        address _owner,\r\n        int32 _score,\r\n        uint32 _place,\r\n        bool _holdsEntryFee,\r\n        bool _ownsPlayerTokens);\r\n}\r\n\r\n/// @title Base contract for CryptoSports. Holds all common structs, events and base variables.\r\n/// @author CryptoSports, Inc. (http://cryptosports.team)\r\n/// @dev See the CSportsCore contract documentation to understand how the various contract facets are arranged.\r\ncontract CSportsBase is CSportsAuth, CSportsRosterPlayer {\r\n\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\r\n\r\n    /// @dev This emits when a commissioner auction is successfully closed\r\n    event CommissionerAuctionSuccessful(uint256 tokenId, uint256 totalPrice, address winner);\r\n\r\n    /// @dev This emits when a commissioner auction is canceled\r\n    event CommissionerAuctionCanceled(uint256 tokenId);\r\n\r\n    /******************/\r\n    /*** DATA TYPES ***/\r\n    /******************/\r\n\r\n    /// @dev The main player token structure. Every released player in the League\r\n    ///  is represented by a single instance of this structure.\r\n    struct PlayerToken {\r\n\r\n      // @dev ID of the real world player this token represents. We can only have\r\n      // a max of 4,294,967,295 real world players, which seems to be enough for\r\n      // a while (haha)\r\n      uint32 realWorldPlayerId;\r\n\r\n      // @dev Serial number indicating the number of PlayerToken(s) for this\r\n      //  same realWorldPlayerId existed at the time this token was minted.\r\n      uint32 serialNumber;\r\n\r\n      // The timestamp from the block when this player token was minted.\r\n      uint64 mintedTime;\r\n\r\n      // The most recent sale price of the player token in an auction\r\n      uint128 mostRecentPrice;\r\n\r\n    }\r\n\r\n    /**************************/\r\n    /*** MAPPINGS (STORAGE) ***/\r\n    /**************************/\r\n\r\n    /// @dev A mapping from a PlayerToken ID to the address that owns it. All\r\n    /// PlayerTokens have an owner (newly minted PlayerTokens are owned by\r\n    /// the core contract).\r\n    mapping (uint256 => address) public playerTokenToOwner;\r\n\r\n    /// @dev Maps a PlayerToken ID to an address approved to take ownership.\r\n    mapping (uint256 => address) public playerTokenToApproved;\r\n\r\n    // @dev A mapping to a given address' tokens\r\n    mapping(address => uint32[]) public ownedTokens;\r\n\r\n    // @dev A mapping that relates a token id to an index into the\r\n    // ownedTokens[currentOwner] array.\r\n    mapping(uint32 => uint32) tokenToOwnedTokensIndex;\r\n\r\n    /// @dev Maps operators\r\n    mapping(address => mapping(address => bool)) operators;\r\n\r\n    // This mapping and corresponding uint16 represent marketing tokens\r\n    // that can be created by the commissioner (up to remainingMarketingTokens)\r\n    // and then given to third parties in the form of 4 words that sha256\r\n    // hash into the key for the mapping.\r\n    //\r\n    // Maps uint256(keccak256) => leagueRosterPlayerMD5\r\n    uint16 public remainingMarketingTokens = MAX_MARKETING_TOKENS;\r\n    mapping (uint256 => uint128) marketingTokens;\r\n\r\n    /***************/\r\n    /*** STORAGE ***/\r\n    /***************/\r\n\r\n    /// @dev Instance of our CSportsLeagueRoster contract. Can be set by\r\n    ///   the CEO only once because this immutable tie to the league roster\r\n    ///   is what relates a playerToken to a real world player. If we could\r\n    ///   update the leagueRosterContract, we could in effect de-value the\r\n    ///   ownership of a playerToken by switching the real world player it\r\n    ///   represents.\r\n    CSportsRosterInterface public leagueRosterContract;\r\n\r\n    /// @dev Addresses of team contract that is authorized to hold player\r\n    ///   tokens for contests.\r\n    CSportsTeam public teamContract;\r\n\r\n    /// @dev An array containing all PlayerTokens in existence.\r\n    PlayerToken[] public playerTokens;\r\n\r\n    /************************************/\r\n    /*** RESTRICTED C-LEVEL FUNCTIONS ***/\r\n    /************************************/\r\n\r\n    /// @dev Sets the reference to the CSportsLeagueRoster contract.\r\n    /// @param _address - Address of CSportsLeagueRoster contract.\r\n    function setLeagueRosterContractAddress(address _address) public onlyCEO {\r\n      // This method may only be called once to guarantee the immutable\r\n      // nature of owning a real world player.\r\n      if (!isDevelopment) {\r\n        require(leagueRosterContract == address(0));\r\n      }\r\n\r\n      CSportsRosterInterface candidateContract = CSportsRosterInterface(_address);\r\n      // NOTE: verify that a contract is what we expect (not foolproof, just\r\n      // a sanity check)\r\n      require(candidateContract.isLeagueRosterContract());\r\n      // Set the new contract address\r\n      leagueRosterContract = candidateContract;\r\n    }\r\n\r\n    /// @dev Adds an authorized team contract that can hold player tokens\r\n    ///   on behalf of a contest, and will return them to the original\r\n    ///   owner when the contest is complete (or if entry is canceled by\r\n    ///   the original owner, or if the contest is canceled).\r\n    function setTeamContractAddress(address _address) public onlyCEO {\r\n      CSportsTeam candidateContract = CSportsTeam(_address);\r\n      // NOTE: verify that a contract is what we expect (not foolproof, just\r\n      // a sanity check)\r\n      require(candidateContract.isTeamContract());\r\n      // Set the new contract address\r\n      teamContract = candidateContract;\r\n    }\r\n\r\n    /**************************/\r\n    /*** INTERNAL FUNCTIONS ***/\r\n    /**************************/\r\n\r\n    /// @dev Identifies whether or not the addressToTest is a contract or not\r\n    /// @param addressToTest The address we are interested in\r\n    function _isContract(address addressToTest) internal view returns (bool) {\r\n        uint size;\r\n        assembly {\r\n            size := extcodesize(addressToTest)\r\n        }\r\n        return (size > 0);\r\n    }\r\n\r\n    /// @dev Returns TRUE if the token exists\r\n    /// @param _tokenId ID to check\r\n    function _tokenExists(uint256 _tokenId) internal view returns (bool) {\r\n        return (_tokenId < playerTokens.length);\r\n    }\r\n\r\n    /// @dev An internal method that mints a new playerToken and stores it\r\n    ///   in the playerTokens array.\r\n    /// @param _realWorldPlayerId ID of the real world player to mint\r\n    /// @param _serialNumber - Indicates the number of playerTokens for _realWorldPlayerId\r\n    ///   that exist prior to this to-be-minted playerToken.\r\n    /// @param _owner - The owner of this newly minted playerToken\r\n    function _mintPlayer(uint32 _realWorldPlayerId, uint32 _serialNumber, address _owner) internal returns (uint32) {\r\n        // We are careful here to make sure the calling contract keeps within\r\n        // our structure's size constraints. Highly unlikely we would ever\r\n        // get to a point where these constraints would be a problem.\r\n        require(_realWorldPlayerId < 4294967295);\r\n        require(_serialNumber < 4294967295);\r\n\r\n        PlayerToken memory _player = PlayerToken({\r\n          realWorldPlayerId: _realWorldPlayerId,\r\n          serialNumber: _serialNumber,\r\n          mintedTime: uint64(now),\r\n          mostRecentPrice: 0\r\n        });\r\n\r\n        uint256 newPlayerTokenId = playerTokens.push(_player) - 1;\r\n\r\n        // It's probably never going to happen, 4 billion playerToken(s) is A LOT, but\r\n        // let's just be 100% sure we never let this happen.\r\n        require(newPlayerTokenId < 4294967295);\r\n\r\n        // This will assign ownership, and also emit the Transfer event as\r\n        // per ERC721 draft\r\n        _transfer(0, _owner, newPlayerTokenId);\r\n\r\n        return uint32(newPlayerTokenId);\r\n    }\r\n\r\n    /// @dev Removes a token (specified by ID) from ownedTokens and\r\n    /// tokenToOwnedTokensIndex mappings for a given address.\r\n    /// @param _from Address to remove from\r\n    /// @param _tokenId ID of token to remove\r\n    function _removeTokenFrom(address _from, uint256 _tokenId) internal {\r\n\r\n      // Grab the index into the _from owner's ownedTokens array\r\n      uint32 fromIndex = tokenToOwnedTokensIndex[uint32(_tokenId)];\r\n\r\n      // Remove the _tokenId from ownedTokens[_from] array\r\n      uint lastIndex = ownedTokens[_from].length - 1;\r\n      uint32 lastToken = ownedTokens[_from][lastIndex];\r\n\r\n      // Swap the last token into the fromIndex position (which is _tokenId's\r\n      // location in the ownedTokens array) and shorten the array\r\n      ownedTokens[_from][fromIndex] = lastToken;\r\n      ownedTokens[_from].length--;\r\n\r\n      // Since we moved lastToken, we need to update its\r\n      // entry in the tokenToOwnedTokensIndex\r\n      tokenToOwnedTokensIndex[lastToken] = fromIndex;\r\n\r\n      // _tokenId is no longer mapped\r\n      tokenToOwnedTokensIndex[uint32(_tokenId)] = 0;\r\n\r\n    }\r\n\r\n    /// @dev Adds a token (specified by ID) to ownedTokens and\r\n    /// tokenToOwnedTokensIndex mappings for a given address.\r\n    /// @param _to Address to add to\r\n    /// @param _tokenId ID of token to remove\r\n    function _addTokenTo(address _to, uint256 _tokenId) internal {\r\n      uint32 toIndex = uint32(ownedTokens[_to].push(uint32(_tokenId))) - 1;\r\n      tokenToOwnedTokensIndex[uint32(_tokenId)] = toIndex;\r\n    }\r\n\r\n    /// @dev Assigns ownership of a specific PlayerToken to an address.\r\n    /// @param _from - Address of who this transfer is from\r\n    /// @param _to - Address of who to tranfer to\r\n    /// @param _tokenId - The ID of the playerToken to transfer\r\n    function _transfer(address _from, address _to, uint256 _tokenId) internal {\r\n\r\n        // transfer ownership\r\n        playerTokenToOwner[_tokenId] = _to;\r\n\r\n        // When minting brand new PlayerTokens, the _from is 0x0, but we don't deal with\r\n        // owned tokens for the 0x0 address.\r\n        if (_from != address(0)) {\r\n\r\n            // Remove the _tokenId from ownedTokens[_from] array (remove first because\r\n            // this method will zero out the tokenToOwnedTokensIndex[_tokenId], which would\r\n            // stomp on the _addTokenTo setting of this value)\r\n            _removeTokenFrom(_from, _tokenId);\r\n\r\n            // Clear our approved mapping for this token\r\n            delete playerTokenToApproved[_tokenId];\r\n        }\r\n\r\n        // Now add the token to the _to address' ownership structures\r\n        _addTokenTo(_to, _tokenId);\r\n\r\n        // Emit the transfer event.\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    /// @dev Converts a uint to its string equivalent\r\n    /// @param v uint to convert\r\n    function uintToString(uint v) internal pure returns (string str) {\r\n      bytes32 b32 = uintToBytes32(v);\r\n      str = bytes32ToString(b32);\r\n    }\r\n\r\n    /// @dev Converts a uint to a bytes32\r\n    /// @param v uint to convert\r\n    function uintToBytes32(uint v) internal pure returns (bytes32 ret) {\r\n        if (v == 0) {\r\n            ret = '0';\r\n        }\r\n        else {\r\n            while (v > 0) {\r\n                ret = bytes32(uint(ret) / (2 ** 8));\r\n                ret |= bytes32(((v % 10) + 48) * 2 ** (8 * 31));\r\n                v /= 10;\r\n            }\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /// @dev Converts bytes32 to a string\r\n    /// @param data bytes32 to convert\r\n    function bytes32ToString (bytes32 data) internal pure returns (string) {\r\n\r\n        uint count = 0;\r\n        bytes memory bytesString = new bytes(32); //  = new bytes[]; //(32);\r\n        for (uint j=0; j<32; j++) {\r\n            byte char = byte(bytes32(uint(data) * 2 ** (8 * j)));\r\n            if (char != 0) {\r\n                bytesString[j] = char;\r\n                count++;\r\n            } else {\r\n              break;\r\n            }\r\n        }\r\n\r\n        bytes memory s = new bytes(count);\r\n        for (j = 0; j < count; j++) {\r\n            s[j] = bytesString[j];\r\n        }\r\n        return string(s);\r\n\r\n    }\r\n\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd.\r\ninterface ERC721 /* is ERC165 */ {\r\n    /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n    ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n    ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n    ///  may be created and assigned without emitting Transfer. At the time of\r\n    ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n    ///\r\n    /// MOVED THIS TO CSportsBase because of how class structure is derived.\r\n    ///\r\n    event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when the approved address for an NFT is changed or\r\n    ///  reaffirmed. The zero address indicates there is no approved address.\r\n    ///  When a Transfer event emits, this also indicates that the approved\r\n    ///  address for that NFT (if any) is reset to none.\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n    /// @dev This emits when an operator is enabled or disabled for an owner.\r\n    ///  The operator can manage all NFTs of the owner.\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    /// @notice Count all NFTs assigned to an owner\r\n    /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n    ///  function throws for queries about the zero address.\r\n    /// @param _owner An address for whom to query the balance\r\n    /// @return The number of NFTs owned by `_owner`, possibly zero\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n\r\n    /// @notice Find the owner of an NFT\r\n    /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n    ///  about them do throw.\r\n    /// @param _tokenId The identifier for an NFT\r\n    /// @return The address of the owner of the NFT\r\n    function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n    ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n    ///  `onERC721Received` on `_to` and throws if the return value is not\r\n    ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    /// @param data Additional data with no specified format, sent in call to `_to`\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n\r\n    /// @notice Transfers the ownership of an NFT from one address to another address\r\n    /// @dev This works identically to the other function with an extra data parameter,\r\n    ///  except this function just sets data to \"\".\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n    ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n    ///  THEY MAY BE PERMANENTLY LOST\r\n    /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n    ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n    ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n    ///  `_tokenId` is not a valid NFT.\r\n    /// @param _from The current owner of the NFT\r\n    /// @param _to The new owner\r\n    /// @param _tokenId The NFT to transfer\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Change or reaffirm the approved address for an NFT\r\n    /// @dev The zero address indicates there is no approved address.\r\n    ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n    ///  operator of the current owner.\r\n    /// @param _approved The new approved NFT controller\r\n    /// @param _tokenId The NFT to approve\r\n    function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n    /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n    ///  all of `msg.sender`'s assets\r\n    /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n    ///  multiple operators per owner.\r\n    /// @param _operator Address to add to the set of authorized operators\r\n    /// @param _approved True if the operator is approved, false to revoke approval\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n    /// @notice Get the approved address for a single NFT\r\n    /// @dev Throws if `_tokenId` is not a valid NFT.\r\n    /// @param _tokenId The NFT to find the approved address for\r\n    /// @return The approved address for this NFT, or the zero address if there is none\r\n    function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n    /// @notice Query if an address is an authorized operator for another address\r\n    /// @param _owner The address that owns the NFTs\r\n    /// @param _operator The address that acts on behalf of the owner\r\n    /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n    function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface ERC721Metadata /* is ERC721 */ {\r\n    /// @notice A descriptive name for a collection of NFTs in this contract\r\n    function name() external view returns (string _name);\r\n\r\n    /// @notice An abbreviated name for NFTs in this contract\r\n    function symbol() external view returns (string _symbol);\r\n\r\n    /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n    /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n    ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n    ///  Metadata JSON Schema\".\r\n    function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface ERC721Enumerable /* is ERC721 */ {\r\n    /// @notice Count NFTs tracked by this contract\r\n    /// @return A count of valid NFTs tracked by this contract, where each one of\r\n    ///  them has an assigned and queryable owner not equal to the zero address\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    /// @notice Enumerate valid NFTs\r\n    /// @dev Throws if `_index` >= `totalSupply()`.\r\n    /// @param _index A counter less than `totalSupply()`\r\n    /// @return The token identifier for the `_index`th NFT,\r\n    ///  (sort order not specified)\r\n    function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n    /// @notice Enumerate NFTs assigned to an owner\r\n    /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n    ///  `_owner` is the zero address, representing invalid NFTs.\r\n    /// @param _owner An address where we are interested in NFTs owned by them\r\n    /// @param _index A counter less than `balanceOf(_owner)`\r\n    /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n    ///   (sort order not specified)\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface ERC721TokenReceiver {\r\n    /// @notice Handle the receipt of an NFT\r\n    /// @dev The ERC721 smart contract calls this function on the recipient\r\n    ///  after a `transfer`. This function MAY throw to revert and reject the\r\n    ///  transfer. Return of other than the magic value MUST result in the\r\n    ///  transaction being reverted.\r\n    ///  Note: the contract address is always the message sender.\r\n    /// @param _operator The address which called `safeTransferFrom` function\r\n    /// @param _from The address which previously owned the token\r\n    /// @param _tokenId The NFT identifier which is being transferred\r\n    /// @param _data Additional data with no specified format\r\n    /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n    ///  unless throwing\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\ninterface ERC165 {\r\n    /// @notice Query if a contract implements an interface\r\n    /// @param interfaceID The interface identifier, as specified in ERC-165\r\n    /// @dev Interface identification is specified in ERC-165. This function\r\n    ///  uses less than 30,000 gas.\r\n    /// @return `true` if the contract implements `interfaceID` and\r\n    ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n    function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\n/// @title The facet of the CSports core contract that manages ownership, ERC-721 compliant.\r\n/// @author CryptoSports, Inc. (http://cryptosports.team)\r\n/// @dev Ref: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md#specification\r\n/// See the CSportsCore contract documentation to understand how the various contract facets are arranged.\r\ncontract CSportsOwnership is CSportsBase {\r\n\r\n  /// @notice These are set in the contract constructor at deployment time\r\n  string _name;\r\n  string _symbol;\r\n  string _tokenURI;\r\n\r\n  // bool public implementsERC721 = true;\r\n  //\r\n  function implementsERC721() public pure returns (bool)\r\n  {\r\n      return true;\r\n  }\r\n\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external view returns (string) {\r\n    return _name;\r\n  }\r\n\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() external view returns (string) {\r\n    return _symbol;\r\n  }\r\n\r\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n  ///  Metadata JSON Schema\".\r\n  function tokenURI(uint256 _tokenId) external view returns (string ret) {\r\n    string memory tokenIdAsString = uintToString(uint(_tokenId));\r\n    ret = string (abi.encodePacked(_tokenURI, tokenIdAsString, \"/\"));\r\n  }\r\n\r\n  /// @notice Find the owner of an NFT\r\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n  ///  about them do throw.\r\n  /// @param _tokenId The identifier for an NFT\r\n  /// @return The address of the owner of the NFT\r\n  function ownerOf(uint256 _tokenId)\r\n      public\r\n      view\r\n      returns (address owner)\r\n  {\r\n      owner = playerTokenToOwner[_tokenId];\r\n      require(owner != address(0));\r\n  }\r\n\r\n  /// @notice Count all NFTs assigned to an owner\r\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n  ///  function throws for queries about the zero address.\r\n  /// @param _owner An address for whom to query the balance\r\n  /// @return The number of NFTs owned by `_owner`, possibly zero\r\n  function balanceOf(address _owner) public view returns (uint256 count) {\r\n      // I am not a big fan of  referencing a property on an array element\r\n      // that may not exist. But if it does not exist, Solidity will return 0\r\n      // which is right.\r\n      return ownedTokens[_owner].length;\r\n  }\r\n\r\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n  ///  THEY MAY BE PERMANENTLY LOST\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  `_tokenId` is not a valid NFT.\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  function transferFrom(\r\n      address _from,\r\n      address _to,\r\n      uint256 _tokenId\r\n  )\r\n      public\r\n      whenNotPaused\r\n  {\r\n      require(_to != address(0));\r\n      require (_tokenExists(_tokenId));\r\n\r\n      // Check for approval and valid ownership\r\n      require(_approvedFor(_to, _tokenId));\r\n      require(_owns(_from, _tokenId));\r\n\r\n      // Validate the sender\r\n      require(_owns(msg.sender, _tokenId) || // sender owns the token\r\n             (msg.sender == playerTokenToApproved[_tokenId]) || // sender is the approved address\r\n             operators[_from][msg.sender]); // sender is an authorized operator for this token\r\n\r\n      // Reassign ownership (also clears pending approvals and emits Transfer event).\r\n      _transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  /// @notice Transfer ownership of a batch of NFTs -- THE CALLER IS RESPONSIBLE\r\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n  ///  THEY MAY BE PERMANENTLY LOST\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for all NFTs. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  any `_tokenId` is not a valid NFT.\r\n  /// @param _from - Current owner of the token being authorized for transfer\r\n  /// @param _to - Address we are transferring to\r\n  /// @param _tokenIds The IDs of the PlayerTokens that can be transferred if this call succeeds.\r\n  function batchTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint32[] _tokenIds\r\n  )\r\n  public\r\n  whenNotPaused\r\n  {\r\n    for (uint32 i = 0; i < _tokenIds.length; i++) {\r\n\r\n        uint32 _tokenId = _tokenIds[i];\r\n\r\n        // Check for approval and valid ownership\r\n        require(_approvedFor(_to, _tokenId));\r\n        require(_owns(_from, _tokenId));\r\n\r\n        // Validate the sender\r\n        require(_owns(msg.sender, _tokenId) || // sender owns the token\r\n        (msg.sender == playerTokenToApproved[_tokenId]) || // sender is the approved address\r\n        operators[_from][msg.sender]); // sender is an authorized operator for this token\r\n\r\n        // Reassign ownership, clear pending approvals (not necessary here),\r\n        // and emit Transfer event.\r\n        _transfer(_from, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /// @notice Change or reaffirm the approved address for an NFT\r\n  /// @dev The zero address indicates there is no approved address.\r\n  ///  Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n  ///  operator of the current owner.\r\n  /// @param _to The new approved NFT controller\r\n  /// @param _tokenId The NFT to approve\r\n  function approve(\r\n      address _to,\r\n      uint256 _tokenId\r\n  )\r\n      public\r\n      whenNotPaused\r\n  {\r\n      address owner = ownerOf(_tokenId);\r\n      require(_to != owner);\r\n\r\n      // Only an owner or authorized operator can grant transfer approval.\r\n      require((msg.sender == owner) || (operators[ownerOf(_tokenId)][msg.sender]));\r\n\r\n      // Register the approval (replacing any previous approval).\r\n      _approve(_tokenId, _to);\r\n\r\n      // Emit approval event.\r\n      emit Approval(msg.sender, _to, _tokenId);\r\n  }\r\n\r\n  /// @notice Change or reaffirm the approved address for an NFT\r\n  /// @dev The zero address indicates there is no approved address.\r\n  /// Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n  /// operator of the current owner.\r\n  /// @param _to The address to be granted transfer approval. Pass address(0) to\r\n  ///  clear all approvals.\r\n  /// @param _tokenIds The IDs of the PlayerTokens that can be transferred if this call succeeds.\r\n  function batchApprove(\r\n        address _to,\r\n        uint32[] _tokenIds\r\n  )\r\n  public\r\n  whenNotPaused\r\n  {\r\n    for (uint32 i = 0; i < _tokenIds.length; i++) {\r\n\r\n        uint32 _tokenId = _tokenIds[i];\r\n\r\n        // Only an owner or authorized operator can grant transfer approval.\r\n        require(_owns(msg.sender, _tokenId) || (operators[ownerOf(_tokenId)][msg.sender]));\r\n\r\n        // Register the approval (replacing any previous approval).\r\n        _approve(_tokenId, _to);\r\n\r\n        // Emit approval event.\r\n        emit Approval(msg.sender, _to, _tokenId);\r\n    }\r\n  }\r\n\r\n  /// @notice Escrows all of the tokensIds passed by transfering ownership\r\n  ///   to the teamContract. CAN ONLY BE CALLED BY THE CURRENT TEAM CONTRACT.\r\n  /// @param _owner - Current owner of the token being authorized for transfer\r\n  /// @param _tokenIds The IDs of the PlayerTokens that can be transferred if this call succeeds.\r\n  function batchEscrowToTeamContract(\r\n    address _owner,\r\n    uint32[] _tokenIds\r\n  )\r\n    public\r\n    whenNotPaused\r\n  {\r\n    require(teamContract != address(0));\r\n    require(msg.sender == address(teamContract));\r\n\r\n    for (uint32 i = 0; i < _tokenIds.length; i++) {\r\n\r\n      uint32 _tokenId = _tokenIds[i];\r\n\r\n      // Only an owner can transfer the token.\r\n      require(_owns(_owner, _tokenId));\r\n\r\n      // Reassign ownership, clear pending approvals (not necessary here),\r\n      // and emit Transfer event.\r\n      _transfer(_owner, teamContract, _tokenId);\r\n    }\r\n  }\r\n\r\n  bytes4 constant TOKEN_RECEIVED_SIG = bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"));\r\n\r\n  /// @notice Transfers the ownership of an NFT from one address to another address\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  ///  `onERC721Received` on `_to` and throws if the return value is not\r\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  /// @param data Additional data with no specified format, sent in call to `_to`\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable {\r\n    transferFrom(_from, _to, _tokenId);\r\n    if (_isContract(_to)) {\r\n        ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\r\n        bytes4 response = receiver.onERC721Received.gas(50000)(msg.sender, _from, _tokenId, data);\r\n        require(response == TOKEN_RECEIVED_SIG);\r\n    }\r\n  }\r\n\r\n  /// @notice Transfers the ownership of an NFT from one address to another address\r\n  /// @dev This works identically to the other function with an extra data parameter,\r\n  ///  except this function just sets data to \"\".\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n    require(_to != address(0));\r\n    transferFrom(_from, _to, _tokenId);\r\n    if (_isContract(_to)) {\r\n        ERC721TokenReceiver receiver = ERC721TokenReceiver(_to);\r\n        bytes4 response = receiver.onERC721Received.gas(50000)(msg.sender, _from, _tokenId, \"\");\r\n        require(response == TOKEN_RECEIVED_SIG);\r\n    }\r\n  }\r\n\r\n  /// @notice Count NFTs tracked by this contract\r\n  /// @return A count of valid NFTs tracked by this contract, where each one of\r\n  ///  them has an assigned and queryable owner not equal to the zero address\r\n  function totalSupply() public view returns (uint) {\r\n      return playerTokens.length;\r\n  }\r\n\r\n  /// @notice Enumerate NFTs assigned to an owner\r\n  /// @dev Throws if `index` >= `balanceOf(owner)` or if\r\n  ///  `owner` is the zero address, representing invalid NFTs.\r\n  /// @param owner An address where we are interested in NFTs owned by them\r\n  /// @param index A counter less than `balanceOf(owner)`\r\n  /// @return The token identifier for the `index`th NFT assigned to `owner`,\r\n  ///   (sort order not specified)\r\n  function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256 _tokenId) {\r\n      require(owner != address(0));\r\n      require(index < balanceOf(owner));\r\n      return ownedTokens[owner][index];\r\n  }\r\n\r\n  /// @notice Enumerate valid NFTs\r\n  /// @dev Throws if `index` >= `totalSupply()`.\r\n  /// @param index A counter less than `totalSupply()`\r\n  /// @return The token identifier for the `index`th NFT,\r\n  ///  (sort order not specified)\r\n  function tokenByIndex(uint256 index) external view returns (uint256) {\r\n      require (_tokenExists(index));\r\n      return index;\r\n  }\r\n\r\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n  ///  all of `msg.sender`'s assets\r\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n  ///  multiple operators per owner.\r\n  /// @param _operator Address to add to the set of authorized operators\r\n  /// @param _approved True if the operator is approved, false to revoke approval\r\n  function setApprovalForAll(address _operator, bool _approved) external {\r\n        require(_operator != msg.sender);\r\n        operators[msg.sender][_operator] = _approved;\r\n        emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  /// @notice Get the approved address for a single NFT\r\n  /// @dev Throws if `_tokenId` is not a valid NFT.\r\n  /// @param _tokenId The NFT to find the approved address for\r\n  /// @return The approved address for this NFT, or the zero address if there is none\r\n  function getApproved(uint256 _tokenId) external view returns (address) {\r\n      require(_tokenExists(_tokenId));\r\n      return playerTokenToApproved[_tokenId];\r\n  }\r\n\r\n  /// @notice Query if a contract implements an interface\r\n  /// @param interfaceID The interface identifier, as specified in ERC-165\r\n  /// @dev Interface identification is specified in ERC-165. This function\r\n  ///  uses less than 30,000 gas.\r\n  /// @return `true` if the contract implements `interfaceID` and\r\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n  function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\r\n      return (\r\n          interfaceID == this.supportsInterface.selector || // ERC165\r\n          interfaceID == 0x5b5e139f || // ERC721Metadata\r\n          interfaceID == 0x80ac58cd || // ERC-721\r\n          interfaceID == 0x780e9d63);  // ERC721Enumerable\r\n  }\r\n\r\n  // Internal utility functions: These functions all assume that their input arguments\r\n  // are valid. We leave it to public methods to sanitize their inputs and follow\r\n  // the required logic.\r\n\r\n  /// @dev Checks if a given address is the current owner of a particular PlayerToken.\r\n  /// @param _claimant the address we are validating against.\r\n  /// @param _tokenId kitten id, only valid when > 0\r\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n      return playerTokenToOwner[_tokenId] == _claimant;\r\n  }\r\n\r\n  /// @dev Checks if a given address currently has transferApproval for a particular PlayerToken.\r\n  /// @param _claimant the address we are confirming PlayerToken is approved for.\r\n  /// @param _tokenId PlayerToken id, only valid when > 0\r\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\r\n      return playerTokenToApproved[_tokenId] == _claimant;\r\n  }\r\n\r\n  /// @dev Marks an address as being approved for transferFrom(), overwriting any previous\r\n  ///  approval. Setting _approved to address(0) clears all transfer approval.\r\n  ///  NOTE: _approve() does NOT send the Approval event. This is intentional because\r\n  ///  _approve() and transferFrom() are used together for putting PlayerToken on auction, and\r\n  ///  there is no value in spamming the log with Approval events in that case.\r\n  function _approve(uint256 _tokenId, address _approved) internal {\r\n      playerTokenToApproved[_tokenId] = _approved;\r\n  }\r\n\r\n}\r\n\r\n/// @dev Interface to the sale clock auction contract\r\ninterface CSportsAuctionInterface {\r\n\r\n    /// @dev Sanity check that allows us to ensure that we are pointing to the\r\n    ///  right auction in our setSaleAuctionAddress() call.\r\n    function isSaleClockAuction() external pure returns (bool);\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of auction (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    ) external;\r\n\r\n    /// @dev Reprices (and updates duration) of an array of tokens that are currently\r\n    /// being auctioned by this contract.\r\n    /// @param _tokenIds Array of tokenIds corresponding to auctions being updated\r\n    /// @param _startingPrices New starting prices\r\n    /// @param _endingPrices New ending price\r\n    /// @param _duration New duration\r\n    /// @param _seller Address of the seller in all specified auctions to be updated\r\n    function repriceAuctions(\r\n        uint256[] _tokenIds,\r\n        uint256[] _startingPrices,\r\n        uint256[] _endingPrices,\r\n        uint256 _duration,\r\n        address _seller\r\n    ) external;\r\n\r\n    /// @dev Cancels an auction that hasn't been won yet by calling\r\n    ///   the super(...) and then notifying any listener.\r\n    /// @param _tokenId - ID of token on auction\r\n    function cancelAuction(uint256 _tokenId) external;\r\n\r\n    /// @dev Withdraw the total contract balance to the core contract\r\n    function withdrawBalance() external;\r\n\r\n}\r\n\r\n/// @title Interface to allow a contract to listen to auction events.\r\ncontract SaleClockAuctionListener {\r\n    function implementsSaleClockAuctionListener() public pure returns (bool);\r\n    function auctionCreated(uint256 tokenId, address seller, uint128 startingPrice, uint128 endingPrice, uint64 duration) public;\r\n    function auctionSuccessful(uint256 tokenId, uint128 totalPrice, address seller, address buyer) public;\r\n    function auctionCancelled(uint256 tokenId, address seller) public;\r\n}\r\n\r\n/// @title The facet of the CSports core contract that manages interfacing with auctions\r\n/// @author CryptoSports, Inc. (http://cryptosports.team)\r\n/// See the CSportsCore contract documentation to understand how the various contract facets are arranged.\r\ncontract CSportsAuction is CSportsOwnership, SaleClockAuctionListener {\r\n\r\n  // Holds a reference to our saleClockAuctionContract\r\n  CSportsAuctionInterface public saleClockAuctionContract;\r\n\r\n  /// @dev SaleClockAuctionLIstener interface method concrete implementation\r\n  function implementsSaleClockAuctionListener() public pure returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /// @dev SaleClockAuctionLIstener interface method concrete implementation\r\n  function auctionCreated(uint256 /* tokenId */, address /* seller */, uint128 /* startingPrice */, uint128 /* endingPrice */, uint64 /* duration */) public {\r\n    require (saleClockAuctionContract != address(0));\r\n    require (msg.sender == address(saleClockAuctionContract));\r\n  }\r\n\r\n  /// @dev SaleClockAuctionLIstener interface method concrete implementation\r\n  /// @param tokenId - ID of the token whose auction successfully completed\r\n  /// @param totalPrice - Price at which the auction closed at\r\n  /// @param seller - Account address of the auction seller\r\n  /// @param winner - Account address of the auction winner (buyer)\r\n  function auctionSuccessful(uint256 tokenId, uint128 totalPrice, address seller, address winner) public {\r\n    require (saleClockAuctionContract != address(0));\r\n    require (msg.sender == address(saleClockAuctionContract));\r\n\r\n    // Record the most recent sale price to the token\r\n    PlayerToken storage _playerToken = playerTokens[tokenId];\r\n    _playerToken.mostRecentPrice = totalPrice;\r\n\r\n    if (seller == address(this)) {\r\n      // We completed a commissioner auction!\r\n      leagueRosterContract.commissionerAuctionComplete(playerTokens[tokenId].realWorldPlayerId, totalPrice);\r\n      emit CommissionerAuctionSuccessful(tokenId, totalPrice, winner);\r\n    }\r\n  }\r\n\r\n  /// @dev SaleClockAuctionLIstener interface method concrete implementation\r\n  /// @param tokenId - ID of the token whose auction was cancelled\r\n  /// @param seller - Account address of seller who decided to cancel the auction\r\n  function auctionCancelled(uint256 tokenId, address seller) public {\r\n    require (saleClockAuctionContract != address(0));\r\n    require (msg.sender == address(saleClockAuctionContract));\r\n    if (seller == address(this)) {\r\n      // We cancelled a commissioner auction!\r\n      leagueRosterContract.commissionerAuctionCancelled(playerTokens[tokenId].realWorldPlayerId);\r\n      emit CommissionerAuctionCanceled(tokenId);\r\n    }\r\n  }\r\n\r\n  /// @dev Sets the reference to the sale auction.\r\n  /// @param _address - Address of sale contract.\r\n  function setSaleAuctionContractAddress(address _address) public onlyCEO {\r\n\r\n      require(_address != address(0));\r\n\r\n      CSportsAuctionInterface candidateContract = CSportsAuctionInterface(_address);\r\n\r\n      // Sanity check\r\n      require(candidateContract.isSaleClockAuction());\r\n\r\n      // Set the new contract address\r\n      saleClockAuctionContract = candidateContract;\r\n\r\n  }\r\n\r\n  /// @dev Allows the commissioner to cancel his auctions (which are owned\r\n  ///   by this contract)\r\n  function cancelCommissionerAuction(uint32 tokenId) public onlyCommissioner {\r\n    require(saleClockAuctionContract != address(0));\r\n    saleClockAuctionContract.cancelAuction(tokenId);\r\n  }\r\n\r\n  /// @dev Put a player up for auction. The message sender must own the\r\n  ///   player token being put up for auction.\r\n  /// @param _playerTokenId - ID of playerToken to be auctioned\r\n  /// @param _startingPrice - Starting price in wei\r\n  /// @param _endingPrice - Ending price in wei\r\n  /// @param _duration - Duration in seconds\r\n  function createSaleAuction(\r\n      uint256 _playerTokenId,\r\n      uint256 _startingPrice,\r\n      uint256 _endingPrice,\r\n      uint256 _duration\r\n  )\r\n      public\r\n      whenNotPaused\r\n  {\r\n      // Auction contract checks input sizes\r\n      // If player is already on any auction, this will throw\r\n      // because it will be owned by the auction contract.\r\n      require(_owns(msg.sender, _playerTokenId));\r\n      _approve(_playerTokenId, saleClockAuctionContract);\r\n\r\n      // saleClockAuctionContract.createAuction throws if inputs are invalid and clears\r\n      // transfer after escrowing the player.\r\n      saleClockAuctionContract.createAuction(\r\n          _playerTokenId,\r\n          _startingPrice,\r\n          _endingPrice,\r\n          _duration,\r\n          msg.sender\r\n      );\r\n  }\r\n\r\n  /// @dev Transfers the balance of the sale auction contract\r\n  /// to the CSportsCore contract. We use two-step withdrawal to\r\n  /// avoid two transfer calls in the auction bid function.\r\n  /// To withdraw from this CSportsCore contract, the CFO must call\r\n  /// the withdrawBalance(...) function defined in CSportsAuth.\r\n  function withdrawAuctionBalances() external onlyCOO {\r\n      saleClockAuctionContract.withdrawBalance();\r\n  }\r\n}\r\n\r\n/// @title The facet of the CSportsCore contract that manages minting new PlayerTokens\r\n/// @author CryptoSports, Inc. (http://cryptosports.team)\r\n/// See the CSportsCore contract documentation to understand how the various contract facets are arranged.\r\ncontract CSportsMinting is CSportsAuction {\r\n\r\n  /// @dev MarketingTokenRedeemed event is fired when a marketing token has been redeemed\r\n  event MarketingTokenRedeemed(uint256 hash, uint128 rwpMd5, address indexed recipient);\r\n\r\n  /// @dev MarketingTokenCreated event is fired when a marketing token has been created\r\n  event MarketingTokenCreated(uint256 hash, uint128 rwpMd5);\r\n\r\n  /// @dev MarketingTokenReplaced event is fired when a marketing token has been replaced\r\n  event MarketingTokenReplaced(uint256 oldHash, uint256 newHash, uint128 rwpMd5);\r\n\r\n  /// @dev Sanity check that identifies this contract as having minting capability\r\n  function isMinter() public pure returns (bool) {\r\n      return true;\r\n  }\r\n\r\n  /// @dev Utility function to make it easy to keccak256 a string in python or javascript using\r\n  /// the exact algorythm used by Solidity.\r\n  function getKeccak256(string stringToHash) public pure returns (uint256) {\r\n      return uint256(keccak256(abi.encodePacked(stringToHash)));\r\n  }\r\n\r\n  /// @dev Allows the commissioner to load up our marketingTokens mapping with up to\r\n  /// MAX_MARKETING_TOKENS marketing tokens that can be created if one knows the words\r\n  /// to keccak256 and match the keywordHash passed here. Use web3.utils.soliditySha3(param1 [, param2, ...])\r\n  /// to create this hash.\r\n  ///\r\n  /// ONLY THE COMMISSIONER CAN CREATE MARKETING TOKENS, AND ONLY UP TO MAX_MARKETING_TOKENS OF THEM\r\n  ///\r\n  /// @param keywordHash - keccak256 of a known set of keyWords\r\n  /// @param md5Token - The md5 key in the leagueRosterContract that specifies the player\r\n  /// player token that will be minted and transfered by the redeemMarketingToken(...) method.\r\n  function addMarketingToken(uint256 keywordHash, uint128 md5Token) public onlyCommissioner {\r\n\r\n    require(remainingMarketingTokens > 0);\r\n    require(marketingTokens[keywordHash] == 0);\r\n\r\n    // Make sure the md5Token exists in the league roster\r\n    uint128 _rosterIndex = leagueRosterContract.getRealWorldPlayerRosterIndex(md5Token);\r\n    require(_rosterIndex != 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n    // Map the keyword Hash to the RWP md5 and decrement the remainingMarketingTokens property\r\n    remainingMarketingTokens--;\r\n    marketingTokens[keywordHash] = md5Token;\r\n\r\n    emit MarketingTokenCreated(keywordHash, md5Token);\r\n\r\n  }\r\n\r\n  /// @dev This method allows the commish to replace an existing marketing token that has\r\n  /// not been used with a new one (new hash and mdt). Since we are replacing, we co not\r\n  /// have to deal with remainingMarketingTokens in any way. This is to allow for replacing\r\n  /// marketing tokens that have not been redeemed and aren't likely to be redeemed (breakage)\r\n  ///\r\n  /// ONLY THE COMMISSIONER CAN ACCESS THIS METHOD\r\n  ///\r\n  /// @param oldKeywordHash Hash to replace\r\n  /// @param newKeywordHash Hash to replace with\r\n  /// @param md5Token The md5 key in the leagueRosterContract that specifies the player\r\n  function replaceMarketingToken(uint256 oldKeywordHash, uint256 newKeywordHash, uint128 md5Token) public onlyCommissioner {\r\n\r\n    uint128 _md5Token = marketingTokens[oldKeywordHash];\r\n    if (_md5Token != 0) {\r\n      marketingTokens[oldKeywordHash] = 0;\r\n      marketingTokens[newKeywordHash] = md5Token;\r\n      emit MarketingTokenReplaced(oldKeywordHash, newKeywordHash, md5Token);\r\n    }\r\n\r\n  }\r\n\r\n  /// @dev Returns the real world player's MD5 key from a keywords string. A 0x00 returned\r\n  /// value means the keyword string parameter isn't mapped to a marketing token.\r\n  /// @param keyWords Keywords to use to look up RWP MD5\r\n  //\r\n  /// ANYONE CAN VALIDATE A KEYWORD STRING (MAP IT TO AN MD5 IF IT HAS ONE)\r\n  ///\r\n  /// @param keyWords - A string that will keccak256 to an entry in the marketingTokens\r\n  /// mapping (or not)\r\n  function MD5FromMarketingKeywords(string keyWords) public view returns (uint128) {\r\n    uint256 keyWordsHash = uint256(keccak256(abi.encodePacked(keyWords)));\r\n    uint128 _md5Token = marketingTokens[keyWordsHash];\r\n    return _md5Token;\r\n  }\r\n\r\n  /// @dev Allows anyone to try to redeem a marketing token by passing N words that will\r\n  /// be SHA256'ed to match an entry in our marketingTokens mapping. If a match is found,\r\n  /// a CryptoSports token is created that corresponds to the md5 retrieved\r\n  /// from the marketingTokens mapping and its owner is assigned as the msg.sender.\r\n  ///\r\n  /// ANYONE CAN REDEEM A MARKETING token\r\n  ///\r\n  /// @param keyWords - A string that will keccak256 to an entry in the marketingTokens mapping\r\n  function redeemMarketingToken(string keyWords) public {\r\n\r\n    uint256 keyWordsHash = uint256(keccak256(abi.encodePacked(keyWords)));\r\n    uint128 _md5Token = marketingTokens[keyWordsHash];\r\n    if (_md5Token != 0) {\r\n\r\n      // Only one redemption per set of keywords\r\n      marketingTokens[keyWordsHash] = 0;\r\n\r\n      uint128 _rosterIndex = leagueRosterContract.getRealWorldPlayerRosterIndex(_md5Token);\r\n      if (_rosterIndex != 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\r\n\r\n        // Grab the real world player record from the leagueRosterContract\r\n        RealWorldPlayer memory _rwp;\r\n        (_rwp.md5Token, _rwp.prevCommissionerSalePrice, _rwp.lastMintedTime, _rwp.mintedCount, _rwp.hasActiveCommissionerAuction, _rwp.mintingEnabled) =  leagueRosterContract.realWorldPlayerFromIndex(_rosterIndex);\r\n\r\n        // Mint this player, sending it to the message sender\r\n        _mintPlayer(uint32(_rosterIndex), _rwp.mintedCount, msg.sender);\r\n\r\n        // Finally, update our realWorldPlayer record to reflect the fact that we just\r\n        // minted a new one, and there is an active commish auction. The only portion of\r\n        // the RWP record we change here is an update to the mingedCount.\r\n        leagueRosterContract.updateRealWorldPlayer(uint32(_rosterIndex), _rwp.prevCommissionerSalePrice, uint64(now), _rwp.mintedCount + 1, _rwp.hasActiveCommissionerAuction, _rwp.mintingEnabled);\r\n\r\n        emit MarketingTokenRedeemed(keyWordsHash, _rwp.md5Token, msg.sender);\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  /// @dev Returns an array of minimum auction starting prices for an array of players\r\n  /// specified by their MD5s.\r\n  /// @param _md5Tokens MD5s in the league roster for the players we are inquiring about.\r\n  function minStartPriceForCommishAuctions(uint128[] _md5Tokens) public view onlyCommissioner returns (uint128[50]) {\r\n    require (_md5Tokens.length <= 50);\r\n    uint128[50] memory minPricesArray;\r\n    for (uint32 i = 0; i < _md5Tokens.length; i++) {\r\n        uint128 _md5Token = _md5Tokens[i];\r\n        uint128 _rosterIndex = leagueRosterContract.getRealWorldPlayerRosterIndex(_md5Token);\r\n        if (_rosterIndex == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\r\n          // Cannot mint a non-existent real world player\r\n          continue;\r\n        }\r\n        RealWorldPlayer memory _rwp;\r\n        (_rwp.md5Token, _rwp.prevCommissionerSalePrice, _rwp.lastMintedTime, _rwp.mintedCount, _rwp.hasActiveCommissionerAuction, _rwp.mintingEnabled) =  leagueRosterContract.realWorldPlayerFromIndex(_rosterIndex);\r\n\r\n        // Skip this if there is no player associated with the md5 specified\r\n        if (_rwp.md5Token != _md5Token) continue;\r\n\r\n        minPricesArray[i] = uint128(_computeNextCommissionerPrice(_rwp.prevCommissionerSalePrice));\r\n    }\r\n    return minPricesArray;\r\n  }\r\n\r\n  /// @dev Creates newly minted playerTokens and puts them up for auction. This method\r\n  ///   can only be called by the commissioner, and checks to make sure certian minting\r\n  ///   conditions are met (reverting if not met):\r\n  ///     * The MD5 of the RWP specified must exist in the CSportsLeagueRoster contract\r\n  ///     * Cannot mint a realWorldPlayer that currently has an active commissioner auction\r\n  ///     * Cannot mint realWorldPlayer that does not have minting enabled\r\n  ///     * Cannot mint realWorldPlayer with a start price exceeding our minimum\r\n  ///   If any of the above conditions fails to be met, then no player tokens will be\r\n  ///   minted.\r\n  ///\r\n  /// *** ONLY THE COMMISSIONER OR THE LEAGUE ROSTER CONTRACT CAN CALL THIS FUNCTION ***\r\n  ///\r\n  /// @param _md5Tokens - array of md5Tokens representing realWorldPlayer that we are minting.\r\n  /// @param _startPrice - the starting price for the auction (0 will set to current minimum price)\r\n  function mintPlayers(uint128[] _md5Tokens, uint256 _startPrice, uint256 _endPrice, uint256 _duration) public {\r\n\r\n    require(leagueRosterContract != address(0));\r\n    require(saleClockAuctionContract != address(0));\r\n    require((msg.sender == commissionerAddress) || (msg.sender == address(leagueRosterContract)));\r\n\r\n    for (uint32 i = 0; i < _md5Tokens.length; i++) {\r\n      uint128 _md5Token = _md5Tokens[i];\r\n      uint128 _rosterIndex = leagueRosterContract.getRealWorldPlayerRosterIndex(_md5Token);\r\n      if (_rosterIndex == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) {\r\n        // Cannot mint a non-existent real world player\r\n        continue;\r\n      }\r\n\r\n      // We don't have to check _rosterIndex here because the getRealWorldPlayerRosterIndex(...)\r\n      // method always returns a valid index.\r\n      RealWorldPlayer memory _rwp;\r\n      (_rwp.md5Token, _rwp.prevCommissionerSalePrice, _rwp.lastMintedTime, _rwp.mintedCount, _rwp.hasActiveCommissionerAuction, _rwp.mintingEnabled) =  leagueRosterContract.realWorldPlayerFromIndex(_rosterIndex);\r\n\r\n      if (_rwp.md5Token != _md5Token) continue;\r\n      if (!_rwp.mintingEnabled) continue;\r\n\r\n      // Enforce the restrictions that there can ever only be a single outstanding commissioner\r\n      // auction - no new minting if there is an active commissioner auction for this real world player\r\n      if (_rwp.hasActiveCommissionerAuction) continue;\r\n\r\n      // Ensure that our price is not less than a minimum\r\n      uint256 _minStartPrice = _computeNextCommissionerPrice(_rwp.prevCommissionerSalePrice);\r\n\r\n      // Make sure the start price exceeds our minimum acceptable\r\n      if (_startPrice < _minStartPrice) {\r\n          _startPrice = _minStartPrice;\r\n      }\r\n\r\n      // Mint the new player token\r\n      uint32 _playerId = _mintPlayer(uint32(_rosterIndex), _rwp.mintedCount, address(this));\r\n\r\n      // @dev Approve ownership transfer to the saleClockAuctionContract (which is required by\r\n      //  the createAuction(...) which will escrow the playerToken)\r\n      _approve(_playerId, saleClockAuctionContract);\r\n\r\n      // Apply the default duration\r\n      if (_duration == 0) {\r\n        _duration = COMMISSIONER_AUCTION_DURATION;\r\n      }\r\n\r\n      // By setting our _endPrice to zero, we become immune to the USD <==> ether\r\n      // conversion rate. No matter how high ether goes, our auction price will get\r\n      // to a USD value that is acceptable to someone (assuming 0 is acceptable that is).\r\n      // This also helps for players that aren't in very much demand.\r\n      saleClockAuctionContract.createAuction(\r\n          _playerId,\r\n          _startPrice,\r\n          _endPrice,\r\n          _duration,\r\n          address(this)\r\n      );\r\n\r\n      // Finally, update our realWorldPlayer record to reflect the fact that we just\r\n      // minted a new one, and there is an active commish auction.\r\n      leagueRosterContract.updateRealWorldPlayer(uint32(_rosterIndex), _rwp.prevCommissionerSalePrice, uint64(now), _rwp.mintedCount + 1, true, _rwp.mintingEnabled);\r\n    }\r\n  }\r\n\r\n  /// @dev Reprices (and updates duration) of an array of tokens that are currently\r\n  /// being auctioned by this contract. Since this function can only be called by\r\n  /// the commissioner, we don't do a lot of checking of parameters and things.\r\n  /// The SaleClockAuction's repriceAuctions method assures that the CSportsCore\r\n  /// contract is the \"seller\" of the token (meaning it is a commissioner auction).\r\n  /// @param _tokenIds Array of tokenIds corresponding to auctions being updated\r\n  /// @param _startingPrices New starting prices for each token being repriced\r\n  /// @param _endingPrices New ending price\r\n  /// @param _duration New duration\r\n  function repriceAuctions(\r\n      uint256[] _tokenIds,\r\n      uint256[] _startingPrices,\r\n      uint256[] _endingPrices,\r\n      uint256 _duration\r\n  ) external onlyCommissioner {\r\n\r\n      // We cannot reprice below our player minimum\r\n      for (uint32 i = 0; i < _tokenIds.length; i++) {\r\n          uint32 _tokenId = uint32(_tokenIds[i]);\r\n          PlayerToken memory pt = playerTokens[_tokenId];\r\n          RealWorldPlayer memory _rwp;\r\n          (_rwp.md5Token, _rwp.prevCommissionerSalePrice, _rwp.lastMintedTime, _rwp.mintedCount, _rwp.hasActiveCommissionerAuction, _rwp.mintingEnabled) = leagueRosterContract.realWorldPlayerFromIndex(pt.realWorldPlayerId);\r\n          uint256 _minStartPrice = _computeNextCommissionerPrice(_rwp.prevCommissionerSalePrice);\r\n\r\n          // We require the price to be >= our _minStartPrice\r\n          require(_startingPrices[i] >= _minStartPrice);\r\n      }\r\n\r\n      // Note we pass in this CSportsCore contract address as the seller, making sure the only auctions\r\n      // that can be repriced by this method are commissioner auctions.\r\n      saleClockAuctionContract.repriceAuctions(_tokenIds, _startingPrices, _endingPrices, _duration, address(this));\r\n  }\r\n\r\n  /// @dev Allows the commissioner to create a sale auction for a token\r\n  ///   that is owned by the core contract. Can only be called when not paused\r\n  ///   and only by the commissioner\r\n  /// @param _playerTokenId - ID of the player token currently owned by the core contract\r\n  /// @param _startingPrice - Starting price for the auction\r\n  /// @param _endingPrice - Ending price for the auction\r\n  /// @param _duration - Duration of the auction (in seconds)\r\n  function createCommissionerAuction(uint32 _playerTokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration)\r\n        public whenNotPaused onlyCommissioner {\r\n\r\n        require(leagueRosterContract != address(0));\r\n        require(_playerTokenId < playerTokens.length);\r\n\r\n        // If player is already on any auction, this will throw because it will not be owned by\r\n        // this CSportsCore contract (as all commissioner tokens are if they are not currently\r\n        // on auction).\r\n        // Any token owned by the CSportsCore contract by definition is a commissioner auction\r\n        // that was canceled which makes it OK to re-list.\r\n        require(_owns(address(this), _playerTokenId));\r\n\r\n        // (1) Grab the real world token ID (md5)\r\n        PlayerToken memory pt = playerTokens[_playerTokenId];\r\n\r\n        // (2) Get the full real world player record from its roster index\r\n        RealWorldPlayer memory _rwp;\r\n        (_rwp.md5Token, _rwp.prevCommissionerSalePrice, _rwp.lastMintedTime, _rwp.mintedCount, _rwp.hasActiveCommissionerAuction, _rwp.mintingEnabled) = leagueRosterContract.realWorldPlayerFromIndex(pt.realWorldPlayerId);\r\n\r\n        // Ensure that our starting price is not less than a minimum\r\n        uint256 _minStartPrice = _computeNextCommissionerPrice(_rwp.prevCommissionerSalePrice);\r\n        if (_startingPrice < _minStartPrice) {\r\n            _startingPrice = _minStartPrice;\r\n        }\r\n\r\n        // Apply the default duration\r\n        if (_duration == 0) {\r\n            _duration = COMMISSIONER_AUCTION_DURATION;\r\n        }\r\n\r\n        // Approve the token for transfer\r\n        _approve(_playerTokenId, saleClockAuctionContract);\r\n\r\n        // saleClockAuctionContract.createAuction throws if inputs are invalid and clears\r\n        // transfer after escrowing the player.\r\n        saleClockAuctionContract.createAuction(\r\n            _playerTokenId,\r\n            _startingPrice,\r\n            _endingPrice,\r\n            _duration,\r\n            address(this)\r\n        );\r\n  }\r\n\r\n  /// @dev Computes the next commissioner auction starting price equal to\r\n  ///  the previous real world player sale price + 25% (with a floor).\r\n  function _computeNextCommissionerPrice(uint128 prevTwoCommissionerSalePriceAve) internal view returns (uint256) {\r\n\r\n      uint256 nextPrice = prevTwoCommissionerSalePriceAve + (prevTwoCommissionerSalePriceAve / 4);\r\n\r\n      // sanity check to ensure we don't overflow arithmetic (this big number is 2^128-1).\r\n      if (nextPrice > 340282366920938463463374607431768211455) {\r\n        nextPrice = 340282366920938463463374607431768211455;\r\n      }\r\n\r\n      // We never auction for less than our floor\r\n      if (nextPrice < COMMISSIONER_AUCTION_FLOOR_PRICE) {\r\n          nextPrice = COMMISSIONER_AUCTION_FLOOR_PRICE;\r\n      }\r\n\r\n      return nextPrice;\r\n  }\r\n\r\n}\r\n\r\n/// @notice This is the main contract that implements the csports ERC721 token.\r\n/// @author CryptoSports, Inc. (http://cryptosports.team)\r\n/// @dev This contract is made up of a series of parent classes so that we could\r\n/// break the code down into meaningful amounts of related functions in\r\n/// single files, as opposed to having one big file. The purpose of\r\n/// each facet is given here:\r\n///\r\n///   CSportsConstants - This facet holds constants used throughout.\r\n///   CSportsAuth -\r\n///   CSportsBase -\r\n///   CSportsOwnership -\r\n///   CSportsAuction -\r\n///   CSportsMinting -\r\n///   CSportsCore - This is the main CSports constract implementing the CSports\r\n///         Fantash Football League. It manages contract upgrades (if / when\r\n///         they might occur), and has generally useful helper methods.\r\n///\r\n/// This CSportsCore contract interacts with the CSportsLeagueRoster contract\r\n/// to determine which PlayerTokens to mint.\r\n///\r\n/// This CSportsCore contract interacts with the TimeAuction contract\r\n/// to implement and run PlayerToken auctions (sales).\r\ncontract CSportsCore is CSportsMinting {\r\n\r\n  /// @dev Used by other contracts as a sanity check\r\n  bool public isCoreContract = true;\r\n\r\n  // Set if (hopefully not) the core contract needs to be upgraded. Can be\r\n  // set by the CEO but only when paused. When successfully set, we can never\r\n  // unpause this contract. See the unpause() method overridden by this class.\r\n  address public newContractAddress;\r\n\r\n  /// @notice Class constructor creates the main CSportsCore smart contract instance.\r\n  /// @param nftName The ERC721 name for the contract\r\n  /// @param nftSymbol The ERC721 symbol for the contract\r\n  /// @param nftTokenURI The ERC721 token uri for the contract\r\n  constructor(string nftName, string nftSymbol, string nftTokenURI) public {\r\n\r\n      // New contract starts paused.\r\n      paused = true;\r\n\r\n      /// @notice storage for the fields that identify this 721 token\r\n      _name = nftName;\r\n      _symbol = nftSymbol;\r\n      _tokenURI = nftTokenURI;\r\n\r\n      // All C-level roles are the message sender\r\n      ceoAddress = msg.sender;\r\n      cfoAddress = msg.sender;\r\n      cooAddress = msg.sender;\r\n      commissionerAddress = msg.sender;\r\n\r\n  }\r\n\r\n  /// @dev Reject all Ether except if it's from one of our approved sources\r\n  function() external payable {\r\n    /*require(\r\n        msg.sender == address(saleClockAuctionContract)\r\n    );*/\r\n  }\r\n\r\n  /// --------------------------------------------------------------------------- ///\r\n  /// ----------------------------- PUBLIC FUNCTIONS ---------------------------- ///\r\n  /// --------------------------------------------------------------------------- ///\r\n\r\n  /// @dev Used to mark the smart contract as upgraded, in case there is a serious\r\n  ///  bug. This method does nothing but keep track of the new contract and\r\n  ///  emit a message indicating that the new address is set. It's up to clients of this\r\n  ///  contract to update to the new contract address in that case. (This contract will\r\n  ///  be paused indefinitely if such an upgrade takes place.)\r\n  /// @param _v2Address new address\r\n  function upgradeContract(address _v2Address) public onlyCEO whenPaused {\r\n      newContractAddress = _v2Address;\r\n      emit ContractUpgrade(_v2Address);\r\n  }\r\n\r\n  /// @dev Override unpause so it requires all external contract addresses\r\n  ///  to be set before contract can be unpaused. Also require that we have\r\n  ///  set a valid season and the contract has not been upgraded.\r\n  function unpause() public onlyCEO whenPaused {\r\n      require(leagueRosterContract != address(0));\r\n      require(saleClockAuctionContract != address(0));\r\n      require(newContractAddress == address(0));\r\n\r\n      // Actually unpause the contract.\r\n      super.unpause();\r\n  }\r\n\r\n  /// @dev Consolidates setting of contract links into a single call for deployment expediency\r\n  function setLeagueRosterAndSaleAndTeamContractAddress(address _leagueAddress, address _saleAddress, address _teamAddress) public onlyCEO {\r\n      setLeagueRosterContractAddress(_leagueAddress);\r\n      setSaleAuctionContractAddress(_saleAddress);\r\n      setTeamContractAddress(_teamAddress);\r\n  }\r\n\r\n  /// @dev Returns all the relevant information about a specific playerToken.\r\n  ///@param _playerTokenID - player token ID we are seeking the full player token info for\r\n  function getPlayerToken(uint32 _playerTokenID) public view returns (\r\n      uint32 realWorldPlayerId,\r\n      uint32 serialNumber,\r\n      uint64 mintedTime,\r\n      uint128 mostRecentPrice) {\r\n    require(_playerTokenID < playerTokens.length);\r\n    PlayerToken storage pt = playerTokens[_playerTokenID];\r\n    realWorldPlayerId = pt.realWorldPlayerId;\r\n    serialNumber = pt.serialNumber;\r\n    mostRecentPrice = pt.mostRecentPrice;\r\n    mintedTime = pt.mintedTime;\r\n  }\r\n\r\n  /// @dev Returns the realWorldPlayer MD5 ID for a given playerTokenID\r\n  /// @param _playerTokenID - player token ID we are seeking the associated realWorldPlayer md5 for\r\n  function realWorldPlayerTokenForPlayerTokenId(uint32 _playerTokenID) public view returns (uint128 md5Token) {\r\n      require(_playerTokenID < playerTokens.length);\r\n      PlayerToken storage pt = playerTokens[_playerTokenID];\r\n      RealWorldPlayer memory _rwp;\r\n      (_rwp.md5Token, _rwp.prevCommissionerSalePrice, _rwp.lastMintedTime, _rwp.mintedCount, _rwp.hasActiveCommissionerAuction, _rwp.mintingEnabled) = leagueRosterContract.realWorldPlayerFromIndex(pt.realWorldPlayerId);\r\n      md5Token = _rwp.md5Token;\r\n  }\r\n\r\n  /// @dev Returns the realWorldPlayer Metadata for a given playerTokenID\r\n  /// @param _playerTokenID - player token ID we are seeking the associated realWorldPlayer md5 for\r\n  function realWorldPlayerMetadataForPlayerTokenId(uint32 _playerTokenID) public view returns (string metadata) {\r\n      require(_playerTokenID < playerTokens.length);\r\n      PlayerToken storage pt = playerTokens[_playerTokenID];\r\n      RealWorldPlayer memory _rwp;\r\n      (_rwp.md5Token, _rwp.prevCommissionerSalePrice, _rwp.lastMintedTime, _rwp.mintedCount, _rwp.hasActiveCommissionerAuction, _rwp.mintingEnabled) = leagueRosterContract.realWorldPlayerFromIndex(pt.realWorldPlayerId);\r\n      metadata = leagueRosterContract.getMetadata(_rwp.md5Token);\r\n  }\r\n\r\n  /// --------------------------------------------------------------------------- ///\r\n  /// ------------------------- RESTRICTED FUNCTIONS ---------------------------- ///\r\n  /// --------------------------------------------------------------------------- ///\r\n\r\n  /// @dev Updates a particular realRealWorldPlayer. Note that the md5Token is immutable. Can only be\r\n  ///   called by the CEO and is used in development stage only as it is only needed by our test suite.\r\n  /// @param _rosterIndex - Index into realWorldPlayers of the entry to change.\r\n  /// @param _prevCommissionerSalePrice - Average of the 2 most recent sale prices in commissioner auctions\r\n  /// @param _lastMintedTime - Time this real world player was last minted\r\n  /// @param _mintedCount - The number of playerTokens that have been minted for this player\r\n  /// @param _hasActiveCommissionerAuction - Whether or not there is an active commissioner auction for this player\r\n  /// @param _mintingEnabled - Denotes whether or not we should mint new playerTokens for this real world player\r\n  function updateRealWorldPlayer(uint32 _rosterIndex, uint128 _prevCommissionerSalePrice, uint64 _lastMintedTime, uint32 _mintedCount, bool _hasActiveCommissionerAuction, bool _mintingEnabled) public onlyCEO onlyUnderDevelopment {\r\n    require(leagueRosterContract != address(0));\r\n    leagueRosterContract.updateRealWorldPlayer(_rosterIndex, _prevCommissionerSalePrice, _lastMintedTime, _mintedCount, _hasActiveCommissionerAuction, _mintingEnabled);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"stringToHash\",\"type\":\"string\"}],\"name\":\"getKeccak256\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"interfaceID\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint128\"},{\"name\":\"\",\"type\":\"uint128\"},{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"auctionCreated\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerTokenID\",\"type\":\"uint32\"}],\"name\":\"realWorldPlayerTokenForPlayerTokenId\",\"outputs\":[{\"name\":\"md5Token\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isDevelopment\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCOO\",\"type\":\"address\"}],\"name\":\"setCOO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_md5Tokens\",\"type\":\"uint128[]\"}],\"name\":\"minStartPriceForCommishAuctions\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128[50]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingMarketingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commissionerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerTokens\",\"outputs\":[{\"name\":\"realWorldPlayerId\",\"type\":\"uint32\"},{\"name\":\"serialNumber\",\"type\":\"uint32\"},{\"name\":\"mintedTime\",\"type\":\"uint64\"},{\"name\":\"mostRecentPrice\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"keywordHash\",\"type\":\"uint256\"},{\"name\":\"md5Token\",\"type\":\"uint128\"}],\"name\":\"addMarketingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSIONER_AUCTION_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ceo\",\"type\":\"address\"},{\"name\":\"_cfo\",\"type\":\"address\"},{\"name\":\"_coo\",\"type\":\"address\"},{\"name\":\"_commish\",\"type\":\"address\"}],\"name\":\"setCLevelAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_playerTokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createSaleAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"totalPrice\",\"type\":\"uint128\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"auctionSuccessful\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setLeagueRosterContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"keyWords\",\"type\":\"string\"}],\"name\":\"redeemMarketingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerTokenToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCommissioner\",\"type\":\"address\"}],\"name\":\"setCommissioner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_playerTokenId\",\"type\":\"uint32\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"createCommissionerAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rosterIndex\",\"type\":\"uint32\"},{\"name\":\"_prevCommissionerSalePrice\",\"type\":\"uint128\"},{\"name\":\"_lastMintedTime\",\"type\":\"uint64\"},{\"name\":\"_mintedCount\",\"type\":\"uint32\"},{\"name\":\"_hasActiveCommissionerAuction\",\"type\":\"bool\"},{\"name\":\"_mintingEnabled\",\"type\":\"bool\"}],\"name\":\"updateRealWorldPlayer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint32[]\"}],\"name\":\"batchTransferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isCoreContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint32[]\"}],\"name\":\"batchApprove\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerTokenToOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MAX_MARKETING_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint256\"},{\"name\":\"seller\",\"type\":\"address\"}],\"name\":\"auctionCancelled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerTokenID\",\"type\":\"uint32\"}],\"name\":\"realWorldPlayerMetadataForPlayerTokenId\",\"outputs\":[{\"name\":\"metadata\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"keyWords\",\"type\":\"string\"}],\"name\":\"MD5FromMarketingKeywords\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawAuctionBalances\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_startingPrices\",\"type\":\"uint256[]\"},{\"name\":\"_endingPrices\",\"type\":\"uint256[]\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"repriceAuctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokenId\",\"type\":\"uint32\"}],\"name\":\"cancelCommissionerAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"COMMISSIONER_AUCTION_FLOOR_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_md5Tokens\",\"type\":\"uint128[]\"},{\"name\":\"_startPrice\",\"type\":\"uint256\"},{\"name\":\"_endPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"mintPlayers\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cooAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leagueRosterContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setTeamContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerTokenID\",\"type\":\"uint32\"}],\"name\":\"getPlayerToken\",\"outputs\":[{\"name\":\"realWorldPlayerId\",\"type\":\"uint32\"},{\"name\":\"serialNumber\",\"type\":\"uint32\"},{\"name\":\"mintedTime\",\"type\":\"uint64\"},{\"name\":\"mostRecentPrice\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleClockAuctionContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"ret\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setProduction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_leagueAddress\",\"type\":\"address\"},{\"name\":\"_saleAddress\",\"type\":\"address\"},{\"name\":\"_teamAddress\",\"type\":\"address\"}],\"name\":\"setLeagueRosterAndSaleAndTeamContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ownedTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setSaleAuctionContractAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_tokenIds\",\"type\":\"uint32[]\"}],\"name\":\"batchEscrowToTeamContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"implementsSaleClockAuctionListener\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_v2Address\",\"type\":\"address\"}],\"name\":\"upgradeContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"oldKeywordHash\",\"type\":\"uint256\"},{\"name\":\"newKeywordHash\",\"type\":\"uint256\"},{\"name\":\"md5Token\",\"type\":\"uint128\"}],\"name\":\"replaceMarketingToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"nftName\",\"type\":\"string\"},{\"name\":\"nftSymbol\",\"type\":\"string\"},{\"name\":\"nftTokenURI\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rwpMd5\",\"type\":\"uint128\"},{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"MarketingTokenRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rwpMd5\",\"type\":\"uint128\"}],\"name\":\"MarketingTokenCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldHash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newHash\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rwpMd5\",\"type\":\"uint128\"}],\"name\":\"MarketingTokenReplaced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"CommissionerAuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"CommissionerAuctionCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"CSportsCore","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000002443727970746f53706f72747320466f6f7462616c6c2046616e746173792053706f72747300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000543534e464c000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002d68747470733a2f2f6170692e63727970746f73706f7274733732312e636f6d2f6e666c2f746f6b656e7572692f00000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://7f843893d21ff1c0b8c8ceb8b84a4c1995365f30f82cd381686835129a8ef93b"}]}