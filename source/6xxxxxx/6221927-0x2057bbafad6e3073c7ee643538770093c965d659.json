{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// This contract is heavily inspired by uPort from https://github.com/uport-project/uport-identity/blob/develop/contracts/TxRelay.sol\r\ncontract TxRelay {\r\n\r\n    // Note: This is a local nonce.\r\n    // Different from the nonce defined w/in protocol.\r\n    mapping(address => uint) public nonce;\r\n\r\n    // This is for debug purpose\r\n    event Log(address from, string message);\r\n    event MetaTxRelayed(address indexed claimedSender, address indexed addressFromSig);\r\n\r\n    /*\r\n     * @dev Relays meta transactions\r\n     * @param sigV, sigR, sigS ECDSA signature on some data to be forwarded\r\n     * @param destination Location the meta-tx should be forwarded to\r\n     * @param data The bytes necessary to call the function in the destination contract.\r\n     */\r\n    function relayMetaTx(\r\n        uint8 sigV,\r\n        bytes32 sigR,\r\n        bytes32 sigS,\r\n        address destination,\r\n        bytes data\r\n    ) public {\r\n\r\n        address claimedSender = getAddressFromData(data);\r\n        // use EIP 191\r\n        // 0x19 :: version :: relay :: sender :: nonce :: destination :: data\r\n        bytes32 h = keccak256(\r\n            abi.encodePacked(byte(0x19), byte(0), this, claimedSender, nonce[claimedSender], destination, data)\r\n        );\r\n        address addressFromSig = getAddressFromSig(h, sigV, sigR, sigS);\r\n\r\n        // address recovered from signature must match with claimed sender\r\n        require(claimedSender == addressFromSig, \"address recovered from signature must match with claimed sender\");\r\n\r\n        //if we are going to do tx, update nonce\r\n        nonce[claimedSender]++;\r\n\r\n        // invoke method on behalf of sender\r\n        require(destination.call(data), \"can not invoke destination function\");\r\n\r\n        emit MetaTxRelayed(claimedSender, addressFromSig);\r\n    }\r\n\r\n    /*\r\n     * @dev Gets an address encoded as the first argument in transaction data\r\n     * @param b The byte array that should have an address as first argument\r\n     * @returns a The address retrieved from the array\r\n     (Optimization based on work by tjade273)\r\n     */\r\n    function getAddressFromData(bytes b) public pure returns (address a) {\r\n        if (b.length < 36) return address(0);\r\n        assembly {\r\n            let mask := 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n            a := and(mask, mload(add(b, 36)))\r\n            // 36 is the offset of the first parameter of the data, if encoded properly.\r\n            // 32 bytes for the length of the bytes array, and 4 bytes for the function signature.\r\n        }\r\n    }\r\n\r\n    /*\r\n     * @dev Gets an address from msgHash and signature\r\n     * @param msgHash EIP 191\r\n     * @param sigV, sigR, sigS ECDSA signature on some data to be forwarded\r\n     * @returns a The address retrieved\r\n     */\r\n    function getAddressFromSig(\r\n        bytes32 msgHash,\r\n        uint8 sigV,\r\n        bytes32 sigR,\r\n        bytes32 sigS\r\n    ) public pure returns (address a) {\r\n        return ecrecover(msgHash, sigV, sigR, sigS);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"name\":\"sigV\",\"type\":\"uint8\"},{\"name\":\"sigR\",\"type\":\"bytes32\"},{\"name\":\"sigS\",\"type\":\"bytes32\"}],\"name\":\"getAddressFromSig\",\"outputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"nonce\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sigV\",\"type\":\"uint8\"},{\"name\":\"sigR\",\"type\":\"bytes32\"},{\"name\":\"sigS\",\"type\":\"bytes32\"},{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"relayMetaTx\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"b\",\"type\":\"bytes\"}],\"name\":\"getAddressFromData\",\"outputs\":[{\"name\":\"a\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Log\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"claimedSender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"addressFromSig\",\"type\":\"address\"}],\"name\":\"MetaTxRelayed\",\"type\":\"event\"}]","ContractName":"TxRelay","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c5532d8df18f09862a2edae63840b5adb573f2de108dd6850294c3e0e689a94e"}]}