{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = a * b;\r\n        require(c / a == b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0);\r\n        // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n    * reverts when dividing by zero.\r\n    */\r\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b != 0);\r\n        return a % b;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n    struct Role {\r\n        mapping(address => bool) bearer;\r\n    }\r\n\r\n    /**\r\n     * @dev give an account access to this role\r\n     */\r\n    function add(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(!has(role, account));\r\n\r\n        role.bearer[account] = true;\r\n    }\r\n\r\n    /**\r\n     * @dev remove an account's access to this role\r\n     */\r\n    function remove(Role storage role, address account) internal {\r\n        require(account != address(0));\r\n        require(has(role, account));\r\n\r\n        role.bearer[account] = false;\r\n    }\r\n\r\n    /**\r\n     * @dev check if an account has this role\r\n     * @return bool\r\n     */\r\n    function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n    {\r\n        require(account != address(0));\r\n        return role.bearer[account];\r\n    }\r\n}\r\n\r\ncontract MinterRole {\r\n    using Roles for Roles.Role;\r\n\r\n    event MinterAdded(address indexed account);\r\n    event MinterRemoved(address indexed account);\r\n\r\n    Roles.Role private minters;\r\n\r\n    constructor() internal {\r\n        _addMinter(msg.sender);\r\n    }\r\n\r\n    modifier onlyMinter() {\r\n        require(isMinter(msg.sender));\r\n        _;\r\n    }\r\n\r\n    function isMinter(address account) public view returns (bool) {\r\n        return minters.has(account);\r\n    }\r\n\r\n    function addMinter(address account) public onlyMinter {\r\n        _addMinter(account);\r\n    }\r\n\r\n    function renounceMinter() public {\r\n        _removeMinter(msg.sender);\r\n    }\r\n\r\n    function _addMinter(address account) internal {\r\n        minters.add(account);\r\n        emit MinterAdded(account);\r\n    }\r\n\r\n    function _removeMinter(address account) internal {\r\n        minters.remove(account);\r\n        emit MinterRemoved(account);\r\n    }\r\n}\r\n\r\n\r\ninterface IQRToken {\r\n    function totalSupply() external view returns (uint256);\r\n\r\n    function balanceOf(address who) external view returns (uint256);\r\n\r\n    function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n    function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n    function mint(address to, uint256 value)\r\n    external returns (bool);\r\n\r\n    function addMinter(address account)\r\n    external;\r\n\r\n    function frozenTime(address owner)\r\n    external view returns (uint);\r\n\r\n    function setFrozenTime(address owner, uint newtime)\r\n    external;\r\n}\r\n\r\ncontract IQRSaleFirst is MinterRole {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    uint256 private  _usdc_for_iqr;\r\n    uint256 private _usdc_for_eth;\r\n    uint256 private _leftToSale;\r\n\r\n    address private _cold_wallet;\r\n\r\n    IQRToken private _token;\r\n\r\n    constructor() public  {\r\n        // price usd cents for one IQR. Default: 1 IQR = $0.06\r\n        _usdc_for_iqr = 6;\r\n        // usd cents for one ether. Default: 1 ETH = $130.92\r\n        _usdc_for_eth = 13092;\r\n        // MAX tokens to sale for this contract\r\n        _leftToSale = 200000000 ether;\r\n        // Address for ether\r\n        _cold_wallet = 0x5BAC0CE2276ebE6845c31C86499C6D7F5C9b0650;\r\n    }\r\n\r\n    function() public payable {\r\n        require(msg.value > 0.1 ether);\r\n        require(_token != address(0x0));\r\n        require(_cold_wallet != address(0x0));\r\n\r\n        uint256 received = msg.value;\r\n        uint256 tokens_to_send = received.mul(_usdc_for_eth).div(_usdc_for_iqr);\r\n        _leftToSale = _leftToSale.sub(tokens_to_send);\r\n        _token.mint(msg.sender, tokens_to_send);\r\n\r\n        _cold_wallet.transfer(msg.value);\r\n    }\r\n\r\n    function sendTokens(address beneficiary, uint256 tokens_to_send) public onlyMinter {\r\n        require(_token != address(0x0));\r\n        _leftToSale = _leftToSale.sub(tokens_to_send);\r\n        _token.mint(beneficiary, tokens_to_send);\r\n    }\r\n\r\n    function sendTokensToManyAddresses(address[] beneficiaries, uint256 tokens_to_send) public onlyMinter {\r\n        require(_token != address(0x0));\r\n        _leftToSale = _leftToSale.sub(tokens_to_send * beneficiaries.length);\r\n        for (uint i = 0; i < beneficiaries.length; i++) {\r\n            _token.mint(beneficiaries[i], tokens_to_send);\r\n        }\r\n    }\r\n\r\n    function setFrozenTime(address _owner, uint _newtime) public onlyMinter {\r\n        require(_token != address(0x0));\r\n        _token.setFrozenTime(_owner, _newtime);\r\n    }\r\n\r\n    function setFrozenTimeToManyAddresses(address[] _owners, uint _newtime) public onlyMinter {\r\n        require(_token != address(0x0));\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            _token.setFrozenTime(_owners[i], _newtime);\r\n        }\r\n    }\r\n\r\n    function unFrozen(address _owner) public onlyMinter {\r\n        require(_token != address(0x0));\r\n        _token.setFrozenTime(_owner, 0);\r\n    }\r\n\r\n    function unFrozenManyAddresses(address[] _owners) public onlyMinter {\r\n        require(_token != address(0x0));\r\n        for (uint i = 0; i < _owners.length; i++) {\r\n            _token.setFrozenTime(_owners[i], 0);\r\n        }\r\n    }\r\n\r\n    function usdc_for_iqr() public view returns (uint256) {\r\n        return _usdc_for_iqr;\r\n    }\r\n\r\n    function usdc_for_eth() public view returns (uint256) {\r\n        return _usdc_for_eth;\r\n    }\r\n\r\n    function leftToSale() public view returns (uint256) {\r\n        return _leftToSale;\r\n    }\r\n\r\n    function cold_wallet() public view returns (address) {\r\n        return _cold_wallet;\r\n    }\r\n\r\n    function token() public view returns (IQRToken) {\r\n        return _token;\r\n    }\r\n\r\n    function setUSDCforIQR(uint256 _usdc_for_iqr_) public onlyMinter {\r\n        _usdc_for_iqr = _usdc_for_iqr_;\r\n    }\r\n\r\n    function setUSDCforETH(uint256 _usdc_for_eth_) public onlyMinter {\r\n        _usdc_for_eth = _usdc_for_eth_;\r\n    }\r\n\r\n    function setColdWallet(address _cold_wallet_) public onlyMinter {\r\n        _cold_wallet = _cold_wallet_;\r\n    }\r\n\r\n    function setToken(IQRToken _token_) public onlyMinter {\r\n        _token = _token_;\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"}],\"name\":\"unFrozenManyAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cold_wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"tokens_to_send\",\"type\":\"uint256\"}],\"name\":\"sendTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cold_wallet_\",\"type\":\"address\"}],\"name\":\"setColdWallet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdc_for_eth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token_\",\"type\":\"address\"}],\"name\":\"setToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_usdc_for_iqr_\",\"type\":\"uint256\"}],\"name\":\"setUSDCforIQR\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"unFrozen\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiaries\",\"type\":\"address[]\"},{\"name\":\"tokens_to_send\",\"type\":\"uint256\"}],\"name\":\"sendTokensToManyAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owners\",\"type\":\"address[]\"},{\"name\":\"_newtime\",\"type\":\"uint256\"}],\"name\":\"setFrozenTimeToManyAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdc_for_iqr\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_newtime\",\"type\":\"uint256\"}],\"name\":\"setFrozenTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"leftToSale\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_usdc_for_eth_\",\"type\":\"uint256\"}],\"name\":\"setUSDCforETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"MinterRemoved\",\"type\":\"event\"}]","ContractName":"IQRSaleFirst","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://26bc20ec66adaccc4d59b803819a8812c86a1b21f300f72bc88c10eaca4970ce"}]}