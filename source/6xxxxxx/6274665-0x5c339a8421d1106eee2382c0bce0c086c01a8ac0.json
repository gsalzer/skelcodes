{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n/******************************************************************************\\\r\n* Author: Nick Mudge, nick@mokens.io\r\n* Copyright (c) 2018\r\n* Mokens\r\n*\r\n* The MokenUpdates contract adds/updates/removes functions. This is how the Mokens\r\n* contract is updated\r\n*\r\n* Function changes emit the ContractUpdated event.\r\n* Monitor changes to the Mokens contract by watching/querying the\r\n* ContractUpdated event\r\n*\r\n* Functions and delegate contracts can be queried by using functions from the\r\n* QueryMokenDelegates contract.\r\n/******************************************************************************/\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Storage contracts\r\n////////////\r\n//Some delegate contracts are listed with storage contracts they inherit.\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Mokens\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage0 {\r\n    // funcId => delegate contract\r\n    mapping(bytes4 => address) internal delegates;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenUpdates\r\n//MokenOwner\r\n//QueryMokenDelegates\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage1 is Storage0 {\r\n    address internal contractOwner;\r\n    bytes[] internal funcSignatures;\r\n    // signature => index+1\r\n    mapping(bytes => uint256) internal funcSignatureToIndex;\r\n}\r\n\r\ncontract MokenUpdates is Storage1 {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    event ContractUpdated(bytes4 indexed functionId, address indexed delegate, bytes32 indexed updateType, string functionSignature);\r\n\r\n    function initializeMokensContract(address _mokenUpdates) external {\r\n        require(contractOwner == address(0), \"Contract owner has been set.\");\r\n        contractOwner = msg.sender;\r\n        emit OwnershipTransferred(address(0), msg.sender);\r\n        /////////////////////////////////////////\r\n        //adding functions to Mokens contract\r\n        /////////////////////////////////////////\r\n        bytes memory signature;\r\n        bytes4 funcId;\r\n        bytes[] memory signatures = new bytes[](3);\r\n        signatures[0] = \"addFunctions(address,string)\";\r\n        signatures[1] = \"updateFunctions(address,string)\";\r\n        signatures[2] = \"removeFunctions(string)\";\r\n        for(uint256 i = 0; i < signatures.length; i++) {\r\n            signature = signatures[i];\r\n            funcId = bytes4(keccak256(signature));\r\n            delegates[funcId] = _mokenUpdates;\r\n            funcSignatures.push(signature);\r\n            funcSignatureToIndex[signature] = funcSignatures.length;\r\n            emit ContractUpdated(funcId, _mokenUpdates, \"new\", string(signature));\r\n        }\r\n    }\r\n\r\n    function addFunctions(address _delegate, string _functionSignatures) external {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        require(_delegate != address(0), \"delegate can't be zero address.\");\r\n        bytes memory signatures = bytes(_functionSignatures);\r\n        uint256 signaturesEnd;\r\n        uint256 pos;\r\n        uint256 start;\r\n        assembly {\r\n            pos := add(signatures,32)\r\n            start := pos\r\n            signaturesEnd := add(pos,mload(signatures))\r\n        }\r\n        bytes4 funcId;\r\n        uint256 num;\r\n        uint256 char;\r\n        for (; pos < signaturesEnd; pos++) {\r\n            assembly {char := byte(0,mload(pos))}\r\n            // 0x29 == )\r\n            if (char == 0x29) {\r\n                pos++;\r\n                num = (pos - start);\r\n                start = pos;\r\n                assembly {\r\n                    mstore(signatures,num)\r\n                }\r\n                funcId = bytes4(keccak256(signatures));\r\n                require(funcSignatureToIndex[signatures] == 0, \"Function already exists.\");\r\n                require(delegates[funcId] == address(0), \"FuncId clash.\");\r\n                delegates[funcId] = _delegate;\r\n                funcSignatures.push(signatures);\r\n                funcSignatureToIndex[signatures] = funcSignatures.length;\r\n                emit ContractUpdated(funcId, _delegate, \"new\", string(signatures));\r\n                assembly {signatures := add(signatures,num)}\r\n            }\r\n        }\r\n    }\r\n\r\n    function updateFunctions(address _delegate, string _functionSignatures) external {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        require(_delegate != address(0), \"delegate can't be zero address.\");\r\n        bytes memory signatures = bytes(_functionSignatures);\r\n        uint256 signaturesEnd;\r\n        uint256 pos;\r\n        uint256 start;\r\n        assembly {\r\n            pos := add(signatures,32)\r\n            start := pos\r\n            signaturesEnd := add(pos,mload(signatures))\r\n        }\r\n        bytes4 funcId;\r\n        uint256 num;\r\n        uint256 char;\r\n        for (; pos < signaturesEnd; pos++) {\r\n            assembly {char := byte(0,mload(pos))}\r\n            // 0x29 == )\r\n            if (char == 0x29) {\r\n                pos++;\r\n                num = (pos - start);\r\n                start = pos;\r\n                assembly {\r\n                    mstore(signatures,num)\r\n                }\r\n                funcId = bytes4(keccak256(signatures));\r\n                if (funcSignatureToIndex[signatures] == 0) {\r\n                    require(delegates[funcId] == address(0), \"FuncId clash.\");\r\n                    delegates[funcId] = _delegate;\r\n                    funcSignatures.push(signatures);\r\n                    funcSignatureToIndex[signatures] = funcSignatures.length;\r\n                    emit ContractUpdated(funcId, _delegate, \"new\", string(signatures));\r\n                    assembly {signatures := add(signatures,num)}\r\n                }\r\n                else if (delegates[funcId] != _delegate) {\r\n                    delegates[funcId] = _delegate;\r\n                    emit ContractUpdated(funcId, _delegate, \"updated\", string(signatures));\r\n                    assembly {signatures := add(signatures,num)}\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function removeFunctions(string _functionSignatures) external {\r\n        require(msg.sender == contractOwner, \"Must own Mokens contract.\");\r\n        address delegate;\r\n        bytes memory signatures = bytes(_functionSignatures);\r\n        uint256 signaturesEnd;\r\n        uint256 pos;\r\n        uint256 start;\r\n        assembly {\r\n            pos := add(signatures,32)\r\n            start := pos\r\n            signaturesEnd := add(pos,mload(signatures))\r\n        }\r\n        bytes4 funcId;\r\n        uint256 num;\r\n        uint256 char;\r\n        uint256 index;\r\n        uint256 lastIndex;\r\n        for (; pos < signaturesEnd; pos++) {\r\n            assembly {char := byte(0,mload(pos))}\r\n            // 0x29 == )\r\n            if (char == 0x29) {\r\n                pos++;\r\n                num = (pos - start);\r\n                start = pos;\r\n                assembly {\r\n                    mstore(signatures,num)\r\n                }\r\n                funcId = bytes4(keccak256(signatures));\r\n                index = funcSignatureToIndex[signatures];\r\n                require(index != 0, \"Function does not exist.\");\r\n                index--;\r\n                lastIndex = funcSignatures.length - 1;\r\n                if (index != lastIndex) {\r\n                    funcSignatures[index] = funcSignatures[lastIndex];\r\n                    funcSignatureToIndex[funcSignatures[lastIndex]] = index + 1;\r\n                }\r\n                funcSignatures.length--;\r\n                delete funcSignatureToIndex[signatures];\r\n                delegate = delegates[funcId];\r\n                delete delegates[funcId];\r\n                emit ContractUpdated(funcId, delegate, \"removed\", string(signatures));\r\n                assembly {signatures := add(signatures,num)}\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_functionSignatures\",\"type\":\"string\"}],\"name\":\"removeFunctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mokenUpdates\",\"type\":\"address\"}],\"name\":\"initializeMokensContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_functionSignatures\",\"type\":\"string\"}],\"name\":\"updateFunctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_delegate\",\"type\":\"address\"},{\"name\":\"_functionSignatures\",\"type\":\"string\"}],\"name\":\"addFunctions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"functionId\",\"type\":\"bytes4\"},{\"indexed\":true,\"name\":\"delegate\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"updateType\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"functionSignature\",\"type\":\"string\"}],\"name\":\"ContractUpdated\",\"type\":\"event\"}]","ContractName":"MokenUpdates","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://14efc5a2f3b74677c1bbda175aabd598f96f0ba34776d536a2ef2c3b627f68b7"}]}