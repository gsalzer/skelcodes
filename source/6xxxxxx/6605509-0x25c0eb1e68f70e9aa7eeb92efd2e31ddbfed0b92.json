{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary MathLib {\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        assert(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0 || b == 0) {\r\n            c = 0;\r\n        } else {\r\n            c = a * b;\r\n            assert(c / a == b);\r\n        }\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\ninterface IMultiOwnable {\r\n\r\n    function owners() external view returns (address[]);\r\n    function transferOwnership(address newOwner) external;\r\n    function appointHeir(address heir) external;\r\n    function succeedOwner(address owner) external;\r\n\r\n    event OwnershipTransfer(address indexed owner, address indexed newOwner);\r\n    event HeirAppointment(address indexed owner, address indexed heir);\r\n    event OwnershipSuccession(address indexed owner, address indexed heir);\r\n}\r\n\r\n\r\nlibrary AddressLib {\r\n\r\n    using AddressLib for AddressLib.Set;\r\n\r\n    function isEmpty(address value) internal pure returns (bool) {\r\n        return value == address(0);\r\n    }\r\n\r\n    function isSender(address value) internal view returns (bool) {\r\n        return value == msg.sender;\r\n    }\r\n\r\n    struct Set {\r\n        address[] vals;\r\n        mapping(address => uint256) seqs;\r\n    }\r\n\r\n    function values(Set storage set) internal view returns (address[]) {\r\n        return set.vals;\r\n    }\r\n\r\n    function count(Set storage set) internal view returns (uint256) {\r\n        return set.vals.length;\r\n    }\r\n\r\n    function first(Set storage set) internal view returns (address) {\r\n        require(set.count() > 0, \"Set cannot be empty\");\r\n\r\n        return set.vals[0];\r\n    }\r\n\r\n    function last(Set storage set) internal view returns (address) {\r\n        require(set.count() > 0, \"Set cannot be empty\");\r\n\r\n        return set.vals[set.vals.length - 1];\r\n    }\r\n\r\n    function contains(Set storage set, address value) internal view returns (bool) {\r\n        return set.seqs[value] > 0;\r\n    }\r\n\r\n    function add(Set storage set, address value) internal {\r\n        if (!set.contains(value)) {\r\n            set.seqs[value] = set.vals.push(value);\r\n        }\r\n    }\r\n\r\n    function remove(Set storage set, address value) internal {\r\n        if (set.contains(value)) {\r\n            uint256 seq = set.seqs[value];\r\n\r\n            if (seq < set.count()) {\r\n                address lastVal = set.last();\r\n\r\n                set.vals[seq - 1] = lastVal;\r\n                set.seqs[lastVal] = seq;\r\n            }\r\n\r\n            set.vals.length--;\r\n            set.seqs[value] = 0;\r\n        }\r\n    }\r\n}\r\n\r\n\r\ncontract MultiOwnable is IMultiOwnable {\r\n\r\n    using AddressLib for address;\r\n    using AddressLib for AddressLib.Set;\r\n\r\n    AddressLib.Set private _owners;\r\n    mapping(address => address) private _heirs;\r\n\r\n    modifier onlyOwner {\r\n        require(_owners.contains(msg.sender), \"Only allowed for a owner\");\r\n        _;\r\n    }\r\n\r\n    constructor (address[] owners) internal {\r\n        for (uint256 i = 0; i < owners.length; i++) {\r\n            _owners.add(owners[i]);\r\n        }\r\n    }\r\n\r\n    function owners() external view returns (address[]) {\r\n        return _owners.values();\r\n    }\r\n\r\n    function transferOwnership(address newOwner) external onlyOwner {\r\n        _transferOwnership(msg.sender, newOwner);\r\n\r\n        emit OwnershipTransfer(msg.sender, newOwner);\r\n    }\r\n\r\n    function appointHeir(address heir) external onlyOwner {\r\n        _heirs[msg.sender] = heir;\r\n\r\n        emit HeirAppointment(msg.sender, heir);\r\n    }\r\n\r\n    function succeedOwner(address owner) external {\r\n        require(_heirs[owner].isSender(), \"Only heir may succeed owner\");\r\n\r\n        _transferOwnership(owner, msg.sender);\r\n        \r\n        emit OwnershipSuccession(owner, msg.sender);\r\n    }\r\n\r\n    function _transferOwnership(address owner, address newOwner) private {\r\n        _owners.remove(owner);\r\n        _owners.add(newOwner);\r\n        _heirs[owner] = address(0);\r\n    }\r\n}\r\n\r\n\r\ncontract Geo {\r\n\r\n    enum Class { District, Zone, Target }\r\n    enum Status { Locked, Unlocked, Owned }\r\n\r\n    struct Area {\r\n        Class class;\r\n        Status status;\r\n        uint256 parent;\r\n        uint256[] siblings;\r\n        uint256[] children;\r\n        address owner;\r\n        uint256 cost;\r\n        uint256 unlockTime;\r\n    }\r\n\r\n    mapping(uint256 => Area) internal areas;\r\n\r\n    constructor () internal { }\r\n\r\n    function initAreas() internal {\r\n        areas[0].class = Class.Target;\r\n\r\n        areas[1].class = Class.District;\r\n        areas[1].parent = 46;\r\n        areas[1].siblings = [2,3];\r\n        areas[2].class = Class.District;\r\n        areas[2].parent = 46;\r\n        areas[2].siblings = [1,3];\r\n        areas[3].class = Class.District;\r\n        areas[3].parent = 46;\r\n        areas[3].siblings = [1,2,4,6,8,9,11,13];\r\n        areas[4].class = Class.District;\r\n        areas[4].parent = 46;\r\n        areas[4].siblings = [3,5,6,9];\r\n        areas[5].class = Class.District;\r\n        areas[5].parent = 46;\r\n        areas[5].siblings = [4,6,7,9,37,38,39,41];\r\n        areas[6].class = Class.District;\r\n        areas[6].parent = 46;\r\n        areas[6].siblings = [3,4,5,7,13,22];\r\n        areas[7].class = Class.District;\r\n        areas[7].parent = 46;\r\n        areas[7].siblings = [5,6,21,22,26,38];\r\n        areas[8].class = Class.District;\r\n        areas[8].parent = 46;\r\n\r\n        areas[9].class = Class.District;\r\n        areas[9].parent = 47;\r\n        areas[9].siblings = [3,4,5,10,11,12,39,41];\r\n        areas[10].class = Class.District;\r\n        areas[10].parent = 47;\r\n        areas[10].siblings = [9,11,12];\r\n        areas[11].class = Class.District;\r\n        areas[11].parent = 47;\r\n        areas[11].siblings = [3,9,10,14];\r\n        areas[12].class = Class.District;\r\n        areas[12].parent = 47;\r\n        areas[12].siblings = [9,10];\r\n        areas[13].class = Class.District;\r\n        areas[13].parent = 47;\r\n        areas[13].siblings = [3,6,15,16,17,22];\r\n        areas[14].class = Class.District;\r\n        areas[14].parent = 47;\r\n        areas[15].class = Class.District;\r\n        areas[15].parent = 47;\r\n        areas[16].class = Class.District;\r\n        areas[16].parent = 47;\r\n\r\n        areas[17].class = Class.District;\r\n        areas[17].parent = 48;\r\n        areas[17].siblings = [13,18,19,22,23];\r\n        areas[18].class = Class.District;\r\n        areas[18].parent = 48;\r\n        areas[18].siblings = [17,19];\r\n        areas[19].class = Class.District;\r\n        areas[19].parent = 48;\r\n        areas[19].siblings = [17,18,20,21,22,25];\r\n        areas[20].class = Class.District;\r\n        areas[20].parent = 48;\r\n        areas[20].siblings = [19,21,24,27];\r\n        areas[21].class = Class.District;\r\n        areas[21].parent = 48;\r\n        areas[21].siblings = [7,19,20,22,26,27];\r\n        areas[22].class = Class.District;\r\n        areas[22].parent = 48;\r\n        areas[22].siblings = [6,7,13,17,19,21];\r\n        areas[23].class = Class.District;\r\n        areas[23].parent = 48;\r\n        areas[24].class = Class.District;\r\n        areas[24].parent = 48;\r\n        areas[25].class = Class.District;\r\n        areas[25].parent = 48;\r\n\r\n        areas[26].class = Class.District;\r\n        areas[26].parent = 49;\r\n        areas[26].siblings = [7,21,27,28,31,38];\r\n        areas[27].class = Class.District;\r\n        areas[27].parent = 49;\r\n        areas[27].siblings = [20,21,26,28,29,32,33,34,36];\r\n        areas[28].class = Class.District;\r\n        areas[28].parent = 49;\r\n        areas[28].siblings = [26,27,30,31,35];\r\n        areas[29].class = Class.District;\r\n        areas[29].parent = 49;\r\n        areas[29].siblings = [27];\r\n        areas[30].class = Class.District;\r\n        areas[30].parent = 49;\r\n        areas[30].siblings = [28,31,37,42];\r\n        areas[31].class = Class.District;\r\n        areas[31].parent = 49;\r\n        areas[31].siblings = [26,28,30,37,38];\r\n        areas[32].class = Class.District;\r\n        areas[32].parent = 49;\r\n        areas[32].siblings = [27];\r\n        areas[33].class = Class.District;\r\n        areas[33].parent = 49;\r\n        areas[33].siblings = [27];\r\n        areas[34].class = Class.District;\r\n        areas[34].parent = 49;\r\n        areas[35].class = Class.District;\r\n        areas[35].parent = 49;\r\n        areas[36].class = Class.District;\r\n        areas[36].parent = 49;\r\n\r\n        areas[37].class = Class.District;\r\n        areas[37].parent = 50;\r\n        areas[37].siblings = [5,30,31,38,39,40,42,45];\r\n        areas[38].class = Class.District;\r\n        areas[38].parent = 50;\r\n        areas[38].siblings = [5,7,26,31,37];\r\n        areas[39].class = Class.District;\r\n        areas[39].parent = 50;\r\n        areas[39].siblings = [5,9,37,40,41,43,44];\r\n        areas[40].class = Class.District;\r\n        areas[40].parent = 50;\r\n        areas[40].siblings = [37,39,42,43];\r\n        areas[41].class = Class.District;\r\n        areas[41].parent = 50;\r\n        areas[41].siblings = [5,9,39];\r\n        areas[42].class = Class.District;\r\n        areas[42].parent = 50;\r\n        areas[42].siblings = [30,37,40,43];\r\n        areas[43].class = Class.District;\r\n        areas[43].parent = 50;\r\n        areas[43].siblings = [39,40,42];\r\n        areas[44].class = Class.District;\r\n        areas[44].parent = 50;\r\n        areas[45].class = Class.District;\r\n        areas[45].parent = 50;\r\n\r\n        areas[46].class = Class.Zone;\r\n        areas[46].children = [1,2,3,4,5,6,7,8];\r\n        areas[47].class = Class.Zone;\r\n        areas[47].children = [9,10,11,12,13,14,15,16];\r\n        areas[48].class = Class.Zone;\r\n        areas[48].children = [17,18,19,20,21,22,23,24,25];\r\n        areas[49].class = Class.Zone;\r\n        areas[49].children = [26,27,28,29,30,31,32,33,34,35,36];\r\n        areas[50].class = Class.Zone;\r\n        areas[50].children = [37,38,39,40,41,42,43,44,45];\r\n    }\r\n}\r\n\r\n\r\ncontract Configs {\r\n\r\n    address[] internal GAME_MASTER_ADDRESSES = [\r\n        0x33e03f9F3eFe593D10327245f8107eAaD09730B7,\r\n        0xbcec8fc952776F4F83829837881092596C29A666,\r\n        0x4Eb1E2B89Aba03b7383F07cC80003937b7814B54,\r\n        address(0),\r\n        address(0)\r\n    ];\r\n\r\n    address internal constant ROYALTY_ADDRESS = 0x8C1A581a19A08Ddb1dB271c82da20D88977670A8;\r\n\r\n    uint256 internal constant AREA_COUNT = 51;\r\n    uint256 internal constant TARGET_AREA = 0;\r\n    uint256 internal constant SOURCE_AREA = 1;\r\n    uint256 internal constant ZONE_START = 46;\r\n    uint256 internal constant ZONE_COUNT = 5;\r\n\r\n    uint256[][] internal UNLOCKED_CONFIGS = [\r\n        [uint256(16 * 10**15), 0, 0, 0, 5, 4],\r\n        [uint256(32 * 10**15), 0, 0, 0, 4, 3],\r\n        [uint256(128 * 10**15), 0, 0, 0, 3, 2]\r\n    ];\r\n\r\n    uint256[][] internal OWNED_CONFIGS = [\r\n        [uint256(90), 2, 3, 5, 4],\r\n        [uint256(80), 0, 5, 4, 3],\r\n        [uint256(99), 0, 1, 3, 2]\r\n    ];\r\n\r\n    uint256 internal constant DISTRICT_UNLOCK_TIME = 1 minutes;\r\n    uint256 internal constant ZONE_UNLOCK_TIME = 3 minutes;\r\n    uint256 internal constant TARGET_UNLOCK_TIME = 10 minutes;\r\n\r\n    uint256 internal constant END_TIME_COUNTDOWN = 6 hours;\r\n    uint256 internal constant DISTRICT_END_TIME_EXTENSION = 30 seconds;\r\n    uint256 internal constant ZONE_END_TIME_EXTENSION = 1 minutes;\r\n    uint256 internal constant TARGET_END_TIME_EXTENSION = 3 minutes;\r\n\r\n    uint256 internal constant LAST_OWNER_SHARE = 55;\r\n    uint256 internal constant TARGET_OWNER_SHARE = 30;\r\n    uint256 internal constant SOURCE_OWNER_SHARE = 5;\r\n    uint256 internal constant ZONE_OWNERS_SHARE = 10;\r\n}\r\n\r\n\r\ncontract Main is Configs, Geo, MultiOwnable {\r\n\r\n    using MathLib for uint256;\r\n\r\n    uint256 private endTime;\r\n    uint256 private countdown;\r\n    address private lastOwner;\r\n\r\n    event Settings(uint256 lastOwnerShare, uint256 targetOwnerShare, uint256 sourceOwnerShare, uint256 zoneOwnersShare);\r\n    event Summary(uint256 currentTime, uint256 endTime, uint256 prize, address lastOwner);\r\n    event Reset();\r\n    event Start();\r\n    event Finish();\r\n    event Unlock(address indexed player, uint256 indexed areaId, uint256 unlockTime);\r\n    event Acquisition(address indexed player, uint256 indexed areaId, uint256 price, uint256 newPrice);\r\n    event Post(address indexed player, uint256 indexed areaId, string message);\r\n    event Dub(address indexed player, string nickname);\r\n\r\n    modifier onlyHuman {\r\n        uint256 codeSize;\r\n        address sender = msg.sender;\r\n        assembly { codeSize := extcodesize(sender) }\r\n\r\n        require(sender == tx.origin, \"Sorry, human only\");\r\n        require(codeSize == 0, \"Sorry, human only\");\r\n\r\n        _;\r\n    }\r\n\r\n    constructor () public MultiOwnable(GAME_MASTER_ADDRESSES) { }\r\n\r\n    function init() external onlyOwner {\r\n        require(countdown == 0 && endTime == 0, \"Game has already been initialized\");\r\n\r\n        initAreas();\r\n        reset();\r\n\r\n        emit Settings(LAST_OWNER_SHARE, TARGET_OWNER_SHARE, SOURCE_OWNER_SHARE, ZONE_OWNERS_SHARE);\r\n    }\r\n\r\n    function start() external onlyOwner {\r\n        require(areas[SOURCE_AREA].status == Status.Locked, \"Game has already started\");\r\n\r\n        areas[SOURCE_AREA].status = Status.Unlocked;\r\n\r\n        emit Start();\r\n    }\r\n\r\n    function finish() external onlyOwner {\r\n        require(endTime > 0 && now >= endTime, \"Cannot end yet\");\r\n\r\n        uint256 unitValue = address(this).balance.div(100);\r\n        uint256 zoneValue = unitValue.mul(ZONE_OWNERS_SHARE).div(ZONE_COUNT);\r\n\r\n        for (uint256 i = 0; i < ZONE_COUNT; i++) {\r\n            areas[ZONE_START.add(i)].owner.transfer(zoneValue);\r\n        }\r\n        lastOwner.transfer(unitValue.mul(LAST_OWNER_SHARE));\r\n        areas[TARGET_AREA].owner.transfer(unitValue.mul(TARGET_OWNER_SHARE));\r\n        areas[SOURCE_AREA].owner.transfer(unitValue.mul(SOURCE_OWNER_SHARE));\r\n\r\n        emit Finish();\r\n\r\n        for (i = 0; i < AREA_COUNT; i++) {\r\n            delete areas[i].cost;\r\n            delete areas[i].owner;\r\n            delete areas[i].status;\r\n            delete areas[i].unlockTime;\r\n        }\r\n        reset();\r\n    }\r\n\r\n    function acquire(uint256 areaId) external payable onlyHuman {\r\n        //TODO: trigger special events within this function somewhere\r\n\r\n        require(endTime == 0 || now < endTime, \"Game has ended\");\r\n\r\n        Area storage area = areas[areaId];\r\n        if (area.status == Status.Unlocked) {\r\n            area.cost = getInitialCost(area);            \r\n        }\r\n\r\n        require(area.status != Status.Locked, \"Cannot acquire locked area\");\r\n        require(area.unlockTime <= now, \"Cannot acquire yet\");\r\n        require(area.owner != msg.sender, \"Cannot acquire already owned area\");\r\n        require(area.cost == msg.value, \"Incorrect value for acquiring this area\");\r\n\r\n        uint256 unitValue = msg.value.div(100);\r\n        uint256 ownerShare;\r\n        uint256 parentShare;\r\n        uint256 devShare;\r\n        uint256 inflationNum;\r\n        uint256 inflationDenom;\r\n        (ownerShare, parentShare, devShare, inflationNum, inflationDenom) = getConfigs(area);\r\n\r\n        if (ownerShare > 0) {\r\n            area.owner.transfer(unitValue.mul(ownerShare));\r\n        }\r\n        if (parentShare > 0 && areas[area.parent].status == Status.Owned) {\r\n            areas[area.parent].owner.transfer(unitValue.mul(parentShare));\r\n        }\r\n        if (devShare > 0) {\r\n            ROYALTY_ADDRESS.transfer(unitValue.mul(devShare));\r\n        }\r\n\r\n        area.cost = area.cost.mul(inflationNum).div(inflationDenom);\r\n        area.owner = msg.sender;\r\n        if (area.class != Class.Target) {\r\n            lastOwner = msg.sender;\r\n        }\r\n\r\n        emit Acquisition(msg.sender, areaId, msg.value, area.cost);        \r\n\r\n        if (area.status == Status.Unlocked) {\r\n            area.status = Status.Owned;\r\n            countdown = countdown.sub(1);\r\n\r\n            if (area.class == Class.District) {\r\n                tryUnlockSiblings(area);\r\n                tryUnlockParent(area);\r\n            } else if (area.class == Class.Zone) {\r\n                tryUnlockTarget();\r\n            } else if (area.class == Class.Target) {\r\n                endTime = now.add(END_TIME_COUNTDOWN);\r\n            }\r\n        } else if (area.status == Status.Owned) {\r\n            if (endTime > 0) {\r\n                if (area.class == Class.District) {\r\n                    endTime = endTime.add(DISTRICT_END_TIME_EXTENSION);\r\n                } else if (area.class == Class.Zone) {\r\n                    endTime = endTime.add(ZONE_END_TIME_EXTENSION);\r\n                } else if (area.class == Class.Target) {\r\n                    endTime = endTime.add(TARGET_END_TIME_EXTENSION);\r\n                }\r\n            }\r\n\r\n            if (endTime > now.add(END_TIME_COUNTDOWN)) {\r\n                endTime = now.add(END_TIME_COUNTDOWN);\r\n            }\r\n        }\r\n\r\n        emit Summary(now, endTime, address(this).balance, lastOwner);\r\n    }\r\n\r\n    function post(uint256 areaId, string message) external onlyHuman {\r\n        require(areas[areaId].owner == msg.sender, \"Cannot post message on other's area\");\r\n\r\n        emit Post(msg.sender, areaId, message);\r\n    }\r\n\r\n    function dub(string nickname) external onlyHuman {\r\n        emit Dub(msg.sender, nickname);\r\n    }\r\n\r\n\r\n\r\n    function reset() private {\r\n        delete endTime;\r\n        countdown = AREA_COUNT;\r\n        delete lastOwner;\r\n        \r\n        emit Reset();\r\n    }\r\n\r\n    function tryUnlockSiblings(Area storage area) private {\r\n        for (uint256 i = 0; i < area.siblings.length; i++) {\r\n            Area storage sibling = areas[area.siblings[i]];\r\n\r\n            if (sibling.status == Status.Locked) {\r\n                sibling.status = Status.Unlocked;\r\n                sibling.unlockTime = now.add(DISTRICT_UNLOCK_TIME);\r\n\r\n                emit Unlock(msg.sender, area.siblings[i], sibling.unlockTime);\r\n            }\r\n        }\r\n    }\r\n\r\n    function tryUnlockParent(Area storage area) private {\r\n        Area storage parent = areas[area.parent];\r\n\r\n        for (uint256 i = 0; i < parent.children.length; i++) {\r\n            Area storage child = areas[parent.children[i]];\r\n\r\n            if (child.status != Status.Owned) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        parent.status = Status.Unlocked;\r\n        parent.unlockTime = now.add(ZONE_UNLOCK_TIME);\r\n\r\n        emit Unlock(msg.sender, area.parent, parent.unlockTime);\r\n    }\r\n\r\n    function tryUnlockTarget() private {\r\n        if (countdown == 1) {\r\n            areas[TARGET_AREA].status = Status.Unlocked;\r\n            areas[TARGET_AREA].unlockTime = now.add(TARGET_UNLOCK_TIME);\r\n\r\n            emit Unlock(msg.sender, TARGET_AREA, areas[TARGET_AREA].unlockTime);\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function getInitialCost(Area storage area) private view returns (uint256) {\r\n        return UNLOCKED_CONFIGS[uint256(area.class)][0];\r\n    }\r\n\r\n    function getConfigs(Area storage area) private view returns (uint256, uint256, uint256, uint256, uint256) {\r\n        uint256 index = uint256(area.class);\r\n        \r\n        if (area.status == Status.Unlocked) {\r\n            return (UNLOCKED_CONFIGS[index][1], UNLOCKED_CONFIGS[index][2], UNLOCKED_CONFIGS[index][3], UNLOCKED_CONFIGS[index][4], UNLOCKED_CONFIGS[index][5]);\r\n        } else if (area.status == Status.Owned) {\r\n            return (OWNED_CONFIGS[index][0], OWNED_CONFIGS[index][1], OWNED_CONFIGS[index][2], OWNED_CONFIGS[index][3], OWNED_CONFIGS[index][4]);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"nickname\",\"type\":\"string\"}],\"name\":\"dub\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"heir\",\"type\":\"address\"}],\"name\":\"appointHeir\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"areaId\",\"type\":\"uint256\"}],\"name\":\"acquire\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"areaId\",\"type\":\"uint256\"},{\"name\":\"message\",\"type\":\"string\"}],\"name\":\"post\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"succeedOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owners\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finish\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"lastOwnerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"targetOwnerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sourceOwnerShare\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"zoneOwnersShare\",\"type\":\"uint256\"}],\"name\":\"Settings\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"currentTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prize\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lastOwner\",\"type\":\"address\"}],\"name\":\"Summary\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Reset\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Start\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finish\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"areaId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unlockTime\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"areaId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPrice\",\"type\":\"uint256\"}],\"name\":\"Acquisition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"areaId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"Post\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nickname\",\"type\":\"string\"}],\"name\":\"Dub\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"heir\",\"type\":\"address\"}],\"name\":\"HeirAppointment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"heir\",\"type\":\"address\"}],\"name\":\"OwnershipSuccession\",\"type\":\"event\"}]","ContractName":"Main","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://382571e4ddfa1ee8e56b885cc0c1b961b089bc3fc29d605ffb6a520353f6065a"}]}