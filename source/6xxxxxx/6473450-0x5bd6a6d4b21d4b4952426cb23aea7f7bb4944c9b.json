{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.25;\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n//                 Recon® Token Teleportation Service v1.10\r\n//\r\n//                           of BlockReconChain®\r\n//                             for ReconBank®\r\n//\r\n//                     ERC Token Standard #20 Interface\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//.\r\n//\"\r\n//.             ::::::..  .,::::::  .,-:::::     ...    :::.    :::\r\n//.           ;;;;``;;;; ;;;;'''' ,;;;'````'  .;;;;;;;.`;;;;,  `;;;\r\n//.            [[[,/[[['  [[cccc  [[[        ,[[     \\[[,[[[[[. '[[\r\n//.            $$$$$$c    $$\"\"\"\"  $$$        $$$,     $$$$$$ \"Y$c$$\r\n//.            888b \"88bo,888oo,__`88bo,__,o,\"888,_ _,88P888    Y88\r\n//.            MMMM   \"W\" \"\"\"\"YUMMM \"YUMMMMMP\" \"YMMMMMP\" MMM     YM\r\n//.\r\n//.\r\n//\" -----------------------------------------------------------------------------------------------------------------\r\n//             ¸.•*´¨)\r\n//        ¸.•´   ¸.•´¸.•*´¨) ¸.•*¨)\r\n//  ¸.•*´       (¸.•´ (¸.•` ¤ ReconBank.eth / ReconBank.com*´¨)\r\n//                                                        ¸.•´¸.•*´¨)\r\n//                                                      (¸.•´   ¸.•`\r\n//                                                          ¸.•´•.¸\r\n//   (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// Common ownership of :\r\n//  ____  _            _    _____                       _____ _           _\r\n// |  _ \\| |          | |  |  __ \\                     / ____| |         (_)\r\n// | |_) | | ___   ___| | _| |__) |___  ___ ___  _ __ | |    | |__   __ _ _ _ __\r\n// |  _ <| |/ _ \\ / __| |/ /  _  // _ \\/ __/ _ \\| '_ \\| |    | '_ \\ / _` | | '_ \\\r\n// | |_) | | (_) | (__|   <| | \\ \\  __/ (_| (_) | | | | |____| | | | (_| | | | | |\r\n// |____/|_|\\___/ \\___|_|\\_\\_|  \\_\\___|\\___\\___/|_| |_|\\_____|_| |_|\\__,_|_|_| |_|®\r\n//'\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// This contract is an order from :\r\n//'\r\n// ██████╗ ███████╗ ██████╗ ██████╗ ███╗   ██╗██████╗  █████╗ ███╗   ██╗██╗  ██╗    ██████╗ ██████╗ ███╗   ███╗®\r\n// ██╔══██╗██╔════╝██╔════╝██╔═══██╗████╗  ██║██╔══██╗██╔══██╗████╗  ██║██║ ██╔╝   ██╔════╝██╔═══██╗████╗ ████║\r\n// ██████╔╝█████╗  ██║     ██║   ██║██╔██╗ ██║██████╔╝███████║██╔██╗ ██║█████╔╝    ██║     ██║   ██║██╔████╔██║\r\n// ██╔══██╗██╔══╝  ██║     ██║   ██║██║╚██╗██║██╔══██╗██╔══██║██║╚██╗██║██╔═██╗    ██║     ██║   ██║██║╚██╔╝██║\r\n// ██║  ██║███████╗╚██████╗╚██████╔╝██║ ╚████║██████╔╝██║  ██║██║ ╚████║██║  ██╗██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\r\n// ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝'\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n//\r\n//                                 Copyright MIT :\r\n//                      GNU Lesser General Public License 3.0\r\n//                  https://www.gnu.org/licenses/lgpl-3.0.en.html\r\n//\r\n//              Permission is hereby granted, free of charge, to\r\n//              any person obtaining a copy of this software and\r\n//              associated documentation files ReconCoin® Token\r\n//              Teleportation Service, to deal in the Software without\r\n//              restriction, including without limitation the rights to\r\n//              use, copy, modify, merge, publish, distribute,\r\n//              sublicense, and/or sell copies of the Software, and\r\n//              to permit persons to whom the Software is furnished\r\n//              to do so, subject to the following conditions:\r\n//              The above copyright notice and this permission\r\n//              notice shall be included in all copies or substantial\r\n//              portions of the Software.\r\n//\r\n//                 THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT\r\n//                 WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\r\n//                 INCLUDING BUT NOT LIMITED TO THE\r\n//                 WARRANTIES OF MERCHANTABILITY, FITNESS FOR\r\n//                 A PARTICULAR PURPOSE AND NONINFRINGEMENT.\r\n//                 IN NO EVENT SHALL THE AUTHORS OR\r\n//                 COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\r\n//                 DAMAGES OR OTHER LIABILITY, WHETHER IN AN\r\n//                 ACTION OF CONTRACT, TORT OR\r\n//                 OTHERWISE, ARISING FROM, OUT OF OR IN\r\n//                 CONNECTION WITH THE SOFTWARE OR THE USE\r\n//                 OR OTHER DEALINGS IN THE SOFTWARE.\r\n//\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n// The new assembly support in Solidity makes writing helpers easy.\r\n// Many have complained how complex it is to use `ecrecover`, especially in conjunction\r\n// with the `eth_sign` RPC call. Here is a helper, which makes that a matter of a single call.\r\n//\r\n// Sample input parameters:\r\n// (with v=0)\r\n// \"0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad\",\r\n// \"0xaca7da997ad177f040240cdccf6905b71ab16b74434388c3a72f34fd25d6439346b2bac274ff29b48b3ea6e2d04c1336eaceafda3c53ab483fc3ff12fac3ebf200\",\r\n// \"0x0e5cb767cce09a7f3ca594df118aa519be5e2b5a\"\r\n//\r\n// (with v=1)\r\n// \"0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad\",\r\n// \"0xdebaaa0cddb321b2dcaaf846d39605de7b97e77ba6106587855b9106cb10421561a22d94fa8b8a687ff9c911c844d1c016d1a685a9166858f9c7c1bc85128aca01\",\r\n// \"0x8743523d96a1b2cbe0c6909653a56da18ed484af\"\r\n//\r\n// (The hash is a hash of \"hello world\".)\r\n//\r\n// Written by Alex Beregszaszi (@axic), use it under the terms of the MIT license.\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\nlibrary ReconVerify {\r\n    // Duplicate Soliditys ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but dont update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        // FIXME: inline assembly cant access return values\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, hash)\r\n            mstore(add(size, 32), v)\r\n            mstore(add(size, 64), r)\r\n            mstore(add(size, 96), s)\r\n\r\n            // NOTE: we can reuse the request memory because we deal with\r\n            //       the return code\r\n            ret := call(3000, 1, 0, size, 128, size, 32)\r\n            addr := mload(size)\r\n        }\r\n\r\n        return (ret, addr);\r\n    }\r\n\r\n    function ecrecovery(bytes32 hash, bytes sig) public returns (bool, address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65)\r\n          return (false, 0);\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n\r\n            // Here we are loading the last 32 bytes. We exploit the fact that\r\n            // 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n\r\n            // Alternative solution:\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            // v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\r\n        // to match the YP range of [27, 28]\r\n        //\r\n        // geth uses [0, 1] and some clients have followed. This might change, see:\r\n        //  https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27)\r\n          v += 27;\r\n\r\n        if (v != 27 && v != 28)\r\n            return (false, 0);\r\n\r\n        return safer_ecrecover(hash, v, r, s);\r\n    }\r\n\r\n    function verify(bytes32 hash, bytes sig, address signer) public returns (bool) {\r\n        bool ret;\r\n        address addr;\r\n        (ret, addr) = ecrecovery(hash, sig);\r\n        return ret == true && addr == signer;\r\n    }\r\n\r\n    function recover(bytes32 hash, bytes sig) internal returns (address addr) {\r\n        bool ret;\r\n        (ret, addr) = ecrecovery(hash, sig);\r\n    }\r\n}\r\n\r\ncontract ReconVerifyTest {\r\n    function test_v0() public returns (bool) {\r\n        bytes32 hash = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad;\r\n        bytes memory sig = \"\\xac\\xa7\\xda\\x99\\x7a\\xd1\\x77\\xf0\\x40\\x24\\x0c\\xdc\\xcf\\x69\\x05\\xb7\\x1a\\xb1\\x6b\\x74\\x43\\x43\\x88\\xc3\\xa7\\x2f\\x34\\xfd\\x25\\xd6\\x43\\x93\\x46\\xb2\\xba\\xc2\\x74\\xff\\x29\\xb4\\x8b\\x3e\\xa6\\xe2\\xd0\\x4c\\x13\\x36\\xea\\xce\\xaf\\xda\\x3c\\x53\\xab\\x48\\x3f\\xc3\\xff\\x12\\xfa\\xc3\\xeb\\xf2\\x00\";\r\n        return ReconVerify.verify(hash, sig, 0x0A5f85C3d41892C934ae82BDbF17027A20717088);\r\n    }\r\n\r\n    function test_v1() public returns (bool) {\r\n        bytes32 hash = 0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad;\r\n        bytes memory sig = \"\\xde\\xba\\xaa\\x0c\\xdd\\xb3\\x21\\xb2\\xdc\\xaa\\xf8\\x46\\xd3\\x96\\x05\\xde\\x7b\\x97\\xe7\\x7b\\xa6\\x10\\x65\\x87\\x85\\x5b\\x91\\x06\\xcb\\x10\\x42\\x15\\x61\\xa2\\x2d\\x94\\xfa\\x8b\\x8a\\x68\\x7f\\xf9\\xc9\\x11\\xc8\\x44\\xd1\\xc0\\x16\\xd1\\xa6\\x85\\xa9\\x16\\x68\\x58\\xf9\\xc7\\xc1\\xbc\\x85\\x12\\x8a\\xca\\x01\";\r\n        return ReconVerify.verify(hash, sig, 0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\r\n    }\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\ncontract owned {\r\n    address public owner;\r\n\r\n    function ReconOwned()  public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) onlyOwner  public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\ncontract tokenRecipient {\r\n    event receivedEther(address sender, uint amount);\r\n    event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData);\r\n\r\n    function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public {\r\n        Token t = Token(_token);\r\n        require(t.transferFrom(_from, this, _value));\r\n        emit receivedTokens(_from, _value, _token, _extraData);\r\n    }\r\n\r\n    function () payable  public {\r\n        emit receivedEther(msg.sender, msg.value);\r\n    }\r\n}\r\n\r\n\r\ninterface Token {\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n}\r\n\r\n\r\ncontract Congress is owned, tokenRecipient {\r\n    // Contract Variables and events\r\n    uint public minimumQuorum;\r\n    uint public debatingPeriodInMinutes;\r\n    int public majorityMargin;\r\n    Proposal[] public proposals;\r\n    uint public numProposals;\r\n    mapping (address => uint) public memberId;\r\n    Member[] public members;\r\n\r\n    event ProposalAdded(uint proposalID, address recipient, uint amount, string description);\r\n    event Voted(uint proposalID, bool position, address voter, string justification);\r\n    event ProposalTallied(uint proposalID, int result, uint quorum, bool active);\r\n    event MembershipChanged(address member, bool isMember);\r\n    event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, int newMajorityMargin);\r\n\r\n    struct Proposal {\r\n        address recipient;\r\n        uint amount;\r\n        string description;\r\n        uint minExecutionDate;\r\n        bool executed;\r\n        bool proposalPassed;\r\n        uint numberOfVotes;\r\n        int currentResult;\r\n        bytes32 proposalHash;\r\n        Vote[] votes;\r\n        mapping (address => bool) voted;\r\n    }\r\n\r\n    struct Member {\r\n        address member;\r\n        string name;\r\n        uint memberSince;\r\n    }\r\n\r\n    struct Vote {\r\n        bool inSupport;\r\n        address voter;\r\n        string justification;\r\n    }\r\n\r\n    // Modifier that allows only shareholders to vote and create new proposals\r\n    modifier onlyMembers {\r\n        require(memberId[msg.sender] != 0);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * Constructor function\r\n     */\r\n    function ReconCongress (\r\n        uint minimumQuorumForProposals,\r\n        uint minutesForDebate,\r\n        int marginOfVotesForMajority\r\n    )  payable public {\r\n        changeVotingRules(minimumQuorumForProposals, minutesForDebate, marginOfVotesForMajority);\r\n        // It’s necessary to add an empty first member\r\n        addMember(0, \"\");\r\n        // and lets add the founder, to save a step later\r\n        addMember(owner, 'founder');\r\n    }\r\n\r\n    /**\r\n     * Add member\r\n     *\r\n     * Make `targetMember` a member named `memberName`\r\n     *\r\n     * @param targetMember ethereum address to be added\r\n     * @param memberName public name for that member\r\n     */\r\n    function addMember(address targetMember, string memberName) onlyOwner public {\r\n        uint id = memberId[targetMember];\r\n        if (id == 0) {\r\n            memberId[targetMember] = members.length;\r\n            id = members.length++;\r\n        }\r\n\r\n        members[id] = Member({member: targetMember, memberSince: now, name: memberName});\r\n        emit MembershipChanged(targetMember, true);\r\n    }\r\n\r\n    /**\r\n     * Remove member\r\n     *\r\n     * @notice Remove membership from `targetMember`\r\n     *\r\n     * @param targetMember ethereum address to be removed\r\n     */\r\n    function removeMember(address targetMember) onlyOwner public {\r\n        require(memberId[targetMember] != 0);\r\n\r\n        for (uint i = memberId[targetMember]; i<members.length-1; i++){\r\n            members[i] = members[i+1];\r\n        }\r\n        delete members[members.length-1];\r\n        members.length--;\r\n    }\r\n\r\n    /**\r\n     * Change voting rules\r\n     *\r\n     * Make so that proposals need to be discussed for at least `minutesForDebate/60` hours,\r\n     * have at least `minimumQuorumForProposals` votes, and have 50% + `marginOfVotesForMajority` votes to be executed\r\n     *\r\n     * @param minimumQuorumForProposals how many members must vote on a proposal for it to be executed\r\n     * @param minutesForDebate the minimum amount of delay between when a proposal is made and when it can be executed\r\n     * @param marginOfVotesForMajority the proposal needs to have 50% plus this number\r\n     */\r\n    function changeVotingRules(\r\n        uint minimumQuorumForProposals,\r\n        uint minutesForDebate,\r\n        int marginOfVotesForMajority\r\n    ) onlyOwner public {\r\n        minimumQuorum = minimumQuorumForProposals;\r\n        debatingPeriodInMinutes = minutesForDebate;\r\n        majorityMargin = marginOfVotesForMajority;\r\n\r\n        emit ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, majorityMargin);\r\n    }\r\n\r\n    /**\r\n     * Add Proposal\r\n     *\r\n     * Propose to send `weiAmount / 1e18` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\r\n     *\r\n     * @param beneficiary who to send the ether to\r\n     * @param weiAmount amount of ether to send, in wei\r\n     * @param jobDescription Description of job\r\n     * @param transactionBytecode bytecode of transaction\r\n     */\r\n    function newProposal(\r\n        address beneficiary,\r\n        uint weiAmount,\r\n        string jobDescription,\r\n        bytes transactionBytecode\r\n    )\r\n        onlyMembers public\r\n        returns (uint proposalID)\r\n    {\r\n        proposalID = proposals.length++;\r\n        Proposal storage p = proposals[proposalID];\r\n        p.recipient = beneficiary;\r\n        p.amount = weiAmount;\r\n        p.description = jobDescription;\r\n        p.proposalHash = keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\r\n        p.minExecutionDate = now + debatingPeriodInMinutes * 1 minutes;\r\n        p.executed = false;\r\n        p.proposalPassed = false;\r\n        p.numberOfVotes = 0;\r\n        emit ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription);\r\n        numProposals = proposalID+1;\r\n\r\n        return proposalID;\r\n    }\r\n\r\n    /**\r\n     * Add proposal in Ether\r\n     *\r\n     * Propose to send `etherAmount` ether to `beneficiary` for `jobDescription`. `transactionBytecode ? Contains : Does not contain` code.\r\n     * This is a convenience function to use if the amount to be given is in round number of ether units.\r\n     *\r\n     * @param beneficiary who to send the ether to\r\n     * @param etherAmount amount of ether to send\r\n     * @param jobDescription Description of job\r\n     * @param transactionBytecode bytecode of transaction\r\n     */\r\n    function newProposalInEther(\r\n        address beneficiary,\r\n        uint etherAmount,\r\n        string jobDescription,\r\n        bytes transactionBytecode\r\n    )\r\n        onlyMembers public\r\n        returns (uint proposalID)\r\n    {\r\n        return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode);\r\n    }\r\n\r\n    /**\r\n     * Check if a proposal code matches\r\n     *\r\n     * @param proposalNumber ID number of the proposal to query\r\n     * @param beneficiary who to send the ether to\r\n     * @param weiAmount amount of ether to send\r\n     * @param transactionBytecode bytecode of transaction\r\n     */\r\n    function checkProposalCode(\r\n        uint proposalNumber,\r\n        address beneficiary,\r\n        uint weiAmount,\r\n        bytes transactionBytecode\r\n    )\r\n        constant public\r\n        returns (bool codeChecksOut)\r\n    {\r\n        Proposal storage p = proposals[proposalNumber];\r\n        return p.proposalHash == keccak256(abi.encodePacked(beneficiary, weiAmount, transactionBytecode));\r\n    }\r\n\r\n    /**\r\n     * Log a vote for a proposal\r\n     *\r\n     * Vote `supportsProposal? in support of : against` proposal #`proposalNumber`\r\n     *\r\n     * @param proposalNumber number of proposal\r\n     * @param supportsProposal either in favor or against it\r\n     * @param justificationText optional justification text\r\n     */\r\n    function vote(\r\n        uint proposalNumber,\r\n        bool supportsProposal,\r\n        string justificationText\r\n    )\r\n        onlyMembers public\r\n        returns (uint voteID)\r\n    {\r\n        Proposal storage p = proposals[proposalNumber]; // Get the proposal\r\n        require(!p.voted[msg.sender]);                  // If has already voted, cancel\r\n        p.voted[msg.sender] = true;                     // Set this voter as having voted\r\n        p.numberOfVotes++;                              // Increase the number of votes\r\n        if (supportsProposal) {                         // If they support the proposal\r\n            p.currentResult++;                          // Increase score\r\n        } else {                                        // If they dont\r\n            p.currentResult--;                          // Decrease the score\r\n        }\r\n\r\n        // Create a log of this event\r\n        emit Voted(proposalNumber,  supportsProposal, msg.sender, justificationText);\r\n        return p.numberOfVotes;\r\n    }\r\n\r\n    /**\r\n     * Finish vote\r\n     *\r\n     * Count the votes proposal #`proposalNumber` and execute it if approved\r\n     *\r\n     * @param proposalNumber proposal number\r\n     * @param transactionBytecode optional: if the transaction contained a bytecode, you need to send it\r\n     */\r\n    function executeProposal(uint proposalNumber, bytes transactionBytecode) public {\r\n        Proposal storage p = proposals[proposalNumber];\r\n\r\n        require(now > p.minExecutionDate                                            // If it is past the voting deadline\r\n            && !p.executed                                                         // and it has not already been executed\r\n            && p.proposalHash == keccak256(abi.encodePacked(p.recipient, p.amount, transactionBytecode))  // and the supplied code matches the proposal\r\n            && p.numberOfVotes >= minimumQuorum);                                  // and a minimum quorum has been reached...\r\n\r\n        // ...then execute result\r\n\r\n        if (p.currentResult > majorityMargin) {\r\n            // Proposal passed; execute the transaction\r\n\r\n            p.executed = true; // Avoid recursive calling\r\n            require(p.recipient.call.value(p.amount)(transactionBytecode));\r\n\r\n            p.proposalPassed = true;\r\n        } else {\r\n            // Proposal failed\r\n            p.proposalPassed = false;\r\n        }\r\n\r\n        // Fire Events\r\n        emit ProposalTallied(proposalNumber, p.currentResult, p.numberOfVotes, p.proposalPassed);\r\n    }\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Recon DateTime Library v1.00\r\n//\r\n// A energy-efficient Solidity date and time library\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// GNU Lesser General Public License 3.0\r\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary ReconDateTimeLibrary {\r\n\r\n    uint constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint constant SECONDS_PER_MINUTE = 60;\r\n    int constant OFFSET19700101 = 2440588;\r\n\r\n    uint constant DOW_MON = 1;\r\n    uint constant DOW_TUE = 2;\r\n    uint constant DOW_WED = 3;\r\n    uint constant DOW_THU = 4;\r\n    uint constant DOW_FRI = 5;\r\n    uint constant DOW_SAT = 6;\r\n    uint constant DOW_SUN = 7;\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate the number of days from 1970/01/01 to year/month/day using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and subtracting the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // days = day\r\n    //      - 32075\r\n    //      + 1461 * (year + 4800 + (month - 14) / 12) / 4\r\n    //      + 367 * (month - 2 - (month - 14) / 12 * 12) / 12\r\n    //      - 3 * ((year + 4900 + (month - 14) / 12) / 100) / 4\r\n    //      - offset\r\n    // ------------------------------------------------------------------------\r\n    function _daysFromDate(uint year, uint month, uint day) internal pure returns (uint _days) {\r\n        int _year = int(year);\r\n        int _month = int(month);\r\n        int _day = int(day);\r\n\r\n        int __days = _day\r\n          - 32075\r\n          + 1461 * (_year + 4800 + (_month - 14) / 12) / 4\r\n          + 367 * (_month - 2 - (_month - 14) / 12 * 12) / 12\r\n          - 3 * ((_year + 4900 + (_month - 14) / 12) / 100) / 4\r\n          - OFFSET19700101;\r\n\r\n        _days = uint(__days);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Calculate year/month/day from the number of days since 1970/01/01 using\r\n    // the date conversion algorithm from\r\n    //   http://aa.usno.navy.mil/faq/docs/JD_Formula.php\r\n    // and adding the offset 2440588 so that 1970/01/01 is day 0\r\n    //\r\n    // int L = days + 68569 + offset\r\n    // int N = 4 * L / 146097\r\n    // L = L - (146097 * N + 3) / 4\r\n    // year = 4000 * (L + 1) / 1461001\r\n    // L = L - 1461 * year / 4 + 31\r\n    // month = 80 * L / 2447\r\n    // dd = L - 2447 * month / 80\r\n    // L = month / 11\r\n    // month = month + 2 - 12 * L\r\n    // year = 100 * (N - 49) + year + L\r\n    // ------------------------------------------------------------------------\r\n    function _daysToDate(uint _days) internal pure returns (uint year, uint month, uint day) {\r\n        int __days = int(_days);\r\n\r\n        int L = __days + 68569 + OFFSET19700101;\r\n        int N = 4 * L / 146097;\r\n        L = L - (146097 * N + 3) / 4;\r\n        int _year = 4000 * (L + 1) / 1461001;\r\n        L = L - 1461 * _year / 4 + 31;\r\n        int _month = 80 * L / 2447;\r\n        int _day = L - 2447 * _month / 80;\r\n        L = _month / 11;\r\n        _month = _month + 2 - 12 * L;\r\n        _year = 100 * (N - 49) + _year + L;\r\n\r\n        year = uint(_year);\r\n        month = uint(_month);\r\n        day = uint(_day);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY;\r\n    }\r\n\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) internal pure returns (uint timestamp) {\r\n        timestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + hour * SECONDS_PER_HOUR + minute * SECONDS_PER_MINUTE + second;\r\n    }\r\n\r\n    function timestampToDate(uint timestamp) internal pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function timestampToDateTime(uint timestamp) internal pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n        secs = secs % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n        second = secs % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function isLeapYear(uint timestamp) internal pure returns (bool leapYear) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        leapYear = _isLeapYear(year);\r\n    }\r\n\r\n    function _isLeapYear(uint year) internal pure returns (bool leapYear) {\r\n        leapYear = ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);\r\n    }\r\n\r\n    function isWeekDay(uint timestamp) internal pure returns (bool weekDay) {\r\n        weekDay = getDayOfWeek(timestamp) <= DOW_FRI;\r\n    }\r\n\r\n    function isWeekEnd(uint timestamp) internal pure returns (bool weekEnd) {\r\n        weekEnd = getDayOfWeek(timestamp) >= DOW_SAT;\r\n    }\r\n\r\n    function getDaysInMonth(uint timestamp) internal pure returns (uint daysInMonth) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        daysInMonth = _getDaysInMonth(year, month);\r\n    }\r\n\r\n    function _getDaysInMonth(uint year, uint month) internal pure returns (uint daysInMonth) {\r\n        if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n            daysInMonth = 31;\r\n        } else if (month != 2) {\r\n            daysInMonth = 30;\r\n        } else {\r\n            daysInMonth = _isLeapYear(year) ? 29 : 28;\r\n        }\r\n    }\r\n    // 1 = Monday, 7 = Sunday\r\n    function getDayOfWeek(uint timestamp) internal pure returns (uint dayOfWeek) {\r\n        uint _days = timestamp / SECONDS_PER_DAY;\r\n        dayOfWeek = (_days + 3) % 7 + 1;\r\n    }\r\n\r\n    function getYear(uint timestamp) internal pure returns (uint year) {\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function getMonth(uint timestamp) internal pure returns (uint month) {\r\n        uint year;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function getDay(uint timestamp) internal pure returns (uint day) {\r\n        uint year;\r\n        uint month;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n    }\r\n\r\n    function getHour(uint timestamp) internal pure returns (uint hour) {\r\n        uint secs = timestamp % SECONDS_PER_DAY;\r\n        hour = secs / SECONDS_PER_HOUR;\r\n    }\r\n\r\n    function getMinute(uint timestamp) internal pure returns (uint minute) {\r\n        uint secs = timestamp % SECONDS_PER_HOUR;\r\n        minute = secs / SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function getSecond(uint timestamp) internal pure returns (uint second) {\r\n        second = timestamp % SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year += _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function addMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        month += _months;\r\n        year += (month - 1) / 12;\r\n        month = (month - 1) % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function addDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _days * SECONDS_PER_DAY;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function addHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function addMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function addSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp + _seconds;\r\n        require(newTimestamp >= timestamp);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        year -= _years;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function subMonths(uint timestamp, uint _months) internal pure returns (uint newTimestamp) {\r\n        uint year;\r\n        uint month;\r\n        uint day;\r\n        (year, month, day) = _daysToDate(timestamp / SECONDS_PER_DAY);\r\n        uint yearMonth = year * 12 + (month - 1) - _months;\r\n        year = yearMonth / 12;\r\n        month = yearMonth % 12 + 1;\r\n        uint daysInMonth = _getDaysInMonth(year, month);\r\n        if (day > daysInMonth) {\r\n            day = daysInMonth;\r\n        }\r\n        newTimestamp = _daysFromDate(year, month, day) * SECONDS_PER_DAY + timestamp % SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function subDays(uint timestamp, uint _days) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _days * SECONDS_PER_DAY;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function subHours(uint timestamp, uint _hours) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _hours * SECONDS_PER_HOUR;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function subMinutes(uint timestamp, uint _minutes) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _minutes * SECONDS_PER_MINUTE;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function subSeconds(uint timestamp, uint _seconds) internal pure returns (uint newTimestamp) {\r\n        newTimestamp = timestamp - _seconds;\r\n        require(newTimestamp <= timestamp);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _years) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        uint fromYear;\r\n        uint fromMonth;\r\n        uint fromDay;\r\n        uint toYear;\r\n        uint toMonth;\r\n        uint toDay;\r\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _years = toYear - fromYear;\r\n    }\r\n\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _months) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        uint fromYear;\r\n        uint fromMonth;\r\n        uint fromDay;\r\n        uint toYear;\r\n        uint toMonth;\r\n        uint toDay;\r\n        (fromYear, fromMonth, fromDay) = _daysToDate(fromTimestamp / SECONDS_PER_DAY);\r\n        (toYear, toMonth, toDay) = _daysToDate(toTimestamp / SECONDS_PER_DAY);\r\n        _months = toYear * 12 + toMonth - fromYear * 12 - fromMonth;\r\n    }\r\n\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _days) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _days = (toTimestamp - fromTimestamp) / SECONDS_PER_DAY;\r\n    }\r\n\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _hours) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _hours = (toTimestamp - fromTimestamp) / SECONDS_PER_HOUR;\r\n    }\r\n\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _minutes) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _minutes = (toTimestamp - fromTimestamp) / SECONDS_PER_MINUTE;\r\n    }\r\n\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) internal pure returns (uint _seconds) {\r\n        require(fromTimestamp <= toTimestamp);\r\n        _seconds = toTimestamp - fromTimestamp;\r\n    }\r\n}\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\n// ----------------------------------------------------------------------------\r\n// Recon DateTime Library v1.00 - Contract Instance\r\n//\r\n// A energy-efficient Solidity date and time library\r\n//\r\n//\r\n// Tested date range 1970/01/01 to 2345/12/31\r\n//\r\n// Conventions:\r\n// Unit      | Range         | Notes\r\n// :-------- |:-------------:|:-----\r\n// timestamp | >= 0          | Unix timestamp, number of seconds since 1970/01/01 00:00:00 UTC\r\n// year      | 1970 ... 2345 |\r\n// month     | 1 ... 12      |\r\n// day       | 1 ... 31      |\r\n// hour      | 0 ... 23      |\r\n// minute    | 0 ... 59      |\r\n// second    | 0 ... 59      |\r\n// dayOfWeek | 1 ... 7       | 1 = Monday, ..., 7 = Sunday\r\n//\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// GNU Lesser General Public License 3.0\r\n// https://www.gnu.org/licenses/lgpl-3.0.en.html\r\n// ----------------------------------------------------------------------------\r\n\r\ncontract ReconDateTimeContract {\r\n    uint public constant SECONDS_PER_DAY = 24 * 60 * 60;\r\n    uint public constant SECONDS_PER_HOUR = 60 * 60;\r\n    uint public constant SECONDS_PER_MINUTE = 60;\r\n    int public constant OFFSET19700101 = 2440588;\r\n\r\n    uint public constant DOW_MON = 1;\r\n    uint public constant DOW_TUE = 2;\r\n    uint public constant DOW_WED = 3;\r\n    uint public constant DOW_THU = 4;\r\n    uint public constant DOW_FRI = 5;\r\n    uint public constant DOW_SAT = 6;\r\n    uint public constant DOW_SUN = 7;\r\n\r\n    function _now() public view returns (uint timestamp) {\r\n        timestamp = now;\r\n    }\r\n\r\n    function _nowDateTime() public view returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day, hour, minute, second) = ReconDateTimeLibrary.timestampToDateTime(now);\r\n    }\r\n\r\n    function _daysFromDate(uint year, uint month, uint day) public pure returns (uint _days) {\r\n        return ReconDateTimeLibrary._daysFromDate(year, month, day);\r\n    }\r\n\r\n    function _daysToDate(uint _days) public pure returns (uint year, uint month, uint day) {\r\n        return ReconDateTimeLibrary._daysToDate(_days);\r\n    }\r\n\r\n    function timestampFromDate(uint year, uint month, uint day) public pure returns (uint timestamp) {\r\n        return ReconDateTimeLibrary.timestampFromDate(year, month, day);\r\n    }\r\n\r\n    function timestampFromDateTime(uint year, uint month, uint day, uint hour, uint minute, uint second) public pure returns (uint timestamp) {\r\n        return ReconDateTimeLibrary.timestampFromDateTime(year, month, day, hour, minute, second);\r\n    }\r\n\r\n    function timestampToDate(uint timestamp) public pure returns (uint year, uint month, uint day) {\r\n        (year, month, day) = ReconDateTimeLibrary.timestampToDate(timestamp);\r\n    }\r\n\r\n    function timestampToDateTime(uint timestamp) public pure returns (uint year, uint month, uint day, uint hour, uint minute, uint second) {\r\n        (year, month, day, hour, minute, second) = ReconDateTimeLibrary.timestampToDateTime(timestamp);\r\n    }\r\n\r\n    function isLeapYear(uint timestamp) public pure returns (bool leapYear) {\r\n        leapYear = ReconDateTimeLibrary.isLeapYear(timestamp);\r\n    }\r\n\r\n    function _isLeapYear(uint year) public pure returns (bool leapYear) {\r\n        leapYear = ReconDateTimeLibrary._isLeapYear(year);\r\n    }\r\n\r\n    function isWeekDay(uint timestamp) public pure returns (bool weekDay) {\r\n        weekDay = ReconDateTimeLibrary.isWeekDay(timestamp);\r\n    }\r\n\r\n    function isWeekEnd(uint timestamp) public pure returns (bool weekEnd) {\r\n        weekEnd = ReconDateTimeLibrary.isWeekEnd(timestamp);\r\n    }\r\n\r\n    function getDaysInMonth(uint timestamp) public pure returns (uint daysInMonth) {\r\n        daysInMonth = ReconDateTimeLibrary.getDaysInMonth(timestamp);\r\n    }\r\n\r\n    function _getDaysInMonth(uint year, uint month) public pure returns (uint daysInMonth) {\r\n        daysInMonth = ReconDateTimeLibrary._getDaysInMonth(year, month);\r\n    }\r\n\r\n    function getDayOfWeek(uint timestamp) public pure returns (uint dayOfWeek) {\r\n        dayOfWeek = ReconDateTimeLibrary.getDayOfWeek(timestamp);\r\n    }\r\n\r\n    function getYear(uint timestamp) public pure returns (uint year) {\r\n        year = ReconDateTimeLibrary.getYear(timestamp);\r\n    }\r\n\r\n    function getMonth(uint timestamp) public pure returns (uint month) {\r\n        month = ReconDateTimeLibrary.getMonth(timestamp);\r\n    }\r\n\r\n    function getDay(uint timestamp) public pure returns (uint day) {\r\n        day = ReconDateTimeLibrary.getDay(timestamp);\r\n    }\r\n\r\n    function getHour(uint timestamp) public pure returns (uint hour) {\r\n        hour = ReconDateTimeLibrary.getHour(timestamp);\r\n    }\r\n\r\n    function getMinute(uint timestamp) public pure returns (uint minute) {\r\n        minute = ReconDateTimeLibrary.getMinute(timestamp);\r\n    }\r\n\r\n    function getSecond(uint timestamp) public pure returns (uint second) {\r\n        second = ReconDateTimeLibrary.getSecond(timestamp);\r\n    }\r\n\r\n    function addYears(uint timestamp, uint _years) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.addYears(timestamp, _years);\r\n    }\r\n\r\n    function addMonths(uint timestamp, uint _months) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.addMonths(timestamp, _months);\r\n    }\r\n\r\n    function addDays(uint timestamp, uint _days) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.addDays(timestamp, _days);\r\n    }\r\n\r\n    function addHours(uint timestamp, uint _hours) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.addHours(timestamp, _hours);\r\n    }\r\n\r\n    function addMinutes(uint timestamp, uint _minutes) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.addMinutes(timestamp, _minutes);\r\n    }\r\n\r\n    function addSeconds(uint timestamp, uint _seconds) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.addSeconds(timestamp, _seconds);\r\n    }\r\n\r\n    function subYears(uint timestamp, uint _years) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.subYears(timestamp, _years);\r\n    }\r\n\r\n    function subMonths(uint timestamp, uint _months) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.subMonths(timestamp, _months);\r\n    }\r\n\r\n    function subDays(uint timestamp, uint _days) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.subDays(timestamp, _days);\r\n    }\r\n\r\n    function subHours(uint timestamp, uint _hours) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.subHours(timestamp, _hours);\r\n    }\r\n\r\n    function subMinutes(uint timestamp, uint _minutes) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.subMinutes(timestamp, _minutes);\r\n    }\r\n\r\n    function subSeconds(uint timestamp, uint _seconds) public pure returns (uint newTimestamp) {\r\n        newTimestamp = ReconDateTimeLibrary.subSeconds(timestamp, _seconds);\r\n    }\r\n\r\n    function diffYears(uint fromTimestamp, uint toTimestamp) public pure returns (uint _years) {\r\n        _years = ReconDateTimeLibrary.diffYears(fromTimestamp, toTimestamp);\r\n    }\r\n\r\n    function diffMonths(uint fromTimestamp, uint toTimestamp) public pure returns (uint _months) {\r\n        _months = ReconDateTimeLibrary.diffMonths(fromTimestamp, toTimestamp);\r\n    }\r\n\r\n    function diffDays(uint fromTimestamp, uint toTimestamp) public pure returns (uint _days) {\r\n        _days = ReconDateTimeLibrary.diffDays(fromTimestamp, toTimestamp);\r\n    }\r\n\r\n    function diffHours(uint fromTimestamp, uint toTimestamp) public pure returns (uint _hours) {\r\n        _hours = ReconDateTimeLibrary.diffHours(fromTimestamp, toTimestamp);\r\n    }\r\n\r\n    function diffMinutes(uint fromTimestamp, uint toTimestamp) public pure returns (uint _minutes) {\r\n        _minutes = ReconDateTimeLibrary.diffMinutes(fromTimestamp, toTimestamp);\r\n    }\r\n\r\n    function diffSeconds(uint fromTimestamp, uint toTimestamp) public pure returns (uint _seconds) {\r\n        _seconds = ReconDateTimeLibrary.diffSeconds(fromTimestamp, toTimestamp);\r\n    }\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    }\r\n\r\n\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes32 hash) public;\r\n}\r\n\r\n\r\ncontract ReconTokenInterface is ERC20Interface {\r\n    uint public constant reconVersion = 110;\r\n\r\n    bytes public constant signingPrefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    bytes4 public constant signedTransferSig = \"\\x75\\x32\\xea\\xac\";\r\n    bytes4 public constant signedApproveSig = \"\\xe9\\xaf\\xa7\\xa1\";\r\n    bytes4 public constant signedTransferFromSig = \"\\x34\\x4b\\xcc\\x7d\";\r\n    bytes4 public constant signedApproveAndCallSig = \"\\xf1\\x6f\\x9b\\x53\";\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event MinterUpdated(address from, address to);\r\n    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\r\n    event MintingDisabled();\r\n    event TransfersEnabled();\r\n    event AccountUnlocked(address indexed tokenOwner);\r\n\r\n    function approveAndCall(address spender, uint tokens, bytes32 hash) public returns (bool success);\r\n\r\n    // ------------------------------------------------------------------------\r\n    // signed{X} functions\r\n    // ------------------------------------------------------------------------\r\n    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\r\n    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\r\n    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\r\n\r\n    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\r\n    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\r\n    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\r\n\r\n    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash);\r\n    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\r\n    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\r\n\r\n    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce) public view returns (bytes32 hash);\r\n    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (CheckResult result);\r\n    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success);\r\n\r\n    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success);\r\n    function unlockAccount(address tokenOwner) public;\r\n    function disableMinting() public;\r\n    function enableTransfers() public;\r\n\r\n\r\n    enum CheckResult {\r\n        Success,                           // 0 Success\r\n        NotTransferable,                   // 1 Tokens not transferable yet\r\n        AccountLocked,                     // 2 Account locked\r\n        SignerMismatch,                    // 3 Mismatch in signing account\r\n        InvalidNonce,                      // 4 Invalid nonce\r\n        InsufficientApprovedTokens,        // 5 Insufficient approved tokens\r\n        InsufficientApprovedTokensForFees, // 6 Insufficient approved tokens for fees\r\n        InsufficientTokens,                // 7 Insufficient tokens\r\n        InsufficientTokensForFees,         // 8 Insufficient tokens for fees\r\n        OverflowError                      // 9 Overflow error\r\n    }\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\nlibrary ReconLib {\r\n    struct Data {\r\n        bool initialised;\r\n\r\n        // Ownership\r\n        address owner;\r\n        address newOwner;\r\n\r\n        // Minting and management\r\n        address minter;\r\n        bool mintable;\r\n        bool transferable;\r\n        mapping(address => bool) accountLocked;\r\n\r\n        // Token\r\n        string symbol;\r\n        string name;\r\n        uint8 decimals;\r\n        uint totalSupply;\r\n        mapping(address => uint) balances;\r\n        mapping(address => mapping(address => uint)) allowed;\r\n        mapping(address => uint) nextNonce;\r\n    }\r\n\r\n\r\n    uint public constant reconVersion = 110;\r\n    bytes public constant signingPrefix = \"\\x19Ethereum Signed Message:\\n32\";\r\n    bytes4 public constant signedTransferSig = \"\\x75\\x32\\xea\\xac\";\r\n    bytes4 public constant signedApproveSig = \"\\xe9\\xaf\\xa7\\xa1\";\r\n    bytes4 public constant signedTransferFromSig = \"\\x34\\x4b\\xcc\\x7d\";\r\n    bytes4 public constant signedApproveAndCallSig = \"\\xf1\\x6f\\x9b\\x53\";\r\n\r\n\r\n    event OwnershipTransferred(address indexed from, address indexed to);\r\n    event MinterUpdated(address from, address to);\r\n    event Mint(address indexed tokenOwner, uint tokens, bool lockAccount);\r\n    event MintingDisabled();\r\n    event TransfersEnabled();\r\n    event AccountUnlocked(address indexed tokenOwner);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n\r\n\r\n    function init(Data storage self, address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {\r\n        require(!self.initialised);\r\n        self.initialised = true;\r\n        self.owner = owner;\r\n        self.symbol = symbol;\r\n        self.name = name;\r\n        self.decimals = decimals;\r\n        if (initialSupply > 0) {\r\n            self.balances[owner] = initialSupply;\r\n            self.totalSupply = initialSupply;\r\n            emit Mint(self.owner, initialSupply, false);\r\n            emit Transfer(address(0), self.owner, initialSupply);\r\n        }\r\n        self.mintable = mintable;\r\n        self.transferable = transferable;\r\n    }\r\n\r\n    function safeAdd(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n\r\n    function safeSub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n\r\n    function safeMul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n\r\n    function safeDiv(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n\r\n\r\n    function transferOwnership(Data storage self, address newOwner) public {\r\n        require(msg.sender == self.owner);\r\n        self.newOwner = newOwner;\r\n    }\r\n\r\n    function acceptOwnership(Data storage self) public {\r\n        require(msg.sender == self.newOwner);\r\n        emit OwnershipTransferred(self.owner, self.newOwner);\r\n        self.owner = self.newOwner;\r\n        self.newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\r\n    }\r\n\r\n    function transferOwnershipImmediately(Data storage self, address newOwner) public {\r\n        require(msg.sender == self.owner);\r\n        emit OwnershipTransferred(self.owner, newOwner);\r\n        self.owner = newOwner;\r\n        self.newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Minting and management\r\n    // ------------------------------------------------------------------------\r\n    function setMinter(Data storage self, address minter) public {\r\n        require(msg.sender == self.owner);\r\n        require(self.mintable);\r\n        emit MinterUpdated(self.minter, minter);\r\n        self.minter = minter;\r\n    }\r\n\r\n    function mint(Data storage self, address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {\r\n        require(self.mintable);\r\n        require(msg.sender == self.minter || msg.sender == self.owner);\r\n        if (lockAccount) {\r\n            self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = true;\r\n        }\r\n        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeAdd(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], tokens);\r\n        self.totalSupply = safeAdd(self.totalSupply, tokens);\r\n        emit Mint(tokenOwner, tokens, lockAccount);\r\n        emit Transfer(address(0x0A5f85C3d41892C934ae82BDbF17027A20717088), tokenOwner, tokens);\r\n        return true;\r\n    }\r\n\r\n    function unlockAccount(Data storage self, address tokenOwner) public {\r\n        require(msg.sender == self.owner);\r\n        require(self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\r\n        self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = false;\r\n        emit AccountUnlocked(tokenOwner);\r\n    }\r\n\r\n    function disableMinting(Data storage self) public {\r\n        require(self.mintable);\r\n        require(msg.sender == self.minter || msg.sender == self.owner);\r\n        self.mintable = false;\r\n        if (self.minter != address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840)) {\r\n            emit MinterUpdated(self.minter, address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840));\r\n            self.minter = address(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840);\r\n        }\r\n        emit MintingDisabled();\r\n    }\r\n\r\n    function enableTransfers(Data storage self) public {\r\n        require(msg.sender == self.owner);\r\n        require(!self.transferable);\r\n        self.transferable = true;\r\n        emit TransfersEnabled();\r\n    }\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Other functions\r\n    // ------------------------------------------------------------------------\r\n    function transferAnyERC20Token(Data storage self, address tokenAddress, uint tokens) public returns (bool success) {\r\n        require(msg.sender == self.owner);\r\n        return ERC20Interface(tokenAddress).transfer(self.owner, tokens);\r\n    }\r\n\r\n    function ecrecoverFromSig(bytes32 hash, bytes32 sig) public pure returns (address recoveredAddress) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n        if (sig.length != 65) return address(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c);\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n            // Here we are loading the last 32 bytes. We exploit the fact that 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(32, mload(add(sig, 96)))\r\n        }\r\n        // Albeit non-transactional signatures are not specified by the YP, one would expect it to match the YP range of [27, 28]\r\n        // geth uses [0, 1] and some clients have followed. This might change, see https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27) {\r\n          v += 27;\r\n        }\r\n        if (v != 27 && v != 28) return address(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c);\r\n        return ecrecover(hash, v, r, s);\r\n    }\r\n\r\n\r\n    function getCheckResultMessage(Data storage /*self*/, ReconTokenInterface.CheckResult result) public pure returns (string) {\r\n        if (result == ReconTokenInterface.CheckResult.Success) {\r\n            return \"Success\";\r\n        } else if (result == ReconTokenInterface.CheckResult.NotTransferable) {\r\n            return \"Tokens not transferable yet\";\r\n        } else if (result == ReconTokenInterface.CheckResult.AccountLocked) {\r\n            return \"Account locked\";\r\n        } else if (result == ReconTokenInterface.CheckResult.SignerMismatch) {\r\n            return \"Mismatch in signing account\";\r\n        } else if (result == ReconTokenInterface.CheckResult.InvalidNonce) {\r\n            return \"Invalid nonce\";\r\n        } else if (result == ReconTokenInterface.CheckResult.InsufficientApprovedTokens) {\r\n            return \"Insufficient approved tokens\";\r\n        } else if (result == ReconTokenInterface.CheckResult.InsufficientApprovedTokensForFees) {\r\n            return \"Insufficient approved tokens for fees\";\r\n        } else if (result == ReconTokenInterface.CheckResult.InsufficientTokens) {\r\n            return \"Insufficient tokens\";\r\n        } else if (result == ReconTokenInterface.CheckResult.InsufficientTokensForFees) {\r\n            return \"Insufficient tokens for fees\";\r\n        } else if (result == ReconTokenInterface.CheckResult.OverflowError) {\r\n            return \"Overflow error\";\r\n        } else {\r\n            return \"Unknown error\";\r\n        }\r\n    }\r\n\r\n\r\n    function transfer(Data storage self, address to, uint tokens) public returns (bool success) {\r\n        // Owner and minter can move tokens before the tokens are transferable\r\n        require(self.transferable || (self.mintable && (msg.sender == self.owner  || msg.sender == self.minter)));\r\n        require(!self.accountLocked[msg.sender]);\r\n        self.balances[msg.sender] = safeSub(self.balances[msg.sender], tokens);\r\n        self.balances[to] = safeAdd(self.balances[to], tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(Data storage self, address spender, uint tokens) public returns (bool success) {\r\n        require(!self.accountLocked[msg.sender]);\r\n        self.allowed[msg.sender][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(Data storage self, address from, address to, uint tokens) public returns (bool success) {\r\n        require(self.transferable);\r\n        require(!self.accountLocked[from]);\r\n        self.balances[from] = safeSub(self.balances[from], tokens);\r\n        self.allowed[from][msg.sender] = safeSub(self.allowed[from][msg.sender], tokens);\r\n        self.balances[to] = safeAdd(self.balances[to], tokens);\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function approveAndCall(Data storage self, address spender, uint tokens, bytes32 data) public returns (bool success) {\r\n        require(!self.accountLocked[msg.sender]);\r\n        self.allowed[msg.sender][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, address(this), data);\r\n        return true;\r\n    }\r\n\r\n\r\n    function signedTransferHash(Data storage /*self*/, address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        hash = keccak256(abi.encodePacked(signedTransferSig, address(this), tokenOwner, to, tokens, fee, nonce));\r\n    }\r\n\r\n    function signedTransferCheck(Data storage self, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\r\n        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\r\n        bytes32 hash = signedTransferHash(self, tokenOwner, to, tokens, fee, nonce);\r\n        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\r\n        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\r\n        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\r\n        uint total = safeAdd(tokens, fee);\r\n        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < tokens) return ReconTokenInterface.CheckResult.InsufficientTokens;\r\n        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < total) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\r\n        if (self.balances[to] + tokens < self.balances[to]) return ReconTokenInterface.CheckResult.OverflowError;\r\n        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\r\n        return ReconTokenInterface.CheckResult.Success;\r\n    }\r\n    function signedTransfer(Data storage self, address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\r\n        require(self.transferable);\r\n        bytes32 hash = signedTransferHash(self, tokenOwner, to, tokens, fee, nonce);\r\n        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\r\n        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\r\n        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\r\n        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\r\n        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], tokens);\r\n        self.balances[to] = safeAdd(self.balances[to], tokens);\r\n        emit Transfer(tokenOwner, to, tokens);\r\n        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\r\n        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\r\n        emit Transfer(tokenOwner, feeAccount, fee);\r\n        return true;\r\n    }\r\n\r\n    function signedApproveHash(Data storage /*self*/, address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        hash = keccak256(abi.encodePacked(signedApproveSig, address(this), tokenOwner, spender, tokens, fee, nonce));\r\n    }\r\n\r\n    function signedApproveCheck(Data storage self, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\r\n        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\r\n        bytes32 hash = signedApproveHash(self, tokenOwner, spender, tokens, fee, nonce);\r\n        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig))\r\n            return ReconTokenInterface.CheckResult.SignerMismatch;\r\n        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\r\n        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\r\n        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < fee) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\r\n        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\r\n        return ReconTokenInterface.CheckResult.Success;\r\n    }\r\n    function signedApprove(Data storage self, address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\r\n        require(self.transferable);\r\n        bytes32 hash = signedApproveHash(self, tokenOwner, spender, tokens, fee, nonce);\r\n        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\r\n        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\r\n        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\r\n        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\r\n        self.allowed[0x0A5f85C3d41892C934ae82BDbF17027A20717088][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = tokens;\r\n        emit Approval(0x0A5f85C3d41892C934ae82BDbF17027A20717088, spender, tokens);\r\n        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\r\n        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\r\n        emit Transfer(tokenOwner, feeAccount, fee);\r\n        return true;\r\n    }\r\n\r\n    function signedTransferFromHash(Data storage /*self*/, address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        hash = keccak256(abi.encodePacked(signedTransferFromSig, address(this), spender, from, to, tokens, fee, nonce));\r\n    }\r\n\r\n    function signedTransferFromCheck(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\r\n        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\r\n        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);\r\n        if (spender == address(0xF848332f5D902EFD874099458Bc8A53C8b7881B1) || spender != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\r\n        if (self.accountLocked[from]) return ReconTokenInterface.CheckResult.AccountLocked;\r\n        if (self.nextNonce[spender] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\r\n        uint total = safeAdd(tokens, fee);\r\n        if (self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] < tokens) return ReconTokenInterface.CheckResult.InsufficientApprovedTokens;\r\n        if (self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] < total) return ReconTokenInterface.CheckResult.InsufficientApprovedTokensForFees;\r\n        if (self.balances[from] < tokens) return ReconTokenInterface.CheckResult.InsufficientTokens;\r\n        if (self.balances[from] < total) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\r\n        if (self.balances[to] + tokens < self.balances[to]) return ReconTokenInterface.CheckResult.OverflowError;\r\n        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\r\n        return ReconTokenInterface.CheckResult.Success;\r\n    }\r\n\r\n    function signedTransferFrom(Data storage self, address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\r\n        require(self.transferable);\r\n        bytes32 hash = signedTransferFromHash(self, spender, from, to, tokens, fee, nonce);\r\n        require(spender != address(0xF848332f5D902EFD874099458Bc8A53C8b7881B1) && spender == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\r\n        require(!self.accountLocked[from]);\r\n        require(self.nextNonce[0xF848332f5D902EFD874099458Bc8A53C8b7881B1] == nonce);\r\n        self.nextNonce[0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = nonce + 1;\r\n        self.balances[from] = safeSub(self.balances[from], tokens);\r\n        self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = safeSub(self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1], tokens);\r\n        self.balances[to] = safeAdd(self.balances[to], tokens);\r\n        emit Transfer(from, to, tokens);\r\n        self.balances[from] = safeSub(self.balances[from], fee);\r\n        self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1] = safeSub(self.allowed[from][0xF848332f5D902EFD874099458Bc8A53C8b7881B1], fee);\r\n        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\r\n        emit Transfer(from, feeAccount, fee);\r\n        return true;\r\n    }\r\n\r\n    function signedApproveAndCallHash(Data storage /*self*/, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        hash = keccak256(abi.encodePacked(signedApproveAndCallSig, address(this), tokenOwner, spender, tokens, data, fee, nonce));\r\n    }\r\n\r\n    function signedApproveAndCallCheck(Data storage self, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\r\n        if (!self.transferable) return ReconTokenInterface.CheckResult.NotTransferable;\r\n        bytes32 hash = signedApproveAndCallHash(self, tokenOwner, spender, tokens, data, fee, nonce);\r\n        if (tokenOwner == address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) || tokenOwner != ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig)) return ReconTokenInterface.CheckResult.SignerMismatch;\r\n        if (self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]) return ReconTokenInterface.CheckResult.AccountLocked;\r\n        if (self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] != nonce) return ReconTokenInterface.CheckResult.InvalidNonce;\r\n        if (self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] < fee) return ReconTokenInterface.CheckResult.InsufficientTokensForFees;\r\n        if (self.balances[feeAccount] + fee < self.balances[feeAccount]) return ReconTokenInterface.CheckResult.OverflowError;\r\n        return ReconTokenInterface.CheckResult.Success;\r\n    }\r\n\r\n    function signedApproveAndCall(Data storage self, address tokenOwner, address spender, uint tokens, bytes32 data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\r\n        require(self.transferable);\r\n        bytes32 hash = signedApproveAndCallHash(self, tokenOwner, spender, tokens, data, fee, nonce);\r\n        require(tokenOwner != address(0x0A5f85C3d41892C934ae82BDbF17027A20717088) && tokenOwner == ecrecoverFromSig(keccak256(abi.encodePacked(signingPrefix, hash)), sig));\r\n        require(!self.accountLocked[0x0A5f85C3d41892C934ae82BDbF17027A20717088]);\r\n        require(self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] == nonce);\r\n        self.nextNonce[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = nonce + 1;\r\n        self.allowed[0x0A5f85C3d41892C934ae82BDbF17027A20717088][spender] = tokens;\r\n        emit Approval(tokenOwner, spender, tokens);\r\n        self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088] = safeSub(self.balances[0x0A5f85C3d41892C934ae82BDbF17027A20717088], fee);\r\n        self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b] = safeAdd(self.balances[0xc083E68D962c2E062D2735B54804Bb5E1f367c1b], fee);\r\n        emit Transfer(tokenOwner, feeAccount, fee);\r\n        ApproveAndCallFallBack(spender).receiveApproval(tokenOwner, tokens, address(this), data);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\ncontract ReconToken is ReconTokenInterface{\r\n    using ReconLib for ReconLib.Data;\r\n\r\n    ReconLib.Data data;\r\n\r\n\r\n    function constructorReconToken(address owner, string symbol, string name, uint8 decimals, uint initialSupply, bool mintable, bool transferable) public {\r\n        data.init(owner, symbol, name, decimals, initialSupply, mintable, transferable);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        return data.owner;\r\n    }\r\n\r\n    function newOwner() public view returns (address) {\r\n        return data.newOwner;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public {\r\n        data.transferOwnership(_newOwner);\r\n    }\r\n    function acceptOwnership() public {\r\n        data.acceptOwnership();\r\n    }\r\n    function transferOwnershipImmediately(address _newOwner) public {\r\n        data.transferOwnershipImmediately(_newOwner);\r\n    }\r\n\r\n    function symbol() public view returns (string) {\r\n        return data.symbol;\r\n    }\r\n\r\n    function name() public view returns (string) {\r\n        return data.name;\r\n    }\r\n\r\n    function decimals() public view returns (uint8) {\r\n        return data.decimals;\r\n    }\r\n\r\n    function minter() public view returns (address) {\r\n        return data.minter;\r\n    }\r\n\r\n    function setMinter(address _minter) public {\r\n        data.setMinter(_minter);\r\n    }\r\n\r\n    function mint(address tokenOwner, uint tokens, bool lockAccount) public returns (bool success) {\r\n        return data.mint(tokenOwner, tokens, lockAccount);\r\n    }\r\n\r\n    function accountLocked(address tokenOwner) public view returns (bool) {\r\n        return data.accountLocked[tokenOwner];\r\n    }\r\n    function unlockAccount(address tokenOwner) public {\r\n        data.unlockAccount(tokenOwner);\r\n    }\r\n\r\n    function mintable() public view returns (bool) {\r\n        return data.mintable;\r\n    }\r\n\r\n    function transferable() public view returns (bool) {\r\n        return data.transferable;\r\n    }\r\n\r\n    function disableMinting() public {\r\n        data.disableMinting();\r\n    }\r\n\r\n    function enableTransfers() public {\r\n        data.enableTransfers();\r\n    }\r\n\r\n    function nextNonce(address spender) public view returns (uint) {\r\n        return data.nextNonce[spender];\r\n    }\r\n\r\n\r\n    // ------------------------------------------------------------------------\r\n    // Other functions\r\n    // ------------------------------------------------------------------------\r\n\r\n    function transferAnyERC20Token(address tokenAddress, uint tokens) public returns (bool success) {\r\n        return data.transferAnyERC20Token(tokenAddress, tokens);\r\n    }\r\n\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return data.totalSupply - data.balances[address(0x0A5f85C3d41892C934ae82BDbF17027A20717088)];\r\n    }\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return data.balances[tokenOwner];\r\n    }\r\n\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n        return data.allowed[tokenOwner][spender];\r\n    }\r\n\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        return data.transfer(to, tokens);\r\n    }\r\n\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        return data.approve(spender, tokens);\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        return data.transferFrom(from, to, tokens);\r\n    }\r\n\r\n    function approveAndCall(address spender, uint tokens, bytes32 _data) public returns (bool success) {\r\n        return data.approveAndCall(spender, tokens, _data);\r\n    }\r\n\r\n    function signedTransferHash(address tokenOwner, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        return data.signedTransferHash(tokenOwner, to, tokens, fee, nonce);\r\n    }\r\n\r\n    function signedTransferCheck(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\r\n        return data.signedTransferCheck(tokenOwner, to, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n\r\n    function signedTransfer(address tokenOwner, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\r\n        return data.signedTransfer(tokenOwner, to, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n\r\n    function signedApproveHash(address tokenOwner, address spender, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        return data.signedApproveHash(tokenOwner, spender, tokens, fee, nonce);\r\n    }\r\n\r\n    function signedApproveCheck(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\r\n        return data.signedApproveCheck(tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n\r\n    function signedApprove(address tokenOwner, address spender, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\r\n        return data.signedApprove(tokenOwner, spender, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n\r\n    function signedTransferFromHash(address spender, address from, address to, uint tokens, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        return data.signedTransferFromHash(spender, from, to, tokens, fee, nonce);\r\n    }\r\n\r\n    function signedTransferFromCheck(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\r\n        return data.signedTransferFromCheck(spender, from, to, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n\r\n    function signedTransferFrom(address spender, address from, address to, uint tokens, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\r\n        return data.signedTransferFrom(spender, from, to, tokens, fee, nonce, sig, feeAccount);\r\n    }\r\n\r\n    function signedApproveAndCallHash(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce) public view returns (bytes32 hash) {\r\n        return data.signedApproveAndCallHash(tokenOwner, spender, tokens, _data, fee, nonce);\r\n    }\r\n\r\n    function signedApproveAndCallCheck(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public view returns (ReconTokenInterface.CheckResult result) {\r\n        return data.signedApproveAndCallCheck(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);\r\n    }\r\n\r\n    function signedApproveAndCall(address tokenOwner, address spender, uint tokens, bytes32 _data, uint fee, uint nonce, bytes32 sig, address feeAccount) public returns (bool success) {\r\n        return data.signedApproveAndCall(tokenOwner, spender, tokens, _data, fee, nonce, sig, feeAccount);\r\n    }\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function Owned1() public {\r\n        owner = msg.sender;\r\n    }\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(newOwner != address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\r\n    }\r\n\r\n    function transferOwnershipImmediately(address _newOwner) public onlyOwner {\r\n        emit OwnershipTransferred(owner, _newOwner);\r\n        owner = _newOwner;\r\n        newOwner = address(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060);\r\n    }\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\ncontract ReconTokenFactory is ERC20Interface, Owned {\r\n    using SafeMath for uint;\r\n\r\n    string public constant name = \"RECON\";\r\n    string public constant symbol = \"RECON\";\r\n    uint8 public constant decimals = 18;\r\n\r\n    uint constant public ReconToMicro = uint(1000000000000000000);\r\n\r\n    // This constants reflects RECON token distribution\r\n\r\n    uint constant public investorSupply                   =  25000000000 * ReconToMicro;\r\n    uint constant public adviserSupply                    =     25000000 * ReconToMicro;\r\n    uint constant public bountySupply                     =     25000000 * ReconToMicro;\r\n\r\n    uint constant public _totalSupply                     = 100000000000 * ReconToMicro;\r\n    uint constant public preICOSupply                     =   5000000000 * ReconToMicro;\r\n    uint constant public presaleSupply                    =   5000000000 * ReconToMicro;\r\n    uint constant public crowdsaleSupply                  =  10000000000 * ReconToMicro;\r\n    uint constant public preICOprivate                    =     99000000 * ReconToMicro;\r\n\r\n    uint constant public Reconowner                       =    101000000 * ReconToMicro;\r\n    uint constant public ReconnewOwner                    =    100000000 * ReconToMicro;\r\n    uint constant public Reconminter                      =     50000000 * ReconToMicro;\r\n    uint constant public ReconfeeAccount                  =     50000000 * ReconToMicro;\r\n    uint constant public Reconspender                     =     50000000 * ReconToMicro;\r\n    uint constant public ReconrecoveredAddress            =     50000000 * ReconToMicro;\r\n    uint constant public ProprityfromReconBank            =    200000000 * ReconToMicro;\r\n    uint constant public ReconManager                     =    200000000 * ReconToMicro;\r\n\r\n    uint constant public ReconCashinB2B                   =   5000000000 * ReconToMicro;\r\n    uint constant public ReconSwitchC2C                   =   5000000000 * ReconToMicro;\r\n    uint constant public ReconCashoutB2C                  =   5000000000 * ReconToMicro;\r\n    uint constant public ReconInvestment                  =   2000000000 * ReconToMicro;\r\n    uint constant public ReconMomentum                    =   2000000000 * ReconToMicro;\r\n    uint constant public ReconReward                      =   2000000000 * ReconToMicro;\r\n    uint constant public ReconDonate                      =   1000000000 * ReconToMicro;\r\n    uint constant public ReconTokens                      =   4000000000 * ReconToMicro;\r\n    uint constant public ReconCash                        =   4000000000 * ReconToMicro;\r\n    uint constant public ReconGold                        =   4000000000 * ReconToMicro;\r\n    uint constant public ReconCard                        =   4000000000 * ReconToMicro;\r\n    uint constant public ReconHardriveWallet              =   2000000000 * ReconToMicro;\r\n    uint constant public RecoinOption                     =   1000000000 * ReconToMicro;\r\n    uint constant public ReconPromo                       =    100000000 * ReconToMicro;\r\n    uint constant public Reconpatents                     =   1000000000 * ReconToMicro;\r\n    uint constant public ReconSecurityandLegalFees        =   1000000000 * ReconToMicro;\r\n    uint constant public PeerToPeerNetworkingService      =   1000000000 * ReconToMicro;\r\n    uint constant public Reconia                          =   2000000000 * ReconToMicro;\r\n\r\n    uint constant public ReconVaultXtraStock              =   7000000000 * ReconToMicro;\r\n    uint constant public ReconVaultSecurityStock          =   5000000000 * ReconToMicro;\r\n    uint constant public ReconVaultAdvancePaymentStock    =   5000000000 * ReconToMicro;\r\n    uint constant public ReconVaultPrivatStock            =   4000000000 * ReconToMicro;\r\n    uint constant public ReconVaultCurrencyInsurancestock =   4000000000 * ReconToMicro;\r\n    uint constant public ReconVaultNextStock              =   4000000000 * ReconToMicro;\r\n    uint constant public ReconVaultFuturStock             =   4000000000 * ReconToMicro;\r\n\r\n\r\n\r\n    // This variables accumulate amount of sold RECON during\r\n    // presale, crowdsale, or given to investors as bonus.\r\n    uint public presaleSold = 0;\r\n    uint public crowdsaleSold = 0;\r\n    uint public investorGiven = 0;\r\n\r\n    // Amount of ETH received during ICO\r\n    uint public ethSold = 0;\r\n\r\n    uint constant public softcapUSD = 20000000000;\r\n    uint constant public preicoUSD  = 5000000000;\r\n\r\n    // Presale lower bound in dollars.\r\n    uint constant public crowdsaleMinUSD = ReconToMicro * 10 * 100 / 12;\r\n    uint constant public bonusLevel0 = ReconToMicro * 10000 * 100 / 12; // 10000$\r\n    uint constant public bonusLevel100 = ReconToMicro * 100000 * 100 / 12; // 100000$\r\n\r\n    // The tokens made available to the public will be in 13 steps\r\n    // for a maximum of 20% of the total supply (see doc for checkTransfer).\r\n    // All dates are stored as timestamps.\r\n    uint constant public unlockDate1  = 1541890800; // 11-11-2018 00:00:00  [1%]  Recon Manager\r\n    uint constant public unlockDate2  = 1545346800; // 21-12-2018 00:00:00  [2%]  Recon Cash-in (B2B)\r\n    uint constant public unlockDate3  = 1549062000; // 02-02-2019 00:00:00  [2%]  Recon Switch (C2C)\r\n    uint constant public unlockDate4  = 1554328800; // 04-04-2019 00:00:00  [2%]  Recon Cash-out (B2C)\r\n    uint constant public unlockDate5  = 1565215200; // 08-08-2019 00:00:00  [2%]  Recon Investment & Recon Momentum\r\n    uint constant public unlockDate6  = 1570658400; // 10-10-2019 00:00:00  [2%]  Recon Reward\r\n    uint constant public unlockDate7  = 1576105200; // 12-12-2019 00:00:00  [1%]  Recon Donate\r\n    uint constant public unlockDate8  = 1580598000; // 02-02-2020 00:00:00  [1%]  Recon Token\r\n    uint constant public unlockDate9  = 1585951200; // 04-04-2020 00:00:00  [2%]  Recon Cash\r\n    uint constant public unlockDate10 = 1591394400; // 06-06-2020 00:00:00  [1%]  Recon Gold\r\n    uint constant public unlockDate11 = 1596837600; // 08-08-2020 00:00:00  [2%]  Recon Card\r\n    uint constant public unlockDate12 = 1602280800; // 10-10-2020 00:00:00  [1%]  Recon Hardrive Wallet\r\n    uint constant public unlockDate13 = 1606863600; // 02-12-2020 00:00:00  [1%]  Recoin Option\r\n\r\n    // The tokens made available to the teams will be made in 4 steps\r\n    // for a maximum of 80% of the total supply (see doc for checkTransfer).\r\n    uint constant public teamUnlock1 = 1544569200; // 12-12-2018 00:00:00  [25%]\r\n    uint constant public teamUnlock2 = 1576105200; // 12-12-2019 00:00:00  [25%]\r\n    uint constant public teamUnlock3 = 1594072800; // 07-07-2020 00:00:00  [25%]\r\n    uint constant public teamUnlock4 = 1608505200; // 21-12-2020 00:00:00  [25%]\r\n\r\n    uint constant public teamETHUnlock1 = 1544569200; // 12-12-2018 00:00:00\r\n    uint constant public teamETHUnlock2 = 1576105200; // 12-12-2019 00:00:00\r\n    uint constant public teamETHUnlock3 = 1594072800; // 07-07-2020 00:00:00\r\n\r\n    //https://casperproject.atlassian.net/wiki/spaces/PROD/pages/277839878/Smart+contract+ICO\r\n    // Presale 10.06.2018 - 22.07.2018\r\n    // Crowd-sale 23.07.2018 - 2.08.2018 (16.08.2018)\r\n    uint constant public presaleStartTime     = 1541890800; // 11-11-2018 00:00:00\r\n    uint constant public crowdsaleStartTime   = 1545346800; // 21-12-2018 00:00:00\r\n    uint          public crowdsaleEndTime     = 1609455599; // 31-12-2020 23:59:59\r\n    uint constant public crowdsaleHardEndTime = 1609455599; // 31-12-2020 23:59:59\r\n    //address constant ReconrWallet = 0x0A5f85C3d41892C934ae82BDbF17027A20717088;\r\n    constructor() public {\r\n        admin = owner;\r\n        balances[owner] = _totalSupply;\r\n        emit Transfer(address(0), owner, _totalSupply);\r\n    }\r\n\r\n    modifier onlyAdmin {\r\n        require(msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwnerAndDirector {\r\n        require(msg.sender == owner || msg.sender == director);\r\n        _;\r\n    }\r\n\r\n    address admin;\r\n    function setAdmin(address _newAdmin) public onlyOwnerAndDirector {\r\n        admin = _newAdmin;\r\n    }\r\n\r\n    address director;\r\n    function setDirector(address _newDirector) public onlyOwner {\r\n        director = _newDirector;\r\n    }\r\n\r\n    bool assignedPreico = false;\r\n    // @notice assignPreicoTokens transfers 3x tokens to pre-ICO participants (99,000,000)\r\n    function assignPreicoTokens() public onlyOwnerAndDirector {\r\n        require(!assignedPreico);\r\n        assignedPreico = true;\r\n\r\n        _freezeTransfer(0x4Bdff2Cc40996C71a1F16b72490d1a8E7Dfb7E56, 3 * 1000000000000000000000000); // Account_34\r\n        _freezeTransfer(0x9189AC4FA7AdBC587fF76DD43248520F8Cb897f3, 3 * 1000000000000000000000000); // Account_35\r\n        _freezeTransfer(0xc1D3DAd07A0dB42a7d34453C7d09eFeA793784e7, 3 * 1000000000000000000000000); // Account_36\r\n        _freezeTransfer(0xA0BC1BAAa5318E39BfB66F8Cd0496d6b09CaE6C1, 3 * 1000000000000000000000000); // Account_37\r\n        _freezeTransfer(0x9a2912F145Ab0d5b4aE6917A8b8ddd222539F424, 3 * 1000000000000000000000000); // Account_38\r\n        _freezeTransfer(0x0bB0ded1d868F1c0a50bD31c1ab5ab7b53c6BC20, 3 * 1000000000000000000000000); // Account_39\r\n        _freezeTransfer(0x65ec9f30249065A1BD23a9c68c0Ee9Ead63b4A4d, 3 * 1000000000000000000000000); // Account_40\r\n        _freezeTransfer(0x87Bdc03582deEeB84E00d3fcFd083B64DA77F471, 3 * 1000000000000000000000000); // Account_41\r\n        _freezeTransfer(0x81382A0998191E2Dd8a7bB2B8875D4Ff6CAA31ff, 3 * 1000000000000000000000000); // Account_42\r\n        _freezeTransfer(0x790069C894ebf518fB213F35b48C8ec5AAF81E62, 3 * 1000000000000000000000000); // Account_43\r\n        _freezeTransfer(0xa3f1404851E8156DFb425eC0EB3D3d5ADF6c8Fc0, 3 * 1000000000000000000000000); // Account_44\r\n        _freezeTransfer(0x11bA01dc4d93234D24681e1B19839D4560D17165, 3 * 1000000000000000000000000); // Account_45\r\n        _freezeTransfer(0x211D495291534009B8D3fa491400aB66F1d6131b, 3 * 1000000000000000000000000); // Account_46\r\n        _freezeTransfer(0x8c481AaF9a735F9a44Ac2ACFCFc3dE2e9B2f88f8, 3 * 1000000000000000000000000); // Account_47\r\n        _freezeTransfer(0xd0BEF2Fb95193f429f0075e442938F5d829a33c8, 3 * 1000000000000000000000000); // Account_48\r\n        _freezeTransfer(0x424cbEb619974ee79CaeBf6E9081347e64766705, 3 * 1000000000000000000000000); // Account_49\r\n        _freezeTransfer(0x9e395cd98089F6589b90643Dde4a304cAe4dA61C, 3 * 1000000000000000000000000); // Account_50\r\n        _freezeTransfer(0x3cDE6Df0906157107491ED17C79fF9218A50D7Dc, 3 * 1000000000000000000000000); // Account_51\r\n        _freezeTransfer(0x419a98D46a368A1704278349803683abB2A9D78E, 3 * 1000000000000000000000000); // Account_52\r\n        _freezeTransfer(0x106Db742344FBB96B46989417C151B781D1a4069, 3 * 1000000000000000000000000); // Account_53\r\n        _freezeTransfer(0xE16b9E9De165DbecA18B657414136cF007458aF5, 3 * 1000000000000000000000000); // Account_54\r\n        _freezeTransfer(0xee32C325A3E11759b290df213E83a257ff249936, 3 * 1000000000000000000000000); // Account_55\r\n        _freezeTransfer(0x7d6F916b0E5BF7Ba7f11E60ed9c30fB71C4A5fE0, 3 * 1000000000000000000000000); // Account_56\r\n        _freezeTransfer(0xCC684085585419100AE5010770557d5ad3F3CE58, 3 * 1000000000000000000000000); // Account_57\r\n        _freezeTransfer(0xB47BE6d74C5bC66b53230D07fA62Fb888594418d, 3 * 1000000000000000000000000); // Account_58\r\n        _freezeTransfer(0xf891555a1BF2525f6EBaC9b922b6118ca4215fdD, 3 * 1000000000000000000000000); // Account_59\r\n        _freezeTransfer(0xE3124478A5ed8550eA85733a4543Dd128461b668, 3 * 1000000000000000000000000); // Account_60\r\n        _freezeTransfer(0xc5836df630225112493fa04fa32B586f072d6298, 3 * 1000000000000000000000000); // Account_61\r\n        _freezeTransfer(0x144a0543C93ce8Fb26c13EB619D7E934FA3eA734, 3 * 1000000000000000000000000); // Account_62\r\n        _freezeTransfer(0x43731e24108E928984DcC63DE7affdF3a805FFb0, 3 * 1000000000000000000000000); // Account_63\r\n        _freezeTransfer(0x49f7744Aa8B706Faf336a3ff4De37078714065BC, 3 * 1000000000000000000000000); // Account_64\r\n        _freezeTransfer(0x1E55C7E97F0b5c162FC9C42Ced92C8e55053e093, 3 * 1000000000000000000000000); // Account_65\r\n        _freezeTransfer(0x40b234009664590997D2F6Fde2f279fE56e8AaBC, 3 * 1000000000000000000000000); // Account_66\r\n    }\r\n\r\n    bool assignedTeam = false;\r\n    // @notice assignTeamTokens assigns tokens to team members (79,901,000,000)\r\n    // @notice tokens for team have their own supply\r\n    function assignTeamTokens() public onlyOwnerAndDirector {\r\n        require(!assignedTeam);\r\n        assignedTeam = true;\r\n\r\n        _teamTransfer(0x0A5f85C3d41892C934ae82BDbF17027A20717088,  101000000 * ReconToMicro); // Recon owner\r\n        _teamTransfer(0x0f65e64662281D6D42eE6dEcb87CDB98fEAf6060,  100000000 * ReconToMicro); // Recon newOwner\r\n        _teamTransfer(0x3Da2585FEbE344e52650d9174e7B1bf35C70D840,   50000000 * ReconToMicro); // Recon minter\r\n        _teamTransfer(0xc083E68D962c2E062D2735B54804Bb5E1f367c1b,   50000000 * ReconToMicro); // Recon feeAccount\r\n        _teamTransfer(0xF848332f5D902EFD874099458Bc8A53C8b7881B1,   50000000 * ReconToMicro); // Recon spender\r\n        _teamTransfer(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c,   50000000 * ReconToMicro); // Recon recoveredAddress\r\n        _teamTransfer(0x5f2D6766C6F3A7250CfD99d6b01380C432293F0c,  200000000 * ReconToMicro); // Proprity from ReconBank\r\n        _teamTransfer(0xD974C2D74f0F352467ae2Da87fCc64491117e7ac,  200000000 * ReconToMicro); // Recon Manager\r\n        _teamTransfer(0x5c4F791D0E0A2E75Ee34D62c16FB6D09328555fF, 5000000000 * ReconToMicro); // Recon Cash-in (B2B)\r\n        _teamTransfer(0xeB479640A6D55374aF36896eCe6db7d92F390015, 5000000000 * ReconToMicro); // Recon Switch (C2C)\r\n        _teamTransfer(0x77167D25Db87dc072399df433e450B00b8Ec105A, 7000000000 * ReconToMicro); // Recon Cash-out (B2C)\r\n        _teamTransfer(0x5C6Fd84b961Cce03e027B0f8aE23c4A6e1195E90, 2000000000 * ReconToMicro); // Recon Investment\r\n        _teamTransfer(0x86F427c5e05C29Fd4124746f6111c1a712C9B5c8, 2000000000 * ReconToMicro); // Recon Momentum\r\n        _teamTransfer(0x1Ecb8dC0932AF3A3ba87e8bFE7eac3Cbe433B78B, 2000000000 * ReconToMicro); // Recon Reward\r\n        _teamTransfer(0x7C31BeCa0290C35c8452b95eA462C988c4003Bb0, 1000000000 * ReconToMicro); // Recon Donate\r\n        _teamTransfer(0x3a5326f9C9b3ff99e2e5011Aabec7b48B2e6A6A2, 4000000000 * ReconToMicro); // Recon Token\r\n        _teamTransfer(0x5a27B07003ce50A80dbBc5512eA5BBd654790673, 4000000000 * ReconToMicro); // Recon Cash\r\n        _teamTransfer(0xD580cF1002d0B4eF7d65dC9aC6a008230cE22692, 4000000000 * ReconToMicro); // Recon Gold\r\n        _teamTransfer(0x9C83562Bf58083ab408E596A4bA4951a2b5724C9, 4000000000 * ReconToMicro); // Recon Card\r\n        _teamTransfer(0x70E06c2Dd9568ECBae760CE2B61aC221C0c497F5, 2000000000 * ReconToMicro); // Recon Hardrive Wallet\r\n        _teamTransfer(0x14bd2Aa04619658F517521adba7E5A17dfD2A3f0, 1000000000 * ReconToMicro); // Recoin Option\r\n        _teamTransfer(0x9C3091a335383566d08cba374157Bdff5b8B034B,  100000000 * ReconToMicro); // Recon Promo\r\n        _teamTransfer(0x3b6F53122903c40ef61441dB807f09D90D6F05c7, 1000000000 * ReconToMicro); // Recon patents\r\n        _teamTransfer(0x7fb5EF151446Adb0B7D39B1902E45f06E11038F6, 1000000000 * ReconToMicro); // Recon Security & Legal Fees\r\n        _teamTransfer(0x47BD87fa63Ce818584F050aFFECca0f1dfFd0564, 1000000000 * ReconToMicro); // ​Peer To Peer Networking Service\r\n        _teamTransfer(0x83b3CD589Bd78aE65d7b338fF7DFc835cD9a8edD, 2000000000 * ReconToMicro); // Reconia\r\n        _teamTransfer(0x6299496342fFd22B7191616fcD19CeC6537C2E8D, 8000000000 * ReconToMicro); // ​Recon Central Securities Depository (Recon Vault XtraStock)\r\n        _teamTransfer(0x26aF11607Fad4FacF1fc44271aFA63Dbf2C22a87, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault SecurityStock)\r\n        _teamTransfer(0x7E21203C5B4A6f98E4986f850dc37eBE9Ca19179, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault Advance Payment Stock)\r\n        _teamTransfer(0x0bD212e88522b7F4C673fccBCc38558829337f71, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault PrivatStock)\r\n        _teamTransfer(0x5b44e309408cE6E73B9f5869C9eeaCeeb8084DC8, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault Currency Insurance stock)\r\n        _teamTransfer(0x48F2eFDE1c028792EbE7a870c55A860e40eb3573, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault NextStock)\r\n        _teamTransfer(0x1fF3BE6f711C684F04Cf6adfD665Ce13D54CAC73, 4000000000 * ReconToMicro); // Recon Central Securities Depository (Recon Vault FuturStock)\r\n    }\r\n\r\n    // @nptice kycPassed is executed by backend and tells SC\r\n    // that particular client has passed KYC\r\n    mapping(address => bool) public kyc;\r\n    mapping(address => address) public referral;\r\n    function kycPassed(address _mem, address _ref) public onlyAdmin {\r\n        kyc[_mem] = true;\r\n        if (_ref == richardAddr || _ref == wuguAddr) {\r\n            referral[_mem] = _ref;\r\n        }\r\n    }\r\n\r\n    // mappings for implementing ERC20\r\n    mapping(address => uint) balances;\r\n    mapping(address => mapping(address => uint)) allowed;\r\n\r\n    // mapping for implementing unlock mechanic\r\n    mapping(address => uint) freezed;\r\n    mapping(address => uint) teamFreezed;\r\n\r\n    // ERC20 standard functions\r\n    function totalSupply() public view returns (uint) {\r\n        return _totalSupply;\r\n    }\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining) {\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    function _transfer(address _from, address _to, uint _tokens) private {\r\n        balances[_from] = balances[_from].sub(_tokens);\r\n        balances[_to] = balances[_to].add(_tokens);\r\n        emit Transfer(_from, _to, _tokens);\r\n    }\r\n\r\n    function transfer(address _to, uint _tokens) public returns (bool success) {\r\n        checkTransfer(msg.sender, _tokens);\r\n        _transfer(msg.sender, _to, _tokens);\r\n        return true;\r\n    }\r\n\r\n    function approve(address spender, uint tokens) public returns (bool success) {\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success) {\r\n        checkTransfer(from, tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        _transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    // @notice checkTransfer ensures that `from` can send only unlocked tokens\r\n    // @notice this function is called for every transfer\r\n    // We unlock PURCHASED and BONUS tokens in 13 stages:\r\n    function checkTransfer(address from, uint tokens) public view {\r\n        uint newBalance = balances[from].sub(tokens);\r\n        uint total = 0;\r\n        if (now < unlockDate5) {\r\n            require(now >= unlockDate1);\r\n            uint frzdPercent = 0;\r\n            if (now < unlockDate2) {\r\n                frzdPercent = 5;\r\n            } else if (now < unlockDate3) {\r\n                frzdPercent = 10;\r\n            } else if (now < unlockDate4) {\r\n                frzdPercent = 10;\r\n            } else if (now < unlockDate5) {\r\n                frzdPercent = 10;\r\n            } else if (now < unlockDate6) {\r\n                frzdPercent = 10;\r\n            } else if (now < unlockDate7) {\r\n                frzdPercent = 10;\r\n            } else if (now < unlockDate8) {\r\n                frzdPercent = 5;\r\n            } else if (now < unlockDate9) {\r\n                frzdPercent = 5;\r\n            } else if (now < unlockDate10) {\r\n                frzdPercent = 10;\r\n            } else if (now < unlockDate11) {\r\n                frzdPercent = 5;\r\n            } else if (now < unlockDate12) {\r\n                frzdPercent = 10;\r\n            } else if (now < unlockDate13) {\r\n                frzdPercent = 5;\r\n            } else {\r\n                frzdPercent = 5;\r\n            }\r\n            total = freezed[from].mul(frzdPercent).div(100);\r\n            require(newBalance >= total);\r\n        }\r\n\r\n        if (now < teamUnlock4 && teamFreezed[from] > 0) {\r\n            uint p = 0;\r\n            if (now < teamUnlock1) {\r\n                p = 100;\r\n            } else if (now < teamUnlock2) {\r\n                p = 75;\r\n            } else if (now < teamUnlock3) {\r\n                p = 50;\r\n            } else if (now < teamUnlock4) {\r\n                p = 25;\r\n            }\r\n            total = total.add(teamFreezed[from].mul(p).div(100));\r\n            require(newBalance >= total);\r\n        }\r\n    }\r\n\r\n    // @return ($ received, ETH received, RECON sold)\r\n    function ICOStatus() public view returns (uint usd, uint eth, uint recon) {\r\n        usd = presaleSold.mul(12).div(10**20) + crowdsaleSold.mul(16).div(10**20);\r\n        usd = usd.add(preicoUSD); // pre-ico tokens\r\n\r\n        return (usd, ethSold + preicoUSD.mul(10**8).div(ethRate), presaleSold + crowdsaleSold);\r\n    }\r\n\r\n    function checkICOStatus() public view returns(bool) {\r\n        uint eth;\r\n        uint recon;\r\n\r\n        (, eth, recon) = ICOStatus();\r\n\r\n        uint dollarsRecvd = eth.mul(ethRate).div(10**8);\r\n\r\n        // 26 228 800$\r\n        return dollarsRecvd >= 25228966 || (recon == presaleSupply + crowdsaleSupply) || now > crowdsaleEndTime;\r\n    }\r\n\r\n    bool icoClosed = false;\r\n    function closeICO() public onlyOwner {\r\n        require(!icoClosed);\r\n        icoClosed = checkICOStatus();\r\n    }\r\n\r\n    // @notice by agreement, we can transfer $4.8M from bank\r\n    // after softcap is reached.\r\n    // @param _to wallet to send RECON to\r\n    // @param  _usd amount of dollars which is withdrawn\r\n    uint bonusTransferred = 0;\r\n    uint constant maxUSD = 4800000;\r\n    function transferBonus(address _to, uint _usd) public onlyOwner {\r\n        bonusTransferred = bonusTransferred.add(_usd);\r\n        require(bonusTransferred <= maxUSD);\r\n\r\n        uint recon = _usd.mul(100).mul(ReconToMicro).div(12); // presale tariff\r\n        presaleSold = presaleSold.add(recon);\r\n        require(presaleSold <= presaleSupply);\r\n        ethSold = ethSold.add(_usd.mul(10**8).div(ethRate));\r\n\r\n        _freezeTransfer(_to, recon);\r\n    }\r\n\r\n    // @notice extend crowdsale for 2 weeks\r\n    function prolongCrowdsale() public onlyOwnerAndDirector {\r\n        require(now < crowdsaleEndTime);\r\n        crowdsaleEndTime = crowdsaleHardEndTime;\r\n    }\r\n\r\n    // 100 000 000 Ether in dollars\r\n    uint public ethRate = 0;\r\n    uint public ethRateMax = 0;\r\n    uint public ethLastUpdate = 0;\r\n    function setETHRate(uint _rate) public onlyAdmin {\r\n        require(ethRateMax == 0 || _rate < ethRateMax);\r\n        ethRate = _rate;\r\n        ethLastUpdate = now;\r\n    }\r\n\r\n    // 100 000 000 BTC in dollars\r\n    uint public btcRate = 0;\r\n    uint public btcRateMax = 0;\r\n    uint public btcLastUpdate;\r\n    function setBTCRate(uint _rate) public onlyAdmin {\r\n        require(btcRateMax == 0 || _rate < btcRateMax);\r\n        btcRate = _rate;\r\n        btcLastUpdate = now;\r\n    }\r\n\r\n    // @notice setMaxRate sets max rate for both BTC/ETH to soften\r\n    // negative consequences in case our backend gots hacked.\r\n    function setMaxRate(uint ethMax, uint btcMax) public onlyOwnerAndDirector {\r\n        ethRateMax = ethMax;\r\n        btcRateMax = btcMax;\r\n    }\r\n\r\n    // @notice _sellPresale checks RECON purchases during crowdsale\r\n    function _sellPresale(uint recon) private {\r\n        require(recon >= bonusLevel0.mul(9950).div(10000));\r\n        presaleSold = presaleSold.add(recon);\r\n        require(presaleSold <= presaleSupply);\r\n    }\r\n\r\n    // @notice _sellCrowd checks RECON purchases during crowdsale\r\n    function _sellCrowd(uint recon, address _to) private {\r\n        require(recon >= crowdsaleMinUSD);\r\n\r\n        if (crowdsaleSold.add(recon) <= crowdsaleSupply) {\r\n            crowdsaleSold = crowdsaleSold.add(recon);\r\n        } else {\r\n            presaleSold = presaleSold.add(crowdsaleSold).add(recon).sub(crowdsaleSupply);\r\n            require(presaleSold <= presaleSupply);\r\n            crowdsaleSold = crowdsaleSupply;\r\n        }\r\n\r\n        if (now < crowdsaleStartTime + 3 days) {\r\n            if (whitemap[_to] >= recon) {\r\n                whitemap[_to] -= recon;\r\n                whitelistTokens -= recon;\r\n            } else {\r\n                require(crowdsaleSupply.add(presaleSupply).sub(presaleSold) >= crowdsaleSold.add(whitelistTokens));\r\n            }\r\n        }\r\n    }\r\n\r\n    // @notice addInvestorBonusInPercent is used for sending bonuses for big investors in %\r\n    function addInvestorBonusInPercent(address _to, uint8 p) public onlyOwner {\r\n        require(p > 0 && p <= 5);\r\n        uint bonus = balances[_to].mul(p).div(100);\r\n\r\n        investorGiven = investorGiven.add(bonus);\r\n        require(investorGiven <= investorSupply);\r\n\r\n        _freezeTransfer(_to, bonus);\r\n    }\r\n\r\n    // @notice addInvestorBonusInTokens is used for sending bonuses for big investors in tokens\r\n    function addInvestorBonusInTokens(address _to, uint tokens) public onlyOwner {\r\n        _freezeTransfer(_to, tokens);\r\n\r\n        investorGiven = investorGiven.add(tokens);\r\n        require(investorGiven <= investorSupply);\r\n    }\r\n\r\n    function () payable public {\r\n        purchaseWithETH(msg.sender);\r\n    }\r\n\r\n    // @notice _freezeTranfer perform actual tokens transfer which\r\n    // will be freezed (see also checkTransfer() )\r\n    function _freezeTransfer(address _to, uint recon) private {\r\n        _transfer(owner, _to, recon);\r\n        freezed[_to] = freezed[_to].add(recon);\r\n    }\r\n\r\n    // @notice _freezeTranfer perform actual tokens transfer which\r\n    // will be freezed (see also checkTransfer() )\r\n    function _teamTransfer(address _to, uint recon) private {\r\n        _transfer(owner, _to, recon);\r\n        teamFreezed[_to] = teamFreezed[_to].add(recon);\r\n    }\r\n\r\n    address public constant wuguAddr = 0x0d340F1344a262c13485e419860cb6c4d8Ec9C6e;\r\n    address public constant richardAddr = 0x49BE16e7FECb14B82b4f661D9a0426F810ED7127;\r\n    mapping(address => address[]) promoterClients;\r\n    mapping(address => mapping(address => uint)) promoterBonus;\r\n\r\n    // @notice withdrawPromoter transfers back to promoter\r\n    // all bonuses accumulated to current moment\r\n    function withdrawPromoter() public {\r\n        address _to = msg.sender;\r\n        require(_to == wuguAddr || _to == richardAddr);\r\n\r\n        uint usd;\r\n        (usd,,) = ICOStatus();\r\n\r\n        // USD received - 5% must be more than softcap\r\n        require(usd.mul(95).div(100) >= softcapUSD);\r\n\r\n        uint bonus = 0;\r\n        address[] memory clients = promoterClients[_to];\r\n        for(uint i = 0; i < clients.length; i++) {\r\n            if (kyc[clients[i]]) {\r\n                uint num = promoterBonus[_to][clients[i]];\r\n                delete promoterBonus[_to][clients[i]];\r\n                bonus += num;\r\n            }\r\n        }\r\n\r\n        _to.transfer(bonus);\r\n    }\r\n\r\n    // @notice cashBack will be used in case of failed ICO\r\n    // All partitipants can receive their ETH back\r\n    function cashBack(address _to) public {\r\n        uint usd;\r\n        (usd,,) = ICOStatus();\r\n\r\n        // ICO fails if crowd-sale is ended and we have not yet reached soft-cap\r\n        require(now > crowdsaleEndTime && usd < softcapUSD);\r\n        require(ethSent[_to] > 0);\r\n\r\n        delete ethSent[_to];\r\n\r\n        _to.transfer(ethSent[_to]);\r\n    }\r\n\r\n    // @notice stores amount of ETH received by SC\r\n    mapping(address => uint) ethSent;\r\n\r\n    function purchaseWithETH(address _to) payable public {\r\n        purchaseWithPromoter(_to, referral[msg.sender]);\r\n    }\r\n\r\n    // @notice purchases tokens, which a send to `_to` with 5% returned to `_ref`\r\n    // @notice 5% return must work only on crowdsale\r\n    function purchaseWithPromoter(address _to, address _ref) payable public {\r\n        require(now >= presaleStartTime && now <= crowdsaleEndTime);\r\n\r\n        require(!icoClosed);\r\n\r\n        uint _wei = msg.value;\r\n        uint recon;\r\n\r\n        ethSent[msg.sender] = ethSent[msg.sender].add(_wei);\r\n        ethSold = ethSold.add(_wei);\r\n\r\n        // accept payment on presale only if it is more than 9997$\r\n        // actual check is performed in _sellPresale\r\n        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\r\n            require(kyc[msg.sender]);\r\n            recon = _wei.mul(ethRate).div(75000000); // 1 RECON = 0.75 $ on presale\r\n\r\n            require(now < crowdsaleStartTime || recon >= bonusLevel100);\r\n\r\n            _sellPresale(recon);\r\n\r\n            // we have only 2 recognized promoters\r\n            if (_ref == wuguAddr || _ref == richardAddr) {\r\n                promoterClients[_ref].push(_to);\r\n                promoterBonus[_ref][_to] = _wei.mul(5).div(100);\r\n            }\r\n        } else {\r\n            recon = _wei.mul(ethRate).div(10000000); // 1 RECON = 1.00 $ on crowd-sale\r\n            _sellCrowd(recon, _to);\r\n        }\r\n\r\n        _freezeTransfer(_to, recon);\r\n    }\r\n\r\n    // @notice purchaseWithBTC is called from backend, where we convert\r\n    // BTC to ETH, and then assign tokens to purchaser, using BTC / $ exchange rate.\r\n    function purchaseWithBTC(address _to, uint _satoshi, uint _wei) public onlyAdmin {\r\n        require(now >= presaleStartTime && now <= crowdsaleEndTime);\r\n\r\n        require(!icoClosed);\r\n\r\n        ethSold = ethSold.add(_wei);\r\n\r\n        uint recon;\r\n        // accept payment on presale only if it is more than 9997$\r\n        // actual check is performed in _sellPresale\r\n        if (now < crowdsaleStartTime || approvedInvestors[msg.sender]) {\r\n            require(kyc[msg.sender]);\r\n            recon = _satoshi.mul(btcRate.mul(10000)).div(75); // 1 RECON = 0.75 $ on presale\r\n\r\n            require(now < crowdsaleStartTime || recon >= bonusLevel100);\r\n\r\n            _sellPresale(recon);\r\n        } else {\r\n            recon = _satoshi.mul(btcRate.mul(10000)).div(100); // 1 RECON = 1.00 $ on presale\r\n            _sellCrowd(recon, _to);\r\n        }\r\n\r\n        _freezeTransfer(_to, recon);\r\n    }\r\n\r\n    // @notice withdrawFunds is called to send team bonuses after\r\n    // then end of the ICO\r\n    bool withdrawCalled = false;\r\n    function withdrawFunds() public onlyOwner {\r\n        require(icoClosed && now >= teamETHUnlock1);\r\n\r\n        require(!withdrawCalled);\r\n        withdrawCalled = true;\r\n\r\n        uint eth;\r\n        (,eth,) = ICOStatus();\r\n\r\n        // pre-ico tokens are not in ethSold\r\n        uint minus = bonusTransferred.mul(10**8).div(ethRate);\r\n        uint team = ethSold.sub(minus);\r\n\r\n        team = team.mul(15).div(100);\r\n\r\n        uint ownerETH = 0;\r\n        uint teamETH = 0;\r\n        if (address(this).balance >= team) {\r\n            teamETH = team;\r\n            ownerETH = address(this).balance.sub(teamETH);\r\n        } else {\r\n            teamETH = address(this).balance;\r\n        }\r\n\r\n        teamETH1 = teamETH.div(3);\r\n        teamETH2 = teamETH.div(3);\r\n        teamETH3 = teamETH.sub(teamETH1).sub(teamETH2);\r\n\r\n        // TODO multisig\r\n        address(0xf14B65F1589B8bC085578BcF68f09653D8F6abA8).transfer(ownerETH);\r\n    }\r\n\r\n    uint teamETH1 = 0;\r\n    uint teamETH2 = 0;\r\n    uint teamETH3 = 0;\r\n    function withdrawTeam() public {\r\n        require(now >= teamETHUnlock1);\r\n\r\n        uint amount = 0;\r\n        if (now < teamETHUnlock2) {\r\n            amount = teamETH1;\r\n            teamETH1 = 0;\r\n        } else if (now < teamETHUnlock3) {\r\n            amount = teamETH1 + teamETH2;\r\n            teamETH1 = 0;\r\n            teamETH2 = 0;\r\n        } else {\r\n            amount = teamETH1 + teamETH2 + teamETH3;\r\n            teamETH1 = 0;\r\n            teamETH2 = 0;\r\n            teamETH3 = 0;\r\n        }\r\n\r\n        address(0x5c4F791D0E0A2E75Ee34D62c16FB6D09328555fF).transfer(amount.mul(6).div(100)); // Recon Cash-in (B2B)\r\n        address(0xeB479640A6D55374aF36896eCe6db7d92F390015).transfer(amount.mul(6).div(100)); // Recon Switch (C2C)\r\n        address(0x77167D25Db87dc072399df433e450B00b8Ec105A).transfer(amount.mul(6).div(100)); // Recon Cash-out (B2C)\r\n        address(0x1Ecb8dC0932AF3A3ba87e8bFE7eac3Cbe433B78B).transfer(amount.mul(2).div(100)); // Recon Reward\r\n        address(0x7C31BeCa0290C35c8452b95eA462C988c4003Bb0).transfer(amount.mul(2).div(100)); // Recon Donate\r\n\r\n        amount = amount.mul(78).div(100);\r\n\r\n        address(0x3a5326f9C9b3ff99e2e5011Aabec7b48B2e6A6A2).transfer(amount.mul(uint(255).mul(100).div(96)).div(1000)); // Recon Token\r\n        address(0x5a27B07003ce50A80dbBc5512eA5BBd654790673).transfer(amount.mul(uint(185).mul(100).div(96)).div(1000)); // Recon Cash\r\n        address(0xD580cF1002d0B4eF7d65dC9aC6a008230cE22692).transfer(amount.mul(uint(25).mul(100).div(96)).div(1000));  // Recon Gold\r\n        address(0x9C83562Bf58083ab408E596A4bA4951a2b5724C9).transfer(amount.mul(uint(250).mul(100).div(96)).div(1000)); // Recon Card\r\n        address(0x70E06c2Dd9568ECBae760CE2B61aC221C0c497F5).transfer(amount.mul(uint(245).mul(100).div(96)).div(1000)); // Recon Hardrive Wallet\r\n    }\r\n\r\n    // @notice doAirdrop is called when we launch airdrop.\r\n    // @notice airdrop tokens has their own supply.\r\n    uint dropped = 0;\r\n    function doAirdrop(address[] members, uint[] tokens) public onlyOwnerAndDirector {\r\n        require(members.length == tokens.length);\r\n\r\n        for(uint i = 0; i < members.length; i++) {\r\n            _freezeTransfer(members[i], tokens[i]);\r\n            dropped = dropped.add(tokens[i]);\r\n        }\r\n        require(dropped <= bountySupply);\r\n    }\r\n\r\n    mapping(address => uint) public whitemap;\r\n    uint public whitelistTokens = 0;\r\n    // @notice addWhitelistMember is used to whitelist participant.\r\n    // This means, that for the first 3 days of crowd-sale `_tokens` RECON\r\n    // will be reserved for him.\r\n    function addWhitelistMember(address[] _mem, uint[] _tokens) public onlyAdmin {\r\n        require(_mem.length == _tokens.length);\r\n        for(uint i = 0; i < _mem.length; i++) {\r\n            whitelistTokens = whitelistTokens.sub(whitemap[_mem[i]]).add(_tokens[i]);\r\n            whitemap[_mem[i]] = _tokens[i];\r\n        }\r\n    }\r\n\r\n    uint public adviserSold = 0;\r\n    // @notice transferAdviser is called to send tokens to advisers.\r\n    // @notice adviser tokens have their own supply\r\n    function transferAdviser(address[] _adv, uint[] _tokens) public onlyOwnerAndDirector {\r\n        require(_adv.length == _tokens.length);\r\n        for (uint i = 0; i < _adv.length; i++) {\r\n            adviserSold = adviserSold.add(_tokens[i]);\r\n            _freezeTransfer(_adv[i], _tokens[i]);\r\n        }\r\n        require(adviserSold <= adviserSupply);\r\n    }\r\n\r\n    mapping(address => bool) approvedInvestors;\r\n    function approveInvestor(address _addr) public onlyOwner {\r\n        approvedInvestors[_addr] = true;\r\n    }\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\ncontract ERC20InterfaceTest {\r\n    function totalSupply() public view returns (uint);\r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n\r\n// ----------------------------------------------------------------------------\r\n// Contracts that can have tokens approved, and then a function execute\r\n// ----------------------------------------------------------------------------\r\ncontract TestApproveAndCallFallBack {\r\n    event LogBytes(bytes data);\r\n\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public {\r\n        ERC20Interface(token).transferFrom(from, address(this), tokens);\r\n        emit LogBytes(data);\r\n    }\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\ncontract AccessRestriction {\r\n    // These will be assigned at the construction\r\n    // phase, where `msg.sender` is the account\r\n    // creating this contract.\r\n    address public owner = msg.sender;\r\n    uint public creationTime = now;\r\n\r\n    // Modifiers can be used to change\r\n    // the body of a function.\r\n    // If this modifier is used, it will\r\n    // prepend a check that only passes\r\n    // if the function is called from\r\n    // a certain address.\r\n    modifier onlyBy(address _account)\r\n    {\r\n        require(\r\n            msg.sender == _account,\r\n            \"Sender not authorized.\"\r\n        );\r\n        // Do not forget the \"_;\"! It will\r\n        // be replaced by the actual function\r\n        // body when the modifier is used.\r\n        _;\r\n    }\r\n\r\n    // Make `_newOwner` the new owner of this\r\n    // contract.\r\n    function changeOwner(address _newOwner)\r\n        public\r\n        onlyBy(owner)\r\n    {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    modifier onlyAfter(uint _time) {\r\n        require(\r\n            now >= _time,\r\n            \"Function called too early.\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    // Erase ownership information.\r\n    // May only be called 6 weeks after\r\n    // the contract has been created.\r\n    function disown()\r\n        public\r\n        onlyBy(owner)\r\n        onlyAfter(creationTime + 6 weeks)\r\n    {\r\n        delete owner;\r\n    }\r\n\r\n    // This modifier requires a certain\r\n    // fee being associated with a function call.\r\n    // If the caller sent too much, he or she is\r\n    // refunded, but only after the function body.\r\n    // This was dangerous before Solidity version 0.4.0,\r\n    // where it was possible to skip the part after `_;`.\r\n    modifier costs(uint _amount) {\r\n        require(\r\n            msg.value >= _amount,\r\n            \"Not enough Ether provided.\"\r\n        );\r\n        _;\r\n        if (msg.value > _amount)\r\n            msg.sender.transfer(msg.value - _amount);\r\n    }\r\n\r\n    function forceOwnerChange(address _newOwner)\r\n        public\r\n        payable\r\n        costs(200 ether)\r\n    {\r\n        owner = _newOwner;\r\n        // just some example condition\r\n        if (uint(owner) & 0 == 1)\r\n            // This did not refund for Solidity\r\n            // before version 0.4.0.\r\n            return;\r\n        // refund overpaid fees\r\n    }\r\n}\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\npragma solidity ^ 0.4.25;\r\n\r\ncontract WithdrawalContract {\r\n    address public richest;\r\n    uint public mostSent;\r\n\r\n    mapping (address => uint) pendingWithdrawals;\r\n\r\n    constructor() public payable {\r\n        richest = msg.sender;\r\n        mostSent = msg.value;\r\n    }\r\n\r\n    function becomeRichest() public payable returns (bool) {\r\n        if (msg.value > mostSent) {\r\n            pendingWithdrawals[richest] += msg.value;\r\n            richest = msg.sender;\r\n            mostSent = msg.value;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function withdraw() public {\r\n        uint amount = pendingWithdrawals[msg.sender];\r\n        // Remember to zero the pending refund before\r\n        // sending to prevent re-entrancy attacks\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n    }\r\n}\r\n\r\n\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//.\r\n//\"\r\n//.             ::::::..  .,::::::  .,-:::::     ...    :::.    :::\r\n//.           ;;;;``;;;; ;;;;'''' ,;;;'````'  .;;;;;;;.`;;;;,  `;;;\r\n//.            [[[,/[[['  [[cccc  [[[        ,[[     \\[[,[[[[[. '[[\r\n//.            $$$$$$c    $$\"\"\"\"  $$$        $$$,     $$$$$$ \"Y$c$$\r\n//.            888b \"88bo,888oo,__`88bo,__,o,\"888,_ _,88P888    Y88\r\n//.            MMMM   \"W\" \"\"\"\"YUMMM \"YUMMMMMP\" \"YMMMMMP\" MMM     YM\r\n//.\r\n//.\r\n//\" -----------------------------------------------------------------------------------------------------------------\r\n//             ¸.•*´¨)\r\n//        ¸.•´   ¸.•´¸.•*´¨) ¸.•*¨)\r\n//  ¸.•*´       (¸.•´ (¸.•` ¤ ReconBank.eth / ReconBank.com*´¨)\r\n//                                                        ¸.•´¸.•*´¨)\r\n//                                                      (¸.•´   ¸.•`\r\n//                                                          ¸.•´•.¸\r\n//   (c) Recon® / Common ownership of BlockReconChain® for ReconBank® / Ltd 2018.\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// Common ownership of :\r\n//  ____  _            _    _____                       _____ _           _\r\n// |  _ \\| |          | |  |  __ \\                     / ____| |         (_)\r\n// | |_) | | ___   ___| | _| |__) |___  ___ ___  _ __ | |    | |__   __ _ _ _ __\r\n// |  _ <| |/ _ \\ / __| |/ /  _  // _ \\/ __/ _ \\| '_ \\| |    | '_ \\ / _` | | '_ \\\r\n// | |_) | | (_) | (__|   <| | \\ \\  __/ (_| (_) | | | | |____| | | | (_| | | | | |\r\n// |____/|_|\\___/ \\___|_|\\_\\_|  \\_\\___|\\___\\___/|_| |_|\\_____|_| |_|\\__,_|_|_| |_|®\r\n//'\r\n// -----------------------------------------------------------------------------------------------------------------\r\n//\r\n// This contract is an order from :\r\n//'\r\n// ██████╗ ███████╗ ██████╗ ██████╗ ███╗   ██╗██████╗  █████╗ ███╗   ██╗██╗  ██╗    ██████╗ ██████╗ ███╗   ███╗®\r\n// ██╔══██╗██╔════╝██╔════╝██╔═══██╗████╗  ██║██╔══██╗██╔══██╗████╗  ██║██║ ██╔╝   ██╔════╝██╔═══██╗████╗ ████║\r\n// ██████╔╝█████╗  ██║     ██║   ██║██╔██╗ ██║██████╔╝███████║██╔██╗ ██║█████╔╝    ██║     ██║   ██║██╔████╔██║\r\n// ██╔══██╗██╔══╝  ██║     ██║   ██║██║╚██╗██║██╔══██╗██╔══██║██║╚██╗██║██╔═██╗    ██║     ██║   ██║██║╚██╔╝██║\r\n// ██║  ██║███████╗╚██████╗╚██████╔╝██║ ╚████║██████╔╝██║  ██║██║ ╚████║██║  ██╗██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\r\n// ╚═╝  ╚═╝╚══════╝ ╚═════╝ ╚═════╝ ╚═╝  ╚═══╝╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝╚═╝  ╚═╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝'\r\n//\r\n// -----------------------------------------------------------------------------------------------------------------\r\n\r\n\r\n// Thank you for making the extra effort that others probably wouldnt have made","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"preICOSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconnewOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Reconminter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"whitemap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preICOprivate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconCashinB2B\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setBTCRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate7\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRateMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate5\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelistTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconVaultNextStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorGiven\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Reconspender\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconCash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"purchaseWithETH\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconfeeAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDirector\",\"type\":\"address\"}],\"name\":\"setDirector\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusLevel0\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"kyc\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PeerToPeerNetworkingService\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamUnlock3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamUnlock4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconCashoutB2C\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconManager\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconrecoveredAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setETHRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconVaultAdvancePaymentStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"assignPreicoTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RecoinOption\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamETHUnlock2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconVaultPrivatStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btcRateMax\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconPromo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Reconia\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate11\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconToMicro\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconVaultSecurityStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adviserSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ethMax\",\"type\":\"uint256\"},{\"name\":\"btcMax\",\"type\":\"uint256\"}],\"name\":\"setMaxRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referral\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleMinUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"richardAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_satoshi\",\"type\":\"uint256\"},{\"name\":\"_wei\",\"type\":\"uint256\"}],\"name\":\"purchaseWithBTC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"approveInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnershipImmediately\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_adv\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"}],\"name\":\"transferAdviser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconDonate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"softcapUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusLevel100\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate12\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountySupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"checkTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"purchaseWithPromoter\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"assignTeamTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate6\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preicoUSD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconCard\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Reconowner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"Owned1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleHardEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"cashBack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconVaultCurrencyInsurancestock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wuguAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ProprityfromReconBank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconHardriveWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"prolongCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ICOStatus\",\"outputs\":[{\"name\":\"usd\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"recon\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"p\",\"type\":\"uint8\"}],\"name\":\"addInvestorBonusInPercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconSwitchC2C\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTeam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mem\",\"type\":\"address[]\"},{\"name\":\"_tokens\",\"type\":\"uint256[]\"}],\"name\":\"addWhitelistMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"members\",\"type\":\"address[]\"},{\"name\":\"tokens\",\"type\":\"uint256[]\"}],\"name\":\"doAirdrop\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconSecurityandLegalFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethLastUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconMomentum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamETHUnlock1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adviserSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate10\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPromoter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamUnlock1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btcLastUpdate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"btcRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Reconpatents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"addInvestorBonusInTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamETHUnlock3\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"investorSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mem\",\"type\":\"address\"},{\"name\":\"_ref\",\"type\":\"address\"}],\"name\":\"kycPassed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamUnlock2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate13\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkICOStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate9\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate8\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconVaultFuturStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconVaultXtraStock\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_usd\",\"type\":\"uint256\"}],\"name\":\"transferBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unlockDate4\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ReconGold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"ReconTokenFactory","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://989f4256500940cfd9fa90e2ba77352c21551c5f9959b0e2d1c3f39592d438e6"}]}