{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n/******************************************************************************\\\r\n* Author: Nick Mudge, nick@mokens.io\r\n* Mokens\r\n* Copyright (c) 2018\r\n*\r\n* Implements ERC998ERC721BottomUp.\r\n/******************************************************************************/\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Storage contracts\r\n////////////\r\n//Some delegate contracts are listed with storage contracts they inherit.\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//Mokens\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage0 {\r\n    // funcId => delegate contract\r\n    mapping(bytes4 => address) internal delegates;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenUpdates\r\n//MokenOwner\r\n//QueryMokenDelegates\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage1 is Storage0 {\r\n    address internal contractOwner;\r\n    bytes[] internal funcSignatures;\r\n    // signature => index+1\r\n    mapping(bytes => uint256) internal funcSignatureToIndex;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokensSupportsInterfaces\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage2 is Storage1 {\r\n    mapping(bytes4 => bool) internal supportedInterfaces;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenRootOwnerOf\r\n//MokenERC721Metadata\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage3 is Storage2 {\r\n    struct Moken {\r\n        string name;\r\n        uint256 data;\r\n        uint256 parentTokenId;\r\n    }\r\n    //tokenId => moken\r\n    mapping(uint256 => Moken) internal mokens;\r\n    uint256 internal mokensLength;\r\n    // child address => child tokenId => tokenId+1\r\n    mapping(address => mapping(uint256 => uint256)) internal childTokenOwner;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC721Enumerable\r\n//MokenLinkHash\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage4 is Storage3 {\r\n    // root token owner address => (tokenId => approved address)\r\n    mapping(address => mapping(uint256 => address)) internal rootOwnerAndTokenIdToApprovedAddress;\r\n    // token owner => (operator address => bool)\r\n    mapping(address => mapping(address => bool)) internal tokenOwnerToOperators;\r\n    // Mapping from owner to list of owned token IDs\r\n    mapping(address => uint32[]) internal ownedTokens;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC721TopDown\r\n//MokenERC998ERC721TopDownBatch\r\n//MokenERC721\r\n//MokenERC721Batch\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage5 is Storage4 {\r\n    // tokenId => (child address => array of child tokens)\r\n    mapping(uint256 => mapping(address => uint256[])) internal childTokens;\r\n    // tokenId => (child address => (child token => child index)\r\n    mapping(uint256 => mapping(address => mapping(uint256 => uint256))) internal childTokenIndex;\r\n    // tokenId => (child address => contract index)\r\n    mapping(uint256 => mapping(address => uint256)) internal childContractIndex;\r\n    // tokenId => child contract\r\n    mapping(uint256 => address[]) internal childContracts;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC20TopDown\r\n//MokenStateChange\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage6 is Storage5 {\r\n    // tokenId => token contract\r\n    mapping(uint256 => address[]) internal erc20Contracts;\r\n    // tokenId => (token contract => token contract index)\r\n    mapping(uint256 => mapping(address => uint256)) erc20ContractIndex;\r\n    // tokenId => (token contract => balance)\r\n    mapping(uint256 => mapping(address => uint256)) internal erc20Balances;\r\n}\r\n///////////////////////////////////////////////////////////////////////////////////\r\n//MokenERC998ERC721BottomUp\r\n//MokenERC998ERC721BottomUpBatch\r\n///////////////////////////////////////////////////////////////////////////////////\r\ncontract Storage7 is Storage6 {\r\n    // parent address => (parent tokenId => array of child tokenIds)\r\n    mapping(address => mapping(uint256 => uint32[])) internal parentToChildTokenIds;\r\n    // tokenId => position in childTokens array\r\n    mapping(uint256 => uint256) internal tokenIdToChildTokenIdsIndex;\r\n}\r\n\r\ncontract RootOwnerOfHelper is Storage3 {\r\n\r\n    bytes32 constant ERC998_MAGIC_VALUE = 0xcd740db5;\r\n\r\n    // Use Cases handled:\r\n    // Case 1: Token owner is this contract and token\r\n    // Case 2: Token owner is this contract and top-down composable.\r\n    // Case 3: Token owner is top-down composable\r\n    // Case 4: Token owner is an unknown contract\r\n    // Case 5: Token owner is a user\r\n    // Case 6: Token owner is a bottom-up composable\r\n    // Case 7: Token owner is ERC721 token owned by top-down token\r\n    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n    // Case 9: Token owner is ERC721 token owned by user\r\n    function rootOwnerOf_(uint256 _tokenId) internal view returns (bytes32 rootOwner) {\r\n        address rootOwnerAddress = address(mokens[_tokenId].data);\r\n        require(rootOwnerAddress != address(0), \"tokenId not found.\");\r\n        uint256 parentTokenId;\r\n        bool isParent;\r\n\r\n        while (rootOwnerAddress == address(this)) {\r\n            parentTokenId = mokens[_tokenId].parentTokenId;\r\n            isParent = parentTokenId > 0;\r\n            if (isParent) {\r\n                // Case 1: Token owner is this contract and token\r\n                _tokenId = parentTokenId - 1;\r\n            }\r\n            else {\r\n                // Case 2: Token owner is this contract and top-down composable.\r\n                _tokenId = childTokenOwner[rootOwnerAddress][_tokenId] - 1;\r\n            }\r\n            rootOwnerAddress = address(mokens[_tokenId].data);\r\n        }\r\n\r\n        parentTokenId = mokens[_tokenId].parentTokenId;\r\n        isParent = parentTokenId > 0;\r\n        if (isParent) {\r\n            parentTokenId--;\r\n        }\r\n\r\n        bytes memory calldata;\r\n        bool callSuccess;\r\n\r\n        if (isParent == false) {\r\n\r\n            // success if this token is owned by a top-down token\r\n            // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n            calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 3: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // Case 4: Token owner is an unknown contract\r\n                // Or\r\n                // Case 5: Token owner is a user\r\n                return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n            }\r\n        }\r\n        else {\r\n\r\n            // 0x43a61a8e == rootOwnerOf(uint256)\r\n            calldata = abi.encodeWithSelector(0x43a61a8e, parentTokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    rootOwner := mload(calldata)\r\n                }\r\n            }\r\n            if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                // Case 6: Token owner is a bottom-up composable\r\n                // Or\r\n                // Case 2: Token owner is top-down composable\r\n                return rootOwner;\r\n            }\r\n            else {\r\n                // token owner is ERC721\r\n                address childContract = rootOwnerAddress;\r\n                //0x6352211e == \"ownerOf(uint256)\"\r\n                calldata = abi.encodeWithSelector(0x6352211e, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwnerAddress := mload(calldata)\r\n                    }\r\n                }\r\n                require(callSuccess, \"Call to ownerOf failed\");\r\n\r\n                // 0xed81cdda == rootOwnerOfChild(address,uint256)\r\n                calldata = abi.encodeWithSelector(0xed81cdda, childContract, parentTokenId);\r\n                assembly {\r\n                    callSuccess := staticcall(gas, rootOwnerAddress, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                    if callSuccess {\r\n                        rootOwner := mload(calldata)\r\n                    }\r\n                }\r\n                if (callSuccess == true && rootOwner >> 224 == ERC998_MAGIC_VALUE) {\r\n                    // Case 7: Token owner is ERC721 token owned by top-down token\r\n                    return rootOwner;\r\n                }\r\n                else {\r\n                    // Case 8: Token owner is ERC721 token owned by unknown contract\r\n                    // Or\r\n                    // Case 9: Token owner is ERC721 token owned by user\r\n                    return ERC998_MAGIC_VALUE << 224 | bytes32(rootOwnerAddress);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract MokenHelpers is Storage4, RootOwnerOfHelper {\r\n\r\n    bytes4 constant ERC721_RECEIVED_NEW = 0x150b7a02;\r\n\r\n    uint256 constant UINT16_MASK = 0x000000000000000000000000000000000000000000000000000000000000ffff;\r\n    uint256 constant MAX_OWNER_MOKENS = 65536;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed tokenOwner, address indexed approved, uint256 indexed tokenId);\r\n\r\n    function childApproved(address _from, uint256 _tokenId) internal {\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n        if(msg.sender != _from) {\r\n            bytes32 tokenOwner;\r\n            bool callSuccess;\r\n            // 0xeadb80b8 == ownerOfChild(address,uint256)\r\n            bytes memory calldata = abi.encodeWithSelector(0xed81cdda, address(this), _tokenId);\r\n            assembly {\r\n                callSuccess := staticcall(gas, _from, add(calldata, 0x20), mload(calldata), calldata, 0x20)\r\n                if callSuccess {\r\n                    tokenOwner := mload(calldata)\r\n                }\r\n            }\r\n            if(callSuccess == true) {\r\n                require(tokenOwner >> 224 != ERC998_MAGIC_VALUE, \"Token is child of top down composable\");\r\n            }\r\n            require(tokenOwnerToOperators[_from][msg.sender] || approvedAddress == msg.sender, \"msg.sender not _from/operator/approved.\");\r\n        }\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[_from][_tokenId];\r\n            emit Approval(_from, address(0), _tokenId);\r\n        }\r\n    }\r\n\r\n    function _transferFrom(uint256 data, address _to, uint256 _tokenId) internal {\r\n        address _from = address(data);\r\n        //removing the tokenId\r\n        // 1. We replace _tokenId in ownedTokens[_from] with the last token id\r\n        //    in ownedTokens[_from]\r\n        uint256 lastTokenIndex = ownedTokens[_from].length - 1;\r\n        uint256 lastTokenId = ownedTokens[_from][lastTokenIndex];\r\n        if (lastTokenId != _tokenId) {\r\n            uint256 tokenIndex = data >> 160 & UINT16_MASK;\r\n            ownedTokens[_from][tokenIndex] = uint32(lastTokenId);\r\n            // 2. We set lastTokeId to point to its new position in ownedTokens[_from]\r\n            mokens[lastTokenId].data = mokens[lastTokenId].data & 0xffffffffffffffffffff0000ffffffffffffffffffffffffffffffffffffffff | tokenIndex << 160;\r\n        }\r\n        // 3. We remove lastTokenId from the end of ownedTokens[_from]\r\n        ownedTokens[_from].length--;\r\n\r\n        //adding the tokenId\r\n        uint256 ownedTokensIndex = ownedTokens[_to].length;\r\n        // prevents 16 bit overflow\r\n        require(ownedTokensIndex < MAX_OWNER_MOKENS, \"A token owner address cannot possess more than 65,536 mokens.\");\r\n        mokens[_tokenId].data = data & 0xffffffffffffffffffff00000000000000000000000000000000000000000000 | ownedTokensIndex << 160 | uint256(_to);\r\n        ownedTokens[_to].push(uint32(_tokenId));\r\n\r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n\r\n    function isContract(address addr) internal view returns (bool) {\r\n        uint256 size;\r\n        assembly {size := extcodesize(addr)}\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ninterface ERC721 {\r\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\r\n    event Approval(address indexed tokenOwner, address indexed approved, uint256 indexed tokenId);\r\n    event ApprovalForAll(address indexed tokenOwner, address indexed operator, bool approved);\r\n\r\n    function balanceOf(address _tokenOwner) external view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) external view returns (address _tokenOwner);\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) external;\r\n    function approve(address _to, uint256 _tokenId) external;\r\n    function setApprovalForAll(address _operator, bool _approved) external;\r\n    function getApproved(uint256 _tokenId) external view returns (address _operator);\r\n    function isApprovedForAll(address _tokenOwner, address _operator) external view returns (bool);\r\n}\r\n\r\ninterface ERC721TokenReceiver {\r\n    function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns (bytes4);\r\n}\r\n\r\ncontract MokenERC998ERC721BottomUp is Storage7, MokenHelpers {\r\n\r\n    event TransferToParent(address indexed toContract, uint256 indexed toTokenId, uint256 tokenId);\r\n    event TransferFromParent(address indexed fromContract, uint256 indexed fromTokenId, uint256 tokenId);\r\n\r\n    function tokenOwnerOf(uint256 _tokenId) external view returns (bytes32 tokenOwner, uint256 parentTokenId, bool isParent) {\r\n        address tokenOwnerAddress = address(mokens[_tokenId].data);\r\n        require(tokenOwnerAddress != address(0), \"tokenId not found.\");\r\n        parentTokenId = mokens[_tokenId].parentTokenId;\r\n        isParent = parentTokenId > 0;\r\n        if (isParent) {\r\n            parentTokenId--;\r\n        }\r\n        return (ERC998_MAGIC_VALUE << 224 | bytes32(tokenOwnerAddress), parentTokenId, isParent);\r\n    }\r\n\r\n    function removeBottomUpChild(address _fromContract, uint256 _fromTokenId, uint256 _tokenId) internal {\r\n        uint256 lastChildTokenIndex = parentToChildTokenIds[_fromContract][_fromTokenId].length - 1;\r\n        uint256 lastChildTokenId = parentToChildTokenIds[_fromContract][_fromTokenId][lastChildTokenIndex];\r\n\r\n        if (_tokenId != lastChildTokenId) {\r\n            uint256 currentChildTokenIndex = tokenIdToChildTokenIdsIndex[_tokenId];\r\n            parentToChildTokenIds[_fromContract][_fromTokenId][currentChildTokenIndex] = uint32(lastChildTokenId);\r\n            tokenIdToChildTokenIdsIndex[lastChildTokenId] = currentChildTokenIndex;\r\n        }\r\n        parentToChildTokenIds[_fromContract][_fromTokenId].length--;\r\n    }\r\n\r\n    function transferFromParent(address _fromContract, uint256 _fromTokenId, address _to, uint256 _tokenId, bytes _data) external {\r\n        require(_fromContract != address(0), \"_fromContract cannot be the 0 address.\");\r\n        require(_to != address(0), \"_to cannot be the 0 address.\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _fromContract, \"The tokenId is not owned by _fromContract.\");\r\n        uint256 parentTokenId = mokens[_tokenId].parentTokenId;\r\n        require(parentTokenId != 0, \"Token does not have a parent token.\");\r\n        require(parentTokenId - 1 == _fromTokenId, \"tokenId not owned by _fromTokenId\");\r\n\r\n        address rootOwner = address(rootOwnerOf_(_tokenId));\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        approvedAddress == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n            emit Approval(rootOwner, address(0), _tokenId);\r\n        }\r\n\r\n        mokens[_tokenId].parentTokenId = 0;\r\n\r\n        removeBottomUpChild(_fromContract, _fromTokenId, _tokenId);\r\n        delete tokenIdToChildTokenIdsIndex[_tokenId];\r\n\r\n        _transferFrom(data, _to, _tokenId);\r\n\r\n        if (isContract(_to)) {\r\n            bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _fromContract, _tokenId, _data);\r\n            require(retval == ERC721_RECEIVED_NEW, \"Contract cannot receive ERC721 token.\");\r\n        }\r\n\r\n        emit TransferFromParent(_fromContract, _fromTokenId, _tokenId);\r\n\r\n    }\r\n\r\n    function transferToParent(address _from, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external {\r\n        require(_from != address(0), \"_from cannot be the 0 address.\");\r\n        require(_toContract != address(0), \"toContract cannot be 0\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _from, \"The tokenId is not owned by _from.\");\r\n        require(mokens[_tokenId].parentTokenId == 0, \"Cannot transfer from address when owned by a token.\");\r\n\r\n        childApproved(_from, _tokenId);\r\n\r\n        uint256 parentTokenId = _toTokenId + 1;\r\n        assert(parentTokenId > _toTokenId);\r\n        mokens[_tokenId].parentTokenId = parentTokenId;\r\n\r\n        uint256 index = parentToChildTokenIds[_toContract][_toTokenId].length;\r\n        parentToChildTokenIds[_toContract][_toTokenId].push(uint32(_tokenId));\r\n        tokenIdToChildTokenIdsIndex[_tokenId] = index;\r\n\r\n        _transferFrom(data, _toContract, _tokenId);\r\n\r\n        require(ERC721(_toContract).ownerOf(_toTokenId) != address(0), \"_toTokenId does not exist\");\r\n        emit TransferToParent(_toContract, _toTokenId, _tokenId);\r\n    }\r\n\r\n    function transferAsChild(address _fromContract, uint256 _fromTokenId, address _toContract, uint256 _toTokenId, uint256 _tokenId, bytes _data) external {\r\n        require(_fromContract != address(0), \"_fromContract cannot be the 0 address.\");\r\n        require(_toContract != address(0), \"_toContract cannot be the 0 address.\");\r\n        uint256 data = mokens[_tokenId].data;\r\n        require(address(data) == _fromContract, \"The tokenId is not owned by _fromContract.\");\r\n        uint256 parentTokenId = mokens[_tokenId].parentTokenId;\r\n        require(parentTokenId != 0, \"Token does not have a parent token.\");\r\n        require(parentTokenId - 1 == _fromTokenId, \"tokenId not owned by _fromTokenId\");\r\n\r\n        address rootOwner = address(rootOwnerOf_(_tokenId));\r\n        address approvedAddress = rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n        require(rootOwner == msg.sender || tokenOwnerToOperators[rootOwner][msg.sender] ||\r\n        approvedAddress == msg.sender, \"msg.sender not rootOwner/operator/approved.\");\r\n\r\n        if (approvedAddress != address(0)) {\r\n            delete rootOwnerAndTokenIdToApprovedAddress[rootOwner][_tokenId];\r\n            emit Approval(rootOwner, address(0), _tokenId);\r\n        }\r\n\r\n        removeBottomUpChild(_fromContract, _fromTokenId, _tokenId);\r\n\r\n        parentTokenId = _toTokenId + 1;\r\n        assert(parentTokenId > _toTokenId);\r\n        mokens[_tokenId].parentTokenId = parentTokenId;\r\n\r\n        uint256 index = parentToChildTokenIds[_toContract][_toTokenId].length;\r\n        parentToChildTokenIds[_toContract][_toTokenId].push(uint32(_tokenId));\r\n        tokenIdToChildTokenIdsIndex[_tokenId] = index;\r\n\r\n        _transferFrom(data, _toContract, _tokenId);\r\n\r\n        require(ERC721(_toContract).ownerOf(_toTokenId) != address(0), \"_toTokenId does not exist\");\r\n\r\n        emit Transfer(_fromContract, _toContract, _tokenId);\r\n        emit TransferFromParent(_fromContract, _fromTokenId, _tokenId);\r\n        emit TransferToParent(_toContract, _toTokenId, _tokenId);\r\n\r\n    }\r\n    function totalChildTokens(address _parentContract, uint256 _parentTokenId) public view returns (uint256) {\r\n        return parentToChildTokenIds[_parentContract][_parentTokenId].length;\r\n    }\r\n\r\n    function childTokenByIndex(address _parentContract, uint256 _parentTokenId, uint256 _index) public view returns (uint256) {\r\n        require(parentToChildTokenIds[_parentContract][_parentTokenId].length > _index, \"Child not found at index.\");\r\n        return parentToChildTokenIds[_parentContract][_parentTokenId][_index];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_parentContract\",\"type\":\"address\"},{\"name\":\"_parentTokenId\",\"type\":\"uint256\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"childTokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromContract\",\"type\":\"address\"},{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferFromParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_parentContract\",\"type\":\"address\"},{\"name\":\"_parentTokenId\",\"type\":\"uint256\"}],\"name\":\"totalChildTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenOwnerOf\",\"outputs\":[{\"name\":\"tokenOwner\",\"type\":\"bytes32\"},{\"name\":\"parentTokenId\",\"type\":\"uint256\"},{\"name\":\"isParent\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fromContract\",\"type\":\"address\"},{\"name\":\"_fromTokenId\",\"type\":\"uint256\"},{\"name\":\"_toContract\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferAsChild\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_toContract\",\"type\":\"address\"},{\"name\":\"_toTokenId\",\"type\":\"uint256\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transferToParent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"toContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"toTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TransferToParent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"fromContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"fromTokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"TransferFromParent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"MokenERC998ERC721BottomUp","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"999","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://475b931c9e7088ea71c05465af0df19871a07334eeab6df562c4c36e3823a1bb"}]}