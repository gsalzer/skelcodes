{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * @title Safe maths\r\n * @author https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n */\r\nlibrary SafeMath {\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        require(c >= a, \"Bad maths.\");\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b <= a, \"Bad maths.\");\r\n        c = a - b;\r\n    }\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b, \"Bad maths.\");\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        require(b > 0, \"Bad maths.\");\r\n        c = a / b;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC Token Standard #20 Interface\r\n * @author https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n * @notice This is the basic interface for ERC20 that ensures all required functions exist.\r\n * @dev https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n */\r\ncontract ERC20Interface {\r\n    function totalSupply() public constant returns (uint256);\r\n    function balanceOf(address tokenOwner) public constant returns (uint256 balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining);\r\n    function transfer(address to, uint256 tokens) public returns (bool success);\r\n    function approve(address spender, uint256 tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens);\r\n}\r\n\r\n\r\n/**\r\n * @title Contract function to receive approval and execute function in one call\r\n * @author https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n * @dev Borrowed from MiniMeToken\r\n */\r\ncontract ApproveAndCallFallBack {\r\n    function receiveApproval(address from, uint256 tokens, address token, bytes data) public;\r\n}\r\n\r\n\r\n/**\r\n * @title Owned Contract\r\n * @author https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n * @notice Gives an inheriting contract the ability for certain functions to be\r\n *   called only by the owner of the system.\r\n */\r\ncontract Owned {\r\n    address internal owner;\r\n    address internal newOwner;\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @notice Modifier indicates that the function can only be called by owner\r\n     */\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only the owner may execute this function.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @notice Give the ownership to the address _newOwner. Change only takes\r\n     *  place once the new owner accepts the ownership of this contract.\r\n     * @param _newOwner The address of the new owner\r\n     */\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n     * @notice Delete owner information\r\n     */\r\n    function disown() public onlyOwner() {\r\n        delete owner;\r\n    }\r\n\r\n    /**\r\n     * @notice The new owner accepts responsibility of contract ownership\r\n     *  by using this function.\r\n     */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner, \"You have not been selected as the new owner.\");\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Snowden Token\r\n * @author David Edwards <Telecontrol Unterhaltungselektronik AG>\r\n * @notice This contract provides UltraUpload a token with which to\r\n *   trade and receive dividends.\r\n * @dev Heavily derivative of the ERC20 Token Standard\r\n    https://theethereum.wiki/w/index.php/ERC20_Token_Standard\r\n */\r\ncontract SnowdenToken is ERC20Interface, Owned {\r\n    using SafeMath for uint256;\r\n\r\n    string public symbol;\r\n    string public  name;\r\n    uint8 public decimals;\r\n    uint256 internal accountCount = 0;\r\n    uint256 internal _totalSupply = 0;\r\n    bool internal readOnly = false;\r\n    uint256 internal constant MAX_256 = 2**256 - 1;\r\n    mapping(address => bool) public ignoreDividend;\r\n\r\n    event DividendGivenEvent(uint64 dividendPercentage);\r\n\r\n    mapping(address => uint256) public freezeUntil;\r\n\r\n    mapping(address => address) internal addressLinkedList;\r\n    mapping(address => uint256) public balances;\r\n    mapping(address => mapping(address => uint256)) public allowed;\r\n\r\n    /**\r\n     * @notice The token constructor. Creates the total supply.\r\n     * @param supply The total number of coins to mint\r\n     * @param addresses The addresses that will receive initial tokens\r\n     * @param tokens The number of tokens that each address will receive\r\n     * @param freezeList The unixepoch timestamp from which addresses are allowed to trade\r\n     * @param ignoreList Addresses passed into this array will never receive dividends. The ignore list will always include this token contract.\r\n     *\r\n     * For example, if addresses is [ \"0x1\", \"0x2\" ], then tokens will need to have [ 1000, 8000 ] and freezeList will need to have [ 0, 0 ]. Numbers may change, but the values need to exist.\r\n     */\r\n    constructor(uint256 supply, address[] addresses, uint256[] tokens, uint256[] freezeList, address[] ignoreList) public {\r\n        symbol = \"SNOW\";\r\n        name = \"Snowden\";\r\n        decimals = 0;\r\n        _totalSupply = supply; // * 10**uint(decimals);\r\n        balances[address(0)] = _totalSupply;\r\n\r\n        uint256 totalAddresses = addresses.length;\r\n        uint256 totalTokens = tokens.length;\r\n\r\n        // Must have positive number of addresses and tokens\r\n        require(totalAddresses > 0 && totalTokens > 0, \"Must be a positive number of addresses and tokens.\");\r\n\r\n        // Require same number of addresses as tokens\r\n        require(totalAddresses == totalTokens, \"Must be tokens assigned to all addresses.\");\r\n\r\n        uint256 aggregateTokens = 0;\r\n\r\n        for (uint256 i = 0; i < totalAddresses; i++) {\r\n            // Do not allow empty tokens â€“ although this would have no impact on\r\n            // the mappings (a 0 count on the mapping will not result in a new entry).\r\n            // It is better to break here to ensure that there was no input error.\r\n            require(tokens[i] > 0, \"No empty tokens allowed.\");\r\n\r\n            aggregateTokens = aggregateTokens + tokens[i];\r\n\r\n            // Supply should always be more than the number of tokens given out!\r\n            require(aggregateTokens <= supply, \"Supply is not enough for demand.\");\r\n\r\n            giveReserveTo(addresses[i], tokens[i]);\r\n            freezeUntil[addresses[i]] = freezeList[i];\r\n        }\r\n\r\n        ignoreDividend[address(this)] = true;\r\n        ignoreDividend[msg.sender] = true;\r\n        for (i = 0; i < ignoreList.length; i++) {\r\n            ignoreDividend[ignoreList[i]] = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Fallback function reverts all paid ether. Do not accept payments.\r\n     */\r\n    function () public payable {\r\n        revert();\r\n    }\r\n\r\n    /**\r\n     * @notice Total supply, including in reserve\r\n     * @return The number of tokens in circulation\r\n     */\r\n    function totalSupply() public constant returns (uint256) {\r\n        return _totalSupply; // (we use the local address to store the rest) - balances[address(0)];\r\n    }\r\n\r\n    /**\r\n     * @notice Return a list of addresses and their tokens\r\n     * @return Two arrays, the first a list of addresses, the second a list of\r\n     *   token amounts. Each index matches the other.\r\n     */\r\n    function list() public view returns (address[], uint256[]) {\r\n        address[] memory addrs = new address[](accountCount);\r\n        uint256[] memory tokens = new uint256[](accountCount);\r\n\r\n        uint256 i = 0;\r\n        address current = addressLinkedList[0];\r\n        while (current != 0) {\r\n            addrs[i] = current;\r\n            tokens[i] = balances[current];\r\n\r\n            current = addressLinkedList[current];\r\n            i++;\r\n        }\r\n\r\n        return (addrs, tokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Return the number of tokens not provisioned\r\n     * @return The total number of tokens left in the reserve pool\r\n     */\r\n    function remainingTokens() public view returns(uint256) {\r\n        return balances[address(0)];\r\n    }\r\n\r\n    /**\r\n     * @return Is the contract set to readonly\r\n     */\r\n    function isReadOnly() public view returns(bool) {\r\n        return readOnly;\r\n    }\r\n\r\n    /**\r\n     * @notice Get the token balance for account `tokenOwner`\r\n     * @param tokenOwner Address of the account to get the number of tokens for\r\n     * @return The number of tokens the address has\r\n     */\r\n    function balanceOf(address tokenOwner) public constant returns (uint256 balance) {\r\n        return balances[tokenOwner];\r\n    }\r\n\r\n    /**\r\n     * @notice Ensure that account is allowed to trade\r\n     * @param from Address of the account to send from\r\n     * @return True if this trade is allowed\r\n     */\r\n    function requireTrade(address from) public view {\r\n        require(!readOnly, \"Read only mode engaged\");\r\n\r\n        uint256 i = 0;\r\n        address current = addressLinkedList[0];\r\n        while (current != 0) {\r\n            if(current == from) {\r\n                uint256 timestamp = freezeUntil[current];\r\n                require(timestamp < block.timestamp, \"Trades from your account are temporarily not possible. This is due to ICO rules.\");\r\n\r\n                break;\r\n            }\r\n\r\n            current = addressLinkedList[current];\r\n            i++;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer the balance from token owner's account to `to` account\r\n     *    - Owner's account must have sufficient balance to transfer\r\n     *    - 0 value transfers are allowed\r\n     * @param to Address to transfer tokens to\r\n     * @param tokens Number of tokens to be transferred\r\n     */\r\n    function transfer(address to, uint256 tokens) public returns (bool success) {\r\n        requireTrade(msg.sender);\r\n        balances[msg.sender] = balances[msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(msg.sender, to, tokens);\r\n\r\n        ensureInAccountList(to);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n     *   from the token owner's account\r\n     * @param spender address of the spender to approve\r\n     * @param tokens Number of tokens to allow spender to spend\r\n     * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md\r\n     *   recommends that there are no checks for the approval double-spend attack\r\n     *   as this should be implemented in user interfaces\r\n     */\r\n    function approve(address spender, uint256 tokens) public returns (bool success) {\r\n        requireTrade(msg.sender);\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Transfer `tokens` from the `from` account to the `to` account\r\n     * @param from address to transfer tokens from\r\n     * @param to address to transfer tokens to\r\n     * @param tokens Number of tokens to transfer\r\n     * @dev The calling account must already have sufficient tokens approve(...)-d\r\n     *   for spending from the `from` account and\r\n     *   - From account must have sufficient balance to transfer\r\n     *   - Spender must have sufficient allowance to transfer\r\n     *   - 0 value transfers are allowed\r\n     */\r\n    function transferFrom(address from, address to, uint256 tokens) public returns (bool success) {\r\n        requireTrade(from);\r\n        balances[from] = balances[from].sub(tokens);\r\n        allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(from, to, tokens);\r\n\r\n        ensureInAccountList(from);\r\n        ensureInAccountList(to);\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice Returns the amount of tokens approved by the owner that can be\r\n     *   transferred to the spender's account\r\n     * @param tokenOwner The address of the owner of the token\r\n     * @param spender The address of the spender of the token\r\n     * @return Number of tokens that are approved for spending from the tokenOwner\r\n     */\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) {\r\n        requireTrade(tokenOwner);\r\n        return allowed[tokenOwner][spender];\r\n    }\r\n\r\n    /**\r\n     * @notice Token owner can approve for `spender` to transferFrom(...) `tokens`\r\n     *   from the token owner's account. The `spender` contract function\r\n     *   `receiveApproval(...)` is then executed\r\n     * @param spender address with which to approve\r\n     * @param tokens The number of tokens that this address is approved to take\r\n     * @param data Pass data to receiveApproval\r\n     */\r\n    function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) {\r\n        requireTrade(msg.sender);\r\n        allowed[msg.sender][spender] = tokens;\r\n        emit Approval(msg.sender, spender, tokens);\r\n        ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @notice In the event of errors, allow the owner to move tokens from an account\r\n     * @param addr address to take tokens from\r\n     * @param tokens The number of tokens to take\r\n     */\r\n    function transferAnyERC20Token(address addr, uint256 tokens) public onlyOwner returns (bool success) {\r\n        requireTrade(addr);\r\n        return ERC20Interface(addr).transfer(owner, tokens);\r\n    }\r\n\r\n    /**\r\n     * @notice Give tokens from the pool to account, creating the account if necessary\r\n     * @param to The address to deliver the new tokens to\r\n     * @param tokens The number of tokens to deliver\r\n     */\r\n    function giveReserveTo(address to, uint256 tokens) public onlyOwner {\r\n        require(!readOnly, \"Read only mode engaged\");\r\n\r\n        balances[address(0)] = balances[address(0)].sub(tokens);\r\n        balances[to] = balances[to].add(tokens);\r\n        emit Transfer(address(0), to, tokens);\r\n\r\n        ensureInAccountList(to);\r\n    }\r\n\r\n    /**\r\n     * @notice Distribute dividends to all owners\r\n     * @param percentage Given in the form 1% === 10000. This is not a number of\r\n     *   tokens, more a form of percentage that does not require decimals. This\r\n     *   supports 0.00001% (with 1 as the percentage value).\r\n     * @dev Dividends are rounded down, if a user has too few tokens, they will not receive anything\r\n     */\r\n    function giveDividend(uint64 percentage) public onlyOwner {\r\n        require(!readOnly, \"Read only mode engaged\");\r\n\r\n        require(percentage > 0, \"Percentage must be more than 0 (10000 = 1%)\"); // At least 0.00001% dividends\r\n        require(percentage <= 500000, \"Percentage may not be larger than 500000 (50%)\"); // No more than 50% dividends\r\n\r\n        emit DividendGivenEvent(percentage);\r\n\r\n        address current = addressLinkedList[0];\r\n        while (current != 0) {\r\n            bool found = ignoreDividend[current];\r\n            if(!found) {\r\n                uint256 extraTokens = (balances[current] * percentage) / 1000000;\r\n                giveReserveTo(current, extraTokens);\r\n            }\r\n            current = addressLinkedList[current];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Allow admins to (en|dis)able all write functionality for emergencies\r\n     * @param enabled true to enable read only mode, false to allow writing\r\n     */\r\n    function setReadOnly(bool enabled) public onlyOwner {\r\n        readOnly = enabled;\r\n    }\r\n\r\n    /**\r\n     * @notice Add an account to a linked list\r\n     * @param addr address of the account to add to the linked list\r\n     * @dev This is necessary to iterate over for listing purposes\r\n     */\r\n    function addToAccountList(address addr) internal {\r\n        require(!readOnly, \"Read only mode engaged\");\r\n\r\n        addressLinkedList[addr] = addressLinkedList[0x0];\r\n        addressLinkedList[0x0] = addr;\r\n        accountCount++;\r\n    }\r\n\r\n    /**\r\n     * @notice Remove an account from a linked list\r\n     * @param addr address of the account to remove from the linked list\r\n     * @dev This is necessary to iterate over for listing purposes\r\n     */\r\n    function removeFromAccountList(address addr) internal {\r\n        require(!readOnly, \"Read only mode engaged\");\r\n\r\n        uint16 i = 0;\r\n        bool found = false;\r\n        address parent;\r\n        address current = addressLinkedList[0];\r\n        while (true) {\r\n            if (addressLinkedList[current] == addr) {\r\n                parent = current;\r\n                found = true;\r\n                break;\r\n            }\r\n            current = addressLinkedList[current];\r\n\r\n            if (i++ > accountCount) break;\r\n        }\r\n\r\n        require(found, \"Account was not found to remove.\");\r\n\r\n        addressLinkedList[parent] = addressLinkedList[addressLinkedList[parent]];\r\n        delete addressLinkedList[addr];\r\n\r\n        if (balances[addr] > 0) {\r\n            balances[address(0)] += balances[addr];\r\n        }\r\n\r\n        delete balances[addr];\r\n\r\n        accountCount--;\r\n    }\r\n\r\n    /**\r\n     * @notice Make sure that this address exists in our linked list\r\n     * @param addr address of the account to test\r\n     * @dev This is necessary to iterate over for listing purposes\r\n     */\r\n    function ensureInAccountList(address addr) internal {\r\n        require(!readOnly, \"Read only mode engaged\");\r\n\r\n        bool found = false;\r\n        address current = addressLinkedList[0];\r\n        while (current != 0) {\r\n            if (current == addr) {\r\n                found = true;\r\n                break;\r\n            }\r\n            current = addressLinkedList[current];\r\n        }\r\n        if (!found) {\r\n            addToAccountList(addr);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"list\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enabled\",\"type\":\"bool\"}],\"name\":\"setReadOnly\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"percentage\",\"type\":\"uint64\"}],\"name\":\"giveDividend\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"ignoreDividend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"}],\"name\":\"requireTrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"freezeUntil\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"giveReserveTo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isReadOnly\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transferAnyERC20Token\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"supply\",\"type\":\"uint256\"},{\"name\":\"addresses\",\"type\":\"address[]\"},{\"name\":\"tokens\",\"type\":\"uint256[]\"},{\"name\":\"freezeList\",\"type\":\"uint256[]\"},{\"name\":\"ignoreList\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dividendPercentage\",\"type\":\"uint64\"}],\"name\":\"DividendGivenEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"SnowdenToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000016e360000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000260000000000000000000000000000000000000000000000000000000000000042000000000000000000000000000000000000000000000000000000000000005e0000000000000000000000000000000000000000000000000000000000000000d0000000000000000000000006aefe37666d410b3b43e849385099199f4ed381b0000000000000000000000006b7c96947df2af9f50bdaca3fd5c06dc49282370000000000000000000000000b48eb7bc4472bc2b6e0a49d2e80f6c086cfc80b70000000000000000000000003f37721eed6bce9b888d9cc70516b649d91d2bc0000000000000000000000000f37e925792b0f92cbfa5bf0686e4af59f26626c90000000000000000000000003d61870d1f5f7d8615db60d1d2cc3ec25eac961f000000000000000000000000451914e68868d43b2ae4ee93a4966cc65109f5fc000000000000000000000000679e6e0dd5452c022326f938a3d47060e96dea7800000000000000000000000070f63dd49c15828e66f8c57b62da193a97453c43000000000000000000000000c77121f16496b26ed31a44184e91af04ec41bdba000000000000000000000000d905faf79704fbd51954406f05be441337c560360000000000000000000000002ea61f913b0170a21d0f131b657304d2c0857e740000000000000000000000005a4271534ce8d3f55dc77c0b0ce1f8c04ed84550000000000000000000000000000000000000000000000000000000000000000d0000000000000000000000000000000000000000000000000000000000186a0000000000000000000000000000000000000000000000000000000000000c350000000000000000000000000000000000000000000000000000000000000c35000000000000000000000000000000000000000000000000000000000000186a00000000000000000000000000000000000000000000000000000000000036ee8000000000000000000000000000000000000000000000000000000000000f424000000000000000000000000000000000000000000000000000000000003d0900000000000000000000000000000000000000000000000000000000000027ac40000000000000000000000000000000000000000000000000000000000053ec6000000000000000000000000000000000000000000000000000000000000668a000000000000000000000000000000000000000000000000000000000000493e0000000000000000000000000000000000000000000000000000000000008d9a00000000000000000000000000000000000000000000000000000000000124f80000000000000000000000000000000000000000000000000000000000000000d000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005c787600000000000000000000000000000000000000000000000000000000005e5afb00000000000000000000000000000000000000000000000000000000005c2aad8000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000005c2aad800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000d0000000000000000000000006aefe37666d410b3b43e849385099199f4ed381b0000000000000000000000006b7c96947df2af9f50bdaca3fd5c06dc49282370000000000000000000000000b48eb7bc4472bc2b6e0a49d2e80f6c086cfc80b70000000000000000000000003f37721eed6bce9b888d9cc70516b649d91d2bc0000000000000000000000000f37e925792b0f92cbfa5bf0686e4af59f26626c90000000000000000000000003d61870d1f5f7d8615db60d1d2cc3ec25eac961f000000000000000000000000451914e68868d43b2ae4ee93a4966cc65109f5fc000000000000000000000000679e6e0dd5452c022326f938a3d47060e96dea7800000000000000000000000070f63dd49c15828e66f8c57b62da193a97453c43000000000000000000000000c77121f16496b26ed31a44184e91af04ec41bdba000000000000000000000000d905faf79704fbd51954406f05be441337c560360000000000000000000000002ea61f913b0170a21d0f131b657304d2c0857e740000000000000000000000005a4271534ce8d3f55dc77c0b0ce1f8c04ed84550","Library":"","SwarmSource":"bzzr://d6da9b42345000198e3a3e54d4e7500feb85b66c480aaee14af75c4070e50aa8"}]}