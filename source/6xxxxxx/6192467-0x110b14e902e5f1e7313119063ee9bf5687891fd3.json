{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    function divUp(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, 'div failed');\r\n        uint256 c = a / b;\r\n        require(a == b * c + a % b, 'div failed');\r\n        if (b * c != a) {\r\n            c += 1;\r\n        }\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary Random {\r\n    function getRandom (uint256 _start, uint256 _end) internal view returns (uint256) {\r\n        require(_start >= 0 && _end >= _start, 'get random error');\r\n        if (_end == _start) {\r\n            return _start;\r\n        }\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            block.timestamp\r\n            + block.difficulty\r\n            + (uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)\r\n            + block.gaslimit\r\n            + (uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)\r\n            + block.number\r\n        )));\r\n        return seed % (_end - _start) + _start;\r\n    }\r\n}\r\n\r\ncontract Events {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event BalanceChange(uint256 _changeType, address _owner, uint256 _amount, uint256 _roundId);\r\n    event Invite(uint256 _firstInvitor, uint256 _firstInvitorAward, uint256 _secondInvitor, uint256 _secondInvitorAward);\r\n    event Buy(uint256 _roundId, uint256 _token, uint256 _ethNoUse, uint256 _ticketEnd, uint256 _ticketNum);\r\n    event RoundStart(uint256 _roundId, uint256 _startTime);\r\n    event RoundEnd(uint256 _roundId, uint256 _endTime, address _luckyPlayerAddr, address _finalPlayerAddr, address _richPlayerAddr, uint256 _currentOut, uint256 _currentSharePool);\r\n    event TokenOver(uint256 _totalRemain);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract Xgame is Events {\r\n    using SafeMath for *;\r\n    \r\n    mapping (address => mapping (address => uint256)) private allowed;\r\n    uint256 public outToken = 0;\r\n    uint256 public outOverRoundId = 0;\r\n    uint256 public totalSharePool = 0;\r\n    bool private activated = false;\r\n    uint256 public pid = 0;\r\n    mapping (uint256 => Datasets.Round) public rounds;\r\n    uint256 public roundId = 0;\r\n    mapping (address => uint256) public addrPids; // address => playerId\r\n    mapping (uint256 => Datasets.Player) public players; // playerId => struct\r\n    Datasets.Token public token;\r\n    Datasets.Config public _config;\r\n    Datasets.Config public _oldConfig;\r\n    address private admin;\r\n    uint256 private adminId;\r\n    mapping (uint256 => mapping(uint256 => Datasets.PlayerRound)) public _playerRounds; // playerId => roundId => struct\r\n    mapping (uint256 => mapping(uint256 => address)) public _roundTickets; // roundId => ticketId => player address\r\n    uint256 private bigRoundStartTime;\r\n    uint256 private hasRoundNum;  // rounds num of big round\r\n    bool private bigRoundLock = false;\r\n    uint256 public bigRoundMaxRoundNum = 12;\r\n    \r\n    constructor () public {\r\n        admin = msg.sender;\r\n        // init config\r\n        token = Datasets.Token('XGT', 18, 50000000000000000000000000, false);\r\n        _config = Datasets.Config(10, 5, 50, 30, 10, 5, 5, 5000000000000000000, 10 minutes, 25000000000000000000000, 500, 5, 4 hours, 24 hours);\r\n        _oldConfig = Datasets.Config(10, 5, 50, 30, 10, 5, 5, 5000000000000000000, 10 minutes, 25000000000000000000000, 500, 5, 4 hours, 24 hours);\r\n        // init admin account\r\n        _determinePid(admin);\r\n        adminId = addrPids[admin];\r\n        players[adminId] = Datasets.Player(0, 0, admin, 0, 0, 0, 0);\r\n    }\r\n    \r\n    modifier isAdmin() {\r\n        require(msg.sender == admin, \"must be admin\");\r\n        _;\r\n    }\r\n    \r\n    modifier isActivated () {\r\n        require(activated == true, 'game not be activated');\r\n        _;\r\n    }\r\n    \r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n    \r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, 'eth too small');\r\n        require(_eth <= 100000000000000000000, 'eth too big');\r\n        _;\r\n    }\r\n    \r\n    modifier notPaused() {\r\n        require(token.paused == false, 'transfer paused');\r\n        _;\r\n    }\r\n    \r\n    //==============================================================================\r\n    //     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n    //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (view)\r\n    //====|=========================================================================\r\n    \r\n    function getRoundAwardTicketNum (uint256 _roundId) external view returns (uint256 last_lucky_ticketnum, uint256 last_rich_ticketnum, uint256 last_final_ticketnum) {\r\n        return (\r\n            activated == false || _roundId < 1 ? 0 : _playerRounds[addrPids[rounds[_roundId].luckyPlayerAddr]][_roundId].ticketNum,\r\n            activated == false || _roundId < 1 ? 0 : _playerRounds[addrPids[rounds[_roundId].richPlayerAddr]][_roundId].ticketNum,\r\n            activated == false || _roundId < 1 ? 0 : _playerRounds[addrPids[rounds[_roundId].finalPlayerAddr]][_roundId].ticketNum\r\n            );\r\n    }\r\n    \r\n    function getTimes () external view returns (uint256 small_gap, uint256 big_gap) {\r\n        if (activated == false) {\r\n            return (0, 0);\r\n        }\r\n        uint256 smallGap = _config.roundGap + rounds[roundId].endTime - now;\r\n        if (!(rounds[roundId].ended == true && rounds[roundId + 1].startTime == 0) || smallGap > _config.roundGap) {\r\n            smallGap = 0;\r\n        }\r\n        \r\n        uint256 bigGap = _config.bigRoundGapTime - now + bigRoundStartTime;\r\n        if (bigRoundLock == false || bigGap > _config.bigRoundGapTime) {\r\n            bigGap = 0;\r\n        }\r\n        \r\n        return (\r\n            smallGap,\r\n            bigGap\r\n            );\r\n    }\r\n    \r\n    function getEthBalance (address _addr) external view returns (uint256) {\r\n        return players[addrPids[_addr]].ethBalance;\r\n    }\r\n    \r\n    \r\n    \r\n    //==============================================================================\r\n    //     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n    //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (public function)\r\n    //====|=========================================================================\r\n    function pauseTransfer () external isHuman notPaused isAdmin {\r\n        token.paused = true;\r\n    }\r\n    \r\n    function deposit () external isHuman isActivated isWithinLimits(msg.value) payable {\r\n        _determinePid(msg.sender);\r\n        players[addrPids[msg.sender]].ethBalance = players[addrPids[msg.sender]].ethBalance.add(msg.value);\r\n    }\r\n    \r\n    function withdraw () external isHuman isActivated {\r\n        require(players[addrPids[msg.sender]].ethBalance > 0, 'balance not enough');\r\n        uint256 _temp = players[addrPids[msg.sender]].ethBalance;\r\n        players[addrPids[msg.sender]].ethBalance = 0;\r\n        msg.sender.transfer(_temp);\r\n    }\r\n    \r\n    function activate () external isAdmin {\r\n        require(rounds[roundId].roundId == 0, 'activate error');\r\n        activated = true;\r\n        \r\n        roundId = 1;\r\n        uint256 _time = now;\r\n        rounds[1] = Datasets.Round(1, 0, 0, _config.initMaxBet, false, _time, 0, 0, 0, 0, 0, 0, 0);\r\n        bigRoundStartTime = _time;\r\n\r\n        emit Events.RoundStart(roundId, rounds[roundId].startTime);\r\n    }\r\n    \r\n    function () external isActivated isHuman isWithinLimits(msg.value) payable {\r\n        _determinePid(msg.sender);\r\n        uint256 _playerId = addrPids[msg.sender];\r\n        uint256 _gotToken = _buyToken(_playerId, msg.value, 0);\r\n        if (rounds[roundId].ended == false && (_gotToken == 0 || _config.ticketSum <= rounds[roundId].ticketIndex)) {\r\n            _endRound();\r\n        }\r\n    }\r\n    \r\n    function withdrawShare (address _to) external isAdmin isActivated isHuman payable {\r\n        require(addrPids[_to] != 0);\r\n        players[addrPids[_to]].ethBalance += msg.value;\r\n    }\r\n    \r\n    function rebuy (uint256 _num) external isActivated isHuman {\r\n        require(_num <= _config.ticketSum);\r\n        require(addrPids[msg.sender] != 0 && players[addrPids[msg.sender]].ethBalance > 0, 'player not exist');\r\n        uint256 _eth = players[addrPids[msg.sender]].ethBalance;\r\n        players[addrPids[msg.sender]].ethBalance = 0;\r\n        uint256 _gotToken = _buyToken(addrPids[msg.sender], _eth, _num);\r\n        \r\n        invite(addrPids[msg.sender], _gotToken, 0);\r\n        \r\n        if (rounds[roundId].ended == false && (_gotToken == 0 || _config.ticketSum <= rounds[roundId].ticketIndex)) {\r\n            _endRound();\r\n        }\r\n    }\r\n    \r\n    function buy(uint256 _invitor) external isActivated isHuman isWithinLimits(msg.value) payable {\r\n        _determinePid(msg.sender);\r\n        uint256 _playerId = addrPids[msg.sender];\r\n        uint256 _gotToken = _buyToken(_playerId, msg.value, 0);\r\n        \r\n        invite(_playerId, _gotToken, _invitor);\r\n        \r\n        \r\n        if (rounds[roundId].ended == false && (_gotToken == 0 || _config.ticketSum <= rounds[roundId].ticketIndex)) {\r\n            _endRound();\r\n        }\r\n    }\r\n\r\n    function transfer(address _to, uint256 _value) external notPaused returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= players[addrPids[msg.sender]].tBalance);\r\n        require(players[addrPids[_to]].tBalance.add(_value) > players[addrPids[_to]].tBalance);\r\n        players[addrPids[msg.sender]].tBalance = players[addrPids[msg.sender]].tBalance.sub(_value);\r\n        emit Events.BalanceChange(0, msg.sender, _value, rounds[roundId].ended ? roundId + 1 : roundId);\r\n        _determinePid(_to);\r\n        players[addrPids[_to]].tBalance = players[addrPids[_to]].tBalance.add(_value);\r\n        emit Events.BalanceChange(1, _to, _value, rounds[roundId].ended ? roundId + 1 : roundId);\r\n        emit Events.Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n    \r\n    function balanceOf(address _owner) constant external returns (uint256 balance) {\r\n        return players[addrPids[_owner]].tBalance;\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\r\n        require(_to != address(0));\r\n        require(_value <= players[addrPids[_from]].tBalance);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n        require(players[addrPids[_to]].tBalance + _value > players[addrPids[_to]].tBalance);\r\n        players[addrPids[_to]].tBalance = players[addrPids[_to]].tBalance.add(_value);\r\n        players[addrPids[_from]].tBalance = players[addrPids[_from]].tBalance.sub(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Events.Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Events.Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    \r\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    //==============================================================================\r\n    //     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n    //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (private function)\r\n    //====|=========================================================================\r\n    \r\n    function invite (uint256 _playerId, uint256 _amount, uint256 _invitor) private returns (bool) {\r\n        if (_amount > 10) {\r\n            if (players[_playerId].invitor != 0) {\r\n                _invitor = players[_playerId].invitor;\r\n            } else {\r\n                if (_invitor == 0 || _playerId == _invitor || players[_invitor].addr == address(0)) {\r\n                    return false;\r\n                }\r\n                players[_playerId].invitor = _invitor;\r\n            }\r\n            \r\n            \r\n            uint256 _firstInvitorAward = _amount * _config.firstInviteAward / 100;\r\n            _giveToken(_invitor, _firstInvitorAward);\r\n            players[_invitor].tokenForInvite += _firstInvitorAward;\r\n\r\n    \r\n            uint256 secondInvitor = players[_invitor].invitor;\r\n            if (secondInvitor != 0 && players[secondInvitor].addr != address(0)) {\r\n                uint256 _secondInvitorAward = _amount * _config.secondInviteAward / 100;\r\n                _giveToken(secondInvitor, _secondInvitorAward);\r\n                players[secondInvitor].tokenForInvite += _secondInvitorAward;\r\n            }\r\n            emit Events.Invite(_invitor, _firstInvitorAward, secondInvitor, _secondInvitorAward);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    \r\n    \r\n    function _endRound () private {\r\n        // end round\r\n        rounds[roundId].ended = true;\r\n        rounds[roundId].endTime = now;\r\n        rounds[roundId].currentOutToken = outToken;\r\n        \r\n        uint256 _totalEth = rounds[roundId].hasBetted + rounds[roundId].wrapPool;\r\n        // share\r\n        uint256 _currentShareAward = _totalEth * _config.sharePoolPercent / 100;\r\n        admin.transfer(_currentShareAward);\r\n        totalSharePool += _currentShareAward;\r\n        // wrap\r\n        rounds[roundId + 1].wrapPool = _totalEth * _config.wrapPercent / 100;\r\n        // lucky\r\n        address _luckyPlayerAddr = _roundTickets[roundId][Random.getRandom(1, rounds[roundId].ticketIndex + 1) - 1];\r\n        if (_luckyPlayerAddr == address(0)) {\r\n            _luckyPlayerAddr = admin;\r\n        }\r\n        rounds[roundId].luckyPlayerAddr = _luckyPlayerAddr;\r\n        uint256 _luckyAward = _totalEth * _config.luckyPoolPercent / 100;\r\n        players[addrPids[_luckyPlayerAddr]].ethBalance += _luckyAward;\r\n        \r\n        // final\r\n        if (rounds[roundId].finalPlayerAddr == address(0)) {\r\n            rounds[roundId].finalPlayerAddr = admin;\r\n        }\r\n        players[addrPids[rounds[roundId].finalPlayerAddr]].ethBalance += _totalEth * _config.finalPoolPercent / 100;\r\n        \r\n        // rich\r\n        if (rounds[roundId].richPlayerAddr == address(0)) {\r\n            rounds[roundId].richPlayerAddr = admin;\r\n        }\r\n        players[addrPids[rounds[roundId].richPlayerAddr]].ethBalance += _totalEth * _config.richPoolPercent / 100;\r\n        \r\n        // next round data \r\n        if (rounds[roundId].ticketIndex < _config.ticketSum) {\r\n            rounds[roundId + 1].maxBet = rounds[roundId].maxBet - (rounds[roundId].maxBet * _config.maxBetRate / 10000);\r\n        } else {\r\n            rounds[roundId + 1].maxBet = rounds[roundId].maxBet + (rounds[roundId].maxBet * _config.maxBetRate).divUp(10000);\r\n        }\r\n        if (rounds[roundId + 1].maxBet < 500000000000000000) {\r\n            rounds[roundId + 1].maxBet = 500000000000000000;\r\n        }\r\n        \r\n        // remain token\r\n        uint256 _totalRemain = token.total - outToken;\r\n        if (outToken < token.total && _totalRemain < _config.tokenMaxIssue * 3 / 2) {\r\n            // change\r\n            _config.firstInviteAward = 0;\r\n            _config.secondInviteAward = 0;\r\n            _config.sharePoolPercent = 1;\r\n            _config.finalPoolPercent = 5;\r\n            _config.richPoolPercent = 5;\r\n            _config.luckyPoolPercent = 79;\r\n            _config.wrapPercent = 10;\r\n            outOverRoundId = roundId;\r\n            players[addrPids[admin]].tBalance += _totalRemain;\r\n            emit Events.BalanceChange(1, admin, _totalRemain, rounds[roundId].ended ? roundId + 1 : roundId);\r\n            outToken = token.total;\r\n            rounds[roundId].currentOutToken = outToken;\r\n            emit Events.TokenOver(_totalRemain);\r\n        }\r\n        \r\n        if (hasRoundNum == bigRoundMaxRoundNum - 1) {\r\n            bigRoundLock = true;\r\n        }\r\n        if (now - bigRoundStartTime > _config.bigRoundGapTime) {\r\n            bigRoundLock = false;\r\n            bigRoundStartTime = rounds[roundId].startTime;\r\n            hasRoundNum = 0;\r\n        }\r\n        \r\n        hasRoundNum += 1;\r\n        emit Events.RoundEnd(roundId, rounds[roundId].endTime, _luckyPlayerAddr, rounds[roundId].finalPlayerAddr, rounds[roundId].richPlayerAddr, rounds[roundId].currentOutToken, _currentShareAward);\r\n    }\r\n    \r\n    function _startRound () private {\r\n        rounds[roundId + 1].roundId = roundId + 1;\r\n        rounds[roundId + 1].ended = false;\r\n        rounds[roundId + 1].startTime = now;\r\n        roundId = roundId + 1;\r\n        emit Events.RoundStart(roundId, rounds[roundId].startTime);\r\n    }\r\n    \r\n    function _buyToken (uint256 _playerId, uint256 _eth, uint256 _num) private returns (uint256) {\r\n        if (rounds[roundId].ended == true) {\r\n            if (now < rounds[roundId].endTime + _config.roundGap) {\r\n                players[_playerId].ethBalance += _eth;\r\n                return 1;\r\n            }\r\n            if (bigRoundLock == true && now - bigRoundStartTime < _config.bigRoundGapTime) {\r\n                players[_playerId].ethBalance += _eth;\r\n                return 1;\r\n            }\r\n            _startRound();\r\n        }\r\n        \r\n        if (rounds[roundId].ended == false && rounds[roundId].startTime + _config.maxRoundTime < now) {\r\n            players[_playerId].ethBalance += _eth;\r\n            return 0;\r\n        }\r\n        \r\n        uint256 _ticketPrice = rounds[roundId].maxBet.divUp(_config.ticketSum);\r\n        if (_eth < _ticketPrice) {\r\n            players[_playerId].ethBalance += _eth;\r\n            return 1;\r\n        }\r\n        \r\n        uint256 _ethNoUse = 0;\r\n        uint256 _ethForToken = _eth;\r\n        uint256 _remainBet = (_config.ticketSum - rounds[roundId].ticketIndex) * _ticketPrice;\r\n        if (_eth > _remainBet) {\r\n            _ethNoUse = _eth - _remainBet;\r\n            players[_playerId].ethBalance += _ethNoUse;\r\n            _ethForToken = _remainBet;\r\n        }\r\n        \r\n        // lucky\r\n        if (_num == 0) {\r\n            uint256 _ticketNum = _ethForToken / _ticketPrice;\r\n        } else {\r\n            _ticketNum = _num;\r\n            require(_ethForToken >= _ticketNum * _ticketPrice);\r\n        }\r\n        \r\n        uint256 _dust = _ethForToken - (_ticketNum * _ticketPrice);\r\n        players[_playerId].ethBalance += _dust;\r\n        _ethNoUse += _dust;\r\n        _ethForToken = _ticketNum * _ticketPrice;\r\n        for (uint256 i = 0; i < _ticketNum; i++) {\r\n            _roundTickets[roundId][rounds[roundId].ticketIndex + i] = msg.sender;\r\n        }\r\n        rounds[roundId].ticketIndex += _ticketNum;\r\n        _playerRounds[_playerId][roundId].ticketNum += _ticketNum;\r\n        \r\n        \r\n        rounds[roundId].hasBetted += _ethForToken;\r\n        \r\n        if (outToken < token.total) {\r\n            // token for eth\r\n            uint256 _gotToken = _ticketNum * _config.tokenMaxIssue / _config.ticketSum;\r\n            _giveToken(_playerId, _gotToken);\r\n            players[_playerId].tokenForEth += _gotToken;\r\n            players[addrPids[admin]].tokenForEth += (_gotToken / 4);\r\n        } else {\r\n            _gotToken = 2;\r\n        }\r\n        \r\n        \r\n        // caculate rich player\r\n        if (rounds[roundId].richPlayerAddr == address(0) || _playerRounds[_playerId][roundId].ticketNum > rounds[roundId].richPlayerTicketsNum) {\r\n            rounds[roundId].richPlayerAddr = msg.sender;\r\n            rounds[roundId].richPlayerTicketsNum = _playerRounds[_playerId][roundId].ticketNum;\r\n        }\r\n        \r\n        // record last\r\n        rounds[roundId].finalPlayerAddr = msg.sender;\r\n        \r\n        emit Events.Buy(roundId, _gotToken, _ethNoUse, rounds[roundId].ticketIndex, _ticketNum);\r\n        \r\n        return _gotToken;\r\n    }\r\n    \r\n    function _giveToken (uint256 _playerId, uint256 _amount) private {\r\n        players[_playerId].tBalance += _amount;\r\n        emit Events.BalanceChange(1, players[_playerId].addr, _amount, rounds[roundId].ended ? roundId + 1 : roundId);\r\n        \r\n        // system got token\r\n        uint256 systemGot = _amount / 4;\r\n        players[addrPids[admin]].tBalance += systemGot;\r\n        emit Events.BalanceChange(1, players[addrPids[admin]].addr, systemGot, rounds[roundId].ended ? roundId + 1 : roundId);\r\n        \r\n        \r\n        outToken += (_amount + systemGot);\r\n    }\r\n    \r\n    function _determinePid(address _addr) private returns (bool) {\r\n        // if pid not exist, generate it\r\n        if (addrPids[_addr] == 0) {\r\n            pid++;\r\n            addrPids[_addr] = pid;\r\n            players[pid].addr = _addr;\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Datasets {\r\n    struct Player {\r\n        uint256 tBalance;\r\n        uint256 ethBalance;\r\n        address addr;\r\n        uint256 invitor;\r\n        uint256 tokenForInvite;\r\n        uint256 hasWithdrawRoundNum;\r\n        uint256 tokenForEth;\r\n    }\r\n    \r\n    struct Token {\r\n        string tokenName;\r\n        uint256 decimals;\r\n        uint256 total;\r\n        bool paused;\r\n    }\r\n    \r\n    struct Config {\r\n        uint256 firstInviteAward; // percent\r\n        uint256 secondInviteAward;\r\n        uint256 sharePoolPercent;\r\n        uint256 luckyPoolPercent;\r\n        uint256 wrapPercent;\r\n        uint256 finalPoolPercent;\r\n        uint256 richPoolPercent;\r\n        uint256 initMaxBet;\r\n        uint256 roundGap;\r\n        uint256 tokenMaxIssue;\r\n        uint256 ticketSum;\r\n        uint256 maxBetRate;  // per ten thousand\r\n        uint256 maxRoundTime;  // max round time. s\r\n        uint256 bigRoundGapTime; // max big round time\r\n    }\r\n    \r\n    struct Round {\r\n        uint256 roundId;\r\n        uint256 hasBetted;\r\n        uint256 wrapPool;\r\n        uint256 maxBet;\r\n        bool ended;\r\n        uint256 startTime;\r\n        uint256 endTime;\r\n        address richPlayerAddr;\r\n        uint256 richPlayerTicketsNum;\r\n        address luckyPlayerAddr;\r\n        uint256 ticketIndex;\r\n        address finalPlayerAddr;\r\n        uint256 currentOutToken;\r\n    }\r\n    \r\n    struct PlayerRound {\r\n        uint256 ticketNum;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawShare\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_config\",\"outputs\":[{\"name\":\"firstInviteAward\",\"type\":\"uint256\"},{\"name\":\"secondInviteAward\",\"type\":\"uint256\"},{\"name\":\"sharePoolPercent\",\"type\":\"uint256\"},{\"name\":\"luckyPoolPercent\",\"type\":\"uint256\"},{\"name\":\"wrapPercent\",\"type\":\"uint256\"},{\"name\":\"finalPoolPercent\",\"type\":\"uint256\"},{\"name\":\"richPoolPercent\",\"type\":\"uint256\"},{\"name\":\"initMaxBet\",\"type\":\"uint256\"},{\"name\":\"roundGap\",\"type\":\"uint256\"},{\"name\":\"tokenMaxIssue\",\"type\":\"uint256\"},{\"name\":\"ticketSum\",\"type\":\"uint256\"},{\"name\":\"maxBetRate\",\"type\":\"uint256\"},{\"name\":\"maxRoundTime\",\"type\":\"uint256\"},{\"name\":\"bigRoundGapTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"outToken\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_num\",\"type\":\"uint256\"}],\"name\":\"rebuy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getEthBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_oldConfig\",\"outputs\":[{\"name\":\"firstInviteAward\",\"type\":\"uint256\"},{\"name\":\"secondInviteAward\",\"type\":\"uint256\"},{\"name\":\"sharePoolPercent\",\"type\":\"uint256\"},{\"name\":\"luckyPoolPercent\",\"type\":\"uint256\"},{\"name\":\"wrapPercent\",\"type\":\"uint256\"},{\"name\":\"finalPoolPercent\",\"type\":\"uint256\"},{\"name\":\"richPoolPercent\",\"type\":\"uint256\"},{\"name\":\"initMaxBet\",\"type\":\"uint256\"},{\"name\":\"roundGap\",\"type\":\"uint256\"},{\"name\":\"tokenMaxIssue\",\"type\":\"uint256\"},{\"name\":\"ticketSum\",\"type\":\"uint256\"},{\"name\":\"maxBetRate\",\"type\":\"uint256\"},{\"name\":\"maxRoundTime\",\"type\":\"uint256\"},{\"name\":\"bigRoundGapTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"roundId\",\"type\":\"uint256\"},{\"name\":\"hasBetted\",\"type\":\"uint256\"},{\"name\":\"wrapPool\",\"type\":\"uint256\"},{\"name\":\"maxBet\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"richPlayerAddr\",\"type\":\"address\"},{\"name\":\"richPlayerTicketsNum\",\"type\":\"uint256\"},{\"name\":\"luckyPlayerAddr\",\"type\":\"address\"},{\"name\":\"ticketIndex\",\"type\":\"uint256\"},{\"name\":\"finalPlayerAddr\",\"type\":\"address\"},{\"name\":\"currentOutToken\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_roundTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pauseTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSharePool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"getRoundAwardTicketNum\",\"outputs\":[{\"name\":\"last_lucky_ticketnum\",\"type\":\"uint256\"},{\"name\":\"last_rich_ticketnum\",\"type\":\"uint256\"},{\"name\":\"last_final_ticketnum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addrPids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bigRoundMaxRoundNum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_invitor\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"outOverRoundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimes\",\"outputs\":[{\"name\":\"small_gap\",\"type\":\"uint256\"},{\"name\":\"big_gap\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"_playerRounds\",\"outputs\":[{\"name\":\"ticketNum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"tBalance\",\"type\":\"uint256\"},{\"name\":\"ethBalance\",\"type\":\"uint256\"},{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"invitor\",\"type\":\"uint256\"},{\"name\":\"tokenForInvite\",\"type\":\"uint256\"},{\"name\":\"hasWithdrawRoundNum\",\"type\":\"uint256\"},{\"name\":\"tokenForEth\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"tokenName\",\"type\":\"string\"},{\"name\":\"decimals\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"paused\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_changeType\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"}],\"name\":\"BalanceChange\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_firstInvitor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_firstInvitorAward\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_secondInvitor\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_secondInvitorAward\",\"type\":\"uint256\"}],\"name\":\"Invite\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_token\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ethNoUse\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ticketEnd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_ticketNum\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"RoundStart\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_endTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_luckyPlayerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_finalPlayerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_richPlayerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_currentOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_currentSharePool\",\"type\":\"uint256\"}],\"name\":\"RoundEnd\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_totalRemain\",\"type\":\"uint256\"}],\"name\":\"TokenOver\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"Xgame","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://aefc682a6c7a02160a46c85fcff37972dee7514aacb6028b69d0b4440dead988"}]}