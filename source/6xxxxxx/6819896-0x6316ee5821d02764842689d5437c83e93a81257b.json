{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary Address {\r\n    /**\r\n     * Returns whether the target address is a contract\r\n     * @dev This function will return false if invoked during the constructor of a contract,\r\n     * as the code is not actually created until after the constructor finishes.\r\n     * @param account address of the account to check\r\n     * @return whether the target address is a contract\r\n     */\r\n    function isContract(address account) internal view returns (bool) {\r\n        uint256 size;\r\n        // XXX Currently there is no better way to check if there is a contract in an address\r\n        // than to check the size of the code at that address.\r\n        // See https://ethereum.stackexchange.com/a/14016/36603\r\n        // for more details about how this works.\r\n        // TODO Check this again before the Serenity release, because all addresses will be\r\n        // contracts then.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly { size := extcodesize(account) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner());\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n* @dev Contract Version Manager\r\n*/\r\ncontract ContractManager is Ownable {\r\n\r\n    event VersionAdded(\r\n        string contractName,\r\n        string versionName,\r\n        address indexed implementation\r\n    );\r\n\r\n    event StatusChanged(\r\n        string contractName,\r\n        string versionName,\r\n        Status status\r\n    );\r\n\r\n    event BugLevelChanged(\r\n        string contractName,\r\n        string versionName,\r\n        BugLevel bugLevel\r\n    );\r\n\r\n    event VersionAudited(string contractName, string versionName);\r\n\r\n    event VersionRecommended(string contractName, string versionName);\r\n\r\n    event RecommendedVersionRemoved(string contractName);\r\n\r\n    /**\r\n    * @dev Indicates the status of the version\r\n    */\r\n    enum Status {BETA, RC, PRODUCTION, DEPRECATED}\r\n\r\n    /**\r\n    * @dev Indicates the highest level of bug found in this version\r\n    */\r\n    enum BugLevel{NONE, LOW, MEDIUM, HIGH, CRITICAL}\r\n\r\n    /**\r\n    * @dev struct to store info about each version\r\n    */\r\n    struct Version {\r\n        string versionName; // ie: \"0.0.1\"\r\n        Status status;\r\n        BugLevel bugLevel;\r\n        address implementation;\r\n        bool audited;\r\n        uint256 timeAdded;\r\n    }\r\n\r\n    /**\r\n    * @dev List of all registered contracts\r\n    */\r\n    string[] internal _contracts;\r\n\r\n    /**\r\n    * @dev To keep track of which contracts have been registered so far\r\n    * to save gas while checking for redundant contracts\r\n    */\r\n    mapping(string => bool) internal _contractExists;\r\n\r\n    /**\r\n    * @dev To keep track of all versions of a given contract\r\n    */\r\n    mapping(string => string[]) internal _contractVsVersionString;\r\n\r\n    /**\r\n    * @dev Mapping of contract name & version name to version struct\r\n    */\r\n    mapping(string => mapping(string => Version)) internal _contractVsVersions;\r\n\r\n    /**\r\n    * @dev Mapping between contract name and the name of its recommended\r\n    * version\r\n    */\r\n    mapping(string => string) internal _contractVsRecommendedVersion;\r\n\r\n    modifier nonZeroAddress(address _address){\r\n        require(_address != address(0), \"The provided address is a 0 address\");\r\n        _;\r\n    }\r\n\r\n    modifier contractRegistered(string contractName) {\r\n\r\n        require(_contractExists[contractName], \"Contract does not exists\");\r\n        _;\r\n    }\r\n\r\n    modifier versionExists(string contractName, string versionName) {\r\n        require(\r\n            _contractVsVersions[contractName][versionName].implementation != address(0),\r\n            \"Version does not exists for contract\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allow owner to add a new version for a contract\r\n    * @param contractName The contract name\r\n    * @param versionName The version name\r\n    * @param status Status of the new version\r\n    * @param implementation The address of the new version\r\n    */\r\n    function addVersion(\r\n        string contractName,\r\n        string versionName,\r\n        Status status,\r\n        address implementation\r\n    )\r\n        external\r\n        onlyOwner\r\n        nonZeroAddress(implementation)\r\n    {\r\n\r\n        //do not allow contract name to be the empty string\r\n        require(\r\n            bytes(contractName).length > 0,\r\n            \"ContractName cannot be empty\"\r\n        );\r\n\r\n        //do not allow empty string as version name\r\n        require(\r\n            bytes(versionName).length > 0,\r\n            \"VersionName cannot be empty\"\r\n        );\r\n\r\n        //implementation must be a contract address\r\n        require(\r\n            Address.isContract(implementation),\r\n            \"Iimplementation cannot be a non-contract address\"\r\n        );\r\n\r\n        //version should not already exist for the contract\r\n        require(\r\n            _contractVsVersions[contractName][versionName].implementation == address(0),\r\n            \"This Version already exists for this contract\"\r\n        );\r\n\r\n        //if this is a new contractName then push it to the contracts[] array\r\n        if (!_contractExists[contractName]) {\r\n            _contracts.push(contractName);\r\n            _contractExists[contractName] = true;\r\n        }\r\n\r\n        _contractVsVersionString[contractName].push(versionName);\r\n\r\n        _contractVsVersions[contractName][versionName] = Version({\r\n            versionName:versionName,\r\n            status:status,\r\n            bugLevel:BugLevel.NONE,\r\n            implementation:implementation,\r\n            audited:false,\r\n            timeAdded:block.timestamp\r\n        });\r\n\r\n        emit VersionAdded(contractName, versionName, implementation);\r\n    }\r\n\r\n    /**\r\n    * @dev Change the status of a version of a contract\r\n    * @param contractName Name of the contract\r\n    * @param versionName Version of the contract\r\n    * @param status Status to be set\r\n    */\r\n    function changeStatus(\r\n        string contractName,\r\n        string versionName,\r\n        Status status\r\n    )\r\n        external\r\n        onlyOwner\r\n        contractRegistered(contractName)\r\n        versionExists(contractName, versionName)\r\n    {\r\n        string storage recommendedVersion = _contractVsRecommendedVersion[\r\n            contractName\r\n        ];\r\n\r\n        //if the recommended version is being marked as DEPRECATED then it will\r\n        //be removed from being recommended\r\n        if (\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    recommendedVersion\r\n                )\r\n            ) == keccak256(\r\n                abi.encodePacked(\r\n                    versionName\r\n                )\r\n            ) && status == Status.DEPRECATED\r\n        )\r\n        {\r\n            removeRecommendedVersion(contractName);\r\n        }\r\n\r\n        _contractVsVersions[contractName][versionName].status = status;\r\n\r\n        emit StatusChanged(contractName, versionName, status);\r\n    }\r\n\r\n    /**\r\n    * @dev Change the bug level for a version of a contract\r\n    * @param contractName Name of the contract\r\n    * @param versionName Version of the contract\r\n    * @param bugLevel New bug level for the contract\r\n    */\r\n    function changeBugLevel(\r\n        string contractName,\r\n        string versionName,\r\n        BugLevel bugLevel\r\n    )\r\n        external\r\n        onlyOwner\r\n        contractRegistered(contractName)\r\n        versionExists(contractName, versionName)\r\n    {\r\n        string storage recommendedVersion = _contractVsRecommendedVersion[\r\n            contractName\r\n        ];\r\n\r\n        //if the recommended version of this contract is being marked as\r\n        // CRITICAL (status level 4) then it will no longer be marked as\r\n        // recommended\r\n        if (\r\n            keccak256(\r\n                abi.encodePacked(\r\n                    recommendedVersion\r\n                )\r\n            ) == keccak256(\r\n                abi.encodePacked(\r\n                    versionName\r\n                )\r\n            ) && bugLevel == BugLevel.CRITICAL\r\n        )\r\n        {\r\n            removeRecommendedVersion(contractName);\r\n        }\r\n\r\n        _contractVsVersions[contractName][versionName].bugLevel = bugLevel;\r\n\r\n        emit BugLevelChanged(contractName, versionName, bugLevel);\r\n    }\r\n\r\n    /**\r\n    * @dev Mark a version of a contract as having been audited\r\n    * @param contractName Name of the contract\r\n    * @param versionName Version of the contract\r\n    */\r\n    function markVersionAudited(\r\n        string contractName,\r\n        string versionName\r\n    )\r\n        external\r\n        contractRegistered(contractName)\r\n        versionExists(contractName, versionName)\r\n        onlyOwner\r\n    {\r\n        //this version should not already be marked audited\r\n        require(\r\n            !_contractVsVersions[contractName][versionName].audited,\r\n            \"Version is already audited\"\r\n        );\r\n\r\n        _contractVsVersions[contractName][versionName].audited = true;\r\n\r\n        emit VersionAudited(contractName, versionName);\r\n    }\r\n\r\n    /**\r\n    * @dev Set recommended version\r\n    * @param contractName Name of the contract\r\n    * @param versionName Version of the contract\r\n    * Version should be in Production stage (status 2) and bug level should\r\n    * not be HIGH or CRITICAL (status level should be less than 3).\r\n    * Version must be marked as audited\r\n    */\r\n    function markRecommendedVersion(\r\n        string contractName,\r\n        string versionName\r\n    )\r\n        external\r\n        onlyOwner\r\n        contractRegistered(contractName)\r\n        versionExists(contractName, versionName)\r\n    {\r\n        //version must be in PRODUCTION state (status 2)\r\n        require(\r\n            _contractVsVersions[contractName][versionName].status == Status.PRODUCTION,\r\n            \"Version is not in PRODUCTION state (status level should be 2)\"\r\n        );\r\n\r\n        //check version must be audited\r\n        require(\r\n            _contractVsVersions[contractName][versionName].audited,\r\n            \"Version is not audited\"\r\n        );\r\n\r\n        //version must have bug level lower than HIGH\r\n        require(\r\n            _contractVsVersions[contractName][versionName].bugLevel < BugLevel.HIGH,\r\n            \"Version bug level is HIGH or CRITICAL (bugLevel should be < 3)\"\r\n        );\r\n\r\n        //mark new version as recommended version for the contract\r\n        _contractVsRecommendedVersion[contractName] = versionName;\r\n\r\n        emit VersionRecommended(contractName, versionName);\r\n    }\r\n\r\n    /**\r\n    * @dev Get the version of the recommended version for a contract.\r\n    * @return Details of recommended version\r\n    */\r\n    function getRecommendedVersion(\r\n        string contractName\r\n    )\r\n        external\r\n        view\r\n        contractRegistered(contractName)\r\n        returns (\r\n            string versionName,\r\n            Status status,\r\n            BugLevel bugLevel,\r\n            address implementation,\r\n            bool audited,\r\n            uint256 timeAdded\r\n        )\r\n    {\r\n        versionName = _contractVsRecommendedVersion[contractName];\r\n\r\n        Version storage recommendedVersion = _contractVsVersions[\r\n            contractName\r\n        ][\r\n            versionName\r\n        ];\r\n\r\n        status = recommendedVersion.status;\r\n        bugLevel = recommendedVersion.bugLevel;\r\n        implementation = recommendedVersion.implementation;\r\n        audited = recommendedVersion.audited;\r\n        timeAdded = recommendedVersion.timeAdded;\r\n\r\n        return (\r\n            versionName,\r\n            status,\r\n            bugLevel,\r\n            implementation,\r\n            audited,\r\n            timeAdded\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Get the total number of contracts registered\r\n    */\r\n    function getTotalContractCount() external view returns (uint256 count) {\r\n        count = _contracts.length;\r\n        return count;\r\n    }\r\n\r\n    /**\r\n    * @dev Get total count of versions for a contract\r\n    * @param contractName Name of the contract\r\n    */\r\n    function getVersionCountForContract(string contractName)\r\n        external\r\n        view\r\n        returns (uint256 count)\r\n    {\r\n        count = _contractVsVersionString[contractName].length;\r\n        return count;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the contract at index\r\n    * @param index The index to be searched for\r\n    */\r\n    function getContractAtIndex(uint256 index)\r\n        external\r\n        view\r\n        returns (string contractName)\r\n    {\r\n        contractName = _contracts[index];\r\n        return contractName;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns versionName of a contract at a specific index\r\n    * @param contractName Name of the contract\r\n    * @param index The index to be searched for\r\n    */\r\n    function getVersionAtIndex(string contractName, uint256 index)\r\n        external\r\n        view\r\n        returns (string versionName)\r\n    {\r\n        versionName = _contractVsVersionString[contractName][index];\r\n        return versionName;\r\n    }\r\n\r\n    /**\r\n    * @dev Returns the version details for the given contract and version\r\n    * @param contractName Name of the contract\r\n    * @param versionName Version string for the contract\r\n    */\r\n    function getVersionDetails(string contractName, string versionName)\r\n        external\r\n        view\r\n        returns (\r\n            string versionString,\r\n            Status status,\r\n            BugLevel bugLevel,\r\n            address implementation,\r\n            bool audited,\r\n            uint256 timeAdded\r\n        )\r\n    {\r\n        Version storage v = _contractVsVersions[contractName][versionName];\r\n\r\n        versionString = v.versionName;\r\n        status = v.status;\r\n        bugLevel = v.bugLevel;\r\n        implementation = v.implementation;\r\n        audited = v.audited;\r\n        timeAdded = v.timeAdded;\r\n\r\n        return (\r\n            versionString,\r\n            status,\r\n            bugLevel,\r\n            implementation,\r\n            audited,\r\n            timeAdded\r\n        );\r\n    }\r\n\r\n    /**\r\n    * @dev Remove the \"recommended\" status of the currently recommended version\r\n    * of a contract (if any)\r\n    * @param contractName Name of the contract\r\n    */\r\n    function removeRecommendedVersion(string contractName)\r\n        public\r\n        onlyOwner\r\n        contractRegistered(contractName)\r\n    {\r\n        //delete it from mapping\r\n        delete _contractVsRecommendedVersion[contractName];\r\n\r\n        emit RecommendedVersionRemoved(contractName);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"versionName\",\"type\":\"string\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"addVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"versionName\",\"type\":\"string\"}],\"name\":\"markVersionAudited\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"versionName\",\"type\":\"string\"},{\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"changeStatus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"versionName\",\"type\":\"string\"},{\"name\":\"bugLevel\",\"type\":\"uint8\"}],\"name\":\"changeBugLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTotalContractCount\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getRecommendedVersion\",\"outputs\":[{\"name\":\"versionName\",\"type\":\"string\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"bugLevel\",\"type\":\"uint8\"},{\"name\":\"implementation\",\"type\":\"address\"},{\"name\":\"audited\",\"type\":\"bool\"},{\"name\":\"timeAdded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"versionName\",\"type\":\"string\"}],\"name\":\"getVersionDetails\",\"outputs\":[{\"name\":\"versionString\",\"type\":\"string\"},{\"name\":\"status\",\"type\":\"uint8\"},{\"name\":\"bugLevel\",\"type\":\"uint8\"},{\"name\":\"implementation\",\"type\":\"address\"},{\"name\":\"audited\",\"type\":\"bool\"},{\"name\":\"timeAdded\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getContractAtIndex\",\"outputs\":[{\"name\":\"contractName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"removeRecommendedVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getVersionAtIndex\",\"outputs\":[{\"name\":\"versionName\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"versionName\",\"type\":\"string\"}],\"name\":\"markRecommendedVersion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getVersionCountForContract\",\"outputs\":[{\"name\":\"count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"versionName\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"implementation\",\"type\":\"address\"}],\"name\":\"VersionAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"versionName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"status\",\"type\":\"uint8\"}],\"name\":\"StatusChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"versionName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"bugLevel\",\"type\":\"uint8\"}],\"name\":\"BugLevelChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"versionName\",\"type\":\"string\"}],\"name\":\"VersionAudited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"versionName\",\"type\":\"string\"}],\"name\":\"VersionRecommended\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"RecommendedVersionRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ContractManager","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://be54d277b43789d0acd782c742dc75bbd2fb00dabf97da5d9511372a6cd18746"}]}