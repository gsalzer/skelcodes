{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n\r\nlibrary BobbySafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract BobbyERC20Base {\r\n\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n\r\n    //是否暂停智能合约的运行\r\n    bool public paused = false;\r\n\r\n    constructor(address cfoAddr) public {\r\n        ceoAddress = msg.sender;\r\n        cfoAddress = cfoAddr;\r\n    }\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) public onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyCEO whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n\r\n    //ERC20指定接口\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    //extend event\r\n    event Grant(address indexed src, address indexed dst, uint wad);    //发放代币，有解禁期\r\n    event Unlock(address indexed user, uint wad);                       //解禁代币\r\n\r\n    function name() public view returns (string n);\r\n    function symbol() public view returns (string s);\r\n    function decimals() public view returns (uint8 d);\r\n    function totalSupply() public view returns (uint256 t);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n}\r\n\r\n//Erc智能合约\r\ncontract ERC20 is ERC20Interface, BobbyERC20Base {\r\n    using BobbySafeMath for uint256;\r\n\r\n    uint private _Thousand = 1000;\r\n    uint private _Billion = _Thousand * _Thousand * _Thousand;\r\n\r\n    //代币基本信息\r\n    string private _name = \"BOBBY\";     //代币名称\r\n    string private _symbol = \"BOBBY\";   //代币标识\r\n    uint8 private _decimals = 9;        //小数点后位数\r\n    uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals));\r\n\r\n    struct LockedToken {\r\n        uint256 total;          // 数量\r\n        uint256 duration;       // 解锁总时长\r\n        uint256 periods;        // 解锁期数\r\n\r\n        uint256 balance;         // 剩余未解锁数量\r\n        uint256 unlockLast;      // 上次解锁时间\r\n    }\r\n\r\n    //解封用户代币结构\r\n    struct UserToken {\r\n        uint index;                     //放在数组中的下标\r\n        address addr;                   //用户账号\r\n        uint256 tokens;                 //通证数量\r\n        LockedToken[] lockedTokens;     //锁定的token\r\n    }\r\n\r\n    mapping(address=>UserToken) private _userMap;           //用户映射\r\n    address[] private _userArray;                           //用户数组,from 1\r\n\r\n    uint32 private actionTransfer = 0;\r\n    uint32 private actionGrant = 1;\r\n    uint32 private actionUnlock = 2;\r\n\r\n    struct LogEntry {\r\n        uint256 time;\r\n        uint32  action;       // 0 转账 1 发放 2 解锁\r\n        address from;\r\n        address to;\r\n        uint256 v1;\r\n        uint256 v2;\r\n        uint256 v3;\r\n    }\r\n\r\n    LogEntry[] private _logs;\r\n\r\n    function _addUser(address addrUser) private returns (UserToken storage) {\r\n        _userMap[addrUser].index = _userArray.length;\r\n        _userMap[addrUser].addr = addrUser;\r\n        _userMap[addrUser].tokens = 0;\r\n        _userArray.push(addrUser);\r\n        return _userMap[addrUser];\r\n    }\r\n\r\n    //构造方法，将代币的初始总供给都分配给合约的部署账户。合约的构造方法只在合约部署时执行一次\r\n    constructor(address cfoAddr) BobbyERC20Base(cfoAddr) public {\r\n\r\n        //placeholder\r\n        _userArray.push(address(0));\r\n\r\n        UserToken storage userCFO = _addUser(cfoAddr);\r\n        userCFO.tokens = _totalSupply;\r\n    }\r\n\r\n    //返回合约名称。view关键子表示函数只查询状态变量，而不写入\r\n    function name() public view returns (string n){\r\n        n = _name;\r\n    }\r\n\r\n    //返回合约标识符\r\n    function symbol() public view returns (string s){\r\n        s = _symbol;\r\n    }\r\n\r\n    //返回合约小数位\r\n    function decimals() public view returns (uint8 d){\r\n        d = _decimals;\r\n    }\r\n\r\n    //返回合约总供给额\r\n    function totalSupply() public view returns (uint256 t){\r\n        t = _totalSupply;\r\n    }\r\n\r\n    //查询账户_owner的账户余额\r\n    function balanceOf(address _owner) public view returns (uint256 balance){\r\n        UserToken storage user = _userMap[_owner];\r\n        if (0 == user.index) {\r\n            balance = 0;\r\n            return;\r\n        }\r\n\r\n        balance = user.tokens;\r\n        for (uint index = 0; index < user.lockedTokens.length; index++) {\r\n            balance = balance.add((user.lockedTokens[index]).balance);\r\n        }\r\n    }\r\n\r\n    function _checkUnlock(address addrUser) private {\r\n        UserToken storage user = _userMap[addrUser];\r\n        if (0 == user.index) {\r\n            return;\r\n        }\r\n\r\n        for (uint index = 0; index < user.lockedTokens.length; index++) {\r\n            LockedToken storage locked = user.lockedTokens[index];\r\n            if(locked.balance <= 0){\r\n                continue;\r\n            }\r\n\r\n            uint256 diff = now.sub(locked.unlockLast);\r\n            uint256 unlockUnit = locked.total.div(locked.periods);\r\n            uint256 periodDuration = locked.duration.div(locked.periods);\r\n            uint256 unlockedPeriods = locked.total.sub(locked.balance).div(unlockUnit);\r\n            uint256 periodsToUnlock = diff.div(periodDuration);\r\n\r\n            if(periodsToUnlock > 0) {\r\n                uint256 tokenToUnlock = 0;\r\n                if(unlockedPeriods + periodsToUnlock >= locked.periods) {\r\n                    tokenToUnlock = locked.balance;\r\n                }else{\r\n                    tokenToUnlock = unlockUnit.mul(periodsToUnlock);\r\n                }\r\n\r\n                if (tokenToUnlock >= locked.balance) {\r\n                    tokenToUnlock = locked.balance;\r\n                }\r\n\r\n                locked.balance = locked.balance.sub(tokenToUnlock);\r\n                user.tokens = user.tokens.add(tokenToUnlock);\r\n                locked.unlockLast = locked.unlockLast.add(periodDuration.mul(periodsToUnlock));\r\n\r\n                emit Unlock(addrUser, tokenToUnlock);\r\n                log(actionUnlock, addrUser, 0, tokenToUnlock, 0, 0);\r\n            }\r\n        }\r\n    }   \r\n\r\n    //从代币合约的调用者地址上转移_value的数量token到的地址_to，并且必须触发Transfer事件\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success){\r\n        require(msg.sender != _to);\r\n\r\n        //检查是否有可以解锁的token\r\n        _checkUnlock(msg.sender);\r\n\r\n        require(_userMap[msg.sender].tokens >= _value);\r\n        _userMap[msg.sender].tokens = _userMap[msg.sender].tokens.sub(_value);\r\n\r\n        UserToken storage userTo = _userMap[_to];\r\n        if(0 == userTo.index){\r\n            userTo = _addUser(_to);\r\n        }\r\n        userTo.tokens = userTo.tokens.add(_value);\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n        log(actionTransfer, msg.sender, _to, _value, 0, 0);\r\n\r\n        success = true;\r\n    }\r\n\r\n    function transferFrom(address, address, uint256) public whenNotPaused returns (bool success){\r\n        success = true;\r\n    }\r\n\r\n    function approve(address, uint256) public whenNotPaused returns (bool success){\r\n        success = true;\r\n    }\r\n\r\n    function allowance(address, address) public view returns (uint256 remaining){\r\n        remaining = 0;\r\n    }\r\n\r\n    function grant(address _to, uint256 _value, uint256 _duration, uint256 _periods) public whenNotPaused returns (bool success){\r\n        require(msg.sender != _to);\r\n\r\n        //检查是否有可以解锁的token\r\n        _checkUnlock(msg.sender);\r\n\r\n        require(_userMap[msg.sender].tokens >= _value);\r\n        _userMap[msg.sender].tokens = _userMap[msg.sender].tokens.sub(_value);\r\n        \r\n        UserToken storage userTo = _userMap[_to];\r\n        if(0 == userTo.index){\r\n            userTo = _addUser(_to);\r\n        }\r\n\r\n        LockedToken memory locked;\r\n        locked.total = _value;\r\n        locked.duration = _duration.mul(30 days);\r\n        // locked.duration = _duration.mul(1 minutes); //for test\r\n        locked.periods = _periods;\r\n        locked.balance = _value;\r\n        locked.unlockLast = now;\r\n        userTo.lockedTokens.push(locked);\r\n\r\n        emit Grant(msg.sender, _to, _value);\r\n        log(actionGrant, msg.sender, _to, _value, _duration, _periods);\r\n\r\n        success = true;\r\n    }\r\n\r\n    function getUserAddr(uint256 _index) public view returns(address addr){\r\n        require(_index < _userArray.length);\r\n        addr = _userArray[_index];\r\n    }\r\n\r\n    function getUserSize() public view returns(uint256 size){\r\n        size = _userArray.length;\r\n    }\r\n\r\n\r\n    function getLockSize(address addr) public view returns (uint256 len) {\r\n        UserToken storage user = _userMap[addr];\r\n        len = user.lockedTokens.length;\r\n    }\r\n\r\n    function getLock(address addr, uint256 index) public view returns (uint256 total, uint256 duration, uint256 periods, uint256 balance, uint256 unlockLast) {\r\n        UserToken storage user = _userMap[addr];\r\n        require(index < user.lockedTokens.length);\r\n        total = user.lockedTokens[index].total;\r\n        duration = user.lockedTokens[index].duration;\r\n        periods = user.lockedTokens[index].periods;\r\n        balance = user.lockedTokens[index].balance;\r\n        unlockLast = user.lockedTokens[index].unlockLast;\r\n    }\r\n\r\n    function getLockInfo(address addr) public view returns (uint256[] totals, uint256[] durations, uint256[] periodses, uint256[] balances, uint256[] unlockLasts) {\r\n        UserToken storage user = _userMap[addr];\r\n        uint256 len = user.lockedTokens.length;\r\n        totals = new uint256[](len);\r\n        durations = new uint256[](len);\r\n        periodses = new uint256[](len);\r\n        balances = new uint256[](len);\r\n        unlockLasts = new uint256[](len);\r\n        for (uint index = 0; index < user.lockedTokens.length; index++) {\r\n            totals[index] = user.lockedTokens[index].total;\r\n            durations[index] = user.lockedTokens[index].duration;\r\n            periodses[index] = user.lockedTokens[index].periods;\r\n            balances[index] = user.lockedTokens[index].balance;\r\n            unlockLasts[index] = user.lockedTokens[index].unlockLast;\r\n        }\r\n    }\r\n\r\n    function log(uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3) private {\r\n        LogEntry memory entry;\r\n        entry.action = action;\r\n        entry.time = now;\r\n        entry.from = from;\r\n        entry.to = to;\r\n        entry.v1 = _v1;\r\n        entry.v2 = _v2;\r\n        entry.v3 = _v3;\r\n        _logs.push(entry);\r\n    }\r\n\r\n    function getLogSize() public view returns(uint256 size){\r\n        size = _logs.length;\r\n    }\r\n\r\n    function getLog(uint256 _index) public view returns(uint time, uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3){\r\n        require(_index < _logs.length);\r\n        require(_index >= 0);\r\n        LogEntry storage entry = _logs[_index];\r\n        action = entry.action;\r\n        time = entry.time;\r\n        from = entry.from;\r\n        to = entry.to;\r\n        _v1 = entry.v1;\r\n        _v2 = entry.v2;\r\n        _v3 = entry.v3;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"n\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLogSize\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getLock\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"periods\",\"type\":\"uint256\"},{\"name\":\"balance\",\"type\":\"uint256\"},{\"name\":\"unlockLast\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getUserAddr\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"d\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLog\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"action\",\"type\":\"uint32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"_v1\",\"type\":\"uint256\"},{\"name\":\"_v2\",\"type\":\"uint256\"},{\"name\":\"_v3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getLockSize\",\"outputs\":[{\"name\":\"len\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getLockInfo\",\"outputs\":[{\"name\":\"totals\",\"type\":\"uint256[]\"},{\"name\":\"durations\",\"type\":\"uint256[]\"},{\"name\":\"periodses\",\"type\":\"uint256[]\"},{\"name\":\"balances\",\"type\":\"uint256[]\"},{\"name\":\"unlockLasts\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"s\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getUserSize\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_periods\",\"type\":\"uint256\"}],\"name\":\"grant\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"cfoAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Grant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"}]","ContractName":"ERC20","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004d60fec50c4dfda6bbc2f047e7f9c3795bede95f","Library":"","SwarmSource":"bzzr://36e41aaa652eadca7eaf6c7aff95bd9f7b0f585f0aeea36c1dca70f67e77afdd"}]}