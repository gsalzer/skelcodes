{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/// @title provides subject to role checking logic\r\ncontract IAccessPolicy {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice We don't make this function constant to allow for state-updating access controls such as rate limiting.\r\n    /// @dev checks if subject belongs to requested role for particular object\r\n    /// @param subject address to be checked against role, typically msg.sender\r\n    /// @param role identifier of required role\r\n    /// @param object contract instance context for role checking, typically contract requesting the check\r\n    /// @param verb additional data, in current AccessControll implementation msg.sig\r\n    /// @return if subject belongs to a role\r\n    function allowed(\r\n        address subject,\r\n        bytes32 role,\r\n        address object,\r\n        bytes4 verb\r\n    )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n/// @title enables access control in implementing contract\r\n/// @dev see AccessControlled for implementation\r\ncontract IAccessControlled {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// @dev must log on access policy change\r\n    event LogAccessPolicyChanged(\r\n        address controller,\r\n        IAccessPolicy oldPolicy,\r\n        IAccessPolicy newPolicy\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev allows to change access control mechanism for this contract\r\n    ///     this method must be itself access controlled, see AccessControlled implementation and notice below\r\n    /// @notice it is a huge issue for Solidity that modifiers are not part of function signature\r\n    ///     then interfaces could be used for example to control access semantics\r\n    /// @param newPolicy new access policy to controll this contract\r\n    /// @param newAccessController address of ROLE_ACCESS_CONTROLLER of new policy that can set access to this contract\r\n    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\r\n        public;\r\n\r\n    function accessPolicy()\r\n        public\r\n        constant\r\n        returns (IAccessPolicy);\r\n\r\n}\r\n\r\ncontract StandardRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // @notice Soldity somehow doesn't evaluate this compile time\r\n    // @dev role which has rights to change permissions and set new policy in contract, keccak256(\"AccessController\")\r\n    bytes32 internal constant ROLE_ACCESS_CONTROLLER = 0xac42f8beb17975ed062dcb80c63e6d203ef1c2c335ced149dc5664cc671cb7da;\r\n}\r\n\r\n/// @title Granular code execution permissions\r\n/// @notice Intended to replace existing Ownable pattern with more granular permissions set to execute smart contract functions\r\n///     for each function where 'only' modifier is applied, IAccessPolicy implementation is called to evaluate if msg.sender belongs to required role for contract being called.\r\n///     Access evaluation specific belong to IAccessPolicy implementation, see RoleBasedAccessPolicy for details.\r\n/// @dev Should be inherited by a contract requiring such permissions controll. IAccessPolicy must be provided in constructor. Access policy may be replaced to a different one\r\n///     by msg.sender with ROLE_ACCESS_CONTROLLER role\r\ncontract AccessControlled is IAccessControlled, StandardRoles {\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    IAccessPolicy private _accessPolicy;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    /// @dev limits function execution only to senders assigned to required 'role'\r\n    modifier only(bytes32 role) {\r\n        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(IAccessPolicy policy) internal {\r\n        require(address(policy) != 0x0);\r\n        _accessPolicy = policy;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements IAccessControlled\r\n    //\r\n\r\n    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\r\n        public\r\n        only(ROLE_ACCESS_CONTROLLER)\r\n    {\r\n        // ROLE_ACCESS_CONTROLLER must be present\r\n        // under the new policy. This provides some\r\n        // protection against locking yourself out.\r\n        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));\r\n\r\n        // We can now safely set the new policy without foot shooting.\r\n        IAccessPolicy oldPolicy = _accessPolicy;\r\n        _accessPolicy = newPolicy;\r\n\r\n        // Log event\r\n        emit LogAccessPolicyChanged(msg.sender, oldPolicy, newPolicy);\r\n    }\r\n\r\n    function accessPolicy()\r\n        public\r\n        constant\r\n        returns (IAccessPolicy)\r\n    {\r\n        return _accessPolicy;\r\n    }\r\n}\r\n\r\n/// @title standard access roles of the Platform\r\n/// @dev constants are kept in CODE not in STORAGE so they are comparatively cheap\r\ncontract AccessRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // NOTE: All roles are set to the keccak256 hash of the\r\n    // CamelCased role name, i.e.\r\n    // ROLE_LOCKED_ACCOUNT_ADMIN = keccak256(\"LockedAccountAdmin\")\r\n\r\n    // May issue (generate) Neumarks\r\n    bytes32 internal constant ROLE_NEUMARK_ISSUER = 0x921c3afa1f1fff707a785f953a1e197bd28c9c50e300424e015953cbf120c06c;\r\n\r\n    // May burn Neumarks it owns\r\n    bytes32 internal constant ROLE_NEUMARK_BURNER = 0x19ce331285f41739cd3362a3ec176edffe014311c0f8075834fdd19d6718e69f;\r\n\r\n    // May create new snapshots on Neumark\r\n    bytes32 internal constant ROLE_SNAPSHOT_CREATOR = 0x08c1785afc57f933523bc52583a72ce9e19b2241354e04dd86f41f887e3d8174;\r\n\r\n    // May enable/disable transfers on Neumark\r\n    bytes32 internal constant ROLE_TRANSFER_ADMIN = 0xb6527e944caca3d151b1f94e49ac5e223142694860743e66164720e034ec9b19;\r\n\r\n    // may reclaim tokens/ether from contracts supporting IReclaimable interface\r\n    bytes32 internal constant ROLE_RECLAIMER = 0x0542bbd0c672578966dcc525b30aa16723bb042675554ac5b0362f86b6e97dc5;\r\n\r\n    // represents legally platform operator in case of forks and contracts with legal agreement attached. keccak256(\"PlatformOperatorRepresentative\")\r\n    bytes32 internal constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = 0xb2b321377653f655206f71514ff9f150d0822d062a5abcf220d549e1da7999f0;\r\n\r\n    // allows to deposit EUR-T and allow addresses to send and receive EUR-T. keccak256(\"EurtDepositManager\")\r\n    bytes32 internal constant ROLE_EURT_DEPOSIT_MANAGER = 0x7c8ecdcba80ce87848d16ad77ef57cc196c208fc95c5638e4a48c681a34d4fe7;\r\n\r\n    // allows to register identities and change associated claims keccak256(\"IdentityManager\")\r\n    bytes32 internal constant ROLE_IDENTITY_MANAGER = 0x32964e6bc50f2aaab2094a1d311be8bda920fc4fb32b2fb054917bdb153a9e9e;\r\n\r\n    // allows to replace controller on euro token and to destroy tokens without withdraw kecckak256(\"EurtLegalManager\")\r\n    bytes32 internal constant ROLE_EURT_LEGAL_MANAGER = 0x4eb6b5806954a48eb5659c9e3982d5e75bfb2913f55199877d877f157bcc5a9b;\r\n\r\n    // allows to change known interfaces in universe kecckak256(\"UniverseManager\")\r\n    bytes32 internal constant ROLE_UNIVERSE_MANAGER = 0xe8d8f8f9ea4b19a5a4368dbdace17ad71a69aadeb6250e54c7b4c7b446301738;\r\n\r\n    // allows to exchange gas for EUR-T keccak(\"GasExchange\")\r\n    bytes32 internal constant ROLE_GAS_EXCHANGE = 0x9fe43636e0675246c99e96d7abf9f858f518b9442c35166d87f0934abef8a969;\r\n\r\n    // allows to set token exchange rates keccak(\"TokenRateOracle\")\r\n    bytes32 internal constant ROLE_TOKEN_RATE_ORACLE = 0xa80c3a0c8a5324136e4c806a778583a2a980f378bdd382921b8d28dcfe965585;\r\n}\r\n\r\ncontract IEthereumForkArbiter {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogForkAnnounced(\r\n        string name,\r\n        string url,\r\n        uint256 blockNumber\r\n    );\r\n\r\n    event LogForkSigned(\r\n        uint256 blockNumber,\r\n        bytes32 blockHash\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function nextForkName()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function nextForkUrl()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function nextForkBlockNumber()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    function lastSignedBlockNumber()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    function lastSignedBlockHash()\r\n        public\r\n        constant\r\n        returns (bytes32);\r\n\r\n    function lastSignedTimestamp()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n}\r\n\r\n/**\r\n * @title legally binding smart contract\r\n * @dev General approach to paring legal and smart contracts:\r\n * 1. All terms and agreement are between two parties: here between smart conctract legal representation and platform investor.\r\n * 2. Parties are represented by public Ethereum addresses. Platform investor is and address that holds and controls funds and receives and controls Neumark token\r\n * 3. Legal agreement has immutable part that corresponds to smart contract code and mutable part that may change for example due to changing regulations or other externalities that smart contract does not control.\r\n * 4. There should be a provision in legal document that future changes in mutable part cannot change terms of immutable part.\r\n * 5. Immutable part links to corresponding smart contract via its address.\r\n * 6. Additional provision should be added if smart contract supports it\r\n *  a. Fork provision\r\n *  b. Bugfixing provision (unilateral code update mechanism)\r\n *  c. Migration provision (bilateral code update mechanism)\r\n *\r\n * Details on Agreement base class:\r\n * 1. We bind smart contract to legal contract by storing uri (preferably ipfs or hash) of the legal contract in the smart contract. It is however crucial that such binding is done by smart contract legal representation so transaction establishing the link must be signed by respective wallet ('amendAgreement')\r\n * 2. Mutable part of agreement may change. We should be able to amend the uri later. Previous amendments should not be lost and should be retrievable (`amendAgreement` and 'pastAgreement' functions).\r\n * 3. It is up to deriving contract to decide where to put 'acceptAgreement' modifier. However situation where there is no cryptographic proof that given address was really acting in the transaction should be avoided, simplest example being 'to' address in `transfer` function of ERC20.\r\n *\r\n**/\r\ncontract IAgreement {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogAgreementAccepted(\r\n        address indexed accepter\r\n    );\r\n\r\n    event LogAgreementAmended(\r\n        address contractLegalRepresentative,\r\n        string agreementUri\r\n    );\r\n\r\n    /// @dev should have access restrictions so only contractLegalRepresentative may call\r\n    function amendAgreement(string agreementUri) public;\r\n\r\n    /// returns information on last amendment of the agreement\r\n    /// @dev MUST revert if no agreements were set\r\n    function currentAgreement()\r\n        public\r\n        constant\r\n        returns\r\n        (\r\n            address contractLegalRepresentative,\r\n            uint256 signedBlockTimestamp,\r\n            string agreementUri,\r\n            uint256 index\r\n        );\r\n\r\n    /// returns information on amendment with index\r\n    /// @dev MAY revert on non existing amendment, indexing starts from 0\r\n    function pastAgreement(uint256 amendmentIndex)\r\n        public\r\n        constant\r\n        returns\r\n        (\r\n            address contractLegalRepresentative,\r\n            uint256 signedBlockTimestamp,\r\n            string agreementUri,\r\n            uint256 index\r\n        );\r\n\r\n    /// returns the number of block at wchich `signatory` signed agreement\r\n    /// @dev MUST return 0 if not signed\r\n    function agreementSignedAtBlock(address signatory)\r\n        public\r\n        constant\r\n        returns (uint256 blockNo);\r\n\r\n    /// returns number of amendments made by contractLegalRepresentative\r\n    function amendmentsCount()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n}\r\n\r\n/**\r\n * @title legally binding smart contract\r\n * @dev read IAgreement for details\r\n**/\r\ncontract Agreement is\r\n    IAgreement,\r\n    AccessControlled,\r\n    AccessRoles\r\n{\r\n\r\n    ////////////////////////\r\n    // Type declarations\r\n    ////////////////////////\r\n\r\n    /// @notice agreement with signature of the platform operator representative\r\n    struct SignedAgreement {\r\n        address contractLegalRepresentative;\r\n        uint256 signedBlockTimestamp;\r\n        string agreementUri;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    IEthereumForkArbiter private ETHEREUM_FORK_ARBITER;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // stores all amendments to the agreement, first amendment is the original\r\n    SignedAgreement[] private _amendments;\r\n\r\n    // stores block numbers of all addresses that signed the agreement (signatory => block number)\r\n    mapping(address => uint256) private _signatories;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    /// @notice logs that agreement was accepted by platform user\r\n    /// @dev intended to be added to functions that if used make 'accepter' origin to enter legally binding agreement\r\n    modifier acceptAgreement(address accepter) {\r\n        acceptAgreementInternal(accepter);\r\n        _;\r\n    }\r\n\r\n    modifier onlyLegalRepresentative(address legalRepresentative) {\r\n        require(mCanAmend(legalRepresentative));\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(IAccessPolicy accessPolicy, IEthereumForkArbiter forkArbiter)\r\n        AccessControlled(accessPolicy)\r\n        internal\r\n    {\r\n        require(forkArbiter != IEthereumForkArbiter(0x0));\r\n        ETHEREUM_FORK_ARBITER = forkArbiter;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function amendAgreement(string agreementUri)\r\n        public\r\n        onlyLegalRepresentative(msg.sender)\r\n    {\r\n        SignedAgreement memory amendment = SignedAgreement({\r\n            contractLegalRepresentative: msg.sender,\r\n            signedBlockTimestamp: block.timestamp,\r\n            agreementUri: agreementUri\r\n        });\r\n        _amendments.push(amendment);\r\n        emit LogAgreementAmended(msg.sender, agreementUri);\r\n    }\r\n\r\n    function ethereumForkArbiter()\r\n        public\r\n        constant\r\n        returns (IEthereumForkArbiter)\r\n    {\r\n        return ETHEREUM_FORK_ARBITER;\r\n    }\r\n\r\n    function currentAgreement()\r\n        public\r\n        constant\r\n        returns\r\n        (\r\n            address contractLegalRepresentative,\r\n            uint256 signedBlockTimestamp,\r\n            string agreementUri,\r\n            uint256 index\r\n        )\r\n    {\r\n        require(_amendments.length > 0);\r\n        uint256 last = _amendments.length - 1;\r\n        SignedAgreement storage amendment = _amendments[last];\r\n        return (\r\n            amendment.contractLegalRepresentative,\r\n            amendment.signedBlockTimestamp,\r\n            amendment.agreementUri,\r\n            last\r\n        );\r\n    }\r\n\r\n    function pastAgreement(uint256 amendmentIndex)\r\n        public\r\n        constant\r\n        returns\r\n        (\r\n            address contractLegalRepresentative,\r\n            uint256 signedBlockTimestamp,\r\n            string agreementUri,\r\n            uint256 index\r\n        )\r\n    {\r\n        SignedAgreement storage amendment = _amendments[amendmentIndex];\r\n        return (\r\n            amendment.contractLegalRepresentative,\r\n            amendment.signedBlockTimestamp,\r\n            amendment.agreementUri,\r\n            amendmentIndex\r\n        );\r\n    }\r\n\r\n    function agreementSignedAtBlock(address signatory)\r\n        public\r\n        constant\r\n        returns (uint256 blockNo)\r\n    {\r\n        return _signatories[signatory];\r\n    }\r\n\r\n    function amendmentsCount()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _amendments.length;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// provides direct access to derived contract\r\n    function acceptAgreementInternal(address accepter)\r\n        internal\r\n    {\r\n        if(_signatories[accepter] == 0) {\r\n            require(_amendments.length > 0);\r\n            _signatories[accepter] = block.number;\r\n            emit LogAgreementAccepted(accepter);\r\n        }\r\n    }\r\n\r\n    //\r\n    // MAgreement Internal interface (todo: extract)\r\n    //\r\n\r\n    /// default amend permission goes to ROLE_PLATFORM_OPERATOR_REPRESENTATIVE\r\n    function mCanAmend(address legalRepresentative)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return accessPolicy().allowed(legalRepresentative, ROLE_PLATFORM_OPERATOR_REPRESENTATIVE, this, msg.sig);\r\n    }\r\n}\r\n\r\ncontract IsContract {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function isContract(address addr)\r\n        internal\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint256 size;\r\n        // takes 700 gas\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\ncontract ITokenMetadata {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function symbol()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function name()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function decimals()\r\n        public\r\n        constant\r\n        returns (uint8);\r\n}\r\n\r\n/// @title adds token metadata to token contract\r\n/// @dev see Neumark for example implementation\r\ncontract TokenMetadata is ITokenMetadata {\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // The Token's name: e.g. DigixDAO Tokens\r\n    string private NAME;\r\n\r\n    // An identifier: e.g. REP\r\n    string private SYMBOL;\r\n\r\n    // Number of decimals of the smallest unit\r\n    uint8 private DECIMALS;\r\n\r\n    // An arbitrary versioning scheme\r\n    string private VERSION;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @notice Constructor to set metadata\r\n    /// @param tokenName Name of the new token\r\n    /// @param decimalUnits Number of decimals of the new token\r\n    /// @param tokenSymbol Token Symbol for the new token\r\n    /// @param version Token version ie. when cloning is used\r\n    constructor(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        string version\r\n    )\r\n        public\r\n    {\r\n        NAME = tokenName;                                 // Set the name\r\n        SYMBOL = tokenSymbol;                             // Set the symbol\r\n        DECIMALS = decimalUnits;                          // Set the decimals\r\n        VERSION = version;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function name()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return NAME;\r\n    }\r\n\r\n    function symbol()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return SYMBOL;\r\n    }\r\n\r\n    function decimals()\r\n        public\r\n        constant\r\n        returns (uint8)\r\n    {\r\n        return DECIMALS;\r\n    }\r\n\r\n    function version()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return VERSION;\r\n    }\r\n}\r\n\r\ncontract IBasicToken {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    /// @param owner The address that's balance is being requested\r\n    /// @return The balance of `owner` at the current block\r\n    function balanceOf(address owner)\r\n        public\r\n        constant\r\n        returns (uint256 balance);\r\n\r\n    /// @notice Send `amount` tokens to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC20Allowance {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param owner The address of the account that owns the token\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of owner that spender is allowed\r\n    ///  to spend\r\n    function allowance(address owner, address spender)\r\n        public\r\n        constant\r\n        returns (uint256 remaining);\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n    /// @notice Send `amount` tokens to `to` from `from` on the condition it\r\n    ///  is approved by `from`\r\n    /// @param from The address holding the tokens being transferred\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address from, address to, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC20Token is IBasicToken, IERC20Allowance {\r\n\r\n}\r\n\r\ncontract IERC677Callback {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // NOTE: This call can be initiated by anyone. You need to make sure that\r\n    // it is send by the token (`require(msg.sender == token)`) or make sure\r\n    // amount is valid (`require(token.allowance(this) >= amount)`).\r\n    function receiveApproval(\r\n        address from,\r\n        uint256 amount,\r\n        address token, // IERC667Token\r\n        bytes data\r\n    )\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC677Allowance is IERC20Allowance {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice `msg.sender` approves `spender` to send `amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param spender The address of the contract able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address spender, uint256 amount, bytes extraData)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC677Token is IERC20Token, IERC677Allowance {\r\n}\r\n\r\ncontract Math {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    // absolute difference: |v1 - v2|\r\n    function absDiff(uint256 v1, uint256 v2)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return v1 > v2 ? v1 - v2 : v2 - v1;\r\n    }\r\n\r\n    // divide v by d, round up if remainder is 0.5 or more\r\n    function divRound(uint256 v, uint256 d)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return add(v, d/2) / d;\r\n    }\r\n\r\n    // computes decimal decimalFraction 'frac' of 'amount' with maximum precision (multiplication first)\r\n    // both amount and decimalFraction must have 18 decimals precision, frac 10**18 represents a whole (100% of) amount\r\n    // mind loss of precision as decimal fractions do not have finite binary expansion\r\n    // do not use instead of division\r\n    function decimalFraction(uint256 amount, uint256 frac)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // it's like 1 ether is 100% proportion\r\n        return proportion(amount, frac, 10**18);\r\n    }\r\n\r\n    // computes part/total of amount with maximum precision (multiplication first)\r\n    // part and total must have the same units\r\n    function proportion(uint256 amount, uint256 part, uint256 total)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return divRound(mul(amount, part), total);\r\n    }\r\n\r\n    //\r\n    // Open Zeppelin Math library below\r\n    //\r\n\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n/// @title internal token transfer function\r\n/// @dev see BasicSnapshotToken for implementation\r\ncontract MTokenTransfer {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param from The address holding the tokens being transferred\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @dev  reverts if transfer was not successful\r\n    function mTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal;\r\n}\r\n\r\n/// @title controls token transfers\r\n/// @dev BasicSnapshotToken observes this interface, Neumark contract implements it\r\ncontract MTokenTransferController {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param from The origin of the transfer\r\n    /// @param to The destination of the transfer\r\n    /// @param amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function mOnTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (bool allow);\r\n\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is\r\n    MTokenTransfer,\r\n    MTokenTransferController,\r\n    IBasicToken,\r\n    Math\r\n{\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    uint256 internal _totalSupply;\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        mTransfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner)\r\n        public\r\n        constant\r\n        returns (uint256 balance)\r\n    {\r\n        return _balances[owner];\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements MTokenTransfer\r\n    //\r\n\r\n    function mTransfer(address from, address to, uint256 amount)\r\n        internal\r\n    {\r\n        require(to != address(0));\r\n        require(mOnTransfer(from, to, amount));\r\n\r\n        _balances[from] = sub(_balances[from], amount);\r\n        _balances[to] = add(_balances[to], amount);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n}\r\n\r\n/// @title controls spending approvals\r\n/// @dev TokenAllowance observes this interface, Neumark contract implements it\r\ncontract MTokenAllowanceController {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param owner The address that calls `approve()`\r\n    /// @param spender The spender in the `approve()` call\r\n    /// @param amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function mOnApprove(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (bool allow);\r\n\r\n    /// @notice Allows to override allowance approved by the owner\r\n    ///         Primary role is to enable forced transfers, do not override if you do not like it\r\n    ///         Following behavior is expected in the observer\r\n    ///         approve() - should revert if mAllowanceOverride() > 0\r\n    ///         allowance() - should return mAllowanceOverride() if set\r\n    ///         transferFrom() - should override allowance if mAllowanceOverride() > 0\r\n    /// @param owner An address giving allowance to spender\r\n    /// @param spender An address getting  a right to transfer allowance amount from the owner\r\n    /// @return current allowance amount\r\n    function mAllowanceOverride(\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint256 allowance);\r\n}\r\n\r\n/// @title token spending approval and transfer\r\n/// @dev implements token approval and transfers and exposes relevant part of ERC20 and ERC677 approveAndCall\r\n///     may be mixed in with any basic token (implementing mTransfer) like BasicSnapshotToken or MintableSnapshotToken to add approval mechanism\r\n///     observes MTokenAllowanceController interface\r\n///     observes MTokenTransfer\r\ncontract TokenAllowance is\r\n    MTokenTransfer,\r\n    MTokenAllowanceController,\r\n    IERC20Allowance,\r\n    IERC677Token\r\n{\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // `allowed` tracks rights to spends others tokens as per ERC20\r\n    // owner => spender => amount\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor()\r\n        internal\r\n    {\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements IERC20Token\r\n    //\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param owner The address of the account that owns the token\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address owner, address spender)\r\n        public\r\n        constant\r\n        returns (uint256 remaining)\r\n    {\r\n        uint256 override = mAllowanceOverride(owner, spender);\r\n        if (override > 0) {\r\n            return override;\r\n        }\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  where allowance per spender must be 0 to allow change of such allowance\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True or reverts, False is never returned\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Alerts the token controller of the approve function call\r\n        require(mOnApprove(msg.sender, spender, amount));\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((amount == 0 || _allowed[msg.sender][spender] == 0) && mAllowanceOverride(msg.sender, spender) == 0);\r\n\r\n        _allowed[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param from The address holding the tokens being transferred\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful, reverts in any other case\r\n    function transferFrom(address from, address to, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint256 allowed = mAllowanceOverride(from, msg.sender);\r\n        if (allowed == 0) {\r\n            // The standard ERC 20 transferFrom functionality\r\n            allowed = _allowed[from][msg.sender];\r\n            // yes this will underflow but then we'll revert. will cost gas however so don't underflow\r\n            _allowed[from][msg.sender] -= amount;\r\n        }\r\n        require(allowed >= amount);\r\n        mTransfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Implements IERC677Token\r\n    //\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param spender The address of the contract able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True or reverts, False is never returned\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 amount,\r\n        bytes extraData\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(approve(spender, amount));\r\n\r\n        success = IERC677Callback(spender).receiveApproval(\r\n            msg.sender,\r\n            amount,\r\n            this,\r\n            extraData\r\n        );\r\n        require(success);\r\n\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements default MTokenAllowanceController\r\n    //\r\n\r\n    // no override in default implementation\r\n    function mAllowanceOverride(\r\n        address /*owner*/,\r\n        address /*spender*/\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is\r\n    IERC20Token,\r\n    BasicToken,\r\n    TokenAllowance\r\n{\r\n\r\n}\r\n\r\n/// @title uniquely identifies deployable (non-abstract) platform contract\r\n/// @notice cheap way of assigning implementations to knownInterfaces which represent system services\r\n///         unfortunatelly ERC165 does not include full public interface (ABI) and does not provide way to list implemented interfaces\r\n///         EIP820 still in the making\r\n/// @dev ids are generated as follows keccak256(\"neufund-platform:<contract name>\")\r\n///      ids roughly correspond to ABIs\r\ncontract IContractId {\r\n    /// @param id defined as above\r\n    /// @param version implementation version\r\n    function contractId() public pure returns (bytes32 id, uint256 version);\r\n}\r\n\r\n/// @title current ERC223 fallback function\r\n/// @dev to be used in all future token contract\r\n/// @dev NEU and ICBMEtherToken (obsolete) are the only contracts that still uses IERC223LegacyCallback\r\ncontract IERC223Callback {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function tokenFallback(address from, uint256 amount, bytes data)\r\n        public;\r\n\r\n}\r\n\r\ncontract IERC223Token is IERC20Token, ITokenMetadata {\r\n\r\n    /// @dev Departure: We do not log data, it has no advantage over a standard\r\n    ///     log event. By sticking to the standard log event we\r\n    ///     stay compatible with constracts that expect and ERC20 token.\r\n\r\n    // event Transfer(\r\n    //    address indexed from,\r\n    //    address indexed to,\r\n    //    uint256 amount,\r\n    //    bytes data);\r\n\r\n\r\n    /// @dev Departure: We do not use the callback on regular transfer calls to\r\n    ///     stay compatible with constracts that expect and ERC20 token.\r\n\r\n    // function transfer(address to, uint256 amount)\r\n    //     public\r\n    //     returns (bool);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function transfer(address to, uint256 amount, bytes data)\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n/// @title granular token controller based on MSnapshotToken observer pattern\r\ncontract ITokenController {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice see MTokenTransferController\r\n    /// @dev additionally passes broker that is executing transaction between from and to\r\n    ///      for unbrokered transfer, broker == from\r\n    function onTransfer(address broker, address from, address to, uint256 amount)\r\n        public\r\n        constant\r\n        returns (bool allow);\r\n\r\n    /// @notice see MTokenAllowanceController\r\n    function onApprove(address owner, address spender, uint256 amount)\r\n        public\r\n        constant\r\n        returns (bool allow);\r\n\r\n    /// @notice see MTokenMint\r\n    function onGenerateTokens(address sender, address owner, uint256 amount)\r\n        public\r\n        constant\r\n        returns (bool allow);\r\n\r\n    /// @notice see MTokenMint\r\n    function onDestroyTokens(address sender, address owner, uint256 amount)\r\n        public\r\n        constant\r\n        returns (bool allow);\r\n\r\n    /// @notice controls if sender can change controller to newController\r\n    /// @dev for this to succeed TYPICALLY current controller must be already migrated to a new one\r\n    function onChangeTokenController(address sender, address newController)\r\n        public\r\n        constant\r\n        returns (bool);\r\n\r\n    /// @notice overrides spender allowance\r\n    /// @dev may be used to implemented forced transfers in which token controller may override approved allowance\r\n    ///      with any > 0 value and then use transferFrom to execute such transfer\r\n    ///      This by definition creates non-trustless token so do not implement this call if you do not need trustless transfers!\r\n    ///      Implementer should not allow approve() to be executed if there is an overrride\r\n    //       Implemented should return allowance() taking into account override\r\n    function onAllowance(address owner, address spender)\r\n        public\r\n        constant\r\n        returns (uint256 allowanceOverride);\r\n}\r\n\r\n/// @title hooks token controller to token contract and allows to replace it\r\ncontract ITokenControllerHook {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogChangeTokenController(\r\n        address oldController,\r\n        address newController,\r\n        address by\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice replace current token controller\r\n    /// @dev please note that this process is also controlled by existing controller\r\n    function changeTokenController(address newController)\r\n        public;\r\n\r\n    /// @notice returns current controller\r\n    function tokenController()\r\n        public\r\n        constant\r\n        returns (address currentController);\r\n\r\n}\r\n\r\ncontract IWithdrawableToken {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice withdraws from a token holding assets\r\n    /// @dev amount of asset should be returned to msg.sender and corresponding balance burned\r\n    function withdraw(uint256 amount)\r\n        public;\r\n}\r\n\r\ncontract EuroToken is\r\n    Agreement,\r\n    IERC677Token,\r\n    StandardToken,\r\n    IWithdrawableToken,\r\n    ITokenControllerHook,\r\n    TokenMetadata,\r\n    IERC223Token,\r\n    IsContract,\r\n    IContractId\r\n{\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    string private constant NAME = \"Euro Token\";\r\n\r\n    string private constant SYMBOL = \"EUR-T\";\r\n\r\n    uint8 private constant DECIMALS = 18;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    ITokenController private _tokenController;\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// on each deposit (increase of supply) of EUR-T\r\n    /// 'by' indicates account that executed the deposit function for 'to' (typically bank connector)\r\n    event LogDeposit(\r\n        address indexed to,\r\n        address by,\r\n        uint256 amount,\r\n        bytes32 reference\r\n    );\r\n\r\n    // proof of requested deposit initiated by token holder\r\n    event LogWithdrawal(\r\n        address indexed from,\r\n        uint256 amount\r\n    );\r\n\r\n    // proof of settled deposit\r\n    event LogWithdrawSettled(\r\n        address from,\r\n        address by, // who settled\r\n        uint256 amount, // settled amount, after fees, negative interest rates etc.\r\n        uint256 originalAmount, // original amount withdrawn\r\n        bytes32 withdrawTxHash, // hash of withdraw transaction\r\n        bytes32 reference // reference number of withdraw operation at deposit manager\r\n    );\r\n\r\n    /// on destroying the tokens without withdraw (see `destroyTokens` function below)\r\n    event LogDestroy(\r\n        address indexed from,\r\n        address by,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    modifier onlyIfDepositAllowed(address to, uint256 amount) {\r\n        require(_tokenController.onGenerateTokens(msg.sender, to, amount));\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfWithdrawAllowed(address from, uint256 amount) {\r\n        require(_tokenController.onDestroyTokens(msg.sender, from, amount));\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        IAccessPolicy accessPolicy,\r\n        IEthereumForkArbiter forkArbiter,\r\n        ITokenController tokenController\r\n    )\r\n        Agreement(accessPolicy, forkArbiter)\r\n        StandardToken()\r\n        TokenMetadata(NAME, DECIMALS, SYMBOL, \"\")\r\n        public\r\n    {\r\n        require(tokenController != ITokenController(0x0));\r\n        _tokenController = tokenController;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice deposit 'amount' of EUR-T to address 'to', attaching correlating `reference` to LogDeposit event\r\n    /// @dev deposit may happen only in case 'to' can receive transfer in token controller\r\n    ///     by default KYC is required to receive deposits\r\n    function deposit(address to, uint256 amount, bytes32 reference)\r\n        public\r\n        only(ROLE_EURT_DEPOSIT_MANAGER)\r\n        onlyIfDepositAllowed(to, amount)\r\n        acceptAgreement(to)\r\n    {\r\n        require(to != address(0));\r\n        _balances[to] = add(_balances[to], amount);\r\n        _totalSupply = add(_totalSupply, amount);\r\n        emit LogDeposit(to, msg.sender, amount, reference);\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    /// @notice runs many deposits within one transaction\r\n    /// @dev deposit may happen only in case 'to' can receive transfer in token controller\r\n    ///     by default KYC is required to receive deposits\r\n    function depositMany(address[] to, uint256[] amount, bytes32[] reference)\r\n        public\r\n    {\r\n        require(to.length == amount.length);\r\n        require(to.length == reference.length);\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            deposit(to[i], amount[i], reference[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice withdraws 'amount' of EUR-T by burning required amount and providing a proof of whithdrawal\r\n    /// @dev proof is provided in form of log entry. based on that proof deposit manager will make a bank transfer\r\n    ///     by default controller will check the following: KYC and existence of working bank account\r\n    function withdraw(uint256 amount)\r\n        public\r\n        onlyIfWithdrawAllowed(msg.sender, amount)\r\n        acceptAgreement(msg.sender)\r\n    {\r\n        destroyTokensPrivate(msg.sender, amount);\r\n        emit LogWithdrawal(msg.sender, amount);\r\n    }\r\n\r\n    /// @notice issued by deposit manager when withdraw request was settled. typicaly amount that could be settled will be lower\r\n    ///         than amount withdrawn: banks charge negative interest rates and various fees that must be deduced\r\n    ///         reference number is attached that may be used to identify withdraw operation at deposit manager\r\n    function settleWithdraw(address from, uint256 amount, uint256 originalAmount, bytes32 withdrawTxHash, bytes32 reference)\r\n        public\r\n        only(ROLE_EURT_DEPOSIT_MANAGER)\r\n    {\r\n        emit LogWithdrawSettled(from, msg.sender, amount, originalAmount, withdrawTxHash, reference);\r\n    }\r\n\r\n    /// @notice this method allows to destroy EUR-T belonging to any account\r\n    ///     note that EURO is fiat currency and is not trustless, EUR-T is also\r\n    ///     just internal currency of Neufund platform, not general purpose stable coin\r\n    ///     we need to be able to destroy EUR-T if ordered by authorities\r\n    function destroy(address owner, uint256 amount)\r\n        public\r\n        only(ROLE_EURT_LEGAL_MANAGER)\r\n    {\r\n        destroyTokensPrivate(owner, amount);\r\n        emit LogDestroy(owner, msg.sender, amount);\r\n    }\r\n\r\n    //\r\n    // Implements ITokenControllerHook\r\n    //\r\n\r\n    function changeTokenController(address newController)\r\n        public\r\n    {\r\n        require(_tokenController.onChangeTokenController(msg.sender, newController));\r\n        _tokenController = ITokenController(newController);\r\n        emit LogChangeTokenController(_tokenController, newController, msg.sender);\r\n    }\r\n\r\n    function tokenController()\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return _tokenController;\r\n    }\r\n\r\n    //\r\n    // Implements IERC223Token\r\n    //\r\n    function transfer(address to, uint256 amount, bytes data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        return ierc223TransferInternal(msg.sender, to, amount, data);\r\n    }\r\n\r\n    /// @notice convenience function to deposit and immediately transfer amount\r\n    /// @param depositTo which account to deposit to and then transfer from\r\n    /// @param transferTo where to transfer after deposit\r\n    /// @param depositAmount amount to deposit\r\n    /// @param transferAmount total amount to transfer, must be <= balance after deposit\r\n    /// @dev intended to deposit from bank account and invest in ETO\r\n    function depositAndTransfer(\r\n        address depositTo,\r\n        address transferTo,\r\n        uint256 depositAmount,\r\n        uint256 transferAmount,\r\n        bytes data,\r\n        bytes32 reference\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        deposit(depositTo, depositAmount, reference);\r\n        return ierc223TransferInternal(depositTo, transferTo, transferAmount, data);\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0xfb5c7e43558c4f3f5a2d87885881c9b10ff4be37e3308579c178bf4eaa2c29cd, 0);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements MTokenController\r\n    //\r\n\r\n    function mOnTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        acceptAgreement(from)\r\n        returns (bool allow)\r\n    {\r\n        address broker = msg.sender;\r\n        if (broker != from) {\r\n            // if called by the depositor (deposit and send), ignore the broker flag\r\n            bool isDepositor = accessPolicy().allowed(msg.sender, ROLE_EURT_DEPOSIT_MANAGER, this, msg.sig);\r\n            // this is not very clean but alternative (give brokerage rights to all depositors) is maintenance hell\r\n            if (isDepositor) {\r\n                broker = from;\r\n            }\r\n        }\r\n        return _tokenController.onTransfer(broker, from, to, amount);\r\n    }\r\n\r\n    function mOnApprove(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        acceptAgreement(owner)\r\n        returns (bool allow)\r\n    {\r\n        return _tokenController.onApprove(owner, spender, amount);\r\n    }\r\n\r\n    function mAllowanceOverride(\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _tokenController.onAllowance(owner, spender);\r\n    }\r\n\r\n    //\r\n    // Observes MAgreement internal interface\r\n    //\r\n\r\n    /// @notice euro token is legally represented by separate entity ROLE_EURT_LEGAL_MANAGER\r\n    function mCanAmend(address legalRepresentative)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return accessPolicy().allowed(legalRepresentative, ROLE_EURT_LEGAL_MANAGER, this, msg.sig);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    function destroyTokensPrivate(address owner, uint256 amount)\r\n        private\r\n    {\r\n        require(_balances[owner] >= amount);\r\n        _balances[owner] = sub(_balances[owner], amount);\r\n        _totalSupply = sub(_totalSupply, amount);\r\n        emit Transfer(owner, address(0), amount);\r\n    }\r\n\r\n    /// @notice internal transfer function that checks permissions and calls the tokenFallback\r\n    function ierc223TransferInternal(address from, address to, uint256 amount, bytes data)\r\n        private\r\n        returns (bool success)\r\n    {\r\n        BasicToken.mTransfer(from, to, amount);\r\n\r\n        // Notify the receiving contract.\r\n        if (isContract(to)) {\r\n            // in case of re-entry (1) transfer is done (2) msg.sender is different\r\n            IERC223Callback(to).tokenFallback(from, amount, data);\r\n        }\r\n        return true;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"reference\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"reference\",\"type\":\"bytes32[]\"}],\"name\":\"depositMany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"originalAmount\",\"type\":\"uint256\"},{\"name\":\"withdrawTxHash\",\"type\":\"bytes32\"},{\"name\":\"reference\",\"type\":\"bytes32\"}],\"name\":\"settleWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPolicy\",\"type\":\"address\"},{\"name\":\"newAccessController\",\"type\":\"address\"}],\"name\":\"setAccessPolicy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signatory\",\"type\":\"address\"}],\"name\":\"agreementSignedAtBlock\",\"outputs\":[{\"name\":\"blockNo\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amendmentsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractId\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amendmentIndex\",\"type\":\"uint256\"}],\"name\":\"pastAgreement\",\"outputs\":[{\"name\":\"contractLegalRepresentative\",\"type\":\"address\"},{\"name\":\"signedBlockTimestamp\",\"type\":\"uint256\"},{\"name\":\"agreementUri\",\"type\":\"string\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentAgreement\",\"outputs\":[{\"name\":\"contractLegalRepresentative\",\"type\":\"address\"},{\"name\":\"signedBlockTimestamp\",\"type\":\"uint256\"},{\"name\":\"agreementUri\",\"type\":\"string\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"spender\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"approveAndCall\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newController\",\"type\":\"address\"}],\"name\":\"changeTokenController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"depositTo\",\"type\":\"address\"},{\"name\":\"transferTo\",\"type\":\"address\"},{\"name\":\"depositAmount\",\"type\":\"uint256\"},{\"name\":\"transferAmount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"reference\",\"type\":\"bytes32\"}],\"name\":\"depositAndTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethereumForkArbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agreementUri\",\"type\":\"string\"}],\"name\":\"amendAgreement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accessPolicy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"accessPolicy\",\"type\":\"address\"},{\"name\":\"forkArbiter\",\"type\":\"address\"},{\"name\":\"tokenController\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reference\",\"type\":\"bytes32\"}],\"name\":\"LogDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"originalAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"withdrawTxHash\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"reference\",\"type\":\"bytes32\"}],\"name\":\"LogWithdrawSettled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogDestroy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldController\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newController\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"LogChangeTokenController\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPolicy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newPolicy\",\"type\":\"address\"}],\"name\":\"LogAccessPolicyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"accepter\",\"type\":\"address\"}],\"name\":\"LogAgreementAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractLegalRepresentative\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"agreementUri\",\"type\":\"string\"}],\"name\":\"LogAgreementAmended\",\"type\":\"event\"}]","ContractName":"EuroToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000ae38c27e646959735ec70d77ed4ecc03a3eff4900000000000000000000000004c688949578b4fd0cb8f8993a0ec608659e05cf10000000000000000000000007b40d0ce14abc2cfa75c96d1ff9bb1085f826e46","Library":"","SwarmSource":"bzzr://c063f1f20bee70e9dd36b4d661436f3694503d414c1fe52a7425a3f437a3c988"}]}