{"status":"1","message":"OK","result":[{"SourceCode":"/**\r\n * Copyright (c) 2018 blockimmo AG license@blockimmo.ch\r\n * Non-Profit Open Software License 3.0 (NPOSL-3.0)\r\n * https://opensource.org/licenses/NPOSL-3.0\r\n */\r\n \r\n\r\npragma solidity 0.4.25;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(\r\n    address indexed purchaser,\r\n    address indexed beneficiary,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per wei\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n  constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(\r\n      msg.sender,\r\n      _beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(_beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method: \r\n   *   super._preValidatePurchase(_beneficiary, _weiAmount);\r\n   *   require(weiRaised.add(_weiAmount) <= cap);\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    token.safeTransfer(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _deliverTokens(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount)\r\n    internal view returns (uint256)\r\n  {\r\n    return _weiAmount.mul(rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyWhileOpen\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title PostDeliveryCrowdsale\r\n * @dev Crowdsale that locks tokens from withdrawal until it ends.\r\n */\r\ncontract PostDeliveryCrowdsale is TimedCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public balances;\r\n\r\n  /**\r\n   * @dev Withdraw tokens only after crowdsale ends.\r\n   */\r\n  function withdrawTokens() public {\r\n    require(hasClosed());\r\n    uint256 amount = balances[msg.sender];\r\n    require(amount > 0);\r\n    balances[msg.sender] = 0;\r\n    _deliverTokens(msg.sender, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides parent by storing balances instead of issuing tokens right away.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _tokenAmount Amount of tokens purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of Crowdsale where an owner can do extra work\r\n * after finishing.\r\n */\r\ncontract FinalizableCrowdsale is Ownable, TimedCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  bool public isFinalized = false;\r\n\r\n  event Finalized();\r\n\r\n  /**\r\n   * @dev Must be called after crowdsale ends, to do some extra finalization\r\n   * work. Calls the contract's finalization function.\r\n   */\r\n  function finalize() public onlyOwner {\r\n    require(!isFinalized);\r\n    require(hasClosed());\r\n\r\n    finalization();\r\n    emit Finalized();\r\n\r\n    isFinalized = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Can be overridden to add finalization logic. The overriding function\r\n   * should call super.finalization() to ensure the chain of finalization is\r\n   * executed entirely.\r\n   */\r\n  function finalization() internal {\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Escrow\r\n * @dev Base escrow contract, holds funds destinated to a payee until they\r\n * withdraw them. The contract that uses the escrow as its payment method\r\n * should be its owner, and provide public methods redirecting to the escrow's\r\n * deposit and withdraw.\r\n */\r\ncontract Escrow is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  event Deposited(address indexed payee, uint256 weiAmount);\r\n  event Withdrawn(address indexed payee, uint256 weiAmount);\r\n\r\n  mapping(address => uint256) private deposits;\r\n\r\n  function depositsOf(address _payee) public view returns (uint256) {\r\n    return deposits[_payee];\r\n  }\r\n\r\n  /**\r\n  * @dev Stores the sent amount as credit to be withdrawn.\r\n  * @param _payee The destination address of the funds.\r\n  */\r\n  function deposit(address _payee) public onlyOwner payable {\r\n    uint256 amount = msg.value;\r\n    deposits[_payee] = deposits[_payee].add(amount);\r\n\r\n    emit Deposited(_payee, amount);\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw accumulated balance for a payee.\r\n  * @param _payee The address whose funds will be withdrawn and transferred to.\r\n  */\r\n  function withdraw(address _payee) public onlyOwner {\r\n    uint256 payment = deposits[_payee];\r\n    assert(address(this).balance >= payment);\r\n\r\n    deposits[_payee] = 0;\r\n\r\n    _payee.transfer(payment);\r\n\r\n    emit Withdrawn(_payee, payment);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title ConditionalEscrow\r\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\r\n */\r\ncontract ConditionalEscrow is Escrow {\r\n  /**\r\n  * @dev Returns whether an address is allowed to withdraw their funds. To be\r\n  * implemented by derived contracts.\r\n  * @param _payee The destination address of the funds.\r\n  */\r\n  function withdrawalAllowed(address _payee) public view returns (bool);\r\n\r\n  function withdraw(address _payee) public {\r\n    require(withdrawalAllowed(_payee));\r\n    super.withdraw(_payee);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title RefundEscrow\r\n * @dev Escrow that holds funds for a beneficiary, deposited from multiple parties.\r\n * The contract owner may close the deposit period, and allow for either withdrawal\r\n * by the beneficiary, or refunds to the depositors.\r\n */\r\ncontract RefundEscrow is Ownable, ConditionalEscrow {\r\n  enum State { Active, Refunding, Closed }\r\n\r\n  event Closed();\r\n  event RefundsEnabled();\r\n\r\n  State public state;\r\n  address public beneficiary;\r\n\r\n  /**\r\n   * @dev Constructor.\r\n   * @param _beneficiary The beneficiary of the deposits.\r\n   */\r\n  constructor(address _beneficiary) public {\r\n    require(_beneficiary != address(0));\r\n    beneficiary = _beneficiary;\r\n    state = State.Active;\r\n  }\r\n\r\n  /**\r\n   * @dev Stores funds that may later be refunded.\r\n   * @param _refundee The address funds will be sent to if a refund occurs.\r\n   */\r\n  function deposit(address _refundee) public payable {\r\n    require(state == State.Active);\r\n    super.deposit(_refundee);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows for the beneficiary to withdraw their funds, rejecting\r\n   * further deposits.\r\n   */\r\n  function close() public onlyOwner {\r\n    require(state == State.Active);\r\n    state = State.Closed;\r\n    emit Closed();\r\n  }\r\n\r\n  /**\r\n   * @dev Allows for refunds to take place, rejecting further deposits.\r\n   */\r\n  function enableRefunds() public onlyOwner {\r\n    require(state == State.Active);\r\n    state = State.Refunding;\r\n    emit RefundsEnabled();\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraws the beneficiary's funds.\r\n   */\r\n  function beneficiaryWithdraw() public {\r\n    require(state == State.Closed);\r\n    beneficiary.transfer(address(this).balance);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether refundees can withdraw their deposits (be refunded).\r\n   */\r\n  function withdrawalAllowed(address _payee) public view returns (bool) {\r\n    return state == State.Refunding;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title RefundableCrowdsale\r\n * @dev Extension of Crowdsale contract that adds a funding goal, and\r\n * the possibility of users getting a refund if goal is not met.\r\n */\r\ncontract RefundableCrowdsale is FinalizableCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  // minimum amount of funds to be raised in weis\r\n  uint256 public goal;\r\n\r\n  // refund escrow used to hold funds while crowdsale is running\r\n  RefundEscrow private escrow;\r\n\r\n  /**\r\n   * @dev Constructor, creates RefundEscrow.\r\n   * @param _goal Funding goal\r\n   */\r\n  constructor(uint256 _goal) public {\r\n    require(_goal > 0);\r\n    escrow = new RefundEscrow(wallet);\r\n    goal = _goal;\r\n  }\r\n\r\n  /**\r\n   * @dev Investors can claim refunds here if crowdsale is unsuccessful\r\n   */\r\n  function claimRefund() public {\r\n    require(isFinalized);\r\n    require(!goalReached());\r\n\r\n    escrow.withdraw(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether funding goal was reached.\r\n   * @return Whether funding goal was reached\r\n   */\r\n  function goalReached() public view returns (bool) {\r\n    return weiRaised >= goal;\r\n  }\r\n\r\n  /**\r\n   * @dev escrow finalization task, called when owner calls finalize()\r\n   */\r\n  function finalization() internal {\r\n    if (goalReached()) {\r\n      escrow.close();\r\n      escrow.beneficiaryWithdraw();\r\n    } else {\r\n      escrow.enableRefunds();\r\n    }\r\n\r\n    super.finalization();\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides Crowdsale fund forwarding, sending funds to escrow.\r\n   */\r\n  function _forwardFunds() internal {\r\n    escrow.deposit.value(msg.value)(msg.sender);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract MedianizerInterface {\r\n  function read() public view returns (bytes32);\r\n}\r\n\r\n\r\ncontract WhitelistInterface {\r\n  function checkRole(address _operator, string _role) public view;\r\n  function hasRole(address _operator, string _role) public view returns (bool);\r\n}\r\n\r\n\r\ncontract WhitelistProxyInterface {\r\n  function whitelist() public view returns (WhitelistInterface);\r\n}\r\n\r\n\r\n/**\r\n * @title TokenSale\r\n * @dev Distribute tokens to investors in exchange for Ether.\r\n *\r\n * This is the primary mechanism for outright sales of commercial investment properties (and blockimmo's STO, where shares\r\n * of our company are represented as `TokenizedProperty`) (official pending FINMA approval).\r\n *\r\n * Selling:\r\n *   1. Deploy `TokenizedProperty`. Initially all tokens and ownership of this property will be assigned to the 'deployer'\r\n *   2. Deploy `ShareholderDAO` and transfer the property's (1) ownership to it\r\n *   3. Configure and deploy a `TokenSale`\r\n *     - After completing (1, 2, 3) blockimmo will verify the property as legitimate in `LandRegistry`\r\n *     - blockimmo will then authorize `this` to the `Whitelist` before seller can proceed to (4)\r\n *   4. Transfer tokens of `TokenizedProperty` (1) to be sold to `this` (3)\r\n *   5. Investors are able to buy tokens while the sale is open. 'Deployer' calls `finalize` to complete the sale\r\n *\r\n * Note: blockimmo will be responsible for managing initial sales on our platform. This means we will be configuring\r\n *       and deploying all contracts for sellers. This provides an extra layer of control/security until we've refined\r\n *       these processes and proven them in the real-world.\r\n *       Later sales will use SplitPayment contracts to route funds, with examples in the tests.\r\n *\r\n * Unsold tokens (of a successful sale) are redistributed proportionally to investors via Airdrop, as described in:\r\n * https://medium.com/FundFantasy/airdropping-vs-burning-part-1-613a9c6ebf1c\r\n *\r\n * If a sale's soft-cap is not reached (and the seller does not `accept` a lower price), investors will be refunded Ether and the seller refunded tokens.\r\n *\r\n * For stable token sales (soft and hard-cap in USD instead of Wei), we rely on MakerDAO's on-chain ETH/USD conversion rate\r\n * https://developer.makerdao.com/feeds/\r\n * This approach to mitigating Ether volatility seems to best when analyzing trade-offs, short of selling directly in FIAT.\r\n */\r\ncontract TokenSale is RefundableCrowdsale, PostDeliveryCrowdsale {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  address public constant MEDIANIZER_ADDRESS = 0x729D19f657BD0614b4985Cf1D82531c67569197B;  // 0x0f5ea0a652e851678ebf77b69484bfcd31f9459b;\r\n  address public constant WHITELIST_PROXY_ADDRESS = 0x7223b032180CDb06Be7a3D634B1E10032111F367;  // 0xc4c7497fbe1a886841a195a5d622cd60053c1376;\r\n\r\n  MedianizerInterface private medianizer = MedianizerInterface(MEDIANIZER_ADDRESS);\r\n  WhitelistProxyInterface private whitelistProxy = WhitelistProxyInterface(WHITELIST_PROXY_ADDRESS);\r\n\r\n  uint256 public cap;\r\n  bool public goalReachedOnFinalize;\r\n  uint256 public totalTokens;\r\n  uint256 public totalTokensSold = 0;\r\n  bool public usd;\r\n\r\n  mapping(address => uint256) public usdInvestment;\r\n\r\n  constructor(\r\n    uint256 _openingTime,\r\n    uint256 _closingTime,\r\n    uint256 _rate,\r\n    address _wallet,\r\n    uint256 _cap,\r\n    ERC20 _token,\r\n    uint256 _goal,\r\n    bool _usd  // if true, both `goal` and `cap` are in units of USD. if false, in ETH\r\n  )\r\n    public\r\n    Crowdsale(_rate, _wallet, _token)\r\n    TimedCrowdsale(_openingTime, _closingTime)\r\n    RefundableCrowdsale(_goal)\r\n    PostDeliveryCrowdsale()\r\n  {\r\n    require(_cap > 0, \"cap is not > 0\");\r\n    require(_goal < _cap, \"goal is not < cap\");\r\n    cap = _cap;\r\n    usd = _usd;\r\n  }\r\n\r\n  function capReached() public view returns (bool) {\r\n    return _reached(cap);\r\n  }\r\n\r\n  function goalReached() public view returns (bool) {\r\n    if (isFinalized) {\r\n      return goalReachedOnFinalize;\r\n    } else {\r\n      return _reached(goal);\r\n    }\r\n  }\r\n\r\n  function withdrawTokens() public {  // airdrop remaining tokens to investors proportionally\r\n    uint256 extra = totalTokens.sub(totalTokensSold).mul(balances[msg.sender]) / totalTokensSold;\r\n    balances[msg.sender] = balances[msg.sender].add(extra);\r\n    super.withdrawTokens();\r\n  }\r\n\r\n  function finalization() internal {  // ether refunds enabled for investors, refund tokens to seller\r\n    totalTokens = token.balanceOf(address(this));\r\n    goalReachedOnFinalize = goalReached();\r\n    if (!goalReachedOnFinalize) {\r\n      token.safeTransfer(owner, totalTokens);\r\n    }\r\n    super.finalization();\r\n  }\r\n\r\n  function _getUsdAmount(uint256 _weiAmount) internal view returns (uint256) {\r\n    uint256 usdPerEth = uint256(medianizer.read());\r\n    return _weiAmount.mul(usdPerEth).div(1e18).div(1e18);\r\n  }\r\n\r\n  function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal {\r\n    require(_weiAmount >= 1e18);\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n\r\n    WhitelistInterface whitelist = whitelistProxy.whitelist();\r\n\r\n    usdInvestment[_beneficiary] = usdInvestment[_beneficiary].add(_getUsdAmount(_weiAmount));\r\n    if (!whitelist.hasRole(_beneficiary, \"uncapped\")) {\r\n      require(usdInvestment[_beneficiary] <= 100000);\r\n      whitelist.checkRole(_beneficiary, \"authorized\");\r\n    }\r\n\r\n    if (usd) {\r\n      require(_getUsdAmount(weiRaised.add(_weiAmount)) <= cap, \"usd raised must not exceed cap\");\r\n    } else {\r\n      require(weiRaised.add(_weiAmount) <= cap, \"wei raised must not exceed cap\");\r\n    }\r\n  }\r\n\r\n  function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal {\r\n    totalTokensSold = totalTokensSold.add(_tokenAmount);\r\n    require(totalTokensSold <= token.balanceOf(address(this)), \"totalTokensSold raised must not exceed balanceOf `this`\");\r\n\r\n    super._processPurchase(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  function _reached(uint256 _target) internal view returns (bool) {\r\n    if (usd) {\r\n      return _getUsdAmount(weiRaised) >= _target;\r\n    } else {\r\n      return weiRaised >= _target;\r\n    }\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"WHITELIST_PROXY_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"hasClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"capReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"usdInvestment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MEDIANIZER_ADDRESS\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReached\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"goalReachedOnFinalize\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRefund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usd\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_goal\",\"type\":\"uint256\"},{\"name\":\"_usd\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenSale","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000005bb1e599000000000000000000000000000000000000000000000000000000005bbb206800000000000000000000000000000000000000000000000000000000000000010000000000000000000000007c01eb2f7f98eef60447bf620136d2dfa9ee5420000000000000000000000000000000000000000000000000000000000000012c0000000000000000000000002bec82472a1f3ad941a94fb9d5512c9e51ec979d000000000000000000000000000000000000000000000000000000000000008c0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://2b75e416c4c59c4ecba2ddb58dd0a3cc84c1304e3676606f7027cb0de12a59dc"}]}