{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @dev Pulled from OpenZeppelin: https://git.io/vbaRf\r\n *   When this is in a public release we will switch to not vendoring this file\r\n *\r\n * @title Eliptic curve signature operations\r\n *\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using his signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig) public pure returns (address) {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    //Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Extracting these values isn't possible without assembly\r\n    // solhint-disable no-inline-assembly\r\n    // Divide the signature in r, s and v variables\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title IPFS hash handler\r\n *\r\n * @dev IPFS multihash handler. Does a small check to validate that a multihash is\r\n *   correct by validating the digest size byte of the hash. For example, the IPFS\r\n *   Multihash \"QmPtkU87jX1SnyhjAgUwnirmabAmeASQ4wGfwxviJSA4wf\" is the base58\r\n *   encoded form of the following data:\r\n *\r\n *     ┌────┬────┬───────────────────────────────────────────────────────────────────┐\r\n *     │byte│byte│             variable length hash based on digest size             │\r\n *     ├────┼────┼───────────────────────────────────────────────────────────────────┤\r\n *     │0x12│0x20│0x1714c8d0fa5dbe9e6c04059ddac50c3860fb0370d67af53f2bd51a4def656526 │\r\n *     └────┴────┴───────────────────────────────────────────────────────────────────┘\r\n *       ▲    ▲                                   ▲\r\n *       │    └───────────┐                       │\r\n *   hash function    digest size             hash value\r\n *\r\n * we still store the data as `bytes` since it is inherently a variable length structure.\r\n *\r\n * @dev See multihash format: https://git.io/vbooc\r\n */\r\ncontract DependentOnIPFS {\r\n  /**\r\n   * @dev Validate a multihash bytes value\r\n   */\r\n  function isValidIPFSMultihash(bytes _multihashBytes) internal pure returns (bool) {\r\n    require(_multihashBytes.length > 2);\r\n\r\n    uint8 _size;\r\n\r\n    // There isn't another way to extract only this byte into a uint8\r\n    // solhint-disable no-inline-assembly\r\n    assembly {\r\n      // Seek forward 33 bytes beyond the solidity length value and the hash function byte\r\n      _size := byte(0, mload(add(_multihashBytes, 33)))\r\n    }\r\n\r\n    return (_multihashBytes.length == _size + 2);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title SigningLogic is contract implementing signature recovery from typed data signatures\r\n * @notice Recovers signatures based on the SignTypedData implementation provided by ethSigUtil\r\n * @dev This contract is inherited by other contracts.\r\n */\r\ncontract SigningLogic {\r\n\r\n  // Signatures contain a nonce to make them unique. usedSignatures tracks which signatures\r\n  //  have been used so they can't be replayed\r\n  mapping (bytes32 => bool) public usedSignatures;\r\n\r\n  function burnSignatureDigest(bytes32 _signatureDigest, address _sender) internal {\r\n    bytes32 _txDataHash = keccak256(abi.encode(_signatureDigest, _sender));\r\n    require(!usedSignatures[_txDataHash], \"Signature not unique\");\r\n    usedSignatures[_txDataHash] = true;\r\n  }\r\n\r\n  bytes32 constant EIP712DOMAIN_TYPEHASH = keccak256(\r\n    \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\r\n  );\r\n\r\n  bytes32 constant ATTESTATION_REQUEST_TYPEHASH = keccak256(\r\n    \"AttestationRequest(bytes32 dataHash,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant ADD_ADDRESS_TYPEHASH = keccak256(\r\n    \"AddAddress(address addressToAdd,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant REMOVE_ADDRESS_TYPEHASH = keccak256(\r\n    \"RemoveAddress(address addressToRemove,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant PAY_TOKENS_TYPEHASH = keccak256(\r\n    \"PayTokens(address sender,address receiver,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant RELEASE_TOKENS_FOR_TYPEHASH = keccak256(\r\n    \"ReleaseTokensFor(address sender,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant ATTEST_FOR_TYPEHASH = keccak256(\r\n    \"AttestFor(address subject,address requester,uint256 reward,bytes32 dataHash,bytes32 requestNonce)\"\r\n  );\r\n\r\n  bytes32 constant CONTEST_FOR_TYPEHASH = keccak256(\r\n    \"ContestFor(address requester,uint256 reward,bytes32 requestNonce)\"\r\n  );\r\n\r\n  bytes32 constant REVOKE_ATTESTATION_FOR_TYPEHASH = keccak256(\r\n    \"RevokeAttestationFor(bytes32 link,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 constant VOTE_FOR_TYPEHASH = keccak256(\r\n    \"VoteFor(uint16 choice,address voter,bytes32 nonce,address poll)\"\r\n  );\r\n\r\n  bytes32 constant LOCKUP_TOKENS_FOR_TYPEHASH = keccak256(\r\n    \"LockupTokensFor(address sender,uint256 amount,bytes32 nonce)\"\r\n  );\r\n\r\n  bytes32 DOMAIN_SEPARATOR;\r\n\r\n  constructor (string name, string version, uint256 chainId) public {\r\n    DOMAIN_SEPARATOR = hash(EIP712Domain({\r\n      name: name,\r\n      version: version,\r\n      chainId: chainId,\r\n      verifyingContract: this\r\n    }));\r\n  }\r\n\r\n  struct EIP712Domain {\r\n      string  name;\r\n      string  version;\r\n      uint256 chainId;\r\n      address verifyingContract;\r\n  }\r\n\r\n  function hash(EIP712Domain eip712Domain) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      EIP712DOMAIN_TYPEHASH,\r\n      keccak256(bytes(eip712Domain.name)),\r\n      keccak256(bytes(eip712Domain.version)),\r\n      eip712Domain.chainId,\r\n      eip712Domain.verifyingContract\r\n    ));\r\n  }\r\n\r\n  struct AttestationRequest {\r\n      bytes32 dataHash;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AttestationRequest request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ATTESTATION_REQUEST_TYPEHASH,\r\n      request.dataHash,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct AddAddress {\r\n      address addressToAdd;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(AddAddress request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ADD_ADDRESS_TYPEHASH,\r\n      request.addressToAdd,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct RemoveAddress {\r\n      address addressToRemove;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(RemoveAddress request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      REMOVE_ADDRESS_TYPEHASH,\r\n      request.addressToRemove,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct PayTokens {\r\n      address sender;\r\n      address receiver;\r\n      uint256 amount;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(PayTokens request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      PAY_TOKENS_TYPEHASH,\r\n      request.sender,\r\n      request.receiver,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct AttestFor {\r\n      address subject;\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 dataHash;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(AttestFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      ATTEST_FOR_TYPEHASH,\r\n      request.subject,\r\n      request.requester,\r\n      request.reward,\r\n      request.dataHash,\r\n      request.requestNonce\r\n    ));\r\n  }\r\n\r\n  struct ContestFor {\r\n      address requester;\r\n      uint256 reward;\r\n      bytes32 requestNonce;\r\n  }\r\n\r\n  function hash(ContestFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      CONTEST_FOR_TYPEHASH,\r\n      request.requester,\r\n      request.reward,\r\n      request.requestNonce\r\n    ));\r\n  }\r\n\r\n  struct RevokeAttestationFor {\r\n      bytes32 link;\r\n      bytes32 nonce;\r\n  }\r\n\r\n  function hash(RevokeAttestationFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      REVOKE_ATTESTATION_FOR_TYPEHASH,\r\n      request.link,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct VoteFor {\r\n      uint16 choice;\r\n      address voter;\r\n      bytes32 nonce;\r\n      address poll;\r\n  }\r\n\r\n  function hash(VoteFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      VOTE_FOR_TYPEHASH,\r\n      request.choice,\r\n      request.voter,\r\n      request.nonce,\r\n      request.poll\r\n    ));\r\n  }\r\n\r\n  struct LockupTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(LockupTokensFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      LOCKUP_TOKENS_FOR_TYPEHASH,\r\n      request.sender,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  struct ReleaseTokensFor {\r\n    address sender;\r\n    uint256 amount;\r\n    bytes32 nonce;\r\n  }\r\n\r\n  function hash(ReleaseTokensFor request) private pure returns (bytes32) {\r\n    return keccak256(abi.encode(\r\n      RELEASE_TOKENS_FOR_TYPEHASH,\r\n      request.sender,\r\n      request.amount,\r\n      request.nonce\r\n    ));\r\n  }\r\n\r\n  function generateRequestAttestationSchemaHash(\r\n    bytes32 _dataHash,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AttestationRequest(\r\n          _dataHash,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateAddAddressSchemaHash(\r\n    address _addressToAdd,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AddAddress(\r\n          _addressToAdd,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateRemoveAddressSchemaHash(\r\n    address _addressToRemove,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(RemoveAddress(\r\n          _addressToRemove,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generatePayTokensSchemaHash(\r\n    address _sender,\r\n    address _receiver,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(PayTokens(\r\n          _sender,\r\n          _receiver,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateAttestForDelegationSchemaHash(\r\n    address _subject,\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _dataHash,\r\n    bytes32 _requestNonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(AttestFor(\r\n          _subject,\r\n          _requester,\r\n          _reward,\r\n          _dataHash,\r\n          _requestNonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateContestForDelegationSchemaHash(\r\n    address _requester,\r\n    uint256 _reward,\r\n    bytes32 _requestNonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(ContestFor(\r\n          _requester,\r\n          _reward,\r\n          _requestNonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateRevokeAttestationForDelegationSchemaHash(\r\n    bytes32 _link,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(RevokeAttestationFor(\r\n          _link,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateVoteForDelegationSchemaHash(\r\n    uint16 _choice,\r\n    address _voter,\r\n    bytes32 _nonce,\r\n    address _poll\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(VoteFor(\r\n          _choice,\r\n          _voter,\r\n          _nonce,\r\n          _poll\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateLockupTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(LockupTokensFor(\r\n          _sender,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function generateReleaseTokensDelegationSchemaHash(\r\n    address _sender,\r\n    uint256 _amount,\r\n    bytes32 _nonce\r\n  ) internal view returns (bytes32) {\r\n    return keccak256(\r\n      abi.encodePacked(\r\n        \"\\x19\\x01\",\r\n        DOMAIN_SEPARATOR,\r\n        hash(ReleaseTokensFor(\r\n          _sender,\r\n          _amount,\r\n          _nonce\r\n        ))\r\n      )\r\n      );\r\n  }\r\n\r\n  function recoverSigner(bytes32 _hash, bytes _sig) internal pure returns (address) {\r\n    address signer = ECRecovery.recover(_hash, _sig);\r\n    require(signer != address(0));\r\n\r\n    return signer;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Voteable poll with associated IPFS data\r\n *\r\n * A poll records votes on a variable number of choices. A poll specifies\r\n * a window during which users can vote. Information like the poll title and\r\n * the descriptions for each option are stored on IPFS.\r\n */\r\ncontract Poll is DependentOnIPFS, SigningLogic {\r\n  // There isn't a way around using time to determine when votes can be cast\r\n  // solhint-disable not-rely-on-time\r\n\r\n  bytes public pollDataMultihash;\r\n  uint16 public numChoices;\r\n  uint256 public startTime;\r\n  uint256 public endTime;\r\n  address public author;\r\n\r\n  event VoteCast(address indexed voter, uint16 indexed choice);\r\n\r\n  constructor(\r\n    string _name,\r\n    uint256 _chainId,\r\n    bytes _ipfsHash,\r\n    uint16 _numChoices,\r\n    uint256 _startTime,\r\n    uint256 _endTime,\r\n    address _author\r\n  ) public SigningLogic(_name, \"2\", _chainId) {\r\n    require(_startTime >= now && _endTime > _startTime);\r\n    require(isValidIPFSMultihash(_ipfsHash));\r\n\r\n    numChoices = _numChoices;\r\n    startTime = _startTime;\r\n    endTime = _endTime;\r\n    pollDataMultihash = _ipfsHash;\r\n    author = _author;\r\n  }\r\n\r\n  function vote(uint16 _choice) external {\r\n    voteForUser(_choice, msg.sender);\r\n  }\r\n\r\n  function voteFor(uint16 _choice, address _voter, bytes32 _nonce, bytes _delegationSig) external {\r\n    validateVoteForSig(_choice, _voter, _nonce, _delegationSig);\r\n    voteForUser(_choice, _voter);\r\n  }\r\n\r\n  function validateVoteForSig(\r\n    uint16 _choice,\r\n    address _voter,\r\n    bytes32 _nonce,\r\n    bytes _delegationSig\r\n  ) private {\r\n    bytes32 _signatureDigest = generateVoteForDelegationSchemaHash(_choice, _voter, _nonce, this);\r\n    require(_voter == recoverSigner(_signatureDigest, _delegationSig),\r\n      \"Invalid signer\"\r\n      );\r\n    burnSignatureDigest(_signatureDigest, _voter);\r\n  }\r\n\r\n  /**\r\n   * @dev Cast or change your vote\r\n   * @param _choice The index of the option in the corresponding IPFS document.\r\n   */\r\n  function voteForUser(uint16 _choice, address _voter) private duringPoll {\r\n    // Choices are indexed from 1 since the mapping returns 0 for \"no vote cast\"\r\n    require(_choice <= numChoices && _choice > 0);\r\n    emit VoteCast(_voter, _choice);\r\n  }\r\n\r\n  modifier duringPoll {\r\n    require(now >= startTime && now <= endTime);\r\n    _;\r\n  }\r\n\r\n}\r\n\r\n\r\n/*\r\n * @title Bloom voting center\r\n * @dev The voting center is the home of all polls conducted within the Bloom network.\r\n *   Anyone can create a new poll and there is no \"owner\" of the network. The Bloom dApp\r\n *   assumes that all polls are in the `polls` field so any Bloom poll should be created\r\n *   through the `createPoll` function.\r\n */\r\ncontract VotingCenter {\r\n  Poll[] public polls;\r\n\r\n  event PollCreated(address indexed poll, address indexed author);\r\n\r\n  /**\r\n   * @dev create a poll and store the address of the poll in this contract\r\n   * @param _ipfsHash Multihash for IPFS file containing poll information\r\n   * @param _numOptions Number of choices in this poll\r\n   * @param _startTime Time after which a user can cast a vote in the poll\r\n   * @param _endTime Time after which the poll no longer accepts new votes\r\n   * @return The address of the new Poll\r\n   */\r\n  function createPoll(\r\n    string _name,\r\n    uint256 _chainId,\r\n    bytes _ipfsHash,\r\n    uint16 _numOptions,\r\n    uint256 _startTime,\r\n    uint256 _endTime\r\n  ) external returns (address) {\r\n    Poll newPoll = new Poll(\r\n      _name,\r\n      _chainId,\r\n      _ipfsHash,\r\n      _numOptions,\r\n      _startTime,\r\n      _endTime,\r\n      msg.sender\r\n      );\r\n    polls.push(newPoll);\r\n\r\n    emit PollCreated(newPoll, msg.sender);\r\n\r\n    return newPoll;\r\n  }\r\n\r\n  function allPolls() external view returns (Poll[]) {\r\n    return polls;\r\n  }\r\n\r\n  function numPolls() external view returns (uint256) {\r\n    return polls.length;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"numPolls\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"polls\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allPolls\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_chainId\",\"type\":\"uint256\"},{\"name\":\"_ipfsHash\",\"type\":\"bytes\"},{\"name\":\"_numOptions\",\"type\":\"uint16\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"}],\"name\":\"createPoll\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"poll\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"author\",\"type\":\"address\"}],\"name\":\"PollCreated\",\"type\":\"event\"}]","ContractName":"VotingCenter","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"ECRecovery:7a75cb349d9a9d4c2d3eb8a22cb3090222d8557b","SwarmSource":"bzzr://7579645169360bd130030e58dec87f8089550f4c3086b5ce9dbcbbad0f43a663"}]}