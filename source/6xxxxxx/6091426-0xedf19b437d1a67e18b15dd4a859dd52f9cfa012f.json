{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(ERC20Basic token, address to, uint256 value) internal {\r\n    require(token.transfer(to, value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 token,\r\n    address from,\r\n    address to,\r\n    uint256 value\r\n  )\r\n    internal\r\n  {\r\n    require(token.transferFrom(from, to, value));\r\n  }\r\n\r\n  function safeApprove(ERC20 token, address spender, uint256 value) internal {\r\n    require(token.approve(spender, value));\r\n  }\r\n}\r\n\r\n// Custom smart contracts developed or adapted for OrcaCrowdsale\r\n// -------------------------------------------------------------\r\n\r\ncontract TokenRecoverable is Ownable {\r\n    using SafeERC20 for ERC20Basic;\r\n\r\n    function recoverTokens(ERC20Basic token, address to, uint256 amount) public onlyOwner {\r\n        uint256 balance = token.balanceOf(address(this));\r\n        require(balance >= amount);\r\n        token.safeTransfer(to, amount);\r\n    }\r\n}\r\n\r\ncontract ERC820Registry {\r\n    function getManager(address addr) public view returns(address);\r\n    function setManager(address addr, address newManager) public;\r\n    function getInterfaceImplementer(address addr, bytes32 iHash) public constant returns (address);\r\n    function setInterfaceImplementer(address addr, bytes32 iHash, address implementer) public;\r\n}\r\n\r\ncontract ERC820Implementer {\r\n    ERC820Registry erc820Registry = ERC820Registry(0x991a1bcb077599290d7305493c9A630c20f8b798);\r\n\r\n    function setInterfaceImplementation(string ifaceLabel, address impl) internal {\r\n        bytes32 ifaceHash = keccak256(abi.encodePacked(ifaceLabel));\r\n        erc820Registry.setInterfaceImplementer(this, ifaceHash, impl);\r\n    }\r\n\r\n    function interfaceAddr(address addr, string ifaceLabel) internal constant returns(address) {\r\n        bytes32 ifaceHash = keccak256(abi.encodePacked(ifaceLabel));\r\n        return erc820Registry.getInterfaceImplementer(addr, ifaceHash);\r\n    }\r\n\r\n    function delegateManagement(address newManager) internal {\r\n        erc820Registry.setManager(this, newManager);\r\n    }\r\n}\r\n\r\ncontract ERC777Token {\r\n    function name() public view returns (string);\r\n    function symbol() public view returns (string);\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address owner) public view returns (uint256);\r\n    function granularity() public view returns (uint256);\r\n\r\n    function defaultOperators() public view returns (address[]);\r\n    function isOperatorFor(address operator, address tokenHolder) public view returns (bool);\r\n    function authorizeOperator(address operator) public;\r\n    function revokeOperator(address operator) public;\r\n\r\n    function send(address to, uint256 amount, bytes holderData) public;\r\n    function operatorSend(address from, address to, uint256 amount, bytes holderData, bytes operatorData) public;\r\n\r\n    function burn(uint256 amount, bytes holderData) public;\r\n    function operatorBurn(address from, uint256 amount, bytes holderData, bytes operatorData) public;\r\n\r\n    event Sent(\r\n        address indexed operator,\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount,\r\n        bytes holderData,\r\n        bytes operatorData\r\n    ); // solhint-disable-next-line separate-by-one-line-in-contract\r\n    event Minted(address indexed operator, address indexed to, uint256 amount, bytes operatorData);\r\n    event Burned(address indexed operator, address indexed from, uint256 amount, bytes holderData, bytes operatorData);\r\n    event AuthorizedOperator(address indexed operator, address indexed tokenHolder);\r\n    event RevokedOperator(address indexed operator, address indexed tokenHolder);\r\n}\r\n\r\ncontract ERC777TokensRecipient {\r\n    function tokensReceived(\r\n        address operator,\r\n        address from,\r\n        address to,\r\n        uint amount,\r\n        bytes userData,\r\n        bytes operatorData\r\n    ) public;\r\n}\r\n\r\ncontract CommunityLock is ERC777TokensRecipient, ERC820Implementer, TokenRecoverable {\r\n\r\n    ERC777Token public token;\r\n\r\n    constructor(address _token) public {\r\n        setInterfaceImplementation(\"ERC777TokensRecipient\", this);\r\n        address tokenAddress = interfaceAddr(_token, \"ERC777Token\");\r\n        require(tokenAddress != address(0));\r\n        token = ERC777Token(tokenAddress);\r\n    }\r\n\r\n    function burn(uint256 _amount) public onlyOwner {\r\n        require(_amount > 0);\r\n        token.burn(_amount, '');\r\n    }\r\n\r\n    function tokensReceived(address, address, address, uint256, bytes, bytes) public {\r\n        require(msg.sender == address(token));\r\n    }\r\n}\r\n\r\ncontract Debuggable {\r\n    event LogUI(string message, uint256 value);\r\n\r\n    function logUI(string message, uint256 value) internal {\r\n        emit LogUI(message, value);\r\n    }\r\n}\r\n\r\ncontract ERC777TokenScheduledTimelock is ERC820Implementer, ERC777TokensRecipient, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    ERC777Token public token;\r\n    uint256 public totalVested;\r\n\r\n    struct Timelock {\r\n        uint256 till;\r\n        uint256 amount;\r\n    }\r\n\r\n    mapping(address => Timelock[]) public schedule;\r\n\r\n    event Released(address to, uint256 amount);\r\n\r\n    constructor(address _token) public {\r\n        setInterfaceImplementation(\"ERC777TokensRecipient\", this);\r\n        address tokenAddress = interfaceAddr(_token, \"ERC777Token\");\r\n        require(tokenAddress != address(0));\r\n        token = ERC777Token(tokenAddress);\r\n    }\r\n\r\n    function scheduleTimelock(address _beneficiary, uint256 _lockTokenAmount, uint256 _lockTill) public onlyOwner {\r\n        require(_beneficiary != address(0));\r\n        require(_lockTill > getNow());\r\n        require(token.balanceOf(address(this)) >= totalVested.add(_lockTokenAmount));\r\n        totalVested = totalVested.add(_lockTokenAmount);\r\n\r\n        schedule[_beneficiary].push(Timelock({ till: _lockTill, amount: _lockTokenAmount }));\r\n    }\r\n\r\n    function release(address _to) public {\r\n        Timelock[] storage timelocks = schedule[_to];\r\n        uint256 tokens = 0;\r\n        uint256 till;\r\n        uint256 n = timelocks.length;\r\n        uint256 timestamp = getNow();\r\n        for (uint256 i = 0; i < n; i++) {\r\n            Timelock storage timelock = timelocks[i];\r\n            till = timelock.till;\r\n            if (till > 0 && till <= timestamp) {\r\n                tokens = tokens.add(timelock.amount);\r\n                timelock.amount = 0;\r\n                timelock.till = 0;\r\n            }\r\n        }\r\n        if (tokens > 0) {\r\n            totalVested = totalVested.sub(tokens);\r\n            token.send(_to, tokens, '');\r\n            emit Released(_to, tokens);\r\n        }\r\n    }\r\n\r\n    function releaseBatch(address[] _to) public {\r\n        require(_to.length > 0 && _to.length < 100);\r\n\r\n        for (uint256 i = 0; i < _to.length; i++) {\r\n            release(_to[i]);\r\n        }\r\n    }\r\n\r\n    function tokensReceived(address, address, address, uint256, bytes, bytes) public {}\r\n\r\n    function getScheduledTimelockCount(address _beneficiary) public view returns (uint256) {\r\n        return schedule[_beneficiary].length;\r\n    }\r\n\r\n    function getNow() internal view returns (uint256) {\r\n        return now; // solhint-disable-line\r\n    }\r\n}\r\n\r\ncontract ExchangeRateConsumer is Ownable {\r\n\r\n    uint8 public constant EXCHANGE_RATE_DECIMALS = 3; // 3 digits precision for exchange rate\r\n\r\n    uint256 public exchangeRate = 600000; // by default exchange rate is $600 with EXCHANGE_RATE_DECIMALS precision\r\n\r\n    address public exchangeRateOracle;\r\n\r\n    function setExchangeRateOracle(address _exchangeRateOracle) public onlyOwner {\r\n        require(_exchangeRateOracle != address(0));\r\n        exchangeRateOracle = _exchangeRateOracle;\r\n    }\r\n\r\n    function setExchangeRate(uint256 _exchangeRate) public {\r\n        require(msg.sender == exchangeRateOracle || msg.sender == owner);\r\n        require(_exchangeRate > 0);\r\n        exchangeRate = _exchangeRate;\r\n    }\r\n}\r\n\r\ncontract OrcaToken is Ownable  {\r\n    using SafeMath for uint256;\r\n\r\n    string private constant name_ = \"ORCA Token\";\r\n    string private constant symbol_ = \"ORCA\";\r\n    uint256 private constant granularity_ = 1;\r\n\r\n    function mint(address _tokenHolder, uint256 _amount, bytes _operatorData) public;\r\n    function burn(uint256 _amount, bytes _holderData) public;\r\n    function finishMinting() public;\r\n}\r\n\r\ncontract Whitelist {\r\n    mapping(address => uint256) public whitelist;\r\n}\r\n\r\ncontract OrcaCrowdsale is TokenRecoverable, ExchangeRateConsumer, Debuggable {\r\n    using SafeMath for uint256;\r\n\r\n    // Wallet where all ether will be stored\r\n    address internal constant WALLET = 0x0909Fb46D48eea996197573415446A26c001994a;\r\n    // Partner wallet\r\n    address internal constant PARTNER_WALLET = 0x536ba70cA19DF9982487e555E335e7d91Da4A474;\r\n    // Team wallet\r\n    address internal constant TEAM_WALLET = 0x5d6aF05d440326AE861100962e861CFF09203556;\r\n    // Advisors wallet\r\n    address internal constant ADVISORS_WALLET = 0xf44e377F35998a6b7776954c64a84fAf420C467B;\r\n\r\n    uint256 internal constant TEAM_TOKENS = 58200000e18;      // 58 200 000 tokens\r\n    uint256 internal constant ADVISORS_TOKENS = 20000000e18;  // 20 000 000 tokens\r\n    uint256 internal constant PARTNER_TOKENS = 82800000e18;   // 82 800 000 tokens\r\n    uint256 internal constant COMMUNITY_TOKENS = 92000000e18; // 92 000 000 tokens\r\n\r\n    uint256 internal constant TOKEN_PRICE = 6; // Token costs 0.06 USD\r\n    uint256 internal constant TEAM_TOKEN_LOCK_DATE = 1565049600; // 2019/08/06 00:00 UTC\r\n\r\n    struct Stage {\r\n        uint256 startDate;\r\n        uint256 endDate;\r\n        uint256 priorityDate; // allow priority users to purchase tokens until this date\r\n        uint256 cap;\r\n        uint64 bonus;\r\n        uint64 maxPriorityId;\r\n    }\r\n\r\n    uint256 public icoTokensLeft = 193200000e18;   // 193 200 000 tokens for ICO\r\n    uint256 public bountyTokensLeft = 13800000e18; // 13 800 000 bounty tokens\r\n    uint256 public preSaleTokens = 0;\r\n\r\n    Stage[] public stages;\r\n\r\n    // The token being sold\r\n    OrcaToken public token;\r\n    Whitelist public whitelist;\r\n    ERC777TokenScheduledTimelock public timelock;\r\n    CommunityLock public communityLock;\r\n\r\n    mapping(address => uint256) public bountyBalances;\r\n\r\n    address public tokenMinter;\r\n\r\n    uint8 public currentStage = 0;\r\n    bool public initialized = false;\r\n    bool public isFinalized = false;\r\n    bool public isPreSaleTokenSet = false;\r\n\r\n    /**\r\n    * event for token purchase logging\r\n    * @param purchaser who paid for the tokens\r\n    * @param beneficiary who got the tokens\r\n    * @param weis paid for purchase\r\n    * @param usd paid for purchase\r\n    * @param amount amount of tokens purchased\r\n    */\r\n    event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 weis, uint256 usd, uint256 rate, uint256 amount);\r\n\r\n    event Finalized();\r\n    /**\r\n     * When there no tokens left to mint and token minter tries to manually mint tokens\r\n     * this event is raised to signal how many tokens we have to charge back to purchaser\r\n     */\r\n    event ManualTokenMintRequiresRefund(address indexed purchaser, uint256 value);\r\n\r\n    modifier onlyInitialized() {\r\n        require(initialized);\r\n        _;\r\n    }\r\n\r\n    constructor(address _token, address _whitelist) public {\r\n        require(_token != address(0));\r\n        require(_whitelist != address(0));\r\n\r\n        uint256 stageCap = 30000000e18; // 30 000 000 tokens\r\n\r\n        stages.push(Stage({\r\n            startDate: 1533546000, // 6th of August, 9:00 UTC\r\n            endDate: 1534150800, // 13th of August, 9:00 UTC\r\n            cap: stageCap,\r\n            bonus: 20,\r\n            maxPriorityId: 5000,\r\n            priorityDate: uint256(1533546000).add(48 hours) // 6th of August, 9:00 UTC + 48 hours\r\n        }));\r\n\r\n        icoTokensLeft = icoTokensLeft.sub(stageCap);\r\n\r\n        token = OrcaToken(_token);\r\n        whitelist = Whitelist(_whitelist);\r\n        timelock = new ERC777TokenScheduledTimelock(_token);\r\n    }\r\n\r\n    function initialize() public onlyOwner {\r\n        require(!initialized);\r\n\r\n        token.mint(timelock, TEAM_TOKENS, '');\r\n        timelock.scheduleTimelock(TEAM_WALLET, TEAM_TOKENS, TEAM_TOKEN_LOCK_DATE);\r\n\r\n        token.mint(ADVISORS_WALLET, ADVISORS_TOKENS, '');\r\n        token.mint(PARTNER_WALLET, PARTNER_TOKENS, '');\r\n\r\n        communityLock = new CommunityLock(token);\r\n        token.mint(communityLock, COMMUNITY_TOKENS, '');\r\n\r\n        initialized = true;\r\n    }\r\n\r\n    function () external payable {\r\n        buyTokens(msg.sender);\r\n    }\r\n\r\n    function mintPreSaleTokens(address[] _receivers, uint256[] _amounts, uint256[] _lockPeroids) external onlyInitialized {\r\n        require(msg.sender == tokenMinter || msg.sender == owner);\r\n        require(_receivers.length > 0 && _receivers.length <= 100);\r\n        require(_receivers.length == _amounts.length);\r\n        require(_receivers.length == _lockPeroids.length);\r\n        require(!isFinalized);\r\n        uint256 tokensInBatch = 0;\r\n        for (uint256 i = 0; i < _amounts.length; i++) {\r\n            tokensInBatch = tokensInBatch.add(_amounts[i]);\r\n        }\r\n        require(preSaleTokens >= tokensInBatch);\r\n\r\n        preSaleTokens = preSaleTokens.sub(tokensInBatch);\r\n        token.mint(timelock, tokensInBatch, '');\r\n\r\n        address receiver;\r\n        uint256 lockTill;\r\n        uint256 timestamp = getNow();\r\n        for (i = 0; i < _receivers.length; i++) {\r\n            receiver = _receivers[i];\r\n            require(receiver != address(0));\r\n\r\n            lockTill = _lockPeroids[i];\r\n            require(lockTill > timestamp);\r\n\r\n            timelock.scheduleTimelock(receiver, _amounts[i], lockTill);\r\n        }\r\n    }\r\n\r\n    function mintToken(address _receiver, uint256 _amount) external onlyInitialized {\r\n        require(msg.sender == tokenMinter || msg.sender == owner);\r\n        require(!isFinalized);\r\n        require(_receiver != address(0));\r\n        require(_amount > 0);\r\n\r\n        ensureCurrentStage();\r\n\r\n        uint256 excessTokens = updateStageCap(_amount);\r\n\r\n        token.mint(_receiver, _amount.sub(excessTokens), '');\r\n\r\n        if (excessTokens > 0) {\r\n            emit ManualTokenMintRequiresRefund(_receiver, excessTokens); // solhint-disable-line\r\n        }\r\n    }\r\n\r\n    function mintTokens(address[] _receivers, uint256[] _amounts) external onlyInitialized {\r\n        require(msg.sender == tokenMinter || msg.sender == owner);\r\n        require(_receivers.length > 0 && _receivers.length <= 100);\r\n        require(_receivers.length == _amounts.length);\r\n        require(!isFinalized);\r\n\r\n        ensureCurrentStage();\r\n\r\n        address receiver;\r\n        uint256 amount;\r\n        uint256 excessTokens;\r\n\r\n        for (uint256 i = 0; i < _receivers.length; i++) {\r\n            receiver = _receivers[i];\r\n            amount = _amounts[i];\r\n\r\n            require(receiver != address(0));\r\n            require(amount > 0);\r\n\r\n            excessTokens = updateStageCap(amount);\r\n\r\n            uint256 tokens = amount.sub(excessTokens);\r\n\r\n            token.mint(receiver, tokens, '');\r\n\r\n            if (excessTokens > 0) {\r\n                emit ManualTokenMintRequiresRefund(receiver, excessTokens); // solhint-disable-line\r\n            }\r\n        }\r\n    }\r\n\r\n    function mintBounty(address[] _receivers, uint256[] _amounts) external onlyInitialized {\r\n        require(msg.sender == tokenMinter || msg.sender == owner);\r\n        require(_receivers.length > 0 && _receivers.length <= 100);\r\n        require(_receivers.length == _amounts.length);\r\n        require(!isFinalized);\r\n        require(bountyTokensLeft > 0);\r\n\r\n        uint256 tokensLeft = bountyTokensLeft;\r\n        address receiver;\r\n        uint256 amount;\r\n        for (uint256 i = 0; i < _receivers.length; i++) {\r\n            receiver = _receivers[i];\r\n            amount = _amounts[i];\r\n\r\n            require(receiver != address(0));\r\n            require(amount > 0);\r\n\r\n            tokensLeft = tokensLeft.sub(amount);\r\n            bountyBalances[receiver] = bountyBalances[receiver].add(amount);\r\n        }\r\n\r\n        bountyTokensLeft = tokensLeft;\r\n    }\r\n\r\n    function buyTokens(address _beneficiary) public payable onlyInitialized {\r\n        require(_beneficiary != address(0));\r\n        ensureCurrentStage();\r\n        validatePurchase();\r\n        uint256 weiReceived = msg.value;\r\n        uint256 usdReceived = weiToUsd(weiReceived);\r\n\r\n        uint8 stageIndex = currentStage;\r\n\r\n        uint256 tokens = usdToTokens(usdReceived, stageIndex);\r\n        uint256 weiToReturn = 0;\r\n\r\n        uint256 excessTokens = updateStageCap(tokens);\r\n\r\n        if (excessTokens > 0) {\r\n            uint256 usdToReturn = tokensToUsd(excessTokens, stageIndex);\r\n            usdReceived = usdReceived.sub(usdToReturn);\r\n            weiToReturn = weiToReturn.add(usdToWei(usdToReturn));\r\n            weiReceived = weiReceived.sub(weiToReturn);\r\n            tokens = tokens.sub(excessTokens);\r\n        }\r\n\r\n        token.mint(_beneficiary, tokens, '');\r\n\r\n        WALLET.transfer(weiReceived);\r\n        emit TokenPurchase(msg.sender, _beneficiary, weiReceived, usdReceived, exchangeRate, tokens); // solhint-disable-line\r\n        if (weiToReturn > 0) {\r\n            msg.sender.transfer(weiToReturn);\r\n        }\r\n    }\r\n\r\n    function ensureCurrentStage() internal {\r\n        uint256 currentTime = getNow();\r\n        uint256 stageCount = stages.length;\r\n\r\n        uint8 curStage = currentStage;\r\n        uint8 nextStage = curStage + 1;\r\n\r\n        while (nextStage < stageCount && stages[nextStage].startDate <= currentTime) {\r\n            stages[nextStage].cap = stages[nextStage].cap.add(stages[curStage].cap);\r\n            curStage = nextStage;\r\n            nextStage = nextStage + 1;\r\n        }\r\n        if (currentStage != curStage) {\r\n            currentStage = curStage;\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Must be called after crowdsale ends, to do some extra finalization\r\n    * work. Calls the contract's finalization function.\r\n    */\r\n    function finalize() public onlyOwner onlyInitialized {\r\n        require(!isFinalized);\r\n        require(preSaleTokens == 0);\r\n        Stage storage lastStage = stages[stages.length - 1];\r\n        require(getNow() >= lastStage.endDate || (lastStage.cap == 0 && icoTokensLeft == 0));\r\n\r\n        token.finishMinting();\r\n        token.transferOwnership(owner);\r\n        communityLock.transferOwnership(owner); // only in finalize just to be sure that it is the same owner as crowdsale\r\n\r\n        emit Finalized(); // solhint-disable-line\r\n\r\n        isFinalized = true;\r\n    }\r\n\r\n    function setTokenMinter(address _tokenMinter) public onlyOwner onlyInitialized {\r\n        require(_tokenMinter != address(0));\r\n        tokenMinter = _tokenMinter;\r\n    }\r\n\r\n    function claimBounty(address beneficiary) public onlyInitialized {\r\n        uint256 balance = bountyBalances[beneficiary];\r\n        require(balance > 0);\r\n        bountyBalances[beneficiary] = 0;\r\n\r\n        token.mint(beneficiary, balance, '');\r\n    }\r\n\r\n    /// @notice Updates current stage cap and returns amount of excess tokens if ICO does not have enough tokens\r\n    function updateStageCap(uint256 _tokens) internal returns (uint256) {\r\n        Stage storage stage = stages[currentStage];\r\n        uint256 cap = stage.cap;\r\n        // normal situation, early exit\r\n        if (cap >= _tokens) {\r\n            stage.cap = cap.sub(_tokens);\r\n            return 0;\r\n        }\r\n\r\n        stage.cap = 0;\r\n        uint256 excessTokens = _tokens.sub(cap);\r\n        if (icoTokensLeft >= excessTokens) {\r\n            icoTokensLeft = icoTokensLeft.sub(excessTokens);\r\n            return 0;\r\n        }\r\n        icoTokensLeft = 0;\r\n        return excessTokens.sub(icoTokensLeft);\r\n    }\r\n\r\n    function weiToUsd(uint256 _wei) internal view returns (uint256) {\r\n        return _wei.mul(exchangeRate).div(10 ** uint256(EXCHANGE_RATE_DECIMALS));\r\n    }\r\n\r\n    function usdToWei(uint256 _usd) internal view returns (uint256) {\r\n        return _usd.mul(10 ** uint256(EXCHANGE_RATE_DECIMALS)).div(exchangeRate);\r\n    }\r\n\r\n    function usdToTokens(uint256 _usd, uint8 _stage) internal view returns (uint256) {\r\n        return _usd.mul(stages[_stage].bonus + 100).div(TOKEN_PRICE);\r\n    }\r\n\r\n    function tokensToUsd(uint256 _tokens, uint8 _stage) internal view returns (uint256) {\r\n        return _tokens.mul(TOKEN_PRICE).div(stages[_stage].bonus + 100);\r\n    }\r\n\r\n    function addStage(uint256 startDate, uint256 endDate, uint256 cap, uint64 bonus, uint64 maxPriorityId, uint256 priorityTime) public onlyOwner onlyInitialized {\r\n        require(!isFinalized);\r\n        require(startDate > getNow());\r\n        require(endDate > startDate);\r\n        Stage storage lastStage = stages[stages.length - 1];\r\n        require(startDate > lastStage.endDate);\r\n        require(startDate.add(priorityTime) <= endDate);\r\n        require(icoTokensLeft >= cap);\r\n        require(maxPriorityId >= lastStage.maxPriorityId);\r\n\r\n        stages.push(Stage({\r\n            startDate: startDate,\r\n            endDate: endDate,\r\n            cap: cap,\r\n            bonus: bonus,\r\n            maxPriorityId: maxPriorityId,\r\n            priorityDate: startDate.add(priorityTime)\r\n        }));\r\n    }\r\n\r\n    function validatePurchase() internal view {\r\n        require(!isFinalized);\r\n        require(msg.value != 0);\r\n\r\n        require(currentStage < stages.length);\r\n        Stage storage stage = stages[currentStage];\r\n        require(stage.cap > 0);\r\n\r\n        uint256 currentTime = getNow();\r\n        require(stage.startDate <= currentTime && currentTime <= stage.endDate);\r\n\r\n        uint256 userId = whitelist.whitelist(msg.sender);\r\n        require(userId > 0);\r\n        if (stage.priorityDate > currentTime) {\r\n            require(userId < stage.maxPriorityId);\r\n        }\r\n    }\r\n\r\n    function setPreSaleTokens(uint256 amount) public onlyOwner onlyInitialized {\r\n        require(!isPreSaleTokenSet);\r\n        require(amount > 0);\r\n        preSaleTokens = amount;\r\n        isPreSaleTokenSet = true;\r\n    }\r\n\r\n    function getStageCount() public view returns (uint256) {\r\n        return stages.length;\r\n    }\r\n\r\n    function getNow() internal view returns (uint256) {\r\n        return now; // solhint-disable-line\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"icoTokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"setPreSaleTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"preSaleTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"initialized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getStageCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRateOracle\",\"type\":\"address\"}],\"name\":\"setExchangeRateOracle\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"mintBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"recoverTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityLock\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXCHANGE_RATE_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenMinter\",\"type\":\"address\"}],\"name\":\"setTokenMinter\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receiver\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mintToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"initialize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stages\",\"outputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"endDate\",\"type\":\"uint256\"},{\"name\":\"priorityDate\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"bonus\",\"type\":\"uint64\"},{\"name\":\"maxPriorityId\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"whitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"beneficiary\",\"type\":\"address\"}],\"name\":\"claimBounty\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bountyTokensLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"startDate\",\"type\":\"uint256\"},{\"name\":\"endDate\",\"type\":\"uint256\"},{\"name\":\"cap\",\"type\":\"uint256\"},{\"name\":\"bonus\",\"type\":\"uint64\"},{\"name\":\"maxPriorityId\",\"type\":\"uint64\"},{\"name\":\"priorityTime\",\"type\":\"uint256\"}],\"name\":\"addStage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenMinter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelock\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_exchangeRate\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isPreSaleTokenSet\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_receivers\",\"type\":\"address[]\"},{\"name\":\"_amounts\",\"type\":\"uint256[]\"},{\"name\":\"_lockPeroids\",\"type\":\"uint256[]\"}],\"name\":\"mintPreSaleTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"bountyBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRateOracle\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_whitelist\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"weis\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"usd\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"rate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"ManualTokenMintRequiresRefund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogUI\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"OrcaCrowdsale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000006f59e0461ae5e2799f1fb3847f05a63b16d0dbf80000000000000000000000001758e5afccd53f6eaaa3039bc44d0e1f7bf6e476","Library":"","SwarmSource":"bzzr://68d63841c963605f8dd2183fffc6f659bbd4880fc117a431ec40800c243619c7"}]}