{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract TeamDreamHub {\r\n    using SafeMath for uint256;\r\n    \r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .\r\n//=============================|================================================    \r\n\taddress private owner;\r\n\tuint256 maxShareHolder = 100;\r\n    mapping(uint256 => ShareHolder) public shareHolderTable;\t\r\n\r\n\tstruct ShareHolder {\r\n        address targetAddr;  // target address\r\n        uint256 ratio; \t\t // profit ‰\r\n    }\t\r\n//==============================================================================\r\n//     _ _  _  __|_ _    __|_ _  _  .\r\n//    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy)\r\n//==============================================================================    \r\n    constructor()\r\n        public\r\n    {\r\n\t\towner = msg.sender;\r\n    }\r\n//==============================================================================\r\n//     _ _  _  _|. |`. _  _ _  .\r\n//    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks)\r\n//==============================================================================    \r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n\t\trequire (_addr == tx.origin);\r\n\t\t\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }    \r\n\t\r\n\tmodifier onlyOwner() {\r\n\t\trequire (msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t\r\n//==============================================================================\r\n//     _    |_ |. _   |`    _  __|_. _  _  _  .\r\n//    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract)\r\n//====|=========================================================================\r\n\r\n    /**\r\n     * @dev fallback function\r\n     */\r\n    function()      \r\n\t\tisHuman()\r\n        public\r\n        payable\r\n    {\r\n\t\t// if use this through SC, will fail because gas not enough.\r\n\t\tdistribute(msg.value);\r\n    }\r\n\t\r\n    function deposit()\r\n        external\r\n        payable\r\n    {\r\n\t\tdistribute(msg.value);\r\n    }\r\n\t\r\n\tfunction distribute(uint256 _totalInput)\r\n        private\r\n    {\t\t\r\n\t\tuint256 _toBeDistribute = _totalInput;\r\n\t\t\r\n\t\tuint256 fund;\r\n\t\taddress targetAddress;\r\n\t\tfor (uint i = 0 ; i < maxShareHolder; i++) {\t\t\t\r\n\t\t\ttargetAddress = shareHolderTable[i].targetAddr;\r\n\t\t\tif(targetAddress != address(0))\r\n\t\t\t{\r\n\t\t\t\tfund = _totalInput.mul(shareHolderTable[i].ratio) / 100;\t\t\t\r\n\t\t\t\ttargetAddress.transfer(fund);\r\n\t\t\t\t_toBeDistribute = _toBeDistribute.sub(fund);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t\tbreak;\r\n\t\t}\t\t\r\n        \r\n\t\t//remainder to contract owner\r\n\t\towner.transfer(_toBeDistribute);\t\r\n    }\r\n\t\r\n\t\r\n\t//setup the target addresses abd ratio (sum = 100%)\r\n    function updateEntry(uint256 tableIdx, address _targetAddress, uint256 _ratio)\r\n        onlyOwner()\r\n        public\r\n    {\r\n\t\trequire (tableIdx < maxShareHolder);\r\n\t\trequire (_targetAddress != address(0));\r\n\t\trequire (_ratio <= 100);\r\n\t\t\r\n\t\tuint256 totalShare = 0;\t\t\r\n\t\tfor (uint i = 0 ; i < maxShareHolder; i++) {\r\n\t\t\tif(i != tableIdx)\r\n\t\t\t\ttotalShare += shareHolderTable[i].ratio;\r\n\t\t\telse\r\n\t\t\t\ttotalShare += _ratio;\r\n\t\t\t\r\n\t\t\tif(totalShare > 100) // if larger than 100%, should REJECT\r\n\t\t\t\trevert('totalShare is larger than 100.');\r\n\t\t}\r\n\t\t\r\n\t\tshareHolderTable[tableIdx] = ShareHolder(_targetAddress,_ratio);        \r\n    }\t\r\n\t\r\n\t//function removeEntry(uint256 tableIdx)\r\n    //    onlyOwner()\r\n    //    public\r\n    //{\r\n\t//\trequire (tableIdx < maxShareHolder);\r\n\t//\t\t\t\r\n    //    shareHolderTable[tableIdx] = ShareHolder(address(0),0);\r\n    //}\t\t\r\n}\r\n\r\n//==============================================================================\r\n// ╔═╗┌─┐┌┐┌┌┬┐┬─┐┌─┐┌─┐┌┬┐  ╔═╗┌─┐┌┬┐┌─┐ \r\n// ║  │ ││││ │ ├┬┘├─┤│   │   ║  │ │ ││├┤  \r\n// ╚═╝└─┘┘└┘ ┴ ┴└─┴ ┴└─┘ ┴   ╚═╝└─┘─┴┘└─┘ \r\n//==============================================================================\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"shareHolderTable\",\"outputs\":[{\"name\":\"targetAddr\",\"type\":\"address\"},{\"name\":\"ratio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tableIdx\",\"type\":\"uint256\"},{\"name\":\"_targetAddress\",\"type\":\"address\"},{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"updateEntry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"TeamDreamHub","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://5db71d5ed660bf04d338aac98af289ad8499787e5e89148704fc6d0bd9f3d693"}]}