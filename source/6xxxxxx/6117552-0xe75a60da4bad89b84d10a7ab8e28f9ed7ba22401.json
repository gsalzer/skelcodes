{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.21;\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ninterface P3DTakeout {\r\n    function buyTokens() external payable;\r\n}\r\n\r\ncontract Betting {\r\n    using SafeMath for uint256; //using safemath\r\n\r\n    address public owner; //owner address\r\n    address house_takeout = 0xf783A81F046448c38f3c863885D9e99D10209779;\r\n    P3DTakeout P3DContract_;\r\n\r\n    uint public winnerPoolTotal;\r\n    string public constant version = \"0.2.3\";\r\n\r\n    struct chronus_info {\r\n        bool  betting_open; // boolean: check if betting is open\r\n        bool  race_start; //boolean: check if race has started\r\n        bool  race_end; //boolean: check if race has ended\r\n        bool  voided_bet; //boolean: check if race has been voided\r\n        uint32  starting_time; // timestamp of when the race starts\r\n        uint32  betting_duration;\r\n        uint32  race_duration; // duration of the race\r\n        uint32 voided_timestamp;\r\n    }\r\n\r\n    struct horses_info{\r\n        int64  BTC_delta; //horses.BTC delta value\r\n        int64  ETH_delta; //horses.ETH delta value\r\n        int64  LTC_delta; //horses.LTC delta value\r\n        bytes32 BTC; //32-bytes equivalent of horses.BTC\r\n        bytes32 ETH; //32-bytes equivalent of horses.ETH\r\n        bytes32 LTC;  //32-bytes equivalent of horses.LTC\r\n    }\r\n\r\n    struct bet_info{\r\n        bytes32 horse; // coin on which amount is bet on\r\n        uint amount; // amount bet by Bettor\r\n    }\r\n    struct coin_info{\r\n        uint256 pre; // locking price\r\n        uint256 post; // ending price\r\n        uint160 total; // total coin pool\r\n        uint32 count; // number of bets\r\n        bool price_check;\r\n    }\r\n    struct voter_info {\r\n        uint160 total_bet; //total amount of bet placed\r\n        bool rewarded; // boolean: check for double spending\r\n        mapping(bytes32=>uint) bets; //array of bets\r\n    }\r\n\r\n    mapping (bytes32 => coin_info) public coinIndex; // mapping coins with pool information\r\n    mapping (address => voter_info) voterIndex; // mapping voter address with Bettor information\r\n\r\n    uint public total_reward; // total reward to be awarded\r\n    uint32 total_bettors;\r\n    mapping (bytes32 => bool) public winner_horse;\r\n\r\n\r\n    // tracking events\r\n    event Deposit(address _from, uint256 _value, bytes32 _horse, uint256 _date);\r\n    event Withdraw(address _to, uint256 _value);\r\n    event PriceCallback(bytes32 coin_pointer, uint256 result, bool isPrePrice);\r\n    event RefundEnabled(string reason);\r\n\r\n    // constructor\r\n    constructor() public payable {\r\n        \r\n        owner = msg.sender;\r\n        \r\n        horses.BTC = bytes32(\"BTC\");\r\n        horses.ETH = bytes32(\"ETH\");\r\n        horses.LTC = bytes32(\"LTC\");\r\n        \r\n        P3DContract_ = P3DTakeout(0x72b2670e55139934D6445348DC6EaB4089B12576);\r\n    }\r\n\r\n    // data access structures\r\n    horses_info public horses;\r\n    chronus_info public chronus;\r\n\r\n    // modifiers for restricting access to methods\r\n    modifier onlyOwner {\r\n        require(owner == msg.sender);\r\n        _;\r\n    }\r\n\r\n    modifier duringBetting {\r\n        require(chronus.betting_open);\r\n        require(now < chronus.starting_time + chronus.betting_duration);\r\n        _;\r\n    }\r\n\r\n    modifier beforeBetting {\r\n        require(!chronus.betting_open && !chronus.race_start);\r\n        _;\r\n    }\r\n\r\n    modifier afterRace {\r\n        require(chronus.race_end);\r\n        _;\r\n    }\r\n\r\n    //function to change owner\r\n    function changeOwnership(address _newOwner) onlyOwner external {\r\n        owner = _newOwner;\r\n    }\r\n\r\n    function priceCallback (bytes32 coin_pointer, uint256 result, bool isPrePrice ) external onlyOwner {\r\n        require (!chronus.race_end);\r\n        emit PriceCallback(coin_pointer, result, isPrePrice);\r\n        chronus.race_start = true;\r\n        chronus.betting_open = false;\r\n        if (isPrePrice) {\r\n            if (now >= chronus.starting_time+chronus.betting_duration+ 60 minutes) {\r\n                emit RefundEnabled(\"Late start price\");\r\n                forceVoidRace();\r\n            } else {\r\n                coinIndex[coin_pointer].pre = result;\r\n            }\r\n        } else if (!isPrePrice){\r\n            if (coinIndex[coin_pointer].pre > 0 ){\r\n                if (now >= chronus.starting_time+chronus.race_duration+ 60 minutes) {\r\n                    emit RefundEnabled(\"Late end price\");\r\n                    forceVoidRace();\r\n                } else {\r\n                    coinIndex[coin_pointer].post = result;\r\n                    coinIndex[coin_pointer].price_check = true;\r\n\r\n                    if (coinIndex[horses.ETH].price_check && coinIndex[horses.BTC].price_check && coinIndex[horses.LTC].price_check) {\r\n                        reward();\r\n                    }\r\n                }\r\n            } else {\r\n                emit RefundEnabled(\"End price came before start price\");\r\n                forceVoidRace();\r\n            }\r\n        }\r\n    }\r\n\r\n    // place a bet on a coin(horse) lockBetting\r\n    function placeBet(bytes32 horse) external duringBetting payable  {\r\n        require(msg.value >= 0.01 ether);\r\n        if (voterIndex[msg.sender].total_bet==0) {\r\n            total_bettors+=1;\r\n        }\r\n        uint _newAmount = voterIndex[msg.sender].bets[horse] + msg.value;\r\n        voterIndex[msg.sender].bets[horse] = _newAmount;\r\n        voterIndex[msg.sender].total_bet += uint160(msg.value);\r\n        uint160 _newTotal = coinIndex[horse].total + uint160(msg.value);\r\n        uint32 _newCount = coinIndex[horse].count + 1;\r\n        coinIndex[horse].total = _newTotal;\r\n        coinIndex[horse].count = _newCount;\r\n        emit Deposit(msg.sender, msg.value, horse, now);\r\n    }\r\n\r\n    // fallback method for accepting payments\r\n    function () private payable {}\r\n\r\n    // method to place the oraclize queries\r\n    function setupRace(uint32 _bettingDuration, uint32 _raceDuration) onlyOwner beforeBetting external payable {\r\n            chronus.starting_time = uint32(block.timestamp);\r\n            chronus.betting_open = true;\r\n            chronus.betting_duration = _bettingDuration;\r\n            chronus.race_duration = _raceDuration;\r\n    }\r\n\r\n    // method to calculate reward (called internally by callback)\r\n    function reward() internal {\r\n        /*\r\n        calculating the difference in price with a precision of 5 digits\r\n        not using safemath since signed integers are handled\r\n        */\r\n        horses.BTC_delta = int64(coinIndex[horses.BTC].post - coinIndex[horses.BTC].pre)*100000/int64(coinIndex[horses.BTC].pre);\r\n        horses.ETH_delta = int64(coinIndex[horses.ETH].post - coinIndex[horses.ETH].pre)*100000/int64(coinIndex[horses.ETH].pre);\r\n        horses.LTC_delta = int64(coinIndex[horses.LTC].post - coinIndex[horses.LTC].pre)*100000/int64(coinIndex[horses.LTC].pre);\r\n\r\n        total_reward = (coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total);\r\n        if (total_bettors <= 1) {\r\n            emit RefundEnabled(\"Not enough participants\");\r\n            forceVoidRace();\r\n        } else {\r\n            // house takeout\r\n            uint house_fee = total_reward.mul(5).div(100);\r\n            require(house_fee < address(this).balance);\r\n            total_reward = total_reward.sub(house_fee);\r\n            house_takeout.transfer(house_fee);\r\n            \r\n            // p3d takeout\r\n            uint p3d_fee = house_fee/2;\r\n            require(p3d_fee < address(this).balance);\r\n            total_reward = total_reward.sub(p3d_fee);\r\n            P3DContract_.buyTokens.value(p3d_fee)();\r\n        }\r\n\r\n        if (horses.BTC_delta > horses.ETH_delta) {\r\n            if (horses.BTC_delta > horses.LTC_delta) {\r\n                winner_horse[horses.BTC] = true;\r\n                winnerPoolTotal = coinIndex[horses.BTC].total;\r\n            }\r\n            else if(horses.LTC_delta > horses.BTC_delta) {\r\n                winner_horse[horses.LTC] = true;\r\n                winnerPoolTotal = coinIndex[horses.LTC].total;\r\n            } else {\r\n                winner_horse[horses.BTC] = true;\r\n                winner_horse[horses.LTC] = true;\r\n                winnerPoolTotal = coinIndex[horses.BTC].total + (coinIndex[horses.LTC].total);\r\n            }\r\n        } else if(horses.ETH_delta > horses.BTC_delta) {\r\n            if (horses.ETH_delta > horses.LTC_delta) {\r\n                winner_horse[horses.ETH] = true;\r\n                winnerPoolTotal = coinIndex[horses.ETH].total;\r\n            }\r\n            else if (horses.LTC_delta > horses.ETH_delta) {\r\n                winner_horse[horses.LTC] = true;\r\n                winnerPoolTotal = coinIndex[horses.LTC].total;\r\n            } else {\r\n                winner_horse[horses.ETH] = true;\r\n                winner_horse[horses.LTC] = true;\r\n                winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.LTC].total);\r\n            }\r\n        } else {\r\n            if (horses.LTC_delta > horses.ETH_delta) {\r\n                winner_horse[horses.LTC] = true;\r\n                winnerPoolTotal = coinIndex[horses.LTC].total;\r\n            } else if(horses.LTC_delta < horses.ETH_delta){\r\n                winner_horse[horses.ETH] = true;\r\n                winner_horse[horses.BTC] = true;\r\n                winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.BTC].total);\r\n            } else {\r\n                winner_horse[horses.LTC] = true;\r\n                winner_horse[horses.ETH] = true;\r\n                winner_horse[horses.BTC] = true;\r\n                winnerPoolTotal = coinIndex[horses.ETH].total + (coinIndex[horses.BTC].total) + (coinIndex[horses.LTC].total);\r\n            }\r\n        }\r\n        chronus.race_end = true;\r\n    }\r\n\r\n    // method to calculate an invidual's reward\r\n    function calculateReward(address candidate) internal afterRace constant returns(uint winner_reward) {\r\n        voter_info storage bettor = voterIndex[candidate];\r\n        if(chronus.voided_bet) {\r\n            winner_reward = bettor.total_bet;\r\n        } else {\r\n            uint winning_bet_total;\r\n            if(winner_horse[horses.BTC]) {\r\n                winning_bet_total += bettor.bets[horses.BTC];\r\n            } if(winner_horse[horses.ETH]) {\r\n                winning_bet_total += bettor.bets[horses.ETH];\r\n            } if(winner_horse[horses.LTC]) {\r\n                winning_bet_total += bettor.bets[horses.LTC];\r\n            }\r\n            winner_reward += (((total_reward.mul(10000000)).div(winnerPoolTotal)).mul(winning_bet_total)).div(10000000);\r\n        }\r\n    }\r\n\r\n    // method to just check the reward amount\r\n    function checkReward() afterRace external constant returns (uint) {\r\n        require(!voterIndex[msg.sender].rewarded);\r\n        return calculateReward(msg.sender);\r\n    }\r\n\r\n    // method to claim the reward amount\r\n    function claim_reward() afterRace external {\r\n        require(!voterIndex[msg.sender].rewarded);\r\n        uint transfer_amount = calculateReward(msg.sender);\r\n        require(address(this).balance >= transfer_amount);\r\n        voterIndex[msg.sender].rewarded = true;\r\n        msg.sender.transfer(transfer_amount);\r\n        emit Withdraw(msg.sender, transfer_amount);\r\n    }\r\n\r\n    function forceVoidRace() internal {\r\n        chronus.voided_bet=true;\r\n        chronus.race_end = true;\r\n        chronus.voided_timestamp=uint32(now);\r\n    }\r\n\r\n    // exposing the coin pool details for DApp\r\n    function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) {\r\n        uint256 coinPrePrice;\r\n        uint256 coinPostPrice;\r\n        if (coinIndex[horses.ETH].pre > 0 && coinIndex[horses.BTC].pre > 0 && coinIndex[horses.LTC].pre > 0) {\r\n            coinPrePrice = coinIndex[index].pre;\r\n        } \r\n        if (coinIndex[horses.ETH].post > 0 && coinIndex[horses.BTC].post > 0 && coinIndex[horses.LTC].post > 0) {\r\n            coinPostPrice = coinIndex[index].post;\r\n        }\r\n        return (coinIndex[index].total, coinPrePrice, coinPostPrice, coinIndex[index].price_check, voterIndex[candidate].bets[index]);\r\n    }\r\n\r\n    // exposing the total reward amount for DApp\r\n    function reward_total() external constant returns (uint) {\r\n        return ((coinIndex[horses.BTC].total) + (coinIndex[horses.ETH].total) + (coinIndex[horses.LTC].total));\r\n    }\r\n\r\n    // in case of any errors in race, enable full refund for the Bettors to claim\r\n    function refund() external onlyOwner {\r\n        require(now > chronus.starting_time + chronus.race_duration);\r\n        require((chronus.betting_open && !chronus.race_start)\r\n            || (chronus.race_start && !chronus.race_end));\r\n        chronus.voided_bet = true;\r\n        chronus.race_end = true;\r\n        chronus.voided_timestamp=uint32(now);\r\n    }\r\n\r\n    // method to claim unclaimed winnings after 30 day notice period\r\n    function recovery() external onlyOwner{\r\n        require((chronus.race_end && now > chronus.starting_time + chronus.race_duration + (30 days))\r\n            || (chronus.voided_bet && now > chronus.voided_timestamp + (30 days)));\r\n        house_takeout.transfer(address(this).balance);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"horse\",\"type\":\"bytes32\"}],\"name\":\"placeBet\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim_reward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"winner_horse\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"coin_pointer\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"uint256\"},{\"name\":\"isPrePrice\",\"type\":\"bool\"}],\"name\":\"priceCallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"winnerPoolTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"horses\",\"outputs\":[{\"name\":\"BTC_delta\",\"type\":\"int64\"},{\"name\":\"ETH_delta\",\"type\":\"int64\"},{\"name\":\"LTC_delta\",\"type\":\"int64\"},{\"name\":\"BTC\",\"type\":\"bytes32\"},{\"name\":\"ETH\",\"type\":\"bytes32\"},{\"name\":\"LTC\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"index\",\"type\":\"bytes32\"},{\"name\":\"candidate\",\"type\":\"address\"}],\"name\":\"getCoinIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"chronus\",\"outputs\":[{\"name\":\"betting_open\",\"type\":\"bool\"},{\"name\":\"race_start\",\"type\":\"bool\"},{\"name\":\"race_end\",\"type\":\"bool\"},{\"name\":\"voided_bet\",\"type\":\"bool\"},{\"name\":\"starting_time\",\"type\":\"uint32\"},{\"name\":\"betting_duration\",\"type\":\"uint32\"},{\"name\":\"race_duration\",\"type\":\"uint32\"},{\"name\":\"voided_timestamp\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bettingDuration\",\"type\":\"uint32\"},{\"name\":\"_raceDuration\",\"type\":\"uint32\"}],\"name\":\"setupRace\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reward_total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"checkReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"coinIndex\",\"outputs\":[{\"name\":\"pre\",\"type\":\"uint256\"},{\"name\":\"post\",\"type\":\"uint256\"},{\"name\":\"total\",\"type\":\"uint160\"},{\"name\":\"count\",\"type\":\"uint32\"},{\"name\":\"price_check\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total_reward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"recovery\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_horse\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"coin_pointer\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isPrePrice\",\"type\":\"bool\"}],\"name\":\"PriceCallback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"reason\",\"type\":\"string\"}],\"name\":\"RefundEnabled\",\"type\":\"event\"}]","ContractName":"Betting","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e77d45ce6aa99d6d4a5bbc305898131a50902b0789baf26c30ca48bb6f9b9a22"}]}