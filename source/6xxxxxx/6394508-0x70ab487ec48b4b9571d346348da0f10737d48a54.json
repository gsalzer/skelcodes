{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n*\r\n* PredictionExchange is an exchange contract that doesn't accept bets on the outcomes,\r\n* but instead matchedes backers/takers (those betting on odds) with layers/makers \r\n* (those offering the odds).\r\n*\r\n* Note:\r\n*\r\n*       side: 0 (unknown), 1 (support), 2 (against), 3 (draw)\r\n*       role: 0 (unknown), 1 (maker), 2 (taker)\r\n*       state: 0 (unknown), 1 (created), 2 (reported), 3 (disputed)\r\n*       __test__* events will be removed prior to production deployment\r\n*       odds are rounded up (2.25 is 225)\r\n*\r\n*/\r\n\r\npragma solidity ^0.4.24;\r\n\r\ncontract PredictionHandshake {\r\n\r\n        struct Market {\r\n\r\n                address creator;\r\n                uint fee; \r\n                bytes32 source;\r\n                uint closingTime; \r\n                uint reportTime; \r\n                uint disputeTime;\r\n\r\n                uint state;\r\n                uint outcome;\r\n\r\n                uint totalMatchedStake;\r\n                uint totalOpenStake;\r\n                uint disputeMatchedStake;\r\n                bool resolved;\r\n                mapping(uint => uint) outcomeMatchedStake;\r\n                \r\n                mapping(address => mapping(uint => Order)) open; // address => side => order\r\n                mapping(address => mapping(uint => Order)) matched; // address => side => order\r\n                mapping(address => bool) disputed;\r\n        }\r\n        \r\n        \r\n        function getMatchedData(uint hid, uint side, address user, uint userOdds) public onlyRoot view returns \r\n        (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        ) \r\n        {\r\n            Market storage m = markets[hid];\r\n            Order storage o = m.matched[user][side];\r\n            // return (stake, payout, odds, pool size)\r\n            return (o.stake, o.payout, userOdds, o.odds[userOdds]);\r\n        }\r\n        \r\n        function getOpenData(uint hid, uint side, address user, uint userOdds) public onlyRoot view returns \r\n        (\r\n            uint256,\r\n            uint256,\r\n            uint256,\r\n            uint256\r\n        ) \r\n        {\r\n            Market storage m = markets[hid];\r\n            Order storage o = m.open[user][side];\r\n            // return (stake, payout, odds, pool size)\r\n            return (o.stake, o.payout, userOdds, o.odds[userOdds]);\r\n        }\r\n\r\n        struct Order {\r\n                uint stake;\r\n                uint payout;\r\n                mapping(uint => uint) odds; // odds => pool size\r\n        }\r\n\r\n        struct Trial {\r\n                uint hid;\r\n                uint side;\r\n                bool valid;\r\n                mapping(uint => uint) amt; // odds => amt\r\n                mapping(uint => uint) totalStakes; // hid => amt\r\n        }\r\n\r\n        uint public NETWORK_FEE = 20; // 20%\r\n        uint public ODDS_1 = 100; // 1.00 is 100; 2.25 is 225 \r\n        uint public DISPUTE_THRESHOLD = 50; // 50%\r\n        uint public EXPIRATION = 30 days; \r\n\r\n        Market[] public markets;\r\n        address public root;\r\n        uint256 public total;\r\n\r\n        mapping(address => Trial) trial;\r\n\r\n        constructor() public {\r\n                root = msg.sender;\r\n        } \r\n\r\n\r\n        event __createMarket(uint hid, uint closingTime, uint reportTime, uint disputeTime, bytes32 offchain);\r\n\r\n        function createMarket(\r\n                uint fee, \r\n                bytes32 source,\r\n                uint closingWindow, \r\n                uint reportWindow, \r\n                uint disputeWindow,\r\n                bytes32 offchain\r\n        ) \r\n                public \r\n        {\r\n                _createMarket(msg.sender, fee, source, closingWindow, reportWindow, disputeWindow, offchain);\r\n        }\r\n\r\n\r\n        function createMarketForShurikenUser(\r\n                address creator,\r\n                uint fee, \r\n                bytes32 source,\r\n                uint closingWindow, \r\n                uint reportWindow, \r\n                uint disputeWindow,\r\n                bytes32 offchain\r\n        ) \r\n                public \r\n                onlyRoot\r\n        {\r\n                _createMarket(creator, fee, source, closingWindow, reportWindow, disputeWindow, offchain);\r\n        }\r\n\r\n        function _createMarket(\r\n                address creator,\r\n                uint fee, \r\n                bytes32 source,\r\n                uint closingWindow, \r\n                uint reportWindow, \r\n                uint disputeWindow,\r\n                bytes32 offchain\r\n        ) \r\n                public \r\n        {\r\n                Market memory m;\r\n                m.creator = creator;\r\n                m.fee = fee;\r\n                m.source = source;\r\n                m.closingTime = now + closingWindow * 1 seconds;\r\n                m.reportTime = m.closingTime + reportWindow * 1 seconds;\r\n                m.disputeTime = m.reportTime + disputeWindow * 1 seconds;\r\n                m.state = 1;\r\n                markets.push(m);\r\n\r\n                emit __createMarket(markets.length - 1, m.closingTime, m.reportTime, m.disputeTime, offchain);\r\n        }\r\n\r\n\r\n        event __init(uint hid, bytes32 offchain);\r\n        event __test__init(uint stake);\r\n\r\n        // market maker\r\n        function init(\r\n                uint hid, \r\n                uint side, \r\n                uint odds, \r\n                bytes32 offchain\r\n        ) \r\n                public \r\n                payable \r\n        {\r\n                _init(hid, side, odds, msg.sender, offchain);\r\n        }\r\n\r\n\r\n        // market maker. only called by root.  \r\n        function initTestDrive(\r\n                uint hid, \r\n                uint side, \r\n                uint odds, \r\n                address maker, \r\n                bytes32 offchain\r\n        ) \r\n                public\r\n                payable\r\n                onlyRoot\r\n        {\r\n                trial[maker].hid = hid;\r\n                trial[maker].side = side;\r\n                trial[maker].amt[odds] += msg.value;\r\n                trial[maker].totalStakes[hid] += msg.value;\r\n                trial[maker].valid = true;\r\n\r\n                _init(hid, side, odds, maker, offchain);\r\n        }\r\n        \r\n        function uninitTestDrive\r\n        (\r\n            uint hid,\r\n            uint side,\r\n            uint odds,\r\n            address maker,\r\n            uint value,\r\n            bytes32 offchain\r\n        )\r\n            public\r\n            onlyRoot\r\n        {\r\n                // make sure trial is existed and currently betting.\r\n                require(trial[maker].hid == hid && trial[maker].side == side && trial[maker].amt[odds] > 0);\r\n                trial[maker].amt[odds] -= value;\r\n                trial[maker].totalStakes[hid] -= value;\r\n                \r\n                Market storage m = markets[hid];\r\n                \r\n                require(m.open[maker][side].stake >= value);\r\n                require(m.open[maker][side].odds[odds] >= value);\r\n                require(m.totalOpenStake >= value);\r\n\r\n                m.open[maker][side].stake -= value;\r\n                m.open[maker][side].odds[odds] -= value;\r\n                m.totalOpenStake -= value;\r\n\r\n                require(total + value >= total);\r\n                total += value;\r\n            \r\n                emit __uninit(hid, offchain);\r\n                emit __test__uninit(m.open[msg.sender][side].stake);\r\n        }\r\n        \r\n        event __withdrawTrial(uint256 amount);\r\n\r\n        function withdrawTrial() public onlyRoot {\r\n            root.transfer(total);\r\n            emit __withdrawTrial(total);\r\n            total = 0;\r\n        }\r\n        \r\n        // market maker cancels order\r\n        function uninit(\r\n                uint hid, \r\n                uint side, \r\n                uint stake, \r\n                uint odds, \r\n                bytes32 offchain\r\n        ) \r\n                public \r\n                onlyPredictor(hid) \r\n        {\r\n                Market storage m = markets[hid];\r\n\r\n                uint trialAmt; \r\n                if (trial[msg.sender].hid == hid && trial[msg.sender].side == side)\r\n                    trialAmt = trial[msg.sender].amt[odds];\r\n\r\n                require(m.open[msg.sender][side].stake - trialAmt >= stake);\r\n                require(m.open[msg.sender][side].odds[odds] - trialAmt >= stake);\r\n\r\n                m.open[msg.sender][side].stake -= stake;\r\n                m.open[msg.sender][side].odds[odds] -= stake;\r\n                m.totalOpenStake -= stake;\r\n\r\n                msg.sender.transfer(stake);\r\n\r\n                emit __uninit(hid, offchain);\r\n                emit __test__uninit(m.open[msg.sender][side].stake);\r\n        }\r\n\r\n\r\n        function _init(\r\n                uint hid, \r\n                uint side, \r\n                uint odds, \r\n                address maker, \r\n                bytes32 offchain\r\n        ) \r\n                private \r\n        {\r\n                Market storage m = markets[hid];\r\n\r\n                require(now < m.closingTime);\r\n                require(m.state == 1);\r\n\r\n                m.open[maker][side].stake += msg.value;\r\n                m.open[maker][side].odds[odds] += msg.value;\r\n                m.totalOpenStake += msg.value;\r\n\r\n                emit __init(hid, offchain);\r\n                emit __test__init(m.open[maker][side].stake);\r\n        }\r\n\r\n\r\n        event __uninit(uint hid, bytes32 offchain);\r\n        event __test__uninit(uint stake);\r\n\r\n        \r\n\r\n\r\n        event __shake(uint hid, bytes32 offchain);\r\n        event __test__shake__taker__matched(uint stake, uint payout);\r\n        event __test__shake__maker__matched(uint stake, uint payout);\r\n        event __test__shake__maker__open(uint stake);\r\n\r\n\r\n        // market taker\r\n        function shake(\r\n                uint hid, \r\n                uint side, \r\n                uint takerOdds, \r\n                address maker, \r\n                uint makerOdds, \r\n                bytes32 offchain\r\n        ) \r\n                public \r\n                payable \r\n        {\r\n                _shake(hid, side, msg.sender, takerOdds, maker, makerOdds, offchain);\r\n        }\r\n\r\n\r\n        function shakeTestDrive(\r\n                uint hid, \r\n                uint side, \r\n                address taker,\r\n                uint takerOdds, \r\n                address maker, \r\n                uint makerOdds, \r\n                bytes32 offchain\r\n        ) \r\n                public \r\n                payable \r\n                onlyRoot\r\n        {\r\n                trial[taker].hid = hid;\r\n                trial[taker].side = side;\r\n                trial[taker].amt[takerOdds] += msg.value;\r\n                trial[taker].totalStakes[hid] += msg.value;\r\n                trial[taker].valid = true;\r\n\r\n                _shake(hid, side, taker, takerOdds, maker, makerOdds, offchain);\r\n        }\r\n\r\n\r\n        function _shake(\r\n                uint hid, \r\n                uint side, \r\n                address taker,\r\n                uint takerOdds, \r\n                address maker, \r\n                uint makerOdds, \r\n                bytes32 offchain\r\n        ) \r\n                private \r\n        {\r\n                require(maker != 0);\r\n                require(takerOdds >= ODDS_1);\r\n                require(makerOdds >= ODDS_1);\r\n\r\n                Market storage m = markets[hid];\r\n\r\n                require(m.state == 1);\r\n                require(now < m.closingTime);\r\n\r\n                uint makerSide = 3 - side;\r\n\r\n                uint takerStake = msg.value;\r\n                uint makerStake = m.open[maker][makerSide].stake;\r\n\r\n                uint takerPayout = (takerStake * takerOdds) / ODDS_1;\r\n                uint makerPayout = (makerStake * makerOdds) / ODDS_1;\r\n\r\n                if (takerPayout < makerPayout) {\r\n                        makerStake = takerPayout - takerStake;\r\n                        makerPayout = takerPayout;\r\n                } else {\r\n                        takerStake = makerPayout - makerStake;\r\n                        takerPayout = makerPayout;\r\n                }\r\n\r\n                // check if the odds matching is valid\r\n                require(takerOdds * ODDS_1 >= makerOdds * (takerOdds - ODDS_1));\r\n\r\n                // check if the stake is sufficient\r\n                require(m.open[maker][makerSide].odds[makerOdds] >= makerStake);\r\n                require(m.open[maker][makerSide].stake >= makerStake);\r\n\r\n                // remove maker's order from open (could be partial)\r\n                m.open[maker][makerSide].odds[makerOdds] -= makerStake;\r\n                m.open[maker][makerSide].stake -= makerStake;\r\n                m.totalOpenStake -=  makerStake;\r\n\r\n                // add maker's order to matched\r\n                m.matched[maker][makerSide].odds[makerOdds] += makerStake;\r\n                m.matched[maker][makerSide].stake += makerStake;\r\n                m.matched[maker][makerSide].payout += makerPayout;\r\n                m.totalMatchedStake += makerStake;\r\n                m.outcomeMatchedStake[makerSide] += makerStake;\r\n\r\n                // add taker's order to matched\r\n                m.matched[taker][side].odds[takerOdds] += takerStake;\r\n                m.matched[taker][side].stake += takerStake;\r\n                m.matched[taker][side].payout += takerPayout;\r\n                m.totalMatchedStake += takerStake;\r\n                m.outcomeMatchedStake[side] += takerStake;\r\n\r\n                emit __shake(hid, offchain);\r\n\r\n                emit __test__shake__taker__matched(m.matched[taker][side].stake, m.matched[taker][side].payout);\r\n                emit __test__shake__maker__matched(m.matched[maker][makerSide].stake, m.matched[maker][makerSide].payout);\r\n                emit __test__shake__maker__open(m.open[maker][makerSide].stake);\r\n\r\n        }\r\n\r\n\r\n        event __collect(uint hid, bytes32 offchain);\r\n        event __test__collect(uint network, uint market, uint trader);\r\n\r\n        function collect(uint hid, bytes32 offchain) public onlyPredictor(hid) {\r\n                _collect(hid, msg.sender, offchain);\r\n        }\r\n\r\n        function collectTestDrive(uint hid, address winner, bytes32 offchain) public onlyRoot {\r\n                _collect(hid, winner, offchain);\r\n        }\r\n\r\n        // collect payouts & outstanding stakes (if there is outcome)\r\n        function _collect(uint hid, address winner, bytes32 offchain) private {\r\n                Market storage m = markets[hid]; \r\n\r\n                require(m.state == 2);\r\n                require(now > m.disputeTime);\r\n\r\n                // calc network commission, market commission and winnings\r\n                uint marketComm = (m.matched[winner][m.outcome].payout * m.fee) / 100;\r\n                uint networkComm = (marketComm * NETWORK_FEE) / 100;\r\n\r\n                uint amt = m.matched[winner][m.outcome].payout;\r\n\r\n                amt += m.open[winner][1].stake; \r\n                amt += m.open[winner][2].stake;\r\n\r\n                require(amt - marketComm >= 0);\r\n                require(marketComm - networkComm >= 0);\r\n\r\n                // update totals\r\n                m.totalOpenStake -= m.open[winner][1].stake;\r\n                m.totalOpenStake -= m.open[winner][2].stake;\r\n                m.totalMatchedStake -= m.matched[winner][1].stake;\r\n                m.totalMatchedStake -= m.matched[winner][2].stake;\r\n\r\n                // wipe data\r\n                m.open[winner][1].stake = 0; \r\n                m.open[winner][2].stake = 0;\r\n                m.matched[winner][1].stake = 0; \r\n                m.matched[winner][2].stake = 0;\r\n                m.matched[winner][m.outcome].payout = 0;\r\n\r\n                winner.transfer(amt - marketComm);\r\n                m.creator.transfer(marketComm - networkComm);\r\n                root.transfer(networkComm);\r\n\r\n                emit __collect(hid, offchain);\r\n                emit __test__collect(networkComm, marketComm - networkComm, amt - marketComm);\r\n        }\r\n\r\n\r\n        event __refund(uint hid, bytes32 offchain);\r\n        event __test__refund(uint amt);\r\n\r\n        // refund stakes when market closes (if there is no outcome)\r\n        function refund(uint hid, bytes32 offchain) public onlyPredictor(hid) {\r\n\r\n                Market storage m = markets[hid]; \r\n\r\n                require(m.state == 1 || m.outcome == 3);\r\n                require(now > m.reportTime);\r\n\r\n                // calc refund amt\r\n                uint amt;\r\n                amt += m.matched[msg.sender][1].stake;\r\n                amt += m.matched[msg.sender][2].stake;\r\n                amt += m.open[msg.sender][1].stake;\r\n                amt += m.open[msg.sender][2].stake;\r\n\r\n                require(amt > 0);\r\n\r\n                // wipe data\r\n                m.matched[msg.sender][1].stake = 0;\r\n                m.matched[msg.sender][2].stake = 0;\r\n                m.open[msg.sender][1].stake = 0;\r\n                m.open[msg.sender][2].stake = 0;\r\n\r\n                if(!(trial[msg.sender].valid)) {\r\n                        msg.sender.transfer(amt);\r\n                } else {\r\n                        uint trialAmt = trial[msg.sender].totalStakes[hid];\r\n                        amt = amt - trialAmt;\r\n                        require(amt > 0);\r\n                        msg.sender.transfer(amt);\r\n                }\r\n\r\n                emit __refund(hid, offchain);\r\n                emit __test__refund(amt);\r\n        }\r\n\r\n\r\n        event __report(uint hid, bytes32 offchain);\r\n\r\n        // report outcome\r\n        function report(uint hid, uint outcome, bytes32 offchain) public {\r\n                Market storage m = markets[hid]; \r\n                require(now <= m.reportTime);\r\n                require(msg.sender == m.creator);\r\n                require(m.state == 1);\r\n                m.outcome = outcome;\r\n                m.state = 2;\r\n                emit __report(hid, offchain);\r\n        }\r\n\r\n\r\n        event __dispute(uint hid, uint outcome, uint state, bytes32 offchain);\r\n\r\n\r\n        function disputeTestDrive(uint hid, address sender, bytes32 offchain) public onlyRoot {\r\n                require(trial[sender].hid == hid && trial[sender].valid);\r\n                _dispute(hid, sender, offchain);\r\n        }        \r\n\r\n        function dispute(uint hid, bytes32 offchain) public onlyPredictor(hid) {\r\n                _dispute(hid, msg.sender, offchain);\r\n        }\r\n\r\n        // dispute outcome\r\n        function _dispute(uint hid, address sender, bytes32 offchain) private {\r\n                Market storage m = markets[hid]; \r\n\r\n                require(now <= m.disputeTime);\r\n                require(m.state == 2);\r\n                require(!m.resolved);\r\n\r\n                require(!m.disputed[sender]);\r\n                m.disputed[sender] = true;\r\n\r\n                // make sure user places bet on this side\r\n                uint side = 3 - m.outcome;\r\n                uint stake = 0;\r\n                uint outcomeMatchedStake = 0;\r\n                if (side == 0) {\r\n                        stake = m.matched[sender][1].stake;   \r\n                        stake += m.matched[sender][2].stake;   \r\n                        outcomeMatchedStake = m.outcomeMatchedStake[1];\r\n                        outcomeMatchedStake += m.outcomeMatchedStake[2];\r\n\r\n                } else {\r\n                        stake = m.matched[sender][side].stake;   \r\n                        outcomeMatchedStake = m.outcomeMatchedStake[side];\r\n                }\r\n                require(stake > 0);\r\n                m.disputeMatchedStake += stake;\r\n\r\n                // if dispute stakes > 50% of the total stakes\r\n                if (100 * m.disputeMatchedStake > DISPUTE_THRESHOLD * outcomeMatchedStake) {\r\n                        m.state = 3;\r\n                }\r\n                emit __dispute(hid, m.outcome, m.state, offchain);\r\n        }\r\n\r\n\r\n        event __resolve(uint hid, bytes32 offchain);\r\n\r\n        function resolve(uint hid, uint outcome, bytes32 offchain) public onlyRoot {\r\n                Market storage m = markets[hid]; \r\n                require(m.state == 3);\r\n                require(outcome == 1 || outcome == 2 || outcome == 3);\r\n                m.resolved = true;\r\n                m.outcome = outcome;\r\n                m.state = 2;\r\n                emit __resolve(hid, offchain);\r\n        }\r\n\r\n\r\n        modifier onlyPredictor(uint hid) {\r\n                require(markets[hid].matched[msg.sender][1].stake > 0 || \r\n                        markets[hid].matched[msg.sender][2].stake > 0 || \r\n                        markets[hid].open[msg.sender][1].stake > 0 || \r\n                        markets[hid].open[msg.sender][2].stake > 0);\r\n                _;\r\n        }\r\n\r\n\r\n        modifier onlyRoot() {\r\n                require(msg.sender == root);\r\n                _;\r\n        }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"source\",\"type\":\"bytes32\"},{\"name\":\"closingWindow\",\"type\":\"uint256\"},{\"name\":\"reportWindow\",\"type\":\"uint256\"},{\"name\":\"disputeWindow\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"_createMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"total\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"uint256\"},{\"name\":\"odds\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"init\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"userOdds\",\"type\":\"uint256\"}],\"name\":\"getOpenData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTrial\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"winner\",\"type\":\"address\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"collectTestDrive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NETWORK_FEE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"uint256\"},{\"name\":\"taker\",\"type\":\"address\"},{\"name\":\"takerOdds\",\"type\":\"uint256\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerOdds\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"shakeTestDrive\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"source\",\"type\":\"bytes32\"},{\"name\":\"closingWindow\",\"type\":\"uint256\"},{\"name\":\"reportWindow\",\"type\":\"uint256\"},{\"name\":\"disputeWindow\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"createMarketForShurikenUser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"sender\",\"type\":\"address\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"disputeTestDrive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"uint256\"},{\"name\":\"stake\",\"type\":\"uint256\"},{\"name\":\"odds\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"uninit\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"outcome\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"resolve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"markets\",\"outputs\":[{\"name\":\"creator\",\"type\":\"address\"},{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"source\",\"type\":\"bytes32\"},{\"name\":\"closingTime\",\"type\":\"uint256\"},{\"name\":\"reportTime\",\"type\":\"uint256\"},{\"name\":\"disputeTime\",\"type\":\"uint256\"},{\"name\":\"state\",\"type\":\"uint256\"},{\"name\":\"outcome\",\"type\":\"uint256\"},{\"name\":\"totalMatchedStake\",\"type\":\"uint256\"},{\"name\":\"totalOpenStake\",\"type\":\"uint256\"},{\"name\":\"disputeMatchedStake\",\"type\":\"uint256\"},{\"name\":\"resolved\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"uint256\"},{\"name\":\"odds\",\"type\":\"uint256\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"initTestDrive\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DISPUTE_THRESHOLD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"EXPIRATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"fee\",\"type\":\"uint256\"},{\"name\":\"source\",\"type\":\"bytes32\"},{\"name\":\"closingWindow\",\"type\":\"uint256\"},{\"name\":\"reportWindow\",\"type\":\"uint256\"},{\"name\":\"disputeWindow\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"createMarket\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"userOdds\",\"type\":\"uint256\"}],\"name\":\"getMatchedData\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"outcome\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"report\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"dispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"uint256\"},{\"name\":\"takerOdds\",\"type\":\"uint256\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"makerOdds\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"shake\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"root\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"side\",\"type\":\"uint256\"},{\"name\":\"odds\",\"type\":\"uint256\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"uninitTestDrive\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"hid\",\"type\":\"uint256\"},{\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"collect\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ODDS_1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"closingTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reportTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"disputeTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__createMarket\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__init\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"__test__init\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"__withdrawTrial\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__uninit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"__test__uninit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__shake\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"__test__shake__taker__matched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payout\",\"type\":\"uint256\"}],\"name\":\"__test__shake__maker__matched\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"stake\",\"type\":\"uint256\"}],\"name\":\"__test__shake__maker__open\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__collect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"network\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"market\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"trader\",\"type\":\"uint256\"}],\"name\":\"__test__collect\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amt\",\"type\":\"uint256\"}],\"name\":\"__test__refund\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__report\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"outcome\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"state\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__dispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"hid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"offchain\",\"type\":\"bytes32\"}],\"name\":\"__resolve\",\"type\":\"event\"}]","ContractName":"PredictionHandshake","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://77cdea5c6ae80ab1bee8577ec1059a1cc22297d405088219b819fb4f013f7792"}]}