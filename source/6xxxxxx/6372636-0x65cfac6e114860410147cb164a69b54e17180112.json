{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n     return a / b;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Ownable {\r\n\taddress public owner;\r\n\taddress public newOwner;\r\n\r\n\tevent OwnershipTransferred(address indexed oldOwner, address indexed newOwner);\r\n\r\n\tconstructor() public {\r\n\t\towner = msg.sender;\r\n\t\tnewOwner = address(0);\r\n\t}\r\n\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner, \"msg.sender == owner\");\r\n\t\t_;\r\n\t}\r\n\r\n\tfunction transferOwnership(address _newOwner) public onlyOwner {\r\n\t\trequire(address(0) != _newOwner, \"address(0) != _newOwner\");\r\n\t\tnewOwner = _newOwner;\r\n\t}\r\n\r\n\tfunction acceptOwnership() public {\r\n\t\trequire(msg.sender == newOwner, \"msg.sender == newOwner\");\r\n\t\temit OwnershipTransferred(owner, msg.sender);\r\n\t\towner = msg.sender;\r\n\t\tnewOwner = address(0);\r\n\t}\r\n}\r\n\r\ncontract tokenInterface {\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool);\r\n\tfunction burn(uint256 _value) public returns(bool);\r\n\tuint256 public totalSupply;\r\n\tuint256 public decimals;\r\n}\r\n\r\ncontract AtomaxKycInterface {\r\n\r\n    // false if the ico is not started, true if the ico is started and running, true if the ico is completed\r\n    function started() public view returns(bool);\r\n\r\n    // false if the ico is not started, false if the ico is started and running, true if the ico is completed\r\n    function ended() public view returns(bool);\r\n\r\n    // time stamp of the starting time of the ico, must return 0 if it depends on the block number\r\n    function startTime() public view returns(uint256);\r\n\r\n    // time stamp of the ending time of the ico, must retrun 0 if it depends on the block number\r\n    function endTime() public view returns(uint256);\r\n\r\n    // returns the total number of the tokens available for the sale, must not change when the ico is started\r\n    function totalTokens() public view returns(uint256);\r\n\r\n    // returns the number of the tokens available for the ico. At the moment that the ico starts it must be equal to totalTokens(),\r\n    // then it will decrease. It is used to calculate the percentage of sold tokens as remainingTokens() / totalTokens()\r\n    function remainingTokens() public view returns(uint256);\r\n\r\n    // return the price as number of tokens released for each ether\r\n    function price() public view returns(uint256);\r\n}\r\n\r\ncontract AtomaxKyc {\r\n    using SafeMath for uint256;\r\n\r\n    mapping (address => bool) public isKycSigner;\r\n    mapping (bytes32 => uint256) public alreadyPayed;\r\n\r\n    event KycVerified(address indexed signer, address buyerAddress, bytes32 buyerId, uint maxAmount);\r\n\r\n    constructor() internal {\r\n        isKycSigner[0x9787295cdAb28b6640bc7e7db52b447B56b1b1f0] = true; //ATOMAX KYC 1 SIGNER\r\n        isKycSigner[0x3b3f379e49cD95937121567EE696dB6657861FB0] = true; //ATOMAX KYC 2 SIGNER\r\n    }\r\n\r\n    // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed\r\n    function releaseTokensTo(address buyer) internal returns(bool);\r\n\r\n    \r\n    function buyTokensFor(address _buyerAddress, bytes32 _buyerId, uint _maxAmount, uint8 _v, bytes32 _r, bytes32 _s, uint8 _bv, bytes32 _br, bytes32 _bs) public payable returns (bool) {\r\n        bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount );\r\n        address signer = ecrecover(hash, _bv, _br, _bs);\r\n        require ( signer == _buyerAddress, \"signer == _buyerAddress \" );\r\n        \r\n        return buyImplementation(_buyerAddress, _buyerId, _maxAmount, _v, _r, _s);\r\n    }\r\n    \r\n    function buyTokens(bytes32 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) {\r\n        return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s);\r\n    }\r\n\r\n    function buyImplementation(address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount, uint8 _v, bytes32 _r, bytes32 _s) private returns (bool) {\r\n        // check the signature\r\n        bytes32 hash = hasher ( _buyerAddress,  _buyerId,  _maxAmount );\r\n        address signer = ecrecover(hash, _v, _r, _s);\r\n\t\t\r\n\t\trequire( isKycSigner[signer], \"isKycSigner[signer]\");\r\n        \r\n\t\tuint256 totalPayed = alreadyPayed[_buyerId].add(msg.value);\r\n\t\trequire(totalPayed <= _maxAmount);\r\n\t\talreadyPayed[_buyerId] = totalPayed;\r\n\t\t\r\n\t\temit KycVerified(signer, _buyerAddress, _buyerId, _maxAmount);\r\n\t\treturn releaseTokensTo(_buyerAddress);\r\n\r\n    }\r\n    \r\n    function hasher (address _buyerAddress, bytes32 _buyerId, uint256 _maxAmount) public view returns ( bytes32 hash ) {\r\n        hash = keccak256(abi.encodePacked(\"Atomax authorization:\", this, _buyerAddress, _buyerId, _maxAmount));\r\n    }\r\n}\r\n\r\ncontract RC_KYC_ADV is AtomaxKycInterface, AtomaxKyc {\r\n    using SafeMath for uint256;\r\n    \r\n    TokedoDaico tokenSaleContract;\r\n    \r\n    uint256 public startTime;\r\n    uint256 public endTime;\r\n    \r\n    uint256 public etherMinimum;\r\n    uint256 public soldTokens;\r\n    uint256 public remainingTokens;\r\n    uint256 public tokenPrice;\r\n    \r\n    address public dad;\r\n\t\r\n\tmapping(address => uint256) public etherUser; // address => ether amount\r\n\tmapping(address => uint256) public pendingTokenUser; // address => token amount that will be claimed after KYC\r\n\tmapping(address => uint256) public tokenUser; // address => token amount owned\r\n\t\r\n    constructor(address _tokenSaleContract, uint256 _tokenPrice, uint256 _remainingTokens, uint256 _etherMinimum, uint256 _startTime , uint256 _endTime, address _dad) public {\r\n        require ( _tokenSaleContract != address(0), \"_tokenSaleContract != address(0)\" );\r\n        require ( _tokenPrice != 0, \"_tokenPrice != 0\" );\r\n        require ( _remainingTokens != 0, \"_remainingTokens != 0\" );  \r\n        require ( _startTime != 0, \"_startTime != 0\" );\r\n        require ( _endTime != 0, \"_endTime != 0\" );\r\n        \r\n        tokenSaleContract = TokedoDaico(_tokenSaleContract);\r\n        \r\n        soldTokens = 0;\r\n        remainingTokens = _remainingTokens;\r\n        tokenPrice = _tokenPrice;\r\n        etherMinimum = _etherMinimum;\r\n        \r\n        startTime = _startTime;\r\n        endTime = _endTime;\r\n        \r\n        dad = _dad;\r\n    }\r\n    \r\n    modifier onlyTokenSaleOwner() {\r\n        require(msg.sender == tokenSaleContract.owner() );\r\n        _;\r\n    }\r\n    \r\n    function setTime(uint256 _newStart, uint256 _newEnd) public onlyTokenSaleOwner {\r\n        if ( _newStart != 0 ) startTime = _newStart;\r\n        if ( _newEnd != 0 ) endTime = _newEnd;\r\n    }\r\n    \r\n    function changeMinimum(uint256 _newEtherMinimum) public onlyTokenSaleOwner {\r\n        etherMinimum = _newEtherMinimum;\r\n    }\r\n    \r\n    function releaseTokensTo(address buyer) internal returns(bool) {\r\n        if( msg.value > 0 ) takeEther(buyer);\r\n        giveToken(buyer);\r\n        return true;\r\n    }\r\n    \r\n    function started() public view returns(bool) {\r\n        return now > startTime || remainingTokens == 0;\r\n    }\r\n    \r\n    function ended() public view returns(bool) {\r\n        return now > endTime || remainingTokens == 0;\r\n    }\r\n    \r\n    function startTime() public view returns(uint) {\r\n        return startTime;\r\n    }\r\n    \r\n    function endTime() public view returns(uint) {\r\n        return endTime;\r\n    }\r\n    \r\n    function totalTokens() public view returns(uint) {\r\n        return remainingTokens.add(soldTokens);\r\n    }\r\n    \r\n    function remainingTokens() public view returns(uint) {\r\n        return remainingTokens;\r\n    }\r\n    \r\n    function price() public view returns(uint) {\r\n        return uint256(1 ether).div( tokenPrice ).mul( 10 ** uint256(tokenSaleContract.decimals()) );\r\n    }\r\n\t\r\n\tfunction () public payable{\r\n\t    takeEther(msg.sender);\r\n\t}\r\n\t\r\n\tevent TakeEther(address buyer, uint256 value, uint256 soldToken, uint256 tokenPrice );\r\n\t\r\n\tfunction takeEther(address _buyer) internal {\r\n\t    require( now > startTime, \"now > startTime\" );\r\n\t\trequire( now < endTime, \"now < endTime\");\r\n        require( msg.value >= etherMinimum, \"msg.value >= etherMinimum\"); \r\n        require( remainingTokens > 0, \"remainingTokens > 0\" );\r\n        \r\n        uint256 oneToken = 10 ** uint256(tokenSaleContract.decimals());\r\n        uint256 tokenAmount = msg.value.mul( oneToken ).div( tokenPrice );\r\n        \r\n        uint256 remainingTokensGlobal = tokenInterface( tokenSaleContract.tokenContract() ).balanceOf( address(tokenSaleContract) );\r\n        \r\n        uint256 remainingTokensApplied;\r\n        if ( remainingTokensGlobal > remainingTokens ) { \r\n            remainingTokensApplied = remainingTokens;\r\n        } else {\r\n            remainingTokensApplied = remainingTokensGlobal;\r\n        }\r\n        \r\n        uint256 refund = 0;\r\n        if ( remainingTokensApplied < tokenAmount ) {\r\n            refund = (tokenAmount - remainingTokensApplied).mul(tokenPrice).div(oneToken);\r\n            tokenAmount = remainingTokensApplied;\r\n\t\t\tremainingTokens = 0; // set remaining token to 0\r\n            _buyer.transfer(refund);\r\n        } else {\r\n\t\t\tremainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus\r\n        }\r\n        \r\n        etherUser[_buyer] = etherUser[_buyer].add(msg.value.sub(refund));\r\n        pendingTokenUser[_buyer] = pendingTokenUser[_buyer].add(tokenAmount);\t\r\n        \r\n        emit TakeEther( _buyer, msg.value, tokenAmount, tokenPrice );\r\n\t}\r\n\t\r\n\tfunction giveToken(address _buyer) internal {\r\n\t    require( pendingTokenUser[_buyer] > 0, \"pendingTokenUser[_buyer] > 0\" );\r\n\r\n\t\ttokenUser[_buyer] = tokenUser[_buyer].add(pendingTokenUser[_buyer]);\r\n\t\r\n\t\ttokenSaleContract.sendTokens(_buyer, pendingTokenUser[_buyer]);\r\n\t\tsoldTokens = soldTokens.add(pendingTokenUser[_buyer]);\r\n\t\tpendingTokenUser[_buyer] = 0;\r\n\t\t\r\n\t\trequire( address(tokenSaleContract).call.value( etherUser[_buyer] )( bytes4( keccak256(\"forwardEther()\") ) ) );\r\n\t\tetherUser[_buyer] = 0;\r\n\t}\r\n\r\n    function refundEther(address to) public onlyTokenSaleOwner {\r\n        to.transfer(etherUser[to]);\r\n        etherUser[to] = 0;\r\n        pendingTokenUser[to] = 0;\r\n    }\r\n    \r\n    function withdraw(address to, uint256 value) public onlyTokenSaleOwner { \r\n        to.transfer(value);\r\n    }\r\n\t\r\n\tfunction userBalance(address _user) public view returns( uint256 _pendingTokenUser, uint256 _tokenUser, uint256 _etherUser ) {\r\n\t\treturn (pendingTokenUser[_user], tokenUser[_user], etherUser[_user]);\r\n\t}\r\n}\r\n\r\ncontract TokedoDaico is Ownable {\r\n    using SafeMath for uint256;\r\n    \r\n    tokenInterface public tokenContract;\r\n    \r\n    address public milestoneSystem;\r\n\tuint256 public decimals;\r\n    uint256 public tokenPrice;\r\n\r\n    mapping(address => bool) public rc;\r\n\r\n    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {\r\n        tokenContract = tokenInterface(_tokenAddress);\r\n        decimals = tokenContract.decimals();\r\n        tokenPrice = _tokenPrice;\r\n        milestoneSystem = new MilestoneSystem(_wallet,_tokenAddress, _time, _funds, _tokenPrice, _activeSupply);\r\n    }\r\n    \r\n    modifier onlyRC() {\r\n        require( rc[msg.sender], \"rc[msg.sender]\" ); //check if is an authorized rcContract\r\n        _;\r\n    }\r\n    \r\n    function forwardEther() onlyRC payable public returns(bool) {\r\n        require(milestoneSystem.call.value(msg.value)(), \"wallet.call.value(msg.value)()\");\r\n        return true;\r\n    }\r\n    \r\n\tfunction sendTokens(address _buyer, uint256 _amount) onlyRC public returns(bool) {\r\n        return tokenContract.transfer(_buyer, _amount);\r\n    }\r\n\r\n    event NewRC(address contr);\r\n    \r\n    function addRC(address _rc) onlyOwner public {\r\n        rc[ _rc ]  = true;\r\n        emit NewRC(_rc);\r\n    }\r\n    \r\n    function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) {\r\n        return tokenContract.transfer(to, value);\r\n    }\r\n    \r\n    function setTokenContract(address _tokenContract) public onlyOwner {\r\n        tokenContract = tokenInterface(_tokenContract);\r\n    }\r\n}\r\n\r\ncontract MilestoneSystem {\r\n    using SafeMath for uint256;\r\n    \r\n    tokenInterface public tokenContract;\r\n    TokedoDaico public tokenSaleContract;\r\n    \r\n    uint256[] public time;\r\n    uint256[] public funds;\r\n    \r\n    bool public locked = false; \r\n    uint256 public endTimeToReturnTokens; \r\n    \r\n    uint8 public step = 0;\r\n    \r\n    uint256 public constant timeframeMilestone = 3 days; \r\n    uint256 public constant timeframeDeath = 30 days; \r\n    \r\n    uint256 public activeSupply;\r\n    \r\n    uint256 public tokenPrice;\r\n    \r\n    uint256 public etherReceived;\r\n    address public wallet;\r\n    \r\n    mapping(address => mapping(uint8 => uint256) ) public balance;\r\n    mapping(uint8 => uint256) public tokenDistrusted;\r\n    \r\n    constructor(address _wallet, address _tokenAddress, uint256[] _time, uint256[] _funds, uint256 _tokenPrice, uint256 _activeSupply) public {\r\n        require( _wallet != address(0), \"_wallet != address(0)\" );\r\n        require( _time.length != 0, \"_time.length != 0\" );\r\n        require( _time.length == _funds.length, \"_time.length == _funds.length\" );\r\n        \r\n        wallet = _wallet;\r\n        \r\n        tokenContract = tokenInterface(_tokenAddress);\r\n        tokenSaleContract = TokedoDaico(msg.sender);\r\n        \r\n        time = _time;\r\n        funds = _funds;\r\n        \r\n        activeSupply = _activeSupply;\r\n        tokenPrice = _tokenPrice;\r\n    }\r\n    \r\n    modifier onlyTokenSaleOwner() {\r\n        require(msg.sender == tokenSaleContract.owner(), \"msg.sender == tokenSaleContract.owner()\" );\r\n        _;\r\n    }\r\n    \r\n    event Distrust(address sender, uint256 amount);\r\n    event Locked();\r\n    \r\n    function distrust(address _from, uint _value, bytes ) public {\r\n        require(msg.sender == address(tokenContract), \"msg.sender == address(tokenContract)\");\r\n        \r\n        if ( !locked ) {\r\n            \r\n            uint256 startTimeMilestone = time[step].sub(timeframeMilestone);\r\n            uint256 endTimeMilestone = time[step];\r\n            uint256 startTimeProjectDeath = time[step].add(timeframeDeath);\r\n            bool unclaimedFunds = funds[step] > 0;\r\n            \r\n            require( \r\n                ( now > startTimeMilestone && now < endTimeMilestone ) || \r\n                ( now > startTimeProjectDeath && unclaimedFunds ), \r\n                \"( now > startTimeMilestone && now < endTimeMilestone ) || ( now > startTimeProjectDeath && unclaimedFunds )\" \r\n            );\r\n        } else {\r\n            require( locked && now < endTimeToReturnTokens ); //a timeframePost to deposit all tokens and then claim the refundMe method\r\n        }\r\n        \r\n        balance[_from][step] = balance[_from][step].add(_value);\r\n        tokenDistrusted[step] = tokenDistrusted[step].add(_value);\r\n        \r\n        emit Distrust(msg.sender, _value);\r\n        \r\n        if( tokenDistrusted[step] > activeSupply && !locked ) {\r\n            locked = true;\r\n            endTimeToReturnTokens = now.add(timeframeDeath);\r\n            emit Locked();\r\n        }\r\n    }\r\n    \r\n    function tokenFallback(address _from, uint _value, bytes _data) public {\r\n        distrust( _from, _value, _data);\r\n    }\r\n\t\r\n\tfunction receiveApproval( address _from, uint _value, bytes _data) public {\r\n\t    require(msg.sender == address(tokenContract), \"msg.sender == address(tokenContract)\");\r\n\t\trequire(msg.sender.call(bytes4(keccak256(\"transferFrom(address,address,uint256)\")), _from, this, _value));\r\n        distrust( _from, _value, _data);\r\n    }\r\n    \r\n    event Trust(address sender, uint256 amount);\r\n    event Unlocked();\r\n    \r\n    function trust(uint8 _step) public {\r\n        require( balance[msg.sender][_step] > 0 , \"balance[msg.sender] > 0\");\r\n        \r\n        uint256 amount = balance[msg.sender][_step];\r\n        balance[msg.sender][_step] = 0;\r\n        \r\n        tokenDistrusted[_step] = tokenDistrusted[_step].sub(amount);\r\n        tokenContract.transfer(msg.sender, amount);\r\n        \r\n        emit Trust(msg.sender, amount);\r\n        \r\n        if( tokenDistrusted[step] <= activeSupply && locked ) {\r\n            locked = false;\r\n            endTimeToReturnTokens = 0;\r\n            emit Unlocked();\r\n        }\r\n    }\r\n    \r\n    event Refund(address sender, uint256 money);\r\n    \r\n    function refundMe() public {\r\n        require(locked, \"locked\");\r\n        require( now > endTimeToReturnTokens, \"now > endTimeToReturnTokens\" );\r\n        \r\n        uint256 ethTot = address(this).balance;\r\n        require( ethTot > 0 , \"ethTot > 0\");\r\n        \r\n        uint256 tknAmount = balance[msg.sender][step];\r\n        require( tknAmount > 0 , \"tknAmount > 0\");\r\n        \r\n        balance[msg.sender][step] = 0;\r\n        \r\n        tokenContract.burn(tknAmount);\r\n        \r\n        uint256 tknTot = tokenDistrusted[step];\r\n        uint256 rate = tknAmount.mul(1e18).div(tknTot);\r\n        uint256 money = ethTot.mul(rate).div(1e18);\r\n        \r\n        if( money > address(this).balance ) {\r\n\t\t    money = address(this).balance;\r\n\t\t}\r\n        msg.sender.transfer(money);\r\n        \r\n        emit Refund(msg.sender, money);\r\n    }\r\n    \r\n    function ownerWithdraw() public onlyTokenSaleOwner {\r\n        require(!locked, \"!locked\");\r\n        \r\n        require(now > time[step], \"now > time[step]\");\r\n        require(funds[step] > 0, \"funds[step] > 0\");\r\n        \r\n        uint256 amountApplied = funds[step];\r\n        funds[step] = 0;\r\n\t\tstep = step+1;\r\n\t\t\r\n\t\tuint256 value;\r\n\t\tif( amountApplied > address(this).balance || time.length == step+1)\r\n\t\t    value = address(this).balance;\r\n\t\telse {\r\n\t\t    value = amountApplied;\r\n\t\t}\r\n\t\t\r\n        msg.sender.transfer(value);\r\n    }\r\n    \r\n    function ownerWithdrawTokens(address _tokenContract, address to, uint256 value) public onlyTokenSaleOwner returns (bool) { //for airdrop reason to distribute to Tokedo Token Holder\r\n        require( _tokenContract != address(tokenContract), \"_tokenContract != address(tokenContract)\"); // the owner can withdraw tokens except Tokedo Tokens\r\n        return tokenInterface(_tokenContract).transfer(to, value);\r\n    }\r\n    \r\n    function setWallet(address _wallet) public onlyTokenSaleOwner returns(bool) {\r\n        require( _wallet != address(0), \"_wallet != address(0)\" );\r\n        wallet = _wallet;\r\n\t\treturn true;\r\n    }\r\n    \r\n    function () public payable {\r\n        require(msg.sender == address(tokenSaleContract), \"msg.sender == address(tokenSaleContract)\");\r\n        \r\n        if( etherReceived < funds[0]  ) {\r\n            require( wallet != address(0), \"wallet != address(0)\" );\r\n            wallet.transfer(msg.value);\r\n        }\r\n        \r\n        etherReceived = etherReceived.add(msg.value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"}],\"name\":\"userBalance\",\"outputs\":[{\"name\":\"_pendingTokenUser\",\"type\":\"uint256\"},{\"name\":\"_tokenUser\",\"type\":\"uint256\"},{\"name\":\"_etherUser\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isKycSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"started\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"}],\"name\":\"refundEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newEtherMinimum\",\"type\":\"uint256\"}],\"name\":\"changeMinimum\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pendingTokenUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"alreadyPayed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_buyerAddress\",\"type\":\"address\"},{\"name\":\"_buyerId\",\"type\":\"bytes32\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"}],\"name\":\"hasher\",\"outputs\":[{\"name\":\"hash\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherMinimum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dad\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"etherUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newStart\",\"type\":\"uint256\"},{\"name\":\"_newEnd\",\"type\":\"uint256\"}],\"name\":\"setTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_buyerAddress\",\"type\":\"address\"},{\"name\":\"_buyerId\",\"type\":\"bytes32\"},{\"name\":\"_maxAmount\",\"type\":\"uint256\"},{\"name\":\"_v\",\"type\":\"uint8\"},{\"name\":\"_r\",\"type\":\"bytes32\"},{\"name\":\"_s\",\"type\":\"bytes32\"},{\"name\":\"_bv\",\"type\":\"uint8\"},{\"name\":\"_br\",\"type\":\"bytes32\"},{\"name\":\"_bs\",\"type\":\"bytes32\"}],\"name\":\"buyTokensFor\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"remainingTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyerId\",\"type\":\"bytes32\"},{\"name\":\"maxAmount\",\"type\":\"uint256\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"buyTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tokenUser\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenSaleContract\",\"type\":\"address\"},{\"name\":\"_tokenPrice\",\"type\":\"uint256\"},{\"name\":\"_remainingTokens\",\"type\":\"uint256\"},{\"name\":\"_etherMinimum\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_dad\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"soldToken\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenPrice\",\"type\":\"uint256\"}],\"name\":\"TakeEther\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"signer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyerId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"maxAmount\",\"type\":\"uint256\"}],\"name\":\"KycVerified\",\"type\":\"event\"}]","ContractName":"RC_KYC_ADV","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000008b850e007736b24f7a81ad776d3e7e0a5c6df4d700000000000000000000000000000000000000000000000000038d7ea4c68000000000000000000000000000000000000000000000108b2a2c2802909400000000000000000000000000000000000000000000000000000000b1a2bc2ec50000000000000000000000000000000000000000000000000000000000005ba4eb0f0000000000000000000000000000000000000000000000000000000394712e960000000000000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://ed12146bdff05f06c37b3ac6317bb505c2e32e29baaf1a6b4e6c27b6ad04a8a5"}]}