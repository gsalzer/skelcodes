{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.1;\r\n\r\n// File: contracts/lib/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address private _owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor () internal {\r\n        _owner = msg.sender;\r\n        emit OwnershipTransferred(address(0), _owner);\r\n    }\r\n\r\n    /**\r\n     * @return the address of the owner.\r\n     */\r\n    function owner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(isOwner(), \"Only the owner can call this function.\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @return true if `msg.sender` is the owner of the contract.\r\n     */\r\n    function isOwner() public view returns (bool) {\r\n        return msg.sender == _owner;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to relinquish control of the contract.\r\n     * @notice Renouncing to ownership will leave the contract without an owner.\r\n     * It will not be possible to call the functions with the `onlyOwner`\r\n     * modifier anymore.\r\n     */\r\n    function renounceOwnership() public onlyOwner {\r\n        emit OwnershipTransferred(_owner, address(0));\r\n        _owner = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _transferOwnership(newOwner);\r\n    }\r\n\r\n    /**\r\n     * @dev Transfers control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function _transferOwnership(address newOwner) internal {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(_owner, newOwner);\r\n        _owner = newOwner;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\n\r\ninterface IERC20 {\r\n\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  // solhint-disable-next-line func-order\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  // solhint-disable-next-line func-order\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  // solhint-disable-next-line func-order\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  // solhint-disable-next-line no-simple-event-func-name\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: contracts/lib/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\n\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: contracts/lib/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n// File: contracts/lib/PauserRole.sol\r\n\r\ncontract PauserRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event PauserAdded(address indexed account);\r\n  event PauserRemoved(address indexed account);\r\n\r\n  Roles.Role private pausers;\r\n\r\n  constructor() public {\r\n    _addPauser(msg.sender);\r\n  }\r\n\r\n  modifier onlyPauser() {\r\n    require(isPauser(msg.sender), \"Can only be called by pauser.\");\r\n    _;\r\n  }\r\n\r\n  function isPauser(address account) public view returns (bool) {\r\n    return pausers.has(account);\r\n  }\r\n\r\n  function addPauser(address account) public onlyPauser {\r\n    _addPauser(account);\r\n  }\r\n\r\n  function renouncePauser() public {\r\n    _removePauser(msg.sender);\r\n  }\r\n\r\n  function _addPauser(address account) internal {\r\n    pausers.add(account);\r\n    emit PauserAdded(account);\r\n  }\r\n\r\n  function _removePauser(address account) internal {\r\n    pausers.remove(account);\r\n    emit PauserRemoved(account);\r\n  }\r\n}\r\n\r\n// File: contracts/lib/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns(bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused, \"Cannot call when paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused, \"Can only call this when paused.\");\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyPauser whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyPauser whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\n// File: contracts/lib/ValidatorRole.sol\r\n\r\ncontract ValidatorRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event ValidatorAdded(address indexed account);\r\n  event ValidatorRemoved(address indexed account);\r\n\r\n  Roles.Role private validators;\r\n\r\n  constructor(address validator) public {\r\n    _addValidator(validator);\r\n  }\r\n\r\n  modifier onlyValidator() {\r\n    require(\r\n      isValidator(msg.sender),\r\n      \"This function can only be called by a validator.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function isValidator(address account) public view returns (bool) {\r\n    return validators.has(account);\r\n  }\r\n\r\n  function addValidator(address account) public onlyValidator {\r\n    _addValidator(account);\r\n  }\r\n\r\n  function renounceValidator() public {\r\n    _removeValidator(msg.sender);\r\n  }\r\n\r\n  function _addValidator(address account) internal {\r\n    validators.add(account);\r\n    emit ValidatorAdded(account);\r\n  }\r\n\r\n  function _removeValidator(address account) internal {\r\n    validators.remove(account);\r\n    emit ValidatorRemoved(account);\r\n  }\r\n}\r\n\r\n// File: contracts/IxtProtect.sol\r\n\r\n/// @title IxtEvents\r\n/// @notice Holds all events used by the IXTProtect contract\r\ncontract IxtEvents {\r\n\r\n  event MemberAdded(\r\n    address indexed memberAddress,\r\n    bytes32 indexed membershipNumber,\r\n    bytes32 indexed invitationCode\r\n  );\r\n\r\n  event StakeDeposited(\r\n    address indexed memberAddress,\r\n    bytes32 indexed membershipNumber,\r\n    uint256 stakeAmount\r\n  );\r\n\r\n  event StakeWithdrawn(\r\n    address indexed memberAddress,\r\n    uint256 stakeAmount\r\n  );\r\n\r\n  event RewardClaimed(\r\n    address indexed memberAddress,\r\n    uint256 rewardAmount\r\n  );\r\n\r\n  event InvitationRewardGiven(\r\n    address indexed memberReceivingReward,\r\n    address indexed memberGivingReward,\r\n    uint256 rewardAmount\r\n  );\r\n\r\n  event PoolDeposit(\r\n    address indexed depositer,\r\n    uint256 amount\r\n  );\r\n\r\n  event PoolWithdraw(\r\n    address indexed withdrawer,\r\n    uint256 amount\r\n  );\r\n\r\n  event AdminRemovedMember(\r\n    address indexed admin,\r\n    address indexed userAddress,\r\n    uint256 refundIssued\r\n  );\r\n\r\n  event MemberDrained(\r\n    address indexed memberAddress,\r\n    uint256 amountRefunded\r\n  );\r\n\r\n  event PoolDrained(\r\n    address indexed refundRecipient,\r\n    uint256 amountRefunded\r\n  );\r\n\r\n  event ContractDrained(\r\n    address indexed drainInitiator\r\n  );\r\n\r\n  event InvitationRewardChanged(\r\n    uint256 newInvitationReward\r\n  );\r\n\r\n  event LoyaltyRewardChanged(\r\n    uint256 newLoyaltyRewardAmount\r\n  );\r\n}\r\n\r\n/// @title RoleManager which inherits the Role-based functionality used\r\n/// by the IXTProtect contract\r\ncontract RoleManager is Ownable, Pausable, ValidatorRole {\r\n\r\n  constructor(address validator)\r\n    public\r\n    ValidatorRole(validator)\r\n  {}\r\n}\r\n\r\n/// @title StakeManager which contains some of the stake-based state\r\n/// used by the IXTProtect contract\r\ncontract StakeManager {\r\n\r\n  /*      Function modifiers      */\r\n\r\n  modifier isValidStakeLevel(StakeLevel level) {\r\n    require(\r\n      uint8(level) >= 0 && uint8(level) <= 2,\r\n      \"Is not valid a staking level.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /*      Data types      */\r\n\r\n  /// @dev The three levels of stake used within the IXTProtect platform\r\n  /// @dev Solidity enums are 0 based\r\n  enum StakeLevel { LOW, MEDIUM, HIGH }\r\n\r\n  /*      Variable declarations      */\r\n\r\n  /// @dev the defined staking amount for each level\r\n  uint256[3] public ixtStakingLevels;\r\n\r\n  /*      Constructor      */\r\n\r\n  /// @param _ixtStakingLevels the amount of stake used for each of the staking levels\r\n  /// used within the IXTProtect platform\r\n  constructor(\r\n    uint256[3] memory _ixtStakingLevels\r\n  ) public {\r\n    ixtStakingLevels = _ixtStakingLevels;\r\n  }\r\n\r\n}\r\n\r\n/// @title RewardManager which contains some of the reward-based state\r\n/// used by the IXTProtect contract\r\ncontract RewardManager {\r\n\r\n  /*      Variable declarations      */\r\n\r\n  /// @dev the reward received when inviting someone\r\n  uint256 public invitationReward;\r\n  /// @dev the period after which a member gets a loyalty reward\r\n  uint256 public loyaltyPeriodDays;\r\n  /// @dev the rate used for calculation of the loyalty reward\r\n  uint256 public loyaltyRewardAmount;\r\n\r\n  /*      Constructor      */\r\n\r\n  /// @param _invitationReward the amount of reward used when a member uses an invitation code\r\n  /// @param _loyaltyPeriodDays the amount of days that will be used for the loyalty period\r\n  /// @param _loyaltyRewardAmount the rate used as a loyalty reward after every loyalty period\r\n  constructor(\r\n    uint256 _invitationReward,\r\n    uint256 _loyaltyPeriodDays,\r\n    uint256 _loyaltyRewardAmount\r\n  ) public {\r\n    require(\r\n      _loyaltyRewardAmount >= 0 &&\r\n      _loyaltyRewardAmount <= 100,\r\n      \"Loyalty reward amount must be between 0 and 100.\"\r\n    );\r\n    invitationReward = _invitationReward;\r\n    loyaltyPeriodDays = _loyaltyPeriodDays;\r\n    loyaltyRewardAmount = _loyaltyRewardAmount;\r\n  }\r\n\r\n}\r\n\r\n/// @title IxtProtect\r\n/// @notice Holds state and contains key logic which controls the IXTProtect platform\r\ncontract IxtProtect is IxtEvents, RoleManager, StakeManager, RewardManager {\r\n\r\n  /*      Function modifiers      */\r\n\r\n  modifier isNotMember(address memberAddress) {\r\n    require(\r\n      members[memberAddress].addedTimestamp == 0,\r\n      \"Already a member.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier isMember(address memberAddress) {\r\n    require(\r\n      members[memberAddress].addedTimestamp != 0,\r\n      \"User is not a member.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier notStaking(address memberAddress) {\r\n    require(\r\n      members[memberAddress].stakeTimestamp == 0,\r\n      \"Member is staking already.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  modifier staking(address memberAddress) {\r\n    require(\r\n      members[memberAddress].stakeTimestamp != 0,\r\n      \"Member is not staking.\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  /*      Data types      */\r\n\r\n  /// @dev data structure used to track state on each member using the platform\r\n  struct Member {\r\n    uint256 addedTimestamp;\r\n    uint256 stakeTimestamp;\r\n    uint256 startOfLoyaltyRewardEligibility;\r\n    bytes32 membershipNumber;\r\n    bytes32 invitationCode;\r\n    uint256 stakeBalance;\r\n    uint256 invitationRewards;\r\n    uint256 previouslyAppliedLoyaltyBalance;\r\n  }\r\n\r\n  /*      Variable declarations      */\r\n\r\n  /// @dev the IXT ERC20 Token contract\r\n  IERC20 public ixtToken;\r\n  /// @dev a mapping from member wallet addresses to Member struct\r\n  mapping(address => Member) public members;\r\n  /// @dev the same data as `members`, but iterable\r\n  address[] public membersArray;\r\n  /// @dev the total balance of all members\r\n  uint256 public totalMemberBalance;\r\n  /// @dev the total pool balance\r\n  uint256 public totalPoolBalance;\r\n  /// @notice a mapping from invitationCode => memberAddress, so invitation rewards can be applied.\r\n  mapping(bytes32 => address) public registeredInvitationCodes;\r\n \r\n\r\n  /*      Constants      */\r\n\r\n  /// @dev the amount of decimals used by the IXT ERC20 token\r\n  uint256 public constant IXT_DECIMALS = 8;\r\n\r\n  /*      Constructor      */\r\n\r\n  /// @param _validator the address to use as the validator\r\n  /// @param _loyaltyPeriodDays the amount of days that will be used for the loyalty period\r\n  /// @param _ixtToken the address of the IXT ERC20 token to be used as stake and for rewards\r\n  /// @param _invitationReward the amount of reward used when a member uses an invitation code\r\n  /// @param _loyaltyRewardAmount the rate used as a loyalty reward after every loyalty period\r\n  /// @param _ixtStakingLevels three ascending amounts of IXT token to be used as staking levels\r\n  constructor(\r\n    address _validator,\r\n    uint256 _loyaltyPeriodDays,\r\n    address _ixtToken,\r\n    uint256 _invitationReward,\r\n    uint256 _loyaltyRewardAmount,\r\n    uint256[3] memory _ixtStakingLevels\r\n  )\r\n    public\r\n    RoleManager(_validator)\r\n    StakeManager(_ixtStakingLevels)\r\n    RewardManager(_invitationReward, _loyaltyPeriodDays, _loyaltyRewardAmount)\r\n  {\r\n    require(_ixtToken != address(0x0), \"ixtToken address was set to 0.\");\r\n    ixtToken = IERC20(_ixtToken);\r\n  }\r\n\r\n  /*                            */\r\n  /*      PUBLIC FUNCTIONS      */\r\n  /*                            */\r\n\r\n  /*      (member control)      */\r\n\r\n  /// @notice Registers a new user as a member after the KYC process\r\n  /// @notice This function should not add the invitationCode\r\n  /// to the mapping yet, this should only happen after join\r\n  /// @notice This function can only be called by a \"validator\" which is set inside the\r\n  /// constructor\r\n  /// @param _membershipNumber the membership number of the member to authorise\r\n  /// @param _memberAddress the EOA address of the member to authorise\r\n  /// @param _invitationCode should be associated with *this* member in order to apply invitation rewards\r\n  /// @param _referralInvitationCode the invitation code of another member which is used to give the\r\n\r\n  function addMember(\r\n    bytes32 _membershipNumber,\r\n    address _memberAddress,\r\n    bytes32 _invitationCode,\r\n    bytes32 _referralInvitationCode\r\n  ) \r\n    public\r\n    onlyValidator\r\n    isNotMember(_memberAddress)\r\n    notStaking(_memberAddress)\r\n  {\r\n    require(\r\n      _memberAddress != address(0x0),\r\n      \"Member address was set to 0.\"\r\n    );\r\n    Member memory member = Member({\r\n      addedTimestamp: block.timestamp,\r\n      stakeTimestamp: 0,\r\n      startOfLoyaltyRewardEligibility: 0,\r\n      membershipNumber: _membershipNumber,\r\n      invitationCode: _invitationCode,\r\n      stakeBalance: 0,\r\n      invitationRewards: 0,\r\n      previouslyAppliedLoyaltyBalance: 0\r\n    });\r\n    members[_memberAddress] = member;\r\n    membersArray.push(_memberAddress);\r\n\r\n    /// @dev add this members invitation code to the mapping\r\n    registeredInvitationCodes[member.invitationCode] = _memberAddress;\r\n    /// @dev if the _referralInvitationCode is already registered, add on reward\r\n    address rewardMemberAddress = registeredInvitationCodes[_referralInvitationCode];\r\n    if (\r\n      rewardMemberAddress != address(0x0)\r\n    ) {\r\n      Member storage rewardee = members[rewardMemberAddress];\r\n      rewardee.invitationRewards = SafeMath.add(rewardee.invitationRewards, invitationReward);\r\n      emit InvitationRewardGiven(rewardMemberAddress, _memberAddress, invitationReward);\r\n    }\r\n\r\n    emit MemberAdded(_memberAddress, _membershipNumber, _invitationCode);\r\n  }\r\n\r\n  /// @notice Called by a member once they have been approved to join the scheme\r\n  /// @notice Before calling the prospective member *must* have approved the appropriate amount of\r\n  /// IXT token to be transferred by this contract\r\n  /// @param _stakeLevel the staking level used by this member. Note this is not the staking *amount*.\r\n  /// other member a reward upon *this* user joining.\r\n  function depositStake(\r\n    StakeLevel _stakeLevel\r\n  )\r\n    public\r\n    whenNotPaused()\r\n    isMember(msg.sender)\r\n    notStaking(msg.sender)\r\n    isValidStakeLevel(_stakeLevel)\r\n  {\r\n    uint256 amountDeposited = depositInternal(msg.sender, ixtStakingLevels[uint256(_stakeLevel)], false);\r\n    Member storage member = members[msg.sender];\r\n    member.stakeTimestamp = block.timestamp;\r\n    member.startOfLoyaltyRewardEligibility = block.timestamp;\r\n    /// @dev add this members invitation code to the mapping\r\n    registeredInvitationCodes[member.invitationCode] = msg.sender;\r\n    emit StakeDeposited(msg.sender, member.membershipNumber, amountDeposited);\r\n  }\r\n\r\n  /// @notice Called by the member if they wish to withdraw the stake\r\n  /// @notice This function will return all stake and eligible reward balance back to the user\r\n  function withdrawStake()\r\n    public\r\n    whenNotPaused()\r\n    staking(msg.sender)\r\n  {\r\n\r\n    uint256 stakeAmount = refundUserBalance(msg.sender);\r\n    delete registeredInvitationCodes[members[msg.sender].invitationCode];\r\n    Member storage member = members[msg.sender];\r\n    member.stakeTimestamp = 0;\r\n    member.startOfLoyaltyRewardEligibility = 0;\r\n    emit StakeWithdrawn(msg.sender, stakeAmount);\r\n  }\r\n\r\n  /// @notice Called by the member if they wish to claim the rewards they are eligible\r\n  /// @notice This function will return all eligible reward balance back to the user\r\n  function claimRewards()\r\n    public\r\n    whenNotPaused()\r\n    staking(msg.sender)\r\n  {\r\n    uint256 rewardClaimed = claimRewardsInternal(msg.sender);\r\n    emit RewardClaimed(msg.sender, rewardClaimed);\r\n  }\r\n\r\n  /*      (getter functions)      */\r\n\r\n  /// @notice Called in order to get the number of members on the platform\r\n  /// @return length of the members array\r\n  function getMembersArrayLength() public view returns (uint256) {\r\n    return membersArray.length;\r\n  }\r\n\r\n  /// @notice Called to obtain the account balance of any given member\r\n  /// @param memberAddress the address of the member to get the account balance for\r\n  /// @return the account balance of the member in question\r\n  function getAccountBalance(address memberAddress)\r\n    public\r\n    view\r\n    staking(memberAddress)\r\n    returns (uint256)\r\n  {\r\n    return getStakeBalance(memberAddress) +\r\n      getRewardBalance(memberAddress);\r\n  }\r\n\r\n  /// @notice Called to obtain the stake balance of any given member\r\n  /// @param memberAddress the address of the member to get the stake balance for\r\n  /// @return the stake balance of the member in question\r\n  function getStakeBalance(address memberAddress)\r\n    public\r\n    view\r\n    staking(memberAddress)\r\n    returns (uint256)\r\n  {\r\n    return members[memberAddress].stakeBalance;\r\n  }\r\n\r\n  /// @notice Called to obtain the reward balance of any given member\r\n  /// @param memberAddress the address of the member to get the total reward balance for\r\n  /// @return the total reward balance of the member in question\r\n  function getRewardBalance(address memberAddress)\r\n    public\r\n    view\r\n    staking(memberAddress)\r\n    returns (uint256)\r\n  {\r\n    return getInvitationRewardBalance(memberAddress) +\r\n      getLoyaltyRewardBalance(memberAddress);\r\n  }\r\n\r\n  /// @notice Called to obtain the invitation reward balance of any given member\r\n  /// @param memberAddress the address of the member to get the invitation reward balance for\r\n  /// @return the invitation reward balance of the member in question\r\n  function getInvitationRewardBalance(address memberAddress)\r\n    public\r\n    view\r\n    staking(memberAddress)\r\n    returns (uint256)\r\n  {\r\n    return members[memberAddress].invitationRewards;\r\n  }\r\n\r\n  /// @notice Called to obtain the loyalty reward balance of any given member\r\n  /// @param memberAddress the address of the member to get the loyalty reward balance for\r\n  /// @return the loyalty reward balance of the member in question\r\n  function getLoyaltyRewardBalance(address memberAddress)\r\n    public\r\n    view\r\n    staking(memberAddress)\r\n    returns (uint256 loyaltyReward)\r\n  {\r\n    uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;\r\n    Member storage thisMember = members[memberAddress];\r\n    uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;\r\n    loyaltyReward = thisMember.previouslyAppliedLoyaltyBalance;\r\n    if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {\r\n      uint256 numWholePeriods = SafeMath.div(elapsedTimeSinceEligible, loyaltyPeriodSeconds);\r\n      uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;\r\n      loyaltyReward += rewardForEachPeriod * numWholePeriods;\r\n    }\r\n  }\r\n\r\n  /*      (admin functions)      */\r\n\r\n  /// @notice Called by the admin to deposit extra IXT into the contract to be used as rewards\r\n  /// @notice This function can only be called by the contract owner\r\n  /// @param amountToDeposit the amount of IXT ERC20 token to deposit into the pool\r\n  function depositPool(uint256 amountToDeposit)\r\n    public\r\n    onlyOwner\r\n  {\r\n    uint256 amountDeposited = depositInternal(msg.sender, amountToDeposit, true);\r\n    emit PoolDeposit(msg.sender, amountDeposited);\r\n  }\r\n\r\n  /// @notice Called by the admin to withdraw IXT from the pool balance\r\n  /// @notice This function can only be called by the contract owner\r\n  /// @param amountToWithdraw the amount of IXT ERC20 token to withdraw from the pool\r\n  function withdrawPool(uint256 amountToWithdraw)\r\n    public\r\n    onlyOwner\r\n  {\r\n    if (amountToWithdraw > 0) {\r\n      require(\r\n        totalPoolBalance >= amountToWithdraw &&\r\n        ixtToken.transfer(msg.sender, amountToWithdraw),\r\n        \"Unable to withdraw this value of IXT.\"  \r\n      );\r\n      totalPoolBalance = SafeMath.sub(totalPoolBalance, amountToWithdraw);\r\n    }\r\n    emit PoolWithdraw(msg.sender, amountToWithdraw);\r\n  }\r\n\r\n  /// @notice Called by an admin to remove a member from the platform\r\n  /// @notice This function can only be called by the contract owner\r\n  /// @notice The member will be automatically refunded their stake balance and any\r\n  /// unclaimed rewards as a result of being removed by the admin\r\n  /// @notice Can be called if user is authorised *or* joined\r\n  /// @param userAddress the address of the member that the admin wishes to remove\r\n  function removeMember(address userAddress)\r\n    public\r\n    isMember(userAddress)\r\n    onlyOwner\r\n  {\r\n    uint256 refund = cancelMembershipInternal(userAddress);\r\n    emit AdminRemovedMember(msg.sender, userAddress, refund);\r\n  }\r\n\r\n  /// @notice Called by an admin in emergency situations only, will returns *ALL* stake balance\r\n  /// and reward balances back to the users. Any left over pool balance will be returned to the\r\n  /// contract owner.\r\n  /// @notice This function can only be called by the contract owner\r\n  function drain() public onlyOwner {\r\n    /// @dev Refund and delete all members\r\n    for (uint256 index = 0; index < membersArray.length; index++) {\r\n      address memberAddress = membersArray[index];\r\n      bool memberJoined = members[memberAddress].stakeTimestamp != 0;\r\n      uint256 amountRefunded = memberJoined ? refundUserBalance(memberAddress) : 0;\r\n\r\n      delete registeredInvitationCodes[members[memberAddress].invitationCode];\r\n      delete members[memberAddress];\r\n\r\n      emit MemberDrained(memberAddress, amountRefunded);\r\n    }\r\n    delete membersArray;\r\n\r\n    /// @dev Refund the pool balance\r\n    require(\r\n      ixtToken.transfer(msg.sender, totalPoolBalance),\r\n      \"Unable to withdraw this value of IXT.\"\r\n    );\r\n    totalPoolBalance = 0;\r\n    emit PoolDrained(msg.sender, totalPoolBalance);\r\n    \r\n    emit ContractDrained(msg.sender);\r\n  }\r\n\r\n  /// @notice Called by the contract owner to set the invitation reward to be given to future members\r\n  /// @notice This function does not affect previously awarded invitation rewards\r\n  /// @param _invitationReward the amount that the invitation reward should be set to\r\n  function setInvitationReward(uint256 _invitationReward)\r\n    public\r\n    onlyOwner\r\n  {\r\n    invitationReward = _invitationReward;\r\n    emit InvitationRewardChanged(_invitationReward);\r\n  }\r\n\r\n  /// @notice Called by the contract owner to set the loyalty reward rate to be given to future members\r\n  /// @notice This function does not affect previously awarded loyalty rewards\r\n  /// @notice The loyalty reward amount is actually a rate from 0 to 100 that is used to\r\n  /// calculate the proportion of stake balance that should be rewarded.\r\n  /// @param newLoyaltyRewardAmount the amount that the loyalty reward should be set to\r\n  function setLoyaltyRewardAmount(uint256 newLoyaltyRewardAmount)\r\n    public\r\n    onlyOwner\r\n  {\r\n    require(\r\n      newLoyaltyRewardAmount >= 0 &&\r\n      newLoyaltyRewardAmount <= 100,\r\n      \"Loyalty reward amount must be between 0 and 100.\"\r\n    );\r\n    uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;\r\n    /// @dev Loop through all the current members and apply previous reward amounts\r\n    for (uint256 i = 0; i < membersArray.length; i++) {\r\n      Member storage thisMember = members[membersArray[i]];\r\n      uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;\r\n      if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {\r\n        uint256 numWholePeriods = SafeMath.div(elapsedTimeSinceEligible, loyaltyPeriodSeconds);\r\n        uint256 rewardForEachPeriod = thisMember.stakeBalance * loyaltyRewardAmount / 100;\r\n        thisMember.previouslyAppliedLoyaltyBalance += rewardForEachPeriod * numWholePeriods;\r\n        thisMember.startOfLoyaltyRewardEligibility += numWholePeriods * loyaltyPeriodSeconds;\r\n      }\r\n    }\r\n    loyaltyRewardAmount = newLoyaltyRewardAmount;\r\n    emit LoyaltyRewardChanged(newLoyaltyRewardAmount);\r\n  }\r\n\r\n  /*                              */\r\n  /*      INTERNAL FUNCTIONS      */\r\n  /*                              */\r\n\r\n  function cancelMembershipInternal(address memberAddress)\r\n    internal\r\n    returns\r\n    (uint256 amountRefunded)\r\n  {\r\n    if(members[memberAddress].stakeTimestamp != 0) {\r\n      amountRefunded = refundUserBalance(memberAddress);\r\n    }\r\n\r\n    delete registeredInvitationCodes[members[memberAddress].invitationCode];\r\n\r\n    delete members[memberAddress];\r\n\r\n    removeMemberFromArray(memberAddress);\r\n  }\r\n\r\n  function refundUserBalance(\r\n    address memberAddress\r\n  ) \r\n    internal\r\n    returns (uint256)\r\n  {\r\n    Member storage member = members[memberAddress];\r\n\r\n    /// @dev Pool balance will be reduced inside this function\r\n    uint256 claimsRefunded = claimRewardsInternal(memberAddress);\r\n    uint256 stakeToRefund = member.stakeBalance;\r\n\r\n    bool userStaking = member.stakeTimestamp != 0;\r\n    if (stakeToRefund > 0 && userStaking) {\r\n      require(\r\n        ixtToken.transfer(memberAddress, stakeToRefund),\r\n        \"Unable to withdraw this value of IXT.\"  \r\n      );\r\n      totalMemberBalance = SafeMath.sub(totalMemberBalance, stakeToRefund);\r\n    }\r\n    member.stakeBalance = 0;\r\n    return claimsRefunded + stakeToRefund;\r\n  }\r\n\r\n  function removeMemberFromArray(address memberAddress) internal {\r\n    /// @dev removing the member address from the membersArray\r\n    for (uint256 index; index < membersArray.length; index++) {\r\n      if (membersArray[index] == memberAddress) {\r\n        membersArray[index] = membersArray[membersArray.length - 1];\r\n        membersArray[membersArray.length - 1] = address(0);\r\n        membersArray.length -= 1;\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  function claimRewardsInternal(address memberAddress)\r\n    internal\r\n    returns (uint256 rewardAmount)\r\n  {\r\n    rewardAmount = getRewardBalance(memberAddress);\r\n\r\n    if (rewardAmount == 0) {\r\n      return rewardAmount;\r\n    }\r\n\r\n    require(\r\n      totalPoolBalance >= rewardAmount,\r\n      \"Pool balance not sufficient to withdraw rewards.\"\r\n    );\r\n    require(\r\n      ixtToken.transfer(memberAddress, rewardAmount),\r\n      \"Unable to withdraw this value of IXT.\"  \r\n    );\r\n    /// @dev we know this is safe as totalPoolBalance >= rewardAmount\r\n    totalPoolBalance -= rewardAmount;\r\n\r\n    Member storage thisMember = members[memberAddress];\r\n    thisMember.previouslyAppliedLoyaltyBalance = 0;\r\n    thisMember.invitationRewards = 0;\r\n\r\n    uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days;\r\n    uint256 elapsedTimeSinceEligible = block.timestamp - thisMember.startOfLoyaltyRewardEligibility;\r\n    if (elapsedTimeSinceEligible >= loyaltyPeriodSeconds) {\r\n      uint256 numWholePeriods = SafeMath.div(elapsedTimeSinceEligible, loyaltyPeriodSeconds);\r\n      thisMember.startOfLoyaltyRewardEligibility += numWholePeriods * loyaltyPeriodSeconds;\r\n    }\r\n  }\r\n\r\n  function depositInternal(\r\n    address depositer,\r\n    uint256 amount,\r\n    bool isPoolDeposit\r\n  ) \r\n    internal\r\n    returns (uint256)\r\n  {\r\n    /// @dev Explicitly checking allowance & balance before transferFrom\r\n    /// so we get the revert message.\r\n    require(amount > 0, \"Cannot deposit 0 IXT.\");\r\n    require(\r\n      ixtToken.allowance(depositer, address(this)) >= amount &&\r\n      ixtToken.balanceOf(depositer) >= amount &&\r\n      ixtToken.transferFrom(depositer, address(this), amount),\r\n      \"Unable to deposit IXT - check allowance and balance.\"  \r\n    );\r\n    if (isPoolDeposit) {\r\n      totalPoolBalance = SafeMath.add(totalPoolBalance, amount);\r\n    } else {\r\n      Member storage member = members[depositer];\r\n      member.stakeBalance = SafeMath.add(member.stakeBalance, amount);\r\n      totalMemberBalance = SafeMath.add(totalMemberBalance, amount);\r\n    }\r\n    return amount;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"members\",\"outputs\":[{\"name\":\"addedTimestamp\",\"type\":\"uint256\"},{\"name\":\"stakeTimestamp\",\"type\":\"uint256\"},{\"name\":\"startOfLoyaltyRewardEligibility\",\"type\":\"uint256\"},{\"name\":\"membershipNumber\",\"type\":\"bytes32\"},{\"name\":\"invitationCode\",\"type\":\"bytes32\"},{\"name\":\"stakeBalance\",\"type\":\"uint256\"},{\"name\":\"invitationRewards\",\"type\":\"uint256\"},{\"name\":\"previouslyAppliedLoyaltyBalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loyaltyRewardAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"userAddress\",\"type\":\"address\"}],\"name\":\"removeMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"getInvitationRewardBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_invitationReward\",\"type\":\"uint256\"}],\"name\":\"setInvitationReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountToDeposit\",\"type\":\"uint256\"}],\"name\":\"depositPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ixtStakingLevels\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimRewards\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amountToWithdraw\",\"type\":\"uint256\"}],\"name\":\"withdrawPool\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPoolBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLoyaltyRewardAmount\",\"type\":\"uint256\"}],\"name\":\"setLoyaltyRewardAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_membershipNumber\",\"type\":\"bytes32\"},{\"name\":\"_memberAddress\",\"type\":\"address\"},{\"name\":\"_invitationCode\",\"type\":\"bytes32\"},{\"name\":\"_referralInvitationCode\",\"type\":\"bytes32\"}],\"name\":\"addMember\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"invitationReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"getLoyaltyRewardBalance\",\"outputs\":[{\"name\":\"loyaltyReward\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"getAccountBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"drain\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"membersArray\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalMemberBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"registeredInvitationCodes\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"getRewardBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMembersArrayLength\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IXT_DECIMALS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"loyaltyPeriodDays\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"getStakeBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stakeLevel\",\"type\":\"uint8\"}],\"name\":\"depositStake\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceValidator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ixtToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_validator\",\"type\":\"address\"},{\"name\":\"_loyaltyPeriodDays\",\"type\":\"uint256\"},{\"name\":\"_ixtToken\",\"type\":\"address\"},{\"name\":\"_invitationReward\",\"type\":\"uint256\"},{\"name\":\"_loyaltyRewardAmount\",\"type\":\"uint256\"},{\"name\":\"_ixtStakingLevels\",\"type\":\"uint256[3]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ValidatorAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"ValidatorRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"membershipNumber\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"invitationCode\",\"type\":\"bytes32\"}],\"name\":\"MemberAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"membershipNumber\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"StakeDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"stakeAmount\",\"type\":\"uint256\"}],\"name\":\"StakeWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"RewardClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberReceivingReward\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"memberGivingReward\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"rewardAmount\",\"type\":\"uint256\"}],\"name\":\"InvitationRewardGiven\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"depositer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolDeposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"withdrawer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PoolWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"admin\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"userAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"refundIssued\",\"type\":\"uint256\"}],\"name\":\"AdminRemovedMember\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"memberAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountRefunded\",\"type\":\"uint256\"}],\"name\":\"MemberDrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"refundRecipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amountRefunded\",\"type\":\"uint256\"}],\"name\":\"PoolDrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"drainInitiator\",\"type\":\"address\"}],\"name\":\"ContractDrained\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newInvitationReward\",\"type\":\"uint256\"}],\"name\":\"InvitationRewardChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newLoyaltyRewardAmount\",\"type\":\"uint256\"}],\"name\":\"LoyaltyRewardChanged\",\"type\":\"event\"}]","ContractName":"IxtProtect","CompilerVersion":"v0.5.1+commit.c8a2cb62","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000054b9a1e220d394548113645adb50081d0f92d17c000000000000000000000000000000000000000000000000000000000000005a000000000000000000000000fca47962d45adfdfd1ab2d972315db4ce7ccf09400000000000000000000000000000000000000000000000000000004a817c800000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000174876e800000000000000000000000000000000000000000000000000000000746a528800000000000000000000000000000000000000000000000000000000e8d4a51000","Library":"","SwarmSource":"bzzr://c21a9c7be01d5eaa450509dd274825b219237d4fa735184c142b676a9c392c47"}]}