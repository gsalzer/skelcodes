{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract EthCrystal\r\n{\r\n\r\n    /*\r\n        EthCrystal.com\r\n        Thanks for choosing us!\r\n\r\n        ███████╗████████╗██╗  ██╗ ██████╗██████╗ ██╗   ██╗███████╗████████╗ █████╗ ██╗         ██████╗ ██████╗ ███╗   ███╗\r\n        ██╔════╝╚══██╔══╝██║  ██║██╔════╝██╔══██╗╚██╗ ██╔╝██╔════╝╚══██╔══╝██╔══██╗██║        ██╔════╝██╔═══██╗████╗ ████║\r\n        █████╗     ██║   ███████║██║     ██████╔╝ ╚████╔╝ ███████╗   ██║   ███████║██║        ██║     ██║   ██║██╔████╔██║\r\n        ██╔══╝     ██║   ██╔══██║██║     ██╔══██╗  ╚██╔╝  ╚════██║   ██║   ██╔══██║██║        ██║     ██║   ██║██║╚██╔╝██║\r\n        ███████╗   ██║   ██║  ██║╚██████╗██║  ██║   ██║   ███████║   ██║   ██║  ██║███████╗██╗╚██████╗╚██████╔╝██║ ╚═╝ ██║\r\n        ╚══════╝   ╚═╝   ╚═╝  ╚═╝ ╚═════╝╚═╝  ╚═╝   ╚═╝   ╚══════╝   ╚═╝   ╚═╝  ╚═╝╚══════╝╚═╝ ╚═════╝ ╚═════╝ ╚═╝     ╚═╝\r\n\r\n        #######               #####\r\n        #       ##### #    # #     # #####  #   #  ####  #####   ##   #           ####   ####  #    #\r\n        #         #   #    # #       #    #  # #  #        #    #  #  #          #    # #    # ##  ##\r\n        #####     #   ###### #       #    #   #    ####    #   #    # #          #      #    # # ## #\r\n        #         #   #    # #       #####    #        #   #   ###### #      ### #      #    # #    #\r\n        #         #   #    # #     # #   #    #   #    #   #   #    # #      ### #    # #    # #    #\r\n        #######   #   #    #  #####  #    #   #    ####    #   #    # ###### ###  ####   ####  #    #\r\n\r\n        Telegram: t.me/EthCrystalGame\r\n\r\n    */\r\n    using SafeMath for *;\r\n\r\n    struct TowersInfoList {\r\n        string name;\r\n        uint256 timeLimit; // The maximum time increasement\r\n        uint256 warriorToTime;\r\n        uint256 currentRoundID;\r\n        uint256 timerType;\r\n        uint256 growthCoefficient;\r\n        uint256 winnerShare; // % to the winner after the round [Active Fond]\r\n        uint256 nextRound; // % to the next round pot\r\n        uint256 dividendShare; // % as dividends to holders after the round\r\n\r\n        mapping (uint256 => TowersInfo) RoundList;\r\n    }\r\n\r\n    struct TowersInfo {\r\n        uint256 roundID;\r\n        uint256 towerBalance; // Balance for distribution in the end\r\n        uint256 totalBalance; // Total balance with referrer or dev %\r\n        uint256 totalWarriors;\r\n        uint256 timeToFinish;\r\n        uint256 timeLimit; // The maximum increasement\r\n        uint256 warriorToTime;\r\n        uint256 bonusPot; // % of tower balance from the previous round\r\n        address lastPlayer;\r\n        bool potReceived;\r\n        bool finished;\r\n    }\r\n\r\n    struct PlayerInfo {\r\n        uint256 playerID;\r\n        address playerAddress;\r\n        address referralAddress;\r\n        string nickname;\r\n        mapping (uint256 => TowersRoundInfo) TowersList;\r\n    }\r\n\r\n    struct TowersRoundInfo {\r\n        uint256 _TowerType;\r\n        mapping (uint256 => PlayerRoundInfo) RoundList;\r\n    }\r\n\r\n    struct PlayerRoundInfo {\r\n        uint256 warriors;\r\n        uint256 cashedOut; // To Allow cashing out before the game finished\r\n    }\r\n\r\n\r\n    struct ReferralInfo {\r\n        uint256 balance;\r\n    }\r\n\r\n    uint256 public playerID_counter = 1;\r\n\r\n    uint256 public devShare = 5; // % to devs\r\n    uint256 public affShare = 10; // bounty % to reffers\r\n\r\n    mapping (uint256 => PlayerInfo) public playersByID;\r\n    mapping (address => PlayerInfo) public players;\r\n    mapping (address => ReferralInfo) public aff;\r\n\r\n    mapping (uint256 => TowersInfoList) public GameRounds;\r\n\r\n    address public ownerAddress;\r\n    \r\n    event BuyEvent(address player, uint256 TowerID, uint256 RoundID, uint256 TotalWarriors, uint256 WarriorPrice, uint256 TimeLeft);\r\n\r\n    constructor() public {\r\n        ownerAddress = msg.sender;\r\n\r\n        // Creating different towers\r\n        GameRounds[0] = TowersInfoList(\"Crystal Tower\", 60*60*24,  30, 0, 2,      10000000000000,     35, 15, 50);\r\n        GameRounds[1] = TowersInfoList(\"Red Tower\",     60*60*24,  60, 0, 2,      20000000000000,     25,  5, 70);\r\n        GameRounds[2] = TowersInfoList(\"Gold Tower\",    60*60*12,  60*2, 0, 2,   250000000000000,     40, 10, 50);\r\n        GameRounds[3] = TowersInfoList(\"Purple Tower\",  60*60*24,  60*10, 0, 2, 5000000000000000,     30, 10, 60);\r\n        GameRounds[4] = TowersInfoList(\"Silver Tower\",  60*60*12,  60*2, 0, 2,  1000000000000000,     35, 15, 50);\r\n        GameRounds[5] = TowersInfoList(\"Black Tower\",   60*60*12,  30, 0, 2,    1000000000000000,     65, 10, 25);\r\n        GameRounds[6] = TowersInfoList(\"Toxic Tower\",   60*60*24,  60, 0, 2,    2000000000000000,     65, 10, 25);\r\n\r\n\r\n        newRound(0);\r\n        newRound(1);\r\n        newRound(2);\r\n        newRound(3);\r\n        newRound(4);\r\n        newRound(5);\r\n        newRound(6);\r\n    }\r\n\r\n    function newRound (uint256 _TowerType) private {\r\n        GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].finished = true;\r\n        GameRounds[_TowerType].currentRoundID++;\r\n        GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID] = TowersInfo(GameRounds[_TowerType].currentRoundID, 0, 0, 0, now+GameRounds[_TowerType].timeLimit, GameRounds[_TowerType].timeLimit, GameRounds[_TowerType].warriorToTime,\r\n        GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID-1].towerBalance*GameRounds[_TowerType].nextRound/100, // Moving nextRound% of the finished round balance to the next round\r\n        0x0, false, false); // New round\r\n    }\r\n\r\n    function buyWarriors (uint256 _TowerType, uint _WarriorsAmount, uint256 _referralID) public payable {\r\n        require (msg.value > 10000000); // To prevent % abusing\r\n        require (_WarriorsAmount >= 1 && _WarriorsAmount < 1000000000); // The limitation of the amount of warriors being bought in 1 time\r\n        require (GameRounds[_TowerType].timeLimit > 0);\r\n\r\n        if (players[msg.sender].playerID == 0){ // this is the new player\r\n            if (_referralID > 0 && _referralID != players[msg.sender].playerID && _referralID == playersByID[_referralID].playerID){\r\n            setNickname(\"\", playersByID[_referralID].playerAddress);  // creating the new player...\r\n            }else{\r\n            setNickname(\"\", ownerAddress);\r\n            }\r\n        }\r\n\r\n        if (GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].timeToFinish < now){\r\n            // The game was ended. Starting the new game...\r\n\r\n            // Sending pot to the winner\r\n            aff[GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].lastPlayer].balance += GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].towerBalance*GameRounds[_TowerType].winnerShare/100;\r\n\r\n            // Sending the bonus pot to the winner\r\n            aff[GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].lastPlayer].balance += GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].bonusPot;\r\n\r\n            newRound(_TowerType);\r\n            //Event Winner and the new round\r\n            //return;\r\n        }\r\n\r\n        // Getting the price of the current warrior\r\n        uint256 _totalWarriors = GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].totalWarriors;\r\n        uint256 _warriorPrice = (_totalWarriors+1)*GameRounds[_TowerType].growthCoefficient; // Warrior Price\r\n\r\n        uint256 _value = (_WarriorsAmount*_warriorPrice)+(((_WarriorsAmount-1)*(_WarriorsAmount-1)+_WarriorsAmount-1)/2)*GameRounds[_TowerType].growthCoefficient;\r\n\r\n        require (msg.value >= _value); // Player pays enough\r\n\r\n        uint256 _ethToTake = affShare+devShare; // 15%\r\n\r\n\r\n        players[msg.sender].TowersList[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].warriors += _WarriorsAmount;\r\n\r\n        if (players[players[msg.sender].referralAddress].playerID > 0 && players[msg.sender].referralAddress != ownerAddress){\r\n            // To referrer and devs\r\n            aff[players[msg.sender].referralAddress].balance += _value*affShare/100; // 10%\r\n            aff[ownerAddress].balance += _value*devShare/100; // 5%\r\n        } else {\r\n            // To devs only\r\n            _ethToTake = affShare;\r\n            aff[ownerAddress].balance += _value*_ethToTake/100; // 10%\r\n        }\r\n\r\n        if (msg.value-_value > 0){\r\n            aff[msg.sender].balance += msg.value-_value; // Returning to player the rest of eth\r\n        }\r\n\r\n        GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].towerBalance += _value*(100-_ethToTake)/100; // 10-15%\r\n        GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].totalBalance += _value;\r\n        GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].totalWarriors += _WarriorsAmount;\r\n        GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].lastPlayer = msg.sender;\r\n\r\n        // Timer increasement\r\n        GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].timeToFinish += (_WarriorsAmount).mul(GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].warriorToTime);\r\n\r\n        // if the finish time is longer than the finish\r\n        if (GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].timeToFinish > now+GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].timeLimit){\r\n            GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].timeToFinish = now+GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].timeLimit;\r\n        }\r\n        \r\n        uint256 TotalWarriors = GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].totalWarriors;\r\n        uint256 TimeLeft = GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].timeToFinish;\r\n        \r\n        // Event about the new potential winner and some Tower Details\r\n        emit BuyEvent(msg.sender,\r\n        _TowerType,\r\n        GameRounds[_TowerType].currentRoundID,\r\n        TotalWarriors,\r\n        (TotalWarriors+1)*GameRounds[_TowerType].growthCoefficient,\r\n        TimeLeft);\r\n        \r\n        return;\r\n    }\r\n\r\n    function dividendCashout (uint256 _TowerType, uint256 _RoundID) public {\r\n        require (GameRounds[_TowerType].timeLimit > 0);\r\n\r\n        uint256 _warriors = players[msg.sender].TowersList[_TowerType].RoundList[_RoundID].warriors;\r\n        require (_warriors > 0);\r\n        uint256 _totalEarned = _warriors*GameRounds[_TowerType].RoundList[_RoundID].towerBalance*GameRounds[_TowerType].dividendShare/GameRounds[_TowerType].RoundList[_RoundID].totalWarriors/100;\r\n        uint256 _alreadyCashedOut = players[msg.sender].TowersList[_TowerType].RoundList[_RoundID].cashedOut;\r\n        uint256 _earnedNow = _totalEarned-_alreadyCashedOut;\r\n        require (_earnedNow > 0); // The total amount of dividends haven't been received by the player yet\r\n\r\n        players[msg.sender].TowersList[_TowerType].RoundList[_RoundID].cashedOut = _totalEarned;\r\n\r\n        if (!msg.sender.send(_earnedNow)){\r\n            players[msg.sender].TowersList[_TowerType].RoundList[_RoundID].cashedOut = _alreadyCashedOut;\r\n        }\r\n        return;\r\n    }\r\n\r\n    function referralCashout () public {\r\n        require (aff[msg.sender].balance > 0);\r\n\r\n        uint256 _balance = aff[msg.sender].balance;\r\n\r\n        aff[msg.sender].balance = 0;\r\n\r\n        if (!msg.sender.send(_balance)){\r\n            aff[msg.sender].balance = _balance;\r\n        }\r\n    }\r\n\r\n    function setNickname (string nickname, address _referralAddress)\r\n    public {\r\n        if (players[msg.sender].playerID == 0){\r\n            players[msg.sender] = PlayerInfo (playerID_counter, msg.sender, _referralAddress, nickname);\r\n            playersByID[playerID_counter] = PlayerInfo (playerID_counter, msg.sender, _referralAddress, nickname);\r\n            playerID_counter++;\r\n        }else{\r\n            players[msg.sender].nickname = nickname;\r\n            playersByID[players[msg.sender].playerID].nickname = nickname;\r\n        }\r\n    }\r\n\r\n    function _playerRoundsInfo (address _playerAddress, uint256 _TowerType, uint256 _RoundID)\r\n    public\r\n    view\r\n    returns (uint256, uint256, uint256, uint256, uint256, bool, address) {\r\n        uint256 _warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors;\r\n        TowersInfo memory r = GameRounds[_TowerType].RoundList[_RoundID];\r\n        uint256 _totalForCashOut = (_warriors*r.towerBalance*GameRounds[_RoundID].dividendShare/r.totalWarriors/100);\r\n        bool isFinished = true;\r\n        if (GameRounds[_TowerType].RoundList[_RoundID].timeToFinish > now){\r\n            isFinished = false;\r\n        }\r\n        return (\r\n        r.towerBalance*GameRounds[_TowerType].winnerShare/100,\r\n        _currentPlayerAmountUnclaimed(_playerAddress, _TowerType, _RoundID),\r\n        _totalForCashOut,\r\n        _warriors,\r\n        r.totalWarriors,\r\n        isFinished,\r\n        r.lastPlayer);\r\n    }\r\n\r\n    function _currentWarriorPrice (uint256 _TowerType)\r\n    public\r\n    view\r\n    returns (uint256) {\r\n        return ((GameRounds[_TowerType].RoundList[GameRounds[_TowerType].currentRoundID].totalWarriors+1)*GameRounds[_TowerType].growthCoefficient);\r\n    }\r\n\r\n    function _currentPlayerAmountUnclaimed (address _playerAddress, uint256 _TowerType, uint256 _RoundID)\r\n    public\r\n    view\r\n    returns (uint256) {\r\n        if (_RoundID == 0){\r\n            _RoundID = GameRounds[_TowerType].currentRoundID;\r\n        }\r\n        uint256 _warriors = players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].warriors;\r\n        uint256 _totalForCashOut = (_warriors*GameRounds[_TowerType].RoundList[_RoundID].towerBalance*GameRounds[_RoundID].dividendShare/GameRounds[_TowerType].RoundList[_RoundID].totalWarriors/100);\r\n        uint256 _unclaimedAmount = _totalForCashOut-players[_playerAddress].TowersList[_TowerType].RoundList[_RoundID].cashedOut;\r\n        return (_unclaimedAmount);\r\n    }\r\n\r\n    function _currentPlayerAmountUnclaimedAll (address _playerAddress)\r\n    public\r\n    view\r\n    returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256) {\r\n        return (_currentPlayerAmountUnclaimed(_playerAddress, 0, 1),\r\n        _currentPlayerAmountUnclaimed(_playerAddress, 1, 1),\r\n        _currentPlayerAmountUnclaimed(_playerAddress, 2, 1),\r\n        _currentPlayerAmountUnclaimed(_playerAddress, 3, 1),\r\n        _currentPlayerAmountUnclaimed(_playerAddress, 4, 1),\r\n        _currentPlayerAmountUnclaimed(_playerAddress, 5, 1),\r\n        _currentPlayerAmountUnclaimed(_playerAddress, 6, 1));\r\n    }\r\n    /*\r\n        Gets the player details by IDs\r\n    */\r\n\r\n    function _playerInfo (uint256 _playerID)\r\n    public\r\n    view\r\n    returns (uint256, address, string, uint256) {\r\n        return (playersByID[_playerID].playerID,\r\n        playersByID[_playerID].playerAddress,\r\n        playersByID[_playerID].nickname,\r\n        aff[playersByID[_playerID].playerAddress].balance);\r\n    }\r\n    \r\n    function WarriorTotalPrice (uint256 _WarriorsAmount, uint256 _warriorPrice, uint256 coef)\r\n    public\r\n    pure\r\n    returns (uint256) {\r\n        return (_WarriorsAmount*_warriorPrice)+(((_WarriorsAmount-1)*(_WarriorsAmount-1)+_WarriorsAmount-1)/2)*coef;\r\n    }\r\n    \r\n\r\n\r\n    function _playerBalance (address _playerAddress)\r\n    public\r\n    view\r\n    returns (uint256) {\r\n        return aff[_playerAddress].balance;\r\n    }\r\n\r\n    /*\r\n        Gets the tower's details by round IDs\r\n    */\r\n    function _TowerRoundDetails (uint256 _TowerType, uint256 _RoundID)\r\n    public\r\n    view\r\n    returns (uint256, uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bool, bool) {\r\n        TowersInfo memory r = GameRounds[_TowerType].RoundList[_RoundID];\r\n        return (\r\n        r.roundID,\r\n        r.towerBalance,\r\n        r.totalBalance,\r\n        r.totalWarriors,\r\n        r.timeToFinish,\r\n        r.timeLimit,\r\n        r.warriorToTime,\r\n        r.bonusPot,\r\n        r.lastPlayer,\r\n        r.potReceived,\r\n        r.finished\r\n        );\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"},{\"name\":\"_TowerType\",\"type\":\"uint256\"},{\"name\":\"_RoundID\",\"type\":\"uint256\"}],\"name\":\"_playerRoundsInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_TowerType\",\"type\":\"uint256\"},{\"name\":\"_WarriorsAmount\",\"type\":\"uint256\"},{\"name\":\"_referralID\",\"type\":\"uint256\"}],\"name\":\"buyWarriors\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"aff\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"nickname\",\"type\":\"string\"},{\"name\":\"_referralAddress\",\"type\":\"address\"}],\"name\":\"setNickname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"GameRounds\",\"outputs\":[{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"timeLimit\",\"type\":\"uint256\"},{\"name\":\"warriorToTime\",\"type\":\"uint256\"},{\"name\":\"currentRoundID\",\"type\":\"uint256\"},{\"name\":\"timerType\",\"type\":\"uint256\"},{\"name\":\"growthCoefficient\",\"type\":\"uint256\"},{\"name\":\"winnerShare\",\"type\":\"uint256\"},{\"name\":\"nextRound\",\"type\":\"uint256\"},{\"name\":\"dividendShare\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerID\",\"type\":\"uint256\"}],\"name\":\"_playerInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"string\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_WarriorsAmount\",\"type\":\"uint256\"},{\"name\":\"_warriorPrice\",\"type\":\"uint256\"},{\"name\":\"coef\",\"type\":\"uint256\"}],\"name\":\"WarriorTotalPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"referralCashout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"playerID_counter\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playersByID\",\"outputs\":[{\"name\":\"playerID\",\"type\":\"uint256\"},{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"referralAddress\",\"type\":\"address\"},{\"name\":\"nickname\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"_playerBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_TowerType\",\"type\":\"uint256\"},{\"name\":\"_RoundID\",\"type\":\"uint256\"}],\"name\":\"_TowerRoundDetails\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"}],\"name\":\"_currentPlayerAmountUnclaimedAll\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"playerID\",\"type\":\"uint256\"},{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"referralAddress\",\"type\":\"address\"},{\"name\":\"nickname\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_playerAddress\",\"type\":\"address\"},{\"name\":\"_TowerType\",\"type\":\"uint256\"},{\"name\":\"_RoundID\",\"type\":\"uint256\"}],\"name\":\"_currentPlayerAmountUnclaimed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_TowerType\",\"type\":\"uint256\"}],\"name\":\"_currentWarriorPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_TowerType\",\"type\":\"uint256\"},{\"name\":\"_RoundID\",\"type\":\"uint256\"}],\"name\":\"dividendCashout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"TowerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"RoundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"TotalWarriors\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"WarriorPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"TimeLeft\",\"type\":\"uint256\"}],\"name\":\"BuyEvent\",\"type\":\"event\"}]","ContractName":"EthCrystal","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://29e545058bf3e0fc72ab9ae27a2f3e5d213189c790bc210256082dbe45e5c11f"}]}