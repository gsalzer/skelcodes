{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.8;\r\n\r\n\r\nlibrary BobbySafeMath {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\ncontract BobbyERC20Base {\r\n\r\n    address public ceoAddress;\r\n    address public cfoAddress;\r\n\r\n    //是否暂停智能合约的运行\r\n    bool public paused = false;\r\n\r\n    constructor(address cfoAddr) public {\r\n        ceoAddress = msg.sender;\r\n        cfoAddress = cfoAddr;\r\n    }\r\n\r\n    modifier onlyCEO() {\r\n        require(msg.sender == ceoAddress);\r\n        _;\r\n    }\r\n\r\n    function setCEO(address _newCEO) public onlyCEO {\r\n        require(_newCEO != address(0));\r\n        ceoAddress = _newCEO;\r\n    }\r\n\r\n    modifier onlyCFO() {\r\n        require(msg.sender == cfoAddress);\r\n        _;\r\n    }\r\n\r\n    modifier allButCFO() {\r\n        require(msg.sender != cfoAddress);\r\n        _;\r\n    }\r\n\r\n    function setCFO(address _newCFO) public onlyCEO {\r\n        require(_newCFO != address(0));\r\n        cfoAddress = _newCFO;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    function pause() external onlyCEO whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    function unpause() public onlyCEO whenPaused {\r\n        paused = false;\r\n    }\r\n}\r\n\r\ncontract ERC20Interface {\r\n\r\n    //ERC20指定接口\r\n    event Approval(address indexed src, address indexed guy, uint wad);\r\n    event Transfer(address indexed src, address indexed dst, uint wad);\r\n\r\n    //extend event\r\n    event Grant(address indexed src, address indexed dst, uint wad);    //发放代币，有解禁期\r\n    event Unlock(address indexed user, uint wad);                       //解禁代币\r\n\r\n    function name() public view returns (string n);\r\n    function symbol() public view returns (string s);\r\n    function decimals() public view returns (uint8 d);\r\n    function totalSupply() public view returns (uint256 t);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n}\r\n\r\n//Erc智能合约\r\ncontract ERC20 is ERC20Interface, BobbyERC20Base {\r\n    using BobbySafeMath for uint256;\r\n\r\n    uint private _Thousand = 1000;\r\n    uint private _Billion = _Thousand * _Thousand * _Thousand;\r\n\r\n    //代币基本信息\r\n    string private _name = \"BOBBYTest\";     //代币名称\r\n    string private _symbol = \"BOBBYTest\";   //代币标识\r\n    uint8 private _decimals = 9;        //小数点后位数\r\n    uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals));\r\n\r\n    //解封用户代币结构\r\n    struct UserToken {\r\n        uint index;              //放在数组中的下标\r\n        address addr;            //用户账号\r\n        uint256 tokens;          //通证数量\r\n\r\n        uint256 unlockUnit;     // 每次解锁数量\r\n        uint256 unlockPeriod;   // 解锁时间间隔\r\n        uint256 unlockLeft;     // 未解锁通证数量\r\n        uint256 unlockLastTime; // 上次解锁时间\r\n    }\r\n\r\n    mapping(address=>UserToken) private _balancesMap;           //用户可用代币映射\r\n    address[] private _balancesArray;                           //用户可用代币数组,from 1\r\n\r\n    uint32 private actionTransfer = 0;\r\n    uint32 private actionGrant = 1;\r\n    uint32 private actionUnlock = 2;\r\n\r\n    struct LogEntry {\r\n        uint256 time;\r\n        uint32  action;       // 0 转账 1 发放 2 解锁\r\n        address from;\r\n        address to;\r\n        uint256 v1;\r\n        uint256 v2;\r\n        uint256 v3;\r\n    }\r\n\r\n    LogEntry[] private _logs;\r\n\r\n    //构造方法，将代币的初始总供给都分配给合约的部署账户。合约的构造方法只在合约部署时执行一次\r\n    constructor(address cfoAddr) BobbyERC20Base(cfoAddr) public {\r\n\r\n        //placeholder\r\n        _balancesArray.push(address(0));\r\n\r\n        //此处需要注意，请使用CEO的地址,因为初始化后，将会使用这个地址作为CEO地址\r\n        //注意，一定要使用memory类型，否则，后面的赋值会影响其它成员变量\r\n        UserToken memory userCFO;\r\n        userCFO.index = _balancesArray.length;\r\n        userCFO.addr = cfoAddr;\r\n        userCFO.tokens = _totalSupply;\r\n        userCFO.unlockUnit = 0;\r\n        userCFO.unlockPeriod = 0;\r\n        userCFO.unlockLeft = 0;\r\n        userCFO.unlockLastTime = 0;\r\n        _balancesArray.push(cfoAddr);\r\n        _balancesMap[cfoAddr] = userCFO;\r\n    }\r\n\r\n    //返回合约名称。view关键子表示函数只查询状态变量，而不写入\r\n    function name() public view returns (string n){\r\n        n = _name;\r\n    }\r\n\r\n    //返回合约标识符\r\n    function symbol() public view returns (string s){\r\n        s = _symbol;\r\n    }\r\n\r\n    //返回合约小数位\r\n    function decimals() public view returns (uint8 d){\r\n        d = _decimals;\r\n    }\r\n\r\n    //返回合约总供给额\r\n    function totalSupply() public view returns (uint256 t){\r\n        t = _totalSupply;\r\n    }\r\n\r\n    //查询账户_owner的账户余额\r\n    function balanceOf(address _owner) public view returns (uint256 balance){\r\n        UserToken storage user = _balancesMap[_owner];\r\n        balance = user.tokens.add(user.unlockLeft);\r\n    }\r\n\r\n    //从代币合约的调用者地址上转移_value的数量token到的地址_to，并且必须触发Transfer事件\r\n    function transfer(address _to, uint256 _value) public returns (bool success){\r\n        require(!paused);\r\n        require(msg.sender != cfoAddress);\r\n        require(msg.sender != _to);\r\n\r\n        //先判断是否有可以解禁\r\n        if(_balancesMap[msg.sender].unlockLeft > 0){\r\n            UserToken storage sender = _balancesMap[msg.sender];\r\n            uint256 diff = now.sub(sender.unlockLastTime);\r\n            uint256 round = diff.div(sender.unlockPeriod);\r\n            if(round > 0) {\r\n                uint256 unlocked = sender.unlockUnit.mul(round);\r\n                if (unlocked > sender.unlockLeft) {\r\n                    unlocked = sender.unlockLeft;\r\n                }\r\n\r\n                sender.unlockLeft = sender.unlockLeft.sub(unlocked);\r\n                sender.tokens = sender.tokens.add(unlocked);\r\n                sender.unlockLastTime = sender.unlockLastTime.add(sender.unlockPeriod.mul(round));\r\n\r\n                emit Unlock(msg.sender, unlocked);\r\n                log(actionUnlock, msg.sender, 0, unlocked, 0, 0);\r\n            }\r\n        }\r\n\r\n        require(_balancesMap[msg.sender].tokens >= _value);\r\n        _balancesMap[msg.sender].tokens = _balancesMap[msg.sender].tokens.sub(_value);\r\n\r\n        uint index = _balancesMap[_to].index;\r\n        if(index == 0){\r\n            UserToken memory user;\r\n            user.index = _balancesArray.length;\r\n            user.addr = _to;\r\n            user.tokens = _value;\r\n            user.unlockUnit = 0;\r\n            user.unlockPeriod = 0;\r\n            user.unlockLeft = 0;\r\n            user.unlockLastTime = 0;\r\n            _balancesMap[_to] = user;\r\n            _balancesArray.push(_to);\r\n        }\r\n        else{\r\n            _balancesMap[_to].tokens = _balancesMap[_to].tokens.add(_value);\r\n        }\r\n\r\n        emit Transfer(msg.sender, _to, _value);\r\n        log(actionTransfer, msg.sender, _to, _value, 0, 0);\r\n        success = true;\r\n    }\r\n\r\n    function transferFrom(address, address, uint256) public returns (bool success){\r\n        require(!paused);\r\n        success = true;\r\n    }\r\n\r\n    function approve(address, uint256) public returns (bool success){\r\n        require(!paused);\r\n        success = true;\r\n    }\r\n\r\n    function allowance(address, address) public view returns (uint256 remaining){\r\n        require(!paused);\r\n        remaining = 0;\r\n    }\r\n\r\n    function grant(address _to, uint256 _value, uint256 _duration, uint256 _periods) public returns (bool success){\r\n        require(msg.sender != _to);\r\n        require(_balancesMap[msg.sender].tokens >= _value);\r\n        require(_balancesMap[_to].unlockLastTime == 0);\r\n\r\n        _balancesMap[msg.sender].tokens = _balancesMap[msg.sender].tokens.sub(_value);\r\n\r\n        if(_balancesMap[_to].index == 0){\r\n            UserToken memory user;\r\n            user.index = _balancesArray.length;\r\n            user.addr = _to;\r\n            user.tokens = 0;\r\n            user.unlockUnit = _value.div(_periods);\r\n            // user.unlockPeriod = _duration.mul(30).mul(1 days).div(_periods);\r\n            user.unlockPeriod = _duration.mul(1 days).div(_periods); //for test \r\n            user.unlockLeft = _value;\r\n            user.unlockLastTime = now;\r\n            _balancesMap[_to] = user;\r\n            _balancesArray.push(_to);\r\n        }\r\n        else{\r\n            _balancesMap[_to].unlockUnit = _value.div(_periods);\r\n            // _balancesMap[_to].unlockPeriod = _duration.mul(30).mul(1 days).div(_periods);\r\n            _balancesMap[_to].unlockPeriod = _duration.mul(1 days).div(_periods); //for test\r\n            _balancesMap[_to].unlockLeft = _value;\r\n            _balancesMap[_to].unlockLastTime = now;\r\n        }\r\n\r\n        emit Grant(msg.sender, _to, _value);\r\n        log(actionGrant, msg.sender, _to, _value, _duration, _periods);\r\n        success = true;\r\n    }\r\n\r\n    function getBalanceAddr(uint256 _index) public view returns(address addr){\r\n        require(_index < _balancesArray.length);\r\n        require(_index >= 0);\r\n        addr = _balancesArray[_index];\r\n    }\r\n\r\n    function getBalanceSize() public view returns(uint256 size){\r\n        size = _balancesArray.length;\r\n    }\r\n\r\n    function getLockInfo(address addr) public view returns (uint256 unlocked, uint256 unit, uint256 period, uint256 last) {\r\n        UserToken storage user = _balancesMap[addr];\r\n        unlocked = user.unlockLeft;\r\n        unit = user.unlockUnit;\r\n        period = user.unlockPeriod;\r\n        last = user.unlockLastTime;\r\n    }\r\n\r\n    function log(uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3) private {\r\n        LogEntry memory entry;\r\n        entry.action = action;\r\n        entry.time = now;\r\n        entry.from = from;\r\n        entry.to = to;\r\n        entry.v1 = _v1;\r\n        entry.v2 = _v2;\r\n        entry.v3 = _v3;\r\n        _logs.push(entry);\r\n    }\r\n\r\n    function getLogSize() public view returns(uint256 size){\r\n        size = _logs.length;\r\n    }\r\n\r\n    function getLog(uint256 _index) public view returns(uint time, uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3){\r\n        require(_index < _logs.length);\r\n        require(_index >= 0);\r\n        LogEntry storage entry = _logs[_index];\r\n        action = entry.action;\r\n        time = entry.time;\r\n        from = entry.from;\r\n        to = entry.to;\r\n        _v1 = entry.v1;\r\n        _v2 = entry.v2;\r\n        _v3 = entry.v3;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"cfoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"n\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ceoAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLogSize\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"t\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCEO\",\"type\":\"address\"}],\"name\":\"setCEO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"d\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getLog\",\"outputs\":[{\"name\":\"time\",\"type\":\"uint256\"},{\"name\":\"action\",\"type\":\"uint32\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"_v1\",\"type\":\"uint256\"},{\"name\":\"_v2\",\"type\":\"uint256\"},{\"name\":\"_v3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newCFO\",\"type\":\"address\"}],\"name\":\"setCFO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalanceSize\",\"outputs\":[{\"name\":\"size\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getLockInfo\",\"outputs\":[{\"name\":\"unlocked\",\"type\":\"uint256\"},{\"name\":\"unit\",\"type\":\"uint256\"},{\"name\":\"period\",\"type\":\"uint256\"},{\"name\":\"last\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"s\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_periods\",\"type\":\"uint256\"}],\"name\":\"grant\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"getBalanceAddr\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"cfoAddr\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"guy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"src\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"dst\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Grant\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wad\",\"type\":\"uint256\"}],\"name\":\"Unlock\",\"type\":\"event\"}]","ContractName":"ERC20","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000004d60fec50c4dfda6bbc2f047e7f9c3795bede95f","Library":"","SwarmSource":"bzzr://cebc2c006877f5b5e8d0dbe77504866597e37abf8714fd2c595c885714a392dc"}]}