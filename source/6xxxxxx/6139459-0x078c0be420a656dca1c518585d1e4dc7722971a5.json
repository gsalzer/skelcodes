{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint a, uint b) internal pure returns (uint) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint a, uint b) internal pure returns (uint) {\r\n    uint c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address internal contractOwner;\r\n\r\n  constructor () internal {\r\n    if(contractOwner == address(0)){\r\n      contractOwner = msg.sender;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == contractOwner);\r\n    _;\r\n  }\r\n  \r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    require(newOwner != address(0));\r\n    contractOwner = newOwner;\r\n  }\r\n\r\n}\r\n\r\ncontract MyCryptoChampCore{\r\n    struct Champ {\r\n        uint id;\r\n        uint attackPower;\r\n        uint defencePower;\r\n        uint cooldownTime; \r\n        uint readyTime;\r\n        uint winCount;\r\n        uint lossCount;\r\n        uint position; \r\n        uint price; \r\n        uint withdrawCooldown; \r\n        uint eq_sword; \r\n        uint eq_shield; \r\n        uint eq_helmet; \r\n        bool forSale; \r\n    }\r\n    \r\n    struct AddressInfo {\r\n        uint withdrawal;\r\n        uint champsCount;\r\n        uint itemsCount;\r\n        string name;\r\n    }\r\n\r\n    struct Item {\r\n        uint id;\r\n        uint8 itemType; \r\n        uint8 itemRarity; \r\n        uint attackPower;\r\n        uint defencePower;\r\n        uint cooldownReduction;\r\n        uint price;\r\n        uint onChampId; \r\n        bool onChamp; \r\n        bool forSale;\r\n    }\r\n    \r\n    Champ[] public champs;\r\n    Item[] public items;\r\n    mapping (uint => uint) public leaderboard;\r\n    mapping (address => AddressInfo) public addressInfo;\r\n    mapping (bool => mapping(address => mapping (address => bool))) public tokenOperatorApprovals;\r\n    mapping (bool => mapping(uint => address)) public tokenApprovals;\r\n    mapping (bool => mapping(uint => address)) public tokenToOwner;\r\n    mapping (uint => string) public champToName;\r\n    mapping (bool => uint) public tokensForSaleCount;\r\n    uint public pendingWithdrawal = 0;\r\n\r\n    function addWithdrawal(address _address, uint _amount) public;\r\n    function clearTokenApproval(address _from, uint _tokenId, bool _isTokenChamp) public;\r\n    function setChampsName(uint _champId, string _name) public;\r\n    function setLeaderboard(uint _x, uint _value) public;\r\n    function setTokenApproval(uint _id, address _to, bool _isTokenChamp) public;\r\n    function setTokenOperatorApprovals(address _from, address _to, bool _approved, bool _isTokenChamp) public;\r\n    function setTokenToOwner(uint _id, address _owner, bool _isTokenChamp) public;\r\n    function setTokensForSaleCount(uint _value, bool _isTokenChamp) public;\r\n    function transferToken(address _from, address _to, uint _id, bool _isTokenChamp) public;\r\n    function newChamp(uint _attackPower,uint _defencePower,uint _cooldownTime,uint _winCount,uint _lossCount,uint _position,uint _price,uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale,address _owner) public returns (uint);\r\n    function newItem(uint8 _itemType,uint8 _itemRarity,uint _attackPower,uint _defencePower,uint _cooldownReduction,uint _price,uint _onChampId,bool _onChamp,bool _forSale,address _owner) public returns (uint);\r\n    function updateAddressInfo(address _address, uint _withdrawal, bool _updatePendingWithdrawal, uint _champsCount, bool _updateChampsCount, uint _itemsCount, bool _updateItemsCount, string _name, bool _updateName) public;\r\n    function updateChamp(uint _champId, uint _attackPower,uint _defencePower,uint _cooldownTime,uint _readyTime,uint _winCount,uint _lossCount,uint _position,uint _price,uint _withdrawCooldown,uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale) public;\r\n    function updateItem(uint _id,uint8 _itemType,uint8 _itemRarity,uint _attackPower,uint _defencePower,uint _cooldownReduction,uint _price,uint _onChampId,bool _onChamp,bool _forSale) public;\r\n\r\n    function getChampStats(uint256 _champId) public view returns(uint256,uint256,uint256);\r\n    function getChampsByOwner(address _owner) external view returns(uint256[]);\r\n    function getTokensForSale(bool _isTokenChamp) view external returns(uint256[]);\r\n    function getItemsByOwner(address _owner) external view returns(uint256[]);\r\n    function getTokenCount(bool _isTokenChamp) external view returns(uint);\r\n    function getTokenURIs(uint _tokenId, bool _isTokenChamp) public view returns(string);\r\n    function onlyApprovedOrOwnerOfToken(uint _id, address _msgsender, bool _isTokenChamp) external view returns(bool);\r\n    \r\n}\r\n\r\ncontract Inherit is Ownable{\r\n  address internal coreAddress;\r\n  MyCryptoChampCore internal core;\r\n\r\n  modifier onlyCore(){\r\n    require(msg.sender == coreAddress);\r\n    _;\r\n  }\r\n\r\n  function loadCoreAddress(address newCoreAddress) public onlyOwner {\r\n    require(newCoreAddress != address(0));\r\n    coreAddress = newCoreAddress;\r\n    core = MyCryptoChampCore(coreAddress);\r\n  }\r\n\r\n}\r\n\r\ncontract Strings {\r\n\r\n    function strConcat(string _a, string _b) internal pure returns (string){\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        string memory ab = new string(_ba.length + _bb.length);\r\n        bytes memory bab = bytes(ab);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) bab[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) bab[k++] = _bb[i];\r\n        return string(bab);\r\n    }\r\n\r\n    function uint2str(uint i) internal pure returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n}\r\n\r\n//ERC721 Contract \r\ninterface EC {\r\n    function emitTransfer(address _from, address _to, uint _tokenId) external; //Controller uses only this one function\r\n}\r\n\r\n//author Patrik Mojzis\r\ncontract Controller is Inherit, Strings {\r\n\r\n    using SafeMath for uint; \r\n\r\n    struct Champ {\r\n        uint id; //same as position in Champ[]\r\n        uint attackPower;\r\n        uint defencePower;\r\n        uint cooldownTime; //how long does it take to be ready attack again\r\n        uint readyTime; //if is smaller than block.timestamp champ is ready to fight\r\n        uint winCount;\r\n        uint lossCount;\r\n        uint position; //position in leaderboard. subtract 1 and you got position in leaderboard[]\r\n        uint price; //selling price\r\n        uint withdrawCooldown; //if you one of the 800 best champs and withdrawCooldown is less as block.timestamp then you get ETH reward\r\n        uint eq_sword; \r\n        uint eq_shield; \r\n        uint eq_helmet; \r\n        bool forSale; //is champ for sale?\r\n    }\r\n\r\n    struct Item {\r\n        uint id;\r\n        uint8 itemType; // 1 - Sword | 2 - Shield | 3 - Helmet\r\n        uint8 itemRarity; // 1 - Common | 2 - Uncommon | 3 - Rare | 4 - Epic | 5 - Legendery | 6 - Forged\r\n        uint attackPower;\r\n        uint defencePower;\r\n        uint cooldownReduction;\r\n        uint price;\r\n        uint onChampId; //can not be used to decide if item is on champ, because champ's id can be 0, 'bool onChamp' solves it.\r\n        bool onChamp; \r\n        bool forSale; //is item for sale?\r\n    }\r\n\r\n    EC champsEC;\r\n    EC itemsEC;\r\n     \r\n    /// @notice People are allowed to withdraw only if min. balance (0.01 gwei) is reached\r\n    modifier contractMinBalanceReached(){\r\n        uint pendingWithdrawal = core.pendingWithdrawal();\r\n        require( (address(core).balance).sub(pendingWithdrawal) > 1000000 );\r\n        _;\r\n    }\r\n    \r\n    modifier onlyApprovedOrOwnerOfToken(uint _id, address _msgsender, bool _isTokenChamp) \r\n    {\r\n        require(core.onlyApprovedOrOwnerOfToken(_id, _msgsender, _isTokenChamp));\r\n        _;\r\n    }\r\n    \r\n\r\n    /// @notice Gets champ's reward in wei\r\n    function getChampReward(uint _position) public view returns(uint) \r\n    {\r\n        if(_position <= 800){\r\n            //percentageMultipier = 10,000\r\n            //maxReward = 2000 = .2% * percentageMultipier\r\n            //subtractPerPosition = 2 = .0002% * percentageMultipier\r\n            //2000 - (2 * (_position - 1))\r\n            uint rewardPercentage = uint(2000).sub(2 * (_position - 1));\r\n\r\n            //available funds are all funds - already pending\r\n            uint availableWithdrawal = address(coreAddress).balance.sub(core.pendingWithdrawal());\r\n\r\n            //calculate reward for champ's position\r\n            //1000000 = percentageMultipier * 100\r\n            return availableWithdrawal / 1000000 * rewardPercentage;\r\n        }else{\r\n            return uint(0);\r\n        }\r\n    }\r\n\r\n    function setChampEC(address _address) public onlyOwner {\r\n        champsEC = EC(_address);\r\n    }\r\n\r\n\r\n    function setItemsEC(address _address) public onlyOwner {\r\n        itemsEC = EC(_address);\r\n    }\r\n\r\n    function changeChampsName(uint _champId, string _name, address _msgsender) external \r\n    onlyApprovedOrOwnerOfToken(_champId, _msgsender, true)\r\n    onlyCore\r\n    {\r\n        core.setChampsName(_champId, _name);\r\n    }\r\n\r\n    /// @dev Move champ reward to pending withdrawal to his wallet. \r\n    function withdrawChamp(uint _id, address _msgsender) external \r\n    onlyApprovedOrOwnerOfToken(_id, _msgsender, true) \r\n    contractMinBalanceReached  \r\n    onlyCore \r\n    {\r\n        Champ memory champ = _getChamp(_id);\r\n        require(champ.position <= 800); \r\n        require(champ.withdrawCooldown < block.timestamp); //isChampWithdrawReady\r\n\r\n        champ.withdrawCooldown = block.timestamp + 1 days; //one withdrawal 1 per day\r\n        _updateChamp(champ); //update core storage\r\n\r\n        core.addWithdrawal(_msgsender, getChampReward(champ.position));\r\n    }\r\n    \r\n\r\n    /// @dev Is called from from Attack function after the winner is already chosen. Updates abilities, champ's stats and swaps positions.\r\n    function _attackCompleted(Champ memory _winnerChamp, Champ memory _defeatedChamp, uint _pointsGiven) private \r\n    {\r\n        /*\r\n         * Updates abilities after fight\r\n         */\r\n        //winner abilities update\r\n        _winnerChamp.attackPower += _pointsGiven; //increase attack power\r\n        _winnerChamp.defencePower += _pointsGiven; //max point that was given - already given to AP\r\n                \r\n        //defeated champ's abilities update\r\n        //checks for not cross minimal AP & DP points\r\n        //_defeatedChamp.attackPower = _subAttack(_defeatedChamp.attackPower, _pointsGiven); //decrease attack power\r\n        _defeatedChamp.attackPower = (_defeatedChamp.attackPower <= _pointsGiven + 2) ? 2 : _defeatedChamp.attackPower - _pointsGiven; //Subtracts ability points. Helps to not cross minimal attack ability points -> 2\r\n\r\n        //_defeatedChamp.defencePower = _subDefence(_defeatedChamp.defencePower, _pointsGiven); // decrease defence power\r\n        _defeatedChamp.defencePower = (_defeatedChamp.defencePower <= _pointsGiven) ? 1 : _defeatedChamp.defencePower - _pointsGiven; //Subtracts ability points. Helps to not cross minimal defence ability points -> 1\r\n\r\n\r\n        /*\r\n         * Update champs' wins and losses\r\n         */\r\n        _winnerChamp.winCount++;\r\n        _defeatedChamp.lossCount++;\r\n            \r\n\r\n        /*\r\n         * Swap positions\r\n         */\r\n        if(_winnerChamp.position > _defeatedChamp.position) { //require loser to has better (lower) postion than attacker\r\n            uint winnerPosition = _winnerChamp.position;\r\n            uint loserPosition = _defeatedChamp.position;\r\n        \r\n            _defeatedChamp.position = winnerPosition;\r\n            _winnerChamp.position = loserPosition;\r\n        }\r\n\r\n        _updateChamp(_winnerChamp);\r\n        _updateChamp(_defeatedChamp);\r\n    }\r\n\r\n\r\n    /*\r\n     * External\r\n     */\r\n    function attack(uint _champId, uint _targetId, address _msgsender) external \r\n    onlyApprovedOrOwnerOfToken(_champId, _msgsender, true) \r\n    onlyCore \r\n    {\r\n        Champ memory myChamp = _getChamp(_champId); \r\n        Champ memory enemyChamp = _getChamp(_targetId); \r\n        \r\n        require (myChamp.readyTime <= block.timestamp); /// Is champ ready to fight again?\r\n        require(_champId != _targetId); /// Prevents from self-attack\r\n        require(core.tokenToOwner(true, _targetId) != address(0)); /// Checks if champ does exist\r\n    \r\n        uint pointsGiven; //total points that will be divided between AP and DP\r\n        uint myChampAttackPower;  \r\n        uint enemyChampDefencePower; \r\n        uint myChampCooldownReduction;\r\n        \r\n        (myChampAttackPower,,myChampCooldownReduction) = core.getChampStats(_champId);\r\n        (,enemyChampDefencePower,) = core.getChampStats(_targetId);\r\n\r\n\r\n        //if attacker's AP is more than target's DP then attacker wins\r\n        if (myChampAttackPower > enemyChampDefencePower) {\r\n            \r\n            //this should demotivate players from farming on way weaker champs than they are\r\n            //the bigger difference between AP & DP is, the reward is smaller\r\n            if(myChampAttackPower - enemyChampDefencePower < 5){\r\n                pointsGiven = 6; //big experience - 6 ability points\r\n            }else if(myChampAttackPower - enemyChampDefencePower < 10){\r\n                pointsGiven = 4; //medium experience - 4 ability points\r\n            }else{\r\n                pointsGiven = 2; //small experience - 2 ability point to random ability (attack power or defence power)\r\n            }\r\n            \r\n            _attackCompleted(myChamp, enemyChamp, pointsGiven/2);\r\n\r\n        } else {\r\n            \r\n            //1 ability point to random ability (attack power or defence power)\r\n            pointsGiven = 2;\r\n\r\n            _attackCompleted(enemyChamp, myChamp, pointsGiven/2);\r\n             \r\n        }\r\n        \r\n        //Trigger cooldown for attacker\r\n        myChamp.readyTime = uint(block.timestamp + myChamp.cooldownTime - myChampCooldownReduction);\r\n\r\n        _updateChamp(myChamp);\r\n\r\n    }\r\n\r\n     function _cancelChampSale(Champ memory _champ) private \r\n     {\r\n        //cancel champ's sale\r\n        //no need waste gas to overwrite his price.\r\n        _champ.forSale = false;\r\n\r\n        /*\r\n        uint champsForSaleCount = core.champsForSaleCount() - 1;\r\n        core.setTokensForSaleCount(champsForSaleCount, true);\r\n        */\r\n\r\n        _updateChamp(_champ);\r\n     }\r\n     \r\n\r\n    function _transferChamp(address _from, address _to, uint _champId) private onlyCore\r\n    {\r\n        Champ memory champ = _getChamp(_champId);\r\n\r\n        //ifChampForSaleThenCancelSale\r\n        if(champ.forSale){\r\n             _cancelChampSale(champ);\r\n        }\r\n\r\n        core.clearTokenApproval(_from, _champId, true);\r\n\r\n        //transfer champ\r\n        (,uint toChampsCount,,) = core.addressInfo(_to); \r\n        (,uint fromChampsCount,,) = core.addressInfo(_from);\r\n\r\n        core.updateAddressInfo(_to,0,false,toChampsCount + 1,true,0,false,\"\",false);\r\n        core.updateAddressInfo(_from,0,false,fromChampsCount - 1,true,0,false,\"\",false);\r\n\r\n        core.setTokenToOwner(_champId, _to, true);\r\n\r\n        champsEC.emitTransfer(_from,_to,_champId);\r\n\r\n        //transfer items\r\n        if(champ.eq_sword != 0) { _transferItem(_from, _to, champ.eq_sword); }\r\n        if(champ.eq_shield != 0) { _transferItem(_from, _to, champ.eq_shield); }\r\n        if(champ.eq_helmet != 0) { _transferItem(_from, _to, champ.eq_helmet); }\r\n    }\r\n\r\n\r\n    function transferToken(address _from, address _to, uint _id, bool _isTokenChamp) external\r\n    onlyCore{\r\n        if(_isTokenChamp){\r\n            _transferChamp(_from, _to, _id);\r\n        }else{\r\n            _transferItem(_from, _to, _id);\r\n        }\r\n    }\r\n\r\n    function cancelTokenSale(uint _id, address _msgsender, bool _isTokenChamp) public \r\n      onlyApprovedOrOwnerOfToken(_id, _msgsender, _isTokenChamp)\r\n      onlyCore \r\n    {\r\n        if(_isTokenChamp){\r\n            Champ memory champ = _getChamp(_id);\r\n            require(champ.forSale); //champIsForSale\r\n            _cancelChampSale(champ);\r\n        }else{\r\n            Item memory item = _getItem(_id);\r\n          require(item.forSale);\r\n           _cancelItemSale(item);\r\n        }\r\n    }\r\n\r\n    /// @dev Address _from is msg.sender\r\n    function giveToken(address _to, uint _id, address _msgsender, bool _isTokenChamp) external \r\n      onlyApprovedOrOwnerOfToken(_id, _msgsender, _isTokenChamp)\r\n      onlyCore \r\n    {\r\n        if(_isTokenChamp){\r\n            _transferChamp(core.tokenToOwner(true,_id), _to, _id);\r\n        }else{\r\n             _transferItem(core.tokenToOwner(false,_id), _to, _id);\r\n        }\r\n    }\r\n\r\n\r\n    function setTokenForSale(uint _id, uint _price, address _msgsender, bool _isTokenChamp) external \r\n      onlyApprovedOrOwnerOfToken(_id, _msgsender, _isTokenChamp) \r\n      onlyCore \r\n    {\r\n        if(_isTokenChamp){\r\n            Champ memory champ = _getChamp(_id);\r\n            require(champ.forSale == false); //champIsNotForSale\r\n            champ.forSale = true;\r\n            champ.price = _price;\r\n            _updateChamp(champ);\r\n            \r\n            /*\r\n            uint champsForSaleCount = core.champsForSaleCount() + 1;\r\n            core.setTokensForSaleCount(champsForSaleCount,true);\r\n            */\r\n        }else{\r\n            Item memory item = _getItem(_id);\r\n            require(item.forSale == false);\r\n            item.forSale = true;\r\n            item.price = _price;\r\n            _updateItem(item);\r\n            \r\n            /*\r\n            uint itemsForSaleCount = core.itemsForSaleCount() + 1;\r\n            core.setTokensForSaleCount(itemsForSaleCount,false);\r\n            */\r\n        }\r\n\r\n    }\r\n\r\n    function _updateChamp(Champ memory champ) private \r\n    {\r\n        core.updateChamp(champ.id, champ.attackPower, champ.defencePower, champ.cooldownTime, champ.readyTime, champ.winCount, champ.lossCount, champ.position, champ.price, champ.withdrawCooldown, champ.eq_sword, champ.eq_shield, champ.eq_helmet, champ.forSale);\r\n    }\r\n\r\n    function _updateItem(Item memory item) private\r\n    {\r\n        core.updateItem(item.id, item.itemType, item.itemRarity, item.attackPower, item.defencePower, item.cooldownReduction,item.price, item.onChampId, item.onChamp, item.forSale);\r\n    }\r\n    \r\n    function _getChamp(uint _champId) private view returns (Champ)\r\n    {\r\n        Champ memory champ;\r\n        \r\n        //CompilerError: Stack too deep, try removing local variables.\r\n        (champ.id, champ.attackPower, champ.defencePower, champ.cooldownTime, champ.readyTime, champ.winCount, champ.lossCount, champ.position,,,,,,) = core.champs(_champId);\r\n        (,,,,,,,,champ.price, champ.withdrawCooldown, champ.eq_sword, champ.eq_shield, champ.eq_helmet, champ.forSale) = core.champs(_champId);\r\n        \r\n        return champ;\r\n    }\r\n    \r\n    function _getItem(uint _itemId) private view returns (Item)\r\n    {\r\n        Item memory item;\r\n        \r\n        //CompilerError: Stack too deep, try removing local variables.\r\n        (item.id, item.itemType, item.itemRarity, item.attackPower, item.defencePower, item.cooldownReduction,,,,) = core.items(_itemId);\r\n        (,,,,,,item.price, item.onChampId, item.onChamp, item.forSale) = core.items(_itemId);\r\n        \r\n        return item;\r\n    }\r\n\r\n    function getTokenURIs(uint _id, bool _isTokenChamp) public pure returns(string)\r\n    {\r\n        if(_isTokenChamp){\r\n            return strConcat('https://mccapi.patrikmojzis.com/champ.php?id=', uint2str(_id));\r\n        }else{\r\n            return strConcat('https://mccapi.patrikmojzis.com/item.php?id=', uint2str(_id));\r\n        }\r\n    }\r\n\r\n\r\n    function _takeOffItem(uint _champId, uint8 _type) private\r\n    {\r\n        uint itemId;\r\n        Champ memory champ = _getChamp(_champId);\r\n        if(_type == 1){\r\n            itemId = champ.eq_sword; //Get item ID\r\n            if (itemId > 0) { //0 = nothing\r\n                champ.eq_sword = 0; //take off sword\r\n            }\r\n        }\r\n        if(_type == 2){\r\n            itemId = champ.eq_shield; //Get item ID\r\n            if(itemId > 0) {//0 = nothing\r\n                champ.eq_shield = 0; //take off shield\r\n            }\r\n        }\r\n        if(_type == 3){\r\n            itemId = champ.eq_helmet; //Get item ID\r\n            if(itemId > 0) { //0 = nothing\r\n                champ.eq_helmet = 0; //take off \r\n            }\r\n        }\r\n        if(itemId > 0){\r\n            Item memory item = _getItem(itemId);\r\n            item.onChamp = false;\r\n            _updateItem(item);\r\n        }\r\n    }\r\n\r\n    function takeOffItem(uint _champId, uint8 _type, address _msgsender) public \r\n    onlyApprovedOrOwnerOfToken(_champId, _msgsender, true) \r\n    onlyCore\r\n    {\r\n            _takeOffItem(_champId, _type);\r\n    }\r\n\r\n    function putOn(uint _champId, uint _itemId, address _msgsender) external \r\n        onlyApprovedOrOwnerOfToken(_champId, _msgsender, true) \r\n        onlyApprovedOrOwnerOfToken(_itemId, _msgsender, false) \r\n        onlyCore \r\n        {\r\n            Champ memory champ = _getChamp(_champId);\r\n            Item memory item = _getItem(_itemId);\r\n\r\n            //checks if items is on some other champ\r\n            if(item.onChamp){\r\n                _takeOffItem(item.onChampId, item.itemType); //take off from champ\r\n            }\r\n\r\n            item.onChamp = true; //item is on champ\r\n            item.onChampId = _champId; //champ's id\r\n\r\n            //put on\r\n            if(item.itemType == 1){\r\n                //take off actual sword \r\n                if(champ.eq_sword > 0){\r\n                    _takeOffItem(champ.id, 1);\r\n                }\r\n                champ.eq_sword = _itemId; //put on sword\r\n            }\r\n            if(item.itemType == 2){\r\n                //take off actual shield \r\n                if(champ.eq_shield > 0){\r\n                    _takeOffItem(champ.id, 2);\r\n                }\r\n                champ.eq_shield = _itemId; //put on shield\r\n            }\r\n            if(item.itemType == 3){\r\n                //take off actual helmet \r\n                if(champ.eq_helmet > 0){\r\n                    _takeOffItem(champ.id, 3);\r\n                }\r\n                champ.eq_helmet = _itemId; //put on helmet\r\n            }\r\n\r\n            _updateChamp(champ);\r\n            _updateItem(item);\r\n    }\r\n\r\n\r\n    function _cancelItemSale(Item memory item) private {\r\n      //No need to overwrite item's price\r\n      item.forSale = false;\r\n      \r\n      /*\r\n      uint itemsForSaleCount = core.itemsForSaleCount() - 1;\r\n      core.setTokensForSaleCount(itemsForSaleCount, false);\r\n      */\r\n\r\n      _updateItem(item);\r\n    }\r\n\r\n    function _transferItem(address _from, address _to, uint _itemID) private \r\n    {\r\n        Item memory item = _getItem(_itemID);\r\n\r\n        if(item.forSale){\r\n              _cancelItemSale(item);\r\n        }\r\n\r\n        //take off      \r\n        if(item.onChamp && _to != core.tokenToOwner(true, item.onChampId)){\r\n          _takeOffItem(item.onChampId, item.itemType);\r\n        }\r\n\r\n        core.clearTokenApproval(_from, _itemID, false);\r\n\r\n        //transfer item\r\n        (,,uint toItemsCount,) = core.addressInfo(_to);\r\n        (,,uint fromItemsCount,) = core.addressInfo(_from);\r\n\r\n        core.updateAddressInfo(_to,0,false,0,false,toItemsCount + 1,true,\"\",false);\r\n        core.updateAddressInfo(_from,0,false,0,false,fromItemsCount - 1,true,\"\",false);\r\n        \r\n        core.setTokenToOwner(_itemID, _to,false);\r\n\r\n        itemsEC.emitTransfer(_from,_to,_itemID);\r\n    }\r\n\r\n    function forgeItems(uint _parentItemID, uint _childItemID, address _msgsender) external \r\n    onlyApprovedOrOwnerOfToken(_parentItemID, _msgsender, false) \r\n    onlyApprovedOrOwnerOfToken(_childItemID, _msgsender, false) \r\n    onlyCore\r\n    {\r\n        //checks if items are not the same\r\n        require(_parentItemID != _childItemID);\r\n        \r\n        Item memory parentItem = _getItem(_parentItemID);\r\n        Item memory childItem = _getItem(_childItemID);\r\n        \r\n        //if Item For Sale Then Cancel Sale\r\n        if(parentItem.forSale){\r\n          _cancelItemSale(parentItem);\r\n        }\r\n        \r\n        //if Item For Sale Then Cancel Sale\r\n        if(childItem.forSale){\r\n          _cancelItemSale(childItem);\r\n        }\r\n\r\n        //take child item off, because child item will be burned\r\n        if(childItem.onChamp){\r\n            _takeOffItem(childItem.onChampId, childItem.itemType);\r\n        }\r\n\r\n        //update parent item\r\n        parentItem.attackPower = (parentItem.attackPower > childItem.attackPower) ? parentItem.attackPower : childItem.attackPower;\r\n        parentItem.defencePower = (parentItem.defencePower > childItem.defencePower) ? parentItem.defencePower : childItem.defencePower;\r\n        parentItem.cooldownReduction = (parentItem.cooldownReduction > childItem.cooldownReduction) ? parentItem.cooldownReduction : childItem.cooldownReduction;\r\n        parentItem.itemRarity = uint8(6);\r\n\r\n        _updateItem(parentItem);\r\n\r\n        //burn child item\r\n        _transferItem(core.tokenToOwner(false,_childItemID), address(0), _childItemID);\r\n\r\n    }\r\n\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_msgsender\",\"type\":\"address\"}],\"name\":\"changeChampsName\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_msgsender\",\"type\":\"address\"},{\"name\":\"_isTokenChamp\",\"type\":\"bool\"}],\"name\":\"cancelTokenSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_msgsender\",\"type\":\"address\"},{\"name\":\"_isTokenChamp\",\"type\":\"bool\"}],\"name\":\"giveToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setChampEC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_isTokenChamp\",\"type\":\"bool\"}],\"name\":\"transferToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"},{\"name\":\"_type\",\"type\":\"uint8\"},{\"name\":\"_msgsender\",\"type\":\"address\"}],\"name\":\"takeOffItem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_position\",\"type\":\"uint256\"}],\"name\":\"getChampReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_parentItemID\",\"type\":\"uint256\"},{\"name\":\"_childItemID\",\"type\":\"uint256\"},{\"name\":\"_msgsender\",\"type\":\"address\"}],\"name\":\"forgeItems\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_price\",\"type\":\"uint256\"},{\"name\":\"_msgsender\",\"type\":\"address\"},{\"name\":\"_isTokenChamp\",\"type\":\"bool\"}],\"name\":\"setTokenForSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_msgsender\",\"type\":\"address\"}],\"name\":\"withdrawChamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"},{\"name\":\"_itemId\",\"type\":\"uint256\"},{\"name\":\"_msgsender\",\"type\":\"address\"}],\"name\":\"putOn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setItemsEC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_champId\",\"type\":\"uint256\"},{\"name\":\"_targetId\",\"type\":\"uint256\"},{\"name\":\"_msgsender\",\"type\":\"address\"}],\"name\":\"attack\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"},{\"name\":\"_isTokenChamp\",\"type\":\"bool\"}],\"name\":\"getTokenURIs\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCoreAddress\",\"type\":\"address\"}],\"name\":\"loadCoreAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"Controller","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://c67b3d4319352bb86d7dff4c72964da6f4ac2397efa08849f76cecda2b190ccc"}]}