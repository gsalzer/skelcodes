{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\n/// @title provides subject to role checking logic\r\ncontract IAccessPolicy {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice We don't make this function constant to allow for state-updating access controls such as rate limiting.\r\n    /// @dev checks if subject belongs to requested role for particular object\r\n    /// @param subject address to be checked against role, typically msg.sender\r\n    /// @param role identifier of required role\r\n    /// @param object contract instance context for role checking, typically contract requesting the check\r\n    /// @param verb additional data, in current AccessControll implementation msg.sig\r\n    /// @return if subject belongs to a role\r\n    function allowed(\r\n        address subject,\r\n        bytes32 role,\r\n        address object,\r\n        bytes4 verb\r\n    )\r\n        public\r\n        returns (bool);\r\n}\r\n\r\n/// @title enables access control in implementing contract\r\n/// @dev see AccessControlled for implementation\r\ncontract IAccessControlled {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// @dev must log on access policy change\r\n    event LogAccessPolicyChanged(\r\n        address controller,\r\n        IAccessPolicy oldPolicy,\r\n        IAccessPolicy newPolicy\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev allows to change access control mechanism for this contract\r\n    ///     this method must be itself access controlled, see AccessControlled implementation and notice below\r\n    /// @notice it is a huge issue for Solidity that modifiers are not part of function signature\r\n    ///     then interfaces could be used for example to control access semantics\r\n    /// @param newPolicy new access policy to controll this contract\r\n    /// @param newAccessController address of ROLE_ACCESS_CONTROLLER of new policy that can set access to this contract\r\n    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\r\n        public;\r\n\r\n    function accessPolicy()\r\n        public\r\n        constant\r\n        returns (IAccessPolicy);\r\n\r\n}\r\n\r\ncontract StandardRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // @notice Soldity somehow doesn't evaluate this compile time\r\n    // @dev role which has rights to change permissions and set new policy in contract, keccak256(\"AccessController\")\r\n    bytes32 internal constant ROLE_ACCESS_CONTROLLER = 0xac42f8beb17975ed062dcb80c63e6d203ef1c2c335ced149dc5664cc671cb7da;\r\n}\r\n\r\n/// @title Granular code execution permissions\r\n/// @notice Intended to replace existing Ownable pattern with more granular permissions set to execute smart contract functions\r\n///     for each function where 'only' modifier is applied, IAccessPolicy implementation is called to evaluate if msg.sender belongs to required role for contract being called.\r\n///     Access evaluation specific belong to IAccessPolicy implementation, see RoleBasedAccessPolicy for details.\r\n/// @dev Should be inherited by a contract requiring such permissions controll. IAccessPolicy must be provided in constructor. Access policy may be replaced to a different one\r\n///     by msg.sender with ROLE_ACCESS_CONTROLLER role\r\ncontract AccessControlled is IAccessControlled, StandardRoles {\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    IAccessPolicy private _accessPolicy;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    /// @dev limits function execution only to senders assigned to required 'role'\r\n    modifier only(bytes32 role) {\r\n        require(_accessPolicy.allowed(msg.sender, role, this, msg.sig));\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(IAccessPolicy policy) internal {\r\n        require(address(policy) != 0x0);\r\n        _accessPolicy = policy;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements IAccessControlled\r\n    //\r\n\r\n    function setAccessPolicy(IAccessPolicy newPolicy, address newAccessController)\r\n        public\r\n        only(ROLE_ACCESS_CONTROLLER)\r\n    {\r\n        // ROLE_ACCESS_CONTROLLER must be present\r\n        // under the new policy. This provides some\r\n        // protection against locking yourself out.\r\n        require(newPolicy.allowed(newAccessController, ROLE_ACCESS_CONTROLLER, this, msg.sig));\r\n\r\n        // We can now safely set the new policy without foot shooting.\r\n        IAccessPolicy oldPolicy = _accessPolicy;\r\n        _accessPolicy = newPolicy;\r\n\r\n        // Log event\r\n        emit LogAccessPolicyChanged(msg.sender, oldPolicy, newPolicy);\r\n    }\r\n\r\n    function accessPolicy()\r\n        public\r\n        constant\r\n        returns (IAccessPolicy)\r\n    {\r\n        return _accessPolicy;\r\n    }\r\n}\r\n\r\n/// @title standard access roles of the Platform\r\n/// @dev constants are kept in CODE not in STORAGE so they are comparatively cheap\r\ncontract AccessRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // NOTE: All roles are set to the keccak256 hash of the\r\n    // CamelCased role name, i.e.\r\n    // ROLE_LOCKED_ACCOUNT_ADMIN = keccak256(\"LockedAccountAdmin\")\r\n\r\n    // May issue (generate) Neumarks\r\n    bytes32 internal constant ROLE_NEUMARK_ISSUER = 0x921c3afa1f1fff707a785f953a1e197bd28c9c50e300424e015953cbf120c06c;\r\n\r\n    // May burn Neumarks it owns\r\n    bytes32 internal constant ROLE_NEUMARK_BURNER = 0x19ce331285f41739cd3362a3ec176edffe014311c0f8075834fdd19d6718e69f;\r\n\r\n    // May create new snapshots on Neumark\r\n    bytes32 internal constant ROLE_SNAPSHOT_CREATOR = 0x08c1785afc57f933523bc52583a72ce9e19b2241354e04dd86f41f887e3d8174;\r\n\r\n    // May enable/disable transfers on Neumark\r\n    bytes32 internal constant ROLE_TRANSFER_ADMIN = 0xb6527e944caca3d151b1f94e49ac5e223142694860743e66164720e034ec9b19;\r\n\r\n    // may reclaim tokens/ether from contracts supporting IReclaimable interface\r\n    bytes32 internal constant ROLE_RECLAIMER = 0x0542bbd0c672578966dcc525b30aa16723bb042675554ac5b0362f86b6e97dc5;\r\n\r\n    // represents legally platform operator in case of forks and contracts with legal agreement attached. keccak256(\"PlatformOperatorRepresentative\")\r\n    bytes32 internal constant ROLE_PLATFORM_OPERATOR_REPRESENTATIVE = 0xb2b321377653f655206f71514ff9f150d0822d062a5abcf220d549e1da7999f0;\r\n\r\n    // allows to deposit EUR-T and allow addresses to send and receive EUR-T. keccak256(\"EurtDepositManager\")\r\n    bytes32 internal constant ROLE_EURT_DEPOSIT_MANAGER = 0x7c8ecdcba80ce87848d16ad77ef57cc196c208fc95c5638e4a48c681a34d4fe7;\r\n\r\n    // allows to register identities and change associated claims keccak256(\"IdentityManager\")\r\n    bytes32 internal constant ROLE_IDENTITY_MANAGER = 0x32964e6bc50f2aaab2094a1d311be8bda920fc4fb32b2fb054917bdb153a9e9e;\r\n\r\n    // allows to replace controller on euro token and to destroy tokens without withdraw kecckak256(\"EurtLegalManager\")\r\n    bytes32 internal constant ROLE_EURT_LEGAL_MANAGER = 0x4eb6b5806954a48eb5659c9e3982d5e75bfb2913f55199877d877f157bcc5a9b;\r\n\r\n    // allows to change known interfaces in universe kecckak256(\"UniverseManager\")\r\n    bytes32 internal constant ROLE_UNIVERSE_MANAGER = 0xe8d8f8f9ea4b19a5a4368dbdace17ad71a69aadeb6250e54c7b4c7b446301738;\r\n\r\n    // allows to exchange gas for EUR-T keccak(\"GasExchange\")\r\n    bytes32 internal constant ROLE_GAS_EXCHANGE = 0x9fe43636e0675246c99e96d7abf9f858f518b9442c35166d87f0934abef8a969;\r\n\r\n    // allows to set token exchange rates keccak(\"TokenRateOracle\")\r\n    bytes32 internal constant ROLE_TOKEN_RATE_ORACLE = 0xa80c3a0c8a5324136e4c806a778583a2a980f378bdd382921b8d28dcfe965585;\r\n}\r\n\r\ncontract IEthereumForkArbiter {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogForkAnnounced(\r\n        string name,\r\n        string url,\r\n        uint256 blockNumber\r\n    );\r\n\r\n    event LogForkSigned(\r\n        uint256 blockNumber,\r\n        bytes32 blockHash\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function nextForkName()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function nextForkUrl()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function nextForkBlockNumber()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    function lastSignedBlockNumber()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    function lastSignedBlockHash()\r\n        public\r\n        constant\r\n        returns (bytes32);\r\n\r\n    function lastSignedTimestamp()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n}\r\n\r\n/**\r\n * @title legally binding smart contract\r\n * @dev General approach to paring legal and smart contracts:\r\n * 1. All terms and agreement are between two parties: here between smart conctract legal representation and platform investor.\r\n * 2. Parties are represented by public Ethereum addresses. Platform investor is and address that holds and controls funds and receives and controls Neumark token\r\n * 3. Legal agreement has immutable part that corresponds to smart contract code and mutable part that may change for example due to changing regulations or other externalities that smart contract does not control.\r\n * 4. There should be a provision in legal document that future changes in mutable part cannot change terms of immutable part.\r\n * 5. Immutable part links to corresponding smart contract via its address.\r\n * 6. Additional provision should be added if smart contract supports it\r\n *  a. Fork provision\r\n *  b. Bugfixing provision (unilateral code update mechanism)\r\n *  c. Migration provision (bilateral code update mechanism)\r\n *\r\n * Details on Agreement base class:\r\n * 1. We bind smart contract to legal contract by storing uri (preferably ipfs or hash) of the legal contract in the smart contract. It is however crucial that such binding is done by smart contract legal representation so transaction establishing the link must be signed by respective wallet ('amendAgreement')\r\n * 2. Mutable part of agreement may change. We should be able to amend the uri later. Previous amendments should not be lost and should be retrievable (`amendAgreement` and 'pastAgreement' functions).\r\n * 3. It is up to deriving contract to decide where to put 'acceptAgreement' modifier. However situation where there is no cryptographic proof that given address was really acting in the transaction should be avoided, simplest example being 'to' address in `transfer` function of ERC20.\r\n *\r\n**/\r\ncontract IAgreement {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogAgreementAccepted(\r\n        address indexed accepter\r\n    );\r\n\r\n    event LogAgreementAmended(\r\n        address contractLegalRepresentative,\r\n        string agreementUri\r\n    );\r\n\r\n    /// @dev should have access restrictions so only contractLegalRepresentative may call\r\n    function amendAgreement(string agreementUri) public;\r\n\r\n    /// returns information on last amendment of the agreement\r\n    /// @dev MUST revert if no agreements were set\r\n    function currentAgreement()\r\n        public\r\n        constant\r\n        returns\r\n        (\r\n            address contractLegalRepresentative,\r\n            uint256 signedBlockTimestamp,\r\n            string agreementUri,\r\n            uint256 index\r\n        );\r\n\r\n    /// returns information on amendment with index\r\n    /// @dev MAY revert on non existing amendment, indexing starts from 0\r\n    function pastAgreement(uint256 amendmentIndex)\r\n        public\r\n        constant\r\n        returns\r\n        (\r\n            address contractLegalRepresentative,\r\n            uint256 signedBlockTimestamp,\r\n            string agreementUri,\r\n            uint256 index\r\n        );\r\n\r\n    /// returns the number of block at wchich `signatory` signed agreement\r\n    /// @dev MUST return 0 if not signed\r\n    function agreementSignedAtBlock(address signatory)\r\n        public\r\n        constant\r\n        returns (uint256 blockNo);\r\n\r\n    /// returns number of amendments made by contractLegalRepresentative\r\n    function amendmentsCount()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n}\r\n\r\n/**\r\n * @title legally binding smart contract\r\n * @dev read IAgreement for details\r\n**/\r\ncontract Agreement is\r\n    IAgreement,\r\n    AccessControlled,\r\n    AccessRoles\r\n{\r\n\r\n    ////////////////////////\r\n    // Type declarations\r\n    ////////////////////////\r\n\r\n    /// @notice agreement with signature of the platform operator representative\r\n    struct SignedAgreement {\r\n        address contractLegalRepresentative;\r\n        uint256 signedBlockTimestamp;\r\n        string agreementUri;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    IEthereumForkArbiter private ETHEREUM_FORK_ARBITER;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // stores all amendments to the agreement, first amendment is the original\r\n    SignedAgreement[] private _amendments;\r\n\r\n    // stores block numbers of all addresses that signed the agreement (signatory => block number)\r\n    mapping(address => uint256) private _signatories;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    /// @notice logs that agreement was accepted by platform user\r\n    /// @dev intended to be added to functions that if used make 'accepter' origin to enter legally binding agreement\r\n    modifier acceptAgreement(address accepter) {\r\n        acceptAgreementInternal(accepter);\r\n        _;\r\n    }\r\n\r\n    modifier onlyLegalRepresentative(address legalRepresentative) {\r\n        require(mCanAmend(legalRepresentative));\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(IAccessPolicy accessPolicy, IEthereumForkArbiter forkArbiter)\r\n        AccessControlled(accessPolicy)\r\n        internal\r\n    {\r\n        require(forkArbiter != IEthereumForkArbiter(0x0));\r\n        ETHEREUM_FORK_ARBITER = forkArbiter;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function amendAgreement(string agreementUri)\r\n        public\r\n        onlyLegalRepresentative(msg.sender)\r\n    {\r\n        SignedAgreement memory amendment = SignedAgreement({\r\n            contractLegalRepresentative: msg.sender,\r\n            signedBlockTimestamp: block.timestamp,\r\n            agreementUri: agreementUri\r\n        });\r\n        _amendments.push(amendment);\r\n        emit LogAgreementAmended(msg.sender, agreementUri);\r\n    }\r\n\r\n    function ethereumForkArbiter()\r\n        public\r\n        constant\r\n        returns (IEthereumForkArbiter)\r\n    {\r\n        return ETHEREUM_FORK_ARBITER;\r\n    }\r\n\r\n    function currentAgreement()\r\n        public\r\n        constant\r\n        returns\r\n        (\r\n            address contractLegalRepresentative,\r\n            uint256 signedBlockTimestamp,\r\n            string agreementUri,\r\n            uint256 index\r\n        )\r\n    {\r\n        require(_amendments.length > 0);\r\n        uint256 last = _amendments.length - 1;\r\n        SignedAgreement storage amendment = _amendments[last];\r\n        return (\r\n            amendment.contractLegalRepresentative,\r\n            amendment.signedBlockTimestamp,\r\n            amendment.agreementUri,\r\n            last\r\n        );\r\n    }\r\n\r\n    function pastAgreement(uint256 amendmentIndex)\r\n        public\r\n        constant\r\n        returns\r\n        (\r\n            address contractLegalRepresentative,\r\n            uint256 signedBlockTimestamp,\r\n            string agreementUri,\r\n            uint256 index\r\n        )\r\n    {\r\n        SignedAgreement storage amendment = _amendments[amendmentIndex];\r\n        return (\r\n            amendment.contractLegalRepresentative,\r\n            amendment.signedBlockTimestamp,\r\n            amendment.agreementUri,\r\n            amendmentIndex\r\n        );\r\n    }\r\n\r\n    function agreementSignedAtBlock(address signatory)\r\n        public\r\n        constant\r\n        returns (uint256 blockNo)\r\n    {\r\n        return _signatories[signatory];\r\n    }\r\n\r\n    function amendmentsCount()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _amendments.length;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// provides direct access to derived contract\r\n    function acceptAgreementInternal(address accepter)\r\n        internal\r\n    {\r\n        if(_signatories[accepter] == 0) {\r\n            require(_amendments.length > 0);\r\n            _signatories[accepter] = block.number;\r\n            emit LogAgreementAccepted(accepter);\r\n        }\r\n    }\r\n\r\n    //\r\n    // MAgreement Internal interface (todo: extract)\r\n    //\r\n\r\n    /// default amend permission goes to ROLE_PLATFORM_OPERATOR_REPRESENTATIVE\r\n    function mCanAmend(address legalRepresentative)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return accessPolicy().allowed(legalRepresentative, ROLE_PLATFORM_OPERATOR_REPRESENTATIVE, this, msg.sig);\r\n    }\r\n}\r\n\r\n/// @title access to snapshots of a token\r\n/// @notice allows to implement complex token holder rights like revenue disbursal or voting\r\n/// @notice snapshots are series of values with assigned ids. ids increase strictly. particular id mechanism is not assumed\r\ncontract ITokenSnapshots {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice Total amount of tokens at a specific `snapshotId`.\r\n    /// @param snapshotId of snapshot at which totalSupply is queried\r\n    /// @return The total amount of tokens at `snapshotId`\r\n    /// @dev reverts on snapshotIds greater than currentSnapshotId()\r\n    /// @dev returns 0 for snapshotIds less than snapshotId of first value\r\n    function totalSupplyAt(uint256 snapshotId)\r\n        public\r\n        constant\r\n        returns(uint256);\r\n\r\n    /// @dev Queries the balance of `owner` at a specific `snapshotId`\r\n    /// @param owner The address from which the balance will be retrieved\r\n    /// @param snapshotId of snapshot at which the balance is queried\r\n    /// @return The balance at `snapshotId`\r\n    function balanceOfAt(address owner, uint256 snapshotId)\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    /// @notice upper bound of series of snapshotIds for which there's a value in series\r\n    /// @return snapshotId\r\n    function currentSnapshotId()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n}\r\n\r\n/// @title represents link between cloned and parent token\r\n/// @dev when token is clone from other token, initial balances of the cloned token\r\n///     correspond to balances of parent token at the moment of parent snapshot id specified\r\n/// @notice please note that other tokens beside snapshot token may be cloned\r\ncontract IClonedTokenParent is ITokenSnapshots {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n\r\n    /// @return address of parent token, address(0) if root\r\n    /// @dev parent token does not need to clonable, nor snapshottable, just a normal token\r\n    function parentToken()\r\n        public\r\n        constant\r\n        returns(IClonedTokenParent parent);\r\n\r\n    /// @return snapshot at wchich initial token distribution was taken\r\n    function parentSnapshotId()\r\n        public\r\n        constant\r\n        returns(uint256 snapshotId);\r\n}\r\n\r\ncontract IBasicToken {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event Transfer(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n\r\n    /// @param owner The address that's balance is being requested\r\n    /// @return The balance of `owner` at the current block\r\n    function balanceOf(address owner)\r\n        public\r\n        constant\r\n        returns (uint256 balance);\r\n\r\n    /// @notice Send `amount` tokens to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC20Allowance {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event Approval(\r\n        address indexed owner,\r\n        address indexed spender,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param owner The address of the account that owns the token\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of owner that spender is allowed\r\n    ///  to spend\r\n    function allowance(address owner, address spender)\r\n        public\r\n        constant\r\n        returns (uint256 remaining);\r\n\r\n    /// @notice `msg.sender` approves `spender` to spend `amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  to be a little bit safer\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True if the approval was successful\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n    /// @notice Send `amount` tokens to `to` from `from` on the condition it\r\n    ///  is approved by `from`\r\n    /// @param from The address holding the tokens being transferred\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful\r\n    function transferFrom(address from, address to, uint256 amount)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC20Token is IBasicToken, IERC20Allowance {\r\n\r\n}\r\n\r\ncontract ITokenMetadata {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function symbol()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function name()\r\n        public\r\n        constant\r\n        returns (string);\r\n\r\n    function decimals()\r\n        public\r\n        constant\r\n        returns (uint8);\r\n}\r\n\r\ncontract IERC223Token is IERC20Token, ITokenMetadata {\r\n\r\n    /// @dev Departure: We do not log data, it has no advantage over a standard\r\n    ///     log event. By sticking to the standard log event we\r\n    ///     stay compatible with constracts that expect and ERC20 token.\r\n\r\n    // event Transfer(\r\n    //    address indexed from,\r\n    //    address indexed to,\r\n    //    uint256 amount,\r\n    //    bytes data);\r\n\r\n\r\n    /// @dev Departure: We do not use the callback on regular transfer calls to\r\n    ///     stay compatible with constracts that expect and ERC20 token.\r\n\r\n    // function transfer(address to, uint256 amount)\r\n    //     public\r\n    //     returns (bool);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function transfer(address to, uint256 amount, bytes data)\r\n        public\r\n        returns (bool);\r\n}\r\n\r\ncontract IERC677Allowance is IERC20Allowance {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice `msg.sender` approves `spender` to send `amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param spender The address of the contract able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True if the function call was successful\r\n    function approveAndCall(address spender, uint256 amount, bytes extraData)\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract IERC677Token is IERC20Token, IERC677Allowance {\r\n}\r\n\r\n/// @title hooks token controller to token contract and allows to replace it\r\ncontract ITokenControllerHook {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogChangeTokenController(\r\n        address oldController,\r\n        address newController,\r\n        address by\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice replace current token controller\r\n    /// @dev please note that this process is also controlled by existing controller\r\n    function changeTokenController(address newController)\r\n        public;\r\n\r\n    /// @notice returns current controller\r\n    function tokenController()\r\n        public\r\n        constant\r\n        returns (address currentController);\r\n\r\n}\r\n\r\n/// @title state space of ETOCommitment\r\ncontract IETOCommitmentStates {\r\n    ////////////////////////\r\n    // Types\r\n    ////////////////////////\r\n\r\n    // order must reflect time precedence, do not change order below\r\n    enum ETOState {\r\n        Setup, // Initial state\r\n        Whitelist,\r\n        Public,\r\n        Signing,\r\n        Claim,\r\n        Payout, // Terminal state\r\n        Refund // Terminal state\r\n    }\r\n\r\n    // number of states in enum\r\n    uint256 constant internal ETO_STATES_COUNT = 7;\r\n}\r\n\r\n/// @title provides callback on state transitions\r\n/// @dev observer called after the state() of commitment contract was set\r\ncontract IETOCommitmentObserver is IETOCommitmentStates {\r\n    function commitmentObserver() public constant returns (address);\r\n    function onStateTransition(ETOState oldState, ETOState newState) public;\r\n}\r\n\r\n/// @title current ERC223 fallback function\r\n/// @dev to be used in all future token contract\r\n/// @dev NEU and ICBMEtherToken (obsolete) are the only contracts that still uses IERC223LegacyCallback\r\ncontract IERC223Callback {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function tokenFallback(address from, uint256 amount, bytes data)\r\n        public;\r\n\r\n}\r\n\r\n/// @title granular token controller based on MSnapshotToken observer pattern\r\ncontract ITokenController {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice see MTokenTransferController\r\n    /// @dev additionally passes broker that is executing transaction between from and to\r\n    ///      for unbrokered transfer, broker == from\r\n    function onTransfer(address broker, address from, address to, uint256 amount)\r\n        public\r\n        constant\r\n        returns (bool allow);\r\n\r\n    /// @notice see MTokenAllowanceController\r\n    function onApprove(address owner, address spender, uint256 amount)\r\n        public\r\n        constant\r\n        returns (bool allow);\r\n\r\n    /// @notice see MTokenMint\r\n    function onGenerateTokens(address sender, address owner, uint256 amount)\r\n        public\r\n        constant\r\n        returns (bool allow);\r\n\r\n    /// @notice see MTokenMint\r\n    function onDestroyTokens(address sender, address owner, uint256 amount)\r\n        public\r\n        constant\r\n        returns (bool allow);\r\n\r\n    /// @notice controls if sender can change controller to newController\r\n    /// @dev for this to succeed TYPICALLY current controller must be already migrated to a new one\r\n    function onChangeTokenController(address sender, address newController)\r\n        public\r\n        constant\r\n        returns (bool);\r\n\r\n    /// @notice overrides spender allowance\r\n    /// @dev may be used to implemented forced transfers in which token controller may override approved allowance\r\n    ///      with any > 0 value and then use transferFrom to execute such transfer\r\n    ///      This by definition creates non-trustless token so do not implement this call if you do not need trustless transfers!\r\n    ///      Implementer should not allow approve() to be executed if there is an overrride\r\n    //       Implemented should return allowance() taking into account override\r\n    function onAllowance(address owner, address spender)\r\n        public\r\n        constant\r\n        returns (uint256 allowanceOverride);\r\n}\r\n\r\ncontract IEquityTokenController is\r\n    IAgreement,\r\n    ITokenController,\r\n    IETOCommitmentObserver,\r\n    IERC223Callback\r\n{\r\n    /// controls if sender can change old nominee to new nominee\r\n    /// @dev for this to succeed typically a voting of the token holders should happen and new nominee should be set\r\n    function onChangeNominee(address sender, address oldNominee, address newNominee)\r\n        public\r\n        constant\r\n        returns (bool);\r\n}\r\n\r\ncontract IEquityToken is\r\n    IAgreement,\r\n    IClonedTokenParent,\r\n    IERC223Token,\r\n    ITokenControllerHook\r\n{\r\n    /// @dev equity token is not divisible (Decimals == 0) but single share is represented by\r\n    ///  tokensPerShare tokens\r\n    function tokensPerShare() public constant returns (uint256);\r\n\r\n    // number of shares represented by tokens. we round to the closest value.\r\n    function sharesTotalSupply() public constant returns (uint256);\r\n\r\n    /// nominal value of a share in EUR decimal(18) precision\r\n    function shareNominalValueEurUlps() public constant returns (uint256);\r\n\r\n    // returns company legal representative account that never changes\r\n    function companyLegalRepresentative() public constant returns (address);\r\n\r\n    /// returns current nominee which is contract legal rep\r\n    function nominee() public constant returns (address);\r\n\r\n    /// only by previous nominee\r\n    function changeNominee(address newNominee) public;\r\n\r\n    /// controlled, always issues to msg.sender\r\n    function issueTokens(uint256 amount) public;\r\n\r\n    /// controlled, may send tokens even when transfer are disabled: to active ETO only\r\n    function distributeTokens(address to, uint256 amount) public;\r\n\r\n    // controlled, msg.sender is typically failed ETO\r\n    function destroyTokens(uint256 amount) public;\r\n}\r\n\r\n/// @title describes layout of claims in 256bit records stored for identities\r\n/// @dev intended to be derived by contracts requiring access to particular claims\r\ncontract IdentityRecord {\r\n\r\n    ////////////////////////\r\n    // Types\r\n    ////////////////////////\r\n\r\n    /// @dev here the idea is to have claims of size of uint256 and use this struct\r\n    ///     to translate in and out of this struct. until we do not cross uint256 we\r\n    ///     have binary compatibility\r\n    struct IdentityClaims {\r\n        bool isVerified; // 1 bit\r\n        bool isSophisticatedInvestor; // 1 bit\r\n        bool hasBankAccount; // 1 bit\r\n        bool accountFrozen; // 1 bit\r\n        // uint252 reserved\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// translates uint256 to struct\r\n    function deserializeClaims(bytes32 data) internal pure returns (IdentityClaims memory claims) {\r\n        // for memory layout of struct, each field below word length occupies whole word\r\n        assembly {\r\n            mstore(claims, and(data, 0x1))\r\n            mstore(add(claims, 0x20), div(and(data, 0x2), 0x2))\r\n            mstore(add(claims, 0x40), div(and(data, 0x4), 0x4))\r\n            mstore(add(claims, 0x60), div(and(data, 0x8), 0x8))\r\n        }\r\n    }\r\n}\r\n\r\n\r\n/// @title interface storing and retrieve 256bit claims records for identity\r\n/// actual format of record is decoupled from storage (except maximum size)\r\ncontract IIdentityRegistry {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// provides information on setting claims\r\n    event LogSetClaims(\r\n        address indexed identity,\r\n        bytes32 oldClaims,\r\n        bytes32 newClaims\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// get claims for identity\r\n    function getClaims(address identity) public constant returns (bytes32);\r\n\r\n    /// set claims for identity\r\n    /// @dev odlClaims and newClaims used for optimistic locking. to override with newClaims\r\n    ///     current claims must be oldClaims\r\n    function setClaims(address identity, bytes32 oldClaims, bytes32 newClaims) public;\r\n}\r\n\r\n/// @title known interfaces (services) of the platform\r\n/// \"known interface\" is a unique id of service provided by the platform and discovered via Universe contract\r\n///  it does not refer to particular contract/interface ABI, particular service may be delivered via different implementations\r\n///  however for a few contracts we commit platform to particular implementation (all ICBM Contracts, Universe itself etc.)\r\n/// @dev constants are kept in CODE not in STORAGE so they are comparatively cheap\r\ncontract KnownInterfaces {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // NOTE: All interface are set to the keccak256 hash of the\r\n    // CamelCased interface or singleton name, i.e.\r\n    // KNOWN_INTERFACE_NEUMARK = keccak256(\"Neumark\")\r\n\r\n    // EIP 165 + EIP 820 should be use instead but it seems they are far from finished\r\n    // also interface signature should be build automatically by solidity. otherwise it is a pure hassle\r\n\r\n    // neumark token interface and sigleton keccak256(\"Neumark\")\r\n    bytes4 internal constant KNOWN_INTERFACE_NEUMARK = 0xeb41a1bd;\r\n\r\n    // ether token interface and singleton keccak256(\"EtherToken\")\r\n    bytes4 internal constant KNOWN_INTERFACE_ETHER_TOKEN = 0x8cf73cf1;\r\n\r\n    // euro token interface and singleton keccak256(\"EuroToken\")\r\n    bytes4 internal constant KNOWN_INTERFACE_EURO_TOKEN = 0x83c3790b;\r\n\r\n    // identity registry interface and singleton keccak256(\"IIdentityRegistry\")\r\n    bytes4 internal constant KNOWN_INTERFACE_IDENTITY_REGISTRY = 0x0a72e073;\r\n\r\n    // currency rates oracle interface and singleton keccak256(\"ITokenExchangeRateOracle\")\r\n    bytes4 internal constant KNOWN_INTERFACE_TOKEN_EXCHANGE_RATE_ORACLE = 0xc6e5349e;\r\n\r\n    // fee disbursal interface and singleton keccak256(\"IFeeDisbursal\")\r\n    bytes4 internal constant KNOWN_INTERFACE_FEE_DISBURSAL = 0xf4c848e8;\r\n\r\n    // platform portfolio holding equity tokens belonging to NEU holders keccak256(\"IPlatformPortfolio\");\r\n    bytes4 internal constant KNOWN_INTERFACE_PLATFORM_PORTFOLIO = 0xaa1590d0;\r\n\r\n    // token exchange interface and singleton keccak256(\"ITokenExchange\")\r\n    bytes4 internal constant KNOWN_INTERFACE_TOKEN_EXCHANGE = 0xddd7a521;\r\n\r\n    // service exchanging euro token for gas (\"IGasTokenExchange\")\r\n    bytes4 internal constant KNOWN_INTERFACE_GAS_EXCHANGE = 0x89dbc6de;\r\n\r\n    // access policy interface and singleton keccak256(\"IAccessPolicy\")\r\n    bytes4 internal constant KNOWN_INTERFACE_ACCESS_POLICY = 0xb05049d9;\r\n\r\n    // euro lock account (upgraded) keccak256(\"LockedAccount:Euro\")\r\n    bytes4 internal constant KNOWN_INTERFACE_EURO_LOCK = 0x2347a19e;\r\n\r\n    // ether lock account (upgraded) keccak256(\"LockedAccount:Ether\")\r\n    bytes4 internal constant KNOWN_INTERFACE_ETHER_LOCK = 0x978a6823;\r\n\r\n    // icbm euro lock account keccak256(\"ICBMLockedAccount:Euro\")\r\n    bytes4 internal constant KNOWN_INTERFACE_ICBM_EURO_LOCK = 0x36021e14;\r\n\r\n    // ether lock account (upgraded) keccak256(\"ICBMLockedAccount:Ether\")\r\n    bytes4 internal constant KNOWN_INTERFACE_ICBM_ETHER_LOCK = 0x0b58f006;\r\n\r\n    // ether token interface and singleton keccak256(\"ICBMEtherToken\")\r\n    bytes4 internal constant KNOWN_INTERFACE_ICBM_ETHER_TOKEN = 0xae8b50b9;\r\n\r\n    // euro token interface and singleton keccak256(\"ICBMEuroToken\")\r\n    bytes4 internal constant KNOWN_INTERFACE_ICBM_EURO_TOKEN = 0xc2c6cd72;\r\n\r\n    // ICBM commitment interface interface and singleton keccak256(\"ICBMCommitment\")\r\n    bytes4 internal constant KNOWN_INTERFACE_ICBM_COMMITMENT = 0x7f2795ef;\r\n\r\n    // ethereum fork arbiter interface and singleton keccak256(\"IEthereumForkArbiter\")\r\n    bytes4 internal constant KNOWN_INTERFACE_FORK_ARBITER = 0x2fe7778c;\r\n\r\n    // Platform terms interface and singletong keccak256(\"PlatformTerms\")\r\n    bytes4 internal constant KNOWN_INTERFACE_PLATFORM_TERMS = 0x75ecd7f8;\r\n\r\n    // for completness we define Universe service keccak256(\"Universe\");\r\n    bytes4 internal constant KNOWN_INTERFACE_UNIVERSE = 0xbf202454;\r\n\r\n    // ETO commitment interface (collection) keccak256(\"ICommitment\")\r\n    bytes4 internal constant KNOWN_INTERFACE_COMMITMENT = 0xfa0e0c60;\r\n\r\n    // Equity Token Controller interface (collection) keccak256(\"IEquityTokenController\")\r\n    bytes4 internal constant KNOWN_INTERFACE_EQUITY_TOKEN_CONTROLLER = 0xfa30b2f1;\r\n\r\n    // Equity Token interface (collection) keccak256(\"IEquityToken\")\r\n    bytes4 internal constant KNOWN_INTERFACE_EQUITY_TOKEN = 0xab9885bb;\r\n}\r\n\r\n/// @notice implemented in the contract that is the target of state migration\r\n/// @dev implementation must provide actual function that will be called by source to migrate state\r\ncontract IMigrationTarget {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // should return migration source address\r\n    function currentMigrationSource()\r\n        public\r\n        constant\r\n        returns (address);\r\n}\r\n\r\n/// @notice implemented in the contract that stores state to be migrated\r\n/// @notice contract is called migration source\r\n/// @dev migration target implements IMigrationTarget interface, when it is passed in 'enableMigration' function\r\n/// @dev 'migrate' function may be called to migrate part of state owned by msg.sender\r\n/// @dev in legal terms this corresponds to amending/changing agreement terms by co-signature of parties\r\ncontract IMigrationSource {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogMigrationEnabled(\r\n        address target\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice should migrate state owned by msg.sender\r\n    /// @dev intended flow is to: read source state, clear source state, call migrate function on target, log success event\r\n    function migrate()\r\n        public;\r\n\r\n    /// @notice should enable migration to migration target\r\n    /// @dev should limit access to specific role in implementation\r\n    function enableMigration(IMigrationTarget migration)\r\n        public;\r\n\r\n    /// @notice returns current migration target\r\n    function currentMigrationTarget()\r\n        public\r\n        constant\r\n        returns (IMigrationTarget);\r\n}\r\n\r\n/// @notice mixin that enables migration pattern for a contract\r\n/// @dev when derived from\r\ncontract MigrationSource is\r\n    IMigrationSource,\r\n    AccessControlled\r\n{\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    /// stores role hash that can enable migration\r\n    bytes32 private MIGRATION_ADMIN;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // migration target contract\r\n    IMigrationTarget internal _migration;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    /// @notice add to enableMigration function to prevent changing of migration\r\n    ///     target once set\r\n    modifier onlyMigrationEnabledOnce() {\r\n        require(address(_migration) == 0);\r\n        _;\r\n    }\r\n\r\n    modifier onlyMigrationEnabled() {\r\n        require(address(_migration) != 0);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        IAccessPolicy policy,\r\n        bytes32 migrationAdminRole\r\n    )\r\n        AccessControlled(policy)\r\n        internal\r\n    {\r\n        MIGRATION_ADMIN = migrationAdminRole;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice should migrate state that belongs to msg.sender\r\n    /// @dev do not forget to add accessor `onlyMigrationEnabled` modifier in implementation\r\n    function migrate()\r\n        public;\r\n\r\n    /// @notice should enable migration to migration target\r\n    /// @dev do not forget to add accessor modifier in override\r\n    function enableMigration(IMigrationTarget migration)\r\n        public\r\n        onlyMigrationEnabledOnce()\r\n        only(MIGRATION_ADMIN)\r\n    {\r\n        // this must be the source\r\n        require(migration.currentMigrationSource() == address(this));\r\n        _migration = migration;\r\n        emit LogMigrationEnabled(_migration);\r\n    }\r\n\r\n    /// @notice returns current migration target\r\n    function currentMigrationTarget()\r\n        public\r\n        constant\r\n        returns (IMigrationTarget)\r\n    {\r\n        return _migration;\r\n    }\r\n}\r\n\r\ncontract IsContract {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function isContract(address addr)\r\n        internal\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint256 size;\r\n        // takes 700 gas\r\n        assembly { size := extcodesize(addr) }\r\n        return size > 0;\r\n    }\r\n}\r\n\r\n/// @title allows deriving contract to recover any token or ether that it has balance of\r\n/// @notice note that this opens your contracts to claims from various people saying they lost tokens and they want them back\r\n///     be ready to handle such claims\r\n/// @dev use with care!\r\n///     1. ROLE_RECLAIMER is allowed to claim tokens, it's not returning tokens to original owner\r\n///     2. in derived contract that holds any token by design you must override `reclaim` and block such possibility.\r\n///         see ICBMLockedAccount as an example\r\ncontract Reclaimable is AccessControlled, AccessRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    IBasicToken constant internal RECLAIM_ETHER = IBasicToken(0x0);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function reclaim(IBasicToken token)\r\n        public\r\n        only(ROLE_RECLAIMER)\r\n    {\r\n        address reclaimer = msg.sender;\r\n        if(token == RECLAIM_ETHER) {\r\n            reclaimer.transfer(address(this).balance);\r\n        } else {\r\n            uint256 balance = token.balanceOf(this);\r\n            require(token.transfer(reclaimer, balance));\r\n        }\r\n    }\r\n}\r\n\r\n/// @title adds token metadata to token contract\r\n/// @dev see Neumark for example implementation\r\ncontract TokenMetadata is ITokenMetadata {\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // The Token's name: e.g. DigixDAO Tokens\r\n    string private NAME;\r\n\r\n    // An identifier: e.g. REP\r\n    string private SYMBOL;\r\n\r\n    // Number of decimals of the smallest unit\r\n    uint8 private DECIMALS;\r\n\r\n    // An arbitrary versioning scheme\r\n    string private VERSION;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @notice Constructor to set metadata\r\n    /// @param tokenName Name of the new token\r\n    /// @param decimalUnits Number of decimals of the new token\r\n    /// @param tokenSymbol Token Symbol for the new token\r\n    /// @param version Token version ie. when cloning is used\r\n    constructor(\r\n        string tokenName,\r\n        uint8 decimalUnits,\r\n        string tokenSymbol,\r\n        string version\r\n    )\r\n        public\r\n    {\r\n        NAME = tokenName;                                 // Set the name\r\n        SYMBOL = tokenSymbol;                             // Set the symbol\r\n        DECIMALS = decimalUnits;                          // Set the decimals\r\n        VERSION = version;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function name()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return NAME;\r\n    }\r\n\r\n    function symbol()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return SYMBOL;\r\n    }\r\n\r\n    function decimals()\r\n        public\r\n        constant\r\n        returns (uint8)\r\n    {\r\n        return DECIMALS;\r\n    }\r\n\r\n    function version()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return VERSION;\r\n    }\r\n}\r\n\r\n/// @title controls spending approvals\r\n/// @dev TokenAllowance observes this interface, Neumark contract implements it\r\ncontract MTokenAllowanceController {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// @notice Notifies the controller about an approval allowing the\r\n    ///  controller to react if desired\r\n    /// @param owner The address that calls `approve()`\r\n    /// @param spender The spender in the `approve()` call\r\n    /// @param amount The amount in the `approve()` call\r\n    /// @return False if the controller does not authorize the approval\r\n    function mOnApprove(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (bool allow);\r\n\r\n    /// @notice Allows to override allowance approved by the owner\r\n    ///         Primary role is to enable forced transfers, do not override if you do not like it\r\n    ///         Following behavior is expected in the observer\r\n    ///         approve() - should revert if mAllowanceOverride() > 0\r\n    ///         allowance() - should return mAllowanceOverride() if set\r\n    ///         transferFrom() - should override allowance if mAllowanceOverride() > 0\r\n    /// @param owner An address giving allowance to spender\r\n    /// @param spender An address getting  a right to transfer allowance amount from the owner\r\n    /// @return current allowance amount\r\n    function mAllowanceOverride(\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint256 allowance);\r\n}\r\n\r\n/// @title controls token transfers\r\n/// @dev BasicSnapshotToken observes this interface, Neumark contract implements it\r\ncontract MTokenTransferController {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// @notice Notifies the controller about a token transfer allowing the\r\n    ///  controller to react if desired\r\n    /// @param from The origin of the transfer\r\n    /// @param to The destination of the transfer\r\n    /// @param amount The amount of the transfer\r\n    /// @return False if the controller does not authorize the transfer\r\n    function mOnTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        returns (bool allow);\r\n\r\n}\r\n\r\n/// @title controls approvals and transfers\r\n/// @dev The token controller contract must implement these functions, see Neumark as example\r\n/// @dev please note that controller may be a separate contract that is called from mOnTransfer and mOnApprove functions\r\ncontract MTokenController is MTokenTransferController, MTokenAllowanceController {\r\n}\r\n\r\ncontract TrustlessTokenController is\r\n    MTokenController\r\n{\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements MTokenController\r\n    //\r\n\r\n    function mOnTransfer(\r\n        address /*from*/,\r\n        address /*to*/,\r\n        uint256 /*amount*/\r\n    )\r\n        internal\r\n        returns (bool allow)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    function mOnApprove(\r\n        address /*owner*/,\r\n        address /*spender*/,\r\n        uint256 /*amount*/\r\n    )\r\n        internal\r\n        returns (bool allow)\r\n    {\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract IERC677Callback {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // NOTE: This call can be initiated by anyone. You need to make sure that\r\n    // it is send by the token (`require(msg.sender == token)`) or make sure\r\n    // amount is valid (`require(token.allowance(this) >= amount)`).\r\n    function receiveApproval(\r\n        address from,\r\n        uint256 amount,\r\n        address token, // IERC667Token\r\n        bytes data\r\n    )\r\n        public\r\n        returns (bool success);\r\n\r\n}\r\n\r\ncontract Math {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    // absolute difference: |v1 - v2|\r\n    function absDiff(uint256 v1, uint256 v2)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return v1 > v2 ? v1 - v2 : v2 - v1;\r\n    }\r\n\r\n    // divide v by d, round up if remainder is 0.5 or more\r\n    function divRound(uint256 v, uint256 d)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return add(v, d/2) / d;\r\n    }\r\n\r\n    // computes decimal decimalFraction 'frac' of 'amount' with maximum precision (multiplication first)\r\n    // both amount and decimalFraction must have 18 decimals precision, frac 10**18 represents a whole (100% of) amount\r\n    // mind loss of precision as decimal fractions do not have finite binary expansion\r\n    // do not use instead of division\r\n    function decimalFraction(uint256 amount, uint256 frac)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        // it's like 1 ether is 100% proportion\r\n        return proportion(amount, frac, 10**18);\r\n    }\r\n\r\n    // computes part/total of amount with maximum precision (multiplication first)\r\n    // part and total must have the same units\r\n    function proportion(uint256 amount, uint256 part, uint256 total)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return divRound(mul(amount, part), total);\r\n    }\r\n\r\n    //\r\n    // Open Zeppelin Math library below\r\n    //\r\n\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return a > b ? a : b;\r\n    }\r\n}\r\n\r\n/// @title internal token transfer function\r\n/// @dev see BasicSnapshotToken for implementation\r\ncontract MTokenTransfer {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param from The address holding the tokens being transferred\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @dev  reverts if transfer was not successful\r\n    function mTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal;\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is\r\n    MTokenTransfer,\r\n    MTokenTransferController,\r\n    IBasicToken,\r\n    Math\r\n{\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    mapping(address => uint256) internal _balances;\r\n\r\n    uint256 internal _totalSupply;\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /**\r\n    * @dev transfer token for a specified address\r\n    * @param to The address to transfer to.\r\n    * @param amount The amount to be transferred.\r\n    */\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool)\r\n    {\r\n        mTransfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _totalSupply;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address owner)\r\n        public\r\n        constant\r\n        returns (uint256 balance)\r\n    {\r\n        return _balances[owner];\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements MTokenTransfer\r\n    //\r\n\r\n    function mTransfer(address from, address to, uint256 amount)\r\n        internal\r\n    {\r\n        require(to != address(0));\r\n        require(mOnTransfer(from, to, amount));\r\n\r\n        _balances[from] = sub(_balances[from], amount);\r\n        _balances[to] = add(_balances[to], amount);\r\n        emit Transfer(from, to, amount);\r\n    }\r\n}\r\n\r\n/// @title token spending approval and transfer\r\n/// @dev implements token approval and transfers and exposes relevant part of ERC20 and ERC677 approveAndCall\r\n///     may be mixed in with any basic token (implementing mTransfer) like BasicSnapshotToken or MintableSnapshotToken to add approval mechanism\r\n///     observes MTokenAllowanceController interface\r\n///     observes MTokenTransfer\r\ncontract TokenAllowance is\r\n    MTokenTransfer,\r\n    MTokenAllowanceController,\r\n    IERC20Allowance,\r\n    IERC677Token\r\n{\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // `allowed` tracks rights to spends others tokens as per ERC20\r\n    // owner => spender => amount\r\n    mapping (address => mapping (address => uint256)) private _allowed;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor()\r\n        internal\r\n    {\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements IERC20Token\r\n    //\r\n\r\n    /// @dev This function makes it easy to read the `allowed[]` map\r\n    /// @param owner The address of the account that owns the token\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens of _owner that _spender is allowed\r\n    ///  to spend\r\n    function allowance(address owner, address spender)\r\n        public\r\n        constant\r\n        returns (uint256 remaining)\r\n    {\r\n        uint256 override = mAllowanceOverride(owner, spender);\r\n        if (override > 0) {\r\n            return override;\r\n        }\r\n        return _allowed[owner][spender];\r\n    }\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_amount` tokens on\r\n    ///  its behalf. This is a modified version of the ERC20 approve function\r\n    ///  where allowance per spender must be 0 to allow change of such allowance\r\n    /// @param spender The address of the account able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True or reverts, False is never returned\r\n    function approve(address spender, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Alerts the token controller of the approve function call\r\n        require(mOnApprove(msg.sender, spender, amount));\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender,0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        require((amount == 0 || _allowed[msg.sender][spender] == 0) && mAllowanceOverride(msg.sender, spender) == 0);\r\n\r\n        _allowed[msg.sender][spender] = amount;\r\n        emit Approval(msg.sender, spender, amount);\r\n        return true;\r\n    }\r\n\r\n    /// @notice Send `_amount` tokens to `_to` from `_from` on the condition it\r\n    ///  is approved by `_from`\r\n    /// @param from The address holding the tokens being transferred\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful, reverts in any other case\r\n    function transferFrom(address from, address to, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        uint256 allowed = mAllowanceOverride(from, msg.sender);\r\n        if (allowed == 0) {\r\n            // The standard ERC 20 transferFrom functionality\r\n            allowed = _allowed[from][msg.sender];\r\n            // yes this will underflow but then we'll revert. will cost gas however so don't underflow\r\n            _allowed[from][msg.sender] -= amount;\r\n        }\r\n        require(allowed >= amount);\r\n        mTransfer(from, to, amount);\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Implements IERC677Token\r\n    //\r\n\r\n    /// @notice `msg.sender` approves `_spender` to send `_amount` tokens on\r\n    ///  its behalf, and then a function is triggered in the contract that is\r\n    ///  being approved, `_spender`. This allows users to use their tokens to\r\n    ///  interact with contracts in one function call instead of two\r\n    /// @param spender The address of the contract able to transfer the tokens\r\n    /// @param amount The amount of tokens to be approved for transfer\r\n    /// @return True or reverts, False is never returned\r\n    function approveAndCall(\r\n        address spender,\r\n        uint256 amount,\r\n        bytes extraData\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        require(approve(spender, amount));\r\n\r\n        success = IERC677Callback(spender).receiveApproval(\r\n            msg.sender,\r\n            amount,\r\n            this,\r\n            extraData\r\n        );\r\n        require(success);\r\n\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements default MTokenAllowanceController\r\n    //\r\n\r\n    // no override in default implementation\r\n    function mAllowanceOverride(\r\n        address /*owner*/,\r\n        address /*spender*/\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return 0;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract StandardToken is\r\n    IERC20Token,\r\n    BasicToken,\r\n    TokenAllowance\r\n{\r\n\r\n}\r\n\r\n/// @title uniquely identifies deployable (non-abstract) platform contract\r\n/// @notice cheap way of assigning implementations to knownInterfaces which represent system services\r\n///         unfortunatelly ERC165 does not include full public interface (ABI) and does not provide way to list implemented interfaces\r\n///         EIP820 still in the making\r\n/// @dev ids are generated as follows keccak256(\"neufund-platform:<contract name>\")\r\n///      ids roughly correspond to ABIs\r\ncontract IContractId {\r\n    /// @param id defined as above\r\n    /// @param version implementation version\r\n    function contractId() public pure returns (bytes32 id, uint256 version);\r\n}\r\n\r\ncontract IWithdrawableToken {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice withdraws from a token holding assets\r\n    /// @dev amount of asset should be returned to msg.sender and corresponding balance burned\r\n    function withdraw(uint256 amount)\r\n        public;\r\n}\r\n\r\ncontract EtherToken is\r\n    IsContract,\r\n    IContractId,\r\n    AccessControlled,\r\n    StandardToken,\r\n    TrustlessTokenController,\r\n    IWithdrawableToken,\r\n    TokenMetadata,\r\n    IERC223Token,\r\n    Reclaimable\r\n{\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    string private constant NAME = \"Ether Token\";\r\n\r\n    string private constant SYMBOL = \"ETH-T\";\r\n\r\n    uint8 private constant DECIMALS = 18;\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogDeposit(\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogWithdrawal(\r\n        address indexed from,\r\n        uint256 amount\r\n    );\r\n\r\n    event LogWithdrawAndSend(\r\n        address indexed from,\r\n        address indexed to,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(IAccessPolicy accessPolicy)\r\n        AccessControlled(accessPolicy)\r\n        StandardToken()\r\n        TokenMetadata(NAME, DECIMALS, SYMBOL, \"\")\r\n        Reclaimable()\r\n        public\r\n    {\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// deposit msg.value of Ether to msg.sender balance\r\n    function deposit()\r\n        public\r\n        payable\r\n    {\r\n        depositPrivate();\r\n        emit Transfer(address(0), msg.sender, msg.value);\r\n    }\r\n\r\n    /// @notice convenience function to deposit and immediately transfer amount\r\n    /// @param transferTo where to transfer after deposit\r\n    /// @param amount total amount to transfer, must be <= balance after deposit\r\n    /// @param data erc223 data\r\n    /// @dev intended to deposit from simple account and invest in ETO\r\n    function depositAndTransfer(address transferTo, uint256 amount, bytes data)\r\n        public\r\n        payable\r\n    {\r\n        depositPrivate();\r\n        transfer(transferTo, amount, data);\r\n    }\r\n\r\n    /// withdraws and sends 'amount' of ether to msg.sender\r\n    function withdraw(uint256 amount)\r\n        public\r\n    {\r\n        withdrawPrivate(amount);\r\n        msg.sender.transfer(amount);\r\n    }\r\n\r\n    /// @notice convenience function to withdraw and transfer to external account\r\n    /// @param sendTo address to which send total amount\r\n    /// @param amount total amount to withdraw and send\r\n    /// @dev function is payable and is meant to withdraw funds on accounts balance and token in single transaction\r\n    /// @dev BEWARE that msg.sender of the funds is Ether Token contract and not simple account calling it.\r\n    /// @dev  when sent to smart conctract funds may be lost, so this is prevented below\r\n    function withdrawAndSend(address sendTo, uint256 amount)\r\n        public\r\n        payable\r\n    {\r\n        // must send at least what is in msg.value to being another deposit function\r\n        require(amount >= msg.value, \"NF_ET_NO_DEPOSIT\");\r\n        if (amount > msg.value) {\r\n            uint256 withdrawRemainder = amount - msg.value;\r\n            withdrawPrivate(withdrawRemainder);\r\n        }\r\n        emit LogWithdrawAndSend(msg.sender, sendTo, amount);\r\n        sendTo.transfer(amount);\r\n    }\r\n\r\n    //\r\n    // Implements IERC223Token\r\n    //\r\n\r\n    function transfer(address to, uint256 amount, bytes data)\r\n        public\r\n        returns (bool)\r\n    {\r\n        BasicToken.mTransfer(msg.sender, to, amount);\r\n\r\n        // Notify the receiving contract.\r\n        if (isContract(to)) {\r\n            // in case of re-entry (1) transfer is done (2) msg.sender is different\r\n            IERC223Callback(to).tokenFallback(msg.sender, amount, data);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Overrides Reclaimable\r\n    //\r\n\r\n    /// @notice allows EtherToken to reclaim tokens wrongly sent to its address\r\n    /// @dev as EtherToken by design has balance of Ether (native Ethereum token)\r\n    ///     such reclamation is not allowed\r\n    function reclaim(IBasicToken token)\r\n        public\r\n    {\r\n        // forbid reclaiming ETH hold in this contract.\r\n        require(token != RECLAIM_ETHER);\r\n        Reclaimable.reclaim(token);\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x75b86bc24f77738576716a36431588ae768d80d077231d1661c2bea674c6373a, 0);\r\n    }\r\n\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    function depositPrivate()\r\n        private\r\n    {\r\n        _balances[msg.sender] = add(_balances[msg.sender], msg.value);\r\n        _totalSupply = add(_totalSupply, msg.value);\r\n        emit LogDeposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdrawPrivate(uint256 amount)\r\n        private\r\n    {\r\n        require(_balances[msg.sender] >= amount);\r\n        _balances[msg.sender] = sub(_balances[msg.sender], amount);\r\n        _totalSupply = sub(_totalSupply, amount);\r\n        emit LogWithdrawal(msg.sender, amount);\r\n        emit Transfer(msg.sender, address(0), amount);\r\n    }\r\n}\r\n\r\ncontract EuroToken is\r\n    Agreement,\r\n    IERC677Token,\r\n    StandardToken,\r\n    IWithdrawableToken,\r\n    ITokenControllerHook,\r\n    TokenMetadata,\r\n    IERC223Token,\r\n    IsContract,\r\n    IContractId\r\n{\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    string private constant NAME = \"Euro Token\";\r\n\r\n    string private constant SYMBOL = \"EUR-T\";\r\n\r\n    uint8 private constant DECIMALS = 18;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    ITokenController private _tokenController;\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// on each deposit (increase of supply) of EUR-T\r\n    /// 'by' indicates account that executed the deposit function for 'to' (typically bank connector)\r\n    event LogDeposit(\r\n        address indexed to,\r\n        address by,\r\n        uint256 amount,\r\n        bytes32 reference\r\n    );\r\n\r\n    // proof of requested deposit initiated by token holder\r\n    event LogWithdrawal(\r\n        address indexed from,\r\n        uint256 amount\r\n    );\r\n\r\n    // proof of settled deposit\r\n    event LogWithdrawSettled(\r\n        address from,\r\n        address by, // who settled\r\n        uint256 amount, // settled amount, after fees, negative interest rates etc.\r\n        uint256 originalAmount, // original amount withdrawn\r\n        bytes32 withdrawTxHash, // hash of withdraw transaction\r\n        bytes32 reference // reference number of withdraw operation at deposit manager\r\n    );\r\n\r\n    /// on destroying the tokens without withdraw (see `destroyTokens` function below)\r\n    event LogDestroy(\r\n        address indexed from,\r\n        address by,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    modifier onlyIfDepositAllowed(address to, uint256 amount) {\r\n        require(_tokenController.onGenerateTokens(msg.sender, to, amount));\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfWithdrawAllowed(address from, uint256 amount) {\r\n        require(_tokenController.onDestroyTokens(msg.sender, from, amount));\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        IAccessPolicy accessPolicy,\r\n        IEthereumForkArbiter forkArbiter,\r\n        ITokenController tokenController\r\n    )\r\n        Agreement(accessPolicy, forkArbiter)\r\n        StandardToken()\r\n        TokenMetadata(NAME, DECIMALS, SYMBOL, \"\")\r\n        public\r\n    {\r\n        require(tokenController != ITokenController(0x0));\r\n        _tokenController = tokenController;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice deposit 'amount' of EUR-T to address 'to', attaching correlating `reference` to LogDeposit event\r\n    /// @dev deposit may happen only in case 'to' can receive transfer in token controller\r\n    ///     by default KYC is required to receive deposits\r\n    function deposit(address to, uint256 amount, bytes32 reference)\r\n        public\r\n        only(ROLE_EURT_DEPOSIT_MANAGER)\r\n        onlyIfDepositAllowed(to, amount)\r\n        acceptAgreement(to)\r\n    {\r\n        require(to != address(0));\r\n        _balances[to] = add(_balances[to], amount);\r\n        _totalSupply = add(_totalSupply, amount);\r\n        emit LogDeposit(to, msg.sender, amount, reference);\r\n        emit Transfer(address(0), to, amount);\r\n    }\r\n\r\n    /// @notice runs many deposits within one transaction\r\n    /// @dev deposit may happen only in case 'to' can receive transfer in token controller\r\n    ///     by default KYC is required to receive deposits\r\n    function depositMany(address[] to, uint256[] amount, bytes32[] reference)\r\n        public\r\n    {\r\n        require(to.length == amount.length);\r\n        require(to.length == reference.length);\r\n        for (uint256 i = 0; i < to.length; i++) {\r\n            deposit(to[i], amount[i], reference[i]);\r\n        }\r\n    }\r\n\r\n    /// @notice withdraws 'amount' of EUR-T by burning required amount and providing a proof of whithdrawal\r\n    /// @dev proof is provided in form of log entry. based on that proof deposit manager will make a bank transfer\r\n    ///     by default controller will check the following: KYC and existence of working bank account\r\n    function withdraw(uint256 amount)\r\n        public\r\n        onlyIfWithdrawAllowed(msg.sender, amount)\r\n        acceptAgreement(msg.sender)\r\n    {\r\n        destroyTokensPrivate(msg.sender, amount);\r\n        emit LogWithdrawal(msg.sender, amount);\r\n    }\r\n\r\n    /// @notice issued by deposit manager when withdraw request was settled. typicaly amount that could be settled will be lower\r\n    ///         than amount withdrawn: banks charge negative interest rates and various fees that must be deduced\r\n    ///         reference number is attached that may be used to identify withdraw operation at deposit manager\r\n    function settleWithdraw(address from, uint256 amount, uint256 originalAmount, bytes32 withdrawTxHash, bytes32 reference)\r\n        public\r\n        only(ROLE_EURT_DEPOSIT_MANAGER)\r\n    {\r\n        emit LogWithdrawSettled(from, msg.sender, amount, originalAmount, withdrawTxHash, reference);\r\n    }\r\n\r\n    /// @notice this method allows to destroy EUR-T belonging to any account\r\n    ///     note that EURO is fiat currency and is not trustless, EUR-T is also\r\n    ///     just internal currency of Neufund platform, not general purpose stable coin\r\n    ///     we need to be able to destroy EUR-T if ordered by authorities\r\n    function destroy(address owner, uint256 amount)\r\n        public\r\n        only(ROLE_EURT_LEGAL_MANAGER)\r\n    {\r\n        destroyTokensPrivate(owner, amount);\r\n        emit LogDestroy(owner, msg.sender, amount);\r\n    }\r\n\r\n    //\r\n    // Implements ITokenControllerHook\r\n    //\r\n\r\n    function changeTokenController(address newController)\r\n        public\r\n    {\r\n        require(_tokenController.onChangeTokenController(msg.sender, newController));\r\n        _tokenController = ITokenController(newController);\r\n        emit LogChangeTokenController(_tokenController, newController, msg.sender);\r\n    }\r\n\r\n    function tokenController()\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return _tokenController;\r\n    }\r\n\r\n    //\r\n    // Implements IERC223Token\r\n    //\r\n    function transfer(address to, uint256 amount, bytes data)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        return ierc223TransferInternal(msg.sender, to, amount, data);\r\n    }\r\n\r\n    /// @notice convenience function to deposit and immediately transfer amount\r\n    /// @param depositTo which account to deposit to and then transfer from\r\n    /// @param transferTo where to transfer after deposit\r\n    /// @param depositAmount amount to deposit\r\n    /// @param transferAmount total amount to transfer, must be <= balance after deposit\r\n    /// @dev intended to deposit from bank account and invest in ETO\r\n    function depositAndTransfer(\r\n        address depositTo,\r\n        address transferTo,\r\n        uint256 depositAmount,\r\n        uint256 transferAmount,\r\n        bytes data,\r\n        bytes32 reference\r\n    )\r\n        public\r\n        returns (bool success)\r\n    {\r\n        deposit(depositTo, depositAmount, reference);\r\n        return ierc223TransferInternal(depositTo, transferTo, transferAmount, data);\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0xfb5c7e43558c4f3f5a2d87885881c9b10ff4be37e3308579c178bf4eaa2c29cd, 0);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements MTokenController\r\n    //\r\n\r\n    function mOnTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        acceptAgreement(from)\r\n        returns (bool allow)\r\n    {\r\n        address broker = msg.sender;\r\n        if (broker != from) {\r\n            // if called by the depositor (deposit and send), ignore the broker flag\r\n            bool isDepositor = accessPolicy().allowed(msg.sender, ROLE_EURT_DEPOSIT_MANAGER, this, msg.sig);\r\n            // this is not very clean but alternative (give brokerage rights to all depositors) is maintenance hell\r\n            if (isDepositor) {\r\n                broker = from;\r\n            }\r\n        }\r\n        return _tokenController.onTransfer(broker, from, to, amount);\r\n    }\r\n\r\n    function mOnApprove(\r\n        address owner,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n        acceptAgreement(owner)\r\n        returns (bool allow)\r\n    {\r\n        return _tokenController.onApprove(owner, spender, amount);\r\n    }\r\n\r\n    function mAllowanceOverride(\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _tokenController.onAllowance(owner, spender);\r\n    }\r\n\r\n    //\r\n    // Observes MAgreement internal interface\r\n    //\r\n\r\n    /// @notice euro token is legally represented by separate entity ROLE_EURT_LEGAL_MANAGER\r\n    function mCanAmend(address legalRepresentative)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return accessPolicy().allowed(legalRepresentative, ROLE_EURT_LEGAL_MANAGER, this, msg.sig);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    function destroyTokensPrivate(address owner, uint256 amount)\r\n        private\r\n    {\r\n        require(_balances[owner] >= amount);\r\n        _balances[owner] = sub(_balances[owner], amount);\r\n        _totalSupply = sub(_totalSupply, amount);\r\n        emit Transfer(owner, address(0), amount);\r\n    }\r\n\r\n    /// @notice internal transfer function that checks permissions and calls the tokenFallback\r\n    function ierc223TransferInternal(address from, address to, uint256 amount, bytes data)\r\n        private\r\n        returns (bool success)\r\n    {\r\n        BasicToken.mTransfer(from, to, amount);\r\n\r\n        // Notify the receiving contract.\r\n        if (isContract(to)) {\r\n            // in case of re-entry (1) transfer is done (2) msg.sender is different\r\n            IERC223Callback(to).tokenFallback(from, amount, data);\r\n        }\r\n        return true;\r\n    }\r\n}\r\n\r\n/// @title serialization of basic types from/to bytes\r\ncontract Serialization {\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n    function decodeAddress(bytes b)\r\n        internal\r\n        pure\r\n        returns (address a)\r\n    {\r\n        require(b.length == 20);\r\n        assembly {\r\n            // load memory area that is address \"carved out\" of 64 byte bytes. prefix is zeroed\r\n            a := and(mload(add(b, 20)), 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n        }\r\n    }\r\n}\r\n\r\ncontract NeumarkIssuanceCurve {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // maximum number of neumarks that may be created\r\n    uint256 private constant NEUMARK_CAP = 1500000000000000000000000000;\r\n\r\n    // initial neumark reward fraction (controls curve steepness)\r\n    uint256 private constant INITIAL_REWARD_FRACTION = 6500000000000000000;\r\n\r\n    // stop issuing new Neumarks above this Euro value (as it goes quickly to zero)\r\n    uint256 private constant ISSUANCE_LIMIT_EUR_ULPS = 8300000000000000000000000000;\r\n\r\n    // approximate curve linearly above this Euro value\r\n    uint256 private constant LINEAR_APPROX_LIMIT_EUR_ULPS = 2100000000000000000000000000;\r\n    uint256 private constant NEUMARKS_AT_LINEAR_LIMIT_ULPS = 1499832501287264827896539871;\r\n\r\n    uint256 private constant TOT_LINEAR_NEUMARKS_ULPS = NEUMARK_CAP - NEUMARKS_AT_LINEAR_LIMIT_ULPS;\r\n    uint256 private constant TOT_LINEAR_EUR_ULPS = ISSUANCE_LIMIT_EUR_ULPS - LINEAR_APPROX_LIMIT_EUR_ULPS;\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice returns additional amount of neumarks issued for euroUlps at totalEuroUlps\r\n    /// @param totalEuroUlps actual curve position from which neumarks will be issued\r\n    /// @param euroUlps amount against which neumarks will be issued\r\n    function incremental(uint256 totalEuroUlps, uint256 euroUlps)\r\n        public\r\n        pure\r\n        returns (uint256 neumarkUlps)\r\n    {\r\n        require(totalEuroUlps + euroUlps >= totalEuroUlps);\r\n        uint256 from = cumulative(totalEuroUlps);\r\n        uint256 to = cumulative(totalEuroUlps + euroUlps);\r\n        // as expansion is not monotonic for large totalEuroUlps, assert below may fail\r\n        // example: totalEuroUlps=1.999999999999999999999000000e+27 and euroUlps=50\r\n        assert(to >= from);\r\n        return to - from;\r\n    }\r\n\r\n    /// @notice returns amount of euro corresponding to burned neumarks\r\n    /// @param totalEuroUlps actual curve position from which neumarks will be burned\r\n    /// @param burnNeumarkUlps amount of neumarks to burn\r\n    function incrementalInverse(uint256 totalEuroUlps, uint256 burnNeumarkUlps)\r\n        public\r\n        pure\r\n        returns (uint256 euroUlps)\r\n    {\r\n        uint256 totalNeumarkUlps = cumulative(totalEuroUlps);\r\n        require(totalNeumarkUlps >= burnNeumarkUlps);\r\n        uint256 fromNmk = totalNeumarkUlps - burnNeumarkUlps;\r\n        uint newTotalEuroUlps = cumulativeInverse(fromNmk, 0, totalEuroUlps);\r\n        // yes, this may overflow due to non monotonic inverse function\r\n        assert(totalEuroUlps >= newTotalEuroUlps);\r\n        return totalEuroUlps - newTotalEuroUlps;\r\n    }\r\n\r\n    /// @notice returns amount of euro corresponding to burned neumarks\r\n    /// @param totalEuroUlps actual curve position from which neumarks will be burned\r\n    /// @param burnNeumarkUlps amount of neumarks to burn\r\n    /// @param minEurUlps euro amount to start inverse search from, inclusive\r\n    /// @param maxEurUlps euro amount to end inverse search to, inclusive\r\n    function incrementalInverse(uint256 totalEuroUlps, uint256 burnNeumarkUlps, uint256 minEurUlps, uint256 maxEurUlps)\r\n        public\r\n        pure\r\n        returns (uint256 euroUlps)\r\n    {\r\n        uint256 totalNeumarkUlps = cumulative(totalEuroUlps);\r\n        require(totalNeumarkUlps >= burnNeumarkUlps);\r\n        uint256 fromNmk = totalNeumarkUlps - burnNeumarkUlps;\r\n        uint newTotalEuroUlps = cumulativeInverse(fromNmk, minEurUlps, maxEurUlps);\r\n        // yes, this may overflow due to non monotonic inverse function\r\n        assert(totalEuroUlps >= newTotalEuroUlps);\r\n        return totalEuroUlps - newTotalEuroUlps;\r\n    }\r\n\r\n    /// @notice finds total amount of neumarks issued for given amount of Euro\r\n    /// @dev binomial expansion does not guarantee monotonicity on uint256 precision for large euroUlps\r\n    ///     function below is not monotonic\r\n    function cumulative(uint256 euroUlps)\r\n        public\r\n        pure\r\n        returns(uint256 neumarkUlps)\r\n    {\r\n        // Return the cap if euroUlps is above the limit.\r\n        if (euroUlps >= ISSUANCE_LIMIT_EUR_ULPS) {\r\n            return NEUMARK_CAP;\r\n        }\r\n        // use linear approximation above limit below\r\n        // binomial expansion does not guarantee monotonicity on uint256 precision for large euroUlps\r\n        if (euroUlps >= LINEAR_APPROX_LIMIT_EUR_ULPS) {\r\n            // (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS) is small so expression does not overflow\r\n            return NEUMARKS_AT_LINEAR_LIMIT_ULPS + (TOT_LINEAR_NEUMARKS_ULPS * (euroUlps - LINEAR_APPROX_LIMIT_EUR_ULPS)) / TOT_LINEAR_EUR_ULPS;\r\n        }\r\n\r\n        // Approximate cap-cap(1-1/D)^n using the Binomial expansion\r\n        // http://galileo.phys.virginia.edu/classes/152.mf1i.spring02/Exponential_Function.htm\r\n        // Function[imax, -CAP*Sum[(-IR*EUR/CAP)^i/Factorial[i], {i, imax}]]\r\n        // which may be simplified to\r\n        // Function[imax, -CAP*Sum[(EUR)^i/(Factorial[i]*(-d)^i), {i, 1, imax}]]\r\n        // where d = cap/initial_reward\r\n        uint256 d = 230769230769230769230769231; // NEUMARK_CAP / INITIAL_REWARD_FRACTION\r\n        uint256 term = NEUMARK_CAP;\r\n        uint256 sum = 0;\r\n        uint256 denom = d;\r\n        do assembly {\r\n            // We use assembler primarily to avoid the expensive\r\n            // divide-by-zero check solc inserts for the / operator.\r\n            term  := div(mul(term, euroUlps), denom)\r\n            sum   := add(sum, term)\r\n            denom := add(denom, d)\r\n            // sub next term as we have power of negative value in the binomial expansion\r\n            term  := div(mul(term, euroUlps), denom)\r\n            sum   := sub(sum, term)\r\n            denom := add(denom, d)\r\n        } while (term != 0);\r\n        return sum;\r\n    }\r\n\r\n    /// @notice find issuance curve inverse by binary search\r\n    /// @param neumarkUlps neumark amount to compute inverse for\r\n    /// @param minEurUlps minimum search range for the inverse, inclusive\r\n    /// @param maxEurUlps maxium search range for the inverse, inclusive\r\n    /// @dev in case of approximate search (no exact inverse) upper element of minimal search range is returned\r\n    /// @dev in case of many possible inverses, the lowest one will be used (if range permits)\r\n    /// @dev corresponds to a linear search that returns first euroUlp value that has cumulative() equal or greater than neumarkUlps\r\n    function cumulativeInverse(uint256 neumarkUlps, uint256 minEurUlps, uint256 maxEurUlps)\r\n        public\r\n        pure\r\n        returns (uint256 euroUlps)\r\n    {\r\n        require(maxEurUlps >= minEurUlps);\r\n        require(cumulative(minEurUlps) <= neumarkUlps);\r\n        require(cumulative(maxEurUlps) >= neumarkUlps);\r\n        uint256 min = minEurUlps;\r\n        uint256 max = maxEurUlps;\r\n\r\n        // Binary search\r\n        while (max > min) {\r\n            uint256 mid = (max + min) / 2;\r\n            uint256 val = cumulative(mid);\r\n            // exact solution should not be used, a late points of the curve when many euroUlps are needed to\r\n            // increase by one nmkUlp this will lead to  \"indeterministic\" inverse values that depend on the initial min and max\r\n            // and further binary division -> you can land at any of the euro value that is mapped to the same nmk value\r\n            // with condition below removed, binary search will point to the lowest eur value possible which is good because it cannot be exploited even with 0 gas costs\r\n            /* if (val == neumarkUlps) {\r\n                return mid;\r\n            }*/\r\n            // NOTE: approximate search (no inverse) must return upper element of the final range\r\n            //  last step of approximate search is always (min, min+1) so new mid is (2*min+1)/2 => min\r\n            //  so new min = mid + 1 = max which was upper range. and that ends the search\r\n            // NOTE: when there are multiple inverses for the same neumarkUlps, the `max` will be dragged down\r\n            //  by `max = mid` expression to the lowest eur value of inverse. works only for ranges that cover all points of multiple inverse\r\n            if (val < neumarkUlps) {\r\n                min = mid + 1;\r\n            } else {\r\n                max = mid;\r\n            }\r\n        }\r\n        // NOTE: It is possible that there is no inverse\r\n        //  for example curve(0) = 0 and curve(1) = 6, so\r\n        //  there is no value y such that curve(y) = 5.\r\n        //  When there is no inverse, we must return upper element of last search range.\r\n        //  This has the effect of reversing the curve less when\r\n        //  burning Neumarks. This ensures that Neumarks can always\r\n        //  be burned. It also ensure that the total supply of Neumarks\r\n        //  remains below the cap.\r\n        return max;\r\n    }\r\n\r\n    function neumarkCap()\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return NEUMARK_CAP;\r\n    }\r\n\r\n    function initialRewardFraction()\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return INITIAL_REWARD_FRACTION;\r\n    }\r\n}\r\n\r\n/// @title advances snapshot id on demand\r\n/// @dev see Snapshot folder for implementation examples ie. DailyAndSnapshotable contract\r\ncontract ISnapshotable {\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// @dev should log each new snapshot id created, including snapshots created automatically via MSnapshotPolicy\r\n    event LogSnapshotCreated(uint256 snapshotId);\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// always creates new snapshot id which gets returned\r\n    /// however, there is no guarantee that any snapshot will be created with this id, this depends on the implementation of MSnaphotPolicy\r\n    function createSnapshot()\r\n        public\r\n        returns (uint256);\r\n\r\n    /// upper bound of series snapshotIds for which there's a value\r\n    function currentSnapshotId()\r\n        public\r\n        constant\r\n        returns (uint256);\r\n}\r\n\r\n/// @title Abstracts snapshot id creation logics\r\n/// @dev Mixin (internal interface) of the snapshot policy which abstracts snapshot id creation logics from Snapshot contract\r\n/// @dev to be implemented and such implementation should be mixed with Snapshot-derived contract, see EveryBlock for simplest example of implementation and StandardSnapshotToken\r\ncontract MSnapshotPolicy {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    // The snapshot Ids need to be strictly increasing.\r\n    // Whenever the snaspshot id changes, a new snapshot will be created.\r\n    // As long as the same snapshot id is being returned, last snapshot will be updated as this indicates that snapshot id didn't change\r\n    //\r\n    // Values passed to `hasValueAt` and `valuteAt` are required\r\n    // to be less or equal to `mCurrentSnapshotId()`.\r\n    function mAdvanceSnapshotId()\r\n        internal\r\n        returns (uint256);\r\n\r\n    // this is a version of mAdvanceSnapshotId that does not modify state but MUST return the same value\r\n    // it is required to implement ITokenSnapshots interface cleanly\r\n    function mCurrentSnapshotId()\r\n        internal\r\n        constant\r\n        returns (uint256);\r\n\r\n}\r\n\r\n/// @title creates new snapshot id on each day boundary\r\n/// @dev snapshot id is unix timestamp of current day boundary\r\ncontract Daily is MSnapshotPolicy {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // Floor[2**128 / 1 days]\r\n    uint256 private MAX_TIMESTAMP = 3938453320844195178974243141571391;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @param start snapshotId from which to start generating values, used to prevent cloning from incompatible schemes\r\n    /// @dev start must be for the same day or 0, required for token cloning\r\n    constructor(uint256 start) internal {\r\n        // 0 is invalid value as we are past unix epoch\r\n        if (start > 0) {\r\n            uint256 base = dayBase(uint128(block.timestamp));\r\n            // must be within current day base\r\n            require(start >= base);\r\n            // dayBase + 2**128 will not overflow as it is based on block.timestamp\r\n            require(start < base + 2**128);\r\n        }\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function snapshotAt(uint256 timestamp)\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        require(timestamp < MAX_TIMESTAMP);\r\n\r\n        return dayBase(uint128(timestamp));\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements MSnapshotPolicy\r\n    //\r\n\r\n    function mAdvanceSnapshotId()\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        return mCurrentSnapshotId();\r\n    }\r\n\r\n    function mCurrentSnapshotId()\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        // disregard overflows on block.timestamp, see MAX_TIMESTAMP\r\n        return dayBase(uint128(block.timestamp));\r\n    }\r\n\r\n    function dayBase(uint128 timestamp)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // Round down to the start of the day (00:00 UTC) and place in higher 128bits\r\n        return 2**128 * (uint256(timestamp) / 1 days);\r\n    }\r\n}\r\n\r\n/// @title creates snapshot id on each day boundary and allows to create additional snapshots within a given day\r\n/// @dev snapshots are encoded in single uint256, where high 128 bits represents a day number (from unix epoch) and low 128 bits represents additional snapshots within given day create via ISnapshotable\r\ncontract DailyAndSnapshotable is\r\n    Daily,\r\n    ISnapshotable\r\n{\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    uint256 private _currentSnapshotId;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @param start snapshotId from which to start generating values\r\n    /// @dev start must be for the same day or 0, required for token cloning\r\n    constructor(uint256 start)\r\n        internal\r\n        Daily(start)\r\n    {\r\n        if (start > 0) {\r\n            _currentSnapshotId = start;\r\n        }\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements ISnapshotable\r\n    //\r\n\r\n    function createSnapshot()\r\n        public\r\n        returns (uint256)\r\n    {\r\n        uint256 base = dayBase(uint128(block.timestamp));\r\n\r\n        if (base > _currentSnapshotId) {\r\n            // New day has started, create snapshot for midnight\r\n            _currentSnapshotId = base;\r\n        } else {\r\n            // within single day, increase counter (assume 2**128 will not be crossed)\r\n            _currentSnapshotId += 1;\r\n        }\r\n\r\n        // Log and return\r\n        emit LogSnapshotCreated(_currentSnapshotId);\r\n        return _currentSnapshotId;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements MSnapshotPolicy\r\n    //\r\n\r\n    function mAdvanceSnapshotId()\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        uint256 base = dayBase(uint128(block.timestamp));\r\n\r\n        // New day has started\r\n        if (base > _currentSnapshotId) {\r\n            _currentSnapshotId = base;\r\n            emit LogSnapshotCreated(base);\r\n        }\r\n\r\n        return _currentSnapshotId;\r\n    }\r\n\r\n    function mCurrentSnapshotId()\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        uint256 base = dayBase(uint128(block.timestamp));\r\n\r\n        return base > _currentSnapshotId ? base : _currentSnapshotId;\r\n    }\r\n}\r\n\r\n/// @title Reads and writes snapshots\r\n/// @dev Manages reading and writing a series of values, where each value has assigned a snapshot id for access to historical data\r\n/// @dev may be added to any contract to provide snapshotting mechanism. should be mixed in with any of MSnapshotPolicy implementations to customize snapshot creation mechanics\r\n///     observes MSnapshotPolicy\r\n/// based on MiniMe token\r\ncontract Snapshot is MSnapshotPolicy {\r\n\r\n    ////////////////////////\r\n    // Types\r\n    ////////////////////////\r\n\r\n    /// @dev `Values` is the structure that attaches a snapshot id to a\r\n    ///  given value, the snapshot id attached is the one that last changed the\r\n    ///  value\r\n    struct Values {\r\n\r\n        // `snapshotId` is the snapshot id that the value was generated at\r\n        uint256 snapshotId;\r\n\r\n        // `value` at a specific snapshot id\r\n        uint256 value;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function hasValue(\r\n        Values[] storage values\r\n    )\r\n        internal\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return values.length > 0;\r\n    }\r\n\r\n    /// @dev makes sure that 'snapshotId' between current snapshot id (mCurrentSnapshotId) and first snapshot id. this guarantees that getValueAt returns value from one of the snapshots.\r\n    function hasValueAt(\r\n        Values[] storage values,\r\n        uint256 snapshotId\r\n    )\r\n        internal\r\n        constant\r\n        returns (bool)\r\n    {\r\n        require(snapshotId <= mCurrentSnapshotId());\r\n        return values.length > 0 && values[0].snapshotId <= snapshotId;\r\n    }\r\n\r\n    /// gets last value in the series\r\n    function getValue(\r\n        Values[] storage values,\r\n        uint256 defaultValue\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        if (values.length == 0) {\r\n            return defaultValue;\r\n        } else {\r\n            uint256 last = values.length - 1;\r\n            return values[last].value;\r\n        }\r\n    }\r\n\r\n    /// @dev `getValueAt` retrieves value at a given snapshot id\r\n    /// @param values The series of values being queried\r\n    /// @param snapshotId Snapshot id to retrieve the value at\r\n    /// @return Value in series being queried\r\n    function getValueAt(\r\n        Values[] storage values,\r\n        uint256 snapshotId,\r\n        uint256 defaultValue\r\n    )\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        require(snapshotId <= mCurrentSnapshotId());\r\n\r\n        // Empty value\r\n        if (values.length == 0) {\r\n            return defaultValue;\r\n        }\r\n\r\n        // Shortcut for the out of bounds snapshots\r\n        uint256 last = values.length - 1;\r\n        uint256 lastSnapshot = values[last].snapshotId;\r\n        if (snapshotId >= lastSnapshot) {\r\n            return values[last].value;\r\n        }\r\n        uint256 firstSnapshot = values[0].snapshotId;\r\n        if (snapshotId < firstSnapshot) {\r\n            return defaultValue;\r\n        }\r\n        // Binary search of the value in the array\r\n        uint256 min = 0;\r\n        uint256 max = last;\r\n        while (max > min) {\r\n            uint256 mid = (max + min + 1) / 2;\r\n            // must always return lower indice for approximate searches\r\n            if (values[mid].snapshotId <= snapshotId) {\r\n                min = mid;\r\n            } else {\r\n                max = mid - 1;\r\n            }\r\n        }\r\n        return values[min].value;\r\n    }\r\n\r\n    /// @dev `setValue` used to update sequence at next snapshot\r\n    /// @param values The sequence being updated\r\n    /// @param value The new last value of sequence\r\n    function setValue(\r\n        Values[] storage values,\r\n        uint256 value\r\n    )\r\n        internal\r\n    {\r\n        // TODO: simplify or break into smaller functions\r\n\r\n        uint256 currentSnapshotId = mAdvanceSnapshotId();\r\n        // Always create a new entry if there currently is no value\r\n        bool empty = values.length == 0;\r\n        if (empty) {\r\n            // Create a new entry\r\n            values.push(\r\n                Values({\r\n                    snapshotId: currentSnapshotId,\r\n                    value: value\r\n                })\r\n            );\r\n            return;\r\n        }\r\n\r\n        uint256 last = values.length - 1;\r\n        bool hasNewSnapshot = values[last].snapshotId < currentSnapshotId;\r\n        if (hasNewSnapshot) {\r\n\r\n            // Do nothing if the value was not modified\r\n            bool unmodified = values[last].value == value;\r\n            if (unmodified) {\r\n                return;\r\n            }\r\n\r\n            // Create new entry\r\n            values.push(\r\n                Values({\r\n                    snapshotId: currentSnapshotId,\r\n                    value: value\r\n                })\r\n            );\r\n        } else {\r\n\r\n            // We are updating the currentSnapshotId\r\n            bool previousUnmodified = last > 0 && values[last - 1].value == value;\r\n            if (previousUnmodified) {\r\n                // Remove current snapshot if current value was set to previous value\r\n                delete values[last];\r\n                values.length--;\r\n                return;\r\n            }\r\n\r\n            // Overwrite next snapshot entry\r\n            values[last].value = value;\r\n        }\r\n    }\r\n}\r\n\r\n/// @title token with snapshots and transfer functionality\r\n/// @dev observes MTokenTransferController interface\r\n///     observes ISnapshotToken interface\r\n///     implementes MTokenTransfer interface\r\ncontract BasicSnapshotToken is\r\n    MTokenTransfer,\r\n    MTokenTransferController,\r\n    IClonedTokenParent,\r\n    IBasicToken,\r\n    Snapshot\r\n{\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // `PARENT_TOKEN` is the Token address that was cloned to produce this token;\r\n    //  it will be 0x0 for a token that was not cloned\r\n    IClonedTokenParent private PARENT_TOKEN;\r\n\r\n    // `PARENT_SNAPSHOT_ID` is the snapshot id from the Parent Token that was\r\n    //  used to determine the initial distribution of the cloned token\r\n    uint256 private PARENT_SNAPSHOT_ID;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // `balances` is the map that tracks the balance of each address, in this\r\n    //  contract when the balance changes the snapshot id that the change\r\n    //  occurred is also included in the map\r\n    mapping (address => Values[]) internal _balances;\r\n\r\n    // Tracks the history of the `totalSupply` of the token\r\n    Values[] internal _totalSupplyValues;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @notice Constructor to create snapshot token\r\n    /// @param parentToken Address of the parent token, set to 0x0 if it is a\r\n    ///  new token\r\n    /// @param parentSnapshotId at which snapshot id clone was created, set to 0 to clone at upper bound\r\n    /// @dev please not that as long as cloned token does not overwrite value at current snapshot id, it will refer\r\n    ///     to parent token at which this snapshot still may change until snapshot id increases. for that time tokens are coupled\r\n    ///     this is prevented by parentSnapshotId value of parentToken.currentSnapshotId() - 1 being the maxiumum\r\n    ///     see SnapshotToken.js test to learn consequences coupling has.\r\n    constructor(\r\n        IClonedTokenParent parentToken,\r\n        uint256 parentSnapshotId\r\n    )\r\n        Snapshot()\r\n        internal\r\n    {\r\n        PARENT_TOKEN = parentToken;\r\n        if (parentToken == address(0)) {\r\n            require(parentSnapshotId == 0);\r\n        } else {\r\n            if (parentSnapshotId == 0) {\r\n                require(parentToken.currentSnapshotId() > 0);\r\n                PARENT_SNAPSHOT_ID = parentToken.currentSnapshotId() - 1;\r\n            } else {\r\n                PARENT_SNAPSHOT_ID = parentSnapshotId;\r\n            }\r\n        }\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements IBasicToken\r\n    //\r\n\r\n    /// @dev This function makes it easy to get the total number of tokens\r\n    /// @return The total number of tokens\r\n    function totalSupply()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return totalSupplyAtInternal(mCurrentSnapshotId());\r\n    }\r\n\r\n    /// @param owner The address that's balance is being requested\r\n    /// @return The balance of `owner` at the current block\r\n    function balanceOf(address owner)\r\n        public\r\n        constant\r\n        returns (uint256 balance)\r\n    {\r\n        return balanceOfAtInternal(owner, mCurrentSnapshotId());\r\n    }\r\n\r\n    /// @notice Send `amount` tokens to `to` from `msg.sender`\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful, reverts in any other case\r\n    function transfer(address to, uint256 amount)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        mTransfer(msg.sender, to, amount);\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Implements ITokenSnapshots\r\n    //\r\n\r\n    function totalSupplyAt(uint256 snapshotId)\r\n        public\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        return totalSupplyAtInternal(snapshotId);\r\n    }\r\n\r\n    function balanceOfAt(address owner, uint256 snapshotId)\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return balanceOfAtInternal(owner, snapshotId);\r\n    }\r\n\r\n    function currentSnapshotId()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return mCurrentSnapshotId();\r\n    }\r\n\r\n    //\r\n    // Implements IClonedTokenParent\r\n    //\r\n\r\n    function parentToken()\r\n        public\r\n        constant\r\n        returns(IClonedTokenParent parent)\r\n    {\r\n        return PARENT_TOKEN;\r\n    }\r\n\r\n    /// @return snapshot at wchich initial token distribution was taken\r\n    function parentSnapshotId()\r\n        public\r\n        constant\r\n        returns(uint256 snapshotId)\r\n    {\r\n        return PARENT_SNAPSHOT_ID;\r\n    }\r\n\r\n    //\r\n    // Other public functions\r\n    //\r\n\r\n    /// @notice gets all token balances of 'owner'\r\n    /// @dev intended to be called via eth_call where gas limit is not an issue\r\n    function allBalancesOf(address owner)\r\n        external\r\n        constant\r\n        returns (uint256[2][])\r\n    {\r\n        /* very nice and working implementation below,\r\n        // copy to memory\r\n        Values[] memory values = _balances[owner];\r\n        do assembly {\r\n            // in memory structs have simple layout where every item occupies uint256\r\n            balances := values\r\n        } while (false);*/\r\n\r\n        Values[] storage values = _balances[owner];\r\n        uint256[2][] memory balances = new uint256[2][](values.length);\r\n        for(uint256 ii = 0; ii < values.length; ++ii) {\r\n            balances[ii] = [values[ii].snapshotId, values[ii].value];\r\n        }\r\n\r\n        return balances;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function totalSupplyAtInternal(uint256 snapshotId)\r\n        internal\r\n        constant\r\n        returns(uint256)\r\n    {\r\n        Values[] storage values = _totalSupplyValues;\r\n\r\n        // If there is a value, return it, reverts if value is in the future\r\n        if (hasValueAt(values, snapshotId)) {\r\n            return getValueAt(values, snapshotId, 0);\r\n        }\r\n\r\n        // Try parent contract at or before the fork\r\n        if (address(PARENT_TOKEN) != 0) {\r\n            uint256 earlierSnapshotId = PARENT_SNAPSHOT_ID > snapshotId ? snapshotId : PARENT_SNAPSHOT_ID;\r\n            return PARENT_TOKEN.totalSupplyAt(earlierSnapshotId);\r\n        }\r\n\r\n        // Default to an empty balance\r\n        return 0;\r\n    }\r\n\r\n    // get balance at snapshot if with continuation in parent token\r\n    function balanceOfAtInternal(address owner, uint256 snapshotId)\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        Values[] storage values = _balances[owner];\r\n\r\n        // If there is a value, return it, reverts if value is in the future\r\n        if (hasValueAt(values, snapshotId)) {\r\n            return getValueAt(values, snapshotId, 0);\r\n        }\r\n\r\n        // Try parent contract at or before the fork\r\n        if (PARENT_TOKEN != address(0)) {\r\n            uint256 earlierSnapshotId = PARENT_SNAPSHOT_ID > snapshotId ? snapshotId : PARENT_SNAPSHOT_ID;\r\n            return PARENT_TOKEN.balanceOfAt(owner, earlierSnapshotId);\r\n        }\r\n\r\n        // Default to an empty balance\r\n        return 0;\r\n    }\r\n\r\n    //\r\n    // Implements MTokenTransfer\r\n    //\r\n\r\n    /// @dev This is the actual transfer function in the token contract, it can\r\n    ///  only be called by other functions in this contract.\r\n    /// @param from The address holding the tokens being transferred\r\n    /// @param to The address of the recipient\r\n    /// @param amount The amount of tokens to be transferred\r\n    /// @return True if the transfer was successful, reverts in any other case\r\n    function mTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        // never send to address 0\r\n        require(to != address(0));\r\n        // block transfers in clone that points to future/current snapshots of parent token\r\n        require(parentToken() == address(0) || parentSnapshotId() < parentToken().currentSnapshotId());\r\n        // Alerts the token controller of the transfer\r\n        require(mOnTransfer(from, to, amount));\r\n\r\n        // If the amount being transfered is more than the balance of the\r\n        //  account the transfer reverts\r\n        uint256 previousBalanceFrom = balanceOf(from);\r\n        require(previousBalanceFrom >= amount);\r\n\r\n        // First update the balance array with the new value for the address\r\n        //  sending the tokens\r\n        uint256 newBalanceFrom = previousBalanceFrom - amount;\r\n        setValue(_balances[from], newBalanceFrom);\r\n\r\n        // Then update the balance array with the new value for the address\r\n        //  receiving the tokens\r\n        uint256 previousBalanceTo = balanceOf(to);\r\n        uint256 newBalanceTo = previousBalanceTo + amount;\r\n        assert(newBalanceTo >= previousBalanceTo); // Check for overflow\r\n        setValue(_balances[to], newBalanceTo);\r\n\r\n        // An event to make the transfer easy to find on the blockchain\r\n        emit Transfer(from, to, amount);\r\n    }\r\n}\r\n\r\n/// @title token generation and destruction\r\n/// @dev internal interface providing token generation and destruction, see MintableSnapshotToken for implementation\r\ncontract MTokenMint {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    /// @notice Generates `amount` tokens that are assigned to `owner`\r\n    /// @param owner The address that will be assigned the new tokens\r\n    /// @param amount The quantity of tokens generated\r\n    /// @dev reverts if tokens could not be generated\r\n    function mGenerateTokens(address owner, uint256 amount)\r\n        internal;\r\n\r\n    /// @notice Burns `amount` tokens from `owner`\r\n    /// @param owner The address that will lose the tokens\r\n    /// @param amount The quantity of tokens to burn\r\n    /// @dev reverts if tokens could not be destroyed\r\n    function mDestroyTokens(address owner, uint256 amount)\r\n        internal;\r\n}\r\n\r\n/// @title basic snapshot token with facitilites to generate and destroy tokens\r\n/// @dev implementes MTokenMint, does not expose any public functions that create/destroy tokens\r\ncontract MintableSnapshotToken is\r\n    BasicSnapshotToken,\r\n    MTokenMint\r\n{\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @notice Constructor to create a MintableSnapshotToken\r\n    /// @param parentToken Address of the parent token, set to 0x0 if it is a\r\n    ///  new token\r\n    constructor(\r\n        IClonedTokenParent parentToken,\r\n        uint256 parentSnapshotId\r\n    )\r\n        BasicSnapshotToken(parentToken, parentSnapshotId)\r\n        internal\r\n    {}\r\n\r\n    /// @notice Generates `amount` tokens that are assigned to `owner`\r\n    /// @param owner The address that will be assigned the new tokens\r\n    /// @param amount The quantity of tokens generated\r\n    function mGenerateTokens(address owner, uint256 amount)\r\n        internal\r\n    {\r\n        // never create for address 0\r\n        require(owner != address(0));\r\n        // block changes in clone that points to future/current snapshots of patent token\r\n        require(parentToken() == address(0) || parentSnapshotId() < parentToken().currentSnapshotId());\r\n\r\n        uint256 curTotalSupply = totalSupply();\r\n        uint256 newTotalSupply = curTotalSupply + amount;\r\n        require(newTotalSupply >= curTotalSupply); // Check for overflow\r\n\r\n        uint256 previousBalanceTo = balanceOf(owner);\r\n        uint256 newBalanceTo = previousBalanceTo + amount;\r\n        assert(newBalanceTo >= previousBalanceTo); // Check for overflow\r\n\r\n        setValue(_totalSupplyValues, newTotalSupply);\r\n        setValue(_balances[owner], newBalanceTo);\r\n\r\n        emit Transfer(0, owner, amount);\r\n    }\r\n\r\n    /// @notice Burns `amount` tokens from `owner`\r\n    /// @param owner The address that will lose the tokens\r\n    /// @param amount The quantity of tokens to burn\r\n    function mDestroyTokens(address owner, uint256 amount)\r\n        internal\r\n    {\r\n        // block changes in clone that points to future/current snapshots of patent token\r\n        require(parentToken() == address(0) || parentSnapshotId() < parentToken().currentSnapshotId());\r\n\r\n        uint256 curTotalSupply = totalSupply();\r\n        require(curTotalSupply >= amount);\r\n\r\n        uint256 previousBalanceFrom = balanceOf(owner);\r\n        require(previousBalanceFrom >= amount);\r\n\r\n        uint256 newTotalSupply = curTotalSupply - amount;\r\n        uint256 newBalanceFrom = previousBalanceFrom - amount;\r\n        setValue(_totalSupplyValues, newTotalSupply);\r\n        setValue(_balances[owner], newBalanceFrom);\r\n\r\n        emit Transfer(owner, 0, amount);\r\n    }\r\n}\r\n\r\n/*\r\n    Copyright 2016, Jordi Baylina\r\n    Copyright 2017, Remco Bloemen, Marcin Rudolf\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n */\r\n/// @title StandardSnapshotToken Contract\r\n/// @author Jordi Baylina, Remco Bloemen, Marcin Rudolf\r\n/// @dev This token contract's goal is to make it easy for anyone to clone this\r\n///  token using the token distribution at a given block, this will allow DAO's\r\n///  and DApps to upgrade their features in a decentralized manner without\r\n///  affecting the original token\r\n/// @dev It is ERC20 compliant, but still needs to under go further testing.\r\n/// @dev Various contracts are composed to provide required functionality of this token, different compositions are possible\r\n///     MintableSnapshotToken provides transfer, miniting and snapshotting functions\r\n///     TokenAllowance provides approve/transferFrom functions\r\n///     TokenMetadata adds name, symbol and other token metadata\r\n/// @dev This token is still abstract, Snapshot, BasicSnapshotToken and TokenAllowance observe interfaces that must be implemented\r\n///     MSnapshotPolicy - particular snapshot id creation mechanism\r\n///     MTokenController - controlls approvals and transfers\r\n///     see Neumark as an example\r\n/// @dev implements ERC223 token transfer\r\ncontract StandardSnapshotToken is\r\n    MintableSnapshotToken,\r\n    TokenAllowance\r\n{\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @notice Constructor to create a MiniMeToken\r\n    ///  is a new token\r\n    /// param tokenName Name of the new token\r\n    /// param decimalUnits Number of decimals of the new token\r\n    /// param tokenSymbol Token Symbol for the new token\r\n    constructor(\r\n        IClonedTokenParent parentToken,\r\n        uint256 parentSnapshotId\r\n    )\r\n        MintableSnapshotToken(parentToken, parentSnapshotId)\r\n        TokenAllowance()\r\n        internal\r\n    {}\r\n}\r\n\r\n/// @title old ERC223 callback function\r\n/// @dev as used in Neumark and ICBMEtherToken\r\ncontract IERC223LegacyCallback {\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    function onTokenTransfer(address from, uint256 amount, bytes data)\r\n        public;\r\n\r\n}\r\n\r\ncontract Neumark is\r\n    AccessControlled,\r\n    AccessRoles,\r\n    Agreement,\r\n    DailyAndSnapshotable,\r\n    StandardSnapshotToken,\r\n    TokenMetadata,\r\n    IERC223Token,\r\n    NeumarkIssuanceCurve,\r\n    Reclaimable,\r\n    IsContract\r\n{\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    string private constant TOKEN_NAME = \"Neumark\";\r\n\r\n    uint8  private constant TOKEN_DECIMALS = 18;\r\n\r\n    string private constant TOKEN_SYMBOL = \"NEU\";\r\n\r\n    string private constant VERSION = \"NMK_1.0\";\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // disable transfers when Neumark is created\r\n    bool private _transferEnabled = false;\r\n\r\n    // at which point on curve new Neumarks will be created, see NeumarkIssuanceCurve contract\r\n    // do not use to get total invested funds. see burn(). this is just a cache for expensive inverse function\r\n    uint256 private _totalEurUlps;\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    event LogNeumarksIssued(\r\n        address indexed owner,\r\n        uint256 euroUlps,\r\n        uint256 neumarkUlps\r\n    );\r\n\r\n    event LogNeumarksBurned(\r\n        address indexed owner,\r\n        uint256 euroUlps,\r\n        uint256 neumarkUlps\r\n    );\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        IAccessPolicy accessPolicy,\r\n        IEthereumForkArbiter forkArbiter\r\n    )\r\n        AccessRoles()\r\n        Agreement(accessPolicy, forkArbiter)\r\n        StandardSnapshotToken(\r\n            IClonedTokenParent(0x0),\r\n            0\r\n        )\r\n        TokenMetadata(\r\n            TOKEN_NAME,\r\n            TOKEN_DECIMALS,\r\n            TOKEN_SYMBOL,\r\n            VERSION\r\n        )\r\n        DailyAndSnapshotable(0)\r\n        NeumarkIssuanceCurve()\r\n        Reclaimable()\r\n        public\r\n    {}\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice issues new Neumarks to msg.sender with reward at current curve position\r\n    ///     moves curve position by euroUlps\r\n    ///     callable only by ROLE_NEUMARK_ISSUER\r\n    function issueForEuro(uint256 euroUlps)\r\n        public\r\n        only(ROLE_NEUMARK_ISSUER)\r\n        acceptAgreement(msg.sender)\r\n        returns (uint256)\r\n    {\r\n        require(_totalEurUlps + euroUlps >= _totalEurUlps);\r\n        uint256 neumarkUlps = incremental(_totalEurUlps, euroUlps);\r\n        _totalEurUlps += euroUlps;\r\n        mGenerateTokens(msg.sender, neumarkUlps);\r\n        emit LogNeumarksIssued(msg.sender, euroUlps, neumarkUlps);\r\n        return neumarkUlps;\r\n    }\r\n\r\n    /// @notice used by ROLE_NEUMARK_ISSUER to transer newly issued neumarks\r\n    ///     typically to the investor and platform operator\r\n    function distribute(address to, uint256 neumarkUlps)\r\n        public\r\n        only(ROLE_NEUMARK_ISSUER)\r\n        acceptAgreement(to)\r\n    {\r\n        mTransfer(msg.sender, to, neumarkUlps);\r\n    }\r\n\r\n    /// @notice msg.sender can burn their Neumarks, curve is rolled back using inverse\r\n    ///     curve. as a result cost of Neumark gets lower (reward is higher)\r\n    function burn(uint256 neumarkUlps)\r\n        public\r\n        only(ROLE_NEUMARK_BURNER)\r\n    {\r\n        burnPrivate(neumarkUlps, 0, _totalEurUlps);\r\n    }\r\n\r\n    /// @notice executes as function above but allows to provide search range for low gas burning\r\n    function burn(uint256 neumarkUlps, uint256 minEurUlps, uint256 maxEurUlps)\r\n        public\r\n        only(ROLE_NEUMARK_BURNER)\r\n    {\r\n        burnPrivate(neumarkUlps, minEurUlps, maxEurUlps);\r\n    }\r\n\r\n    function enableTransfer(bool enabled)\r\n        public\r\n        only(ROLE_TRANSFER_ADMIN)\r\n    {\r\n        _transferEnabled = enabled;\r\n    }\r\n\r\n    function createSnapshot()\r\n        public\r\n        only(ROLE_SNAPSHOT_CREATOR)\r\n        returns (uint256)\r\n    {\r\n        return DailyAndSnapshotable.createSnapshot();\r\n    }\r\n\r\n    function transferEnabled()\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return _transferEnabled;\r\n    }\r\n\r\n    function totalEuroUlps()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _totalEurUlps;\r\n    }\r\n\r\n    function incremental(uint256 euroUlps)\r\n        public\r\n        constant\r\n        returns (uint256 neumarkUlps)\r\n    {\r\n        return incremental(_totalEurUlps, euroUlps);\r\n    }\r\n\r\n    //\r\n    // Implements IERC223Token with IERC223Callback (onTokenTransfer) callback\r\n    //\r\n\r\n    // old implementation of ERC223 that was actual when ICBM was deployed\r\n    // as Neumark is already deployed this function keeps old behavior for testing\r\n    function transfer(address to, uint256 amount, bytes data)\r\n        public\r\n        returns (bool)\r\n    {\r\n        // it is necessary to point out implementation to be called\r\n        BasicSnapshotToken.mTransfer(msg.sender, to, amount);\r\n\r\n        // Notify the receiving contract.\r\n        if (isContract(to)) {\r\n            IERC223LegacyCallback(to).onTokenTransfer(msg.sender, amount, data);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Implements MTokenController\r\n    //\r\n\r\n    function mOnTransfer(\r\n        address from,\r\n        address, // to\r\n        uint256 // amount\r\n    )\r\n        internal\r\n        acceptAgreement(from)\r\n        returns (bool allow)\r\n    {\r\n        // must have transfer enabled or msg.sender is Neumark issuer\r\n        return _transferEnabled || accessPolicy().allowed(msg.sender, ROLE_NEUMARK_ISSUER, this, msg.sig);\r\n    }\r\n\r\n    function mOnApprove(\r\n        address owner,\r\n        address, // spender,\r\n        uint256 // amount\r\n    )\r\n        internal\r\n        acceptAgreement(owner)\r\n        returns (bool allow)\r\n    {\r\n        return true;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    function burnPrivate(uint256 burnNeumarkUlps, uint256 minEurUlps, uint256 maxEurUlps)\r\n        private\r\n    {\r\n        uint256 prevEuroUlps = _totalEurUlps;\r\n        // burn first in the token to make sure balance/totalSupply is not crossed\r\n        mDestroyTokens(msg.sender, burnNeumarkUlps);\r\n        _totalEurUlps = cumulativeInverse(totalSupply(), minEurUlps, maxEurUlps);\r\n        // actually may overflow on non-monotonic inverse\r\n        assert(prevEuroUlps >= _totalEurUlps);\r\n        uint256 euroUlps = prevEuroUlps - _totalEurUlps;\r\n        emit LogNeumarksBurned(msg.sender, euroUlps, burnNeumarkUlps);\r\n    }\r\n}\r\n\r\n/// @title disburse payment token amount to snapshot token holders\r\n/// @dev payment token received via ERC223 Transfer\r\ncontract IFeeDisbursal is IERC223Callback {\r\n    // TODO: declare interface\r\n}\r\n\r\n/// @title disburse payment token amount to snapshot token holders\r\n/// @dev payment token received via ERC223 Transfer\r\ncontract IPlatformPortfolio is IERC223Callback {\r\n    // TODO: declare interface\r\n}\r\n\r\ncontract ITokenExchangeRateOracle {\r\n    /// @notice provides actual price of 'numeratorToken' in 'denominatorToken'\r\n    ///     returns timestamp at which price was obtained in oracle\r\n    function getExchangeRate(address numeratorToken, address denominatorToken)\r\n        public\r\n        constant\r\n        returns (uint256 rateFraction, uint256 timestamp);\r\n\r\n    /// @notice allows to retreive multiple exchange rates in once call\r\n    function getExchangeRates(address[] numeratorTokens, address[] denominatorTokens)\r\n        public\r\n        constant\r\n        returns (uint256[] rateFractions, uint256[] timestamps);\r\n}\r\n\r\n/// @title root of trust and singletons + known interface registry\r\n/// provides a root which holds all interfaces platform trust, this includes\r\n/// singletons - for which accessors are provided\r\n/// collections of known instances of interfaces\r\n/// @dev interfaces are identified by bytes4, see KnownInterfaces.sol\r\ncontract Universe is\r\n    Agreement,\r\n    IContractId,\r\n    KnownInterfaces\r\n{\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// raised on any change of singleton instance\r\n    /// @dev for convenience we provide previous instance of singleton in replacedInstance\r\n    event LogSetSingleton(\r\n        bytes4 interfaceId,\r\n        address instance,\r\n        address replacedInstance\r\n    );\r\n\r\n    /// raised on add/remove interface instance in collection\r\n    event LogSetCollectionInterface(\r\n        bytes4 interfaceId,\r\n        address instance,\r\n        bool isSet\r\n    );\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // mapping of known contracts to addresses of singletons\r\n    mapping(bytes4 => address) private _singletons;\r\n\r\n    // mapping of known interfaces to collections of contracts\r\n    mapping(bytes4 =>\r\n        mapping(address => bool)) private _collections; // solium-disable-line indentation\r\n\r\n    // known instances\r\n    mapping(address => bytes4[]) private _instances;\r\n\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        IAccessPolicy accessPolicy,\r\n        IEthereumForkArbiter forkArbiter\r\n    )\r\n        Agreement(accessPolicy, forkArbiter)\r\n        public\r\n    {\r\n        setSingletonPrivate(KNOWN_INTERFACE_ACCESS_POLICY, accessPolicy);\r\n        setSingletonPrivate(KNOWN_INTERFACE_FORK_ARBITER, forkArbiter);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public methods\r\n    ////////////////////////\r\n\r\n    /// get singleton instance for 'interfaceId'\r\n    function getSingleton(bytes4 interfaceId)\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return _singletons[interfaceId];\r\n    }\r\n\r\n    function getManySingletons(bytes4[] interfaceIds)\r\n        public\r\n        constant\r\n        returns (address[])\r\n    {\r\n        address[] memory addresses = new address[](interfaceIds.length);\r\n        uint256 idx;\r\n        while(idx < interfaceIds.length) {\r\n            addresses[idx] = _singletons[interfaceIds[idx]];\r\n            idx += 1;\r\n        }\r\n        return addresses;\r\n    }\r\n\r\n    /// checks of 'instance' is instance of interface 'interfaceId'\r\n    function isSingleton(bytes4 interfaceId, address instance)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return _singletons[interfaceId] == instance;\r\n    }\r\n\r\n    /// checks if 'instance' is one of instances of 'interfaceId'\r\n    function isInterfaceCollectionInstance(bytes4 interfaceId, address instance)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return _collections[interfaceId][instance];\r\n    }\r\n\r\n    function isAnyOfInterfaceCollectionInstance(bytes4[] interfaceIds, address instance)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        uint256 idx;\r\n        while(idx < interfaceIds.length) {\r\n            if (_collections[interfaceIds[idx]][instance]) {\r\n                return true;\r\n            }\r\n            idx += 1;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// gets all interfaces of given instance\r\n    function getInterfacesOfInstance(address instance)\r\n        public\r\n        constant\r\n        returns (bytes4[] interfaces)\r\n    {\r\n        return _instances[instance];\r\n    }\r\n\r\n    /// sets 'instance' of singleton with interface 'interfaceId'\r\n    function setSingleton(bytes4 interfaceId, address instance)\r\n        public\r\n        only(ROLE_UNIVERSE_MANAGER)\r\n    {\r\n        setSingletonPrivate(interfaceId, instance);\r\n    }\r\n\r\n    /// convenience method for setting many singleton instances\r\n    function setManySingletons(bytes4[] interfaceIds, address[] instances)\r\n        public\r\n        only(ROLE_UNIVERSE_MANAGER)\r\n    {\r\n        require(interfaceIds.length == instances.length);\r\n        uint256 idx;\r\n        while(idx < interfaceIds.length) {\r\n            setSingletonPrivate(interfaceIds[idx], instances[idx]);\r\n            idx += 1;\r\n        }\r\n    }\r\n\r\n    /// set or unset 'instance' with 'interfaceId' in collection of instances\r\n    function setCollectionInterface(bytes4 interfaceId, address instance, bool set)\r\n        public\r\n        only(ROLE_UNIVERSE_MANAGER)\r\n    {\r\n        setCollectionPrivate(interfaceId, instance, set);\r\n    }\r\n\r\n    /// set or unset 'instance' in many collections of instances\r\n    function setInterfaceInManyCollections(bytes4[] interfaceIds, address instance, bool set)\r\n        public\r\n        only(ROLE_UNIVERSE_MANAGER)\r\n    {\r\n        uint256 idx;\r\n        while(idx < interfaceIds.length) {\r\n            setCollectionPrivate(interfaceIds[idx], instance, set);\r\n            idx += 1;\r\n        }\r\n    }\r\n\r\n    /// set or unset array of collection\r\n    function setCollectionsInterfaces(bytes4[] interfaceIds, address[] instances, bool[] set_flags)\r\n        public\r\n        only(ROLE_UNIVERSE_MANAGER)\r\n    {\r\n        require(interfaceIds.length == instances.length);\r\n        require(interfaceIds.length == set_flags.length);\r\n        uint256 idx;\r\n        while(idx < interfaceIds.length) {\r\n            setCollectionPrivate(interfaceIds[idx], instances[idx], set_flags[idx]);\r\n            idx += 1;\r\n        }\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x8b57bfe21a3ef4854e19d702063b6cea03fa514162f8ff43fde551f06372fefd, 0);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Getters\r\n    ////////////////////////\r\n\r\n    function accessPolicy() public constant returns (IAccessPolicy) {\r\n        return IAccessPolicy(_singletons[KNOWN_INTERFACE_ACCESS_POLICY]);\r\n    }\r\n\r\n    function forkArbiter() public constant returns (IEthereumForkArbiter) {\r\n        return IEthereumForkArbiter(_singletons[KNOWN_INTERFACE_FORK_ARBITER]);\r\n    }\r\n\r\n    function neumark() public constant returns (Neumark) {\r\n        return Neumark(_singletons[KNOWN_INTERFACE_NEUMARK]);\r\n    }\r\n\r\n    function etherToken() public constant returns (IERC223Token) {\r\n        return IERC223Token(_singletons[KNOWN_INTERFACE_ETHER_TOKEN]);\r\n    }\r\n\r\n    function euroToken() public constant returns (IERC223Token) {\r\n        return IERC223Token(_singletons[KNOWN_INTERFACE_EURO_TOKEN]);\r\n    }\r\n\r\n    function etherLock() public constant returns (address) {\r\n        return _singletons[KNOWN_INTERFACE_ETHER_LOCK];\r\n    }\r\n\r\n    function euroLock() public constant returns (address) {\r\n        return _singletons[KNOWN_INTERFACE_EURO_LOCK];\r\n    }\r\n\r\n    function icbmEtherLock() public constant returns (address) {\r\n        return _singletons[KNOWN_INTERFACE_ICBM_ETHER_LOCK];\r\n    }\r\n\r\n    function icbmEuroLock() public constant returns (address) {\r\n        return _singletons[KNOWN_INTERFACE_ICBM_EURO_LOCK];\r\n    }\r\n\r\n    function identityRegistry() public constant returns (address) {\r\n        return IIdentityRegistry(_singletons[KNOWN_INTERFACE_IDENTITY_REGISTRY]);\r\n    }\r\n\r\n    function tokenExchangeRateOracle() public constant returns (address) {\r\n        return ITokenExchangeRateOracle(_singletons[KNOWN_INTERFACE_TOKEN_EXCHANGE_RATE_ORACLE]);\r\n    }\r\n\r\n    function feeDisbursal() public constant returns (address) {\r\n        return IFeeDisbursal(_singletons[KNOWN_INTERFACE_FEE_DISBURSAL]);\r\n    }\r\n\r\n    function platformPortfolio() public constant returns (address) {\r\n        return IPlatformPortfolio(_singletons[KNOWN_INTERFACE_PLATFORM_PORTFOLIO]);\r\n    }\r\n\r\n    function tokenExchange() public constant returns (address) {\r\n        return _singletons[KNOWN_INTERFACE_TOKEN_EXCHANGE];\r\n    }\r\n\r\n    function gasExchange() public constant returns (address) {\r\n        return _singletons[KNOWN_INTERFACE_GAS_EXCHANGE];\r\n    }\r\n\r\n    function platformTerms() public constant returns (address) {\r\n        return _singletons[KNOWN_INTERFACE_PLATFORM_TERMS];\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private methods\r\n    ////////////////////////\r\n\r\n    function setSingletonPrivate(bytes4 interfaceId, address instance)\r\n        private\r\n    {\r\n        require(interfaceId != KNOWN_INTERFACE_UNIVERSE, \"NF_UNI_NO_UNIVERSE_SINGLETON\");\r\n        address replacedInstance = _singletons[interfaceId];\r\n        // do nothing if not changing\r\n        if (replacedInstance != instance) {\r\n            dropInstance(replacedInstance, interfaceId);\r\n            addInstance(instance, interfaceId);\r\n            _singletons[interfaceId] = instance;\r\n        }\r\n\r\n        emit LogSetSingleton(interfaceId, instance, replacedInstance);\r\n    }\r\n\r\n    function setCollectionPrivate(bytes4 interfaceId, address instance, bool set)\r\n        private\r\n    {\r\n        // do nothing if not changing\r\n        if (_collections[interfaceId][instance] == set) {\r\n            return;\r\n        }\r\n        _collections[interfaceId][instance] = set;\r\n        if (set) {\r\n            addInstance(instance, interfaceId);\r\n        } else {\r\n            dropInstance(instance, interfaceId);\r\n        }\r\n        emit LogSetCollectionInterface(interfaceId, instance, set);\r\n    }\r\n\r\n    function addInstance(address instance, bytes4 interfaceId)\r\n        private\r\n    {\r\n        if (instance == address(0)) {\r\n            // do not add null instance\r\n            return;\r\n        }\r\n        bytes4[] storage current = _instances[instance];\r\n        uint256 idx;\r\n        while(idx < current.length) {\r\n            // instancy has this interface already, do nothing\r\n            if (current[idx] == interfaceId)\r\n                return;\r\n            idx += 1;\r\n        }\r\n        // new interface\r\n        current.push(interfaceId);\r\n    }\r\n\r\n    function dropInstance(address instance, bytes4 interfaceId)\r\n        private\r\n    {\r\n        if (instance == address(0)) {\r\n            // do not drop null instance\r\n            return;\r\n        }\r\n        bytes4[] storage current = _instances[instance];\r\n        uint256 idx;\r\n        uint256 last = current.length - 1;\r\n        while(idx <= last) {\r\n            if (current[idx] == interfaceId) {\r\n                // delete element\r\n                if (idx < last) {\r\n                    // if not last element move last element to idx being deleted\r\n                    current[idx] = current[last];\r\n                }\r\n                // delete last element\r\n                current.length -= 1;\r\n                return;\r\n            }\r\n            idx += 1;\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice mixin that enables contract to receive migration\r\n/// @dev when derived from\r\ncontract MigrationTarget is\r\n    IMigrationTarget\r\n{\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    // intended to be applied on migration receiving function\r\n    modifier onlyMigrationSource() {\r\n        require(msg.sender == currentMigrationSource(), \"NF_INV_SOURCE\");\r\n        _;\r\n    }\r\n}\r\n\r\n/// @notice implemented in the contract that is the target of LockedAccount migration\r\n///  migration process is removing investors balance from source LockedAccount fully\r\n///  target should re-create investor with the same balance, totalLockedAmount and totalInvestors are invariant during migration\r\ncontract ICBMLockedAccountMigration is\r\n    MigrationTarget\r\n{\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // implemented in migration target, apply `onlyMigrationSource()` modifier, modifiers are not inherited\r\n    function migrateInvestor(\r\n        address investor,\r\n        uint256 balance,\r\n        uint256 neumarksDue,\r\n        uint256 unlockDate\r\n    )\r\n        public;\r\n\r\n}\r\n\r\n/// @title standard access roles of the Platform\r\n/// @dev constants are kept in CODE not in STORAGE so they are comparatively cheap\r\ncontract ICBMRoles {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // NOTE: All roles are set to the keccak256 hash of the\r\n    // CamelCased role name, i.e.\r\n    // ROLE_LOCKED_ACCOUNT_ADMIN = keccak256(\"LockedAccountAdmin\")\r\n\r\n    // may setup LockedAccount, change disbursal mechanism and set migration\r\n    bytes32 internal constant ROLE_LOCKED_ACCOUNT_ADMIN = 0x4675da546d2d92c5b86c4f726a9e61010dce91cccc2491ce6019e78b09d2572e;\r\n\r\n    // may setup whitelists and abort whitelisting contract with curve rollback\r\n    bytes32 internal constant ROLE_WHITELIST_ADMIN = 0xaef456e7c864418e1d2a40d996ca4febf3a7e317fe3af5a7ea4dda59033bbe5c;\r\n}\r\n\r\ncontract TimeSource {\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function currentTime() internal constant returns (uint256) {\r\n        return block.timestamp;\r\n    }\r\n}\r\n\r\ncontract ICBMLockedAccount is\r\n    AccessControlled,\r\n    ICBMRoles,\r\n    TimeSource,\r\n    Math,\r\n    IsContract,\r\n    MigrationSource,\r\n    IERC677Callback,\r\n    Reclaimable\r\n{\r\n\r\n    ////////////////////////\r\n    // Type declarations\r\n    ////////////////////////\r\n\r\n    // state space of LockedAccount\r\n    enum LockState {\r\n        // controller is not yet set\r\n        Uncontrolled,\r\n        // new funds lockd are accepted from investors\r\n        AcceptingLocks,\r\n        // funds may be unlocked by investors, final state\r\n        AcceptingUnlocks,\r\n        // funds may be unlocked by investors, without any constraints, final state\r\n        ReleaseAll\r\n    }\r\n\r\n    // represents locked account of the investor\r\n    struct Account {\r\n        // funds locked in the account\r\n        uint256 balance;\r\n        // neumark amount that must be returned to unlock\r\n        uint256 neumarksDue;\r\n        // date with which unlock may happen without penalty\r\n        uint256 unlockDate;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // a token controlled by LockedAccount, read ERC20 + extensions to read what\r\n    // token is it (ETH/EUR etc.)\r\n    IERC677Token private ASSET_TOKEN;\r\n\r\n    Neumark private NEUMARK;\r\n\r\n    // longstop period in seconds\r\n    uint256 private LOCK_PERIOD;\r\n\r\n    // penalty: decimalFraction of stored amount on escape hatch\r\n    uint256 private PENALTY_FRACTION;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // total amount of tokens locked\r\n    uint256 private _totalLockedAmount;\r\n\r\n    // total number of locked investors\r\n    uint256 internal _totalInvestors;\r\n\r\n    // current state of the locking contract\r\n    LockState private _lockState;\r\n\r\n    // controlling contract that may lock money or unlock all account if fails\r\n    address private _controller;\r\n\r\n    // fee distribution pool\r\n    address private _penaltyDisbursalAddress;\r\n\r\n    // LockedAccountMigration private migration;\r\n    mapping(address => Account) internal _accounts;\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// @notice logged when funds are locked by investor\r\n    /// @param investor address of investor locking funds\r\n    /// @param amount amount of newly locked funds\r\n    /// @param amount of neumarks that must be returned to unlock funds\r\n    event LogFundsLocked(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        uint256 neumarks\r\n    );\r\n\r\n    /// @notice logged when investor unlocks funds\r\n    /// @param investor address of investor unlocking funds\r\n    /// @param amount amount of unlocked funds\r\n    /// @param neumarks amount of Neumarks that was burned\r\n    event LogFundsUnlocked(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        uint256 neumarks\r\n    );\r\n\r\n    /// @notice logged when unlock penalty is disbursed to Neumark holders\r\n    /// @param disbursalPoolAddress address of disbursal pool receiving penalty\r\n    /// @param amount penalty amount\r\n    /// @param assetToken address of token contract penalty was paid with\r\n    /// @param investor addres of investor paying penalty\r\n    /// @dev assetToken and investor parameters are added for quick tallying penalty payouts\r\n    event LogPenaltyDisbursed(\r\n        address indexed disbursalPoolAddress,\r\n        uint256 amount,\r\n        address assetToken,\r\n        address investor\r\n    );\r\n\r\n    /// @notice logs Locked Account state transitions\r\n    event LogLockStateTransition(\r\n        LockState oldState,\r\n        LockState newState\r\n    );\r\n\r\n    event LogInvestorMigrated(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        uint256 neumarks,\r\n        uint256 unlockDate\r\n    );\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    modifier onlyController() {\r\n        require(msg.sender == address(_controller));\r\n        _;\r\n    }\r\n\r\n    modifier onlyState(LockState state) {\r\n        require(_lockState == state);\r\n        _;\r\n    }\r\n\r\n    modifier onlyStates(LockState state1, LockState state2) {\r\n        require(_lockState == state1 || _lockState == state2);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @notice creates new LockedAccount instance\r\n    /// @param policy governs execution permissions to admin functions\r\n    /// @param assetToken token contract representing funds locked\r\n    /// @param neumark Neumark token contract\r\n    /// @param penaltyDisbursalAddress address of disbursal contract for penalty fees\r\n    /// @param lockPeriod period for which funds are locked, in seconds\r\n    /// @param penaltyFraction decimal fraction of unlocked amount paid as penalty,\r\n    ///     if unlocked before lockPeriod is over\r\n    /// @dev this implementation does not allow spending funds on ICOs but provides\r\n    ///     a migration mechanism to final LockedAccount with such functionality\r\n    constructor(\r\n        IAccessPolicy policy,\r\n        IERC677Token assetToken,\r\n        Neumark neumark,\r\n        address penaltyDisbursalAddress,\r\n        uint256 lockPeriod,\r\n        uint256 penaltyFraction\r\n    )\r\n        MigrationSource(policy, ROLE_LOCKED_ACCOUNT_ADMIN)\r\n        Reclaimable()\r\n        public\r\n    {\r\n        ASSET_TOKEN = assetToken;\r\n        NEUMARK = neumark;\r\n        LOCK_PERIOD = lockPeriod;\r\n        PENALTY_FRACTION = penaltyFraction;\r\n        _penaltyDisbursalAddress = penaltyDisbursalAddress;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice locks funds of investors for a period of time\r\n    /// @param investor funds owner\r\n    /// @param amount amount of funds locked\r\n    /// @param neumarks amount of neumarks that needs to be returned by investor to unlock funds\r\n    /// @dev callable only from controller (Commitment) contract\r\n    function lock(address investor, uint256 amount, uint256 neumarks)\r\n        public\r\n        onlyState(LockState.AcceptingLocks)\r\n        onlyController()\r\n    {\r\n        require(amount > 0);\r\n        // transfer to itself from Commitment contract allowance\r\n        assert(ASSET_TOKEN.transferFrom(msg.sender, address(this), amount));\r\n\r\n        Account storage account = _accounts[investor];\r\n        account.balance = addBalance(account.balance, amount);\r\n        account.neumarksDue = add(account.neumarksDue, neumarks);\r\n\r\n        if (account.unlockDate == 0) {\r\n            // this is new account - unlockDate always > 0\r\n            _totalInvestors += 1;\r\n            account.unlockDate = currentTime() + LOCK_PERIOD;\r\n        }\r\n        emit LogFundsLocked(investor, amount, neumarks);\r\n    }\r\n\r\n    /// @notice unlocks investors funds, see unlockInvestor for details\r\n    /// @dev function requires that proper allowance on Neumark is made to LockedAccount by msg.sender\r\n    ///     except in ReleaseAll state which does not burn Neumark\r\n    function unlock()\r\n        public\r\n        onlyStates(LockState.AcceptingUnlocks, LockState.ReleaseAll)\r\n    {\r\n        unlockInvestor(msg.sender);\r\n    }\r\n\r\n    /// @notice unlocks investors funds, see unlockInvestor for details\r\n    /// @dev this ERC667 callback by Neumark contract after successful approve\r\n    ///     allows to unlock and allow neumarks to be burned in one transaction\r\n    function receiveApproval(\r\n        address from,\r\n        uint256, // _amount,\r\n        address _token,\r\n        bytes _data\r\n    )\r\n        public\r\n        onlyState(LockState.AcceptingUnlocks)\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == _token);\r\n        require(_data.length == 0);\r\n\r\n        // only from neumarks\r\n        require(_token == address(NEUMARK));\r\n\r\n        // this will check if allowance was made and if _amount is enough to\r\n        //  unlock, reverts on any error condition\r\n        unlockInvestor(from);\r\n\r\n        // we assume external call so return value will be lost to clients\r\n        // that's why we throw above\r\n        return true;\r\n    }\r\n\r\n    /// allows to anyone to release all funds without burning Neumarks and any\r\n    /// other penalties\r\n    function controllerFailed()\r\n        public\r\n        onlyState(LockState.AcceptingLocks)\r\n        onlyController()\r\n    {\r\n        changeState(LockState.ReleaseAll);\r\n    }\r\n\r\n    /// allows anyone to use escape hatch\r\n    function controllerSucceeded()\r\n        public\r\n        onlyState(LockState.AcceptingLocks)\r\n        onlyController()\r\n    {\r\n        changeState(LockState.AcceptingUnlocks);\r\n    }\r\n\r\n    function setController(address controller)\r\n        public\r\n        only(ROLE_LOCKED_ACCOUNT_ADMIN)\r\n        onlyState(LockState.Uncontrolled)\r\n    {\r\n        _controller = controller;\r\n        changeState(LockState.AcceptingLocks);\r\n    }\r\n\r\n    /// sets address to which tokens from unlock penalty are sent\r\n    /// both simple addresses and contracts are allowed\r\n    /// contract needs to implement ApproveAndCallCallback interface\r\n    function setPenaltyDisbursal(address penaltyDisbursalAddress)\r\n        public\r\n        only(ROLE_LOCKED_ACCOUNT_ADMIN)\r\n    {\r\n        require(penaltyDisbursalAddress != address(0));\r\n\r\n        // can be changed at any moment by admin\r\n        _penaltyDisbursalAddress = penaltyDisbursalAddress;\r\n    }\r\n\r\n    function assetToken()\r\n        public\r\n        constant\r\n        returns (IERC677Token)\r\n    {\r\n        return ASSET_TOKEN;\r\n    }\r\n\r\n    function neumark()\r\n        public\r\n        constant\r\n        returns (Neumark)\r\n    {\r\n        return NEUMARK;\r\n    }\r\n\r\n    function lockPeriod()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return LOCK_PERIOD;\r\n    }\r\n\r\n    function penaltyFraction()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return PENALTY_FRACTION;\r\n    }\r\n\r\n    function balanceOf(address investor)\r\n        public\r\n        constant\r\n        returns (uint256, uint256, uint256)\r\n    {\r\n        Account storage account = _accounts[investor];\r\n        return (account.balance, account.neumarksDue, account.unlockDate);\r\n    }\r\n\r\n    function controller()\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return _controller;\r\n    }\r\n\r\n    function lockState()\r\n        public\r\n        constant\r\n        returns (LockState)\r\n    {\r\n        return _lockState;\r\n    }\r\n\r\n    function totalLockedAmount()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _totalLockedAmount;\r\n    }\r\n\r\n    function totalInvestors()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _totalInvestors;\r\n    }\r\n\r\n    function penaltyDisbursalAddress()\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return _penaltyDisbursalAddress;\r\n    }\r\n\r\n    //\r\n    // Overrides migration source\r\n    //\r\n\r\n    /// enables migration to new LockedAccount instance\r\n    /// it can be set only once to prevent setting temporary migrations that let\r\n    /// just one investor out\r\n    /// may be set in AcceptingLocks state (in unlikely event that controller\r\n    /// fails we let investors out)\r\n    /// and AcceptingUnlocks - which is normal operational mode\r\n    function enableMigration(IMigrationTarget migration)\r\n        public\r\n        onlyStates(LockState.AcceptingLocks, LockState.AcceptingUnlocks)\r\n    {\r\n        // will enforce other access controls\r\n        MigrationSource.enableMigration(migration);\r\n    }\r\n\r\n    /// migrates single investor\r\n    function migrate()\r\n        public\r\n        onlyMigrationEnabled()\r\n    {\r\n        // migrates\r\n        Account memory account = _accounts[msg.sender];\r\n\r\n        // return on non existing accounts silently\r\n        if (account.balance == 0) {\r\n            return;\r\n        }\r\n\r\n        // this will clear investor storage\r\n        removeInvestor(msg.sender, account.balance);\r\n\r\n        // let migration target to own asset balance that belongs to investor\r\n        assert(ASSET_TOKEN.approve(address(_migration), account.balance));\r\n        ICBMLockedAccountMigration(_migration).migrateInvestor(\r\n            msg.sender,\r\n            account.balance,\r\n            account.neumarksDue,\r\n            account.unlockDate\r\n        );\r\n        emit LogInvestorMigrated(msg.sender, account.balance, account.neumarksDue, account.unlockDate);\r\n    }\r\n\r\n    //\r\n    // Overrides Reclaimable\r\n    //\r\n\r\n    /// @notice allows LockedAccount to reclaim tokens wrongly sent to its address\r\n    /// @dev as LockedAccount by design has balance of assetToken (in the name of investors)\r\n    ///     such reclamation is not allowed\r\n    function reclaim(IBasicToken token)\r\n        public\r\n    {\r\n        // forbid reclaiming locked tokens\r\n        require(token != ASSET_TOKEN);\r\n        Reclaimable.reclaim(token);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function addBalance(uint256 balance, uint256 amount)\r\n        internal\r\n        returns (uint256)\r\n    {\r\n        _totalLockedAmount = add(_totalLockedAmount, amount);\r\n        uint256 newBalance = balance + amount;\r\n        return newBalance;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    function subBalance(uint256 balance, uint256 amount)\r\n        private\r\n        returns (uint256)\r\n    {\r\n        _totalLockedAmount -= amount;\r\n        return balance - amount;\r\n    }\r\n\r\n    function removeInvestor(address investor, uint256 balance)\r\n        private\r\n    {\r\n        subBalance(balance, balance);\r\n        _totalInvestors -= 1;\r\n        delete _accounts[investor];\r\n    }\r\n\r\n    function changeState(LockState newState)\r\n        private\r\n    {\r\n        assert(newState != _lockState);\r\n        emit LogLockStateTransition(_lockState, newState);\r\n        _lockState = newState;\r\n    }\r\n\r\n    /// @notice unlocks 'investor' tokens by making them withdrawable from assetToken\r\n    /// @dev expects number of neumarks that is due on investor's account to be approved for LockedAccount for transfer\r\n    /// @dev there are 3 unlock modes depending on contract and investor state\r\n    ///     in 'AcceptingUnlocks' state Neumarks due will be burned and funds transferred to investors address in assetToken,\r\n    ///         before unlockDate, penalty is deduced and distributed\r\n    ///     in 'ReleaseAll' neumarks are not burned and unlockDate is not observed, funds are unlocked unconditionally\r\n    function unlockInvestor(address investor)\r\n        private\r\n    {\r\n        // use memory storage to obtain copy and be able to erase storage\r\n        Account memory accountInMem = _accounts[investor];\r\n\r\n        // silently return on non-existing accounts\r\n        if (accountInMem.balance == 0) {\r\n            return;\r\n        }\r\n        // remove investor account before external calls\r\n        removeInvestor(investor, accountInMem.balance);\r\n\r\n        // Neumark burning and penalty processing only in AcceptingUnlocks state\r\n        if (_lockState == LockState.AcceptingUnlocks) {\r\n            // transfer Neumarks to be burned to itself via allowance mechanism\r\n            //  not enough allowance results in revert which is acceptable state so 'require' is used\r\n            require(NEUMARK.transferFrom(investor, address(this), accountInMem.neumarksDue));\r\n\r\n            // burn neumarks corresponding to unspent funds\r\n            NEUMARK.burn(accountInMem.neumarksDue);\r\n\r\n            // take the penalty if before unlockDate\r\n            if (currentTime() < accountInMem.unlockDate) {\r\n                require(_penaltyDisbursalAddress != address(0));\r\n                uint256 penalty = decimalFraction(accountInMem.balance, PENALTY_FRACTION);\r\n\r\n                // distribute penalty\r\n                if (isContract(_penaltyDisbursalAddress)) {\r\n                    require(\r\n                        ASSET_TOKEN.approveAndCall(_penaltyDisbursalAddress, penalty, \"\")\r\n                    );\r\n                } else {\r\n                    // transfer to simple address\r\n                    assert(ASSET_TOKEN.transfer(_penaltyDisbursalAddress, penalty));\r\n                }\r\n                emit LogPenaltyDisbursed(_penaltyDisbursalAddress, penalty, ASSET_TOKEN, investor);\r\n                accountInMem.balance -= penalty;\r\n            }\r\n        }\r\n        if (_lockState == LockState.ReleaseAll) {\r\n            accountInMem.neumarksDue = 0;\r\n        }\r\n        // transfer amount back to investor - now it can withdraw\r\n        assert(ASSET_TOKEN.transfer(investor, accountInMem.balance));\r\n        emit LogFundsUnlocked(investor, accountInMem.balance, accountInMem.neumarksDue);\r\n    }\r\n}\r\n\r\ncontract LockedAccount is\r\n    Agreement,\r\n    Math,\r\n    Serialization,\r\n    ICBMLockedAccountMigration,\r\n    IdentityRecord,\r\n    KnownInterfaces,\r\n    Reclaimable,\r\n    IContractId\r\n{\r\n    ////////////////////////\r\n    // Type declarations\r\n    ////////////////////////\r\n\r\n    /// represents locked account of the investor\r\n    struct Account {\r\n        // funds locked in the account\r\n        uint112 balance;\r\n        // neumark amount that must be returned to unlock\r\n        uint112 neumarksDue;\r\n        // date with which unlock may happen without penalty\r\n        uint32 unlockDate;\r\n    }\r\n\r\n    /// represents account migration destination\r\n    /// @notice migration destinations require KYC when being set\r\n    /// @dev used to setup migration to different wallet if for some reason investors\r\n    ///   wants to use different wallet in the Platform than ICBM.\r\n    /// @dev it also allows to split the tickets, neumarks due will be split proportionally\r\n    struct Destination {\r\n        // destination wallet\r\n        address investor;\r\n        // amount to be migrated to wallet above. 0 means all funds\r\n        uint112 amount;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // token that stores investors' funds\r\n    IERC223Token private PAYMENT_TOKEN;\r\n\r\n    Neumark private NEUMARK;\r\n\r\n    // longstop period in seconds\r\n    uint256 private LOCK_PERIOD;\r\n\r\n    // penalty: decimalFraction of stored amount on escape hatch\r\n    uint256 private PENALTY_FRACTION;\r\n\r\n    // interface registry\r\n    Universe private UNIVERSE;\r\n\r\n    // icbm locked account which is migration source\r\n    ICBMLockedAccount private MIGRATION_SOURCE;\r\n\r\n    // old payment token\r\n    IERC677Token private OLD_PAYMENT_TOKEN;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // total amount of tokens locked\r\n    uint112 private _totalLockedAmount;\r\n\r\n    // total number of locked investors\r\n    uint256 internal _totalInvestors;\r\n\r\n    // all accounts\r\n    mapping(address => Account) internal _accounts;\r\n\r\n    // tracks investment to be able to control refunds (commitment => investor => account)\r\n    mapping(address => mapping(address => Account)) internal _commitments;\r\n\r\n    // account migration destinations\r\n    mapping(address => Destination[]) private _destinations;\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// @notice logged when funds are committed to token offering\r\n    /// @param investor address\r\n    /// @param commitment commitment contract where funds were sent\r\n    /// @param amount amount of invested funds\r\n    /// @param amount of corresponging Neumarks that successful offering will \"unlock\"\r\n    event LogFundsCommitted(\r\n        address indexed investor,\r\n        address indexed commitment,\r\n        uint256 amount,\r\n        uint256 neumarks\r\n    );\r\n\r\n    /// @notice logged when investor unlocks funds\r\n    /// @param investor address of investor unlocking funds\r\n    /// @param amount amount of unlocked funds\r\n    /// @param neumarks amount of Neumarks that was burned\r\n    event LogFundsUnlocked(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        uint256 neumarks\r\n    );\r\n\r\n    /// @notice logged when investor account is migrated\r\n    /// @param investor address receiving the migration\r\n    /// @param amount amount of newly migrated funds\r\n    /// @param amount of neumarks that must be returned to unlock funds\r\n    event LogFundsLocked(\r\n        address indexed investor,\r\n        uint256 amount,\r\n        uint256 neumarks\r\n    );\r\n\r\n    /// @notice logged when investor funds/obligations moved to different address\r\n    /// @param oldInvestor current address\r\n    /// @param newInvestor destination address\r\n    /// @dev see move function for comments\r\n    /*event LogInvestorMoved(\r\n        address indexed oldInvestor,\r\n        address indexed newInvestor\r\n    );*/\r\n\r\n    /// @notice logged when funds are locked as a refund by commitment contract\r\n    /// @param investor address of refunded investor\r\n    /// @param commitment commitment contract sending the refund\r\n    /// @param amount refund amount\r\n    /// @param amount of neumarks corresponding to the refund\r\n    event LogFundsRefunded(\r\n        address indexed investor,\r\n        address indexed commitment,\r\n        uint256 amount,\r\n        uint256 neumarks\r\n    );\r\n\r\n    /// @notice logged when unlock penalty is disbursed to Neumark holders\r\n    /// @param disbursalPoolAddress address of disbursal pool receiving penalty\r\n    /// @param amount penalty amount\r\n    /// @param paymentToken address of token contract penalty was paid with\r\n    /// @param investor addres of investor paying penalty\r\n    /// @dev paymentToken and investor parameters are added for quick tallying penalty payouts\r\n    event LogPenaltyDisbursed(\r\n        address indexed disbursalPoolAddress,\r\n        address indexed investor,\r\n        uint256 amount,\r\n        address paymentToken\r\n    );\r\n\r\n    /// @notice logged when migration destination is set for an investor\r\n    event LogMigrationDestination(\r\n        address indexed investor,\r\n        address indexed destination,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    modifier onlyIfCommitment(address commitment) {\r\n        // is allowed token offering\r\n        require(UNIVERSE.isInterfaceCollectionInstance(KNOWN_INTERFACE_COMMITMENT, commitment), \"NF_LOCKED_ONLY_COMMITMENT\");\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// @notice creates new LockedAccount instance\r\n    /// @param universe provides interface and identity registries\r\n    /// @param paymentToken token contract representing funds locked\r\n    /// @param migrationSource old locked account\r\n    constructor(\r\n        Universe universe,\r\n        Neumark neumark,\r\n        IERC223Token paymentToken,\r\n        ICBMLockedAccount migrationSource\r\n    )\r\n        Agreement(universe.accessPolicy(), universe.forkArbiter())\r\n        Reclaimable()\r\n        public\r\n    {\r\n        PAYMENT_TOKEN = paymentToken;\r\n        MIGRATION_SOURCE = migrationSource;\r\n        OLD_PAYMENT_TOKEN = MIGRATION_SOURCE.assetToken();\r\n        UNIVERSE = universe;\r\n        NEUMARK = neumark;\r\n        LOCK_PERIOD = migrationSource.lockPeriod();\r\n        PENALTY_FRACTION = migrationSource.penaltyFraction();\r\n        // this is not super sexy but it's very practical against attaching ETH wallet to EUR wallet\r\n        // we decrease chances of migration lethal setup errors in non migrated wallets\r\n        require(keccak256(abi.encodePacked(ITokenMetadata(OLD_PAYMENT_TOKEN).symbol())) == keccak256(abi.encodePacked(PAYMENT_TOKEN.symbol())));\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    /// @notice commits funds in one of offerings on the platform\r\n    /// @param commitment commitment contract with token offering\r\n    /// @param amount amount of funds to invest\r\n    /// @dev data ignored, to keep compatibility with ERC223\r\n    /// @dev happens via ERC223 transfer and callback\r\n    function transfer(address commitment, uint256 amount, bytes /*data*/)\r\n        public\r\n        onlyIfCommitment(commitment)\r\n    {\r\n        require(amount > 0, \"NF_LOCKED_NO_ZERO\");\r\n        Account storage account = _accounts[msg.sender];\r\n        // no overflow with account.balance which is uint112\r\n        require(account.balance >= amount, \"NF_LOCKED_NO_FUNDS\");\r\n        // calculate unlocked NEU as proportion of invested amount to account balance\r\n        uint112 unlockedNmkUlps = uint112(\r\n            proportion(\r\n                account.neumarksDue,\r\n                amount,\r\n                account.balance\r\n            )\r\n        );\r\n        account.balance = subBalance(account.balance, uint112(amount));\r\n        // will not overflow as amount < account.balance so unlockedNmkUlps must be >= account.neumarksDue\r\n        account.neumarksDue -= unlockedNmkUlps;\r\n        // track investment\r\n        Account storage investment = _commitments[address(commitment)][msg.sender];\r\n        investment.balance += uint112(amount);\r\n        investment.neumarksDue += unlockedNmkUlps;\r\n        // invest via ERC223 interface\r\n        assert(PAYMENT_TOKEN.transfer(commitment, amount, abi.encodePacked(msg.sender)));\r\n        emit LogFundsCommitted(msg.sender, commitment, amount, unlockedNmkUlps);\r\n    }\r\n\r\n    /// @notice unlocks investors funds, see unlockInvestor for details\r\n    /// @dev function requires that proper allowance on Neumark is made to LockedAccount by msg.sender\r\n    ///     except in ReleaseAll state which does not burn Neumark\r\n    function unlock()\r\n        public\r\n    {\r\n        unlockInvestor(msg.sender);\r\n    }\r\n\r\n    /// @notice unlocks investors funds, see unlockInvestor for details\r\n    /// @dev this ERC667 callback by Neumark contract after successful approve\r\n    ///     allows to unlock and allow neumarks to be burned in one transaction\r\n    function receiveApproval(address from, uint256, address _token, bytes _data)\r\n        public\r\n        returns (bool)\r\n    {\r\n        require(msg.sender == _token);\r\n        require(_data.length == 0);\r\n        // only from neumarks\r\n        require(_token == address(NEUMARK), \"NF_ONLY_NEU\");\r\n        // this will check if allowance was made and if _amount is enough to\r\n        //  unlock, reverts on any error condition\r\n        unlockInvestor(from);\r\n        return true;\r\n    }\r\n\r\n    /// @notice refunds investor in case of failed offering\r\n    /// @param investor funds owner\r\n    /// @dev callable only by ETO contract, bookkeeping in LockedAccount::_commitments\r\n    /// @dev expected that ETO makes allowance for transferFrom\r\n    function refunded(address investor)\r\n        public\r\n    {\r\n        Account memory investment = _commitments[msg.sender][investor];\r\n        // return silently when there is no refund (so commitment contracts can blank-call, less gas used)\r\n        if (investment.balance == 0)\r\n            return;\r\n        // free gas here\r\n        delete _commitments[msg.sender][investor];\r\n        Account storage account = _accounts[investor];\r\n        // account must exist\r\n        require(account.unlockDate > 0, \"NF_LOCKED_ACCOUNT_LIQUIDATED\");\r\n        // add refunded amount\r\n        account.balance = addBalance(account.balance, investment.balance);\r\n        account.neumarksDue = add112(account.neumarksDue, investment.neumarksDue);\r\n        // transfer to itself from Commitment contract allowance\r\n        assert(PAYMENT_TOKEN.transferFrom(msg.sender, address(this), investment.balance));\r\n        emit LogFundsRefunded(investor, msg.sender, investment.balance, investment.neumarksDue);\r\n    }\r\n\r\n    /// @notice may be used by commitment contract to refund gas for commitment bookkeeping\r\n    /// @dev https://gastoken.io/ (15000 - 900 for a call)\r\n    function claimed(address investor) public {\r\n        delete _commitments[msg.sender][investor];\r\n    }\r\n\r\n    /// checks commitments made from locked account that were not settled by ETO via refunded or claimed functions\r\n    function pendingCommitments(address commitment, address investor)\r\n        public\r\n        constant\r\n        returns (uint256 balance, uint256 neumarkDue)\r\n    {\r\n        Account storage i = _commitments[commitment][investor];\r\n        return (i.balance, i.neumarksDue);\r\n    }\r\n\r\n    //\r\n    // Implements LockedAccountMigrationTarget\r\n    //\r\n\r\n    function migrateInvestor(\r\n        address investor,\r\n        uint256 balance256,\r\n        uint256 neumarksDue256,\r\n        uint256 unlockDate256\r\n    )\r\n        public\r\n        onlyMigrationSource()\r\n    {\r\n        // internally we use 112 bits to store amounts\r\n        require(balance256 < 2**112, \"NF_OVR\");\r\n        uint112 balance = uint112(balance256);\r\n        assert(neumarksDue256 < 2**112);\r\n        uint112 neumarksDue = uint112(neumarksDue256);\r\n        assert(unlockDate256 < 2**32);\r\n        uint32 unlockDate = uint32(unlockDate256);\r\n\r\n        // transfer assets\r\n        require(OLD_PAYMENT_TOKEN.transferFrom(msg.sender, address(this), balance));\r\n        IWithdrawableToken(OLD_PAYMENT_TOKEN).withdraw(balance);\r\n        // migrate previous asset token depends on token type, unfortunatelly deposit function differs so we have to cast. this is weak...\r\n        if (PAYMENT_TOKEN == UNIVERSE.etherToken()) {\r\n            // after EtherToken withdraw, deposit ether into new token\r\n            EtherToken(PAYMENT_TOKEN).deposit.value(balance)();\r\n        } else {\r\n            EuroToken(PAYMENT_TOKEN).deposit(this, balance, 0x0);\r\n        }\r\n        Destination[] storage destinations = _destinations[investor];\r\n        if (destinations.length == 0) {\r\n            // if no destinations defined then migrate to original investor wallet\r\n            lock(investor, balance, neumarksDue, unlockDate);\r\n        } else {\r\n            // enumerate all destinations and migrate balance piece by piece\r\n            uint256 idx;\r\n            while(idx < destinations.length) {\r\n                Destination storage destination = destinations[idx];\r\n                // get partial amount to migrate, if 0 specified then take all, as a result 0 must be the last destination\r\n                uint112 partialAmount = destination.amount == 0 ? balance : destination.amount;\r\n                require(partialAmount <= balance, \"NF_LOCKED_ACCOUNT_SPLIT_OVERSPENT\");\r\n                // compute corresponding NEU proportionally, result < 10**18 as partialAmount <= balance\r\n                uint112 partialNmkUlps = uint112(\r\n                    proportion(\r\n                        neumarksDue,\r\n                        partialAmount,\r\n                        balance\r\n                    )\r\n                );\r\n                // no overflow see above\r\n                balance -= partialAmount;\r\n                // no overflow partialNmkUlps <= neumarksDue as as partialAmount <= balance, see proportion\r\n                neumarksDue -= partialNmkUlps;\r\n                // lock partial to destination investor\r\n                lock(destination.investor, partialAmount, partialNmkUlps, unlockDate);\r\n                idx += 1;\r\n            }\r\n            // all funds and NEU must be migrated\r\n            require(balance == 0, \"NF_LOCKED_ACCOUNT_SPLIT_UNDERSPENT\");\r\n            assert(neumarksDue == 0);\r\n            // free up gas\r\n            delete _destinations[investor];\r\n        }\r\n    }\r\n\r\n    /// @notice changes migration destination for msg.sender\r\n    /// @param destinationWallet where migrate funds to, must have valid verification claims\r\n    /// @dev msg.sender has funds in old icbm wallet and calls this function on new icbm wallet before s/he migrates\r\n    function setInvestorMigrationWallet(address destinationWallet)\r\n        public\r\n    {\r\n        Destination[] storage destinations = _destinations[msg.sender];\r\n        // delete old destinations\r\n        if(destinations.length > 0) {\r\n            delete _destinations[msg.sender];\r\n        }\r\n        // new destination for the whole amount\r\n        addDestination(destinations, destinationWallet, 0);\r\n    }\r\n\r\n    /// @dev if one of amounts is > 2**112, solidity will pass modulo value, so for 2**112 + 1, we'll get 1\r\n    ///      and that's fine\r\n    function setInvestorMigrationWallets(address[] wallets, uint112[] amounts)\r\n        public\r\n    {\r\n        require(wallets.length == amounts.length);\r\n        Destination[] storage destinations = _destinations[msg.sender];\r\n        // delete old destinations\r\n        if(destinations.length > 0) {\r\n            delete _destinations[msg.sender];\r\n        }\r\n        uint256 idx;\r\n        while(idx < wallets.length) {\r\n            addDestination(destinations, wallets[idx], amounts[idx]);\r\n            idx += 1;\r\n        }\r\n    }\r\n\r\n    /// @notice returns current set of destination wallets for investor migration\r\n    function getInvestorMigrationWallets(address investor)\r\n        public\r\n        constant\r\n        returns (address[] wallets, uint112[] amounts)\r\n    {\r\n        Destination[] storage destinations = _destinations[investor];\r\n        wallets = new address[](destinations.length);\r\n        amounts = new uint112[](destinations.length);\r\n        uint256 idx;\r\n        while(idx < destinations.length) {\r\n            wallets[idx] = destinations[idx].investor;\r\n            amounts[idx] = destinations[idx].amount;\r\n            idx += 1;\r\n        }\r\n    }\r\n\r\n    //\r\n    // Implements IMigrationTarget\r\n    //\r\n\r\n    function currentMigrationSource()\r\n        public\r\n        constant\r\n        returns (address)\r\n    {\r\n        return address(MIGRATION_SOURCE);\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x15fbe12e85e3698f22c35480f7c66bc38590bb8cfe18cbd6dc3d49355670e561, 0);\r\n    }\r\n\r\n    //\r\n    // Payable default function to receive ether during migration\r\n    //\r\n    function ()\r\n        public\r\n        payable\r\n    {\r\n        require(msg.sender == address(OLD_PAYMENT_TOKEN));\r\n    }\r\n\r\n    //\r\n    // Overrides Reclaimable\r\n    //\r\n\r\n    /// @notice allows LockedAccount to reclaim tokens wrongly sent to its address\r\n    /// @dev as LockedAccount by design has balance of paymentToken (in the name of investors)\r\n    ///     such reclamation is not allowed\r\n    function reclaim(IBasicToken token)\r\n        public\r\n    {\r\n        // forbid reclaiming locked tokens\r\n        require(token != PAYMENT_TOKEN, \"NO_PAYMENT_TOKEN_RECLAIM\");\r\n        Reclaimable.reclaim(token);\r\n    }\r\n\r\n    //\r\n    // Public accessors\r\n    //\r\n\r\n    function paymentToken()\r\n        public\r\n        constant\r\n        returns (IERC223Token)\r\n    {\r\n        return PAYMENT_TOKEN;\r\n    }\r\n\r\n    function neumark()\r\n        public\r\n        constant\r\n        returns (Neumark)\r\n    {\r\n        return NEUMARK;\r\n    }\r\n\r\n    function lockPeriod()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return LOCK_PERIOD;\r\n    }\r\n\r\n    function penaltyFraction()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return PENALTY_FRACTION;\r\n    }\r\n\r\n    function balanceOf(address investor)\r\n        public\r\n        constant\r\n        returns (uint256 balance, uint256 neumarksDue, uint32 unlockDate)\r\n    {\r\n        Account storage account = _accounts[investor];\r\n        return (account.balance, account.neumarksDue, account.unlockDate);\r\n    }\r\n\r\n    function totalLockedAmount()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _totalLockedAmount;\r\n    }\r\n\r\n    function totalInvestors()\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return _totalInvestors;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function addBalance(uint112 balance, uint112 amount)\r\n        internal\r\n        returns (uint112)\r\n    {\r\n        _totalLockedAmount = add112(_totalLockedAmount, amount);\r\n        // will not overflow as _totalLockedAmount >= balance\r\n        return balance + amount;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    function subBalance(uint112 balance, uint112 amount)\r\n        private\r\n        returns (uint112)\r\n    {\r\n        _totalLockedAmount = sub112(_totalLockedAmount, amount);\r\n        return sub112(balance, amount);\r\n    }\r\n\r\n    function removeInvestor(address investor, uint112 balance)\r\n        private\r\n    {\r\n        subBalance(balance, balance);\r\n        _totalInvestors -= 1;\r\n        delete _accounts[investor];\r\n    }\r\n\r\n    /// @notice unlocks 'investor' tokens by making them withdrawable from paymentToken\r\n    /// @dev expects number of neumarks that is due on investor's account to be approved for LockedAccount for transfer\r\n    /// @dev there are 3 unlock modes depending on contract and investor state\r\n    ///     in 'AcceptingUnlocks' state Neumarks due will be burned and funds transferred to investors address in paymentToken,\r\n    ///         before unlockDate, penalty is deduced and distributed\r\n    function unlockInvestor(address investor)\r\n        private\r\n    {\r\n        // use memory storage to obtain copy and be able to erase storage\r\n        Account memory accountInMem = _accounts[investor];\r\n\r\n        // silently return on non-existing accounts\r\n        if (accountInMem.balance == 0) {\r\n            return;\r\n        }\r\n        // remove investor account before external calls\r\n        removeInvestor(investor, accountInMem.balance);\r\n\r\n        // transfer Neumarks to be burned to itself via allowance mechanism\r\n        //  not enough allowance results in revert which is acceptable state so 'require' is used\r\n        require(NEUMARK.transferFrom(investor, address(this), accountInMem.neumarksDue));\r\n\r\n        // burn neumarks corresponding to unspent funds\r\n        NEUMARK.burn(accountInMem.neumarksDue);\r\n\r\n        // take the penalty if before unlockDate\r\n        if (block.timestamp < accountInMem.unlockDate) {\r\n            address penaltyDisbursalAddress = UNIVERSE.feeDisbursal();\r\n            require(penaltyDisbursalAddress != address(0));\r\n            uint112 penalty = uint112(decimalFraction(accountInMem.balance, PENALTY_FRACTION));\r\n            // distribution via ERC223 to contract or simple address\r\n            assert(PAYMENT_TOKEN.transfer(penaltyDisbursalAddress, penalty, abi.encodePacked(NEUMARK)));\r\n            emit LogPenaltyDisbursed(penaltyDisbursalAddress, investor, penalty, PAYMENT_TOKEN);\r\n            accountInMem.balance -= penalty;\r\n        }\r\n        // transfer amount back to investor - now it can withdraw\r\n        assert(PAYMENT_TOKEN.transfer(investor, accountInMem.balance, \"\"));\r\n        emit LogFundsUnlocked(investor, accountInMem.balance, accountInMem.neumarksDue);\r\n    }\r\n\r\n    /// @notice locks funds of investors for a period of time, called by migration\r\n    /// @param investor funds owner\r\n    /// @param amount amount of funds locked\r\n    /// @param neumarks amount of neumarks that needs to be returned by investor to unlock funds\r\n    /// @param unlockDate unlockDate of migrating account\r\n    /// @dev used only by migration\r\n    function lock(address investor, uint112 amount, uint112 neumarks, uint32 unlockDate)\r\n        private\r\n        acceptAgreement(investor)\r\n    {\r\n        require(amount > 0);\r\n        Account storage account = _accounts[investor];\r\n        if (account.unlockDate == 0) {\r\n            // this is new account - unlockDate always > 0\r\n            _totalInvestors += 1;\r\n        }\r\n\r\n        // update holdings\r\n        account.balance = addBalance(account.balance, amount);\r\n        account.neumarksDue = add112(account.neumarksDue, neumarks);\r\n        // overwrite unlockDate if it is earler. we do not supporting joining tickets from different investors\r\n        // this will discourage sending 1 wei to move unlock date\r\n        if (unlockDate > account.unlockDate) {\r\n            account.unlockDate = unlockDate;\r\n        }\r\n\r\n        emit LogFundsLocked(investor, amount, neumarks);\r\n    }\r\n\r\n    function addDestination(Destination[] storage destinations, address wallet, uint112 amount)\r\n        private\r\n    {\r\n        // only verified destinations\r\n        IIdentityRegistry identityRegistry = IIdentityRegistry(UNIVERSE.identityRegistry());\r\n        IdentityClaims memory claims = deserializeClaims(identityRegistry.getClaims(wallet));\r\n        require(claims.isVerified && !claims.accountFrozen, \"NF_DEST_NO_VERIFICATION\");\r\n        if (wallet != msg.sender) {\r\n            // prevent squatting - cannot set destination for not yet migrated investor\r\n            (,,uint256 unlockDate) = MIGRATION_SOURCE.balanceOf(wallet);\r\n            require(unlockDate == 0, \"NF_DEST_NO_SQUATTING\");\r\n        }\r\n\r\n        destinations.push(\r\n            Destination({investor: wallet, amount: amount})\r\n        );\r\n        emit LogMigrationDestination(msg.sender, wallet, amount);\r\n    }\r\n\r\n    function sub112(uint112 a, uint112 b) internal pure returns (uint112)\r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add112(uint112 a, uint112 b) internal pure returns (uint112)\r\n    {\r\n        uint112 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract ShareholderRights is IContractId {\r\n\r\n    ////////////////////////\r\n    // Types\r\n    ////////////////////////\r\n\r\n    enum VotingRule {\r\n        // nominee has no voting rights\r\n        NoVotingRights,\r\n        // nominee votes yes if token holders do not say otherwise\r\n        Positive,\r\n        // nominee votes against if token holders do not say otherwise\r\n        Negative,\r\n        // nominee passes the vote as is giving yes/no split\r\n        Proportional\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constants state\r\n    ////////////////////////\r\n\r\n    bytes32 private constant EMPTY_STRING_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // a right to drag along (or be dragged) on exit\r\n    bool public constant HAS_DRAG_ALONG_RIGHTS = true;\r\n    // a right to tag along\r\n    bool public constant HAS_TAG_ALONG_RIGHTS = true;\r\n    // information is fundamental right that cannot be removed\r\n    bool public constant HAS_GENERAL_INFORMATION_RIGHTS = true;\r\n    // voting Right\r\n    VotingRule public GENERAL_VOTING_RULE;\r\n    // voting rights in tag along\r\n    VotingRule public TAG_ALONG_VOTING_RULE;\r\n    // liquidation preference multiplicator as decimal fraction\r\n    uint256 public LIQUIDATION_PREFERENCE_MULTIPLIER_FRAC;\r\n    // founder's vesting\r\n    bool public HAS_FOUNDERS_VESTING;\r\n    // duration of general voting\r\n    uint256 public GENERAL_VOTING_DURATION;\r\n    // duration of restricted act votings (like exit etc.)\r\n    uint256 public RESTRICTED_ACT_VOTING_DURATION;\r\n    // offchain time to finalize and execute voting;\r\n    uint256 public VOTING_FINALIZATION_DURATION;\r\n    // quorum of tokenholders for the vote to count as decimal fraction\r\n    uint256 public TOKENHOLDERS_QUORUM_FRAC = 10**17; // 10%\r\n    // number of tokens voting / total supply must be more than this to count the vote\r\n    uint256 public VOTING_MAJORITY_FRAC = 10**17; // 10%\r\n    // url (typically IPFS hash) to investment agreement between nominee and company\r\n    string public INVESTMENT_AGREEMENT_TEMPLATE_URL;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        VotingRule generalVotingRule,\r\n        VotingRule tagAlongVotingRule,\r\n        uint256 liquidationPreferenceMultiplierFrac,\r\n        bool hasFoundersVesting,\r\n        uint256 generalVotingDuration,\r\n        uint256 restrictedActVotingDuration,\r\n        uint256 votingFinalizationDuration,\r\n        uint256 tokenholdersQuorumFrac,\r\n        uint256 votingMajorityFrac,\r\n        string investmentAgreementTemplateUrl\r\n    )\r\n        public\r\n    {\r\n        // todo: revise requires\r\n        require(uint(generalVotingRule) < 4);\r\n        require(uint(tagAlongVotingRule) < 4);\r\n        // quorum < 100%\r\n        require(tokenholdersQuorumFrac < 10**18);\r\n        require(keccak256(abi.encodePacked(investmentAgreementTemplateUrl)) != EMPTY_STRING_HASH);\r\n\r\n        GENERAL_VOTING_RULE = generalVotingRule;\r\n        TAG_ALONG_VOTING_RULE = tagAlongVotingRule;\r\n        LIQUIDATION_PREFERENCE_MULTIPLIER_FRAC = liquidationPreferenceMultiplierFrac;\r\n        HAS_FOUNDERS_VESTING = hasFoundersVesting;\r\n        GENERAL_VOTING_DURATION = generalVotingDuration;\r\n        RESTRICTED_ACT_VOTING_DURATION = restrictedActVotingDuration;\r\n        VOTING_FINALIZATION_DURATION = votingFinalizationDuration;\r\n        TOKENHOLDERS_QUORUM_FRAC = tokenholdersQuorumFrac;\r\n        VOTING_MAJORITY_FRAC = votingMajorityFrac;\r\n        INVESTMENT_AGREEMENT_TEMPLATE_URL = investmentAgreementTemplateUrl;\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x7f46caed28b4e7a90dc4db9bba18d1565e6c4824f0dc1b96b3b88d730da56e57, 0);\r\n    }\r\n}\r\n\r\n/// @title set terms of Platform (investor's network) of the ETO\r\ncontract PlatformTerms is Math, IContractId {\r\n\r\n    ////////////////////////\r\n    // Constants\r\n    ////////////////////////\r\n\r\n    // fraction of fee deduced on successful ETO (see Math.sol for fraction definition)\r\n    uint256 public constant PLATFORM_FEE_FRACTION = 3 * 10**16;\r\n    // fraction of tokens deduced on succesful ETO\r\n    uint256 public constant TOKEN_PARTICIPATION_FEE_FRACTION = 2 * 10**16;\r\n    // share of Neumark reward platform operator gets\r\n    // actually this is a divisor that splits Neumark reward in two parts\r\n    // the results of division belongs to platform operator, the remaining reward part belongs to investor\r\n    uint256 public constant PLATFORM_NEUMARK_SHARE = 2; // 50:50 division\r\n    // ICBM investors whitelisted by default\r\n    bool public constant IS_ICBM_INVESTOR_WHITELISTED = true;\r\n\r\n    // minimum ticket size Platform accepts in EUR ULPS\r\n    uint256 public constant MIN_TICKET_EUR_ULPS = 100 * 10**18;\r\n    // maximum ticket size Platform accepts in EUR ULPS\r\n    // no max ticket in general prospectus regulation\r\n    // uint256 public constant MAX_TICKET_EUR_ULPS = 10000000 * 10**18;\r\n\r\n    // min duration from setting the date to ETO start\r\n    uint256 public constant DATE_TO_WHITELIST_MIN_DURATION = 5 days;\r\n    // token rate expires after\r\n    uint256 public constant TOKEN_RATE_EXPIRES_AFTER = 4 hours;\r\n\r\n    // duration constraints\r\n    uint256 public constant MIN_WHITELIST_DURATION = 0 days;\r\n    uint256 public constant MAX_WHITELIST_DURATION = 30 days;\r\n    uint256 public constant MIN_PUBLIC_DURATION = 0 days;\r\n    uint256 public constant MAX_PUBLIC_DURATION = 60 days;\r\n\r\n    // minimum length of whole offer\r\n    uint256 public constant MIN_OFFER_DURATION = 1 days;\r\n    // quarter should be enough for everyone\r\n    uint256 public constant MAX_OFFER_DURATION = 90 days;\r\n\r\n    uint256 public constant MIN_SIGNING_DURATION = 14 days;\r\n    uint256 public constant MAX_SIGNING_DURATION = 60 days;\r\n\r\n    uint256 public constant MIN_CLAIM_DURATION = 7 days;\r\n    uint256 public constant MAX_CLAIM_DURATION = 30 days;\r\n\r\n    ////////////////////////\r\n    // Public Function\r\n    ////////////////////////\r\n\r\n    // calculates investor's and platform operator's neumarks from total reward\r\n    function calculateNeumarkDistribution(uint256 rewardNmk)\r\n        public\r\n        pure\r\n        returns (uint256 platformNmk, uint256 investorNmk)\r\n    {\r\n        // round down - platform may get 1 wei less than investor\r\n        platformNmk = rewardNmk / PLATFORM_NEUMARK_SHARE;\r\n        // rewardNmk > platformNmk always\r\n        return (platformNmk, rewardNmk - platformNmk);\r\n    }\r\n\r\n    function calculatePlatformTokenFee(uint256 tokenAmount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        // mind tokens having 0 precision\r\n        return proportion(tokenAmount, TOKEN_PARTICIPATION_FEE_FRACTION, 10**18);\r\n    }\r\n\r\n    function calculatePlatformFee(uint256 amount)\r\n        public\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return decimalFraction(amount, PLATFORM_FEE_FRACTION);\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x95482babc4e32de6c4dc3910ee7ae62c8e427efde6bc4e9ce0d6d93e24c39323, 0);\r\n    }\r\n}\r\n\r\n/// @title sets duration of states in ETO\r\ncontract ETODurationTerms is IContractId {\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // duration of Whitelist state\r\n    uint32 public WHITELIST_DURATION;\r\n\r\n    // duration of Public state\r\n    uint32 public PUBLIC_DURATION;\r\n\r\n    // time for Nominee and Company to sign Investment Agreement offchain and present proof on-chain\r\n    uint32 public SIGNING_DURATION;\r\n\r\n    // time for Claim before fee payout from ETO to NEU holders\r\n    uint32 public CLAIM_DURATION;\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        uint32 whitelistDuration,\r\n        uint32 publicDuration,\r\n        uint32 signingDuration,\r\n        uint32 claimDuration\r\n    )\r\n        public\r\n    {\r\n        WHITELIST_DURATION = whitelistDuration;\r\n        PUBLIC_DURATION = publicDuration;\r\n        SIGNING_DURATION = signingDuration;\r\n        CLAIM_DURATION = claimDuration;\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x5fb50201b453799d95f8a80291b940f1c543537b95bff2e3c78c2e36070494c0, 0);\r\n    }\r\n}\r\n\r\n/// @title sets terms for tokens in ETO\r\ncontract ETOTokenTerms is IContractId {\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // minimum number of tokens being offered. will set min cap\r\n    uint256 public MIN_NUMBER_OF_TOKENS;\r\n    // maximum number of tokens being offered. will set max cap\r\n    uint256 public MAX_NUMBER_OF_TOKENS;\r\n    // base token price in EUR-T, without any discount scheme\r\n    uint256 public TOKEN_PRICE_EUR_ULPS;\r\n    // maximum number of tokens in whitelist phase\r\n    uint256 public MAX_NUMBER_OF_TOKENS_IN_WHITELIST;\r\n    // equity tokens per share\r\n    uint256 public constant EQUITY_TOKENS_PER_SHARE = 10000;\r\n    // equity tokens decimals (precision)\r\n    uint8 public constant EQUITY_TOKENS_PRECISION = 0; // indivisible\r\n\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        uint256 minNumberOfTokens,\r\n        uint256 maxNumberOfTokens,\r\n        uint256 tokenPriceEurUlps,\r\n        uint256 maxNumberOfTokensInWhitelist\r\n    )\r\n        public\r\n    {\r\n        require(maxNumberOfTokensInWhitelist <= maxNumberOfTokens);\r\n        require(maxNumberOfTokens >= minNumberOfTokens);\r\n        // min cap must be > single share\r\n        require(minNumberOfTokens >= EQUITY_TOKENS_PER_SHARE, \"NF_ETO_TERMS_ONE_SHARE\");\r\n\r\n        MIN_NUMBER_OF_TOKENS = minNumberOfTokens;\r\n        MAX_NUMBER_OF_TOKENS = maxNumberOfTokens;\r\n        TOKEN_PRICE_EUR_ULPS = tokenPriceEurUlps;\r\n        MAX_NUMBER_OF_TOKENS_IN_WHITELIST = maxNumberOfTokensInWhitelist;\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x591e791aab2b14c80194b729a2abcba3e8cce1918be4061be170e7223357ae5c, 0);\r\n    }\r\n}\r\n\r\n/// @title base terms of Equity Token Offering\r\n/// encapsulates pricing, discounts and whitelisting mechanism\r\n/// @dev to be split is mixins\r\ncontract ETOTerms is\r\n    IdentityRecord,\r\n    Math,\r\n    IContractId\r\n{\r\n\r\n    ////////////////////////\r\n    // Types\r\n    ////////////////////////\r\n\r\n    // @notice whitelist entry with a discount\r\n    struct WhitelistTicket {\r\n        // this also overrides maximum ticket\r\n        uint128 discountAmountEurUlps;\r\n        // a percentage of full price to be paid (1 - discount)\r\n        uint128 fullTokenPriceFrac;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Constants state\r\n    ////////////////////////\r\n\r\n    bytes32 private constant EMPTY_STRING_HASH = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n    uint256 public constant MIN_QUALIFIED_INVESTOR_TICKET_EUR_ULPS = 100000 * 10**18;\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // reference to duration terms\r\n    ETODurationTerms public DURATION_TERMS;\r\n    // reference to token terms\r\n    ETOTokenTerms public TOKEN_TERMS;\r\n    // total number of shares in the company (incl. Authorized Shares) at moment of sale\r\n    uint256 public EXISTING_COMPANY_SHARES;\r\n    // sets nominal value of a share\r\n    uint256 public SHARE_NOMINAL_VALUE_EUR_ULPS;\r\n    // maximum discount on token price that may be given to investor (as decimal fraction)\r\n    // uint256 public MAXIMUM_TOKEN_PRICE_DISCOUNT_FRAC;\r\n    // minimum ticket\r\n    uint256 public MIN_TICKET_EUR_ULPS;\r\n    // maximum ticket for sophisiticated investors\r\n    uint256 public MAX_TICKET_EUR_ULPS;\r\n    // maximum ticket for simple investors\r\n    uint256 public MAX_TICKET_SIMPLE_EUR_ULPS;\r\n    // should enable transfers on ETO success\r\n    // transfers are always disabled during token offering\r\n    // if set to False transfers on Equity Token will remain disabled after offering\r\n    // once those terms are on-chain this flags fully controls token transferability\r\n    bool public ENABLE_TRANSFERS_ON_SUCCESS;\r\n    // tells if offering accepts retail investors. if so, registered prospectus is required\r\n    // and ENABLE_TRANSFERS_ON_SUCCESS is forced to be false as per current platform policy\r\n    bool public ALLOW_RETAIL_INVESTORS;\r\n    // represents the discount % for whitelist participants\r\n    uint256 public WHITELIST_DISCOUNT_FRAC;\r\n    // represents the discount % for public participants, using values > 0 will result\r\n    // in automatic downround shareholder resolution\r\n    uint256 public PUBLIC_DISCOUNT_FRAC;\r\n\r\n    // paperwork\r\n    // prospectus / investment memorandum / crowdfunding pamphlet etc.\r\n    string public INVESTOR_OFFERING_DOCUMENT_URL;\r\n    // settings for shareholder rights\r\n    ShareholderRights public SHAREHOLDER_RIGHTS;\r\n\r\n    // equity token setup\r\n    string public EQUITY_TOKEN_NAME;\r\n    string public EQUITY_TOKEN_SYMBOL;\r\n\r\n    // manages whitelist\r\n    address public WHITELIST_MANAGER;\r\n    // wallet registry of KYC procedure\r\n    IIdentityRegistry public IDENTITY_REGISTRY;\r\n    Universe public UNIVERSE;\r\n\r\n    // variables from token terms for local use\r\n    // minimum number of tokens being offered. will set min cap\r\n    uint256 private MIN_NUMBER_OF_TOKENS;\r\n    // maximum number of tokens being offered. will set max cap\r\n    uint256 private MAX_NUMBER_OF_TOKENS;\r\n    // base token price in EUR-T, without any discount scheme\r\n    uint256 private TOKEN_PRICE_EUR_ULPS;\r\n\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // mapping of investors allowed in whitelist\r\n    mapping (address => WhitelistTicket) private _whitelist;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    modifier onlyWhitelistManager() {\r\n        require(msg.sender == WHITELIST_MANAGER);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    // raised on invesor added to whitelist\r\n    event LogInvestorWhitelisted(\r\n        address indexed investor,\r\n        uint256 discountAmountEurUlps,\r\n        uint256 fullTokenPriceFrac\r\n    );\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    constructor(\r\n        Universe universe,\r\n        ETODurationTerms durationTerms,\r\n        ETOTokenTerms tokenTerms,\r\n        uint256 existingCompanyShares,\r\n        uint256 minTicketEurUlps,\r\n        uint256 maxTicketEurUlps,\r\n        bool allowRetailInvestors,\r\n        bool enableTransfersOnSuccess,\r\n        string investorOfferingDocumentUrl,\r\n        ShareholderRights shareholderRights,\r\n        string equityTokenName,\r\n        string equityTokenSymbol,\r\n        uint256 shareNominalValueEurUlps,\r\n        uint256 whitelistDiscountFrac,\r\n        uint256 publicDiscountFrac\r\n    )\r\n        public\r\n    {\r\n        require(durationTerms != address(0));\r\n        require(tokenTerms != address(0));\r\n        require(existingCompanyShares > 0);\r\n        require(keccak256(abi.encodePacked(investorOfferingDocumentUrl)) != EMPTY_STRING_HASH);\r\n        require(keccak256(abi.encodePacked(equityTokenName)) != EMPTY_STRING_HASH);\r\n        require(keccak256(abi.encodePacked(equityTokenSymbol)) != EMPTY_STRING_HASH);\r\n        require(shareholderRights != address(0));\r\n        // test interface\r\n        // require(shareholderRights.HAS_GENERAL_INFORMATION_RIGHTS());\r\n        require(shareNominalValueEurUlps > 0);\r\n        require(whitelistDiscountFrac >= 0 && whitelistDiscountFrac <= 99*10**16);\r\n        require(publicDiscountFrac >= 0 && publicDiscountFrac <= 99*10**16);\r\n        require(minTicketEurUlps<=maxTicketEurUlps);\r\n\r\n        // copy token terms variables\r\n        MIN_NUMBER_OF_TOKENS = tokenTerms.MIN_NUMBER_OF_TOKENS();\r\n        MAX_NUMBER_OF_TOKENS = tokenTerms.MAX_NUMBER_OF_TOKENS();\r\n        TOKEN_PRICE_EUR_ULPS = tokenTerms.TOKEN_PRICE_EUR_ULPS();\r\n\r\n        DURATION_TERMS = durationTerms;\r\n        TOKEN_TERMS = tokenTerms;\r\n        EXISTING_COMPANY_SHARES = existingCompanyShares;\r\n        MIN_TICKET_EUR_ULPS = minTicketEurUlps;\r\n        MAX_TICKET_EUR_ULPS = maxTicketEurUlps;\r\n        ALLOW_RETAIL_INVESTORS = allowRetailInvestors;\r\n        ENABLE_TRANSFERS_ON_SUCCESS = enableTransfersOnSuccess;\r\n        INVESTOR_OFFERING_DOCUMENT_URL = investorOfferingDocumentUrl;\r\n        SHAREHOLDER_RIGHTS = shareholderRights;\r\n        EQUITY_TOKEN_NAME = equityTokenName;\r\n        EQUITY_TOKEN_SYMBOL = equityTokenSymbol;\r\n        SHARE_NOMINAL_VALUE_EUR_ULPS = shareNominalValueEurUlps;\r\n        WHITELIST_DISCOUNT_FRAC = whitelistDiscountFrac;\r\n        PUBLIC_DISCOUNT_FRAC = publicDiscountFrac;\r\n        WHITELIST_MANAGER = msg.sender;\r\n        IDENTITY_REGISTRY = IIdentityRegistry(universe.identityRegistry());\r\n        UNIVERSE = universe;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Public methods\r\n    ////////////////////////\r\n\r\n    // calculates token amount for a given commitment at a position of the curve\r\n    // we require that equity token precision is 0\r\n    function calculateTokenAmount(uint256 /*totalEurUlps*/, uint256 committedEurUlps)\r\n        public\r\n        constant\r\n        returns (uint256 tokenAmountInt)\r\n    {\r\n        // we may disregard totalEurUlps as curve is flat, round down when calculating tokens\r\n        return committedEurUlps / calculatePriceFraction(10**18 - PUBLIC_DISCOUNT_FRAC);\r\n    }\r\n\r\n    // calculates amount of euro required to acquire amount of tokens at a position of the (inverse) curve\r\n    // we require that equity token precision is 0\r\n    function calculateEurUlpsAmount(uint256 /*totalTokensInt*/, uint256 tokenAmountInt)\r\n        public\r\n        constant\r\n        returns (uint256 committedEurUlps)\r\n    {\r\n        // we may disregard totalTokensInt as curve is flat\r\n        return mul(tokenAmountInt, calculatePriceFraction(10**18 - PUBLIC_DISCOUNT_FRAC));\r\n    }\r\n\r\n    // get mincap in EUR\r\n    function ESTIMATED_MIN_CAP_EUR_ULPS() public constant returns(uint256) {\r\n        return calculateEurUlpsAmount(0, MIN_NUMBER_OF_TOKENS);\r\n    }\r\n\r\n    // get max cap in EUR\r\n    function ESTIMATED_MAX_CAP_EUR_ULPS() public constant returns(uint256) {\r\n        return calculateEurUlpsAmount(0, MAX_NUMBER_OF_TOKENS);\r\n    }\r\n\r\n    function calculatePriceFraction(uint256 priceFrac) public constant returns(uint256) {\r\n        if (priceFrac == 1) {\r\n            return TOKEN_PRICE_EUR_ULPS;\r\n        } else {\r\n            return decimalFraction(priceFrac, TOKEN_PRICE_EUR_ULPS);\r\n        }\r\n    }\r\n\r\n    function addWhitelisted(\r\n        address[] investors,\r\n        uint256[] discountAmountsEurUlps,\r\n        uint256[] discountsFrac\r\n    )\r\n        external\r\n        onlyWhitelistManager\r\n    {\r\n        require(investors.length == discountAmountsEurUlps.length);\r\n        require(investors.length == discountsFrac.length);\r\n\r\n        for (uint256 i = 0; i < investors.length; i += 1) {\r\n            addWhitelistInvestorPrivate(investors[i], discountAmountsEurUlps[i], discountsFrac[i]);\r\n        }\r\n    }\r\n\r\n    function whitelistTicket(address investor)\r\n        public\r\n        constant\r\n        returns (bool isWhitelisted, uint256 discountAmountEurUlps, uint256 fullTokenPriceFrac)\r\n    {\r\n        WhitelistTicket storage wlTicket = _whitelist[investor];\r\n        isWhitelisted = wlTicket.fullTokenPriceFrac > 0;\r\n        discountAmountEurUlps = wlTicket.discountAmountEurUlps;\r\n        fullTokenPriceFrac = wlTicket.fullTokenPriceFrac;\r\n    }\r\n\r\n    // calculate contribution of investor\r\n    function calculateContribution(\r\n        address investor,\r\n        uint256 totalContributedEurUlps,\r\n        uint256 existingInvestorContributionEurUlps,\r\n        uint256 newInvestorContributionEurUlps,\r\n        bool applyWhitelistDiscounts\r\n    )\r\n        public\r\n        constant\r\n        returns (\r\n            bool isWhitelisted,\r\n            bool isEligible,\r\n            uint256 minTicketEurUlps,\r\n            uint256 maxTicketEurUlps,\r\n            uint256 equityTokenInt,\r\n            uint256 fixedSlotEquityTokenInt\r\n            )\r\n    {\r\n        (\r\n            isWhitelisted,\r\n            minTicketEurUlps,\r\n            maxTicketEurUlps,\r\n            equityTokenInt,\r\n            fixedSlotEquityTokenInt\r\n        ) = calculateContributionPrivate(\r\n            investor,\r\n            totalContributedEurUlps,\r\n            existingInvestorContributionEurUlps,\r\n            newInvestorContributionEurUlps,\r\n            applyWhitelistDiscounts);\r\n        // check if is eligible for investment\r\n        IdentityClaims memory claims = deserializeClaims(IDENTITY_REGISTRY.getClaims(investor));\r\n        isEligible = claims.isVerified && !claims.accountFrozen;\r\n    }\r\n\r\n    function equityTokensToShares(uint256 amount)\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return divRound(amount, TOKEN_TERMS.EQUITY_TOKENS_PER_SHARE());\r\n    }\r\n\r\n    /// @notice checks terms against platform terms, reverts on invalid\r\n    function requireValidTerms(PlatformTerms platformTerms)\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        // apply constraints on retail fundraising\r\n        if (ALLOW_RETAIL_INVESTORS) {\r\n            // make sure transfers are disabled after offering for retail investors\r\n            require(!ENABLE_TRANSFERS_ON_SUCCESS, \"NF_MUST_DISABLE_TRANSFERS\");\r\n        } else {\r\n            // only qualified investors allowed defined as tickets > 100000 EUR\r\n            require(MIN_TICKET_EUR_ULPS >= MIN_QUALIFIED_INVESTOR_TICKET_EUR_ULPS, \"NF_MIN_QUALIFIED_INVESTOR_TICKET\");\r\n        }\r\n        // min ticket must be > token price\r\n        require(MIN_TICKET_EUR_ULPS >= TOKEN_TERMS.TOKEN_PRICE_EUR_ULPS(), \"NF_MIN_TICKET_LT_TOKEN_PRICE\");\r\n        // it must be possible to collect more funds than max number of tokens\r\n        require(ESTIMATED_MAX_CAP_EUR_ULPS() >= MIN_TICKET_EUR_ULPS, \"NF_MAX_FUNDS_LT_MIN_TICKET\");\r\n\r\n        require(MIN_TICKET_EUR_ULPS >= platformTerms.MIN_TICKET_EUR_ULPS(), \"NF_ETO_TERMS_MIN_TICKET_EUR_ULPS\");\r\n        // duration checks\r\n        require(DURATION_TERMS.WHITELIST_DURATION() >= platformTerms.MIN_WHITELIST_DURATION(), \"NF_ETO_TERMS_WL_D_MIN\");\r\n        require(DURATION_TERMS.WHITELIST_DURATION() <= platformTerms.MAX_WHITELIST_DURATION(), \"NF_ETO_TERMS_WL_D_MAX\");\r\n\r\n        require(DURATION_TERMS.PUBLIC_DURATION() >= platformTerms.MIN_PUBLIC_DURATION(), \"NF_ETO_TERMS_PUB_D_MIN\");\r\n        require(DURATION_TERMS.PUBLIC_DURATION() <= platformTerms.MAX_PUBLIC_DURATION(), \"NF_ETO_TERMS_PUB_D_MAX\");\r\n\r\n        uint256 totalDuration = DURATION_TERMS.WHITELIST_DURATION() + DURATION_TERMS.PUBLIC_DURATION();\r\n        require(totalDuration >= platformTerms.MIN_OFFER_DURATION(), \"NF_ETO_TERMS_TOT_O_MIN\");\r\n        require(totalDuration <= platformTerms.MAX_OFFER_DURATION(), \"NF_ETO_TERMS_TOT_O_MAX\");\r\n\r\n        require(DURATION_TERMS.SIGNING_DURATION() >= platformTerms.MIN_SIGNING_DURATION(), \"NF_ETO_TERMS_SIG_MIN\");\r\n        require(DURATION_TERMS.SIGNING_DURATION() <= platformTerms.MAX_SIGNING_DURATION(), \"NF_ETO_TERMS_SIG_MAX\");\r\n\r\n        require(DURATION_TERMS.CLAIM_DURATION() >= platformTerms.MIN_CLAIM_DURATION(), \"NF_ETO_TERMS_CLAIM_MIN\");\r\n        require(DURATION_TERMS.CLAIM_DURATION() <= platformTerms.MAX_CLAIM_DURATION(), \"NF_ETO_TERMS_CLAIM_MAX\");\r\n\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x3468b14073c33fa00ee7f8a289b14f4a10c78ab72726033b27003c31c47b3f6a, 0);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private methods\r\n    ////////////////////////\r\n\r\n    function calculateContributionPrivate(\r\n        address investor,\r\n        uint256 totalContributedEurUlps,\r\n        uint256 existingInvestorContributionEurUlps,\r\n        uint256 newInvestorContributionEurUlps,\r\n        bool applyWhitelistDiscounts\r\n    )\r\n        private\r\n        constant\r\n        returns (\r\n            bool isWhitelisted,\r\n            uint256 minTicketEurUlps,\r\n            uint256 maxTicketEurUlps,\r\n            uint256 equityTokenInt,\r\n            uint256 fixedSlotEquityTokenInt\r\n        )\r\n    {\r\n        uint256 discountedAmount;\r\n        minTicketEurUlps = MIN_TICKET_EUR_ULPS;\r\n        maxTicketEurUlps = MAX_TICKET_EUR_ULPS;\r\n        WhitelistTicket storage wlTicket = _whitelist[investor];\r\n        // check if has access to discount\r\n        isWhitelisted = wlTicket.fullTokenPriceFrac > 0;\r\n        // whitelist use discount is possible\r\n        if (applyWhitelistDiscounts) {\r\n            // can invest more than general max ticket\r\n            maxTicketEurUlps = max(wlTicket.discountAmountEurUlps, maxTicketEurUlps);\r\n            // can invest less than general min ticket\r\n            if (wlTicket.discountAmountEurUlps > 0) {\r\n                minTicketEurUlps = min(wlTicket.discountAmountEurUlps, minTicketEurUlps);\r\n            }\r\n            if (existingInvestorContributionEurUlps < wlTicket.discountAmountEurUlps) {\r\n                discountedAmount = min(newInvestorContributionEurUlps, wlTicket.discountAmountEurUlps - existingInvestorContributionEurUlps);\r\n                // discount is fixed so use base token price\r\n                if (discountedAmount > 0) {\r\n                    // always round down when calculating tokens\r\n                    fixedSlotEquityTokenInt = discountedAmount / calculatePriceFraction(wlTicket.fullTokenPriceFrac);\r\n                }\r\n            }\r\n        }\r\n        // if any amount above discount\r\n        uint256 remainingAmount = newInvestorContributionEurUlps - discountedAmount;\r\n        if (remainingAmount > 0) {\r\n            if (applyWhitelistDiscounts && WHITELIST_DISCOUNT_FRAC > 0) {\r\n                // will not overflow, WHITELIST_DISCOUNT_FRAC < Q18 from constructor, also round down\r\n                equityTokenInt = remainingAmount / calculatePriceFraction(10**18 - WHITELIST_DISCOUNT_FRAC);\r\n            } else {\r\n                // use pricing along the curve\r\n                equityTokenInt = calculateTokenAmount(totalContributedEurUlps + discountedAmount, remainingAmount);\r\n            }\r\n        }\r\n        // should have all issued tokens\r\n        equityTokenInt += fixedSlotEquityTokenInt;\r\n\r\n    }\r\n\r\n    function addWhitelistInvestorPrivate(\r\n        address investor,\r\n        uint256 discountAmountEurUlps,\r\n        uint256 fullTokenPriceFrac\r\n    )\r\n        private\r\n    {\r\n        // Validate\r\n        require(investor != address(0));\r\n        require(fullTokenPriceFrac > 0 && fullTokenPriceFrac <= 10**18, \"NF_DISCOUNT_RANGE\");\r\n        require(discountAmountEurUlps < 2**128);\r\n\r\n\r\n        _whitelist[investor] = WhitelistTicket({\r\n            discountAmountEurUlps: uint128(discountAmountEurUlps),\r\n            fullTokenPriceFrac: uint128(fullTokenPriceFrac)\r\n        });\r\n\r\n        emit LogInvestorWhitelisted(investor, discountAmountEurUlps, fullTokenPriceFrac);\r\n    }\r\n\r\n}\r\n\r\n/// @title default interface of commitment process\r\n///  investment always happens via payment token ERC223 callback\r\n///  methods for checking finality and success/fail of the process are vailable\r\n///  commitment event is standardized for tracking\r\ncontract ICommitment is\r\n    IAgreement,\r\n    IERC223Callback\r\n{\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    /// on every commitment transaction\r\n    /// `investor` committed `amount` in `paymentToken` currency which was\r\n    /// converted to `baseCurrencyEquivalent` that generates `grantedAmount` of\r\n    /// `assetToken` and `neuReward` NEU\r\n    /// for investment funds could be provided from `wallet` (like icbm wallet) controlled by investor\r\n    event LogFundsCommitted(\r\n        address indexed investor,\r\n        address wallet,\r\n        address paymentToken,\r\n        uint256 amount,\r\n        uint256 baseCurrencyEquivalent,\r\n        uint256 grantedAmount,\r\n        address assetToken,\r\n        uint256 neuReward\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // says if state is final\r\n    function finalized() public constant returns (bool);\r\n\r\n    // says if state is success\r\n    function success() public constant returns (bool);\r\n\r\n    // says if state is failure\r\n    function failed() public constant returns (bool);\r\n\r\n    // currently committed funds\r\n    function totalInvestment()\r\n        public\r\n        constant\r\n        returns (\r\n            uint256 totalEquivEurUlps,\r\n            uint256 totalTokensInt,\r\n            uint256 totalInvestors\r\n        );\r\n\r\n    /// commit function happens via ERC223 callback that must happen from trusted payment token\r\n    /// @param investor address of the investor\r\n    /// @param amount amount commited\r\n    /// @param data may have meaning in particular ETO implementation\r\n    function tokenFallback(address investor, uint256 amount, bytes data)\r\n        public;\r\n\r\n}\r\n\r\n/// @title default interface of commitment process\r\ncontract IETOCommitment is\r\n    ICommitment,\r\n    IETOCommitmentStates\r\n{\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    // on every state transition\r\n    event LogStateTransition(\r\n        uint32 oldState,\r\n        uint32 newState,\r\n        uint32 timestamp\r\n    );\r\n\r\n    /// on a claim by invester\r\n    ///   `investor` claimed `amount` of `assetToken` and claimed `nmkReward` amount of NEU\r\n    event LogTokensClaimed(\r\n        address indexed investor,\r\n        address indexed assetToken,\r\n        uint256 amount,\r\n        uint256 nmkReward\r\n    );\r\n\r\n    /// on a refund to investor\r\n    ///   `investor` was refunded `amount` of `paymentToken`\r\n    /// @dev may be raised multiple times per refund operation\r\n    event LogFundsRefunded(\r\n        address indexed investor,\r\n        address indexed paymentToken,\r\n        uint256 amount\r\n    );\r\n\r\n    // logged at the moment of Company setting terms\r\n    event LogTermsSet(\r\n        address companyLegalRep,\r\n        address etoTerms,\r\n        address equityToken\r\n    );\r\n\r\n    // logged at the moment Company sets/resets Whitelisting start date\r\n    event LogETOStartDateSet(\r\n        address companyLegalRep,\r\n        uint256 previousTimestamp,\r\n        uint256 newTimestamp\r\n    );\r\n\r\n    // logged at the moment Signing procedure starts\r\n    event LogSigningStarted(\r\n        address nominee,\r\n        address companyLegalRep,\r\n        uint256 newShares,\r\n        uint256 capitalIncreaseEurUlps\r\n    );\r\n\r\n    // logged when company presents signed investment agreement\r\n    event LogCompanySignedAgreement(\r\n        address companyLegalRep,\r\n        address nominee,\r\n        string signedInvestmentAgreementUrl\r\n    );\r\n\r\n    // logged when nominee presents and verifies its copy of investment agreement\r\n    event LogNomineeConfirmedAgreement(\r\n        address nominee,\r\n        address companyLegalRep,\r\n        string signedInvestmentAgreementUrl\r\n    );\r\n\r\n    // logged on refund transition to mark destroyed tokens\r\n    event LogRefundStarted(\r\n        address assetToken,\r\n        uint256 totalTokenAmountInt,\r\n        uint256 totalRewardNmkUlps\r\n    );\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // ETOState control\r\n    //\r\n\r\n    // returns current ETO state\r\n    function state() public constant returns (ETOState);\r\n\r\n    // returns start of given state\r\n    function startOf(ETOState s) public constant returns (uint256);\r\n\r\n    // returns commitment observer (typically equity token controller)\r\n    function commitmentObserver() public constant returns (IETOCommitmentObserver);\r\n\r\n    //\r\n    // Commitment process\r\n    //\r\n\r\n    /// refunds investor if ETO failed\r\n    function refund() external;\r\n\r\n    function refundMany(address[] investors) external;\r\n\r\n    /// claims tokens if ETO is a success\r\n    function claim() external;\r\n\r\n    function claimMany(address[] investors) external;\r\n\r\n    // initiate fees payout\r\n    function payout() external;\r\n\r\n\r\n    //\r\n    // Offering terms\r\n    //\r\n\r\n    function etoTerms() public constant returns (ETOTerms);\r\n\r\n    // equity token\r\n    function equityToken() public constant returns (IEquityToken);\r\n\r\n    // nominee\r\n    function nominee() public constant returns (address);\r\n\r\n    function companyLegalRep() public constant returns (address);\r\n\r\n    /// signed agreement as provided by company and nominee\r\n    /// @dev available on Claim state transition\r\n    function signedInvestmentAgreementUrl() public constant returns (string);\r\n\r\n    /// financial outcome of token offering set on Signing state transition\r\n    /// @dev in preceding states 0 is returned\r\n    function contributionSummary()\r\n        public\r\n        constant\r\n        returns (\r\n            uint256 newShares, uint256 capitalIncreaseEurUlps,\r\n            uint256 additionalContributionEth, uint256 additionalContributionEurUlps,\r\n            uint256 tokenParticipationFeeInt, uint256 platformFeeEth, uint256 platformFeeEurUlps,\r\n            uint256 sharePriceEurUlps\r\n        );\r\n\r\n    /// method to obtain current investors ticket\r\n    function investorTicket(address investor)\r\n        public\r\n        constant\r\n        returns (\r\n            uint256 equivEurUlps,\r\n            uint256 rewardNmkUlps,\r\n            uint256 equityTokenInt,\r\n            uint256 sharesInt,\r\n            uint256 tokenPrice,\r\n            uint256 neuRate,\r\n            uint256 amountEth,\r\n            uint256 amountEurUlps,\r\n            bool claimOrRefundSettled,\r\n            bool usedLockedAccount\r\n        );\r\n}\r\n\r\ncontract METOStateMachineObserver is IETOCommitmentStates {\r\n    /// @notice called before state transitions, allows override transition due to additional business logic\r\n    /// @dev advance due to time implemented in advanceTimedState, here implement other conditions like\r\n    ///     max cap reached -> we go to signing\r\n    function mBeforeStateTransition(ETOState oldState, ETOState newState)\r\n        internal\r\n        constant\r\n        returns (ETOState newStateOverride);\r\n\r\n    /// @notice gets called after every state transition.\r\n    function mAfterTransition(ETOState oldState, ETOState newState)\r\n        internal;\r\n\r\n    /// @notice gets called after business logic, may induce state transition\r\n    function mAdavanceLogicState(ETOState oldState)\r\n        internal\r\n        constant\r\n        returns (ETOState);\r\n}\r\n\r\n/// @title time induced state machine for Equity Token Offering\r\n/// @notice implements ETO state machine with setup, whitelist, public, signing, claim, refund and payout phases\r\n/// @dev inherited contract must implement internal interface, see comments\r\n///  intended usage via 'withStateTransition' modifier which makes sure that state machine transitions into\r\n///  correct state before executing function body. note that this is contract state changing modifier so use with care\r\n/// @dev timed state change request is publicly accessible via 'handleTimedTransitions'\r\n/// @dev time is based on block.timestamp\r\ncontract ETOTimedStateMachine is\r\n    IETOCommitment,\r\n    METOStateMachineObserver\r\n{\r\n\r\n    ////////////////////////\r\n    // CONSTANTS\r\n    ////////////////////////\r\n\r\n    // uint32 private constant TS_STATE_NOT_SET = 1;\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // maps states to durations (index is ETOState)\r\n    uint32[] private ETO_STATE_DURATIONS;\r\n\r\n    // observer receives notifications on all state changes\r\n    IETOCommitmentObserver private COMMITMENT_OBSERVER;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // current state\r\n    ETOState private _state = ETOState.Setup;\r\n\r\n    // historical times of state transition (index is ETOState)\r\n    // internal access used to allow mocking time\r\n    uint32[7] internal _pastStateTransitionTimes;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    // @dev This modifier needs to be applied to all external non-constant functions.\r\n    //  this modifier goes _before_ other state modifiers like `onlyState`.\r\n    //  after function body execution state may transition again in `advanceLogicState`\r\n    modifier withStateTransition() {\r\n        // switch state due to time\r\n        advanceTimedState();\r\n        // execute function body\r\n        _;\r\n        // switch state due to business logic\r\n        advanceLogicState();\r\n    }\r\n\r\n    modifier onlyState(ETOState state) {\r\n        require(_state == state);\r\n        _;\r\n    }\r\n\r\n    modifier onlyStates(ETOState state0, ETOState state1) {\r\n        require(_state == state0 || _state == state1);\r\n        _;\r\n    }\r\n\r\n    /// @dev Multiple states can be handled by adding more modifiers.\r\n    /* modifier notInState(ETOState state) {\r\n        require(_state != state);\r\n        _;\r\n    }*/\r\n\r\n    ////////////////////////\r\n    // Public functions\r\n    ////////////////////////\r\n\r\n    // @notice This function is public so that it can be called independently.\r\n    function handleStateTransitions()\r\n        public\r\n    {\r\n        advanceTimedState();\r\n    }\r\n\r\n    //\r\n    // Implements ICommitment\r\n    //\r\n\r\n    // says if state is final\r\n    function finalized()\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return (_state == ETOState.Refund || _state == ETOState.Payout || _state == ETOState.Claim);\r\n    }\r\n\r\n    // says if state is success\r\n    function success()\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return (_state == ETOState.Claim || _state == ETOState.Payout);\r\n    }\r\n\r\n    // says if state is filure\r\n    function failed()\r\n        public\r\n        constant\r\n        returns (bool)\r\n    {\r\n        return _state == ETOState.Refund;\r\n    }\r\n\r\n    //\r\n    // Implement IETOCommitment\r\n    //\r\n\r\n    function state()\r\n        public\r\n        constant\r\n        returns (ETOState)\r\n    {\r\n        return _state;\r\n    }\r\n\r\n    function startOf(ETOState s)\r\n        public\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        return startOfInternal(s);\r\n    }\r\n\r\n    // returns time induced state which differs from storage state if transition is overdue\r\n    function timedState()\r\n        external\r\n        constant\r\n        returns (ETOState)\r\n    {\r\n        // below we change state but function is constant. the intention is to force this function to be eth_called\r\n        advanceTimedState();\r\n        return _state;\r\n    }\r\n\r\n    function startOfStates()\r\n        public\r\n        constant\r\n        returns (uint256[7] startOfs)\r\n    {\r\n        // 7 is number of states\r\n        for(uint256 ii = 0;ii<ETO_STATES_COUNT;ii += 1) {\r\n            startOfs[ii] = startOfInternal(ETOState(ii));\r\n        }\r\n    }\r\n\r\n    function commitmentObserver() public constant returns (IETOCommitmentObserver) {\r\n        return COMMITMENT_OBSERVER;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    function setupStateMachine(ETODurationTerms durationTerms, IETOCommitmentObserver observer)\r\n        internal\r\n    {\r\n        require(COMMITMENT_OBSERVER == address(0), \"NF_STM_SET_ONCE\");\r\n        require(observer != address(0));\r\n\r\n        COMMITMENT_OBSERVER = observer;\r\n        ETO_STATE_DURATIONS = [\r\n            0, durationTerms.WHITELIST_DURATION(), durationTerms.PUBLIC_DURATION(), durationTerms.SIGNING_DURATION(),\r\n            durationTerms.CLAIM_DURATION(), 0, 0\r\n            ];\r\n    }\r\n\r\n    function runStateMachine(uint32 startDate)\r\n        internal\r\n    {\r\n        // this sets expiration of setup state\r\n        _pastStateTransitionTimes[uint32(ETOState.Setup)] = startDate;\r\n    }\r\n\r\n    function startOfInternal(ETOState s)\r\n        internal\r\n        constant\r\n        returns (uint256)\r\n    {\r\n        // initial state does not have start time\r\n        if (s == ETOState.Setup) {\r\n            return 0;\r\n        }\r\n\r\n        // if timed state machine was not run, the next state will never come\r\n        // if (_pastStateTransitionTimes[uint32(ETOState.Setup)] == 0) {\r\n        //    return 0xFFFFFFFF;\r\n        // }\r\n\r\n        // special case for Refund\r\n        if (s == ETOState.Refund) {\r\n            return _state == s ? _pastStateTransitionTimes[uint32(_state)] : 0;\r\n        }\r\n        // current and previous states: just take s - 1 which is the end of previous state\r\n        if (uint32(s) - 1 <= uint32(_state)) {\r\n            return _pastStateTransitionTimes[uint32(s) - 1];\r\n        }\r\n        // for future states\r\n        uint256 currStateExpiration = _pastStateTransitionTimes[uint32(_state)];\r\n        // this trick gets start of required state by adding all durations between current and required states\r\n        // note that past and current state were handled above so required state is in the future\r\n        // we also rely on terminal states having duration of 0\r\n        for (uint256 stateIdx = uint32(_state) + 1; stateIdx < uint32(s); stateIdx++) {\r\n            currStateExpiration += ETO_STATE_DURATIONS[stateIdx];\r\n        }\r\n        return currStateExpiration;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    // @notice time induced state transitions, called before logic\r\n    // @dev don't use `else if` and keep sorted by time and call `state()`\r\n    //     or else multiple transitions won't cascade properly.\r\n    function advanceTimedState()\r\n        private\r\n    {\r\n        // if timed state machine was not run, the next state will never come\r\n        if (_pastStateTransitionTimes[uint32(ETOState.Setup)] == 0) {\r\n            return;\r\n        }\r\n\r\n        uint256 t = block.timestamp;\r\n        if (_state == ETOState.Setup && t >= startOfInternal(ETOState.Whitelist)) {\r\n            transitionTo(ETOState.Whitelist);\r\n        }\r\n        if (_state == ETOState.Whitelist && t >= startOfInternal(ETOState.Public)) {\r\n            transitionTo(ETOState.Public);\r\n        }\r\n        if (_state == ETOState.Public && t >= startOfInternal(ETOState.Signing)) {\r\n            transitionTo(ETOState.Signing);\r\n        }\r\n        // signing to refund: first we check if it's claim time and if it we go\r\n        // for refund. to go to claim agreement MUST be signed, no time transition\r\n        if (_state == ETOState.Signing && t >= startOfInternal(ETOState.Claim)) {\r\n            transitionTo(ETOState.Refund);\r\n        }\r\n        // claim to payout\r\n        if (_state == ETOState.Claim && t >= startOfInternal(ETOState.Payout)) {\r\n            transitionTo(ETOState.Payout);\r\n        }\r\n    }\r\n\r\n    // @notice transitions due to business logic\r\n    // @dev called after logic\r\n    function advanceLogicState()\r\n        private\r\n    {\r\n        ETOState newState = mAdavanceLogicState(_state);\r\n        if (_state != newState) {\r\n            transitionTo(newState);\r\n            // if we had state transition, we may have another\r\n            advanceLogicState();\r\n        }\r\n    }\r\n\r\n    /// @notice executes transition state function\r\n    function transitionTo(ETOState newState)\r\n        private\r\n    {\r\n        ETOState oldState = _state;\r\n        ETOState effectiveNewState = mBeforeStateTransition(oldState, newState);\r\n        // require(validTransition(oldState, effectiveNewState));\r\n\r\n        _state = effectiveNewState;\r\n        // store deadline for previous state\r\n        uint32 deadline = _pastStateTransitionTimes[uint256(oldState)];\r\n        // if transition came before deadline, count time from timestamp, if after always count from deadline\r\n        if (uint32(block.timestamp) < deadline) {\r\n            deadline = uint32(block.timestamp);\r\n        }\r\n        // we have 60+ years for 2^32 overflow on epoch so disregard\r\n        _pastStateTransitionTimes[uint256(oldState)] = deadline;\r\n        // set deadline on next state\r\n        _pastStateTransitionTimes[uint256(effectiveNewState)] = deadline + ETO_STATE_DURATIONS[uint256(effectiveNewState)];\r\n        // should not change _state\r\n        mAfterTransition(oldState, effectiveNewState);\r\n        assert(_state == effectiveNewState);\r\n        // should notify observer after internal state is settled\r\n        COMMITMENT_OBSERVER.onStateTransition(oldState, effectiveNewState);\r\n        emit LogStateTransition(uint32(oldState), uint32(effectiveNewState), deadline);\r\n    }\r\n\r\n    /*function validTransition(ETOState oldState, ETOState newState)\r\n        private\r\n        pure\r\n        returns (bool valid)\r\n    {\r\n        // TODO: think about disabling it before production deployment\r\n        // (oldState == ETOState.Setup && newState == ETOState.Public) ||\r\n        // (oldState == ETOState.Setup && newState == ETOState.Refund) ||\r\n        return\r\n            (oldState == ETOState.Setup && newState == ETOState.Whitelist) ||\r\n            (oldState == ETOState.Whitelist && newState == ETOState.Public) ||\r\n            (oldState == ETOState.Whitelist && newState == ETOState.Signing) ||\r\n            (oldState == ETOState.Public && newState == ETOState.Signing) ||\r\n            (oldState == ETOState.Public && newState == ETOState.Refund) ||\r\n            (oldState == ETOState.Signing && newState == ETOState.Refund) ||\r\n            (oldState == ETOState.Signing && newState == ETOState.Claim) ||\r\n            (oldState == ETOState.Claim && newState == ETOState.Payout);\r\n    }*/\r\n}\r\n\r\n/// @title represents token offering organized by Company\r\n///  token offering goes through states as defined in ETOTimedStateMachine\r\n///  setup phase requires several parties to provide documents and information\r\n///   (deployment (by anyone) -> eto terms (company) -> RAAA agreement (nominee) -> adding to universe (platform) + issue NEU -> start date (company))\r\n///   price curves, whitelists, discounts and other offer terms are extracted to ETOTerms\r\n/// todo: review all divisions for rounding errors\r\ncontract ETOCommitment is\r\n    AccessControlled,\r\n    Agreement,\r\n    ETOTimedStateMachine,\r\n    Math,\r\n    Serialization,\r\n    IContractId\r\n{\r\n\r\n    ////////////////////////\r\n    // Types\r\n    ////////////////////////\r\n\r\n    /// @notice state of individual investment\r\n    /// @dev mind uint size: allows ticket to occupy two storage slots\r\n    struct InvestmentTicket {\r\n        // euro equivalent of both currencies.\r\n        //  for ether equivalent is generated per ETH/EUR spot price provided by ITokenExchangeRateOracle\r\n        uint96 equivEurUlps;\r\n        // NEU reward issued\r\n        uint96 rewardNmkUlps;\r\n        // Equity Tokens issued, no precision\r\n        uint96 equityTokenInt;\r\n        // total Ether invested\r\n        uint96 amountEth;\r\n        // total Euro invested\r\n        uint96 amountEurUlps;\r\n        // claimed or refunded\r\n        bool claimOrRefundSettled;\r\n        // locked account was used\r\n        bool usedLockedAccount;\r\n        // uint30 reserved // still some bits free\r\n    }\r\n\r\n    ////////////////////////\r\n    // Immutable state\r\n    ////////////////////////\r\n\r\n    // a root of trust contract\r\n    Universe private UNIVERSE;\r\n    // NEU tokens issued as reward for investment\r\n    Neumark private NEUMARK;\r\n    // ether token to store and transfer ether\r\n    IERC223Token private ETHER_TOKEN;\r\n    // euro token to store and transfer euro\r\n    IERC223Token private EURO_TOKEN;\r\n    // allowed icbm investor accounts\r\n    LockedAccount private ETHER_LOCK;\r\n    LockedAccount private EURO_LOCK;\r\n    // equity token issued\r\n    IEquityToken private EQUITY_TOKEN;\r\n    // currency rate oracle\r\n    ITokenExchangeRateOracle private CURRENCY_RATES;\r\n\r\n    // max cap taken from ETOTerms for low gas costs\r\n    uint256 private MIN_NUMBER_OF_TOKENS;\r\n    // min cap taken from ETOTerms for low gas costs\r\n    uint256 private MAX_NUMBER_OF_TOKENS;\r\n    // max cap of tokens in whitelist (without fixed slots)\r\n    uint256 private MAX_NUMBER_OF_TOKENS_IN_WHITELIST;\r\n    // minimum ticket in tokens with base price\r\n    uint256 private MIN_TICKET_TOKENS;\r\n    // platform operator share for low gas costs\r\n    uint128 private PLATFORM_NEUMARK_SHARE;\r\n    // token rate expires after\r\n    uint128 private TOKEN_RATE_EXPIRES_AFTER;\r\n\r\n    // wallet that keeps Platform Operator share of neumarks\r\n    //  and where token participation fee is temporarily stored\r\n    address private PLATFORM_WALLET;\r\n    // company representative address\r\n    address private COMPANY_LEGAL_REPRESENTATIVE;\r\n    // nominee address\r\n    address private NOMINEE;\r\n\r\n    // terms contracts\r\n    ETOTerms private ETO_TERMS;\r\n    // reference to platform terms\r\n    PlatformTerms private PLATFORM_TERMS;\r\n\r\n    ////////////////////////\r\n    // Mutable state\r\n    ////////////////////////\r\n\r\n    // investment tickets\r\n    mapping (address => InvestmentTicket) private _tickets;\r\n\r\n    // data below start at 32 bytes boundary and pack into 32 bytes word\r\n    // total investment in euro equivalent (ETH converted on spot prices)\r\n    uint112 private _totalEquivEurUlps;\r\n\r\n    // total equity tokens acquired\r\n    uint56 private _totalTokensInt;\r\n\r\n    // total equity tokens acquired in fixed slots\r\n    uint56 private _totalFixedSlotsTokensInt;\r\n\r\n    // total investors that participated\r\n    uint32 private _totalInvestors;\r\n\r\n    // nominee investment agreement url confirmation hash\r\n    bytes32 private _nomineeSignedInvestmentAgreementUrlHash;\r\n\r\n    // successful ETO bookeeping\r\n    // amount of new shares generated\r\n    uint96 private _newShares;\r\n    // how many equity tokens goes to platform portfolio as a fee\r\n    uint96 private _tokenParticipationFeeInt;\r\n    // platform fee in eth\r\n    uint96 private _platformFeeEth;\r\n    // platform fee in eur\r\n    uint96 private _platformFeeEurUlps;\r\n    // additonal contribution (investment amount) eth\r\n    uint96 private _additionalContributionEth;\r\n    // additonal contribution (investment amount) eur\r\n    uint96 private _additionalContributionEurUlps;\r\n\r\n    // signed investment agreement url\r\n    string private _signedInvestmentAgreementUrl;\r\n\r\n    ////////////////////////\r\n    // Modifiers\r\n    ////////////////////////\r\n\r\n    modifier onlyCompany() {\r\n        require(msg.sender == COMPANY_LEGAL_REPRESENTATIVE);\r\n        _;\r\n    }\r\n\r\n    modifier onlyNominee() {\r\n        require(msg.sender == NOMINEE);\r\n        _;\r\n    }\r\n\r\n    modifier onlyWithAgreement {\r\n        require(amendmentsCount() > 0);\r\n        _;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Events\r\n    ////////////////////////\r\n\r\n    // logged on claim state transition indicating that additional contribution was released to company\r\n    event LogAdditionalContribution(\r\n        address companyLegalRep,\r\n        address paymentToken,\r\n        uint256 amount\r\n    );\r\n\r\n    // logged on claim state transition indicating NEU reward available\r\n    event LogPlatformNeuReward(\r\n        address platformWallet,\r\n        uint256 totalRewardNmkUlps,\r\n        uint256 platformRewardNmkUlps\r\n    );\r\n\r\n    // logged on payout transition to mark cash payout to NEU holders\r\n    event LogPlatformFeePayout(\r\n        address paymentToken,\r\n        address disbursalPool,\r\n        uint256 amount\r\n    );\r\n\r\n    // logged on payout transition to mark equity token payout to portfolio smart contract\r\n    event LogPlatformPortfolioPayout(\r\n        address assetToken,\r\n        address platformPortfolio,\r\n        uint256 amount\r\n    );\r\n\r\n    ////////////////////////\r\n    // Constructor\r\n    ////////////////////////\r\n\r\n    /// anyone may be a deployer, the platform acknowledges the contract by adding it to Universe Commitment collection\r\n    constructor(\r\n        Universe universe,\r\n        address platformWallet,\r\n        address nominee,\r\n        address companyLegalRep,\r\n        ETOTerms etoTerms,\r\n        IEquityToken equityToken\r\n    )\r\n        Agreement(universe.accessPolicy(), universe.forkArbiter())\r\n        ETOTimedStateMachine()\r\n        public\r\n    {\r\n        UNIVERSE = universe;\r\n        PLATFORM_TERMS = PlatformTerms(universe.platformTerms());\r\n\r\n        require(equityToken.decimals() == etoTerms.TOKEN_TERMS().EQUITY_TOKENS_PRECISION());\r\n        require(platformWallet != address(0) && nominee != address(0) && companyLegalRep != address(0));\r\n        require(etoTerms.requireValidTerms(PLATFORM_TERMS));\r\n\r\n        PLATFORM_WALLET = platformWallet;\r\n        COMPANY_LEGAL_REPRESENTATIVE = companyLegalRep;\r\n        NOMINEE = nominee;\r\n        PLATFORM_NEUMARK_SHARE = uint128(PLATFORM_TERMS.PLATFORM_NEUMARK_SHARE());\r\n        TOKEN_RATE_EXPIRES_AFTER = uint128(PLATFORM_TERMS.TOKEN_RATE_EXPIRES_AFTER());\r\n\r\n        NEUMARK = universe.neumark();\r\n        ETHER_TOKEN = universe.etherToken();\r\n        EURO_TOKEN = universe.euroToken();\r\n        ETHER_LOCK = LockedAccount(universe.etherLock());\r\n        EURO_LOCK = LockedAccount(universe.euroLock());\r\n        CURRENCY_RATES = ITokenExchangeRateOracle(universe.tokenExchangeRateOracle());\r\n\r\n        ETO_TERMS = etoTerms;\r\n        EQUITY_TOKEN = equityToken;\r\n\r\n        MAX_NUMBER_OF_TOKENS = etoTerms.TOKEN_TERMS().MAX_NUMBER_OF_TOKENS();\r\n        MAX_NUMBER_OF_TOKENS_IN_WHITELIST = etoTerms.TOKEN_TERMS().MAX_NUMBER_OF_TOKENS_IN_WHITELIST();\r\n        MIN_NUMBER_OF_TOKENS = etoTerms.TOKEN_TERMS().MIN_NUMBER_OF_TOKENS();\r\n        MIN_TICKET_TOKENS = etoTerms.calculateTokenAmount(0, etoTerms.MIN_TICKET_EUR_ULPS());\r\n\r\n        setupStateMachine(\r\n            ETO_TERMS.DURATION_TERMS(),\r\n            IETOCommitmentObserver(EQUITY_TOKEN.tokenController())\r\n        );\r\n    }\r\n\r\n    ////////////////////////\r\n    // External functions\r\n    ////////////////////////\r\n\r\n    /// @dev sets timed state machine in motion\r\n    function setStartDate(\r\n        ETOTerms etoTerms,\r\n        IEquityToken equityToken,\r\n        uint256 startDate\r\n    )\r\n        external\r\n        onlyCompany\r\n        onlyWithAgreement\r\n        withStateTransition()\r\n        onlyState(ETOState.Setup)\r\n    {\r\n        require(etoTerms == ETO_TERMS);\r\n        require(equityToken == EQUITY_TOKEN);\r\n        assert(startDate < 0xFFFFFFFF);\r\n        // must be more than NNN days (platform terms!)\r\n        require(\r\n            startDate > block.timestamp && startDate - block.timestamp > PLATFORM_TERMS.DATE_TO_WHITELIST_MIN_DURATION(),\r\n            \"NF_ETO_DATE_TOO_EARLY\");\r\n        // prevent re-setting start date if ETO starts too soon\r\n        uint256 startAt = startOfInternal(ETOState.Whitelist);\r\n        // block.timestamp must be less than startAt, otherwise timed state transition is done\r\n        require(\r\n            startAt == 0 || (startAt - block.timestamp > PLATFORM_TERMS.DATE_TO_WHITELIST_MIN_DURATION()),\r\n            \"NF_ETO_START_TOO_SOON\");\r\n        runStateMachine(uint32(startDate));\r\n        // todo: lock ETO_TERMS whitelist to be more trustless\r\n\r\n        emit LogTermsSet(msg.sender, address(etoTerms), address(equityToken));\r\n        emit LogETOStartDateSet(msg.sender, startAt, startDate);\r\n    }\r\n\r\n    function companySignsInvestmentAgreement(string signedInvestmentAgreementUrl)\r\n        public\r\n        withStateTransition()\r\n        onlyState(ETOState.Signing)\r\n        onlyCompany\r\n    {\r\n        _signedInvestmentAgreementUrl = signedInvestmentAgreementUrl;\r\n        emit LogCompanySignedAgreement(msg.sender, NOMINEE, signedInvestmentAgreementUrl);\r\n    }\r\n\r\n    function nomineeConfirmsInvestmentAgreement(string signedInvestmentAgreementUrl)\r\n        public\r\n        withStateTransition()\r\n        onlyState(ETOState.Signing)\r\n        onlyNominee\r\n    {\r\n        bytes32 nomineeHash = keccak256(abi.encodePacked(signedInvestmentAgreementUrl));\r\n        require(keccak256(abi.encodePacked(_signedInvestmentAgreementUrl)) == nomineeHash, \"NF_INV_HASH\");\r\n        // setting this variable will induce state transition to Claim via mAdavanceLogicState\r\n        _nomineeSignedInvestmentAgreementUrlHash = nomineeHash;\r\n        emit LogNomineeConfirmedAgreement(msg.sender, COMPANY_LEGAL_REPRESENTATIVE, signedInvestmentAgreementUrl);\r\n    }\r\n\r\n    //\r\n    // Implements ICommitment\r\n    //\r\n\r\n    /// commit function happens via ERC223 callback that must happen from trusted payment token\r\n    /// @dev data in case of LockedAccount contains investor address and investor is LockedAccount address\r\n    function tokenFallback(address wallet, uint256 amount, bytes data)\r\n        public\r\n        withStateTransition()\r\n        onlyStates(ETOState.Whitelist, ETOState.Public)\r\n    {\r\n        uint256 equivEurUlps = amount;\r\n        bool isEuroInvestment = msg.sender == address(EURO_TOKEN);\r\n        bool isEtherInvestment = msg.sender == address(ETHER_TOKEN);\r\n        // we trust only tokens below\r\n        require(isEtherInvestment || isEuroInvestment, \"NF_ETO_UNK_TOKEN\");\r\n        // check if LockedAccount\r\n        bool isLockedAccount = (wallet == address(ETHER_LOCK) || wallet == address(EURO_LOCK));\r\n        address investor = wallet;\r\n        if (isLockedAccount) {\r\n            // data contains investor address\r\n            investor = decodeAddress(data);\r\n        }\r\n        if (isEtherInvestment) {\r\n            // compute EUR eurEquivalent via oracle if ether\r\n            (uint256 rate, uint256 rateTimestamp) = CURRENCY_RATES.getExchangeRate(ETHER_TOKEN, EURO_TOKEN);\r\n            // require if rate older than 4 hours\r\n            require(block.timestamp - rateTimestamp < TOKEN_RATE_EXPIRES_AFTER, \"NF_ETO_INVALID_ETH_RATE\");\r\n            equivEurUlps = decimalFraction(amount, rate);\r\n        }\r\n        // agreement accepted by act of reserving funds in this function\r\n        acceptAgreementInternal(investor);\r\n        // we modify state and emit events in function below\r\n        processTicket(investor, wallet, amount, equivEurUlps, isEuroInvestment);\r\n    }\r\n\r\n    //\r\n    // Implements IETOCommitment\r\n    //\r\n\r\n    function claim()\r\n        external\r\n        withStateTransition()\r\n        onlyStates(ETOState.Claim, ETOState.Payout)\r\n\r\n    {\r\n        claimTokensPrivate(msg.sender);\r\n    }\r\n\r\n    function claimMany(address[] investors)\r\n        external\r\n        withStateTransition()\r\n        onlyStates(ETOState.Claim, ETOState.Payout)\r\n    {\r\n        for(uint256 ii = 0; ii < investors.length; ii++) {\r\n            claimTokensPrivate(investors[ii]);\r\n        }\r\n    }\r\n\r\n    function refund()\r\n        external\r\n        withStateTransition()\r\n        onlyState(ETOState.Refund)\r\n\r\n    {\r\n        refundTokensPrivate(msg.sender);\r\n    }\r\n\r\n    function refundMany(address[] investors)\r\n        external\r\n        withStateTransition()\r\n        onlyState(ETOState.Refund)\r\n    {\r\n        for(uint256 ii = 0; ii < investors.length; ii++) {\r\n            refundTokensPrivate(investors[ii]);\r\n        }\r\n    }\r\n\r\n    function payout()\r\n        external\r\n        withStateTransition()\r\n        onlyState(ETOState.Payout)\r\n    {\r\n        // does nothing - all hapens in state transition\r\n    }\r\n\r\n    //\r\n    // Getters\r\n    //\r\n\r\n    //\r\n    // IETOCommitment getters\r\n    //\r\n\r\n    function signedInvestmentAgreementUrl()\r\n        public\r\n        constant\r\n        returns (string)\r\n    {\r\n        return _signedInvestmentAgreementUrl;\r\n    }\r\n\r\n    function contributionSummary()\r\n        public\r\n        constant\r\n        returns (\r\n            uint256 newShares, uint256 capitalIncreaseEurUlps,\r\n            uint256 additionalContributionEth, uint256 additionalContributionEurUlps,\r\n            uint256 tokenParticipationFeeInt, uint256 platformFeeEth, uint256 platformFeeEurUlps,\r\n            uint256 sharePriceEurUlps\r\n        )\r\n    {\r\n        return (\r\n            _newShares, _newShares * EQUITY_TOKEN.shareNominalValueEurUlps(),\r\n            _additionalContributionEth, _additionalContributionEurUlps,\r\n            _tokenParticipationFeeInt, _platformFeeEth, _platformFeeEurUlps,\r\n            _newShares == 0 ? 0 : divRound(_totalEquivEurUlps, _newShares)\r\n        );\r\n    }\r\n\r\n    function etoTerms() public constant returns (ETOTerms) {\r\n        return ETO_TERMS;\r\n    }\r\n\r\n    function equityToken() public constant returns (IEquityToken) {\r\n        return EQUITY_TOKEN;\r\n    }\r\n\r\n    function nominee() public constant returns (address) {\r\n        return NOMINEE;\r\n    }\r\n\r\n    function companyLegalRep() public constant returns (address) {\r\n        return COMPANY_LEGAL_REPRESENTATIVE;\r\n    }\r\n\r\n    function singletons()\r\n        public\r\n        constant\r\n        returns (\r\n            address platformWallet,\r\n            address universe,\r\n            address platformTerms\r\n            )\r\n    {\r\n        platformWallet = PLATFORM_WALLET;\r\n        universe = UNIVERSE;\r\n        platformTerms = PLATFORM_TERMS;\r\n    }\r\n\r\n    function totalInvestment()\r\n        public\r\n        constant\r\n        returns (\r\n            uint256 totalEquivEurUlps,\r\n            uint256 totalTokensInt,\r\n            uint256 totalInvestors\r\n            )\r\n    {\r\n        return (_totalEquivEurUlps, _totalTokensInt, _totalInvestors);\r\n    }\r\n\r\n    function calculateContribution(address investor, bool fromIcbmWallet, uint256 newInvestorContributionEurUlps)\r\n        external\r\n        constant\r\n        // use timed state so we show what should be\r\n        withStateTransition()\r\n        returns (\r\n            bool isWhitelisted,\r\n            bool isEligible,\r\n            uint256 minTicketEurUlps,\r\n            uint256 maxTicketEurUlps,\r\n            uint256 equityTokenInt,\r\n            uint256 neuRewardUlps,\r\n            bool maxCapExceeded\r\n            )\r\n    {\r\n        InvestmentTicket storage ticket = _tickets[investor];\r\n        // we use state() here because time was forwarded by withStateTransition\r\n        bool applyDiscounts = state() == ETOState.Whitelist;\r\n        uint256 fixedSlotsEquityTokenInt;\r\n        (\r\n            isWhitelisted,\r\n            isEligible,\r\n            minTicketEurUlps,\r\n            maxTicketEurUlps,\r\n            equityTokenInt,\r\n            fixedSlotsEquityTokenInt\r\n        ) = ETO_TERMS.calculateContribution(\r\n            investor,\r\n            _totalEquivEurUlps,\r\n            ticket.equivEurUlps,\r\n            newInvestorContributionEurUlps,\r\n            applyDiscounts\r\n        );\r\n        isWhitelisted = isWhitelisted || fromIcbmWallet;\r\n        if (!fromIcbmWallet) {\r\n            (,neuRewardUlps) = calculateNeumarkDistribution(NEUMARK.incremental(newInvestorContributionEurUlps));\r\n        }\r\n        // crossing max cap can always happen\r\n        maxCapExceeded = isCapExceeded(applyDiscounts, equityTokenInt, fixedSlotsEquityTokenInt);\r\n    }\r\n\r\n    function investorTicket(address investor)\r\n        public\r\n        constant\r\n        returns (\r\n            uint256 equivEurUlps,\r\n            uint256 rewardNmkUlps,\r\n            uint256 equityTokenInt,\r\n            uint256 sharesInt,\r\n            uint256 tokenPrice,\r\n            uint256 neuRate,\r\n            uint256 amountEth,\r\n            uint256 amountEurUlps,\r\n            bool claimedOrRefunded,\r\n            bool usedLockedAccount\r\n        )\r\n    {\r\n        InvestmentTicket storage ticket = _tickets[investor];\r\n        // here we assume that equity token precisions is 0\r\n        equivEurUlps = ticket.equivEurUlps;\r\n        rewardNmkUlps = ticket.rewardNmkUlps;\r\n        equityTokenInt = ticket.equityTokenInt;\r\n        sharesInt = ETO_TERMS.equityTokensToShares(ticket.equityTokenInt);\r\n        tokenPrice = equityTokenInt > 0 ? equivEurUlps / equityTokenInt : 0;\r\n        neuRate = rewardNmkUlps > 0 ? proportion(equivEurUlps, 10**18, rewardNmkUlps) : 0;\r\n        amountEth = ticket.amountEth;\r\n        amountEurUlps = ticket.amountEurUlps;\r\n        claimedOrRefunded = ticket.claimOrRefundSettled;\r\n        usedLockedAccount = ticket.usedLockedAccount;\r\n    }\r\n\r\n    //\r\n    // Implements IContractId\r\n    //\r\n\r\n    function contractId() public pure returns (bytes32 id, uint256 version) {\r\n        return (0x70ef68fc8c585f9edc7af1bfac26c4b1b9e98ba05cf5ddd99e4b3dc46ea70073, 0);\r\n    }\r\n\r\n    ////////////////////////\r\n    // Internal functions\r\n    ////////////////////////\r\n\r\n    //\r\n    // Overrides internal interface\r\n    //\r\n\r\n    function mAdavanceLogicState(ETOState oldState)\r\n        internal\r\n        constant\r\n        returns (ETOState)\r\n    {\r\n        // add 1 to MIN_TICKET_TOKEN because it was produced by floor and check only MAX CAP\r\n        // WHITELIST CAP will not induce state transition as fixed slots should be able to invest till the end of Whitelist\r\n        bool capExceeded = isCapExceeded(false, MIN_TICKET_TOKENS + 1, 0);\r\n        if (capExceeded) {\r\n            if (oldState == ETOState.Whitelist) {\r\n                return ETOState.Public;\r\n            }\r\n            if (oldState == ETOState.Public) {\r\n                return ETOState.Signing;\r\n            }\r\n        }\r\n        if (oldState == ETOState.Signing && _nomineeSignedInvestmentAgreementUrlHash != bytes32(0)) {\r\n            return ETOState.Claim;\r\n        }\r\n        return oldState;\r\n    }\r\n\r\n    function mBeforeStateTransition(ETOState /*oldState*/, ETOState newState)\r\n        internal\r\n        constant\r\n        returns (ETOState)\r\n    {\r\n        // force refund if floor criteria are not met\r\n        // todo: allow for super edge case when MIN_NUMBER_OF_TOKENS is very close to MAX_NUMBER_OF_TOKENS and we are within minimum ticket\r\n        if (newState == ETOState.Signing && _totalTokensInt < MIN_NUMBER_OF_TOKENS) {\r\n            return ETOState.Refund;\r\n        }\r\n        // go to refund if attempt to go to Claim without nominee agreement confirmation\r\n        // if (newState == ETOState.Claim && _nomineeSignedInvestmentAgreementUrlHash == bytes32(0)) {\r\n        //     return ETOState.Refund;\r\n        // }\r\n\r\n        return newState;\r\n    }\r\n\r\n    function mAfterTransition(ETOState /*oldState*/, ETOState newState)\r\n        internal\r\n    {\r\n        if (newState == ETOState.Signing) {\r\n            onSigningTransition();\r\n        }\r\n        if (newState == ETOState.Claim) {\r\n            onClaimTransition();\r\n        }\r\n        if (newState == ETOState.Refund) {\r\n            onRefundTransition();\r\n        }\r\n        if (newState == ETOState.Payout) {\r\n            onPayoutTransition();\r\n        }\r\n    }\r\n\r\n    //\r\n    // Overrides Agreement internal interface\r\n    //\r\n\r\n    function mCanAmend(address legalRepresentative)\r\n        internal\r\n        returns (bool)\r\n    {\r\n        return legalRepresentative == NOMINEE && startOfInternal(ETOState.Whitelist) == 0;\r\n    }\r\n\r\n    ////////////////////////\r\n    // Private functions\r\n    ////////////////////////\r\n\r\n    // a copy of PlatformTerms working on local storage\r\n    function calculateNeumarkDistribution(uint256 rewardNmk)\r\n        private\r\n        constant\r\n        returns (uint256 platformNmk, uint256 investorNmk)\r\n    {\r\n        // round down - platform may get 1 wei less than investor\r\n        platformNmk = rewardNmk / PLATFORM_NEUMARK_SHARE;\r\n        // rewardNmk > platformNmk always\r\n        return (platformNmk, rewardNmk - platformNmk);\r\n    }\r\n\r\n    /// called on transition to Signing\r\n    function onSigningTransition()\r\n        private\r\n    {\r\n        // get final balances\r\n        uint256 etherBalance = ETHER_TOKEN.balanceOf(this);\r\n        uint256 euroBalance = EURO_TOKEN.balanceOf(this);\r\n        // additional equity tokens are issued and sent to platform operator (temporarily)\r\n        uint256 tokensPerShare = EQUITY_TOKEN.tokensPerShare();\r\n        uint256 tokenParticipationFeeInt = PLATFORM_TERMS.calculatePlatformTokenFee(_totalTokensInt);\r\n        // we must have integer number of shares\r\n        uint256 tokensRemainder = (_totalTokensInt + tokenParticipationFeeInt) % tokensPerShare;\r\n        if (tokensRemainder > 0) {\r\n            // round up to whole share\r\n            tokenParticipationFeeInt += tokensPerShare - tokensRemainder;\r\n        }\r\n        // assert 96bit values 2**96 / 10**18 ~ 78 bln\r\n        assert(_totalTokensInt + tokenParticipationFeeInt < 2 ** 96);\r\n        assert(etherBalance < 2 ** 96 && euroBalance < 2 ** 96);\r\n        // we save 30k gas on 96 bit resolution, we can live with 98 bln euro max investment amount\r\n        _newShares = uint96((_totalTokensInt + tokenParticipationFeeInt) / tokensPerShare);\r\n        // preserve platform token participation fee to be send out on claim transition\r\n        _tokenParticipationFeeInt = uint96(tokenParticipationFeeInt);\r\n        // compute fees to be sent on payout transition\r\n        _platformFeeEth = uint96(PLATFORM_TERMS.calculatePlatformFee(etherBalance));\r\n        _platformFeeEurUlps = uint96(PLATFORM_TERMS.calculatePlatformFee(euroBalance));\r\n        // compute additional contributions to be sent on claim transition\r\n        _additionalContributionEth = uint96(etherBalance) - _platformFeeEth;\r\n        _additionalContributionEurUlps = uint96(euroBalance) - _platformFeeEurUlps;\r\n        // nominee gets nominal share value immediately to be added to cap table\r\n        uint256 capitalIncreaseEurUlps = EQUITY_TOKEN.shareNominalValueEurUlps() * _newShares;\r\n        // limit the amount if balance on EURO_TOKEN < capitalIncreaseEurUlps. in that case Nomine must handle it offchain\r\n        // no overflow as smaller one is uint96\r\n        uint96 availableCapitalEurUlps = uint96(min(capitalIncreaseEurUlps, _additionalContributionEurUlps));\r\n        assert(EURO_TOKEN.transfer(NOMINEE, availableCapitalEurUlps, \"\"));\r\n        // decrease additional contribution by value that was sent to nominee\r\n        _additionalContributionEurUlps -= availableCapitalEurUlps;\r\n\r\n        emit LogSigningStarted(NOMINEE, COMPANY_LEGAL_REPRESENTATIVE, _newShares, capitalIncreaseEurUlps);\r\n    }\r\n\r\n    /// called on transition to ETOState.Claim\r\n    function onClaimTransition()\r\n        private\r\n    {\r\n        // platform operator gets share of NEU\r\n        uint256 rewardNmk = NEUMARK.balanceOf(this);\r\n        (uint256 platformNmk,) = calculateNeumarkDistribution(rewardNmk);\r\n        assert(NEUMARK.transfer(PLATFORM_WALLET, platformNmk, \"\"));\r\n        // company legal rep receives funds\r\n        if (_additionalContributionEth > 0) {\r\n            assert(ETHER_TOKEN.transfer(COMPANY_LEGAL_REPRESENTATIVE, _additionalContributionEth, \"\"));\r\n        }\r\n\r\n        if (_additionalContributionEurUlps > 0) {\r\n            assert(EURO_TOKEN.transfer(COMPANY_LEGAL_REPRESENTATIVE, _additionalContributionEurUlps, \"\"));\r\n        }\r\n        // issue missing tokens\r\n        EQUITY_TOKEN.issueTokens(_tokenParticipationFeeInt);\r\n        emit LogPlatformNeuReward(PLATFORM_WALLET, rewardNmk, platformNmk);\r\n        emit LogAdditionalContribution(COMPANY_LEGAL_REPRESENTATIVE, ETHER_TOKEN, _additionalContributionEth);\r\n        emit LogAdditionalContribution(COMPANY_LEGAL_REPRESENTATIVE, EURO_TOKEN, _additionalContributionEurUlps);\r\n    }\r\n\r\n    /// called on transtion to ETOState.Refund\r\n    function onRefundTransition()\r\n        private\r\n    {\r\n        // burn all neumark generated in this ETO\r\n        uint256 balanceNmk = NEUMARK.balanceOf(this);\r\n        uint256 balanceTokenInt = EQUITY_TOKEN.balanceOf(this);\r\n        if (balanceNmk > 0) {\r\n            NEUMARK.burn(balanceNmk);\r\n        }\r\n        // destroy all tokens generated in ETO\r\n        if (balanceTokenInt > 0) {\r\n            EQUITY_TOKEN.destroyTokens(balanceTokenInt);\r\n        }\r\n        emit LogRefundStarted(EQUITY_TOKEN, balanceTokenInt, balanceNmk);\r\n    }\r\n\r\n    /// called on transition to ETOState.Payout\r\n    function onPayoutTransition()\r\n        private\r\n    {\r\n        // distribute what's left in balances: company took funds on claim\r\n        address disbursal = UNIVERSE.feeDisbursal();\r\n        assert(disbursal != address(0));\r\n        address platformPortfolio = UNIVERSE.platformPortfolio();\r\n        assert(platformPortfolio != address(0));\r\n        bytes memory serializedAddress = abi.encodePacked(address(NEUMARK));\r\n        // assert(decodeAddress(serializedAddress) == address(NEUMARK));\r\n        if (_platformFeeEth > 0) {\r\n            // disburse via ERC223, where we encode token used to provide pro-rata in `data` parameter\r\n            assert(ETHER_TOKEN.transfer(disbursal, _platformFeeEth, serializedAddress));\r\n        }\r\n        if (_platformFeeEurUlps > 0) {\r\n            // disburse via ERC223\r\n            assert(EURO_TOKEN.transfer(disbursal, _platformFeeEurUlps, serializedAddress));\r\n        }\r\n        // add token participation fee to platfrom portfolio\r\n        EQUITY_TOKEN.distributeTokens(platformPortfolio, _tokenParticipationFeeInt);\r\n\r\n        emit LogPlatformFeePayout(ETHER_TOKEN, disbursal, _platformFeeEth);\r\n        emit LogPlatformFeePayout(EURO_TOKEN, disbursal, _platformFeeEurUlps);\r\n        emit LogPlatformPortfolioPayout(EQUITY_TOKEN, platformPortfolio, _tokenParticipationFeeInt);\r\n    }\r\n\r\n    function processTicket(\r\n        address investor,\r\n        address wallet,\r\n        uint256 amount,\r\n        uint256 equivEurUlps,\r\n        bool isEuroInvestment\r\n    )\r\n        private\r\n    {\r\n        // read current ticket\r\n        InvestmentTicket storage ticket = _tickets[investor];\r\n        // should we apply whitelist discounts\r\n        bool applyDiscounts = state() == ETOState.Whitelist;\r\n        // calculate contribution\r\n        (\r\n            bool isWhitelisted,\r\n            bool isEligible,\r\n            uint minTicketEurUlps,\r\n            uint256 maxTicketEurUlps,\r\n            uint256 equityTokenInt256,\r\n            uint256 fixedSlotEquityTokenInt256\r\n        ) = ETO_TERMS.calculateContribution(investor, _totalEquivEurUlps, ticket.equivEurUlps, equivEurUlps, applyDiscounts);\r\n        // kick out on KYC\r\n        require(isEligible, \"NF_ETO_INV_NOT_VER\");\r\n        assert(equityTokenInt256 < 2 ** 32 && fixedSlotEquityTokenInt256 < 2 ** 32);\r\n        // kick on minimum ticket and you must buy at least one token!\r\n        require(equivEurUlps + ticket.equivEurUlps >= minTicketEurUlps && equityTokenInt256 > 0, \"NF_ETO_MIN_TICKET\");\r\n        // kick on max ticket exceeded\r\n        require(equivEurUlps + ticket.equivEurUlps <= maxTicketEurUlps, \"NF_ETO_MAX_TICKET\");\r\n        // kick on cap exceeded\r\n        require(!isCapExceeded(applyDiscounts, equityTokenInt256, fixedSlotEquityTokenInt256), \"NF_ETO_MAX_TOK_CAP\");\r\n        // when that sent money is not the same as investor it must be icbm locked wallet\r\n        // bool isLockedAccount = wallet != investor;\r\n        // kick out not whitelist or not LockedAccount\r\n        if (applyDiscounts) {\r\n            require(isWhitelisted || wallet != investor, \"NF_ETO_NOT_ON_WL\");\r\n        }\r\n        // we trust NEU token so we issue NEU before writing state\r\n        // issue only for \"new money\" so LockedAccount from ICBM is excluded\r\n        if (wallet == investor) {\r\n            (, uint256 investorNmk) = calculateNeumarkDistribution(NEUMARK.issueForEuro(equivEurUlps));\r\n            if (investorNmk > 0) {\r\n                // now there is rounding danger as we calculate the above for any investor but then just once to get platform share in onClaimTransition\r\n                // it is much cheaper to just round down than to book keep to a single wei which will use additional storage\r\n                // small amount of NEU ( no of investors * (PLATFORM_NEUMARK_SHARE-1)) may be left in contract\r\n                assert(investorNmk > PLATFORM_NEUMARK_SHARE - 1);\r\n                investorNmk -= PLATFORM_NEUMARK_SHARE - 1;\r\n            }\r\n        }\r\n        // issue equity token\r\n        assert(equityTokenInt256 + ticket.equityTokenInt < 2**32);\r\n        // this will also check ticket.amountEurUlps + uint96(amount) as ticket.equivEurUlps is always >= ticket.amountEurUlps\r\n        assert(equivEurUlps + ticket.equivEurUlps < 2**96);\r\n        assert(amount < 2**96);\r\n        // practically impossible: would require price of ETH smaller than 1 EUR and > 2**96 amount of ether\r\n        assert(uint256(ticket.amountEth) + amount < 2**96);\r\n        EQUITY_TOKEN.issueTokens(uint32(equityTokenInt256));\r\n        // update total investment\r\n        _totalEquivEurUlps += uint96(equivEurUlps);\r\n        _totalTokensInt += uint32(equityTokenInt256);\r\n        _totalFixedSlotsTokensInt += uint32(fixedSlotEquityTokenInt256);\r\n        _totalInvestors += ticket.equivEurUlps == 0 ? 1 : 0;\r\n        // write new ticket values\r\n        ticket.equivEurUlps += uint96(equivEurUlps);\r\n        // uint96 is much more than 1.5 bln of NEU so no overflow\r\n        ticket.rewardNmkUlps += uint96(investorNmk);\r\n        ticket.equityTokenInt += uint32(equityTokenInt256);\r\n        if (isEuroInvestment) {\r\n            ticket.amountEurUlps += uint96(amount);\r\n        } else {\r\n            ticket.amountEth += uint96(amount);\r\n        }\r\n        ticket.usedLockedAccount = ticket.usedLockedAccount || wallet != investor;\r\n        // log successful commitment\r\n        emit LogFundsCommitted(\r\n            investor,\r\n            wallet,\r\n            msg.sender,\r\n            amount,\r\n            equivEurUlps,\r\n            equityTokenInt256,\r\n            EQUITY_TOKEN,\r\n            investorNmk\r\n        );\r\n    }\r\n\r\n    function isCapExceeded(bool applyDiscounts, uint256 equityTokenInt, uint256 fixedSlotsEquityTokenInt)\r\n        private\r\n        constant\r\n        returns (bool maxCapExceeded)\r\n    {\r\n        maxCapExceeded = _totalTokensInt + equityTokenInt > MAX_NUMBER_OF_TOKENS;\r\n        if (applyDiscounts && !maxCapExceeded) {\r\n            maxCapExceeded = _totalTokensInt + equityTokenInt - _totalFixedSlotsTokensInt - fixedSlotsEquityTokenInt > MAX_NUMBER_OF_TOKENS_IN_WHITELIST;\r\n        }\r\n    }\r\n\r\n    function claimTokensPrivate(address investor)\r\n        private\r\n    {\r\n        InvestmentTicket storage ticket = _tickets[investor];\r\n        if (ticket.claimOrRefundSettled) {\r\n            return;\r\n        }\r\n        if (ticket.equivEurUlps == 0) {\r\n            return;\r\n        }\r\n        ticket.claimOrRefundSettled = true;\r\n\r\n        if (ticket.rewardNmkUlps > 0) {\r\n            NEUMARK.distribute(investor, ticket.rewardNmkUlps);\r\n        }\r\n        if (ticket.equityTokenInt > 0) {\r\n            EQUITY_TOKEN.distributeTokens(investor, ticket.equityTokenInt);\r\n        }\r\n        if (ticket.usedLockedAccount) {\r\n            ETHER_LOCK.claimed(investor);\r\n            EURO_LOCK.claimed(investor);\r\n        }\r\n        emit LogTokensClaimed(investor, EQUITY_TOKEN, ticket.equityTokenInt, ticket.rewardNmkUlps);\r\n    }\r\n\r\n    function refundTokensPrivate(address investor)\r\n        private\r\n    {\r\n        InvestmentTicket storage ticket = _tickets[investor];\r\n        if (ticket.claimOrRefundSettled) {\r\n            return;\r\n        }\r\n        if (ticket.equivEurUlps == 0) {\r\n            return;\r\n        }\r\n        ticket.claimOrRefundSettled = true;\r\n        refundSingleToken(investor, ticket.amountEth, ticket.usedLockedAccount, ETHER_LOCK, ETHER_TOKEN);\r\n        refundSingleToken(investor, ticket.amountEurUlps, ticket.usedLockedAccount, EURO_LOCK, EURO_TOKEN);\r\n\r\n        emit LogFundsRefunded(investor, ETHER_TOKEN, ticket.amountEth);\r\n        emit LogFundsRefunded(investor, EURO_TOKEN, ticket.amountEurUlps);\r\n    }\r\n\r\n    function refundSingleToken(\r\n        address investor,\r\n        uint256 amount,\r\n        bool usedLockedAccount,\r\n        LockedAccount lockedAccount,\r\n        IERC223Token token\r\n    )\r\n        private\r\n    {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        uint256 a = amount;\r\n        // possible partial refund to locked account\r\n        if (usedLockedAccount) {\r\n            (uint256 balance,) = lockedAccount.pendingCommitments(this, investor);\r\n            assert(balance <= a);\r\n            if (balance > 0) {\r\n                assert(token.approve(address(lockedAccount), balance));\r\n                lockedAccount.refunded(investor);\r\n                a -= balance;\r\n            }\r\n        }\r\n        if (a > 0) {\r\n            assert(token.transfer(investor, a, \"\"));\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"timedState\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"success\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signedInvestmentAgreementUrl\",\"type\":\"string\"}],\"name\":\"companySignsInvestmentAgreement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestment\",\"outputs\":[{\"name\":\"totalEquivEurUlps\",\"type\":\"uint256\"},{\"name\":\"totalTokensInt\",\"type\":\"uint256\"},{\"name\":\"totalInvestors\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"startOfStates\",\"outputs\":[{\"name\":\"startOfs\",\"type\":\"uint256[7]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nominee\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etoTerms\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commitmentObserver\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contributionSummary\",\"outputs\":[{\"name\":\"newShares\",\"type\":\"uint256\"},{\"name\":\"capitalIncreaseEurUlps\",\"type\":\"uint256\"},{\"name\":\"additionalContributionEth\",\"type\":\"uint256\"},{\"name\":\"additionalContributionEurUlps\",\"type\":\"uint256\"},{\"name\":\"tokenParticipationFeeInt\",\"type\":\"uint256\"},{\"name\":\"platformFeeEth\",\"type\":\"uint256\"},{\"name\":\"platformFeeEurUlps\",\"type\":\"uint256\"},{\"name\":\"sharePriceEurUlps\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newPolicy\",\"type\":\"address\"},{\"name\":\"newAccessController\",\"type\":\"address\"}],\"name\":\"setAccessPolicy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"etoTerms\",\"type\":\"address\"},{\"name\":\"equityToken\",\"type\":\"address\"},{\"name\":\"startDate\",\"type\":\"uint256\"}],\"name\":\"setStartDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signedInvestmentAgreementUrl\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"signatory\",\"type\":\"address\"}],\"name\":\"agreementSignedAtBlock\",\"outputs\":[{\"name\":\"blockNo\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amendmentsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investors\",\"type\":\"address[]\"}],\"name\":\"claimMany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractId\",\"outputs\":[{\"name\":\"id\",\"type\":\"bytes32\"},{\"name\":\"version\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"singletons\",\"outputs\":[{\"name\":\"platformWallet\",\"type\":\"address\"},{\"name\":\"universe\",\"type\":\"address\"},{\"name\":\"platformTerms\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"amendmentIndex\",\"type\":\"uint256\"}],\"name\":\"pastAgreement\",\"outputs\":[{\"name\":\"contractLegalRepresentative\",\"type\":\"address\"},{\"name\":\"signedBlockTimestamp\",\"type\":\"uint256\"},{\"name\":\"agreementUri\",\"type\":\"string\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"s\",\"type\":\"uint8\"}],\"name\":\"startOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"finalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"}],\"name\":\"investorTicket\",\"outputs\":[{\"name\":\"equivEurUlps\",\"type\":\"uint256\"},{\"name\":\"rewardNmkUlps\",\"type\":\"uint256\"},{\"name\":\"equityTokenInt\",\"type\":\"uint256\"},{\"name\":\"sharesInt\",\"type\":\"uint256\"},{\"name\":\"tokenPrice\",\"type\":\"uint256\"},{\"name\":\"neuRate\",\"type\":\"uint256\"},{\"name\":\"amountEth\",\"type\":\"uint256\"},{\"name\":\"amountEurUlps\",\"type\":\"uint256\"},{\"name\":\"claimedOrRefunded\",\"type\":\"bool\"},{\"name\":\"usedLockedAccount\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"failed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"equityToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentAgreement\",\"outputs\":[{\"name\":\"contractLegalRepresentative\",\"type\":\"address\"},{\"name\":\"signedBlockTimestamp\",\"type\":\"uint256\"},{\"name\":\"agreementUri\",\"type\":\"string\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"investors\",\"type\":\"address[]\"}],\"name\":\"refundMany\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"fromIcbmWallet\",\"type\":\"bool\"},{\"name\":\"newInvestorContributionEurUlps\",\"type\":\"uint256\"}],\"name\":\"calculateContribution\",\"outputs\":[{\"name\":\"isWhitelisted\",\"type\":\"bool\"},{\"name\":\"isEligible\",\"type\":\"bool\"},{\"name\":\"minTicketEurUlps\",\"type\":\"uint256\"},{\"name\":\"maxTicketEurUlps\",\"type\":\"uint256\"},{\"name\":\"equityTokenInt\",\"type\":\"uint256\"},{\"name\":\"neuRewardUlps\",\"type\":\"uint256\"},{\"name\":\"maxCapExceeded\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethereumForkArbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agreementUri\",\"type\":\"string\"}],\"name\":\"amendAgreement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"accessPolicy\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"handleStateTransitions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"signedInvestmentAgreementUrl\",\"type\":\"string\"}],\"name\":\"nomineeConfirmsInvestmentAgreement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"companyLegalRep\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"universe\",\"type\":\"address\"},{\"name\":\"platformWallet\",\"type\":\"address\"},{\"name\":\"nominee\",\"type\":\"address\"},{\"name\":\"companyLegalRep\",\"type\":\"address\"},{\"name\":\"etoTerms\",\"type\":\"address\"},{\"name\":\"equityToken\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyLegalRep\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAdditionalContribution\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"platformWallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalRewardNmkUlps\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"platformRewardNmkUlps\",\"type\":\"uint256\"}],\"name\":\"LogPlatformNeuReward\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"disbursalPool\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogPlatformFeePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"platformPortfolio\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogPlatformPortfolioPayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldState\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"newState\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint32\"}],\"name\":\"LogStateTransition\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"assetToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"nmkReward\",\"type\":\"uint256\"}],\"name\":\"LogTokensClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogFundsRefunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyLegalRep\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"etoTerms\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"equityToken\",\"type\":\"address\"}],\"name\":\"LogTermsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyLegalRep\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"previousTimestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newTimestamp\",\"type\":\"uint256\"}],\"name\":\"LogETOStartDateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nominee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"companyLegalRep\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newShares\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"capitalIncreaseEurUlps\",\"type\":\"uint256\"}],\"name\":\"LogSigningStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"companyLegalRep\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"nominee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"signedInvestmentAgreementUrl\",\"type\":\"string\"}],\"name\":\"LogCompanySignedAgreement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nominee\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"companyLegalRep\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"signedInvestmentAgreementUrl\",\"type\":\"string\"}],\"name\":\"LogNomineeConfirmedAgreement\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"assetToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"totalTokenAmountInt\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalRewardNmkUlps\",\"type\":\"uint256\"}],\"name\":\"LogRefundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"paymentToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"baseCurrencyEquivalent\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"grantedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"assetToken\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"neuReward\",\"type\":\"uint256\"}],\"name\":\"LogFundsCommitted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"controller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldPolicy\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newPolicy\",\"type\":\"address\"}],\"name\":\"LogAccessPolicyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"accepter\",\"type\":\"address\"}],\"name\":\"LogAgreementAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contractLegalRepresentative\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"agreementUri\",\"type\":\"string\"}],\"name\":\"LogAgreementAmended\",\"type\":\"event\"}]","ContractName":"ETOCommitment","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000082fb5126506b6c315fa4a7ae3d4cb8a46a1aae67000000000000000000000000a826813d0eb5d629e959c02b8f7a3d0f53066ce40000000000000000000000006c4b76db2b38a6cae6bad649a547f5616b7a718b000000000000000000000000304206eb582705ea82195b7d12a21a8d98f212f700000000000000000000000068cfdb9ede92a64d24df431ce020d1bc9fc550e2000000000000000000000000164e07ae48ca7774663e90732d44b324f2e3c679","Library":"","SwarmSource":"bzzr://b02b75e911118ecad4f7687fe285e5ee164fc7be6c7a56cf1ccae451f332dbda"}]}