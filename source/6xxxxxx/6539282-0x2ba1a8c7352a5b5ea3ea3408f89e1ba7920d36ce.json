{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: /home/blackjak/Projects/winding-tree/wt-contracts/node_modules/zos-lib/contracts/application/ImplementationProvider.sol\r\n\r\n/**\r\n * @title ImplementationProvider\r\n * @dev Interface for providing implementation addresses for other contracts by name.\r\n */\r\ninterface ImplementationProvider {\r\n  /**\r\n   * @dev Abstract function to return the implementation address of a contract.\r\n   * @param contractName Name of the contract.\r\n   * @return Implementation address of the contract.\r\n   */\r\n  function getImplementation(string contractName) public view returns (address);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: /home/blackjak/Projects/winding-tree/wt-contracts/node_modules/zos-lib/contracts/application/Package.sol\r\n\r\n/**\r\n * @title Package\r\n * @dev A package is composed by a set of versions, identified via semantic versioning,\r\n * where each version has a contract address that refers to a reusable implementation,\r\n * plus an optional content URI with metadata. Note that the semver identifier is restricted\r\n * to major, minor, and patch, as prerelease tags are not supported.\r\n */\r\ncontract Package is Ownable {\r\n  /**\r\n   * @dev Emitted when a version is added to the package.\r\n   * @param semanticVersion Name of the added version.\r\n   * @param contractAddress Contract associated with the version.\r\n   * @param contentURI Optional content URI with metadata of the version.\r\n   */\r\n  event VersionAdded(uint64[3] semanticVersion, address contractAddress, bytes contentURI);\r\n\r\n  struct Version {\r\n    uint64[3] semanticVersion;\r\n    address contractAddress;\r\n    bytes contentURI; \r\n  }\r\n\r\n  mapping (bytes32 => Version) internal versions;\r\n  mapping (uint64 => bytes32) internal majorToLatestVersion;\r\n  uint64 internal latestMajor;\r\n\r\n  /**\r\n   * @dev Returns a version given its semver identifier.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @return Contract address and content URI for the version, or zero if not exists.\r\n   */\r\n  function getVersion(uint64[3] semanticVersion) public view returns (address contractAddress, bytes contentURI) {\r\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n    return (version.contractAddress, version.contentURI); \r\n  }\r\n\r\n  /**\r\n   * @dev Returns a contract for a version given its semver identifier.\r\n   * This method is equivalent to `getVersion`, but returns only the contract address.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @return Contract address for the version, or zero if not exists.\r\n   */\r\n  function getContract(uint64[3] semanticVersion) public view returns (address contractAddress) {\r\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n    return version.contractAddress;\r\n  }\r\n\r\n  /**\r\n   * @dev Adds a new version to the package. Only the Owner can add new versions.\r\n   * Reverts if the specified semver identifier already exists. \r\n   * Emits a `VersionAdded` event if successful.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @param contractAddress Contract address for the version, must be non-zero.\r\n   * @param contentURI Optional content URI for the version.\r\n   */\r\n  function addVersion(uint64[3] semanticVersion, address contractAddress, bytes contentURI) public onlyOwner {\r\n    require(contractAddress != address(0), \"Contract address is required\");\r\n    require(!hasVersion(semanticVersion), \"Given version is already registered in package\");\r\n    require(!semanticVersionIsZero(semanticVersion), \"Version must be non zero\");\r\n\r\n    // Register version\r\n    bytes32 versionId = semanticVersionHash(semanticVersion);\r\n    versions[versionId] = Version(semanticVersion, contractAddress, contentURI);\r\n    \r\n    // Update latest major\r\n    uint64 major = semanticVersion[0];\r\n    if (major > latestMajor) {\r\n      latestMajor = semanticVersion[0];\r\n    }\r\n\r\n    // Update latest version for this major\r\n    uint64 minor = semanticVersion[1];\r\n    uint64 patch = semanticVersion[2];\r\n    uint64[3] latestVersionForMajor = versions[majorToLatestVersion[major]].semanticVersion;\r\n    if (semanticVersionIsZero(latestVersionForMajor) // No latest was set for this major\r\n       || (minor > latestVersionForMajor[1]) // Or current minor is greater \r\n       || (minor == latestVersionForMajor[1] && patch > latestVersionForMajor[2]) // Or current patch is greater\r\n       ) { \r\n      majorToLatestVersion[major] = versionId;\r\n    }\r\n\r\n    emit VersionAdded(semanticVersion, contractAddress, contentURI);\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether a version is present in the package.\r\n   * @param semanticVersion Semver identifier of the version.\r\n   * @return true if the version is registered in this package, false otherwise.\r\n   */\r\n  function hasVersion(uint64[3] semanticVersion) public view returns (bool) {\r\n    Version storage version = versions[semanticVersionHash(semanticVersion)];\r\n    return address(version.contractAddress) != address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the version with the highest semver identifier registered in the package.\r\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will always return `2.0.0`, regardless \r\n   * of the order in which they were registered. Returns zero if no versions are registered.\r\n   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\r\n   */\r\n  function getLatest() public view returns (uint64[3] semanticVersion, address contractAddress, bytes contentURI) {\r\n    return getLatestByMajor(latestMajor);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the version with the highest semver identifier for the given major.\r\n   * For instance, if `1.2.0`, `1.3.0`, and `2.0.0` are present, will return `1.3.0` for major `1`, \r\n   * regardless of the order in which they were registered. Returns zero if no versions are registered\r\n   * for the specified major.\r\n   * @param major Major identifier to query\r\n   * @return Semver identifier, contract address, and content URI for the version, or zero if not exists.\r\n   */\r\n  function getLatestByMajor(uint64 major) public view returns (uint64[3] semanticVersion, address contractAddress, bytes contentURI) {\r\n    Version storage version = versions[majorToLatestVersion[major]];\r\n    return (version.semanticVersion, version.contractAddress, version.contentURI); \r\n  }\r\n\r\n  function semanticVersionHash(uint64[3] version) internal pure returns (bytes32) {\r\n    return keccak256(abi.encodePacked(version[0], version[1], version[2]));\r\n  }\r\n\r\n  function semanticVersionIsZero(uint64[3] version) internal pure returns (bool) {\r\n    return version[0] == 0 && version[1] == 0 && version[2] == 0;\r\n  }\r\n}\r\n\r\n// File: /home/blackjak/Projects/winding-tree/wt-contracts/node_modules/zos-lib/contracts/upgradeability/Proxy.sol\r\n\r\n/**\r\n * @title Proxy\r\n * @dev Implements delegation of calls to other contracts, with proper\r\n * forwarding of return values and bubbling of failures.\r\n * It defines a fallback function that delegates all calls to the address\r\n * returned by the abstract _implementation() internal function.\r\n */\r\ncontract Proxy {\r\n  /**\r\n   * @dev Fallback function.\r\n   * Implemented entirely in `_fallback`.\r\n   */\r\n  function () payable external {\r\n    _fallback();\r\n  }\r\n\r\n  /**\r\n   * @return The Address of the implementation.\r\n   */\r\n  function _implementation() internal view returns (address);\r\n\r\n  /**\r\n   * @dev Delegates execution to an implementation contract.\r\n   * This is a low level function that doesn't return to its internal call site.\r\n   * It will return to the external caller whatever the implementation returns.\r\n   * @param implementation Address to delegate.\r\n   */\r\n  function _delegate(address implementation) internal {\r\n    assembly {\r\n      // Copy msg.data. We take full control of memory in this inline assembly\r\n      // block because it will not return to Solidity code. We overwrite the\r\n      // Solidity scratch pad at memory position 0.\r\n      calldatacopy(0, 0, calldatasize)\r\n\r\n      // Call the implementation.\r\n      // out and outsize are 0 because we don't know the size yet.\r\n      let result := delegatecall(gas, implementation, 0, calldatasize, 0, 0)\r\n\r\n      // Copy the returned data.\r\n      returndatacopy(0, 0, returndatasize)\r\n\r\n      switch result\r\n      // delegatecall returns 0 on error.\r\n      case 0 { revert(0, returndatasize) }\r\n      default { return(0, returndatasize) }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Function that is run as the first thing in the fallback function.\r\n   * Can be redefined in derived contracts to add functionality.\r\n   * Redefinitions must call super._willFallback().\r\n   */\r\n  function _willFallback() internal {\r\n  }\r\n\r\n  /**\r\n   * @dev fallback implementation.\r\n   * Extracted to enable manual triggering.\r\n   */\r\n  function _fallback() internal {\r\n    _willFallback();\r\n    _delegate(_implementation());\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/AddressUtils.sol\r\n\r\n/**\r\n * Utility library of inline functions on addresses\r\n */\r\nlibrary AddressUtils {\r\n\r\n  /**\r\n   * Returns whether the target address is a contract\r\n   * @dev This function will return false if invoked during the constructor of a contract,\r\n   * as the code is not actually created until after the constructor finishes.\r\n   * @param _addr address to check\r\n   * @return whether the target address is a contract\r\n   */\r\n  function isContract(address _addr) internal view returns (bool) {\r\n    uint256 size;\r\n    // XXX Currently there is no better way to check if there is a contract in an address\r\n    // than to check the size of the code at that address.\r\n    // See https://ethereum.stackexchange.com/a/14016/36603\r\n    // for more details about how this works.\r\n    // TODO Check this again before the Serenity release, because all addresses will be\r\n    // contracts then.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly { size := extcodesize(_addr) }\r\n    return size > 0;\r\n  }\r\n\r\n}\r\n\r\n// File: /home/blackjak/Projects/winding-tree/wt-contracts/node_modules/zos-lib/contracts/upgradeability/UpgradeabilityProxy.sol\r\n\r\n/**\r\n * @title UpgradeabilityProxy\r\n * @dev This contract implements a proxy that allows to change the\r\n * implementation address to which it will delegate.\r\n * Such a change is called an implementation upgrade.\r\n */\r\ncontract UpgradeabilityProxy is Proxy {\r\n  /**\r\n   * @dev Emitted when the implementation is upgraded.\r\n   * @param implementation Address of the new implementation.\r\n   */\r\n  event Upgraded(address indexed implementation);\r\n\r\n  /**\r\n   * @dev Storage slot with the address of the current implementation.\r\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.implementation\", and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 private constant IMPLEMENTATION_SLOT = 0x7050c9e0f4ca769c69bd3a8ef740bc37934f8e2c036e5a723fd8ee048ed3f8c3;\r\n\r\n  /**\r\n   * @dev Contract constructor.\r\n   * @param _implementation Address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  constructor(address _implementation, bytes _data) public payable {\r\n    assert(IMPLEMENTATION_SLOT == keccak256(\"org.zeppelinos.proxy.implementation\"));\r\n    _setImplementation(_implementation);\r\n    if(_data.length > 0) {\r\n      require(_implementation.delegatecall(_data));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current implementation.\r\n   * @return Address of the current implementation\r\n   */\r\n  function _implementation() internal view returns (address impl) {\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n    assembly {\r\n      impl := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades the proxy to a new implementation.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _upgradeTo(address newImplementation) internal {\r\n    _setImplementation(newImplementation);\r\n    emit Upgraded(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the implementation address of the proxy.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function _setImplementation(address newImplementation) private {\r\n    require(AddressUtils.isContract(newImplementation), \"Cannot set a proxy implementation to a non-contract address\");\r\n\r\n    bytes32 slot = IMPLEMENTATION_SLOT;\r\n\r\n    assembly {\r\n      sstore(slot, newImplementation)\r\n    }\r\n  }\r\n}\r\n\r\n// File: /home/blackjak/Projects/winding-tree/wt-contracts/node_modules/zos-lib/contracts/upgradeability/AdminUpgradeabilityProxy.sol\r\n\r\n/**\r\n * @title AdminUpgradeabilityProxy\r\n * @dev This contract combines an upgradeability proxy with an authorization\r\n * mechanism for administrative tasks.\r\n * All external functions in this contract must be guarded by the\r\n * `ifAdmin` modifier. See ethereum/solidity#3864 for a Solidity\r\n * feature proposal that would enable this to be done automatically.\r\n */\r\ncontract AdminUpgradeabilityProxy is UpgradeabilityProxy {\r\n  /**\r\n   * @dev Emitted when the administration has been transferred.\r\n   * @param previousAdmin Address of the previous admin.\r\n   * @param newAdmin Address of the new admin.\r\n   */\r\n  event AdminChanged(address previousAdmin, address newAdmin);\r\n\r\n  /**\r\n   * @dev Storage slot with the admin of the contract.\r\n   * This is the keccak-256 hash of \"org.zeppelinos.proxy.admin\", and is\r\n   * validated in the constructor.\r\n   */\r\n  bytes32 private constant ADMIN_SLOT = 0x10d6a54a4754c8869d6886b5f5d7fbfa5b4522237ea5c60d11bc4e7a1ff9390b;\r\n\r\n  /**\r\n   * @dev Modifier to check whether the `msg.sender` is the admin.\r\n   * If it is, it will run the function. Otherwise, it will delegate the call\r\n   * to the implementation.\r\n   */\r\n  modifier ifAdmin() {\r\n    if (msg.sender == _admin()) {\r\n      _;\r\n    } else {\r\n      _fallback();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Contract constructor.\r\n   * It sets the `msg.sender` as the proxy administrator.\r\n   * @param _implementation address of the initial implementation.\r\n   * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   */\r\n  constructor(address _implementation, bytes _data) UpgradeabilityProxy(_implementation, _data) public payable {\r\n    assert(ADMIN_SLOT == keccak256(\"org.zeppelinos.proxy.admin\"));\r\n\r\n    _setAdmin(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @return The address of the proxy admin.\r\n   */\r\n  function admin() external view ifAdmin returns (address) {\r\n    return _admin();\r\n  }\r\n\r\n  /**\r\n   * @return The address of the implementation.\r\n   */\r\n  function implementation() external view ifAdmin returns (address) {\r\n    return _implementation();\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin of the proxy.\r\n   * Only the current admin can call this function.\r\n   * @param newAdmin Address to transfer proxy administration to.\r\n   */\r\n  function changeAdmin(address newAdmin) external ifAdmin {\r\n    require(newAdmin != address(0), \"Cannot change the admin of a proxy to the zero address\");\r\n    emit AdminChanged(_admin(), newAdmin);\r\n    _setAdmin(newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy.\r\n   * Only the admin can call this function.\r\n   * @param newImplementation Address of the new implementation.\r\n   */\r\n  function upgradeTo(address newImplementation) external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrade the backing implementation of the proxy and call a function\r\n   * on the new implementation.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param newImplementation Address of the new implementation.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n  function upgradeToAndCall(address newImplementation, bytes data) payable external ifAdmin {\r\n    _upgradeTo(newImplementation);\r\n    require(newImplementation.delegatecall(data));\r\n  }\r\n\r\n  /**\r\n   * @return The admin slot.\r\n   */\r\n  function _admin() internal view returns (address adm) {\r\n    bytes32 slot = ADMIN_SLOT;\r\n    assembly {\r\n      adm := sload(slot)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Sets the address of the proxy admin.\r\n   * @param newAdmin Address of the new proxy admin.\r\n   */\r\n  function _setAdmin(address newAdmin) internal {\r\n    bytes32 slot = ADMIN_SLOT;\r\n\r\n    assembly {\r\n      sstore(slot, newAdmin)\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Only fall back when the sender is not the admin.\r\n   */\r\n  function _willFallback() internal {\r\n    require(msg.sender != _admin(), \"Cannot call fallback function from the proxy admin\");\r\n    super._willFallback();\r\n  }\r\n}\r\n\r\n// File: node_modules/zos-lib/contracts/application/App.sol\r\n\r\n/**\r\n * @title App\r\n * @dev Contract for upgradeable applications.\r\n * It handles the creation and upgrading of proxies.\r\n */\r\ncontract App is Ownable {\r\n  /**\r\n   * @dev Emitted when a new proxy is created.\r\n   * @param proxy Address of the created proxy.\r\n   */\r\n  event ProxyCreated(address proxy);\r\n\r\n  /**\r\n   * @dev Emitted when a package dependency is changed in the application.\r\n   * @param providerName Name of the package that changed.\r\n   * @param package Address of the package associated to the name.\r\n   * @param version Version of the package in use.\r\n   */\r\n  event PackageChanged(string providerName, address package, uint64[3] version);\r\n\r\n  /**\r\n   * @dev Tracks a package in a particular version, used for retrieving implementations\r\n   */\r\n  struct ProviderInfo {\r\n    Package package;\r\n    uint64[3] version;\r\n  }\r\n\r\n  /**\r\n   * @dev Maps from dependency name to a tuple of package and version\r\n   */\r\n  mapping(string => ProviderInfo) internal providers;\r\n\r\n  /**\r\n   * @dev Constructor function.\r\n   */\r\n  constructor() public { }\r\n\r\n  /**\r\n   * @dev Returns the provider for a given package name, or zero if not set.\r\n   * @param packageName Name of the package to be retrieved.\r\n   * @return The provider.\r\n   */\r\n  function getProvider(string packageName) public view returns (ImplementationProvider provider) {\r\n    ProviderInfo storage info = providers[packageName];\r\n    if (address(info.package) == address(0)) return ImplementationProvider(0);\r\n    return ImplementationProvider(info.package.getContract(info.version));\r\n  }\r\n\r\n  /**\r\n   * @dev Returns information on a package given its name.\r\n   * @param packageName Name of the package to be queried.\r\n   * @return A tuple with the package address and pinned version given a package name, or zero if not set\r\n   */\r\n  function getPackage(string packageName) public view returns (Package, uint64[3]) {\r\n    ProviderInfo storage info = providers[packageName];\r\n    return (info.package, info.version);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets a package in a specific version as a dependency for this application.\r\n   * Requires the version to be present in the package.\r\n   * @param packageName Name of the package to set or overwrite.\r\n   * @param package Address of the package to register.\r\n   * @param version Version of the package to use in this application.\r\n   */\r\n  function setPackage(string packageName, Package package, uint64[3] version) public onlyOwner {\r\n    require(package.hasVersion(version), \"The requested version must be registered in the given package\");\r\n    providers[packageName] = ProviderInfo(package, version);\r\n    emit PackageChanged(packageName, package, version);\r\n  }\r\n\r\n  /**\r\n   * @dev Unsets a package given its name.\r\n   * Reverts if the package is not set in the application.\r\n   * @param packageName Name of the package to remove.\r\n   */\r\n  function unsetPackage(string packageName) public onlyOwner {\r\n    require(address(providers[packageName].package) != address(0), \"Package to unset not found\");\r\n    delete providers[packageName];\r\n    emit PackageChanged(packageName, address(0), [uint64(0), uint64(0), uint64(0)]);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the implementation address for a given contract name, provided by the `ImplementationProvider`.\r\n   * @param packageName Name of the package where the contract is contained.\r\n   * @param contractName Name of the contract.\r\n   * @return Address where the contract is implemented.\r\n   */\r\n  function getImplementation(string packageName, string contractName) public view returns (address) {\r\n    ImplementationProvider provider = getProvider(packageName);\r\n    if (address(provider) == address(0)) return address(0);\r\n    return provider.getImplementation(contractName);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the current implementation of a proxy.\r\n   * This is needed because only the proxy admin can query it.\r\n   * @return The address of the current implementation of the proxy.\r\n   */\r\n  function getProxyImplementation(AdminUpgradeabilityProxy proxy) public view returns (address) {\r\n    return proxy.implementation();\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the admin of a proxy. Only the admin can query it.\r\n   * @return The address of the current admin of the proxy.\r\n   */\r\n  function getProxyAdmin(AdminUpgradeabilityProxy proxy) public view returns (address) {\r\n    return proxy.admin();\r\n  }\r\n\r\n  /**\r\n   * @dev Changes the admin of a proxy.\r\n   * @param proxy Proxy to change admin.\r\n   * @param newAdmin Address to transfer proxy administration to.\r\n   */\r\n  function changeProxyAdmin(AdminUpgradeabilityProxy proxy, address newAdmin) public onlyOwner {\r\n    proxy.changeAdmin(newAdmin);\r\n  }\r\n\r\n  /**\r\n   * @dev Creates a new proxy for the given contract and forwards a function call to it.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param packageName Name of the package where the contract is contained.\r\n   * @param contractName Name of the contract.\r\n   * @param data Data to send as msg.data to the corresponding implementation to initialize the proxied contract.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.\r\n   * @return Address of the new proxy.\r\n   */\r\n   function create(string packageName, string contractName, bytes data) payable public returns (AdminUpgradeabilityProxy) {\r\n    address implementation = getImplementation(packageName, contractName);\r\n     AdminUpgradeabilityProxy proxy = (new AdminUpgradeabilityProxy).value(msg.value)(implementation, data);\r\n     emit ProxyCreated(proxy);\r\n     return proxy;\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades a proxy to the newest implementation of a contract.\r\n   * @param proxy Proxy to be upgraded.\r\n   * @param packageName Name of the package where the contract is contained.\r\n   * @param contractName Name of the contract.\r\n   */\r\n  function upgrade(AdminUpgradeabilityProxy proxy, string packageName, string contractName) public onlyOwner {\r\n    address implementation = getImplementation(packageName, contractName);\r\n    proxy.upgradeTo(implementation);\r\n  }\r\n\r\n  /**\r\n   * @dev Upgrades a proxy to the newest implementation of a contract and forwards a function call to it.\r\n   * This is useful to initialize the proxied contract.\r\n   * @param proxy Proxy to be upgraded.\r\n   * @param packageName Name of the package where the contract is contained.\r\n   * @param contractName Name of the contract.\r\n   * @param data Data to send as msg.data in the low level call.\r\n   * It should include the signature and the parameters of the function to be called, as described in\r\n   * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.\r\n   */\r\n  function upgradeAndCall(AdminUpgradeabilityProxy proxy, string packageName, string contractName, bytes data) payable public onlyOwner {\r\n    address implementation = getImplementation(packageName, contractName);\r\n    proxy.upgradeToAndCall.value(msg.value)(implementation, data);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"packageName\",\"type\":\"string\"},{\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"getImplementation\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"packageName\",\"type\":\"string\"},{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"create\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"packageName\",\"type\":\"string\"}],\"name\":\"getProvider\",\"outputs\":[{\"name\":\"provider\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"packageName\",\"type\":\"string\"},{\"name\":\"package\",\"type\":\"address\"},{\"name\":\"version\",\"type\":\"uint64[3]\"}],\"name\":\"setPackage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"newAdmin\",\"type\":\"address\"}],\"name\":\"changeProxyAdmin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"packageName\",\"type\":\"string\"},{\"name\":\"contractName\",\"type\":\"string\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"packageName\",\"type\":\"string\"}],\"name\":\"getPackage\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint64[3]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"packageName\",\"type\":\"string\"}],\"name\":\"unsetPackage\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"},{\"name\":\"packageName\",\"type\":\"string\"},{\"name\":\"contractName\",\"type\":\"string\"},{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"upgradeAndCall\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"getProxyAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"proxy\",\"type\":\"address\"}],\"name\":\"ProxyCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"providerName\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"package\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"version\",\"type\":\"uint64[3]\"}],\"name\":\"PackageChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"App","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://baa7a50100c304b29771c266a51ce0a13c4844dd7640815db0ec8be6184ba94b"}]}