{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n//    Copyright Countryside Company Limited\r\n*/\r\n\r\npragma solidity ^0.4.18;\r\n\r\n// File: contracts/Ownable.sol\r\n\r\ncontract Ownable {\r\n\r\n\taddress public owner;\r\n\taddress public pendingOwner;\r\n\taddress public operator;\r\n\r\n\tevent OwnershipTransferred(\r\n\t\taddress indexed previousOwner,\r\n\t\taddress indexed newOwner\r\n\t);\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tconstructor() public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Modifier throws if called by any account other than the pendingOwner.\r\n\t */\r\n\tmodifier onlyPendingOwner() {\r\n\t\trequire(msg.sender == pendingOwner);\r\n\t\t_;\r\n\t}\r\n\r\n\tmodifier ownerOrOperator {\r\n\t\trequire(msg.sender == owner || msg.sender == operator);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to set the pendingOwner address.\r\n\t * @param newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address newOwner) onlyOwner public {\r\n\t\tpendingOwner = newOwner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the pendingOwner address to finalize the transfer.\r\n\t */\r\n\tfunction claimOwnership() onlyPendingOwner public {\r\n\t\temit OwnershipTransferred(owner, pendingOwner);\r\n\t\towner = pendingOwner;\r\n\t\tpendingOwner = address(0);\r\n\t}\r\n\r\n\tfunction setOperator(address _operator) onlyOwner public {\r\n\t\toperator = _operator;\r\n\t}\r\n\r\n}\r\n\r\n// File: contracts/LikeCoinInterface.sol\r\n\r\ncontract LikeCoinInterface {\r\n\tfunction balanceOf(address _owner) public constant returns (uint256 balance);\r\n\tfunction transfer(address _to, uint256 _value) public returns (bool success);\r\n\tfunction transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\tfunction approve(address _spender, uint256 _value) public returns (bool success);\r\n}\r\n\r\n// File: contracts/ArtMuseumBase.sol\r\n\r\ncontract ArtMuseumBase is Ownable {\r\n\r\n\tstruct Artwork {\r\n\t\tuint8 artworkType;\r\n\t\tuint32 sequenceNumber;\r\n\t\tuint128 value;\r\n\t\taddress player;\r\n\t}\r\n\tLikeCoinInterface public like;\r\n\r\n\t/** array holding ids mapping of the curret artworks*/\r\n\tuint32[] public ids;\r\n\t/** the last sequence id to be given to the link artwork **/\r\n\tuint32 public lastId;\r\n\t/** the id of the oldest artwork */\r\n\tuint32 public oldest;\r\n\t/** the artwork belonging to a given id */\r\n\tmapping(uint32 => Artwork) artworks;\r\n\t/** the user purchase sequence number per each artwork type */\r\n\tmapping(address=>mapping(uint8 => uint32)) userArtworkSequenceNumber;\r\n\t/** the cost of each artwork type */\r\n\tuint128[] public costs;\r\n\t/** the value of each artwork type (cost - fee), so it's not necessary to compute it each time*/\r\n\tuint128[] public values;\r\n\t/** the fee to be paid each time an artwork is bought in percent*/\r\n\tuint8 public fee;\r\n\r\n\t/** total number of artworks in the game (uint32 because of multiplication issues) */\r\n\tuint32 public numArtworks;\r\n\t/** The maximum of artworks allowed in the game */\r\n\tuint16 public maxArtworks;\r\n\t/** number of artworks per type */\r\n\tuint32[] numArtworksXType;\r\n\r\n\t/** initializes the contract parameters */\r\n\tfunction init(address _likeAddr) public onlyOwner {\r\n\t\trequire(like==address(0));\r\n\t\tlike = LikeCoinInterface(_likeAddr);\r\n\t\tcosts = [800 ether, 2000 ether, 5000 ether, 12000 ether, 25000 ether];\r\n\t\tsetFee(5);\r\n\t\tmaxArtworks = 1000;\r\n\t\tlastId = 1;\r\n\t\toldest = 0;\r\n\t}\r\n\r\n\tfunction deposit() payable public {\r\n\r\n\t}\r\n\r\n\tfunction withdrawBalance() public onlyOwner returns(bool res) {\r\n\t\towner.transfer(address(this).balance);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * allows the owner to collect the accumulated fees\r\n\t * sends the given amount to the owner's address if the amount does not exceed the\r\n\t * fees (cannot touch the players' balances)\r\n\t * */\r\n\tfunction collectFees(uint128 amount) public onlyOwner {\r\n\t\tuint collectedFees = getFees();\r\n\t\tif (amount <= collectedFees) {\r\n\t\t\tlike.transfer(owner,amount);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getArtwork(uint32 artworkId) public constant returns(uint8 artworkType, uint32 sequenceNumber, uint128 value, address player) {\r\n\t\treturn (artworks[artworkId].artworkType, artworks[artworkId].sequenceNumber, artworks[artworkId].value, artworks[artworkId].player);\r\n\t}\r\n\r\n\tfunction getAllArtworks() public constant returns(uint32[] artworkIds,uint8[] types,uint32[] sequenceNumbers, uint128[] artworkValues) {\r\n\t\tuint32 id;\r\n\t\tartworkIds = new uint32[](numArtworks);\r\n\t\ttypes = new uint8[](numArtworks);\r\n\t\tsequenceNumbers = new uint32[](numArtworks);\r\n\t\tartworkValues = new uint128[](numArtworks);\r\n\t\tfor (uint16 i = 0; i < numArtworks; i++) {\r\n\t\t\tid = ids[i];\r\n\t\t\tartworkIds[i] = id;\r\n\t\t\ttypes[i] = artworks[id].artworkType;\r\n\t\t\tsequenceNumbers[i] = artworks[id].sequenceNumber;\r\n\t\t\tartworkValues[i] = artworks[id].value;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getAllArtworksByOwner() public constant returns(uint32[] artworkIds,uint8[] types,uint32[] sequenceNumbers, uint128[] artworkValues) {\r\n\t\tuint32 id;\r\n\t\tuint16 j = 0;\r\n\t\tuint16 howmany = 0;\r\n\t\taddress player = address(msg.sender);\r\n\t\tfor (uint16 k = 0; k < numArtworks; k++) {\r\n\t\t\tif (artworks[ids[k]].player == player)\r\n\t\t\t\thowmany++;\r\n\t\t}\r\n\t\tartworkIds = new uint32[](howmany);\r\n\t\ttypes = new uint8[](howmany);\r\n\t\tsequenceNumbers = new uint32[](howmany);\r\n\t\tartworkValues = new uint128[](howmany);\r\n\t\tfor (uint16 i = 0; i < numArtworks; i++) {\r\n\t\t\tif (artworks[ids[i]].player == player) {\r\n\t\t\t\tid = ids[i];\r\n\t\t\t\tartworkIds[j] = id;\r\n\t\t\t\ttypes[j] = artworks[id].artworkType;\r\n\t\t\t\tsequenceNumbers[j] = artworks[id].sequenceNumber;\r\n\t\t\t\tartworkValues[j] = artworks[id].value;\r\n\t\t\t\tj++;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction setCosts(uint128[] _costs) public onlyOwner {\r\n\t\trequire(_costs.length >= costs.length);\r\n\t\tcosts = _costs;\r\n\t\tsetFee(fee);\r\n\t}\r\n\t\r\n\tfunction setFee(uint8 _fee) public onlyOwner {\r\n\t\tfee = _fee;\r\n\t\tfor (uint8 i = 0; i < costs.length; i++) {\r\n\t\t\tif (i < values.length)\r\n\t\t\t\tvalues[i] = costs[i] - costs[i] / 100 * fee;\r\n\t\t\telse {\r\n\t\t\t\tvalues.push(costs[i] - costs[i] / 100 * fee);\r\n\t\t\t\tnumArtworksXType.push(0);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getFees() public constant returns(uint) {\r\n\t\tuint reserved = 0;\r\n\t\tfor (uint16 j = 0; j < numArtworks; j++)\r\n\t\t\treserved += artworks[ids[j]].value;\r\n\t\treturn like.balanceOf(this) - reserved;\r\n\t}\r\n\r\n\tfunction getNumArtworksXType() public constant returns(uint32[] _numArtworksXType) {\r\n\t\t_numArtworksXType = numArtworksXType;\r\n\t}\r\n\r\n\r\n}\r\n\r\n// File: contracts/oraclizeAPI.sol\r\n\r\n// This api is currently targeted at 0.4.18, please import oraclizeAPI_pre0.4.sol or oraclizeAPI_0.4 where necessary\r\n\r\npragma solidity ^0.4.20;//<=0.4.20;// Incompatible compiler version... please select one stated within pragma solidity or use different oraclizeAPI version\r\n\r\ncontract OraclizeI {\r\n\taddress public cbAddress;\r\n\tfunction query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id);\r\n\tfunction query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id);\r\n\tfunction query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id);\r\n\tfunction query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id);\r\n\tfunction queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id);\r\n\tfunction queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id);\r\n\tfunction getPrice(string _datasource) public returns (uint _dsprice);\r\n\tfunction getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice);\r\n\tfunction setProofType(byte _proofType) external;\r\n\tfunction setCustomGasPrice(uint _gasPrice) external;\r\n\tfunction randomDS_getSessionPubKeyHash() external constant returns(bytes32);\r\n}\r\n\r\ncontract OraclizeAddrResolverI {\r\n\tfunction getAddress() public returns (address _addr);\r\n}\r\n\r\ncontract usingOraclize { // is ArtMuseumBase {\r\n\tuint constant day = 60*60*24;\r\n\tuint constant week = 60*60*24*7;\r\n\tuint constant month = 60*60*24*30;\r\n\tbyte constant proofType_NONE = 0x00;\r\n\tbyte constant proofType_TLSNotary = 0x10;\r\n\tbyte constant proofType_Android = 0x20;\r\n\tbyte constant proofType_Ledger = 0x30;\r\n\tbyte constant proofType_Native = 0xF0;\r\n\tbyte constant proofStorage_IPFS = 0x01;\r\n\tuint8 constant networkID_auto = 0;\r\n\tuint8 constant networkID_mainnet = 1;\r\n\tuint8 constant networkID_testnet = 2;\r\n\tuint8 constant networkID_morden = 2;\r\n\tuint8 constant networkID_consensys = 161;\r\n\tstring oraclize_network_name;\r\n\tOraclizeAddrResolverI OAR;\r\n\tOraclizeI oraclize;\r\n\tmodifier oraclizeAPI {\r\n\t\tif((address(OAR)==0)||(getCodeSize(address(OAR))==0))\r\n\t\t\toraclize_setNetwork(networkID_auto);\r\n\r\n\t\tif(address(oraclize) != OAR.getAddress())\r\n\t\t\toraclize = OraclizeI(OAR.getAddress());\r\n\r\n\t\t_;\r\n\t}\r\n\tfunction oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n\t  return oraclize_setNetwork();\r\n\t  networkID; // silence the warning and remain backwards compatible\r\n\t}\r\n\tfunction oraclize_setNetwork() internal returns(bool){\r\n\t\tif (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n\t\t\tOAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n\t\t\toraclize_setNetworkName(\"eth_mainnet\");\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n\t\t\tOAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n\t\t\toraclize_setNetworkName(\"eth_ropsten3\");\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n\t\t\tOAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n\t\t\toraclize_setNetworkName(\"eth_kovan\");\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n\t\t\tOAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n\t\t\toraclize_setNetworkName(\"eth_rinkeby\");\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n\t\t\tOAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n\t\t\tOAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n\t\t\tOAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t}\r\n\tfunction oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n\t\treturn oraclize.getPrice(datasource);\r\n\t}\r\n\tfunction oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n\t\treturn oraclize.getPrice(datasource, gaslimit);\r\n\t}\r\n\tfunction oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n\t\tuint price = oraclize.getPrice(datasource);\r\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n\t\treturn oraclize.query.value(price)(0, datasource, arg);\r\n\t}\r\n\tfunction oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n\t\tuint price = oraclize.getPrice(datasource);\r\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n\t\treturn oraclize.query.value(price)(timestamp, datasource, arg);\r\n\t}\r\n\tfunction oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\r\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n\t\treturn oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n\t}\r\n\tfunction oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\r\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n\t\treturn oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n\t}\r\n\tfunction oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n\t\tuint price = oraclize.getPrice(datasource);\r\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n\t\treturn oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n\t}\r\n\tfunction oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n\t\tuint price = oraclize.getPrice(datasource);\r\n\t\tif (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n\t\treturn oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n\t}\r\n\tfunction oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\r\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n\t\treturn oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n\t}\r\n\tfunction oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n\t\tuint price = oraclize.getPrice(datasource, gaslimit);\r\n\t\tif (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n\t\treturn oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n\t}\r\n\r\n\tfunction oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n\t\treturn oraclize.cbAddress();\r\n\t}\r\n\tfunction oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n\t\treturn oraclize.setCustomGasPrice(gasPrice);\r\n\t}\r\n\tfunction getCodeSize(address _addr) constant internal returns(uint _size) {\r\n\t\tassembly {\r\n\t\t\t_size := extcodesize(_addr)\r\n\t\t}\r\n\t}\r\n\t// parseInt\r\n\tfunction parseInt(string _a) internal pure returns (uint) {\r\n\t\treturn parseInt(_a, 0);\r\n\t}\r\n\t// parseInt(parseFloat*10^_b)\r\n\tfunction parseInt(string _a, uint _b) internal pure returns (uint) {\r\n\t\tbytes memory bresult = bytes(_a);\r\n\t\tuint mint = 0;\r\n\t\tbool decimals = false;\r\n\t\tfor (uint i=0; i<bresult.length; i++){\r\n\t\t\tif ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n\t\t\t\tif (decimals){\r\n\t\t\t\t   if (_b == 0) break;\r\n\t\t\t\t\telse _b--;\r\n\t\t\t\t}\r\n\t\t\t\tmint *= 10;\r\n\t\t\t\tmint += uint(bresult[i]) - 48;\r\n\t\t\t} else if (bresult[i] == 46) decimals = true;\r\n\t\t}\r\n\t\tif (_b > 0) mint *= 10**_b;\r\n\t\treturn mint;\r\n\t}\r\n\tfunction oraclize_setNetworkName(string _network_name) internal {\r\n\t\toraclize_network_name = _network_name;\r\n\t}\r\n\tfunction oraclize_getNetworkName() internal view returns (string) {\r\n\t\treturn oraclize_network_name;\r\n\t}\r\n}\r\n\r\n// File: contracts/strings.sol\r\n\r\nlibrary strings {\r\n\tstruct slice {\r\n\t\tuint _len;\r\n\t\tuint _ptr;\r\n\t}\r\n\r\n\tfunction memcpy(uint dest, uint src, uint len) private pure {\r\n\t\t// Copy word-length chunks while possible\r\n\t\tfor(; len >= 32; len -= 32) {\r\n\t\t\tassembly {\r\n\t\t\t\tmstore(dest, mload(src))\r\n\t\t\t}\r\n\t\t\tdest += 32;\r\n\t\t\tsrc += 32;\r\n\t\t}\r\n\r\n\t\t// Copy remaining bytes\r\n\t\tuint mask = 256 ** (32 - len) - 1;\r\n\t\tassembly {\r\n\t\t\tlet srcpart := and(mload(src), not(mask))\r\n\t\t\tlet destpart := and(mload(dest), mask)\r\n\t\t\tmstore(dest, or(destpart, srcpart))\r\n\t\t}\r\n\t}\r\n\r\n\t/*\r\n\t * @dev Returns a slice containing the entire string.\r\n\t * @param self The string to make a slice from.\r\n\t * @return A newly allocated slice containing the entire string.\r\n\t */\r\n\tfunction toSlice(string self) internal pure returns (slice) {\r\n\t\tuint ptr;\r\n\t\tassembly {\r\n\t\t\tptr := add(self, 0x20)\r\n\t\t}\r\n\t\treturn slice(bytes(self).length, ptr);\r\n\t}\r\n\r\n\t/*\r\n\t * @dev Copies a slice to a new string.\r\n\t * @param self The slice to copy.\r\n\t * @return A newly allocated string containing the slice's text.\r\n\t */\r\n\tfunction toString(slice self) internal pure returns (string) {\r\n\t\tstring memory ret = new string(self._len);\r\n\t\tuint retptr;\r\n\t\tassembly { retptr := add(ret, 32) }\r\n\r\n\t\tmemcpy(retptr, self._ptr, self._len);\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t// Returns the memory address of the first byte of the first occurrence of\r\n\t// `needle` in `self`, or the first byte after `self` if not found.\r\n\tfunction findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) {\r\n\t\tuint ptr = selfptr;\r\n\t\tuint idx;\r\n\r\n\t\tif (needlelen <= selflen) {\r\n\t\t\tif (needlelen <= 32) {\r\n\t\t\t\tbytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1));\r\n\r\n\t\t\t\tbytes32 needledata;\r\n\t\t\t\tassembly { needledata := and(mload(needleptr), mask) }\r\n\r\n\t\t\t\tuint end = selfptr + selflen - needlelen;\r\n\t\t\t\tbytes32 ptrdata;\r\n\t\t\t\tassembly { ptrdata := and(mload(ptr), mask) }\r\n\r\n\t\t\t\twhile (ptrdata != needledata) {\r\n\t\t\t\t\tif (ptr >= end)\r\n\t\t\t\t\t\treturn selfptr + selflen;\r\n\t\t\t\t\tptr++;\r\n\t\t\t\t\tassembly { ptrdata := and(mload(ptr), mask) }\r\n\t\t\t\t}\r\n\t\t\t\treturn ptr;\r\n\t\t\t} else {\r\n\t\t\t\t// For long needles, use hashing\r\n\t\t\t\tbytes32 hash;\r\n\t\t\t\tassembly { hash := sha3(needleptr, needlelen) }\r\n\r\n\t\t\t\tfor (idx = 0; idx <= selflen - needlelen; idx++) {\r\n\t\t\t\t\tbytes32 testHash;\r\n\t\t\t\t\tassembly { testHash := sha3(ptr, needlelen) }\r\n\t\t\t\t\tif (hash == testHash)\r\n\t\t\t\t\t\treturn ptr;\r\n\t\t\t\t\tptr += 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn selfptr + selflen;\r\n\t}\r\n\r\n\r\n\t/*\r\n\t * @dev Splits the slice, setting `self` to everything after the first\r\n\t *      occurrence of `needle`, and `token` to everything before it. If\r\n\t *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n\t *      and `token` is set to the entirety of `self`.\r\n\t * @param self The slice to split.\r\n\t * @param needle The text to search for in `self`.\r\n\t * @param token An output parameter to which the first token is written.\r\n\t * @return `token`.\r\n\t */\r\n\tfunction split(slice self, slice needle, slice token) internal pure returns (slice) {\r\n\t\tuint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr);\r\n\t\ttoken._ptr = self._ptr;\r\n\t\ttoken._len = ptr - self._ptr;\r\n\t\tif (ptr == self._ptr + self._len) {\r\n\t\t\t// Not found\r\n\t\t\tself._len = 0;\r\n\t\t} else {\r\n\t\t\tself._len -= token._len + needle._len;\r\n\t\t\tself._ptr = ptr + needle._len;\r\n\t\t}\r\n\t\treturn token;\r\n\t}\r\n\r\n\t/*\r\n\t * @dev Splits the slice, setting `self` to everything after the first\r\n\t *      occurrence of `needle`, and returning everything before it. If\r\n\t *      `needle` does not occur in `self`, `self` is set to the empty slice,\r\n\t *      and the entirety of `self` is returned.\r\n\t * @param self The slice to split.\r\n\t * @param needle The text to search for in `self`.\r\n\t * @return The part of `self` up to the first occurrence of `delim`.\r\n\t */\r\n\tfunction split(slice self, slice needle) internal pure returns (slice token) {\r\n\t\tsplit(self, needle, token);\r\n\t}\r\n\r\n\t/*\r\n\t * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`.\r\n\t * @param self The slice to search.\r\n\t * @param needle The text to search for in `self`.\r\n\t * @return The number of occurrences of `needle` found in `self`.\r\n\t */\r\n\tfunction count(slice self, slice needle) internal pure returns (uint cnt) {\r\n\t\tuint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len;\r\n\t\twhile (ptr <= self._ptr + self._len) {\r\n\t\t\tcnt++;\r\n\t\t\tptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len;\r\n\t\t}\r\n\t}\r\n\r\n}\r\n\r\n// File: contracts/ArtMuseumV1.sol\r\n\r\ncontract ArtMuseumV1 is ArtMuseumBase, usingOraclize {\r\n\r\n\t//using Strings for string;\r\n\tusing strings for *;\r\n\r\n\t/** num of times oldest artwork get bonus **/\r\n\tuint32 public lastcombo;\r\n\t/** last stolen at block number in blockchain **/\r\n\tuint public lastStealBlockNumber;\r\n\t/** oldest artwork extra steal probability **/\r\n\tuint8[] public oldestExtraStealProbability;\r\n\r\n\t/** the query string getting the random numbers from oraclize**/\r\n\tstring randomQuery;\r\n\t/** the type of the oraclize query**/\r\n\tstring queryType;\r\n\t/** the timestamp of the next attack **/\r\n\tuint public nextStealTimestamp;\r\n\t/** gas provided for oraclize callback (attack)**/\r\n\tuint32 public oraclizeGas;\r\n\t/** gas provided for oraclize callback calculate by extra artworks fund likecoin (attack)**/\r\n\tuint32 public oraclizeGasExtraArtwork;\r\n\t/** the id of the next oraclize callback**/\r\n\tuint32 public etherExchangeLikeCoin;\r\n\t/** the id of oraclize callback**/\r\n\tbytes32 nextStealId;\r\n\t/** total number of times steal per day  **/\r\n\tuint8 public numOfTimesSteal;\r\n\t/** accumulate ether fee for trigger next steal include oraclize fee and trigger gas fee **/\r\n\tuint public oraclizeFee;\r\n\r\n\t/** is fired when new artworks are purchased (who bought how many artworks of which type?) */\r\n\tevent newPurchase(address player, uint32 startId, uint8[] artworkTypes, uint32[] startSequenceNumbers);\r\n\t/** is fired when an steal occures */\r\n\tevent newSteal(uint timestamp,uint32[] stolenArtworks,uint8[] artworkTypes,uint32[] sequenceNumbers, uint256[] values,address[] players);\r\n\t/** is fired when an steal occures */\r\n\tevent newStealRewards(uint128 total,uint128[] values);\r\n\t/** is fired when a single artwork is sold **/\r\n\tevent newSell(uint32[] artworkId, address player, uint256 value);\r\n\t/** trigger oraclize **/\r\n\tevent newTriggerOraclize(bytes32 nextStealId, uint waittime, uint gasAmount, uint price, uint balancebefore, uint balance);\r\n\t/** oraclize callback **/\r\n\tevent newOraclizeCallback(bytes32 nextStealId, string result, uint32 killed, uint128 killedValue, uint128 distValue,uint oraclizeFee,uint gaslimit,uint exchange);\r\n\r\n\tfunction initOraclize() public onlyOwner {\r\n\t\tif((address(OAR)==0)||(getCodeSize(address(OAR))==0))\r\n\t\t\toraclize_setNetwork();\r\n\t}\r\n\r\n\tfunction init1() public onlyOwner {\r\n\t\trandomQuery = \"10 random numbers between 1 and 100000\";\r\n\t\tqueryType = \"WolframAlpha\";\r\n\t\toraclizeGas = 150000;\r\n\t\toraclizeGasExtraArtwork = 14000;\r\n\t\tetherExchangeLikeCoin = 50000;\r\n\t\toldestExtraStealProbability = [3,5,10,15,30,50];\r\n\t\tnumOfTimesSteal = 1;\r\n\t}\r\n\r\n\t/**\r\n\t * buy artworks when likecoin transfer callback\r\n\t * */\r\n\tfunction giveArtworks(uint8[] artworkTypes, address receiver, uint256 _value) internal {\r\n\t\tuint32 len = uint32(artworkTypes.length);\r\n\t\trequire(numArtworks + len < maxArtworks);\r\n\t\tuint256 amount = 0;\r\n\t\tfor (uint16 i = 0; i < len; i++) {\r\n\t\t\trequire(artworkTypes[i] < costs.length);\r\n\t\t\tamount += costs[artworkTypes[i]];\r\n\t\t}\r\n\t\trequire(_value >= amount);\r\n\t\tuint8 artworkType;\r\n\t\tuint32[] memory seqnolist = new uint32[](len);\r\n\t\tfor (uint16 j = 0; j < len; j++) {\r\n\t\t\tif (numArtworks < ids.length)\r\n\t\t\t\tids[numArtworks] = lastId;\r\n\t\t\telse\r\n\t\t\t\tids.push(lastId);\r\n\t\t\tartworkType = artworkTypes[j];\r\n\t\t\tuserArtworkSequenceNumber[receiver][artworkType]++;\r\n\t\t\tseqnolist[j] = userArtworkSequenceNumber[receiver][artworkType];\r\n\t\t\tartworks[lastId] = Artwork(artworkTypes[j], userArtworkSequenceNumber[receiver][artworkType], values[artworkType], receiver);\r\n\t\t\tnumArtworks++;\r\n\t\t\tlastId++;\r\n\t\t\tnumArtworksXType[artworkType]++;\r\n\t\t}\r\n\t\t// tryAutoTriggerSteal();\r\n\t\temit newPurchase(receiver, lastId - len, artworkTypes, seqnolist);\r\n\t}\r\n\r\n\t/**\r\n\t * Replaces the artwork with the given id with the last artwork in the array\r\n\t * */\r\n\tfunction replaceArtwork(uint16 index) internal {\r\n\t\tuint32 artworkId = ids[index];\r\n\t\tnumArtworksXType[artworks[artworkId].artworkType]--;\r\n\t\tnumArtworks--;\r\n\t\tif (artworkId == oldest) oldest = 0;\r\n\t\tdelete artworks[artworkId];\r\n\t\tif (numArtworks>0)\r\n\t\t\tids[index] = ids[numArtworks];\r\n\t\tdelete ids[numArtworks];\r\n\t\tids.length = numArtworks;\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * get the oldest artwork\r\n\t * */\r\n\tfunction getOldest() public constant returns(uint32 artworkId,uint8 artworkType, uint32 sequenceNumber, uint128 value, address player) {\r\n\t\tif (numArtworks==0) artworkId = 0;\r\n\t\telse {\r\n\t\t\tartworkId = oldest;\r\n\t\t\tif (artworkId==0) {\r\n\t\t\t\tartworkId = ids[0];\r\n\t\t\t\tfor (uint16 i = 1; i < numArtworks; i++) {\r\n\t\t\t\t\tif (ids[i] < artworkId) //the oldest artwork has the lowest id\r\n\t\t\t\t\t\tartworkId = ids[i];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tartworkType = artworks[artworkId].artworkType;\r\n\t\t\tsequenceNumber = artworks[artworkId].sequenceNumber;\r\n\t\t\tvalue = artworks[artworkId].value;\r\n\t\t\tplayer = artworks[artworkId].player;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * set the oldest artwork when steal\r\n\t * */\r\n\tfunction setOldest() internal returns(uint32 artworkId,uint16 index) {\r\n\t\tif (numArtworks==0) artworkId = 0;\r\n\t\telse {\r\n\t\t\tif (oldest==0) {\r\n\t\t\t\toldest = ids[0];\r\n\t\t\t\tindex = 0;\r\n\t\t\t\tfor (uint16 i = 1; i < numArtworks; i++) {\r\n\t\t\t\t\tif (ids[i] < oldest) { //the oldest artwork has the lowest id\r\n\t\t\t\t\t\toldest = ids[i];\r\n\t\t\t\t\t\tindex = i;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfor (uint16 j = 0; j < numArtworks; j++) {\r\n\t\t\t\t\tif (ids[j] == oldest) {\r\n\t\t\t\t\t\tindex = j;\r\n\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\t\t\t\t\r\n\t\t\t}\r\n\t\t\tartworkId = oldest;\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * sell the artwork of the given id\r\n\t * */\r\n\tfunction sellArtwork(uint32 artworkId) public {\r\n\t\trequire(msg.sender == artworks[artworkId].player);\r\n\t\tuint256 val = uint256(artworks[artworkId].value);// - sellfee;\r\n\t\tuint16 artworkIndex;\r\n\t\tbool found = false;\r\n\t\tfor (uint16 i = 0; i < numArtworks; i++) {\r\n\t\t\tif (ids[i] == artworkId) {\r\n\t\t\t\tartworkIndex = i;\r\n\t\t\t\tfound = true;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\trequire(found == true);\r\n\t\treplaceArtwork(artworkIndex);\r\n\t\tif (val>0)\r\n\t\t\tlike.transfer(msg.sender,val);\r\n\t\tuint32[] memory artworkIds = new uint32[](1);\r\n\t\tartworkIds[0] = artworkId;\r\n\t\t// tryAutoTriggerSteal();\r\n\t\t// ids.length = numArtworks;\r\n\t\temit newSell(artworkIds, msg.sender, val);\r\n\t}\r\n\t\r\n\t/**\r\n\t * manually triggers the steal ( by oraclize )\r\n\t * */\r\n\tfunction triggerStealManually(uint32 inseconds) public payable ownerOrOperator {\r\n\t\trequire((nextStealTimestamp) < now); // avoid two scheduled callback, asssume max 5mins wait to callback when trigger\r\n\t\ttriggerSteal(inseconds, (oraclizeGas + oraclizeGasExtraArtwork * numArtworks));\r\n\t}\r\n\r\n\t/**\r\n\t * manually triggers the steal ( by our script )\r\n\t * */\r\n\tfunction triggerStealManually2(string result) public payable ownerOrOperator {\r\n\t\tuint gaslimit = gasleft();\r\n\t\toraclizeFee = (gaslimit) * tx.gasprice + oraclizeFee;\r\n\t\trequire(nextStealTimestamp < now); // avoid two scheduled callback, asssume max 5mins wait to callback when trigger\r\n\t\tuint32 howmany;\r\n\t\tuint128 pot;\r\n\t\tuint gasCost;\r\n\t\tuint128 distpot;\r\n\t\tuint oraclizeFeeTmp = 0; // for event log\r\n\t\tif (numArtworks<=1) {\r\n\t\t\tremoveArtworksByString(\"\",0);\r\n\t\t\tdistribute(0);\r\n\t\t\toraclizeFeeTmp = oraclizeFee;\r\n\t\t} else {\r\n\t\t\thowmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10; //do not kill more than 10%, but at least one\r\n\t\t\tpot = removeArtworksByString(result,howmany);\r\n\t\t\tgasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether;\r\n\t\t\tif (pot > gasCost)\r\n\t\t\t\tdistpot = uint128(pot - gasCost);\r\n\t\t\tdistribute(distpot); //distribute the pot minus the oraclize gas costs\r\n\t\t\toraclizeFeeTmp = oraclizeFee;\r\n\t\t\toraclizeFee = 0;\r\n\t\t}\r\n\t\temit newOraclizeCallback(0x0,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin);\r\n\t}\r\n\r\n\t/**\r\n\t * manually triggers the steal ( by our script with specific gas )\r\n\t * */\r\n\tfunction triggerStealManually3(string result,uint gaslimit) public payable ownerOrOperator {\r\n\t\toraclizeFee = (gaslimit) * tx.gasprice + oraclizeFee;\r\n\t\trequire(nextStealTimestamp < now); // avoid two scheduled callback, asssume max 5mins wait to callback when trigger\r\n\t\tuint32 howmany;\r\n\t\tuint128 pot;\r\n\t\tuint gasCost;\r\n\t\tuint128 distpot;\r\n\t\tuint oraclizeFeeTmp = 0; // for event log\r\n\t\tif (numArtworks<=1) {\r\n\t\t\tremoveArtworksByString(\"\",0);\r\n\t\t\tdistribute(0);\r\n\t\t\toraclizeFeeTmp = oraclizeFee;\r\n\t\t} else {\r\n\t\t\thowmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10; //do not kill more than 10%, but at least one\r\n\t\t\tpot = removeArtworksByString(result,howmany);\r\n\t\t\tgasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether;\r\n\t\t\tif (pot > gasCost)\r\n\t\t\t\tdistpot = uint128(pot - gasCost);\r\n\t\t\tdistribute(distpot); //distribute the pot minus the oraclize gas costs\r\n\t\t\toraclizeFeeTmp = oraclizeFee;\r\n\t\t\toraclizeFee = 0;\r\n\t\t}\r\n\t\temit newOraclizeCallback(0x0,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin);\r\n\t}\r\n\r\n\r\n\t/**\r\n\t * the frequency of the thief steal depends on the number of artworks in the game. \r\n\t * many artworks -> many thief steal\r\n\t * */\r\n\tfunction timeTillNextSteal() constant internal returns(uint32) {\r\n\t\treturn (86400 / (1 + numArtworks / 100)) / ( numOfTimesSteal );\r\n\t}\r\n\r\n\t/**\r\n\t * sends a query to oraclize in order to get random numbers in 'inseconds' seconds\r\n\t */\r\n\tfunction triggerSteal(uint32 inseconds, uint gasAmount) internal {\r\n\t\t// Check if we have enough remaining funds\r\n\t\tuint gaslimit = gasleft();\r\n\t\tuint price = oraclize_getPrice(queryType, gasAmount);\r\n\t\tuint balancebefore = address(this).balance;\r\n\t\trequire(price <= address(this).balance);\r\n\t\tif (numArtworks<=1) {\r\n\t\t\tremoveArtworksByString(\"\",0);\r\n\t\t\tdistribute(0);\r\n\t\t\tnextStealId = 0x0;\r\n\t\t\tprice = 0;\r\n\t\t} else {\r\n\t\t\tnextStealId = oraclize_query(nextStealTimestamp, queryType, randomQuery, gasAmount);\r\n\t\t}\r\n\t\temit newTriggerOraclize(nextStealId, inseconds, gasAmount, price, balancebefore, address(this).balance);\r\n\t\toraclizeFee = price + (gaslimit-gasleft() + 200000 /*add gas overhead*/) * tx.gasprice;\r\n\t}\r\n\r\n\t/**\r\n\t * convert a random number to index of artworks list\r\n\t * */\r\n\tfunction findIndexFromRandomNumber(uint32 randomNumbers) internal returns (uint32 artworkId, uint16 index) {\r\n\t\tuint16 indexOldest;\r\n\t\tuint maxNumber;\r\n\t\tuint8 extraProbability;\r\n\t\tif (oldest==0)\r\n\t\t\tlastcombo = 0;\r\n\t\t(artworkId,indexOldest) = setOldest();\r\n\t\tif (lastcombo>oldestExtraStealProbability.length-1)\r\n\t\t\textraProbability = oldestExtraStealProbability[oldestExtraStealProbability.length-1];\r\n\t\telse\r\n\t\t\textraProbability = oldestExtraStealProbability[lastcombo];\r\n\t\tmaxNumber = 100000 - extraProbability*1000;\r\n\t\tif (extraProbability>0 && randomNumbers>maxNumber) {\r\n\t\t\tindex = indexOldest;\r\n\t\t\tartworkId = oldest;\r\n\t\t} else {\r\n\t\t\tindex = mapToNewRange(randomNumbers, numArtworks, maxNumber);\r\n\t\t\tartworkId = ids[index];\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * remove artwork by random number (a string, number list)\r\n\t * */\r\n\tfunction removeArtworksByString(string result,uint32 howmany) internal returns (uint128 pot) {\r\n\t\tuint32[] memory stolenArtworks = new uint32[](howmany);\r\n\t\tuint8[] memory artworkTypes = new uint8[](howmany);\r\n\t\tuint32[] memory sequenceNumbers = new uint32[](howmany);\r\n\t\tuint256[] memory artworkValues = new uint256[](howmany);\r\n\t\taddress[] memory players = new address[](howmany);\r\n\t\tif (howmany>0) {\r\n\t\t\tuint32[] memory randomNumbers = getNumbersFromString(result, \",\", howmany);\r\n\t\t\tuint16 index;\r\n\t\t\tuint32 artworkId;\r\n\t\t\tArtwork memory artworkData;\r\n\t\t\tpot = 0;\r\n\t\t\tif (oldest!=0)\r\n\t\t\t\tlastcombo++;\r\n\t\t\tfor (uint32 i = 0; i < howmany; i++) {\r\n\t\t\t\t(artworkId,index) = findIndexFromRandomNumber(randomNumbers[i]);\r\n\t\t\t\tartworkData = artworks[artworkId];\r\n\t\t\t\tpot += artworkData.value;\r\n\t\t\t\tstolenArtworks[i] = artworkId;\r\n\t\t\t\tartworkTypes[i] = artworkData.artworkType;\r\n\t\t\t\tsequenceNumbers[i] = artworkData.sequenceNumber;\r\n\t\t\t\tartworkValues[i] = artworkData.value;\r\n\t\t\t\tplayers[i] = artworkData.player;\r\n\t\t\t\treplaceArtwork(index);\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tpot = 0;\r\n\t\t}\r\n\t\temit newSteal(now,stolenArtworks,artworkTypes,sequenceNumbers,artworkValues,players);\r\n\t}\r\n\r\n\t/**\r\n\t * oraclize call back\r\n\t * */\r\n\tfunction __callback(bytes32 myid, string result) public {\r\n\t\tuint gaslimit = gasleft();\r\n\t\tuint32 howmany;\r\n\t\tuint128 pot;\r\n\t\tuint gasCost;\r\n\t\tuint128 distpot;\r\n\t\tuint oraclizeFeeTmp = 0; // for event log\r\n\t\tif (msg.sender == oraclize_cbAddress() && myid == nextStealId) {\r\n\t\t\thowmany = numArtworks < 100 ? (numArtworks < 10 ? (numArtworks < 2 ? 0 : 1) : numArtworks / 10) : 10; //do not kill more than 10%, but at least one\r\n\t\t\tpot = removeArtworksByString(result,howmany);\r\n\t\t\tgasCost = ((oraclizeFee * etherExchangeLikeCoin) / 1 ether) * 1 ether + 1 ether/* not floor() */;\r\n\t\t\tif (pot > gasCost)\r\n\t\t\t\tdistpot = uint128(pot - gasCost);\r\n\t\t\tdistribute(distpot); //distribute the pot minus the oraclize gas costs\r\n\t\t\toraclizeFeeTmp = oraclizeFee;\r\n\t\t\toraclizeFee = 0;\r\n\t\t}\r\n\t\temit newOraclizeCallback(myid,result,howmany,pot,distpot,oraclizeFeeTmp,gaslimit,etherExchangeLikeCoin);\r\n\t}\r\n\r\n\t/**\r\n\t * change next steal time\r\n\t * */\r\n\tfunction updateNextStealTime(uint32 inseconds) internal {\r\n\t\tnextStealTimestamp = now + inseconds;\r\n\t}\r\n\r\n\t/** distributes the given amount among the surviving artworks*/\r\n\tfunction distribute(uint128 totalAmount) internal {\r\n\t\tuint32 artworkId;\r\n\t\tuint128 amount = ( totalAmount * 60 ) / 100;\r\n\t\tuint128 valueSum = 0;\r\n\t\tuint128 totalAmountRemain = totalAmount;\r\n\t\tuint128[] memory shares = new uint128[](values.length+1);\r\n\t\tif (totalAmount>0) {\r\n\t\t\t//distribute the rest according to their type\r\n\t\t\tfor (uint8 v = 0; v < values.length; v++) {\r\n\t\t\t\tif (numArtworksXType[v] > 0) valueSum += values[v];\r\n\t\t\t}\r\n\t\t\tfor (uint8 m = 0; m < values.length; m++) {\r\n\t\t\t\tif (numArtworksXType[m] > 0)\r\n\t\t\t\t\tshares[m] = ((amount * (values[m] * 1000 / valueSum) / numArtworksXType[m]) / (1000 ether)) * (1 ether);\r\n\t\t\t}\r\n\t\t\tfor (uint16 i = 0; i < numArtworks; i++) {\r\n\t\t\t\tartworkId = ids[i];\r\n\t\t\t\tamount = shares[artworks[artworkId].artworkType];\r\n\t\t\t\tartworks[artworkId].value += amount;\r\n\t\t\t\ttotalAmountRemain -= amount;\r\n\t\t\t}\r\n\t\t\tsetOldest();\r\n\t\t\tartworks[oldest].value += totalAmountRemain;\r\n\t\t\tshares[shares.length-1] = totalAmountRemain;\t\t\t\r\n\t\t}\r\n\t\tlastStealBlockNumber = block.number;\r\n\t\tupdateNextStealTime(timeTillNextSteal());\r\n\t\temit newStealRewards(totalAmount,shares);\r\n\t}\r\n\r\n\r\n\t\r\n\t/****************** GETTERS *************************/\r\n\r\n\tfunction get30Artworks(uint16 startIndex) public constant returns(uint32[] artworkIds,uint8[] types,uint32[] sequenceNumbers, uint128[] artworkValues,address[] players) {\r\n\t\tuint32 endIndex = startIndex + 30 > numArtworks ? numArtworks : startIndex + 30;\r\n\t\tuint32 id;\r\n\t\tuint32 num = endIndex - startIndex;\r\n\t\tartworkIds = new uint32[](num);\r\n\t\ttypes = new uint8[](num);\r\n\t\tsequenceNumbers = new uint32[](num);\r\n\t\tartworkValues = new uint128[](num);\r\n\t\tplayers = new address[](num);\r\n\t\tuint16 j = 0;\t\t\r\n\t\tfor (uint16 i = startIndex; i < endIndex; i++) {\r\n\t\t\tid = ids[i];\r\n\t\t\tartworkIds[j] = id;\r\n\t\t\ttypes[j] = artworks[id].artworkType;\r\n\t\t\tsequenceNumbers[j] = artworks[id].sequenceNumber;\r\n\t\t\tartworkValues[j] = artworks[id].value;\r\n\t\t\tplayers[j] = artworks[id].player;\r\n\t\t\tj++;\r\n\t\t}\r\n\t}\r\n\r\n\tfunction getRemainTime() public constant returns(uint remainTime) {\r\n\t\tif (nextStealTimestamp>now) remainTime = nextStealTimestamp - now;\r\n\t}\r\n\r\n\t/****************** SETTERS *************************/\r\n\r\n\tfunction setCustomGasPrice(uint gasPrice) public ownerOrOperator {\r\n\t\toraclize_setCustomGasPrice(gasPrice);\r\n\t}\r\n\r\n\tfunction setOraclizeGas(uint32 newGas) public ownerOrOperator {\r\n\t\toraclizeGas = newGas;\r\n\t}\r\n\r\n\tfunction setOraclizeGasExtraArtwork(uint32 newGas) public ownerOrOperator {\r\n\t\toraclizeGasExtraArtwork = newGas;\r\n\t}\r\n\r\n\tfunction setEtherExchangeLikeCoin(uint32 newValue) public ownerOrOperator {\r\n\t\tetherExchangeLikeCoin = newValue;\r\n\t}\r\n\r\n\tfunction setMaxArtworks(uint16 number) public ownerOrOperator {\r\n\t\tmaxArtworks = number;\r\n\t}\r\n\t\r\n\tfunction setNumOfTimesSteal(uint8 adjust) public ownerOrOperator {\r\n\t\tnumOfTimesSteal = adjust;\r\n\t}\r\n\r\n\tfunction updateNextStealTimeByOperator(uint32 inseconds) public ownerOrOperator {\r\n\t\tnextStealTimestamp = now + inseconds;\r\n\t}\r\n\r\n\r\n\t/************* HELPERS ****************/\r\n\r\n\t/**\r\n\t * maps a given number to the new range (old range 100000)\r\n\t * */\r\n\tfunction mapToNewRange(uint number, uint range, uint max) pure internal returns(uint16 randomNumber) {\r\n\t\treturn uint16(number * range / max);\r\n\t}\r\n\r\n\t/**\r\n\t * converts a string of numbers being separated by a given delimiter into an array of numbers (#howmany) \r\n\t */\r\n\tfunction getNumbersFromString(string s, string delimiter, uint32 howmany) public pure returns(uint32[] numbers) {\r\n\t\tvar s2 = s.toSlice();\r\n\t\tvar delim = delimiter.toSlice();\r\n\t\tstring[] memory parts = new string[](s2.count(delim) + 1);\r\n\t\tfor(uint8 i = 0; i < parts.length; i++) {\r\n\t\t\tparts[i] = s2.split(delim).toString();\r\n\t\t}\r\n\t\tnumbers = new uint32[](howmany);\r\n\t\tif (howmany>parts.length) howmany = uint32(parts.length);\r\n\t\tfor (uint8 j = 0; j < howmany; j++) {\r\n\t\t\tnumbers[j] = uint32(parseInt(parts[j]));\r\n\t\t}\r\n\t\treturn numbers;\r\n\t}\r\n\r\n\t/**\r\n\t * likecoin transfer callback \r\n\t */\r\n\tfunction tokenCallback(address _from, uint256 _value, bytes _data) public {\r\n\t\trequire(msg.sender == address(like));\r\n\t\tuint[] memory result;\r\n\t\tuint len;\r\n\t\tassembly {\r\n\t\t\tlen := mload(_data)\r\n\t\t\tlet c := 0\r\n\t\t\tresult := mload(0x40)\r\n\t\t\tfor { let i := 0 } lt(i, len) { i := add(i, 0x20) }\r\n\t\t\t{\r\n\t\t\t\tmstore(add(result, add(i, 0x20)), mload(add(_data, add(i, 0x20))))\r\n\t\t\t\tc := add(c, 1)\r\n\t\t\t}\r\n\t\t\tmstore(result, c)\r\n\t\t\tmstore(0x40, add(result , add(0x20, mul(c, 0x20))))\r\n\t\t}\r\n\t\tuint8[] memory result2 = new uint8[](result.length);\r\n\t\tfor (uint16 j=0;j<result.length; j++) {\r\n\t\t\tresult2[j] = uint8(result[j]);\r\n\t\t}\r\n\t\tgiveArtworks(result2, _from, _value);\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"initOraclize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclizeGasExtraArtwork\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_likeAddr\",\"type\":\"address\"}],\"name\":\"init\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"artworkId\",\"type\":\"uint32\"}],\"name\":\"sellArtwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"artworkId\",\"type\":\"uint32\"}],\"name\":\"getArtwork\",\"outputs\":[{\"name\":\"artworkType\",\"type\":\"uint8\"},{\"name\":\"sequenceNumber\",\"type\":\"uint32\"},{\"name\":\"value\",\"type\":\"uint128\"},{\"name\":\"player\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numArtworks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"adjust\",\"type\":\"uint8\"}],\"name\":\"setNumOfTimesSteal\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"result\",\"type\":\"string\"},{\"name\":\"gaslimit\",\"type\":\"uint256\"}],\"name\":\"triggerStealManually3\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint128\"}],\"name\":\"collectFees\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastcombo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_costs\",\"type\":\"uint128[]\"}],\"name\":\"setCosts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oldest\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclizeGas\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"costs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"oraclizeFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"numOfTimesSteal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inseconds\",\"type\":\"uint32\"}],\"name\":\"updateNextStealTimeByOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllArtworksByOwner\",\"outputs\":[{\"name\":\"artworkIds\",\"type\":\"uint32[]\"},{\"name\":\"types\",\"type\":\"uint8[]\"},{\"name\":\"sequenceNumbers\",\"type\":\"uint32[]\"},{\"name\":\"artworkValues\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"values\",\"outputs\":[{\"name\":\"\",\"type\":\"uint128\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[{\"name\":\"res\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherExchangeLikeCoin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"tokenCallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getNumArtworksXType\",\"outputs\":[{\"name\":\"_numArtworksXType\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newGas\",\"type\":\"uint32\"}],\"name\":\"setOraclizeGasExtraArtwork\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getOldest\",\"outputs\":[{\"name\":\"artworkId\",\"type\":\"uint32\"},{\"name\":\"artworkType\",\"type\":\"uint8\"},{\"name\":\"sequenceNumber\",\"type\":\"uint32\"},{\"name\":\"value\",\"type\":\"uint128\"},{\"name\":\"player\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newGas\",\"type\":\"uint32\"}],\"name\":\"setOraclizeGas\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAllArtworks\",\"outputs\":[{\"name\":\"artworkIds\",\"type\":\"uint32[]\"},{\"name\":\"types\",\"type\":\"uint8[]\"},{\"name\":\"sequenceNumbers\",\"type\":\"uint32[]\"},{\"name\":\"artworkValues\",\"type\":\"uint128[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newValue\",\"type\":\"uint32\"}],\"name\":\"setEtherExchangeLikeCoin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"number\",\"type\":\"uint16\"}],\"name\":\"setMaxArtworks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"triggerStealManually2\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"maxArtworks\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"like\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextStealTimestamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"s\",\"type\":\"string\"},{\"name\":\"delimiter\",\"type\":\"string\"},{\"name\":\"howmany\",\"type\":\"uint32\"}],\"name\":\"getNumbersFromString\",\"outputs\":[{\"name\":\"numbers\",\"type\":\"uint32[]\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"startIndex\",\"type\":\"uint16\"}],\"name\":\"get30Artworks\",\"outputs\":[{\"name\":\"artworkIds\",\"type\":\"uint32[]\"},{\"name\":\"types\",\"type\":\"uint8[]\"},{\"name\":\"sequenceNumbers\",\"type\":\"uint32[]\"},{\"name\":\"artworkValues\",\"type\":\"uint128[]\"},{\"name\":\"players\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"oldestExtraStealProbability\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"gasPrice\",\"type\":\"uint256\"}],\"name\":\"setCustomGasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_fee\",\"type\":\"uint8\"}],\"name\":\"setFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inseconds\",\"type\":\"uint32\"}],\"name\":\"triggerStealManually\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastStealBlockNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"init1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"ids\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getRemainTime\",\"outputs\":[{\"name\":\"remainTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"startId\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"artworkTypes\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"startSequenceNumbers\",\"type\":\"uint32[]\"}],\"name\":\"newPurchase\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timestamp\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"stolenArtworks\",\"type\":\"uint32[]\"},{\"indexed\":false,\"name\":\"artworkTypes\",\"type\":\"uint8[]\"},{\"indexed\":false,\"name\":\"sequenceNumbers\",\"type\":\"uint32[]\"},{\"indexed\":false,\"name\":\"values\",\"type\":\"uint256[]\"},{\"indexed\":false,\"name\":\"players\",\"type\":\"address[]\"}],\"name\":\"newSteal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"total\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"values\",\"type\":\"uint128[]\"}],\"name\":\"newStealRewards\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"artworkId\",\"type\":\"uint32[]\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"newSell\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nextStealId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"waittime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gasAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balancebefore\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"balance\",\"type\":\"uint256\"}],\"name\":\"newTriggerOraclize\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"nextStealId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"result\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"killed\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"killedValue\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"distValue\",\"type\":\"uint128\"},{\"indexed\":false,\"name\":\"oraclizeFee\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"gaslimit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"exchange\",\"type\":\"uint256\"}],\"name\":\"newOraclizeCallback\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"ArtMuseumV1","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8b5609afc8d2cfbd18d8041921ced51c871026181349dd276613242388b5256a"}]}