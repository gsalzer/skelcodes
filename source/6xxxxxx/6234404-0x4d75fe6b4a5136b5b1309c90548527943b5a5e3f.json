{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n// File: contracts/BytesUtils.sol\r\n\r\nlibrary BytesUtils {\r\n    /*\r\n    * @dev Returns the keccak-256 hash of a byte range.\r\n    * @param self The byte string to hash.\r\n    * @param offset The position to start hashing at.\r\n    * @param len The number of bytes to hash.\r\n    * @return The hash of the byte range.\r\n    */\r\n    function keccak(bytes memory self, uint offset, uint len) internal pure returns (bytes32 ret) {\r\n        require(offset + len <= self.length);\r\n        assembly {\r\n            ret := sha3(add(add(self, 32), offset), len)\r\n        }\r\n    }\r\n\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal.\r\n    * @param self The first bytes to compare.\r\n    * @param other The second bytes to compare.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, bytes memory other) internal pure returns (int) {\r\n        return compare(self, 0, self.length, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns a positive number if `other` comes lexicographically after\r\n    *      `self`, a negative number if it comes before, or zero if the\r\n    *      contents of the two bytes are equal. Comparison is done per-rune,\r\n    *      on unicode codepoints.\r\n    * @param self The first bytes to compare.\r\n    * @param offset The offset of self.\r\n    * @param len    The length of self.\r\n    * @param other The second bytes to compare.\r\n    * @param otheroffset The offset of the other string.\r\n    * @param otherlen    The length of the other string.\r\n    * @return The result of the comparison.\r\n    */\r\n    function compare(bytes memory self, uint offset, uint len, bytes memory other, uint otheroffset, uint otherlen) internal pure returns (int) {\r\n        uint shortest = len;\r\n        if (otherlen < len)\r\n        shortest = otherlen;\r\n\r\n        uint selfptr;\r\n        uint otherptr;\r\n\r\n        assembly {\r\n            selfptr := add(self, add(offset, 32))\r\n            otherptr := add(other, add(otheroffset, 32))\r\n        }\r\n        for (uint idx = 0; idx < shortest; idx += 32) {\r\n            uint a;\r\n            uint b;\r\n            assembly {\r\n                a := mload(selfptr)\r\n                b := mload(otherptr)\r\n            }\r\n            if (a != b) {\r\n                // Mask out irrelevant bytes and check again\r\n                uint mask;\r\n                if (shortest > 32) {\r\n                    mask = uint256(- 1); // aka 0xffffff....\r\n                } else {\r\n                    mask = ~(2 ** (8 * (32 - shortest + idx)) - 1);\r\n                }\r\n                uint diff = (a & mask) - (b & mask);\r\n                if (diff != 0)\r\n                return int(diff);\r\n            }\r\n            selfptr += 32;\r\n            otherptr += 32;\r\n        }\r\n\r\n        return int(len) - int(otherlen);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @param len The number of bytes to compare\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset, uint len) internal pure returns (bool) {\r\n        return keccak(self, offset, len) == keccak(other, otherOffset, len);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal with offsets.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @param otherOffset The offset into the second byte range.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other, uint otherOffset) internal pure returns (bool) {\r\n        return keccak(self, offset, self.length - offset) == keccak(other, otherOffset, other.length - otherOffset);\r\n    }\r\n\r\n    /*\r\n    * @dev Compares a range of 'self' to all of 'other' and returns True iff\r\n    *      they are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param offset The offset into the first byte range.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, uint offset, bytes memory other) internal pure returns (bool) {\r\n        return self.length >= offset + other.length && equals(self, offset, other, 0, other.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns true if the two byte ranges are equal.\r\n    * @param self The first byte range to compare.\r\n    * @param other The second byte range to compare.\r\n    * @return True if the byte ranges are equal, false otherwise.\r\n    */\r\n    function equals(bytes memory self, bytes memory other) internal pure returns(bool) {\r\n        return self.length == other.length && equals(self, 0, other, 0, self.length);\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 8-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 8 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint8(bytes memory self, uint idx) internal pure returns (uint8 ret) {\r\n        require(idx + 1 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 1), idx)), 0xFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 16-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 16 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint16(bytes memory self, uint idx) internal pure returns (uint16 ret) {\r\n        require(idx + 2 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 2), idx)), 0xFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32-bit number at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bits of the string, interpreted as an integer.\r\n    */\r\n    function readUint32(bytes memory self, uint idx) internal pure returns (uint32 ret) {\r\n        require(idx + 4 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 4), idx)), 0xFFFFFFFF)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes32(bytes memory self, uint idx) internal pure returns (bytes32 ret) {\r\n        require(idx + 32 <= self.length);\r\n        assembly {\r\n            ret := mload(add(add(self, 32), idx))\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the 32 byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytes20(bytes memory self, uint idx) internal pure returns (bytes20 ret) {\r\n        require(idx + 20 <= self.length);\r\n        assembly {\r\n            ret := and(mload(add(add(self, 32), idx)), 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000000)\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Returns the n byte value at the specified index of self.\r\n    * @param self The byte string.\r\n    * @param idx The index into the bytes.\r\n    * @param len The number of bytes.\r\n    * @return The specified 32 bytes of the string.\r\n    */\r\n    function readBytesN(bytes memory self, uint idx, uint len) internal pure returns (bytes20 ret) {\r\n        require(idx + len <= self.length);\r\n        assembly {\r\n            let mask := not(sub(exp(256, sub(32, len)), 1))\r\n            ret := and(mload(add(add(self, 32), idx)),  mask)\r\n        }\r\n    }\r\n\r\n    function memcpy(uint dest, uint src, uint len) private pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /*\r\n    * @dev Copies a substring into a new byte string.\r\n    * @param self The byte string to copy from.\r\n    * @param offset The offset to start copying at.\r\n    * @param len The number of bytes to copy.\r\n    */\r\n    function substring(bytes memory self, uint offset, uint len) internal pure returns(bytes) {\r\n        require(offset + len <= self.length);\r\n\r\n        bytes memory ret = new bytes(len);\r\n        uint dest;\r\n        uint src;\r\n\r\n        assembly {\r\n            dest := add(ret, 32)\r\n            src := add(add(self, 32), offset)\r\n        }\r\n        memcpy(dest, src, len);\r\n\r\n        return ret;\r\n    }\r\n\r\n    // Maps characters from 0x30 to 0x7A to their base32 values.\r\n    // 0xFF represents invalid characters in that range.\r\n    bytes constant base32HexTable = hex'00010203040506070809FFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1FFFFFFFFFFFFFFFFFFFFF0A0B0C0D0E0F101112131415161718191A1B1C1D1E1F';\r\n\r\n    /**\r\n     * @dev Decodes unpadded base32 data of up to one word in length.\r\n     * @param self The data to decode.\r\n     * @param off Offset into the string to start at.\r\n     * @param len Number of characters to decode.\r\n     * @return The decoded data, left aligned.\r\n     */\r\n    function base32HexDecodeWord(bytes memory self, uint off, uint len) internal pure returns(bytes32) {\r\n        require(len <= 52);\r\n\r\n        uint ret = 0;\r\n        for(uint i = 0; i < len; i++) {\r\n            byte char = self[off + i];\r\n            require(char >= 0x30 && char <= 0x7A);\r\n            uint8 decoded = uint8(base32HexTable[uint(char) - 0x30]);\r\n            require(decoded <= 0x20);\r\n            if(i == len - 1) {\r\n                break;\r\n            }\r\n            ret = (ret << 5) | decoded;\r\n        }\r\n\r\n        uint bitlen = len * 5;\r\n        if(len % 8 == 0) {\r\n            // Multiple of 8 characters, no padding\r\n            ret = (ret << 5) | decoded;\r\n        } else if(len % 8 == 2) {\r\n            // Two extra characters - 1 byte\r\n            ret = (ret << 3) | (decoded >> 2);\r\n            bitlen -= 2;\r\n        } else if(len % 8 == 4) {\r\n            // Four extra characters - 2 bytes\r\n            ret = (ret << 1) | (decoded >> 4);\r\n            bitlen -= 4;\r\n        } else if(len % 8 == 5) {\r\n            // Five extra characters - 3 bytes\r\n            ret = (ret << 4) | (decoded >> 1);\r\n            bitlen -= 1;\r\n        } else if(len % 8 == 7) {\r\n            // Seven extra characters - 4 bytes\r\n            ret = (ret << 2) | (decoded >> 3);\r\n            bitlen -= 3;\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        return bytes32(ret << (256 - bitlen));\r\n    }\r\n}\r\n\r\n// File: contracts/algorithms/Algorithm.sol\r\n\r\n/**\r\n* @dev An interface for contracts implementing a DNSSEC (signing) algorithm.\r\n*/\r\ninterface Algorithm {\r\n    /**\r\n    * @dev Verifies a signature.\r\n    * @param key The public key to verify with.\r\n    * @param data The signed data to verify.\r\n    * @param signature The signature to verify.\r\n    * @return True iff the signature is valid.\r\n    */\r\n    function verify(bytes key, bytes data, bytes signature) external view returns (bool);\r\n}\r\n\r\n// File: @ensdomains/buffer/contracts/Buffer.sol\r\n\r\n/**\r\n* @dev A library for working with mutable byte buffers in Solidity.\r\n*\r\n* Byte buffers are mutable and expandable, and provide a variety of primitives\r\n* for writing to them. At any time you can fetch a bytes object containing the\r\n* current contents of the buffer. The bytes object should not be stored between\r\n* operations, as it may change due to resizing of the buffer.\r\n*/\r\nlibrary Buffer {\r\n    /**\r\n    * @dev Represents a mutable buffer. Buffers have a current value (buf) and\r\n    *      a capacity. The capacity may be longer than the current value, in\r\n    *      which case it can be extended without the need to allocate more memory.\r\n    */\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a buffer with an initial capacity.\r\n    * @param buf The buffer to initialize.\r\n    * @param capacity The number of bytes of space to allocate the buffer.\r\n    * @return The buffer, for chaining.\r\n    */\r\n    function init(buffer memory buf, uint capacity) internal pure returns(buffer memory) {\r\n        if (capacity % 32 != 0) {\r\n            capacity += 32 - (capacity % 32);\r\n        }\r\n        // Allocate space for the buffer data\r\n        buf.capacity = capacity;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(buf, ptr)\r\n            mstore(ptr, 0)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Initializes a new buffer from an existing bytes object.\r\n    *      Changes to the buffer may mutate the original value.\r\n    * @param b The bytes object to initialize the buffer with.\r\n    * @return A new buffer.\r\n    */\r\n    function fromBytes(bytes b) internal pure returns(buffer memory) {\r\n        buffer memory buf;\r\n        buf.buf = b;\r\n        buf.capacity = b.length;\r\n        return buf;\r\n    }\r\n\r\n    function resize(buffer memory buf, uint capacity) private pure {\r\n        bytes memory oldbuf = buf.buf;\r\n        init(buf, capacity);\r\n        append(buf, oldbuf);\r\n    }\r\n\r\n    function max(uint a, uint b) private pure returns(uint) {\r\n        if (a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    /**\r\n    * @dev Sets buffer length to 0.\r\n    * @param buf The buffer to truncate.\r\n    * @return The original buffer, for chaining..\r\n    */\r\n    function truncate(buffer memory buf) internal pure returns (buffer memory) {\r\n        assembly {\r\n            let bufptr := mload(buf)\r\n            mstore(bufptr, 0)\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The start offset to write to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes data, uint len) internal pure returns(buffer memory) {\r\n        require(len <= data.length);\r\n\r\n        if (off + len + buf.buf.length > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len + off) * 2);\r\n        }\r\n\r\n        uint dest;\r\n        uint src;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Start address = buffer address + offset + sizeof(buffer length)\r\n            dest := add(add(bufptr, 32), off)\r\n            // Update buffer length if we're extending it\r\n            if gt(add(len, off), buflen) {\r\n                mstore(bufptr, add(len, off))\r\n            }\r\n            src := add(data, 32)\r\n        }\r\n\r\n        // Copy word-length chunks while possible\r\n        for (; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to copy.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes data, uint len) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, len);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte string to a buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function append(buffer memory buf, bytes data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, data.length);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write the byte at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeUint8(buffer memory buf, uint off, uint8 data) internal pure returns(buffer memory) {\r\n        if (off > buf.capacity) {\r\n            resize(buf, buf.capacity * 2);\r\n        }\r\n\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + sizeof(buffer length) + off\r\n            let dest := add(add(bufptr, off), 32)\r\n            mstore8(dest, data)\r\n            // Update buffer length if we extended it\r\n            if eq(off, buflen) {\r\n                mstore(bufptr, add(buflen, 1))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a byte to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendUint8(buffer memory buf, uint8 data) internal pure returns(buffer memory) {\r\n        return writeUint8(buf, buf.buf.length, data);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes up to 32 bytes to the buffer. Resizes if doing so would\r\n    *      exceed the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (left-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function write(buffer memory buf, uint off, bytes32 data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        // Right-align data\r\n        data = data >> (8 * (32 - len));\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + sizeof(buffer length) + off + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n    * @dev Writes a bytes20 to the buffer. Resizes if doing so would exceed the\r\n    *      capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeBytes20(buffer memory buf, uint off, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, off, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes20 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chhaining.\r\n    */\r\n    function appendBytes20(buffer memory buf, bytes20 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, bytes32(data), 20);\r\n    }\r\n\r\n    /**\r\n    * @dev Appends a bytes32 to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param data The data to append.\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function appendBytes32(buffer memory buf, bytes32 data) internal pure returns (buffer memory) {\r\n        return write(buf, buf.buf.length, data, 32);\r\n    }\r\n\r\n    /**\r\n    * @dev Writes an integer to the buffer. Resizes if doing so would exceed\r\n    *      the capacity of the buffer.\r\n    * @param buf The buffer to append to.\r\n    * @param off The offset to write at.\r\n    * @param data The data to append.\r\n    * @param len The number of bytes to write (right-aligned).\r\n    * @return The original buffer, for chaining.\r\n    */\r\n    function writeInt(buffer memory buf, uint off, uint data, uint len) private pure returns(buffer memory) {\r\n        if (len + off > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len + off) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Address = buffer address + off + sizeof(buffer length) + len\r\n            let dest := add(add(bufptr, off), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length if we extended it\r\n            if gt(add(off, len), mload(bufptr)) {\r\n                mstore(bufptr, add(off, len))\r\n            }\r\n        }\r\n        return buf;\r\n    }\r\n}\r\n\r\n// File: contracts/algorithms/ModexpPrecompile.sol\r\n\r\nlibrary ModexpPrecompile {\r\n    using Buffer for *;\r\n\r\n    /**\r\n    * @dev Computes (base ^ exponent) % modulus over big numbers.\r\n    */\r\n    function modexp(bytes memory base, bytes memory exponent, bytes memory modulus) internal view returns (bool success, bytes memory output) {\r\n        uint size = (32 * 3) + base.length + exponent.length + modulus.length;\r\n\r\n        Buffer.buffer memory input;\r\n        input.init(size);\r\n\r\n        input.appendBytes32(bytes32(base.length));\r\n        input.appendBytes32(bytes32(exponent.length));\r\n        input.appendBytes32(bytes32(modulus.length));\r\n        input.append(base);\r\n        input.append(exponent);\r\n        input.append(modulus);\r\n\r\n        output = new bytes(modulus.length);\r\n\r\n        assembly {\r\n            success := staticcall(gas(), 5, add(mload(input), 32), size, add(output, 32), mload(modulus))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/algorithms/RSAVerify.sol\r\n\r\nlibrary RSAVerify {\r\n    /**\r\n    * @dev Recovers the input data from an RSA signature, returning the result in S.\r\n    * @param N The RSA public modulus.\r\n    * @param E The RSA public exponent.\r\n    * @param S The signature to recover.\r\n    * @return True if the recovery succeeded.\r\n    */\r\n    function rsarecover(bytes memory N, bytes memory E, bytes memory S) internal view returns (bool, bytes memory) {\r\n        return ModexpPrecompile.modexp(S, E, N);\r\n    }\r\n}\r\n\r\n// File: @ensdomains/solsha1/contracts/SHA1.sol\r\n\r\nlibrary SHA1 {\r\n    event Debug(bytes32 x);\r\n\r\n    function sha1(bytes data) internal pure returns(bytes20 ret) {\r\n        assembly {\r\n            // Get a safe scratch location\r\n            let scratch := mload(0x40)\r\n\r\n            // Get the data length, and point data at the first byte\r\n            let len := mload(data)\r\n            data := add(data, 32)\r\n\r\n            // Find the length after padding\r\n            let totallen := add(and(add(len, 1), 0xFFFFFFFFFFFFFFC0), 64)\r\n            switch lt(sub(totallen, len), 9)\r\n            case 1 { totallen := add(totallen, 64) }\r\n\r\n            let h := 0x6745230100EFCDAB890098BADCFE001032547600C3D2E1F0\r\n\r\n            function readword(ptr, off, count) -> result {\r\n                result := 0\r\n                if lt(off, count) {\r\n                    result := mload(add(ptr, off))\r\n                    count := sub(count, off)\r\n                    if lt(count, 32) {\r\n                        let mask := not(sub(exp(256, sub(32, count)), 1))\r\n                        result := and(result, mask)\r\n                    }\r\n                }\r\n            }\r\n\r\n            for { let i := 0 } lt(i, totallen) { i := add(i, 64) } {\r\n                mstore(scratch, readword(data, i, len))\r\n                mstore(add(scratch, 32), readword(data, add(i, 32), len))\r\n\r\n                // If we loaded the last byte, store the terminator byte\r\n                switch lt(sub(len, i), 64)\r\n                case 1 { mstore8(add(scratch, sub(len, i)), 0x80) }\r\n\r\n                // If this is the last block, store the length\r\n                switch eq(i, sub(totallen, 64))\r\n                case 1 { mstore(add(scratch, 32), or(mload(add(scratch, 32)), mul(len, 8))) }\r\n\r\n                // Expand the 16 32-bit words into 80\r\n                for { let j := 64 } lt(j, 128) { j := add(j, 12) } {\r\n                    let temp := xor(xor(mload(add(scratch, sub(j, 12))), mload(add(scratch, sub(j, 32)))), xor(mload(add(scratch, sub(j, 56))), mload(add(scratch, sub(j, 64)))))\r\n                    temp := or(and(mul(temp, 2), 0xFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFEFFFFFFFE), and(div(temp, 0x80000000), 0x0000000100000001000000010000000100000001000000010000000100000001))\r\n                    mstore(add(scratch, j), temp)\r\n                }\r\n                for { let j := 128 } lt(j, 320) { j := add(j, 24) } {\r\n                    let temp := xor(xor(mload(add(scratch, sub(j, 24))), mload(add(scratch, sub(j, 64)))), xor(mload(add(scratch, sub(j, 112))), mload(add(scratch, sub(j, 128)))))\r\n                    temp := or(and(mul(temp, 4), 0xFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFCFFFFFFFC), and(div(temp, 0x40000000), 0x0000000300000003000000030000000300000003000000030000000300000003))\r\n                    mstore(add(scratch, j), temp)\r\n                }\r\n\r\n                let x := h\r\n                let f := 0\r\n                let k := 0\r\n                for { let j := 0 } lt(j, 80) { j := add(j, 1) } {\r\n                    switch div(j, 20)\r\n                    case 0 {\r\n                        // f = d xor (b and (c xor d))\r\n                        f := xor(div(x, 0x100000000000000000000), div(x, 0x10000000000))\r\n                        f := and(div(x, 0x1000000000000000000000000000000), f)\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0x5A827999\r\n                    }\r\n                    case 1{\r\n                        // f = b xor c xor d\r\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0x6ED9EBA1\r\n                    }\r\n                    case 2 {\r\n                        // f = (b and c) or (d and (b or c))\r\n                        f := or(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := and(div(x, 0x10000000000), f)\r\n                        f := or(and(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000)), f)\r\n                        k := 0x8F1BBCDC\r\n                    }\r\n                    case 3 {\r\n                        // f = b xor c xor d\r\n                        f := xor(div(x, 0x1000000000000000000000000000000), div(x, 0x100000000000000000000))\r\n                        f := xor(div(x, 0x10000000000), f)\r\n                        k := 0xCA62C1D6\r\n                    }\r\n                    // temp = (a leftrotate 5) + f + e + k + w[i]\r\n                    let temp := and(div(x, 0x80000000000000000000000000000000000000000000000), 0x1F)\r\n                    temp := or(and(div(x, 0x800000000000000000000000000000000000000), 0xFFFFFFE0), temp)\r\n                    temp := add(f, temp)\r\n                    temp := add(and(x, 0xFFFFFFFF), temp)\r\n                    temp := add(k, temp)\r\n                    temp := add(div(mload(add(scratch, mul(j, 4))), 0x100000000000000000000000000000000000000000000000000000000), temp)\r\n                    x := or(div(x, 0x10000000000), mul(temp, 0x10000000000000000000000000000000000000000))\r\n                    x := or(and(x, 0xFFFFFFFF00FFFFFFFF000000000000FFFFFFFF00FFFFFFFF), mul(or(and(div(x, 0x4000000000000), 0xC0000000), and(div(x, 0x400000000000000000000), 0x3FFFFFFF)), 0x100000000000000000000))\r\n                }\r\n\r\n                h := and(add(h, x), 0xFFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF00FFFFFFFF)\r\n            }\r\n            ret := mul(or(or(or(or(and(div(h, 0x100000000), 0xFFFFFFFF00000000000000000000000000000000), and(div(h, 0x1000000), 0xFFFFFFFF000000000000000000000000)), and(div(h, 0x10000), 0xFFFFFFFF0000000000000000)), and(div(h, 0x100), 0xFFFFFFFF00000000)), and(h, 0xFFFFFFFF)), 0x1000000000000000000000000)\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/algorithms/RSASHA1Algorithm.sol\r\n\r\n/**\r\n* @dev Implements the DNSSEC RSASHA1 algorithm.\r\n*/\r\ncontract RSASHA1Algorithm is Algorithm {\r\n    using BytesUtils for *;\r\n\r\n    function verify(bytes key, bytes data, bytes sig) external view returns (bool) {\r\n        bytes memory exponent;\r\n        bytes memory modulus;\r\n\r\n        uint16 exponentLen = uint16(key.readUint8(4));\r\n        if (exponentLen != 0) {\r\n            exponent = key.substring(5, exponentLen);\r\n            modulus = key.substring(exponentLen + 5, key.length - exponentLen - 5);\r\n        } else {\r\n            exponentLen = key.readUint16(5);\r\n            exponent = key.substring(7, exponentLen);\r\n            modulus = key.substring(exponentLen + 7, key.length - exponentLen - 7);\r\n        }\r\n\r\n        // Recover the message from the signature\r\n        bool ok;\r\n        bytes memory result;\r\n        (ok, result) = RSAVerify.rsarecover(modulus, exponent, sig);\r\n\r\n        // Verify it ends with the hash of our data\r\n        return ok && SHA1.sha1(data) == result.readBytes20(result.length - 20);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"key\",\"type\":\"bytes\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"sig\",\"type\":\"bytes\"}],\"name\":\"verify\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"RSASHA1Algorithm","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://00377e99a5dcf38ad2b94ea7dfd05275f942cc30bed9aa8a194a89fbd3093bec"}]}