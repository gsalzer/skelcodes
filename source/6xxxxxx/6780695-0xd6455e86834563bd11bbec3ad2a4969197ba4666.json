{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    constructor() \r\n    public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) \r\n        onlyOwner \r\n    public {\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ReailtioSafeMath256\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary RealitioSafeMath256 {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    uint256 c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/*\r\nThis contract allows you to split ETH between up to 100 receivers.\r\n\r\nEach receiver can withdraw their own share of the funds without the cooperation of the others. \r\nThey can also replace their own address with a different one.\r\n\r\nThe receivers can be added by the `owner` contract, for example a multisig wallet. \r\nThe same receiver can be added multiple times if you want an unequal distribution.\r\nTransfer ownership to 0x0 if you want to lock the receiver list and prevent further changes.\r\n\r\nThis contract receives ETH normally, without using extra gas that could cause incoming payments to fail.\r\nAnyone can then call allocate() to assign any unassigned balance to the receivers.\r\nThe `allocate()` call may leave a small amount of ETH unassigned due to rounding. This can be allocated in a future call.\r\n\r\nOnce funds are allocated, each party can withdraw their own funds by calling `withdraw()`.\r\n*/\r\n\r\ncontract SplitterWallet is Owned {\r\n\r\n    // We sometimes loop over our recipient list, so set a maximum to avoid gas exhaustion\r\n    uint256 constant MAX_RECIPIENTS = 100;\r\n\r\n    using RealitioSafeMath256 for uint256;\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    \r\n    // Sum of all balances in balanceOf\r\n    uint256 public balanceTotal; \r\n\r\n    // List of recipients. May contain duplicates to get paid twice.\r\n    address[] public recipients;\r\n\r\n    event LogWithdraw(\r\n        address indexed user,\r\n        uint256 amount\r\n    );\r\n\r\n    function _firstRecipientIndex(address addr) \r\n        internal\r\n    view returns (uint256) \r\n    {\r\n        uint256 i;\r\n        for(i=0; i<recipients.length; i++) {\r\n            if (recipients[i] == addr) {\r\n                return i;\r\n            }\r\n        }\r\n        revert(\"Recipient not found\");\r\n    }\r\n\r\n    /// @notice Add a recipient to the list\r\n    /// @param addr The address to add\r\n    /// @dev Doesn't check for duplicates, it's OK to add the same recipient twice for an unequal distribution\r\n    function addRecipient(address addr) \r\n        onlyOwner\r\n    external {\r\n        require(recipients.length < MAX_RECIPIENTS, \"Too many recipients\");\r\n        recipients.push(addr);\r\n    }\r\n\r\n    /// @notice Remove a recipient from the list\r\n    /// @param old_addr The address to remove\r\n    /// @dev If your address shows up more than once, removes the first occurance\r\n    function removeRecipient(address old_addr) \r\n        onlyOwner\r\n    external {\r\n\r\n        uint256 idx = _firstRecipientIndex(old_addr);\r\n        assert(recipients[idx] == old_addr);\r\n\r\n        // If you're not deleting the last item, copy the last item over to the thing you're deleting\r\n        uint256 last_idx = recipients.length - 1;\r\n        if (idx != last_idx) {\r\n            recipients[idx] = recipients[last_idx];\r\n        }\r\n\r\n        recipients.length--;\r\n    }\r\n\r\n    /// @notice Replace your own address with a different one\r\n    /// @param new_addr The new address\r\n    /// @dev If your address shows up more than once, replaces the first occurance\r\n    function replaceSelf(address new_addr) \r\n    external {\r\n        uint256 idx = _firstRecipientIndex(msg.sender);\r\n        assert(recipients[idx] == msg.sender);\r\n        recipients[idx] = new_addr;\r\n    }\r\n\r\n    /// @notice Allocate any unallocated funds from the contract balance\r\n    /// @dev Any time the contract gets funds, they will appear as unallocated\r\n    /// @dev Assign them to the current recipients, and mark them as allocated\r\n    function allocate()\r\n    external {\r\n\r\n        uint256 unallocated = address(this).balance.sub(balanceTotal);\r\n        require(unallocated > 0, \"No funds to allocate\");\r\n\r\n        uint256 num_recipients = recipients.length;\r\n\r\n        // NB Rounding may leave some funds unallocated, we can claim them later\r\n        uint256 each = unallocated / num_recipients;\r\n        require(each > 0, \"No money left to be allocated after rounding down\");\r\n\r\n        uint256 i;\r\n        for (i=0; i<num_recipients; i++) {\r\n            address recip = recipients[i];\r\n            balanceOf[recip] = balanceOf[recip].add(each);\r\n            balanceTotal = balanceTotal.add(each);\r\n        }\r\n\r\n        assert(address(this).balance >= balanceTotal);\r\n\r\n    }\r\n\r\n    /// @notice Withdraw the address balance to the owner account\r\n    function withdraw() \r\n    external {\r\n\r\n        uint256 bal = balanceOf[msg.sender];\r\n        require(bal > 0, \"Balance must be positive\");\r\n\r\n        balanceTotal = balanceTotal.sub(bal);\r\n        balanceOf[msg.sender] = 0;\r\n        msg.sender.transfer(bal);\r\n\r\n        emit LogWithdraw(msg.sender, bal);\r\n\r\n        assert(address(this).balance >= balanceTotal);\r\n\r\n    }\r\n\r\n    function()\r\n    external payable {\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"old_addr\",\"type\":\"address\"}],\"name\":\"removeRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"addRecipient\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"balanceTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"new_addr\",\"type\":\"address\"}],\"name\":\"replaceSelf\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"allocate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"recipients\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogWithdraw\",\"type\":\"event\"}]","ContractName":"SplitterWallet","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8fc37da673ce00d08b8cd9cae34fa14f7b4c8a9e6177e23052775e97e89d33cf"}]}