{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.21;\r\n\r\n/**\r\n *   @title SafeMath\r\n *   @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *   @title ERC20\r\n *   @dev Standart ERC20 token interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address _owner) public constant returns(uint256);\r\n    function transfer(address _to, uint256 _value) public returns(bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\r\n    function approve(address _spender, uint256 _value) public returns(bool);\r\n    function allowance(address _owner, address _spender) public constant returns(uint256);\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/**\r\n *   @dev CRET token contract\r\n */\r\ncontract WbcToken is ERC20 {\r\n    using SafeMath for uint256;\r\n    string public name = \"WhizBizCoin\";\r\n    string public symbol = \"WB\";\r\n    uint256 public decimals = 18;\r\n    uint256 public totalSupply = 888000000 * 1e18;\r\n    uint256 public timeStamp = 0;\r\n    uint256 constant fundPartYear = 44400000 * 1e18; \r\n    uint256 constant trioPartYear = 8880000 * 1e18; //1% of tokens for CrowdSale, Film Comany and Investors in one year for 6 years\r\n    uint256 constant minimumAge = 30 days; // minimum age for coins\r\n    uint256 constant oneYear = 360 days;\r\n    uint256 public minted = 0;\r\n    address public teamCSN;\r\n    address public teamFilmCompany;\r\n    address public teamInvestors;\r\n    address public teamFund;\r\n    address public manager;\r\n    address public reserveFund;\r\n    \r\n    struct transferStruct{\r\n    uint128 amount;\r\n    uint64 time;\r\n    }\r\n    \r\n    mapping(uint8 => bool) trioChecker;\r\n    mapping(uint8 => bool) fundChecker;\r\n    mapping(uint256 => bool) priceChecker;\r\n    mapping(address => transferStruct[]) transferSt;\r\n    mapping(uint256 => uint256) coinPriceNow;\r\n\r\n    // Ico contract address\r\n    address public owner;\r\n\r\n    // Allows execution by the owner only\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyManager {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n    \r\n    \r\n    \r\n    constructor (address _owner, address _teamCSN, address _teamFilmCompany, address _teamInvestors, address _fund, address _manager, address _reserveFund) public {\r\n        owner = _owner;\r\n        teamCSN = _teamCSN;\r\n        teamFilmCompany = _teamFilmCompany;\r\n        teamInvestors = _teamInvestors;\r\n        teamFund = _fund;\r\n        manager = _manager;\r\n        reserveFund = _reserveFund;\r\n\r\n    }\r\n    \r\n    \r\n    function doTimeStamp(uint256 _value) external onlyOwner {\r\n        timeStamp = _value;\r\n    }\r\n    \r\n    \r\n\r\n   /**\r\n    *   @dev Mint tokens\r\n    *   @param _investor     address the tokens will be issued to\r\n    *   @param _value        number of tokens\r\n    */\r\n    function mintTokens(address _investor, uint256 _value) external onlyOwner {\r\n        require(_value > 0);\r\n        require(minted.add(_value) <= totalSupply);\r\n        balances[_investor] = balances[_investor].add(_value);\r\n        minted = minted.add(_value);\r\n        transferSt[_investor].push(transferStruct(uint128(_value),uint64(now)));\r\n        emit Transfer(0x0, _investor, _value);\r\n    }\r\n    \r\n    \r\n    \r\n    function mintTrio() external onlyManager {\r\n        require(now > (timeStamp + 360 days));\r\n        if(now > (timeStamp + 360 days) && now <= (timeStamp + 720 days)){\r\n            require(trioChecker[1] != true);\r\n            partingTrio(1);\r\n        }\r\n        if(now > (timeStamp + 720 days) && now <= (timeStamp + 1080 days)){\r\n            require(trioChecker[2] != true);\r\n            partingTrio(2);\r\n        }\r\n        if(now > (timeStamp + 1080 days) && now <= (timeStamp + 1440 days)){\r\n            require(trioChecker[3] != true);\r\n            partingTrio(3);\r\n        }\r\n        if(now > (timeStamp + 1440 days) && now <= (timeStamp + 1800 days)){\r\n            require(trioChecker[4] != true);\r\n            partingTrio(4);\r\n        }\r\n        if(now > (timeStamp + 1800 days) && now <= (timeStamp + 2160 days)){\r\n            require(trioChecker[5] != true);\r\n            partingTrio(5);\r\n        }\r\n        if(now > (timeStamp + 2160 days) && now <= (timeStamp + 2520 days)){\r\n            require(trioChecker[6] != true);\r\n            partingTrio(6);\r\n        }\r\n    }\r\n    \r\n    \r\n    function mintFund() external onlyManager {\r\n        require(now > (timeStamp + 360 days));\r\n        if(now > (timeStamp + 360 days) && now <= (timeStamp + 720 days)){\r\n            require(fundChecker[1] != true);\r\n            partingFund(1);\r\n        }\r\n        if(now > (timeStamp + 720 days) && now <= (timeStamp + 1080 days)){\r\n            require(fundChecker[2] != true);\r\n            partingFund(2);\r\n        }\r\n        if(now > (timeStamp + 1080 days) && now <= (timeStamp + 1440 days)){\r\n            require(fundChecker[3] != true);\r\n            partingFund(3);\r\n        }\r\n        if(now > (timeStamp + 1440 days) && now <= (timeStamp + 1800 days)){\r\n            require(fundChecker[4] != true);\r\n            partingFund(4);\r\n        }\r\n        if(now > (timeStamp + 1800 days) && now <= (timeStamp + 2160 days)){\r\n            require(fundChecker[5] != true);\r\n            partingFund(5);\r\n        }\r\n        if(now > (timeStamp + 2160 days) && now <= (timeStamp + 2520 days)){\r\n            require(fundChecker[6] != true);\r\n            partingFund(6);\r\n        }\r\n        if(now > (timeStamp + 2520 days) && now <= (timeStamp + 2880 days)){\r\n            require(fundChecker[7] != true);\r\n            partingFund(7);\r\n        }\r\n    \r\n    }\r\n    \r\n    \r\n    function partingFund(uint8 _x) internal {\r\n        require(_x > 0 && _x <= 7);\r\n        balances[teamFund] = balances[teamFund].add(fundPartYear);\r\n        fundChecker[_x] = true;\r\n        minted = minted.add(fundPartYear);\r\n        transferSt[teamFund].push(transferStruct(uint128(fundPartYear),uint64(now)));\r\n            \r\n        emit Transfer(0x0, teamFund, fundPartYear);\r\n    }\r\n    \r\n    \r\n    function partingTrio(uint8 _x) internal {\r\n        require(_x > 0 && _x <= 6);\r\n        balances[teamCSN] = balances[teamCSN].add(trioPartYear);\r\n        balances[teamFilmCompany] = balances[teamFilmCompany].add(trioPartYear);\r\n        balances[teamInvestors] = balances[teamInvestors].add(trioPartYear);\r\n        trioChecker[_x] = true;\r\n        minted = minted.add(trioPartYear.mul(3));\r\n        transferSt[teamCSN].push(transferStruct(uint128(trioPartYear),uint64(now)));\r\n        transferSt[teamFilmCompany].push(transferStruct(uint128(trioPartYear),uint64(now)));\r\n        transferSt[teamInvestors].push(transferStruct(uint128(trioPartYear),uint64(now)));\r\n            \r\n        emit Transfer(0x0, teamCSN, trioPartYear);\r\n        emit Transfer(0x0, teamFilmCompany, trioPartYear);\r\n        emit Transfer(0x0, teamInvestors, trioPartYear);\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Get balance of investor\r\n    *   @param _owner        investor's address\r\n    *   @return              balance of investor\r\n    */\r\n    function balanceOf(address _owner) public constant returns(uint256) {\r\n      return balances[_owner];\r\n    }\r\n\r\n   /**\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transfer(address _to, uint256 _amount) public returns(bool) {\r\n        if(msg.sender == _to) {return POSMint();}\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        if(transferSt[msg.sender].length > 0) {delete transferSt[msg.sender];}\r\n        uint64 _now = uint64(now);\r\n        transferSt[msg.sender].push(transferStruct(uint128(balances[msg.sender]),_now));\r\n        transferSt[_to].push(transferStruct(uint128(_amount),_now));\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {\r\n        require(_amount <= allowed[_from][msg.sender]);\r\n        require(_amount <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        if(transferSt[_from].length > 0) {delete transferSt[_from];}\r\n        uint64 _now = uint64(now);\r\n        transferSt[_from].push(transferStruct(uint128(balances[_from]),_now));\r\n        transferSt[_to].push(transferStruct(uint128(_amount),_now));\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function POSMint() internal returns (bool) {\r\n        require(now > (timeStamp + minimumAge));\r\n        if(balances[msg.sender] <= 0) {return false;}\r\n        if(transferSt[msg.sender].length <= 0) {return false;}\r\n\r\n        uint256 _now = now;\r\n        uint256 _year = getYear();\r\n        uint256 _phase = getPhase(_year);\r\n        uint256 _coinsAmount = getCoinsAmount(msg.sender, _now);\r\n        if(_coinsAmount <= 0) {return false;}\r\n        uint256 _coinsPrice = getCoinPrice(_year, _phase);\r\n        if(_coinsPrice <= 0) {return false;}\r\n        uint256 reward = (_coinsAmount.mul(_coinsPrice)).div(100000);\r\n        if(reward <= 0) {return false;}\r\n        if(reward > 0) {require(minted.add(reward) <= totalSupply);}\r\n        minted = minted.add(reward);\r\n        balances[msg.sender] = balances[msg.sender].add(reward);\r\n        delete transferSt[msg.sender];\r\n        transferSt[msg.sender].push(transferStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        emit Transfer(0x0, msg.sender, reward);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function getCoinsAmount(address _address, uint _now) internal view returns (uint256) {\r\n        if(transferSt[_address].length <= 0) {return 0;}\r\n        uint256 Coins = 0;\r\n        for (uint256 i = 0; i < transferSt[_address].length; i++){\r\n            if( _now < uint(transferSt[_address][i].time).add(minimumAge) ) {return Coins;}\r\n            Coins = Coins.add(uint256(transferSt[_address][i].amount));\r\n        }\r\n        return Coins;\r\n    }\r\n    \r\n    \r\n    function getYear() internal view returns (uint256) {\r\n        require(timeStamp > 0);\r\n        for(uint256 i = 0; i <= 99; i++) {\r\n        if(now >= ((timeStamp + minimumAge).add((i.mul(oneYear)))) && now < ((timeStamp + minimumAge).add(((i+1).mul(oneYear))))) {\r\n            return (i);    // how many years gone\r\n            }\r\n        }\r\n        if(now >= ((timeStamp + minimumAge).add((oneYear.mul(100))))) {return (100);}\r\n    \r\n    }\r\n\r\n\r\n    function getPhase(uint256 _x) internal pure returns (uint256) {\r\n        require(_x >= 0);\r\n        if(_x >= 0 && _x < 3) {return 1;}\r\n        if(_x >= 3 && _x < 6) {return 2;}\r\n        if(_x >= 6 && _x < 9) {return 3;}\r\n        if(_x >= 9 && _x < 12) {return 4;}\r\n        if(_x >= 12) {return 5;}        // last phase which include 18*3 years\r\n    \r\n    }\r\n    \r\n    \r\n    function getMonthLimit(uint256 _x) internal pure returns (uint256) {\r\n        require(_x > 0 && _x <=5);\r\n        if(_x == 1) {return (2220000 * 1e18);} //limit in month in this phase for all\r\n        if(_x == 2) {return (1480000 * 1e18);}\r\n        if(_x == 3) {return (740000 * 1e18);}\r\n        if(_x == 4) {return (370000 * 1e18);}\r\n        if(_x == 5) {return (185000 * 1e18);}\r\n    }\r\n    \r\n \r\n\r\n    \r\n    function getCoinPrice(uint256 _year, uint256 _phase) internal returns (uint256) {\r\n    require(_year >= 0);\r\n    uint256 _monthLimit = getMonthLimit(_phase);\r\n    uint256 _sumToAdd = _year.mul(oneYear);\r\n    uint256 _monthInYear = _year.mul(12);\r\n\r\n    for(uint256 i = 0; i <= 11; i++) {\r\n    if(now >= (timeStamp + minimumAge).add(_sumToAdd).add(minimumAge.mul(i)) && now < (timeStamp + minimumAge).add(_sumToAdd).add(minimumAge.mul(i+1))) {\r\n        uint256 _num = _monthInYear.add(i);\r\n        if(priceChecker[_num] != true) {\r\n            coinPriceNow[_num] = minted;\r\n            priceChecker[_num] = true;\r\n            return (_monthLimit.mul(100000)).div(minted);} \r\n        if(priceChecker[_num] == true) {\r\n            return (_monthLimit.mul(100000)).div(coinPriceNow[_num]);}\r\n    }\r\n    }\r\n}\r\n\r\n   /**\r\n    *   @dev Allows another account/contract to spend some tokens on its behalf\r\n    * approve has to be called twice in 2 separate transactions - once to\r\n    *   change the allowance to 0 and secondly to change it to the new allowance value\r\n    *   @param _spender      approved address\r\n    *   @param _amount       allowance amount\r\n    *\r\n    *   @return true if the approval was successful\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns(bool) {\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    *   @param _owner        the address which owns the funds\r\n    *   @param _spender      the address which will spend the funds\r\n    *\r\n    *   @return              the amount of tokens still avaible for the spender\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns(uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}\r\n\r\n\r\ncontract WbcICO {\r\n    using SafeMath for uint256;\r\n    \r\n    address public CSN; //\r\n    address public FilmCompany; //\r\n    address public Investors; //\r\n    address public Fund;\r\n    address public Manager; // Manager controls contract\r\n    address public Reserve;\r\n    address internal addressCompanion1;\r\n    address internal addressCompanion2;\r\n\r\n    WbcToken public WBC;\r\n    \r\n    mapping(address => bool) public kyc;  // investor identification status\r\n    \r\n    // Possible ICO statuses\r\n    enum StatusICO {\r\n        Created,\r\n        Ico,\r\n        IcoFinished\r\n    }\r\n    \r\n    StatusICO statusICO;\r\n    \r\n    \r\n    /**\r\n    *   @dev Contract constructor function\r\n    */\r\n    constructor (\r\n        address _CSN,\r\n        address _FilmCompany,\r\n        address _Investors,\r\n        address _Fund,\r\n        address _Manager,\r\n        address _Reserve\r\n    )\r\n        public {\r\n        CSN = _CSN;\r\n        FilmCompany = _FilmCompany;\r\n        Investors = _Investors;\r\n        Fund = _Fund;\r\n        Manager = _Manager;\r\n        Reserve = _Reserve;\r\n        statusICO = StatusICO.Created;\r\n        WBC = new WbcToken(this, _CSN, _FilmCompany, _Investors, _Fund, _Manager, _Reserve);\r\n    }\r\n    \r\n \r\n    \r\n\r\n    // Token price parameters\r\n    uint256 public Rate_Eth = 700; // Rate USD per ETH\r\n    uint256 internal Tokens_Per_Dollar = 77; // WBC token per dollar multiplied on 10\r\n    uint256 internal Token_Price_For_Ten_Ether = Tokens_Per_Dollar.mul(Rate_Eth); // WBC token per ETH\r\n    uint256 constant trioPartIco = 5920000 * 1e18; //0.6% of tokens for CrowdSale, Film Comany and Investors\r\n    uint256 constant reservePart = 17760000 * 1e18; //2% or 17mln and 760k  for reserve fund\r\n    uint256 constant MAX_TO_SOLD = 88800000 * 1e18; // tokens for sale in ICO\r\n    uint256 public soldTotal;  // total sold\r\n\r\n\r\n\r\n\r\n    // Events Log\r\n\r\n    event LogStartIco();\r\n    event LogFinishICO();\r\n    event LogBuyForInvestor(address investor, uint256 value);\r\n\r\n\r\n    // Modifiers\r\n    // Allows execution by the contract manager only\r\n    modifier managerOnly {\r\n        require(msg.sender == Manager);\r\n        _;\r\n    }\r\n    \r\n    // Allows execution by the companions only\r\n    modifier companionsOnly {\r\n        require(msg.sender == CSN || msg.sender == FilmCompany);\r\n        _;\r\n    }\r\n\r\n    \r\n    \r\n    function currentStage() public view returns (string) {\r\n        if(statusICO == StatusICO.Created){return \"Created\";}\r\n        else if(statusICO == StatusICO.Ico){return \"Ico\";}\r\n        else if(statusICO == StatusICO.IcoFinished){return \"IcoFinished\";}\r\n    }\r\n\r\n   /**\r\n    *   @dev Set rate of ETH and update token price\r\n    *   @param _RateEth       current ETH rate\r\n    */\r\n    function setRate(uint256 _RateEth) external managerOnly {\r\n        Rate_Eth = _RateEth;\r\n        Token_Price_For_Ten_Ether = Tokens_Per_Dollar.mul(_RateEth);\r\n    }\r\n    \r\n    \r\n    // passing KYC for investor\r\n    function passKYC(address _investor) external managerOnly {\r\n        kyc[_investor] = true;\r\n    }\r\n\r\n\r\n\r\n   /**\r\n    *   @dev Start ICO\r\n    *   Set ICO status\r\n    */\r\n    \r\n    function startIco() external managerOnly {\r\n        require(statusICO == StatusICO.Created);\r\n        WBC.mintTokens(CSN, trioPartIco);\r\n        WBC.mintTokens(FilmCompany, trioPartIco);\r\n        WBC.mintTokens(Investors, trioPartIco);\r\n        WBC.mintTokens(Reserve, reservePart);\r\n        statusICO = StatusICO.Ico;\r\n        emit LogStartIco();\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Finish ICO and emit tokens for bounty advisors and team\r\n    */\r\n    function finishIco() external managerOnly {\r\n        require(statusICO == StatusICO.Ico);\r\n        statusICO = StatusICO.IcoFinished;\r\n        WBC.doTimeStamp(now);\r\n        emit LogFinishICO();\r\n    }\r\n\r\n\r\n\r\n\r\n   /**\r\n    *   @dev Fallback function calls function to create tokens\r\n    *        when investor sends ETH to address of ICO contract\r\n    */\r\n    function() external payable {\r\n        require(msg.value > 0);\r\n        require(kyc[msg.sender]);\r\n        createTokens(msg.sender, (msg.value.mul(Token_Price_For_Ten_Ether)).div(10)); // divide by 10 because multiplied \"Per Dollar\" on 10\r\n    }\r\n    \r\n   \r\n    \r\n    function buyToken() external payable {\r\n        require(msg.value > 0);\r\n        require(kyc[msg.sender]);\r\n        createTokens(msg.sender, (msg.value.mul(Token_Price_For_Ten_Ether)).div(10)); // divide by 10 because multiplied \"Per Dollar\" on 10\r\n    }\r\n    \r\n    \r\n\r\n\r\n    function buyForInvestor(address _investor, uint256 _value) external managerOnly {\r\n        uint256 decvalue = _value.mul(1 ether);\r\n        require(_value > 0);\r\n        require(kyc[_investor]);\r\n        require(statusICO != StatusICO.IcoFinished);\r\n        require(statusICO != StatusICO.Created);\r\n        require(soldTotal.add(decvalue) <= MAX_TO_SOLD);\r\n        WBC.mintTokens(_investor, decvalue);\r\n        soldTotal = soldTotal.add(decvalue);\r\n        emit LogBuyForInvestor(_investor, _value);\r\n    }\r\n    \r\n\r\n\r\n    function createTokens(address _investor, uint256 _value) internal {\r\n        require(_value > 0);\r\n        require(soldTotal.add(_value) <= MAX_TO_SOLD);\r\n        require(statusICO != StatusICO.IcoFinished);\r\n        require(statusICO != StatusICO.Created);\r\n        WBC.mintTokens(_investor, _value);\r\n        soldTotal = soldTotal.add(_value);\r\n    }\r\n    \r\n    \r\n    /**\r\n    *   @dev Allows Companions to add consensus address\r\n    */\r\n    function consensusAddress(address _investor) external companionsOnly {\r\n        require(CSN != 0x0 && FilmCompany != 0x0);\r\n        if(msg.sender == CSN) {\r\n            addressCompanion1 = _investor;\r\n        } else {\r\n            addressCompanion2 = _investor;\r\n        }\r\n    }\r\n\r\n\r\n\r\n   /**\r\n    *   @dev Allows Companions withdraw investments\r\n    */\r\n    function takeInvestments() external companionsOnly {\r\n        require(addressCompanion1 != 0x0 && addressCompanion2 != 0x0);\r\n        require(addressCompanion1 == addressCompanion2);\r\n\r\n        addressCompanion1.transfer(address(this).balance);\r\n        \r\n        }\r\n        \r\n    }\r\n\r\n\r\n// gexabyte.com","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"kyc\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_RateEth\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WBC\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"consensusAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentStage\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Fund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Investors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"buyToken\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CSN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"soldTotal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"buyForInvestor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"takeInvestments\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Reserve\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Rate_Eth\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"FilmCompany\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"}],\"name\":\"passKYC\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishIco\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_CSN\",\"type\":\"address\"},{\"name\":\"_FilmCompany\",\"type\":\"address\"},{\"name\":\"_Investors\",\"type\":\"address\"},{\"name\":\"_Fund\",\"type\":\"address\"},{\"name\":\"_Manager\",\"type\":\"address\"},{\"name\":\"_Reserve\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogStartIco\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"LogFinishICO\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"investor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogBuyForInvestor\",\"type\":\"event\"}]","ContractName":"WbcICO","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"000000000000000000000000199f395944e8e9f1cb88ab256d7795fb9acd6b320000000000000000000000005b9364643bd8529e6f542ae9480d7889770e48640000000000000000000000008d20baefc893495696230a091789b13af3ca4a330000000000000000000000000dcf8b982a286873ecc27987a3198bb521a8ef06000000000000000000000000a3a106f1d081f5b9fc0b2a1b46613f55ea308cdc0000000000000000000000005f9100aa68836dd4979b4b2ef94e8e1d8546380b","Library":"","SwarmSource":"bzzr://f680cf848876aed58d8d97fdaef7c5ea3a118b4842a4fd4c67cf1aea366af0a5"}]}