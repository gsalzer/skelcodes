{"status":"1","message":"OK","result":[{"SourceCode":"/*\r\n ______   _________  ___   ___   _______    _______             ________  ______      \r\n/_____/\\ /________/\\/__/\\ /__/\\ /______/\\  /______/\\           /_______/\\/_____/\\     \r\n\\::::_\\/_\\__.::.__\\/\\::\\ \\\\  \\ \\\\::::__\\/__\\::::__\\/__         \\__.::._\\/\\:::_ \\ \\    \r\n \\:\\/___/\\  \\::\\ \\   \\::\\/_\\ .\\ \\\\:\\ /____/\\\\:\\ /____/\\  ___      \\::\\ \\  \\:\\ \\ \\ \\   \r\n  \\::___\\/_  \\::\\ \\   \\:: ___::\\ \\\\:\\\\_  _\\/ \\:\\\\_  _\\/ /__/\\     _\\::\\ \\__\\:\\ \\ \\ \\  \r\n   \\:\\____/\\  \\::\\ \\   \\: \\ \\\\::\\ \\\\:\\_\\ \\ \\  \\:\\_\\ \\ \\ \\::\\ \\   /__\\::\\__/\\\\:\\_\\ \\ \\ \r\n    \\_____\\/   \\__\\/    \\__\\/ \\::\\/ \\_____\\/   \\_____\\/  \\:_\\/   \\________\\/ \\_____\\/ \r\n  ______ _______ _    _    _____  ____   ____  _____     _____          __  __ ______  _____ \r\n |  ____|__   __| |  | |  / ____|/ __ \\ / __ \\|  __ \\   / ____|   /\\   |  \\/  |  ____|/ ____|\r\n | |__     | |  | |__| | | |  __| |  | | |  | | |  | | | |  __   /  \\  | \\  / | |__  | (___  \r\n |  __|    | |  |  __  | | | |_ | |  | | |  | | |  | | | | |_ | / /\\ \\ | |\\/| |  __|  \\___ \\ \r\n | |____   | |  | |  | | | |__| | |__| | |__| | |__| | | |__| |/ ____ \\| |  | | |____ ____) |\r\n |______|  |_|  |_|  |_|  \\_____|\\____/ \\____/|_____/   \\_____/_/    \\_\\_|  |_|______|_____/ \r\n                                                                                             \r\n                                                         BY : LmsSky@Gmail.com\r\n*/                            \r\npragma solidity ^0.4.25;\r\npragma experimental \"v0.5.0\";\r\ncontract safeApi{\r\n    \r\n   modifier safe(){\r\n        address _addr = msg.sender;\r\n        require (_addr == tx.origin,'Error Action!');\r\n        uint256 _codeLength;\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"Sender not authorized!\");\r\n            _;\r\n    }\r\n\r\n\r\n    \r\n function toBytes(uint256 _num) internal returns (bytes _ret) {\r\n   assembly {\r\n        _ret := mload(0x10)\r\n        mstore(_ret, 0x20)\r\n        mstore(add(_ret, 0x20), _num)\r\n    }\r\n}\r\n\r\nfunction subStr(string _s, uint start, uint end) internal pure returns (string){\r\n        bytes memory s = bytes(_s);\r\n        string memory copy = new string(end - start);\r\n//        string memory copy = new string(5);\r\n          uint k = 0;\r\n        for (uint i = start; i < end; i++){ \r\n            bytes(copy)[k++] = bytes(_s)[i];\r\n        }\r\n        return copy;\r\n    }\r\n     \r\n\r\n function safePercent(uint256 a,uint256 b) \r\n      internal\r\n      constant\r\n      returns(uint256)\r\n      {\r\n        assert(a>0 && a <=100);\r\n        return  div(mul(b,a),100);\r\n      }\r\n      \r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n \r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0âˆ‚\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return c;\r\n  }\r\n \r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n \r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n\r\n}\r\ncontract gameFinances is safeApi{\r\nmapping(bytes32=>uint)  validQueryId;\r\n    struct player\r\n    {\r\n        uint64 id;\r\n        uint32 affNumLevel_1;\r\n        uint32 affNumLevel_2;\r\n        uint32 timeStamp;\r\n        uint balance;//wei\r\n        uint gameBalance;\r\n        address addr;\r\n    }\r\n\r\n    struct  gameConfig\r\n    {\r\n         uint8 eachPct;\r\n         uint8 feePct;\r\n         uint8 poolPct;\r\n         uint8 adminPct;\r\n         uint8 levelPct1;\r\n         uint8 levelPct2;\r\n         uint16 index;\r\n         uint32 maxPct;\r\n         uint64 autoPlayId;\r\n    }\r\n    \r\n   struct  orderInfo\r\n    {  \r\n       uint64 pid;\r\n       uint32 pct;\r\n       uint32 times;\r\n       uint eth;\r\n       uint balance;\r\n    }\r\n    \r\n    struct gameInfo{\r\n       uint64 winner;\r\n       uint32 pointer;\r\n       uint bonus;//Additional bonuses other than the prize pool are issued by the admin\r\n       uint totalEth;\r\n       uint lastTime;\r\n       uint startTime;\r\n       orderInfo[] list;\r\n       mapping(uint64=>playerRecord) pinfo;\r\n    }\r\n    \r\n      struct  playerRecord\r\n    {  \r\n       bool status;\r\n       uint32 times;\r\n    } \r\n    \r\n    event join(\r\n        uint16 indexed index,\r\n        uint key,\r\n        address indexed addr\r\n    );\r\n    \r\n   \r\n    event next_game(\r\n        uint16 indexed index\r\n        ); \r\n    \r\n     mapping (uint64 => player)  player_;\r\n     mapping (address => uint64)  playAddr_;\r\n     mapping (uint64 => uint64)  playAff_;\r\n     mapping(uint16 =>gameInfo) gameInfo_;\r\n\r\n     gameConfig  gameConfig_;\r\n     address  admin_;\r\n  \r\n     constructor() public {\r\n         admin_ = msg.sender;\r\n         getPlayId(msg.sender);\r\n         gameConfig_.eachPct=20;\r\n         gameConfig_.maxPct=100;\r\n         gameConfig_.feePct=6;\r\n         gameConfig_.poolPct=70;\r\n         gameConfig_.adminPct=15;\r\n         gameConfig_.levelPct1=10;\r\n         gameConfig_.levelPct2=5;\r\n         gameConfig_.index=1;\r\n         gameInfo_[1].startTime=now;\r\n    }\r\n    \r\nfunction  joinGame(address _level1, address _level2) external payable safe(){\r\n        uint16 _index=gameConfig_.index;\r\n        gameInfo storage _g=gameInfo_[_index];\r\n        uint _now=now;\r\n        if(_g.lastTime>0){\r\n          require(_g.lastTime+86400 >_now,'Please wait for the start of the next round');\r\n        }\r\n        uint64 _pid=getPlayId(msg.sender);\r\n        initAddf(_pid,_level1,_level2);\r\n        uint _value=msg.value;\r\n        require(_value>=0.1 ether && _value<= 100 ether,'Eth Error');\r\n        require(_value%0.1 ether==0,'Eth Error2');\r\n        playerRecord storage _pr=_g.pinfo[_pid];\r\n        _g.totalEth=add(_g.totalEth,_value);\r\n        require(_pr.status==false,'Last settlement has not been completed');\r\n        _pr.status=true;\r\n        _pr.times++;\r\n         gameMatch(_g,_value);\r\n         uint32 _pct=gameConfig_.maxPct;\r\n        if(_pr.times<5){\r\n               _pct=_pr.times * gameConfig_.eachPct;\r\n        }\r\n        uint _balance = add(_value,safePercent(_pct,_value));\r\n        _g.list.push(orderInfo(\r\n            _pid,\r\n            _pct,\r\n             _pr.times,\r\n            _value,\r\n            _balance\r\n          ));\r\n      _g.lastTime=_now;\r\n\r\n      emit join(_index,_g.list.length,msg.sender);\r\n}\r\n\r\n//Start the next round of games\r\nfunction nextGame() external safe(){\r\n    require(msg.sender == admin_,'Error 1');\r\n    uint16 _index=gameConfig_.index;\r\n    uint  _endTime=gameInfo_[_index].lastTime+86400;\r\n    uint _now=now;\r\n    require(_now > _endTime,'Error 2');\r\n     emit next_game(_index);\r\n     uint _lastIndex=gameInfo_[_index].list.length;\r\n     //Transfer to the winner\r\n     if(_lastIndex>0){\r\n         uint64 _winnerId=gameInfo_[_index].list[_lastIndex-1].pid;\r\n         uint _prizePool=safePercent(gameConfig_.feePct,gameInfo_[_index].totalEth);\r\n         _prizePool=safePercent(gameConfig_.poolPct,_prizePool);\r\n         _prizePool=add(_prizePool,gameInfo_[_index].bonus);//Additional bonuses other than the prize pool are issued by the admin\r\n         uint _adminFee =  safePercent(gameConfig_.feePct,_prizePool);//Admin fee\r\n         uint64 _adminId=playAddr_[admin_];\r\n         player_[_adminId].balance=add(player_[_adminId].balance,_adminFee);\r\n         uint _winnerAmount=sub(_prizePool,_adminFee);\r\n         player_[_winnerId].addr.transfer(_winnerAmount);\r\n     }\r\n    _index++;\r\n    gameConfig_.index=_index;\r\n    gameInfo_[_index].startTime=_now;\r\n}\r\n\r\nfunction gameMatch(gameInfo storage _g,  uint _value) private{\r\n        uint _length=_g.list.length;\r\n        if(_length==0){\r\n             uint64 adminId=playAddr_[admin_];\r\n             player_[adminId].gameBalance=add(player_[adminId].gameBalance,_value);\r\n             return;\r\n        }\r\n            uint _myBalance=_value;\r\n            for(uint32 i=_g.pointer;i<_length;i++){\r\n                orderInfo storage  _gip=_g.list[i];\r\n                if(_gip.balance==0)\r\n                     break;\r\n                if(_myBalance>=_gip.balance){\r\n                    _g.pinfo[_gip.pid].status=false;\r\n                    _myBalance=sub(_myBalance,_gip.balance);\r\n                    player_[_gip.pid].gameBalance=add( player_[_gip.pid].gameBalance,_gip.balance);\r\n                    _gip.balance=0;\r\n                    _g.pointer++;\r\n                }else{\r\n                    _gip.balance=sub(_gip.balance,_myBalance);\r\n                    player_[_gip.pid].gameBalance=add(player_[_gip.pid].gameBalance,_myBalance);\r\n                    _myBalance=0;\r\n                    break;\r\n               }\r\n            }\r\n            if(_myBalance>0){\r\n                uint64 adminId=playAddr_[admin_];\r\n                player_[adminId].gameBalance=add(player_[adminId].gameBalance,_myBalance);\r\n            }\r\n}\r\n    \r\nfunction initAddf(uint64 _pid,address _level1, address _level2) private{\r\n    \r\n            address  _errorAddr=address(0);\r\n            uint64 _level1Pid=playAff_[_pid];\r\n            if(_level1Pid>0 || _level1 ==_errorAddr || _level1==_level2 || msg.sender==_level1 || msg.sender==_level2)\r\n               return;\r\n           if(_level1Pid==0 && _level1 == _errorAddr){\r\n                  uint64 adminId=playAddr_[admin_];\r\n                  playAff_[_pid]=adminId;\r\n                  return;\r\n           }\r\n              _level1Pid= playAddr_[_level1];\r\n              if(_level1Pid==0){\r\n                 _level1Pid=getPlayId(_level1);\r\n              }\r\n                  player_[_level1Pid].affNumLevel_1++;\r\n                  playAff_[_pid]=_level1Pid;\r\n                  uint64 _level2Pid=playAff_[_level1Pid];\r\n                  \r\n                  if(_level2Pid==0 &&  _level2 == _errorAddr){\r\n                     return;   \r\n                  }\r\n                     _level2Pid= playAddr_[_level2];\r\n                    if(_level2Pid==0){\r\n                       _level2Pid=getPlayId(_level2);\r\n                        playAff_[_level1Pid]=_level2Pid;\r\n                    }\r\n                    player_[_level2Pid].affNumLevel_2++;\r\n}\r\n\r\n    \r\nfunction withdraw(uint64 pid) safe() external{\r\n        require(playAddr_[msg.sender] == pid,'Error Action');\r\n        require(player_[pid].addr == msg.sender,'Error Action');\r\n        require(player_[pid].balance > 0,'Insufficient balance');\r\n        uint balance =player_[pid].balance;\r\n        player_[pid].balance=0;\r\n        player_[pid].addr.transfer(balance);\r\n}\r\n\r\n\r\n function withdrawGame(uint64 pid) safe() external{\r\n        require(playAddr_[msg.sender] == pid,'Error Action');\r\n        require(player_[pid].addr == msg.sender,'Error Action');\r\n        require(player_[pid].gameBalance >0,'Insufficient balance');\r\n        uint _balance =player_[pid].gameBalance;\r\n        player_[pid].gameBalance=0;\r\n        uint64 _level1Pid=playAff_[pid];\r\n        uint64 _adminId=playAddr_[admin_];\r\n        //Withdrawal fee\r\n        uint _fee=safePercent(gameConfig_.feePct,_balance);\r\n        //The prize pool has been increased when the investment is added, there is no need to operate here.\r\n        //Admin\r\n        uint _adminAmount=safePercent(gameConfig_.adminPct,_fee);\r\n        \r\n        //1 Level\r\n        uint levellAmount=safePercent(gameConfig_.levelPct1,_fee);\r\n        \r\n        //2 Level\r\n        uint level2Amount=safePercent(gameConfig_.levelPct2,_fee);\r\n        if(_level1Pid >0 && _level1Pid!=_adminId){\r\n            player_[_level1Pid].balance=add(player_[_level1Pid].balance,levellAmount);\r\n            uint64 _level2Pid=playAff_[_level1Pid];\r\n             if(_level2Pid>0){\r\n                player_[_level2Pid].balance=add(player_[_level2Pid].balance,level2Amount);\r\n             }else{\r\n                _adminAmount=add(_adminAmount,level2Amount);\r\n             }\r\n        }else{\r\n            _adminAmount=add(_adminAmount,add(levellAmount,level2Amount));\r\n        }\r\n        player_[_adminId].balance=add(player_[_adminId].balance,_adminAmount);\r\n        return player_[pid].addr.transfer(sub(_balance,_fee));\r\n    }\r\n   \r\n     //2020.01.01 Used to update the game\r\n   function updateGame() external safe() {\r\n        uint time=1577808000;\r\n        require(now > time,'Time has not arrived');\r\n        require(msg.sender == admin_,'Error');\r\n        selfdestruct(admin_);\r\n    }\r\n   \r\n    function getPlayId(address addr) private returns(uint64){\r\n        require (address(0)!=addr,'Error Addr');\r\n        if(playAddr_[addr] >0){\r\n         return playAddr_[addr];\r\n        }\r\n              gameConfig_.autoPlayId++;\r\n              playAddr_[addr]=  gameConfig_.autoPlayId;\r\n              player memory _p;\r\n              _p.id=  gameConfig_.autoPlayId;\r\n              _p.addr=addr;\r\n              _p.timeStamp=uint32(now);\r\n              player_[gameConfig_.autoPlayId]=_p;\r\n              return gameConfig_.autoPlayId;\r\n   }\r\n   \r\n   function getGameInfo(uint16 _index)external view returns(\r\n       uint16,uint,uint,uint,uint,uint,uint\r\n       ){ \r\n        gameInfo memory _g;\r\n       if(_index==0){\r\n             _g=gameInfo_[gameConfig_.index];\r\n       }else{\r\n             _g=gameInfo_[_index];\r\n       }\r\n       return(\r\n             gameConfig_.index,\r\n             _g.bonus,//Additional bonuses other than the prize pool are issued by the admin\r\n            _g.totalEth,\r\n            _g.startTime,\r\n            _g.lastTime,\r\n            _g.list.length,\r\n            gameInfo_[gameConfig_.index].list.length\r\n        );\r\n  }\r\n  \r\n  function getOrderInfo(uint16 _index, uint64 _key)external view returns(uint32,uint,uint,uint32){ \r\n           uint64 _pid =playAddr_[msg.sender];\r\n       orderInfo memory _g=gameInfo_[_index].list[_key];\r\n       require(_g.pid==_pid,'Error 404');\r\n       return(\r\n            _g.pct,\r\n            _g.eth,\r\n            _g.balance,\r\n            _g.times\r\n        );\r\n  }\r\n    \r\n  function getMyGameStatus(uint16 _index)external view returns (bool,uint32){\r\n         uint64 _pid =playAddr_[msg.sender];\r\n         playerRecord memory _g;\r\n       if(_index>0){\r\n           _g=gameInfo_[_index].pinfo[_pid];\r\n       }else{\r\n             _g=gameInfo_[gameConfig_.index].pinfo[_pid];\r\n       }\r\n      return (\r\n            _g.status,\r\n            _g.times\r\n          );\r\n  }\r\n  \r\n function getMyInfo()external view returns(uint64,uint,uint32,uint32,uint32,uint){ \r\n       uint64 _pid =playAddr_[msg.sender];\r\n       player memory _p=player_[_pid];\r\n       return(\r\n            _pid,\r\n            _p.balance,\r\n            _p.affNumLevel_1,\r\n            _p.affNumLevel_2,\r\n            _p.timeStamp,\r\n            _p.gameBalance\r\n        );\r\n  }\r\n  \r\n  //Add extra prizes to the prize pool ETH\r\n  function payment() external payable safe(){\r\n      //Additional bonuses other than the prize pool are issued by the admin\r\n      if(msg.value>0)\r\n     gameInfo_[gameConfig_.index].bonus=add(gameInfo_[gameConfig_.index].bonus,msg.value);\r\n  }\r\n  \r\n\r\n  function getConfig() external view returns(\r\n       uint8,uint8,uint8,uint8,uint8,uint8,uint32\r\n       ){\r\n     return (      \r\n         gameConfig_.eachPct,\r\n         gameConfig_.feePct,\r\n         gameConfig_.poolPct,\r\n         gameConfig_.adminPct,\r\n         gameConfig_.levelPct1,\r\n         gameConfig_.levelPct2,\r\n        gameConfig_.maxPct\r\n      );\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"updateGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"nextGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"payment\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"getMyGameStatus\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint16\"}],\"name\":\"getGameInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint16\"},{\"name\":\"_key\",\"type\":\"uint64\"}],\"name\":\"getOrderInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint64\"}],\"name\":\"withdrawGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"pid\",\"type\":\"uint64\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getMyInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint32\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_level1\",\"type\":\"address\"},{\"name\":\"_level2\",\"type\":\"address\"}],\"name\":\"joinGame\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getConfig\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"index\",\"type\":\"uint16\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"join\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"index\",\"type\":\"uint16\"}],\"name\":\"next_game\",\"type\":\"event\"}]","ContractName":"gameFinances","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://52043f9edfbfc1563a10ee73ea5b396640a8f9d86929728c6c7dcd114d48a150"}]}