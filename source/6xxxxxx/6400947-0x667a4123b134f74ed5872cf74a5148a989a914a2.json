{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * Safe unsigned safe math.\r\n *\r\n * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli\r\n *\r\n * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol\r\n *\r\n * Maintained here until merged to mainline zeppelin-solidity.\r\n *\r\n */\r\nlibrary SafeMathLibExt {\r\n\r\n    function times(uint a, uint b) public pure returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function divides(uint a, uint b) public pure returns (uint) {\r\n        assert(b > 0);\r\n        uint c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function minus(uint a, uint b) public pure returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function plus(uint a, uint b) public pure returns (uint) {\r\n        uint c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n    * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n    * account.\r\n    */\r\n    constructor () public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n    * @dev Throws if called by any account other than the owner.\r\n    */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n    * @param newOwner The address to transfer ownership to.\r\n    */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n/*\r\n * Haltable\r\n *\r\n * Abstract contract that allows children to implement an\r\n * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode.\r\n *\r\n *\r\n * Originally envisioned in FirstBlood ICO contract.\r\n */\r\ncontract Haltable is Ownable {\r\n    bool public halted;\r\n\r\n    modifier stopInEmergency {\r\n        if (halted) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier stopNonOwnersInEmergency {\r\n        if (halted && msg.sender != owner) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    modifier onlyInEmergency {\r\n        if (!halted) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    // called by the owner on emergency, triggers stopped state\r\n    function halt() external onlyOwner {\r\n        halted = true;\r\n    }\r\n\r\n    // called by the owner on end of emergency, returns to normal state\r\n    function unhalt() external onlyOwner onlyInEmergency {\r\n        halted = false;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Interface for defining crowdsale pricing.\r\n */\r\ncontract PricingStrategy {\r\n\r\n    address public tier;\r\n\r\n    /** Interface declaration. */\r\n    function isPricingStrategy() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /** Self check if all references are correctly set.\r\n    *\r\n    * Checks that pricing strategy matches crowdsale parameters.\r\n    */\r\n    function isSane() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Pricing tells if this is a presale purchase or not.  \r\n      @return False by default, true if a presale purchaser\r\n    */\r\n    function isPresalePurchase() public pure returns (bool) {\r\n        return false;\r\n    }\r\n\r\n    /* How many weis one token costs */\r\n    function updateRate(uint oneTokenInCents) public;\r\n\r\n    /**\r\n    * When somebody tries to buy tokens for X eth, calculate how many tokens they get.\r\n    *\r\n    *\r\n    * @param value - What is the value of the transaction send in as wei\r\n    * @param tokensSold - how much tokens have been sold this far\r\n    * @param decimals - how many decimal units the token has\r\n    * @return Amount of tokens the investor receives\r\n    */\r\n    function calculatePrice(uint value, uint tokensSold, uint decimals) public view returns (uint tokenAmount);\r\n\r\n    function oneTokenInWei(uint tokensSold, uint decimals) public view returns (uint);\r\n}\r\n\r\n/**\r\n * Finalize agent defines what happens at the end of succeseful crowdsale.\r\n *\r\n * - Allocate tokens for founders, bounties and community\r\n * - Make tokens transferable\r\n * - etc.\r\n */\r\ncontract FinalizeAgent {\r\n\r\n    bool public reservedTokensAreDistributed = false;\r\n\r\n    function isFinalizeAgent() public pure returns(bool) {\r\n        return true;\r\n    }\r\n\r\n    /** Return true if we can run finalizeCrowdsale() properly.\r\n    *\r\n    * This is a safety check function that doesn't allow crowdsale to begin\r\n    * unless the finalizer has been set up properly.\r\n    */\r\n    function isSane() public view returns (bool);\r\n\r\n    function distributeReservedTokens(uint reservedTokensDistributionBatch) public;\r\n\r\n    /** Called once by crowdsale finalize() if the sale was success. */\r\n    function finalizeCrowdsale() public;\r\n    \r\n    /**\r\n    * Allow to (re)set Token.\r\n    */\r\n    function setCrowdsaleTokenExtv1(address _token) public;\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * A token that defines fractional units as decimals.\r\n */\r\ncontract FractionalERC20Ext is ERC20 {\r\n    uint public decimals;\r\n    uint public minCap;\r\n}\r\n\r\ncontract Allocatable is Ownable {\r\n\r\n  /** List of agents that are allowed to allocate new tokens */\r\n    mapping (address => bool) public allocateAgents;\r\n\r\n    event AllocateAgentChanged(address addr, bool state  );\r\n\r\n  /**\r\n   * Owner can allow a crowdsale contract to allocate new tokens.\r\n   */\r\n    function setAllocateAgent(address addr, bool state) public onlyOwner  \r\n    {\r\n        allocateAgents[addr] = state;\r\n        emit AllocateAgentChanged(addr, state);\r\n    }\r\n\r\n    modifier onlyAllocateAgent() {\r\n        //Only crowdsale contracts are allowed to allocate new tokens\r\n        require(allocateAgents[msg.sender]);\r\n        _;\r\n    }\r\n}\r\n\r\n/**\r\n * Contract to enforce Token Vesting\r\n */\r\ncontract TokenVesting is Allocatable {\r\n\r\n    using SafeMathLibExt for uint;\r\n\r\n    address public crowdSaleTokenAddress;\r\n\r\n    /** keep track of total tokens yet to be released, \r\n     * this should be less than or equal to UTIX tokens held by this contract. \r\n     */\r\n    uint256 public totalUnreleasedTokens;\r\n\r\n    // default vesting parameters\r\n    uint256 private startAt = 0;\r\n    uint256 private cliff = 1;\r\n    uint256 private duration = 4; \r\n    uint256 private step = 300; //15778463;  //2592000;\r\n    bool private changeFreezed = false;\r\n\r\n    struct VestingSchedule {\r\n        uint256 startAt;\r\n        uint256 cliff;\r\n        uint256 duration;\r\n        uint256 step;\r\n        uint256 amount;\r\n        uint256 amountReleased;\r\n        bool changeFreezed;\r\n    }\r\n\r\n    mapping (address => VestingSchedule) public vestingMap;\r\n\r\n    event VestedTokensReleased(address _adr, uint256 _amount);\r\n    \r\n    constructor(address _tokenAddress) public {\r\n        \r\n        crowdSaleTokenAddress = _tokenAddress;\r\n    }\r\n\r\n    /** Modifier to check if changes to vesting is freezed  */\r\n    modifier changesToVestingFreezed(address _adr) {\r\n        require(vestingMap[_adr].changeFreezed);\r\n        _;\r\n    }\r\n\r\n    /** Modifier to check if changes to vesting is not freezed yet  */\r\n    modifier changesToVestingNotFreezed(address adr) {\r\n        require(!vestingMap[adr].changeFreezed); // if vesting not set then also changeFreezed will be false\r\n        _;\r\n    }\r\n\r\n    /** Function to set default vesting schedule parameters. */\r\n    function setDefaultVestingParameters(\r\n        uint256 _startAt, uint256 _cliff, uint256 _duration,\r\n        uint256 _step, bool _changeFreezed) public onlyAllocateAgent {\r\n\r\n        // data validation\r\n        require(_step != 0);\r\n        require(_duration != 0);\r\n        require(_cliff <= _duration);\r\n\r\n        startAt = _startAt;\r\n        cliff = _cliff;\r\n        duration = _duration; \r\n        step = _step;\r\n        changeFreezed = _changeFreezed;\r\n\r\n    }\r\n\r\n    /** Function to set vesting with default schedule. */\r\n    function setVestingWithDefaultSchedule(address _adr, uint256 _amount) \r\n    public \r\n    changesToVestingNotFreezed(_adr) onlyAllocateAgent {\r\n       \r\n        setVesting(_adr, startAt, cliff, duration, step, _amount, changeFreezed);\r\n    }    \r\n\r\n    /** Function to set/update vesting schedule. PS - Amount cannot be changed once set */\r\n    function setVesting(\r\n        address _adr,\r\n        uint256 _startAt,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _step,\r\n        uint256 _amount,\r\n        bool _changeFreezed) \r\n    public changesToVestingNotFreezed(_adr) onlyAllocateAgent {\r\n\r\n        VestingSchedule storage vestingSchedule = vestingMap[_adr];\r\n\r\n        // data validation\r\n        require(_step != 0);\r\n        require(_amount != 0 || vestingSchedule.amount > 0);\r\n        require(_duration != 0);\r\n        require(_cliff <= _duration);\r\n\r\n        //if startAt is zero, set current time as start time.\r\n        if (_startAt == 0) \r\n            _startAt = block.timestamp;\r\n\r\n        vestingSchedule.startAt = _startAt;\r\n        vestingSchedule.cliff = _cliff;\r\n        vestingSchedule.duration = _duration;\r\n        vestingSchedule.step = _step;\r\n\r\n        // special processing for first time vesting setting\r\n        if (vestingSchedule.amount == 0) {\r\n            // check if enough tokens are held by this contract\r\n            ERC20 token = ERC20(crowdSaleTokenAddress);\r\n            require(token.balanceOf(this) >= totalUnreleasedTokens.plus(_amount));\r\n            totalUnreleasedTokens = totalUnreleasedTokens.plus(_amount);\r\n            vestingSchedule.amount = _amount; \r\n        }\r\n\r\n        vestingSchedule.amountReleased = 0;\r\n        vestingSchedule.changeFreezed = _changeFreezed;\r\n    }\r\n\r\n    function isVestingSet(address adr) public view returns (bool isSet) {\r\n        return vestingMap[adr].amount != 0;\r\n    }\r\n\r\n    function freezeChangesToVesting(address _adr) public changesToVestingNotFreezed(_adr) onlyAllocateAgent {\r\n        require(isVestingSet(_adr)); // first check if vesting is set\r\n        vestingMap[_adr].changeFreezed = true;\r\n    }\r\n\r\n    /** Release tokens as per vesting schedule, called by contributor  */\r\n    function releaseMyVestedTokens() public changesToVestingFreezed(msg.sender) {\r\n        releaseVestedTokens(msg.sender);\r\n    }\r\n\r\n    /** Release tokens as per vesting schedule, called by anyone  */\r\n    function releaseVestedTokens(address _adr) public changesToVestingFreezed(_adr) {\r\n        VestingSchedule storage vestingSchedule = vestingMap[_adr];\r\n        \r\n        // check if all tokens are not vested\r\n        require(vestingSchedule.amount.minus(vestingSchedule.amountReleased) > 0);\r\n        \r\n        // calculate total vested tokens till now\r\n        uint256 totalTime = block.timestamp - vestingSchedule.startAt;\r\n        uint256 totalSteps = totalTime / vestingSchedule.step;\r\n\r\n        // check if cliff is passed\r\n        require(vestingSchedule.cliff <= totalSteps);\r\n\r\n        uint256 tokensPerStep = vestingSchedule.amount / vestingSchedule.duration;\r\n        // check if amount is divisble by duration\r\n        if (tokensPerStep * vestingSchedule.duration != vestingSchedule.amount) tokensPerStep++;\r\n\r\n        uint256 totalReleasableAmount = tokensPerStep.times(totalSteps);\r\n\r\n        // handle the case if user has not claimed even after vesting period is over or amount was not divisible\r\n        if (totalReleasableAmount > vestingSchedule.amount) totalReleasableAmount = vestingSchedule.amount;\r\n\r\n        uint256 amountToRelease = totalReleasableAmount.minus(vestingSchedule.amountReleased);\r\n        vestingSchedule.amountReleased = vestingSchedule.amountReleased.plus(amountToRelease);\r\n\r\n        // transfer vested tokens\r\n        ERC20 token = ERC20(crowdSaleTokenAddress);\r\n        token.transfer(_adr, amountToRelease);\r\n        // decrement overall unreleased token count\r\n        totalUnreleasedTokens = totalUnreleasedTokens.minus(amountToRelease);\r\n        emit VestedTokensReleased(_adr, amountToRelease);\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set Token.\r\n    */\r\n    function setCrowdsaleTokenExtv1(address _token) public onlyAllocateAgent {       \r\n        crowdSaleTokenAddress = _token;\r\n    }\r\n}\r\n\r\n/**\r\n * Abstract base contract for token sales.\r\n *\r\n * Handle\r\n * - start and end dates\r\n * - accepting investments\r\n * - minimum funding goal and refund\r\n * - various statistics during the crowdfund\r\n * - different pricing strategies\r\n * - different investment policies (require server side customer id, allow only whitelisted addresses)\r\n *\r\n */\r\ncontract CrowdsaleExt is Allocatable, Haltable {\r\n\r\n    /* Max investment count when we are still allowed to change the multisig address */\r\n    uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5;\r\n\r\n    using SafeMathLibExt for uint;\r\n\r\n    /* The token we are selling */\r\n    FractionalERC20Ext public token;\r\n\r\n    /* How we are going to price our offering */\r\n    PricingStrategy public pricingStrategy;\r\n\r\n    /* Post-success callback */\r\n    FinalizeAgent public finalizeAgent;\r\n\r\n    TokenVesting public tokenVesting;\r\n\r\n    /* name of the crowdsale tier */\r\n    string public name;\r\n\r\n    /* tokens will be transfered from this address */\r\n    address public multisigWallet;\r\n\r\n    /* if the funding goal is not reached, investors may withdraw their funds */\r\n    uint public minimumFundingGoal;\r\n\r\n    /* the UNIX timestamp start date of the crowdsale */\r\n    uint public startsAt;\r\n\r\n    /* the UNIX timestamp end date of the crowdsale */\r\n    uint public endsAt;\r\n\r\n    /* the number of tokens already sold through this contract*/\r\n    uint public tokensSold = 0;\r\n\r\n    /* How many wei of funding we have raised */\r\n    uint public weiRaised = 0;\r\n\r\n    /* How many distinct addresses have invested */\r\n    uint public investorCount = 0;\r\n\r\n    /* Has this crowdsale been finalized */\r\n    bool public finalized;\r\n\r\n    bool public isWhiteListed;\r\n\r\n      /* Token Vesting Contract */\r\n    address public tokenVestingAddress;\r\n\r\n    address[] public joinedCrowdsales;\r\n    uint8 public joinedCrowdsalesLen = 0;\r\n    uint8 public joinedCrowdsalesLenMax = 50;\r\n\r\n    struct JoinedCrowdsaleStatus {\r\n        bool isJoined;\r\n        uint8 position;\r\n    }\r\n\r\n    mapping (address => JoinedCrowdsaleStatus) public joinedCrowdsaleState;\r\n\r\n    /** How much ETH each address has invested to this crowdsale */\r\n    mapping (address => uint256) public investedAmountOf;\r\n\r\n    /** How much tokens this crowdsale has credited for each investor address */\r\n    mapping (address => uint256) public tokenAmountOf;\r\n\r\n    struct WhiteListData {\r\n        bool status;\r\n        uint minCap;\r\n        uint maxCap;\r\n    }\r\n\r\n    //is crowdsale updatable\r\n    bool public isUpdatable;\r\n\r\n    /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */\r\n    mapping (address => WhiteListData) public earlyParticipantWhitelist;\r\n\r\n    /** List of whitelisted addresses */\r\n    address[] public whitelistedParticipants;\r\n\r\n    /** This is for manul testing for the interaction from owner wallet. \r\n    You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */\r\n    uint public ownerTestValue;\r\n\r\n    /** State machine\r\n    *\r\n    * - Preparing: All contract initialization calls and variables have not been set yet\r\n    * - Prefunding: We have not passed start time yet\r\n    * - Funding: Active crowdsale\r\n    * - Success: Minimum funding goal reached\r\n    * - Failure: Minimum funding goal not reached before ending time\r\n    * - Finalized: The finalized has been called and succesfully executed\r\n    */\r\n    enum State { Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized }\r\n\r\n    // A new investment was made\r\n    event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId);\r\n\r\n    // Address early participation whitelist status changed\r\n    event Whitelisted(address addr, bool status, uint minCap, uint maxCap);\r\n    event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap);\r\n\r\n    // Crowdsale start time has been changed\r\n    event StartsAtChanged(uint newStartsAt);\r\n\r\n    // Crowdsale end time has been changed\r\n    event EndsAtChanged(uint newEndsAt);\r\n\r\n    constructor(string _name, address _token, PricingStrategy _pricingStrategy, \r\n    address _multisigWallet, uint _start, uint _end, \r\n    uint _minimumFundingGoal, bool _isUpdatable, \r\n    bool _isWhiteListed, address _tokenVestingAddress) public {\r\n\r\n        owner = msg.sender;\r\n\r\n        name = _name;\r\n\r\n        tokenVestingAddress = _tokenVestingAddress;\r\n\r\n        token = FractionalERC20Ext(_token);\r\n\r\n        setPricingStrategy(_pricingStrategy);\r\n\r\n        multisigWallet = _multisigWallet;\r\n        if (multisigWallet == 0) {\r\n            revert();\r\n        }\r\n\r\n        if (_start == 0) {\r\n            revert();\r\n        }\r\n\r\n        startsAt = _start;\r\n\r\n        if (_end == 0) {\r\n            revert();\r\n        }\r\n\r\n        endsAt = _end;\r\n\r\n        // Don't mess the dates\r\n        if (startsAt >= endsAt) {\r\n            revert();\r\n        }\r\n\r\n        // Minimum funding goal can be zero\r\n        minimumFundingGoal = _minimumFundingGoal;\r\n\r\n        isUpdatable = _isUpdatable;\r\n\r\n        isWhiteListed = _isWhiteListed;\r\n    }\r\n\r\n    /**\r\n    * Don't expect to just send in money and get tokens.\r\n    */\r\n    function() external payable {\r\n        buy();\r\n    }\r\n\r\n    /**\r\n    * The basic entry point to participate the crowdsale process.\r\n    *\r\n    * Pay for funding, get invested tokens back in the sender address.\r\n    */\r\n    function buy() public payable {\r\n        invest(msg.sender);\r\n    }\r\n\r\n    /**\r\n    * Allow anonymous contributions to this crowdsale.\r\n    */\r\n    function invest(address addr) public payable {\r\n        investInternal(addr, 0);\r\n    }\r\n\r\n    /**\r\n    * Make an investment.\r\n    *\r\n    * Crowdsale must be running for one to invest.\r\n    * We must have not pressed the emergency brake.\r\n    *\r\n    * @param receiver The Ethereum address who receives the tokens\r\n    * @param customerId (optional) UUID v4 to track the successful payments on the server side\r\n    *\r\n    */\r\n    function investInternal(address receiver, uint128 customerId) private stopInEmergency {\r\n\r\n        // Determine if it's a good time to accept investment from this participant\r\n        if (getState() == State.PreFunding) {\r\n            // Are we whitelisted for early deposit\r\n            revert();\r\n        } else if (getState() == State.Funding) {\r\n            // Retail participants can only come in when the crowdsale is running\r\n            // pass\r\n            if (isWhiteListed) {\r\n                if (!earlyParticipantWhitelist[receiver].status) {\r\n                    revert();\r\n                }\r\n            }\r\n        } else {\r\n            // Unwanted state\r\n            revert();\r\n        }\r\n\r\n        uint weiAmount = msg.value;\r\n\r\n        // Account presale sales separately, so that they do not count against pricing tranches\r\n        uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, tokensSold, token.decimals());\r\n\r\n        if (tokenAmount == 0) {\r\n          // Dust transaction\r\n            revert();\r\n        }\r\n\r\n        if (isWhiteListed) {\r\n            if (weiAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) {\r\n              // weiAmount < minCap for investor\r\n                revert();\r\n            }\r\n\r\n            // Check that we did not bust the investor's cap\r\n            if (isBreakingInvestorCap(receiver, weiAmount)) {\r\n                revert();\r\n            }\r\n\r\n            updateInheritedEarlyParticipantWhitelist(receiver, weiAmount);\r\n        } else {\r\n            if (weiAmount < token.minCap() && tokenAmountOf[receiver] == 0) {\r\n                revert();\r\n            }\r\n        }\r\n\r\n        if (investedAmountOf[receiver] == 0) {\r\n          // A new investor\r\n            investorCount++;\r\n        }\r\n\r\n        // Update investor\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\n\r\n        // Update totals\r\n        weiRaised = weiRaised.plus(weiAmount);\r\n        tokensSold = tokensSold.plus(tokenAmount);\r\n\r\n        // Check that we did not bust the cap\r\n        if (isBreakingCap(tokensSold)) {\r\n            revert();\r\n        }\r\n\r\n        assignTokens(receiver, tokenAmount);\r\n\r\n        // Pocket the money\r\n        if (!multisigWallet.send(weiAmount)) revert();\r\n\r\n        // Tell us invest was success\r\n        emit Invested(receiver, weiAmount, tokenAmount, customerId);\r\n    }\r\n\r\n    /**\r\n    * allocate tokens for the early investors.\r\n    *\r\n    * Preallocated tokens have been sold before the actual crowdsale opens.\r\n    * This function mints the tokens and moves the crowdsale needle.\r\n    *\r\n    * Investor count is not handled; it is assumed this goes for multiple investors\r\n    * and the token distribution happens outside the smart contract flow.\r\n    *\r\n    * No money is exchanged, as the crowdsale team already have received the payment.\r\n    *\r\n    * param weiPrice Price of a single full token in wei\r\n    *\r\n    */\r\n    function allocate(address receiver, uint256 tokenAmount, uint128 customerId, uint256 lockedTokenAmount) public onlyAllocateAgent {\r\n\r\n      // cannot lock more than total tokens\r\n        require(lockedTokenAmount <= tokenAmount);\r\n        uint weiPrice = pricingStrategy.oneTokenInWei(tokensSold, token.decimals());\r\n        // This can be also 0, we give out tokens for free\r\n        uint256 weiAmount = (weiPrice * tokenAmount)/10**uint256(token.decimals());         \r\n\r\n        weiRaised = weiRaised.plus(weiAmount);\r\n        tokensSold = tokensSold.plus(tokenAmount);\r\n\r\n        investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount);\r\n        tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount);\r\n\r\n        // assign locked token to Vesting contract\r\n        if (lockedTokenAmount > 0) {\r\n            tokenVesting = TokenVesting(tokenVestingAddress);\r\n            // to prevent minting of tokens which will be useless as vesting amount cannot be updated\r\n            require(!tokenVesting.isVestingSet(receiver));\r\n            assignTokens(tokenVestingAddress, lockedTokenAmount);\r\n            // set vesting with default schedule\r\n            tokenVesting.setVestingWithDefaultSchedule(receiver, lockedTokenAmount); \r\n        }\r\n\r\n        // assign remaining tokens to contributor\r\n        if (tokenAmount - lockedTokenAmount > 0) {\r\n            assignTokens(receiver, tokenAmount - lockedTokenAmount);\r\n        }\r\n\r\n        // Tell us invest was success\r\n        emit Invested(receiver, weiAmount, tokenAmount, customerId);\r\n    }\r\n\r\n    //\r\n    // Modifiers\r\n    //\r\n    /** Modified allowing execution only if the crowdsale is currently running.  */\r\n\r\n    modifier inState(State state) {\r\n        if (getState() != state) \r\n            revert();\r\n        _;\r\n    }\r\n\r\n    function distributeReservedTokens(uint reservedTokensDistributionBatch) \r\n    public inState(State.Success) onlyOwner stopInEmergency {\r\n      // Already finalized\r\n        if (finalized) {\r\n            revert();\r\n        }\r\n\r\n        // Finalizing is optional. We only call it if we are given a finalizing agent.\r\n        if (address(finalizeAgent) != address(0)) {\r\n            finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch);\r\n        }\r\n    }\r\n\r\n    function areReservedTokensDistributed() public view returns (bool) {\r\n        return finalizeAgent.reservedTokensAreDistributed();\r\n    }\r\n\r\n    function canDistributeReservedTokens() public view returns(bool) {\r\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\r\n        if ((lastTierCntrct.getState() == State.Success) &&\r\n        !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed())\r\n            return true;\r\n        return false;\r\n    }\r\n\r\n    /**\r\n    * Finalize a succcesful crowdsale.\r\n    *\r\n    * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens.\r\n    */\r\n    function finalize() public inState(State.Success) onlyOwner stopInEmergency {\r\n\r\n      // Already finalized\r\n        if (finalized) {\r\n            revert();\r\n        }\r\n\r\n      // Finalizing is optional. We only call it if we are given a finalizing agent.\r\n        if (address(finalizeAgent) != address(0)) {\r\n            finalizeAgent.finalizeCrowdsale();\r\n        }\r\n\r\n        finalized = true;\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set finalize agent.\r\n    *\r\n    * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes.\r\n    */\r\n    function setFinalizeAgent(FinalizeAgent addr) public onlyOwner {\r\n        assert(address(addr) != address(0));\r\n        assert(address(finalizeAgent) == address(0));\r\n        finalizeAgent = addr;\r\n\r\n        // Don't allow setting bad agent\r\n        if (!finalizeAgent.isFinalizeAgent()) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Allow addresses to do early participation.\r\n    */\r\n    function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner {\r\n        if (!isWhiteListed) revert();\r\n        assert(addr != address(0));\r\n        assert(maxCap > 0);\r\n        assert(minCap <= maxCap);\r\n        assert(now <= endsAt);\r\n\r\n        if (!isAddressWhitelisted(addr)) {\r\n            whitelistedParticipants.push(addr);\r\n            emit Whitelisted(addr, status, minCap, maxCap);\r\n        } else {\r\n            emit WhitelistItemChanged(addr, status, minCap, maxCap);\r\n        }\r\n\r\n        earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap});\r\n    }\r\n\r\n    function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) \r\n    public onlyOwner {\r\n        if (!isWhiteListed) revert();\r\n        assert(now <= endsAt);\r\n        assert(addrs.length == statuses.length);\r\n        assert(statuses.length == minCaps.length);\r\n        assert(minCaps.length == maxCaps.length);\r\n        for (uint iterator = 0; iterator < addrs.length; iterator++) {\r\n            setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]);\r\n        }\r\n    }\r\n\r\n    function updateEarlyParticipantWhitelist(address addr, uint weiAmount) public {\r\n        if (!isWhiteListed) revert();\r\n        assert(addr != address(0));\r\n        assert(now <= endsAt);\r\n        assert(isTierJoined(msg.sender));\r\n        if (weiAmount < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) revert();\r\n        //if (addr != msg.sender && contractAddr != msg.sender) throw;\r\n        uint newMaxCap = earlyParticipantWhitelist[addr].maxCap;\r\n        newMaxCap = newMaxCap.minus(weiAmount);\r\n        earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap});\r\n    }\r\n\r\n    function updateInheritedEarlyParticipantWhitelist(address reciever, uint weiAmount) private {\r\n        if (!isWhiteListed) revert();\r\n        if (weiAmount < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) revert();\r\n\r\n        uint8 tierPosition = getTierPosition(this);\r\n\r\n        for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\r\n            CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\r\n            crowdsale.updateEarlyParticipantWhitelist(reciever, weiAmount);\r\n        }\r\n    }\r\n\r\n    function isAddressWhitelisted(address addr) public view returns(bool) {\r\n        for (uint i = 0; i < whitelistedParticipants.length; i++) {\r\n            if (whitelistedParticipants[i] == addr) {\r\n                return true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function whitelistedParticipantsLength() public view returns (uint) {\r\n        return whitelistedParticipants.length;\r\n    }\r\n\r\n    function isTierJoined(address addr) public view returns(bool) {\r\n        return joinedCrowdsaleState[addr].isJoined;\r\n    }\r\n\r\n    function getTierPosition(address addr) public view returns(uint8) {\r\n        return joinedCrowdsaleState[addr].position;\r\n    }\r\n\r\n    function getLastTier() public view returns(address) {\r\n        if (joinedCrowdsalesLen > 0)\r\n            return joinedCrowdsales[joinedCrowdsalesLen - 1];\r\n        else\r\n            return address(0);\r\n    }\r\n\r\n    function setJoinedCrowdsales(address addr) private onlyOwner {\r\n        assert(addr != address(0));\r\n        assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax);\r\n        assert(!isTierJoined(addr));\r\n        joinedCrowdsales.push(addr);\r\n        joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({\r\n            isJoined: true,\r\n            position: joinedCrowdsalesLen\r\n        });\r\n        joinedCrowdsalesLen++;\r\n    }\r\n\r\n    function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner {\r\n        assert(addrs.length > 0);\r\n        assert(joinedCrowdsalesLen == 0);\r\n        assert(addrs.length <= joinedCrowdsalesLenMax);\r\n        for (uint8 iter = 0; iter < addrs.length; iter++) {\r\n            setJoinedCrowdsales(addrs[iter]);\r\n        }\r\n    }\r\n\r\n    function setStartsAt(uint time) public onlyOwner {\r\n        assert(!finalized);\r\n        assert(isUpdatable);\r\n        assert(now <= time); // Don't change past\r\n        assert(time <= endsAt);\r\n        assert(now <= startsAt);\r\n\r\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\r\n        if (lastTierCntrct.finalized()) revert();\r\n\r\n        uint8 tierPosition = getTierPosition(this);\r\n\r\n        //start time should be greater then end time of previous tiers\r\n        for (uint8 j = 0; j < tierPosition; j++) {\r\n            CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\r\n            assert(time >= crowdsale.endsAt());\r\n        }\r\n\r\n        startsAt = time;\r\n        emit StartsAtChanged(startsAt);\r\n    }\r\n\r\n    /**\r\n    * Allow crowdsale owner to close early or extend the crowdsale.\r\n    *\r\n    * This is useful e.g. for a manual soft cap implementation:\r\n    * - after X amount is reached determine manual closing\r\n    *\r\n    * This may put the crowdsale to an invalid state,\r\n    * but we trust owners know what they are doing.\r\n    *\r\n    */\r\n    function setEndsAt(uint time) public onlyOwner {\r\n        assert(!finalized);\r\n        assert(isUpdatable);\r\n        assert(now <= time);// Don't change past\r\n        assert(startsAt <= time);\r\n        assert(now <= endsAt);\r\n\r\n        CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier());\r\n        if (lastTierCntrct.finalized()) revert();\r\n\r\n\r\n        uint8 tierPosition = getTierPosition(this);\r\n\r\n        for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) {\r\n            CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]);\r\n            assert(time <= crowdsale.startsAt());\r\n        }\r\n\r\n        endsAt = time;\r\n        emit EndsAtChanged(endsAt);\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set pricing strategy.\r\n    *\r\n    * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes.\r\n    */\r\n    function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner {\r\n        assert(address(_pricingStrategy) != address(0));\r\n        assert(address(pricingStrategy) == address(0));\r\n        pricingStrategy = _pricingStrategy;\r\n\r\n        // Don't allow setting bad agent\r\n        if (!pricingStrategy.isPricingStrategy()) {\r\n            revert();\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Allow to (re)set Token.\r\n    * @param _token upgraded token address\r\n    */\r\n    function setCrowdsaleTokenExtv1(address _token) public onlyOwner {\r\n        assert(_token != address(0));\r\n        token = FractionalERC20Ext(_token);\r\n        \r\n        if (address(finalizeAgent) != address(0)) {\r\n            finalizeAgent.setCrowdsaleTokenExtv1(_token);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * Allow to change the team multisig address in the case of emergency.\r\n    *\r\n    * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun\r\n    * (we have done only few test transactions). After the crowdsale is going\r\n    * then multisig address stays locked for the safety reasons.\r\n    */\r\n    function setMultisig(address addr) public onlyOwner {\r\n\r\n      // Change\r\n        if (investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) {\r\n            revert();\r\n        }\r\n\r\n        multisigWallet = addr;\r\n    }\r\n\r\n    /**\r\n    * @return true if the crowdsale has raised enough money to be a successful.\r\n    */\r\n    function isMinimumGoalReached() public view returns (bool reached) {\r\n        return weiRaised >= minimumFundingGoal;\r\n    }\r\n\r\n    /**\r\n    * Check if the contract relationship looks good.\r\n    */\r\n    function isFinalizerSane() public view returns (bool sane) {\r\n        return finalizeAgent.isSane();\r\n    }\r\n\r\n    /**\r\n    * Check if the contract relationship looks good.\r\n    */\r\n    function isPricingSane() public view returns (bool sane) {\r\n        return pricingStrategy.isSane();\r\n    }\r\n\r\n    /**\r\n    * Crowdfund state machine management.\r\n    *\r\n    * We make it a function and do not assign the result to a variable, \r\n    * so there is no chance of the variable being stale.\r\n    */\r\n    function getState() public view returns (State) {\r\n        if(finalized) return State.Finalized;\r\n        else if (address(finalizeAgent) == 0) return State.Preparing;\r\n        else if (!finalizeAgent.isSane()) return State.Preparing;\r\n        else if (!pricingStrategy.isSane()) return State.Preparing;\r\n        else if (block.timestamp < startsAt) return State.PreFunding;\r\n        else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding;\r\n        else if (isMinimumGoalReached()) return State.Success;\r\n        else return State.Failure;\r\n    }\r\n\r\n    /** Interface marker. */\r\n    function isCrowdsale() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    //\r\n    // Abstract functions\r\n    //\r\n\r\n    /**\r\n    * Check if the current invested breaks our cap rules.\r\n    *\r\n    *\r\n    * The child contract must define their own cap setting rules.\r\n    * We allow a lot of flexibility through different capping strategies (ETH, token count)\r\n    * Called from invest().\r\n    *  \r\n    * @param tokensSoldTotal What would be our total sold tokens count after this transaction\r\n    *\r\n    * @return true if taking this investment would break our cap rules\r\n    */\r\n    function isBreakingCap(uint tokensSoldTotal) public view returns (bool limitBroken);\r\n\r\n    function isBreakingInvestorCap(address receiver, uint tokenAmount) public view returns (bool limitBroken);\r\n\r\n    /**\r\n    * Check if the current crowdsale is full and we can no longer sell any tokens.\r\n    */\r\n    function isCrowdsaleFull() public view returns (bool);\r\n\r\n    /**\r\n    * Create new tokens or transfer issued tokens to the investor depending on the cap model.\r\n    */\r\n    function assignTokens(address receiver, uint tokenAmount) private;\r\n}\r\n\r\n/**\r\n * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation.\r\n *\r\n * Based on code by FirstBlood:\r\n * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20 {\r\n\r\n    using SafeMathLibExt for uint;\r\n    /* Token supply got increased and a new owner received these tokens */\r\n    event Minted(address receiver, uint amount);\r\n\r\n    /* Actual balances of token holders */\r\n    mapping(address => uint) public balances;\r\n\r\n    /* approve() allowances */\r\n    mapping (address => mapping (address => uint)) public allowed;\r\n\r\n    /* Interface declaration */\r\n    function isToken() public pure returns (bool weAre) {\r\n        return true;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        balances[msg.sender] = balances[msg.sender].minus(_value);\r\n        balances[_to] = balances[_to].plus(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        uint _allowance = allowed[_from][msg.sender];\r\n\r\n        balances[_to] = balances[_to].plus(_value);\r\n        balances[_from] = balances[_from].minus(_value);\r\n        allowed[_from][msg.sender] = _allowance.minus(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n\r\n        // To change the approve amount you first have to reduce the addresses`\r\n        //  allowance to zero by calling `approve(_spender, 0)` if it is not\r\n        //  already 0 to mitigate the race condition described here:\r\n        //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n        if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert();\r\n\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * Upgrade agent interface inspired by Lunyr.\r\n *\r\n * Upgrade agent transfers tokens to a new contract.\r\n * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting.\r\n */\r\ncontract UpgradeAgent {\r\n\r\n    uint public originalSupply;\r\n\r\n    /** Interface marker */\r\n    function isUpgradeAgent() public pure returns (bool) {\r\n        return true;\r\n    }\r\n\r\n    function upgradeFrom(address _from, uint256 _value) public;\r\n\r\n}\r\n\r\n/**\r\n * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision.\r\n *\r\n * First envisioned by Golem and Lunyr projects.\r\n */\r\ncontract UpgradeableToken is StandardToken {\r\n\r\n    /** Contract / person who can set the upgrade path. \r\n        This can be the same as team multisig wallet, as what it is with its default value. */\r\n    address public upgradeMaster;\r\n\r\n    /** The next contract where the tokens will be migrated. */\r\n    UpgradeAgent public upgradeAgent;\r\n\r\n    /** How many tokens we have upgraded by now. */\r\n    uint256 public totalUpgraded;\r\n\r\n    /**\r\n    * Upgrade states.\r\n    *\r\n    * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun\r\n    * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet\r\n    * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet\r\n    * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens\r\n    *\r\n    */\r\n    enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading}\r\n\r\n    /**\r\n    * Somebody has upgraded some of his tokens.\r\n    */\r\n    event Upgrade(address indexed _from, address indexed _to, uint256 _value);\r\n\r\n    /**\r\n    * New upgrade agent available.\r\n    */\r\n    event UpgradeAgentSet(address agent);\r\n\r\n    /**\r\n    * Do not allow construction without upgrade master set.\r\n    */\r\n    constructor(address _upgradeMaster) public {\r\n        upgradeMaster = _upgradeMaster;\r\n    }\r\n\r\n    /**\r\n    * Allow the token holder to upgrade some of their tokens to a new contract.\r\n    */\r\n    function upgrade(uint256 value) public {\r\n\r\n        UpgradeState state = getUpgradeState();\r\n        if (!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) {\r\n            // Called in a bad state\r\n            revert();\r\n        }\r\n\r\n        // Validate input value.\r\n        if (value == 0) revert();\r\n\r\n        balances[msg.sender] = balances[msg.sender].minus(value);\r\n\r\n        // Take tokens out from circulation\r\n        totalSupply = totalSupply.minus(value);\r\n        totalUpgraded = totalUpgraded.plus(value);\r\n\r\n        // Upgrade agent reissues the tokens\r\n        upgradeAgent.upgradeFrom(msg.sender, value);\r\n        emit Upgrade(msg.sender, upgradeAgent, value);\r\n    }\r\n\r\n    /**\r\n    * Child contract can enable to provide the condition when the upgrade can begun.\r\n    */\r\n    function canUpgrade() public view returns(bool) {\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Set an upgrade agent that handles\r\n    */\r\n    function setUpgradeAgent(address agent) external {\r\n        if (!canUpgrade()) {\r\n            // The token is not yet in a state that we could think upgrading\r\n            revert();\r\n        }\r\n\r\n        if (agent == 0x0) revert();\r\n        // Only a master can designate the next agent\r\n        if (msg.sender != upgradeMaster) revert();\r\n        // Upgrade has already begun for an agent\r\n        if (getUpgradeState() == UpgradeState.Upgrading) revert();\r\n\r\n        upgradeAgent = UpgradeAgent(agent);\r\n\r\n        // Bad interface\r\n        if (!upgradeAgent.isUpgradeAgent()) revert();      \r\n\r\n        emit UpgradeAgentSet(upgradeAgent);\r\n    }\r\n\r\n    /**\r\n    * Get the state of the token upgrade.\r\n    */\r\n    function getUpgradeState() public view returns(UpgradeState) {\r\n        if (!canUpgrade()) return UpgradeState.NotAllowed;\r\n        else if (address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent;\r\n        else if (totalUpgraded == 0) return UpgradeState.ReadyToUpgrade;\r\n        else return UpgradeState.Upgrading;\r\n    }\r\n\r\n    /**\r\n    * Change the upgrade master.\r\n    *\r\n    * This allows us to set a new owner for the upgrade mechanism.\r\n    */\r\n    function setUpgradeMaster(address master) public {\r\n        if (master == 0x0) revert();\r\n        if (msg.sender != upgradeMaster) revert();\r\n        upgradeMaster = master;\r\n    }\r\n}\r\n\r\n /**\r\n  * Define interface for releasing the token transfer after a successful crowdsale.\r\n  */\r\ncontract ReleasableToken is ERC20, Ownable {\r\n\r\n    /* The finalizer contract that allows unlift the transfer limits on this token */\r\n    address public releaseAgent;\r\n\r\n    /** A crowdsale contract can release us to the wild if ICO success. \r\n        If false we are are in transfer lock up period.*/\r\n    bool public released = false;\r\n\r\n    /** Map of agents that are allowed to transfer tokens regardless of the lock down period. \r\n        These are crowdsale contracts and possible the team multisig itself. */\r\n    mapping (address => bool) public transferAgents;\r\n\r\n    /**\r\n    * Limit token transfer until the crowdsale is over.\r\n    *\r\n    */\r\n    modifier canTransfer(address _sender) {\r\n\r\n        if (!released) {\r\n            if (!transferAgents[_sender]) {\r\n                revert();\r\n            }\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * Set the contract that can call release and make the token transferable.\r\n    *\r\n    * Design choice. Allow reset the release agent to fix fat finger mistakes.\r\n    */\r\n    function setReleaseAgent(address addr) public onlyOwner inReleaseState(false) {\r\n        // We don't do interface check here as we might want to a normal wallet address to act as a release agent\r\n        releaseAgent = addr;\r\n    }\r\n\r\n    /**\r\n    * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period.\r\n    */\r\n    function setTransferAgent(address addr, bool state) public onlyOwner inReleaseState(false) {\r\n        transferAgents[addr] = state;\r\n    }\r\n\r\n    /**\r\n    * One way function to release the tokens to the wild.\r\n    *\r\n    * Can be called only from the release agent that is the final ICO contract. \r\n    * It is only called if the crowdsale has been success (first milestone reached).\r\n    */\r\n    function releaseTokenTransfer() public onlyReleaseAgent {\r\n        released = true;\r\n    }\r\n\r\n    /** The function can be called only before or after the tokens have been releasesd */\r\n    modifier inReleaseState(bool releaseState) {\r\n        if (releaseState != released) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /** The function can be called only by a whitelisted release agent. */\r\n    modifier onlyReleaseAgent() {\r\n        if (msg.sender != releaseAgent) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public canTransfer(msg.sender) returns (bool success) {\r\n        // Call StandardToken.transfer()\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public canTransfer(_from) returns (bool success) {\r\n        // Call StandardToken.transferForm()\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * A token that can increase its supply by another contract.\r\n *\r\n * This allows uncapped crowdsale by dynamically increasing the supply when money pours in.\r\n * Only mint agents, contracts whitelisted by owner, can mint new tokens.\r\n *\r\n */\r\ncontract MintableTokenExt is StandardToken, Ownable {\r\n\r\n    using SafeMathLibExt for uint;\r\n\r\n    bool public mintingFinished = false;\r\n\r\n    /** List of agents that are allowed to create new tokens */\r\n    mapping (address => bool) public mintAgents;\r\n\r\n    event MintingAgentChanged(address addr, bool state  );\r\n\r\n    /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals.\r\n    * For example, for reserved tokens in percents 2.54%\r\n    * inPercentageUnit = 254\r\n    * inPercentageDecimals = 2\r\n    */\r\n    struct ReservedTokensData {\r\n        uint inTokens;\r\n        uint inPercentageUnit;\r\n        uint inPercentageDecimals;\r\n        bool isReserved;\r\n        bool isDistributed;\r\n        bool isVested;\r\n    }\r\n\r\n    mapping (address => ReservedTokensData) public reservedTokensList;\r\n    address[] public reservedTokensDestinations;\r\n    uint public reservedTokensDestinationsLen = 0;\r\n    bool private reservedTokensDestinationsAreSet = false;\r\n\r\n    modifier onlyMintAgent() {\r\n        // Only crowdsale contracts are allowed to mint new tokens\r\n        if (!mintAgents[msg.sender]) {\r\n            revert();\r\n        }\r\n        _;\r\n    }\r\n\r\n    /** Make sure we are not done yet. */\r\n    modifier canMint() {\r\n        if (mintingFinished) revert();\r\n        _;\r\n    }\r\n\r\n    function finalizeReservedAddress(address addr) public onlyMintAgent canMint {\r\n        ReservedTokensData storage reservedTokensData = reservedTokensList[addr];\r\n        reservedTokensData.isDistributed = true;\r\n    }\r\n\r\n    function isAddressReserved(address addr) public view returns (bool isReserved) {\r\n        return reservedTokensList[addr].isReserved;\r\n    }\r\n\r\n    function areTokensDistributedForAddress(address addr) public view returns (bool isDistributed) {\r\n        return reservedTokensList[addr].isDistributed;\r\n    }\r\n\r\n    function getReservedTokens(address addr) public view returns (uint inTokens) {\r\n        return reservedTokensList[addr].inTokens;\r\n    }\r\n\r\n    function getReservedPercentageUnit(address addr) public view returns (uint inPercentageUnit) {\r\n        return reservedTokensList[addr].inPercentageUnit;\r\n    }\r\n\r\n    function getReservedPercentageDecimals(address addr) public view returns (uint inPercentageDecimals) {\r\n        return reservedTokensList[addr].inPercentageDecimals;\r\n    }\r\n\r\n    function getReservedIsVested(address addr) public view returns (bool isVested) {\r\n        return reservedTokensList[addr].isVested;\r\n    }\r\n\r\n    function setReservedTokensListMultiple(\r\n        address[] addrs, \r\n        uint[] inTokens, \r\n        uint[] inPercentageUnit, \r\n        uint[] inPercentageDecimals,\r\n        bool[] isVested\r\n        ) public canMint onlyOwner {\r\n        assert(!reservedTokensDestinationsAreSet);\r\n        assert(addrs.length == inTokens.length);\r\n        assert(inTokens.length == inPercentageUnit.length);\r\n        assert(inPercentageUnit.length == inPercentageDecimals.length);\r\n        for (uint iterator = 0; iterator < addrs.length; iterator++) {\r\n            if (addrs[iterator] != address(0)) {\r\n                setReservedTokensList(\r\n                    addrs[iterator],\r\n                    inTokens[iterator],\r\n                    inPercentageUnit[iterator],\r\n                    inPercentageDecimals[iterator],\r\n                    isVested[iterator]\r\n                    );\r\n            }\r\n        }\r\n        reservedTokensDestinationsAreSet = true;\r\n    }\r\n\r\n    /**\r\n    * Create new tokens and allocate them to an address..\r\n    *\r\n    * Only callably by a crowdsale contract (mint agent).\r\n    */\r\n    function mint(address receiver, uint amount) public onlyMintAgent canMint {\r\n        totalSupply = totalSupply.plus(amount);\r\n        balances[receiver] = balances[receiver].plus(amount);\r\n\r\n        // This will make the mint transaction apper in EtherScan.io\r\n        // We can remove this after there is a standardized minting event\r\n        emit Transfer(0, receiver, amount);\r\n    }\r\n\r\n    /**\r\n    * Owner can allow a crowdsale contract to mint new tokens.\r\n    */\r\n    function setMintAgent(address addr, bool state) public onlyOwner canMint {\r\n        mintAgents[addr] = state;\r\n        emit MintingAgentChanged(addr, state);\r\n    }\r\n\r\n    function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals,bool isVested) \r\n    private canMint onlyOwner {\r\n        assert(addr != address(0));\r\n        if (!isAddressReserved(addr)) {\r\n            reservedTokensDestinations.push(addr);\r\n            reservedTokensDestinationsLen++;\r\n        }\r\n\r\n        reservedTokensList[addr] = ReservedTokensData({\r\n            inTokens: inTokens,\r\n            inPercentageUnit: inPercentageUnit,\r\n            inPercentageDecimals: inPercentageDecimals,\r\n            isReserved: true,\r\n            isDistributed: false,\r\n            isVested:isVested\r\n        });\r\n    }\r\n}\r\n\r\n/**\r\n * A crowdsaled token.\r\n *\r\n * An ERC-20 token designed specifically for crowdsales with investor protection and further development path.\r\n *\r\n * - The token transfer() is disabled until the crowdsale is over\r\n * - The token contract gives an opt-in upgrade path to a new contract\r\n * - The same token can be part of several crowdsales through approve() mechanism\r\n * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens)\r\n *\r\n */\r\ncontract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken {\r\n\r\n    /** Name and symbol were updated. */\r\n    event UpdatedTokenInformation(string newName, string newSymbol);\r\n\r\n    event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount);\r\n\r\n    string public name;\r\n\r\n    string public symbol;\r\n\r\n    uint public decimals;\r\n\r\n    /* Minimum ammount of tokens every buyer can buy. */\r\n    uint public minCap;\r\n\r\n    /**\r\n    * Construct the token.\r\n    *\r\n    * This token must be created through a team multisig wallet, so that it is owned by that wallet.\r\n    *\r\n    * @param _name Token name\r\n    * @param _symbol Token symbol - should be all caps\r\n    * @param _initialSupply How many tokens we start with\r\n    * @param _decimals Number of decimal places\r\n    * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? \r\n    * Note that when the token becomes transferable the minting always ends.\r\n    */\r\n    constructor(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) \r\n    public UpgradeableToken(msg.sender) {\r\n\r\n        // Create any address, can be transferred\r\n        // to team multisig via changeOwner(),\r\n        // also remember to call setUpgradeMaster()\r\n        owner = msg.sender;\r\n\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        totalSupply = _initialSupply;\r\n\r\n        decimals = _decimals;\r\n\r\n        minCap = _globalMinCap;\r\n\r\n        // Create initially all balance on the team multisig\r\n        balances[owner] = totalSupply;\r\n\r\n        if (totalSupply > 0) {\r\n            emit Minted(owner, totalSupply);\r\n        }\r\n\r\n        // No more new supply allowed after the token creation\r\n        if (!_mintable) {\r\n            mintingFinished = true;\r\n            if (totalSupply == 0) {\r\n                revert(); // Cannot create a token without supply and no minting\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n    * When token is released to be transferable, enforce no new tokens can be created.\r\n    */\r\n    function releaseTokenTransfer() public onlyReleaseAgent {\r\n        mintingFinished = true;\r\n        super.releaseTokenTransfer();\r\n    }\r\n\r\n    /**\r\n    * Allow upgrade agent functionality kick in only if the crowdsale was success.\r\n    */\r\n    function canUpgrade() public view returns(bool) {\r\n        return released && super.canUpgrade();\r\n    }\r\n\r\n    /**\r\n    * Owner can update token information here.\r\n    *\r\n    * It is often useful to conceal the actual token association, until\r\n    * the token operations, like central issuance or reissuance have been completed.\r\n    *\r\n    * This function allows the token owner to rename the token after the operations\r\n    * have been completed and then point the audience to use the token contract.\r\n    */\r\n    function setTokenInformation(string _name, string _symbol) public onlyOwner {\r\n        name = _name;\r\n        symbol = _symbol;\r\n\r\n        emit UpdatedTokenInformation(name, symbol);\r\n    }\r\n\r\n    /**\r\n    * Claim tokens that were accidentally sent to this contract.\r\n    *\r\n    * @param _token The address of the token contract that you want to recover.\r\n    */\r\n    function claimTokens(address _token) public onlyOwner {\r\n        require(_token != address(0));\r\n\r\n        ERC20 token = ERC20(_token);\r\n        uint balance = token.balanceOf(this);\r\n        token.transfer(owner, balance);\r\n\r\n        emit ClaimedTokens(_token, owner, balance);\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * The default behavior for the crowdsale end.\r\n *\r\n * Unlock tokens.\r\n */\r\ncontract ReservedTokensFinalizeAgent is FinalizeAgent {\r\n    using SafeMathLibExt for uint;\r\n    CrowdsaleTokenExt public token;\r\n    CrowdsaleExt public crowdsale;\r\n\r\n    uint public distributedReservedTokensDestinationsLen = 0;\r\n\r\n    constructor(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public {\r\n        token = _token;\r\n        crowdsale = _crowdsale;\r\n    }\r\n\r\n    /** Check that we can release the token */\r\n    function isSane() public view returns (bool) {\r\n        return (token.releaseAgent() == address(this));\r\n    }\r\n    \r\n    /**\r\n    * Allow to (re)set Token.\r\n    */\r\n    function setCrowdsaleTokenExtv1(address _token) public {\r\n        assert(msg.sender == address(crowdsale));\r\n        token = CrowdsaleTokenExt(_token);\r\n    }\r\n\r\n    //distributes reserved tokens. Should be called before finalization\r\n    function distributeReservedTokens(uint reservedTokensDistributionBatch) public {\r\n        assert(msg.sender == address(crowdsale));\r\n\r\n        assert(reservedTokensDistributionBatch > 0);\r\n        assert(!reservedTokensAreDistributed);\r\n        assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen());\r\n\r\n        // How many % of tokens the founders and others get\r\n        uint tokensSold = 0;\r\n        for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) {\r\n            CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i));\r\n            tokensSold = tokensSold.plus(tier.tokensSold());\r\n        }\r\n\r\n        uint startLooping = distributedReservedTokensDestinationsLen;\r\n        uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen);\r\n        if (batch >= reservedTokensDistributionBatch) {\r\n            batch = reservedTokensDistributionBatch;\r\n        }\r\n        uint endLooping = startLooping + batch;\r\n\r\n        // move reserved tokens\r\n        for (uint j = startLooping; j < endLooping; j++) {\r\n            address reservedAddr = token.reservedTokensDestinations(j);\r\n            if (!token.areTokensDistributedForAddress(reservedAddr)) {\r\n                uint allocatedBonusInPercentage;\r\n                uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr);\r\n                uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr);\r\n                uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr);\r\n                bool isVested = token.getReservedIsVested(reservedAddr);\r\n\r\n                if (percentsOfTokensUnit > 0) {\r\n                    allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100;\r\n                    if(isVested) {                    \r\n                        crowdsale.allocate(reservedAddr, allocatedBonusInPercentage, 0, allocatedBonusInPercentage);\r\n                    }\r\n                    else {\r\n                        token.mint(reservedAddr, allocatedBonusInPercentage);\r\n                    }\r\n                }\r\n\r\n                if (allocatedBonusInTokens > 0) {\r\n                    if(isVested) {                     \r\n                        crowdsale.allocate(reservedAddr, allocatedBonusInTokens, 0, allocatedBonusInTokens);\r\n                    }\r\n                    else {\r\n                        token.mint(reservedAddr, allocatedBonusInTokens);\r\n                    }\r\n                }\r\n\r\n                token.finalizeReservedAddress(reservedAddr);\r\n                distributedReservedTokensDestinationsLen++;\r\n            }\r\n        }\r\n\r\n        if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) {\r\n            reservedTokensAreDistributed = true;\r\n        }\r\n    }\r\n\r\n    /** Called once by crowdsale finalize() if the sale was success. */\r\n    function finalizeCrowdsale() public {\r\n        assert(msg.sender == address(crowdsale));\r\n\r\n        if (token.reservedTokensDestinationsLen() > 0) {\r\n            assert(reservedTokensAreDistributed);\r\n        }\r\n\r\n        token.releaseTokenTransfer();\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"finalizeCrowdsale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalizeAgent\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSane\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"distributedReservedTokensDestinationsLen\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"reservedTokensDistributionBatch\",\"type\":\"uint256\"}],\"name\":\"distributeReservedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"setCrowdsaleTokenExtv1\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reservedTokensAreDistributed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_crowdsale\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ReservedTokensFinalizeAgent","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000003b1ad2987a6dc21678ef80973c2da0d94079651d000000000000000000000000e31e62c08146a0b8bcf05aefbded7e6831ec0644","Library":"SafeMathLibExt:8a0128980df4f35bb7515275d9e1cb869159a6c2","SwarmSource":"bzzr://71274fbe6be833bec86039c6a39ca15a72c37f7e9052080d07eca55f635ad6e9"}]}