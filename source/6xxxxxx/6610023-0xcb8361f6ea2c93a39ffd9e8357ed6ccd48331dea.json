{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/*\r\n* CryptoMiningWar - Build your own empire on Blockchain\r\n* Author: InspiGames\r\n* Website: https://cryptominingwar.github.io/\r\n*/\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\ncontract CryptoEngineerInterface {\r\n    uint256 public prizePool = 0;\r\n    address public gameSponsor;\r\n    function getPlayerData(address /*_addr*/) \r\n    public \r\n    pure \r\n    returns(\r\n        uint256 /*_engineerRoundNumber*/, \r\n        uint256 /*_virusNumber*/, \r\n        uint256 /*_virusDefence*/, \r\n        uint256 /*_research*/, \r\n        uint256 /*_researchPerDay*/, \r\n        uint256 /*_lastUpdateTime*/, \r\n        uint256[8] /*_engineersCount*/, \r\n        uint256 /*_nextTimeAtk*/,\r\n        uint256 /*_endTimeUnequalledDef*/\r\n    ) {}\r\n    function fallback() public payable {}\r\n    function claimPrizePool(address /*_addr*/, uint256 /*_value*/) public pure {} \r\n    function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/) {}\r\n}\r\ncontract CryptoMiningWarInterface {\r\n    uint256 public deadline; \r\n    mapping(address => PlayerData) public players;\r\n    struct PlayerData {\r\n        uint256 roundNumber;\r\n        mapping(uint256 => uint256) minerCount;\r\n        uint256 hashrate;\r\n        uint256 crystals;\r\n        uint256 lastUpdateTime;\r\n        uint256 referral_count;\r\n        uint256 noQuest;\r\n    }\r\n    function getPlayerData(address /*addr*/) public pure\r\n    returns (\r\n        uint256 /*crystals*/, \r\n        uint256 /*lastupdate*/, \r\n        uint256 /*hashratePerDay*/, \r\n        uint256[8] /*miners*/, \r\n        uint256 /*hasBoost*/, \r\n        uint256 /*referral_count*/, \r\n        uint256 /*playerBalance*/, \r\n        uint256 /*noQuest*/ \r\n        ) {}\r\n    function subCrystal( address /*_addr*/, uint256 /*_value*/ ) public pure {}\r\n}\r\ncontract CryptoAirdropGameInterface {\r\n    mapping(address => PlayerData) public players;\r\n    struct PlayerData {\r\n        uint256 currentMiniGameId;\r\n        uint256 lastMiniGameId; \r\n        uint256 win;\r\n        uint256 share;\r\n        uint256 totalJoin;\r\n        uint256 miningWarRoundNumber;\r\n    }\r\n    function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/ ) {}\r\n}\r\ncontract CryptoBossWannaCryInterface {\r\n    mapping(address => PlayerData) public players;\r\n    struct PlayerData {\r\n        uint256 currentBossRoundNumber;\r\n        uint256 lastBossRoundNumber;\r\n        uint256 win;\r\n        uint256 share;\r\n        uint256 dame; \r\n        uint256 nextTimeAtk;\r\n    }\r\n    function isContractMiniGame() public pure returns( bool /*_isContractMiniGame*/ ) {}\r\n}\r\ncontract CrystalDeposit {\r\n    using SafeMath for uint256;\r\n\r\n    bool private init = false;\r\n    address private administrator;\r\n    // mini game\r\n    uint256 private round = 0;\r\n    uint256 private HALF_TIME       = 1 days;\r\n    uint256 private RESET_QUEST_TIME= 4 hours;\r\n    uint256 constant private RESET_QUEST_FEE = 0.005 ether; \r\n    address private engineerAddress;\r\n\r\n    CryptoEngineerInterface     public Engineer;\r\n    CryptoMiningWarInterface    public MiningWar;\r\n    CryptoAirdropGameInterface  public AirdropGame;\r\n    CryptoBossWannaCryInterface public BossWannaCry;\r\n    \r\n    // mining war info\r\n    uint256 private miningWarDeadline;\r\n    uint256 constant private CRTSTAL_MINING_PERIOD = 86400;\r\n    /** \r\n    * @dev mini game information\r\n    */\r\n    mapping(uint256 => Game) public games;\r\n    // quest info \r\n    mapping(uint256 => Quest) public quests;\r\n\r\n    mapping(address => PlayerQuest) public playersQuests;\r\n    /** \r\n    * @dev player information\r\n    */\r\n    mapping(address => Player) public players;\r\n   \r\n    struct Game {\r\n        uint256 round;\r\n        uint256 crystals;\r\n        uint256 prizePool;\r\n        uint256 endTime;\r\n        bool ended; \r\n    }\r\n    struct Player {\r\n        uint256 currentRound;\r\n        uint256 lastRound;\r\n        uint256 reward;\r\n        uint256 share; // your crystals share in current round \r\n        uint256 questSequence;\r\n        uint256 totalQuestFinish;\r\n        uint256 resetFreeTime;\r\n    }\r\n    struct Quest {\r\n        uint256 typeQuest;\r\n        uint256 levelOne;\r\n        uint256 levelTwo;\r\n        uint256 levelThree;\r\n        uint256 levelFour;\r\n    }\r\n    struct PlayerQuest {\r\n        bool haveQuest;\r\n        uint256 questId;\r\n        uint256 level;\r\n        uint256 numberOfTimes;\r\n        uint256 deposit;\r\n        uint256 miningWarRound;   // current mining war round player join\r\n        uint256 referralCount;    // current referral_count\r\n        uint256 totalMiner;       // current total miner\r\n        uint256 totalEngineer;    // current total engineer\r\n        uint256 airdropGameId;    // current airdrop game id\r\n        uint256 totalJoinAirdrop; // total join the airdrop game\r\n        uint256 nextTimeAtkPlayer; // \r\n        uint256 dameBossWannaCry; // current dame boss\r\n        uint256 levelBossWannaCry; // current boss player atk\r\n    }\r\n    event EndRound(uint256 round, uint256 crystals, uint256 prizePool, uint256 endTime);\r\n    event AddPlayerQuest(address player, uint256 questId, uint256 questLv, uint256 deposit);\r\n    event ConfirmQuest(address player, uint256 questId, uint256 questLv, uint256 deposit, uint256 bonus, uint256 percent);\r\n    modifier isAdministrator()\r\n    {\r\n        require(msg.sender == administrator);\r\n        _;\r\n    }\r\n    modifier disableContract()\r\n    {\r\n        require(tx.origin == msg.sender);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        administrator = msg.sender;\r\n        initQuests();\r\n        engineerAddress = address(0x69fd0e5d0a93bf8bac02c154d343a8e3709adabf);\r\n        setMiningWarInterface(0xf84c61bb982041c030b8580d1634f00fffb89059);\r\n        setEngineerInterface(engineerAddress);\r\n        setAirdropGameInterface(0x5b813a2f4b58183d270975ab60700740af00a3c9);\r\n        setBossWannaCryInterface(0x54e96d609b183196de657fc7380032a96f27f384);\r\n    }\r\n    function initQuests() private\r\n    {\r\n                  //     type   level 1   level 2   level 3   level 4\r\n        quests[0] = Quest(1     , 5       , 10      , 15      , 20   ); // Win x Starter Quest\r\n        quests[1] = Quest(2     , 1       , 2       , 3       , 4    ); // Buy x Miner\r\n        quests[2] = Quest(3     , 1       , 2       , 3       , 4    ); // Buy x Engineer\r\n        quests[3] = Quest(4     , 1       , 1       , 1       , 1    ); // Join An Airdrop Game\r\n        quests[4] = Quest(5     , 1       , 1       , 1       , 1    ); // Attack x Player\r\n        quests[5] = Quest(6     , 100     , 1000    , 10000   ,100000); // Attack x Hp Boss WannaCry\r\n    }\r\n    function () public payable\r\n    {\r\n        if (engineerAddress != msg.sender) addCurrentPrizePool(msg.value);   \r\n    }\r\n    // ---------------------------------------------------------------------------------------\r\n    // SET INTERFACE CONTRACT\r\n    // ---------------------------------------------------------------------------------------\r\n    \r\n    function setMiningWarInterface(address _addr) public isAdministrator\r\n    {\r\n        MiningWar = CryptoMiningWarInterface(_addr);\r\n    }\r\n    function setEngineerInterface(address _addr) public isAdministrator\r\n    {\r\n        CryptoEngineerInterface engineerInterface = CryptoEngineerInterface(_addr);\r\n        \r\n        require(engineerInterface.isContractMiniGame() == true);\r\n\r\n        engineerAddress = _addr;\r\n        Engineer = engineerInterface;\r\n    }\r\n    function setAirdropGameInterface(address _addr) public isAdministrator\r\n    {\r\n        CryptoAirdropGameInterface airdropGameInterface = CryptoAirdropGameInterface(_addr);\r\n        \r\n        require(airdropGameInterface.isContractMiniGame() == true);\r\n\r\n        AirdropGame = airdropGameInterface;\r\n    }\r\n    function setBossWannaCryInterface(address _addr) public isAdministrator\r\n    {\r\n        CryptoBossWannaCryInterface bossWannaCryInterface = CryptoBossWannaCryInterface(_addr);\r\n        \r\n        require(bossWannaCryInterface.isContractMiniGame() == true);\r\n\r\n        BossWannaCry = bossWannaCryInterface;\r\n    }\r\n    /** \r\n    * @dev MainContract used this function to verify game's contract\r\n    */\r\n    function isContractMiniGame() public pure returns( bool _isContractMiniGame )\r\n    {\r\n        _isContractMiniGame = true;\r\n    }\r\n    function upgrade(address addr) public isAdministrator\r\n    {\r\n        selfdestruct(addr);\r\n    }\r\n    // ---------------------------------------------------------------------------------------------\r\n    // SETUP GAME\r\n    // ---------------------------------------------------------------------------------------------\r\n    function setHalfTime(uint256 _time) public isAdministrator\r\n    {\r\n        HALF_TIME = _time;\r\n    }\r\n    function setResetQuestTime(uint256 _time) public isAdministrator\r\n    {\r\n        RESET_QUEST_TIME = _time;\r\n    }\r\n    /** \r\n    * @dev Main Contract call this function to setup mini game.\r\n    */\r\n    function setupMiniGame( uint256 /*_miningWarRoundNumber*/, uint256 _miningWarDeadline ) public\r\n    {\r\n        miningWarDeadline = _miningWarDeadline;\r\n    }\r\n    /**\r\n    * @dev start the mini game\r\n    */\r\n    function startGame() public \r\n    {\r\n        require(msg.sender == administrator);\r\n        require(init == false);\r\n        init = true;\r\n        miningWarDeadline = getMiningWarDealine();\r\n\r\n        games[round].ended = true;\r\n    \r\n        startRound();\r\n    }\r\n    function startRound() private\r\n    {\r\n        require(games[round].ended == true);\r\n\r\n        uint256 crystalsLastRound = games[round].crystals;\r\n        uint256 prizePoolLastRound= games[round].prizePool; \r\n\r\n        round = round + 1;\r\n\r\n        uint256 endTime = now + HALF_TIME;\r\n        // claim 5% of current prizePool as rewards.\r\n        uint256 engineerPrizePool = getEngineerPrizePool();\r\n        uint256 prizePool = SafeMath.div(SafeMath.mul(engineerPrizePool, 5),100); \r\n\r\n        Engineer.claimPrizePool(address(this), prizePool);\r\n        \r\n        if (crystalsLastRound <= 0) prizePool = SafeMath.add(prizePool, prizePoolLastRound);\r\n        \r\n        games[round] = Game(round, 0, prizePool, endTime, false);\r\n    }\r\n    function endRound() private\r\n    {\r\n        require(games[round].ended == false);\r\n        require(games[round].endTime <= now);\r\n\r\n        Game storage g = games[round];\r\n        g.ended = true;\r\n        \r\n        startRound();\r\n\r\n        emit EndRound(g.round, g.crystals, g.prizePool, g.endTime);\r\n    }\r\n    /**\r\n    * @dev player send crystals to the pot\r\n    */\r\n    function share(uint256 _value) public disableContract\r\n    {\r\n        require(miningWarDeadline > now);\r\n        require(games[round].ended == false);\r\n        require(_value >= 10000);\r\n        require(playersQuests[msg.sender].haveQuest == false);\r\n\r\n        MiningWar.subCrystal(msg.sender, _value); \r\n\r\n        if (games[round].endTime <= now) endRound();\r\n        \r\n        updateReward(msg.sender);\r\n\r\n        uint256 _share = SafeMath.mul(_value, CRTSTAL_MINING_PERIOD);\r\n        \r\n        addPlayerQuest(msg.sender, _share);\r\n    }\r\n    function freeResetQuest(address _addr) public disableContract\r\n    {\r\n        _addr = msg.sender;\r\n        resetQuest(_addr);\r\n    }\r\n    function instantResetQuest(address _addr) public payable disableContract\r\n    {\r\n        require(msg.value >= RESET_QUEST_FEE);\r\n\r\n        _addr = msg.sender;\r\n\r\n        uint256 fee = devFee(msg.value);\r\n        address gameSponsor = getGameSponsor();\r\n        gameSponsor.transfer(fee);\r\n        administrator.transfer(fee);\r\n\r\n        uint256 prizePool = msg.value - (fee * 2);\r\n        addEngineerPrizePool(prizePool);\r\n        resetQuest(_addr);\r\n    }\r\n    function confirmQuest(address _addr) public disableContract\r\n    {\r\n        _addr = msg.sender;\r\n        bool _isFinish;\r\n        (_isFinish, ,) = checkQuest(_addr);\r\n        require(_isFinish == true);\r\n        require(playersQuests[_addr].haveQuest  == true);\r\n\r\n        if (games[round].endTime <= now) endRound();\r\n        \r\n        updateReward(_addr);\r\n\r\n        Player storage p      = players[_addr];\r\n        Game storage g        = games[round];\r\n        PlayerQuest storage pQ = playersQuests[_addr];\r\n\r\n        uint256 _share = pQ.deposit;\r\n        uint256 rate = 0;\r\n        // bonus\r\n        // lv 4 50 - 100 %\r\n        if (pQ.questId == 2) rate = 50 + randomNumber(_addr, 0, 51);\r\n        if (pQ.questId == 0 && pQ.level == 4) rate = 50 + randomNumber(_addr, 0, 51); \r\n        if (pQ.questId == 1 && pQ.level == 4) rate = 50 + randomNumber(_addr, 0, 51);\r\n        if (pQ.questId == 5 && pQ.level == 4) rate = 50 + randomNumber(_addr, 0, 51);\r\n        // lv 3 25 - 75 %\r\n        if (pQ.questId == 0 && pQ.level == 3) rate = 25 + randomNumber(_addr, 0, 51); \r\n        if (pQ.questId == 1 && pQ.level == 3) rate = 25 + randomNumber(_addr, 0, 51);\r\n        if (pQ.questId == 5 && pQ.level == 3) rate = 25 + randomNumber(_addr, 0, 51);\r\n        // lv 2 10 - 50 %\r\n        if (pQ.questId == 0 && pQ.level == 2) rate = 10 + randomNumber(_addr, 0, 41); \r\n        if (pQ.questId == 1 && pQ.level == 2) rate = 10 + randomNumber(_addr, 0, 41);\r\n        if (pQ.questId == 5 && pQ.level == 2) rate = 10 + randomNumber(_addr, 0, 41);\r\n        if (pQ.questId == 3) rate = 10 + randomNumber(_addr, 0, 51);\r\n        // lv 1 0 - 25 %\r\n        if (pQ.questId == 0 && pQ.level == 1) rate = randomNumber(_addr, 0, 26); \r\n        if (pQ.questId == 1 && pQ.level == 1) rate = randomNumber(_addr, 0, 26);\r\n        if (pQ.questId == 5 && pQ.level == 1) rate = randomNumber(_addr, 0, 26);\r\n        if (pQ.questId == 4) rate = randomNumber(_addr, 0, 26);\r\n\r\n        if (rate > 0) _share += SafeMath.div(SafeMath.mul(_share, rate), 100);\r\n\r\n        g.crystals = SafeMath.add(g.crystals, _share);\r\n        \r\n        if (p.currentRound == round) {\r\n            p.share = SafeMath.add(p.share, _share);\r\n        } else {\r\n            p.share = _share;\r\n            p.currentRound = round;\r\n        }\r\n\r\n        p.questSequence += 1; \r\n        p.totalQuestFinish += 1; \r\n        pQ.haveQuest = false;\r\n\r\n        emit ConfirmQuest(_addr, pQ.questId, pQ.level, pQ.deposit, SafeMath.sub(_share, pQ.deposit), rate);\r\n\r\n        pQ.deposit = 0; \r\n    }\r\n    function checkQuest(address _addr) public view returns(bool _isFinish, uint256 _numberOfTimes, uint256 _number) \r\n    {\r\n        PlayerQuest memory pQ = playersQuests[_addr];\r\n\r\n        if (pQ.questId == 0) (_isFinish, _numberOfTimes, _number ) = checkWonStarterQuest(_addr); \r\n        if (pQ.questId == 1) (_isFinish, _numberOfTimes, _number ) = checkBuyMinerQuest(_addr); \r\n        if (pQ.questId == 2) (_isFinish, _numberOfTimes, _number ) = checkBuyEngineerQuest(_addr); \r\n        if (pQ.questId == 3) (_isFinish, _numberOfTimes, _number ) = checkJoinAirdropQuest(_addr); \r\n        if (pQ.questId == 4) (_isFinish, _numberOfTimes, _number ) = checkAtkPlayerQuest(_addr); \r\n        if (pQ.questId == 5) (_isFinish, _numberOfTimes, _number ) = ckeckAtkBossWannaCryQuest(_addr); \r\n    }\r\n    \r\n    function getData(address _addr) \r\n    public\r\n    view\r\n    returns(\r\n        // current game\r\n        uint256 _prizePool,\r\n        uint256 _crystals,\r\n        uint256 _endTime,\r\n        // player info\r\n        uint256 _reward,\r\n        uint256 _share,\r\n        uint256 _questSequence,\r\n        // current quest of player\r\n        uint256 _deposit,\r\n        uint256 _resetFreeTime,\r\n        uint256 _typeQuest,\r\n        uint256 _numberOfTimes, \r\n        uint256 _number,\r\n        bool _isFinish,\r\n        bool _haveQuest\r\n    ) {\r\n         (_prizePool, _crystals, _endTime) = getCurrentGame();\r\n         (_reward, _share, _questSequence, , _resetFreeTime)   = getPlayerData(_addr);\r\n         (_haveQuest, _typeQuest, _isFinish, _numberOfTimes, _number, _deposit) = getCurrentQuest(_addr);\r\n         \r\n    }\r\n    function withdrawReward() public disableContract\r\n    {\r\n        if (games[round].endTime <= now) endRound();\r\n        \r\n        updateReward(msg.sender);\r\n        Player storage p = players[msg.sender];\r\n        uint256 balance  = p.reward; \r\n        if (address(this).balance >= balance) {\r\n             msg.sender.transfer(balance);\r\n            // update player\r\n            p.reward = 0;     \r\n        }\r\n    }\r\n    // ---------------------------------------------------------------------------------------------------------------------------------\r\n    // INTERNAL\r\n    // ---------------------------------------------------------------------------------------------------------------------------------\r\n    function addCurrentPrizePool(uint256 _value) private\r\n    {\r\n        require(games[round].ended == false);\r\n        require(init == true);\r\n        games[round].prizePool += _value; \r\n    }\r\n    function devFee(uint256 _amount) private pure returns(uint256)\r\n    {\r\n        return SafeMath.div(SafeMath.mul(_amount, 5), 100);\r\n    }\r\n    function resetQuest(address _addr) private \r\n    {\r\n        if (games[round].endTime <= now) endRound();\r\n        \r\n        updateReward(_addr);\r\n\r\n        uint256 currentQuestId= playersQuests[_addr].questId; \r\n        uint256 questId       = randomNumber(_addr, 0, 6);\r\n\r\n        if (currentQuestId == questId && questId < 5) questId += 1; \r\n        if (currentQuestId == questId && questId >= 5) questId -= 1; \r\n\r\n        uint256 level         = 1 + randomNumber(_addr, questId + 1, 4);\r\n        uint256 numberOfTimes = getNumberOfTimesQuest(questId, level);\r\n\r\n        if (questId == 0) addWonStarterQuest(_addr); // won x starter quest\r\n        if (questId == 1) addBuyMinerQuest(_addr); // buy x miner\r\n        if (questId == 2) addBuyEngineerQuest(_addr); // buy x engineer\r\n        if (questId == 3) addJoinAirdropQuest(_addr); // join airdrop game\r\n        if (questId == 4) addAtkPlayerQuest(_addr); // atk a player\r\n        if (questId == 5) addAtkBossWannaCryQuest(_addr); // atk hp boss\r\n\r\n        PlayerQuest storage pQ = playersQuests[_addr];\r\n        \r\n        players[_addr].questSequence = 0;\r\n        players[_addr].resetFreeTime = now + RESET_QUEST_TIME;\r\n\r\n        pQ.questId       = questId;\r\n        pQ.level         = level;\r\n        pQ.numberOfTimes = numberOfTimes;\r\n        emit AddPlayerQuest(_addr, questId, level, pQ.deposit);\r\n    }\r\n    function getCurrentGame() private view returns(uint256 _prizePool, uint256 _crystals, uint256 _endTime)\r\n    {\r\n        Game memory g = games[round];\r\n        _prizePool = g.prizePool;\r\n        _crystals  = g.crystals;\r\n        _endTime   = g.endTime;\r\n    }\r\n    function getCurrentQuest(address _addr) private view returns(bool _haveQuest, uint256 _typeQuest, bool _isFinish, uint256 _numberOfTimes, uint256 _number, uint256 _deposit)\r\n    {   \r\n        PlayerQuest memory pQ = playersQuests[_addr];\r\n        _haveQuest     = pQ.haveQuest;\r\n        _deposit       = pQ.deposit;\r\n        _typeQuest = quests[pQ.questId].typeQuest;\r\n        (_isFinish, _numberOfTimes, _number) = checkQuest(_addr);\r\n    }\r\n    function getPlayerData(address _addr) private view returns(uint256 _reward, uint256 _share, uint256 _questSequence, uint256 _totalQuestFinish, uint256 _resetFreeTime)\r\n    {\r\n        Player memory p = players[_addr];\r\n        _reward           = p.reward;\r\n        _questSequence    = p.questSequence;\r\n        _totalQuestFinish = p.totalQuestFinish;\r\n        _resetFreeTime    = p.resetFreeTime;\r\n        if (p.currentRound == round) _share = players[_addr].share; \r\n        if (p.currentRound != p.lastRound) _reward += calculateReward(_addr, p.currentRound);\r\n    }\r\n    function updateReward(address _addr) private\r\n    {\r\n        Player storage p = players[_addr];\r\n        \r\n        if ( \r\n            games[p.currentRound].ended == true &&\r\n            p.lastRound < p.currentRound\r\n            ) {\r\n            p.reward = SafeMath.add(p.reward, calculateReward(msg.sender, p.currentRound));\r\n            p.lastRound = p.currentRound;\r\n        }\r\n    }\r\n      /**\r\n    * @dev calculate reward\r\n    */\r\n    function randomNumber(address _addr, uint256 randNonce, uint256 _maxNumber) private view returns(uint256)\r\n    {\r\n        return uint256(keccak256(abi.encodePacked(now, _addr, randNonce))) % _maxNumber;\r\n    }\r\n    function calculateReward(address _addr, uint256 _round) private view returns(uint256)\r\n    {\r\n        Player memory p = players[_addr];\r\n        Game memory g = games[_round];\r\n        if (g.endTime > now) return 0;\r\n        if (g.crystals == 0) return 0; \r\n        return SafeMath.div(SafeMath.mul(g.prizePool, p.share), g.crystals);\r\n    }\r\n    // --------------------------------------------------------------------------------------------------------------\r\n    // ADD QUEST INTERNAL\r\n    // --------------------------------------------------------------------------------------------------------------\r\n    function addPlayerQuest(address _addr, uint256 _share) private\r\n    {\r\n        uint256 questId       = randomNumber(_addr, 0, 6);\r\n        uint256 level         = 1 + randomNumber(_addr, questId + 1, 4);\r\n        uint256 numberOfTimes = getNumberOfTimesQuest(questId, level);\r\n\r\n        if (questId == 0) addWonStarterQuest(_addr); // won x starter quest\r\n        if (questId == 1) addBuyMinerQuest(_addr); // buy x miner\r\n        if (questId == 2) addBuyEngineerQuest(_addr); // buy x engineer\r\n        if (questId == 3) addJoinAirdropQuest(_addr); // join airdrop game\r\n        if (questId == 4) addAtkPlayerQuest(_addr); // atk a player\r\n        if (questId == 5) addAtkBossWannaCryQuest(_addr); // atk hp boss\r\n\r\n        PlayerQuest storage pQ = playersQuests[_addr];\r\n        pQ.deposit       = _share;\r\n        pQ.haveQuest     = true;\r\n        pQ.questId       = questId;\r\n        pQ.level         = level;\r\n        pQ.numberOfTimes = numberOfTimes;\r\n\r\n        players[_addr].resetFreeTime = now + RESET_QUEST_TIME;\r\n\r\n        emit AddPlayerQuest(_addr, questId, level, _share);\r\n    }\r\n    function getNumberOfTimesQuest(uint256 _questId, uint256 _level) private view returns(uint256)\r\n    {\r\n        Quest memory q = quests[_questId];\r\n\r\n        if (_level == 1) return q.levelOne;\r\n        if (_level == 2) return q.levelTwo;\r\n        if (_level == 3) return q.levelThree;\r\n        if (_level == 4) return q.levelFour;\r\n\r\n        return 0;\r\n    } \r\n    function addWonStarterQuest(address _addr) private\r\n    {\r\n        uint256 miningWarRound;\r\n        uint256 referralCount;\r\n        (miningWarRound, referralCount) = getPlayerMiningWarData(_addr);\r\n\r\n        playersQuests[_addr].miningWarRound = miningWarRound;\r\n        playersQuests[_addr].referralCount  = referralCount;\r\n    }\r\n    \r\n    function addBuyMinerQuest(address _addr) private\r\n    {\r\n        uint256 miningWarRound;\r\n        (miningWarRound, ) = getPlayerMiningWarData(_addr);\r\n\r\n        playersQuests[_addr].totalMiner     = getTotalMiner(_addr);\r\n        playersQuests[_addr].miningWarRound = miningWarRound;\r\n    }\r\n    function addBuyEngineerQuest(address _addr) private\r\n    {\r\n        playersQuests[_addr].totalEngineer = getTotalEngineer(_addr);\r\n    }\r\n    function addJoinAirdropQuest(address _addr) private\r\n    {\r\n        uint256 airdropGameId;    // current airdrop game id\r\n        uint256 totalJoinAirdrop;\r\n        (airdropGameId , totalJoinAirdrop) = getPlayerAirdropGameData(_addr);\r\n\r\n        playersQuests[_addr].airdropGameId    = airdropGameId;\r\n        playersQuests[_addr].totalJoinAirdrop = totalJoinAirdrop;\r\n        \r\n    }\r\n    function addAtkPlayerQuest(address _addr) private\r\n    {        \r\n        playersQuests[_addr].nextTimeAtkPlayer = getNextTimeAtkPlayer(_addr);\r\n    }\r\n    function addAtkBossWannaCryQuest(address _addr) private\r\n    {\r\n        uint256 dameBossWannaCry; // current dame boss\r\n        uint256 levelBossWannaCry;\r\n        (levelBossWannaCry, dameBossWannaCry) = getPlayerBossWannaCryData(_addr);\r\n\r\n        playersQuests[_addr].levelBossWannaCry = levelBossWannaCry;\r\n        playersQuests[_addr].dameBossWannaCry  = dameBossWannaCry;\r\n    }\r\n    // --------------------------------------------------------------------------------------------------------------\r\n    // CHECK QUEST INTERNAL\r\n    // --------------------------------------------------------------------------------------------------------------\r\n    function checkWonStarterQuest(address _addr) private view returns(bool _isFinish, uint256 _numberOfTimes, uint256 _number)\r\n    {\r\n        PlayerQuest memory pQ = playersQuests[_addr];\r\n\r\n        uint256 miningWarRound;\r\n        uint256 referralCount;\r\n        (miningWarRound, referralCount) = getPlayerMiningWarData(_addr);\r\n\r\n        _numberOfTimes = pQ.numberOfTimes;\r\n        if (pQ.miningWarRound != miningWarRound) _number = referralCount;\r\n        if (pQ.miningWarRound == miningWarRound) _number = SafeMath.sub(referralCount, pQ.referralCount);    \r\n        if (\r\n            (pQ.miningWarRound != miningWarRound && referralCount >= pQ.numberOfTimes) ||\r\n            (pQ.miningWarRound == miningWarRound && referralCount >= SafeMath.add(pQ.referralCount, pQ.numberOfTimes)) \r\n            ) {\r\n            _isFinish = true;\r\n        } \r\n        \r\n    }\r\n    function checkBuyMinerQuest(address _addr) private view returns(bool _isFinish, uint256 _numberOfTimes, uint256 _number)\r\n    {\r\n        PlayerQuest memory pQ = playersQuests[_addr];\r\n        uint256 miningWarRound;\r\n        (miningWarRound, ) = getPlayerMiningWarData(_addr);\r\n        uint256 totalMiner = getTotalMiner(_addr);\r\n\r\n        _numberOfTimes = pQ.numberOfTimes;\r\n        if (pQ.miningWarRound != miningWarRound) _number = totalMiner;\r\n        if (pQ.miningWarRound == miningWarRound) _number = SafeMath.sub(totalMiner, pQ.totalMiner); \r\n        if (\r\n            (pQ.miningWarRound != miningWarRound && totalMiner >= pQ.numberOfTimes) ||\r\n            (pQ.miningWarRound == miningWarRound && totalMiner >= SafeMath.add(pQ.totalMiner, pQ.numberOfTimes))\r\n            ) {\r\n            _isFinish = true;\r\n        }\r\n    }\r\n    function checkBuyEngineerQuest(address _addr) private view returns(bool _isFinish, uint256 _numberOfTimes, uint256 _number)\r\n    {\r\n        PlayerQuest memory pQ = playersQuests[_addr];\r\n\r\n        uint256 totalEngineer = getTotalEngineer(_addr);\r\n        _numberOfTimes = pQ.numberOfTimes;\r\n        _number = SafeMath.sub(totalEngineer, pQ.totalEngineer); \r\n        if (totalEngineer >= SafeMath.add(pQ.totalEngineer, pQ.numberOfTimes)) {\r\n            _isFinish = true;\r\n        }\r\n    }\r\n    function checkJoinAirdropQuest(address _addr) private view returns(bool _isFinish, uint256 _numberOfTimes, uint256 _number)\r\n    {\r\n        PlayerQuest memory pQ = playersQuests[_addr];\r\n\r\n        uint256 airdropGameId;    // current airdrop game id\r\n        uint256 totalJoinAirdrop;\r\n        (airdropGameId , totalJoinAirdrop) = getPlayerAirdropGameData(_addr);\r\n        _numberOfTimes = pQ.numberOfTimes;\r\n        if (\r\n            (pQ.airdropGameId != airdropGameId) ||\r\n            (pQ.airdropGameId == airdropGameId && totalJoinAirdrop >= SafeMath.add(pQ.totalJoinAirdrop, pQ.numberOfTimes))\r\n            ) {\r\n            _isFinish = true;\r\n            _number = _numberOfTimes;\r\n        }\r\n    }\r\n    function checkAtkPlayerQuest(address _addr) private view returns(bool _isFinish, uint256 _numberOfTimes, uint256 _number)\r\n    {\r\n        PlayerQuest memory pQ = playersQuests[_addr];\r\n\r\n        uint256 nextTimeAtkPlayer = getNextTimeAtkPlayer(_addr);\r\n        _numberOfTimes = pQ.numberOfTimes;\r\n        if (nextTimeAtkPlayer > pQ.nextTimeAtkPlayer) {\r\n            _isFinish = true;\r\n            _number = _numberOfTimes;\r\n        }\r\n    }\r\n    function ckeckAtkBossWannaCryQuest(address _addr) private view returns(bool _isFinish, uint256 _numberOfTimes, uint256 _number)\r\n    {\r\n        PlayerQuest memory pQ = playersQuests[_addr];\r\n\r\n        uint256 dameBossWannaCry; // current dame boss\r\n        uint256 levelBossWannaCry;\r\n        (levelBossWannaCry, dameBossWannaCry) = getPlayerBossWannaCryData(_addr);\r\n        _numberOfTimes = pQ.numberOfTimes;\r\n        if (pQ.levelBossWannaCry != levelBossWannaCry) _number = dameBossWannaCry;\r\n        if (pQ.levelBossWannaCry == levelBossWannaCry) _number = SafeMath.sub(dameBossWannaCry, pQ.dameBossWannaCry);\r\n        if (\r\n            (pQ.levelBossWannaCry != levelBossWannaCry && dameBossWannaCry >= pQ.numberOfTimes) ||\r\n            (pQ.levelBossWannaCry == levelBossWannaCry && dameBossWannaCry >= SafeMath.add(pQ.dameBossWannaCry, pQ.numberOfTimes))\r\n            ) {\r\n            _isFinish = true;\r\n        }\r\n    }\r\n\r\n    // --------------------------------------------------------------------------------------------------------------\r\n    // INTERFACE FUNCTION INTERNAL\r\n    // --------------------------------------------------------------------------------------------------------------\r\n    // Mining War\r\n    function getMiningWarDealine () private view returns(uint256)\r\n    {\r\n        return MiningWar.deadline();\r\n    }\r\n    \r\n    function getTotalMiner(address _addr) private view returns(uint256 _total)\r\n    {\r\n        uint256[8] memory _minersCount;\r\n        (, , , _minersCount, , , , ) = MiningWar.getPlayerData(_addr);\r\n        for (uint256 idx = 0; idx < 8; idx ++) {\r\n            _total += _minersCount[idx];\r\n        }\r\n    }\r\n    function getPlayerMiningWarData(address _addr) private view returns(uint256 _roundNumber, uint256 _referral_count) \r\n    {\r\n        (_roundNumber, , , , _referral_count, ) = MiningWar.players(_addr);\r\n    }\r\n    // ENGINEER\r\n    function addEngineerPrizePool(uint256 _value) private \r\n    {\r\n        Engineer.fallback.value(_value)();\r\n    }\r\n    function getGameSponsor() public view returns(address)\r\n    {\r\n        return Engineer.gameSponsor();\r\n    }\r\n    function getEngineerPrizePool() private view returns(uint256)\r\n    {\r\n        return Engineer.prizePool();\r\n    }\r\n    function getNextTimeAtkPlayer(address _addr) private view returns(uint256 _nextTimeAtk)\r\n    {\r\n        (, , , , , , , _nextTimeAtk,) = Engineer.getPlayerData(_addr);\r\n    }\r\n    function getTotalEngineer(address _addr) private view returns(uint256 _total)\r\n    {\r\n        uint256[8] memory _engineersCount;\r\n        (, , , , , , _engineersCount, ,) = Engineer.getPlayerData(_addr);\r\n        for (uint256 idx = 0; idx < 8; idx ++) {\r\n            _total += _engineersCount[idx];\r\n        }\r\n    }\r\n    // AIRDROP GAME\r\n    function getPlayerAirdropGameData(address _addr) private view returns(uint256 _currentGameId, uint256 _totalJoin)\r\n    {\r\n        (_currentGameId, , , , _totalJoin, ) = AirdropGame.players(_addr);\r\n    }\r\n    // BOSS WANNACRY\r\n    function getPlayerBossWannaCryData(address _addr) private view returns(uint256 _currentBossRoundNumber, uint256 _dame)\r\n    {\r\n        (_currentBossRoundNumber, , , , _dame, ) = BossWannaCry.players(_addr);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setAirdropGameInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"confirmQuest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"crystals\",\"type\":\"uint256\"},{\"name\":\"prizePool\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isContractMiniGame\",\"outputs\":[{\"name\":\"_isContractMiniGame\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getData\",\"outputs\":[{\"name\":\"_prizePool\",\"type\":\"uint256\"},{\"name\":\"_crystals\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256\"},{\"name\":\"_share\",\"type\":\"uint256\"},{\"name\":\"_questSequence\",\"type\":\"uint256\"},{\"name\":\"_deposit\",\"type\":\"uint256\"},{\"name\":\"_resetFreeTime\",\"type\":\"uint256\"},{\"name\":\"_typeQuest\",\"type\":\"uint256\"},{\"name\":\"_numberOfTimes\",\"type\":\"uint256\"},{\"name\":\"_number\",\"type\":\"uint256\"},{\"name\":\"_isFinish\",\"type\":\"bool\"},{\"name\":\"_haveQuest\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setMiningWarInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"playersQuests\",\"outputs\":[{\"name\":\"haveQuest\",\"type\":\"bool\"},{\"name\":\"questId\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"numberOfTimes\",\"type\":\"uint256\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"miningWarRound\",\"type\":\"uint256\"},{\"name\":\"referralCount\",\"type\":\"uint256\"},{\"name\":\"totalMiner\",\"type\":\"uint256\"},{\"name\":\"totalEngineer\",\"type\":\"uint256\"},{\"name\":\"airdropGameId\",\"type\":\"uint256\"},{\"name\":\"totalJoinAirdrop\",\"type\":\"uint256\"},{\"name\":\"nextTimeAtkPlayer\",\"type\":\"uint256\"},{\"name\":\"dameBossWannaCry\",\"type\":\"uint256\"},{\"name\":\"levelBossWannaCry\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setHalfTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AirdropGame\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"freeResetQuest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"Engineer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"instantResetQuest\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"_miningWarDeadline\",\"type\":\"uint256\"}],\"name\":\"setupMiniGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"share\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MiningWar\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawReward\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"checkQuest\",\"outputs\":[{\"name\":\"_isFinish\",\"type\":\"bool\"},{\"name\":\"_numberOfTimes\",\"type\":\"uint256\"},{\"name\":\"_number\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BossWannaCry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"quests\",\"outputs\":[{\"name\":\"typeQuest\",\"type\":\"uint256\"},{\"name\":\"levelOne\",\"type\":\"uint256\"},{\"name\":\"levelTwo\",\"type\":\"uint256\"},{\"name\":\"levelThree\",\"type\":\"uint256\"},{\"name\":\"levelFour\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_time\",\"type\":\"uint256\"}],\"name\":\"setResetQuestTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setBossWannaCryInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"currentRound\",\"type\":\"uint256\"},{\"name\":\"lastRound\",\"type\":\"uint256\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"share\",\"type\":\"uint256\"},{\"name\":\"questSequence\",\"type\":\"uint256\"},{\"name\":\"totalQuestFinish\",\"type\":\"uint256\"},{\"name\":\"resetFreeTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameSponsor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setEngineerInterface\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"crystals\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"prizePool\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"EndRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"questId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"questLv\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"}],\"name\":\"AddPlayerQuest\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"questId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"questLv\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"deposit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonus\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"ConfirmQuest\",\"type\":\"event\"}]","ContractName":"CrystalDeposit","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3b7179a63d2c746c55f82006ec627f04110f2ae912a2820b6bc5505937828857"}]}