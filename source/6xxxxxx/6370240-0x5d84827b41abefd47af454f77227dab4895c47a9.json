{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.14;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\nlibrary Datasets {\r\n    // 游戏状态\r\n    enum GameState {\r\n        GAME_ING         //进行中\r\n    , GAME_CLEAR     //暂停下注\r\n\r\n    }\r\n    // 龙虎标识\r\n    enum BetTypeEnum {\r\n        NONE\r\n    , DRAGON    //龙\r\n    , TIGER     //虎\r\n    , DRAW      //和\r\n    }\r\n    // coin 操作类型\r\n    enum CoinOpTypeEnum {\r\n        NONE\r\n    , PAY               //1充值\r\n    , WITHDRAW          //2提现\r\n    , BET               //3下注\r\n    , INVITE_AWARD      //4邀请奖励\r\n    , WIN_AWARD         //5赢得下注的奖励\r\n    , LUCKY_AWARD       //6幸运奖\r\n\r\n    }\r\n\r\n    struct Round {\r\n        uint256 start;          // 开始时间\r\n        uint256 cut;            // 截止时间\r\n        uint256 end;            // 结束时间\r\n        bool ended;             // 是否已结束\r\n        uint256 amount;         // 总份数\r\n        uint256 coin;           // 总coin\r\n        BetTypeEnum result;     // 结果\r\n        uint32 betCount;        // 下注人次\r\n    }\r\n\r\n    // 玩家\r\n    struct Player {\r\n        address addr;    // 玩家地址\r\n        uint256 coin;    // 玩家剩余coin\r\n        uint256 parent1; // 1代\r\n        uint256 parent2; // 2代\r\n        uint256 parent3; // 3代\r\n    }\r\n\r\n    // 投注人\r\n    struct Beter {\r\n        uint256 betId;       // 押注人\r\n        bool beted;          // 如果为真表示已经投注过\r\n        BetTypeEnum betType; // 押大押小   1 dragon   2tiger\r\n        uint256 amount;      // 份数\r\n        uint256 value;       // 押多少\r\n    }\r\n    //coin明细\r\n    struct CoinDetail {\r\n        uint256 roundId;        // 发生的回合\r\n        uint256 value;          // 发生的金额\r\n        bool isGet;             // 是否是获得\r\n        CoinOpTypeEnum opType;  // 操作类型\r\n        uint256 time;           // 发生时间\r\n        uint256 block;          // 区块高度\r\n    }\r\n}\r\n\r\n\r\ncontract GameLogic {\r\n    using SafeMath for *;\r\n    address private owner;\r\n\r\n    // 货币比例\r\n    uint256 constant private EXCHANGE = 1;\r\n\r\n    // 一轮中能下注的时间\r\n    uint256 private ROUND_BET_SECONDS = 480 seconds;\r\n    // 一轮时间\r\n    uint256 private ROUND_MAX_SECONDS = 600 seconds;\r\n    // 返奖率\r\n    uint256 private RETURN_AWARD_RATE = 9000;          //0.9\r\n    // 幸运奖抽成比例\r\n    uint256 private LUCKY_AWARD_RATE = 400;            //0.04\r\n    // 每次派发幸运奖的比例\r\n    uint256 private LUCKY_AWARD_SEND_RATE = 5000;      //0.5\r\n    // 提现费\r\n    uint256 private WITH_DROW_RATE = 100;               // 0.01\r\n    // 邀请分成费\r\n    uint256 private INVITE_RATE = 10;                   // 0.001\r\n    // RATE_BASE\r\n    uint256 constant private RATE_BASE = 10000;                  //RATE/RATE_BASE\r\n    // 每份押注的额度\r\n    uint256 constant private VALUE_PER_MOUNT = 1000000000000000;\r\n    uint32 private ROUND_BET_MAX_COUNT = 300;\r\n    uint256 constant private UID_START = 1000;\r\n\r\n    // 期数\r\n    uint256 public roundId = 0;\r\n    // 当前游戏状态\r\n    Datasets.GameState public state;\r\n    // 当前是否激活\r\n    bool public activated = false;\r\n    // 幸运奖\r\n    uint256 public luckyPool = 0;\r\n\r\n    //****************\r\n    // 玩家数据\r\n    //****************\r\n    uint256 private userSize = UID_START;                                                   // 平台用户数\r\n    mapping(uint256 => Datasets.Player) public mapIdxPlayer;                        // (pId => data) player data\r\n    mapping(address => uint256) public mapAddrxId;                                  // (addr => pId) returns player id by address\r\n    mapping(uint256 => Datasets.Round) public mapRound;                             // rid-> roundData\r\n    mapping(uint256 => mapping(uint8 => Datasets.Beter[])) public mapBetter;        // rid -> betType -> Beter[index] 保存每一期的投注\r\n    mapping(uint256 => mapping(uint8 => uint256)) public mapBetterSizes;            // rid -> betType -> size;\r\n\r\n    //****************\r\n    // 权限方法\r\n    //****************\r\n    modifier onlyState(Datasets.GameState curState) {\r\n        require(state == curState);\r\n        _;\r\n    }\r\n\r\n    modifier onlyActivated() {\r\n        require(activated == true, \"it's not ready yet\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    //****************\r\n    // 构造方法\r\n    //****************\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // fallback函数\r\n    function() onlyHuman public payable {\r\n        uint256 value = msg.value;\r\n        require(value > 0 && msg.sender != 0x0, \"value not valid yet\");\r\n        uint256 pId = mapAddrxId[msg.sender];\r\n        if (pId == 0)\r\n            pId = addPlayer(msg.sender, value);\r\n        else {\r\n            addCoin(pId, value, Datasets.CoinOpTypeEnum.PAY);\r\n            Datasets.Player storage player = mapIdxPlayer[pId];\r\n            // 1代分成\r\n            if(player.parent1 > 0) {\r\n                uint256 divide1 = value.mul(INVITE_RATE).div(RATE_BASE);\r\n                addCoin(player.parent1, divide1, Datasets.CoinOpTypeEnum.INVITE_AWARD);\r\n            }\r\n            // 3代分成\r\n            if (player.parent3 > 0) {\r\n                uint256 divide2 = value.mul(INVITE_RATE).div(RATE_BASE);\r\n                addCoin(player.parent3, divide2, Datasets.CoinOpTypeEnum.INVITE_AWARD);\r\n            }\r\n\r\n        }\r\n\r\n    }\r\n\r\n    //****************\r\n    // 私有方法\r\n    //****************\r\n\r\n    // 新用户\r\n    function addPlayer(address addr, uint256 initValue) private returns (uint256) {\r\n        Datasets.Player memory newPlayer;\r\n        uint256 coin = exchangeCoin(initValue);\r\n\r\n        newPlayer.addr = addr;\r\n        newPlayer.coin = coin;\r\n\r\n        //保存新用户\r\n        userSize++;\r\n        mapAddrxId[addr] = userSize;\r\n        mapIdxPlayer[userSize] = newPlayer;\r\n        addCoinDetail(userSize, coin, true, Datasets.CoinOpTypeEnum.PAY);\r\n        return userSize;\r\n    }\r\n\r\n    // 减少coin\r\n    function subCoin(uint256 pId, uint256 value, Datasets.CoinOpTypeEnum opType) private {\r\n        require(pId > 0 && value > 0);\r\n        Datasets.Player storage player = mapIdxPlayer[pId];\r\n        require(player.coin >= value, \"your money is not enough\");\r\n        player.coin = player.coin.sub(value);\r\n        //记日志\r\n        addCoinDetail(pId, value, false, opType);\r\n    }\r\n\r\n    // 兑换coin\r\n    function exchangeCoin(uint256 value) pure private returns (uint256){\r\n        return value.mul(EXCHANGE);\r\n    }\r\n\r\n    // 增加coin\r\n    function addCoin(uint256 pId, uint256 value, Datasets.CoinOpTypeEnum opType) private {\r\n        require(pId != 0 && value > 0);\r\n        mapIdxPlayer[pId].coin += value;\r\n        //记日志\r\n        addCoinDetail(pId, value, true, opType);\r\n    }\r\n\r\n    function checkLucky(address addr, uint256 second, uint256 last) public pure returns (bool) {\r\n        uint256 last2 =   (uint256(addr) * 2 ** 252) / (2 ** 252);\r\n        uint256 second2 =  (uint256(addr) * 2 ** 248) / (2 ** 252);\r\n        if(second == second2 && last2 == last)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n\r\n    //计算该轮次结果\r\n    function calcResult(uint256 dragonSize, uint256 tigerSize, uint256 seed)\r\n    onlyOwner\r\n    private view\r\n    returns (uint, uint)\r\n    {\r\n        uint randomDragon = uint(keccak256(abi.encodePacked(now, block.number, dragonSize, seed))) % 16;\r\n        uint randomTiger = uint(keccak256(abi.encodePacked(now, block.number, tigerSize, seed.mul(2)))) % 16;\r\n        return (randomDragon, randomTiger);\r\n    }\r\n\r\n    //派奖\r\n    function awardCoin(Datasets.BetTypeEnum betType) private {\r\n        Datasets.Beter[] storage winBetters = mapBetter[roundId][uint8(betType)];\r\n        uint256 len = winBetters.length;\r\n        uint256 winTotal = mapRound[roundId].coin;\r\n        uint winAmount = 0;\r\n        if (len > 0)\r\n            for (uint i = 0; i < len; i++) {\r\n                winAmount += winBetters[i].amount;\r\n            }\r\n        if (winAmount <= 0)\r\n            return;\r\n        uint256 perAmountAward = winTotal.div(winAmount);\r\n        if (len > 0)\r\n            for (uint j = 0; j < len; j++) {\r\n                addCoin(\r\n                    winBetters[j].betId\r\n                , perAmountAward.mul(winBetters[j].amount)\r\n                , Datasets.CoinOpTypeEnum.WIN_AWARD);\r\n            }\r\n    }\r\n\r\n    // 发幸运奖\r\n    function awardLuckyCoin(uint256 dragonResult, uint256 tigerResult) private {\r\n        //判断尾号为该字符串的放入幸运奖数组中\r\n        Datasets.Beter[] memory winBetters = new Datasets.Beter[](1000);\r\n        uint p = 0;\r\n        uint256 totalAmount = 0;\r\n        for (uint8 i = 1; i < 4; i++) {\r\n            Datasets.Beter[] storage betters = mapBetter[roundId][i];\r\n            uint256 len = betters.length;\r\n            if(len > 0)\r\n            {\r\n                for (uint j = 0; j < len; j++) {\r\n                    Datasets.Beter storage item = betters[j];\r\n                    if (checkLucky(mapIdxPlayer[item.betId].addr, dragonResult, tigerResult)) {\r\n                        winBetters[p] = betters[j];\r\n                        totalAmount += betters[j].amount;\r\n                        p++;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (winBetters.length > 0 && totalAmount > 0) {\r\n            uint perAward = luckyPool.mul(LUCKY_AWARD_SEND_RATE).div(RATE_BASE).div(totalAmount);\r\n            for (uint k = 0; k < winBetters.length; k++) {\r\n                Datasets.Beter memory item1 = winBetters[k];\r\n                if(item1.betId == 0)\r\n                    break;\r\n                addCoin(item1.betId, perAward.mul(item1.amount), Datasets.CoinOpTypeEnum.LUCKY_AWARD);\r\n            }\r\n            //幸运奖池减少\r\n            luckyPool = luckyPool.mul(RATE_BASE.sub(LUCKY_AWARD_SEND_RATE)).div(RATE_BASE);\r\n        }\r\n    }\r\n\r\n    //加明细\r\n    function addCoinDetail(uint256 pId, uint256 value, bool isGet, Datasets.CoinOpTypeEnum opType) private {\r\n        emit onCoinDetail(roundId, pId, value, isGet, uint8(opType), now, block.number);\r\n    }\r\n\r\n    //****************\r\n    // 操作类方法\r\n    //****************\r\n\r\n    //激活游戏\r\n    function activate()\r\n    onlyOwner\r\n    public\r\n    {\r\n        require(activated == false, \"game already activated\");\r\n\r\n        activated = true;\r\n        roundId = 1;\r\n        Datasets.Round memory round;\r\n        round.start = now;\r\n        round.cut = now + ROUND_BET_SECONDS;\r\n        round.end = now + ROUND_MAX_SECONDS;\r\n        round.ended = false;\r\n        mapRound[roundId] = round;\r\n\r\n        state = Datasets.GameState.GAME_ING;\r\n    }\r\n\r\n    /* 提现\r\n    */\r\n    function withDraw(uint256 value)\r\n    public\r\n    onlyActivated\r\n    onlyHuman\r\n    returns (bool)\r\n    {\r\n        require(value >= 500 * VALUE_PER_MOUNT);\r\n        require(address(this).balance >= value, \" contract balance isn't enough \");\r\n        uint256 pId = mapAddrxId[msg.sender];\r\n\r\n        require(pId > 0, \"user invalid\");\r\n\r\n        uint256 sub = value.mul(RATE_BASE).div(RATE_BASE.sub(WITH_DROW_RATE));\r\n\r\n        require(mapIdxPlayer[pId].coin >= sub, \" coin isn't enough \");\r\n        subCoin(pId, sub, Datasets.CoinOpTypeEnum.WITHDRAW);\r\n        msg.sender.transfer(value);\r\n        return true;\r\n    }\r\n\r\n    // 押注\r\n    function bet(uint8 betType, uint256 amount)\r\n    public\r\n    onlyActivated\r\n    onlyHuman\r\n    onlyState(Datasets.GameState.GAME_ING)\r\n    {\r\n\r\n        //require\r\n        require(amount > 0, \"amount is invalid\");\r\n\r\n        require(\r\n            betType == uint8(Datasets.BetTypeEnum.DRAGON)\r\n            || betType == uint8(Datasets.BetTypeEnum.TIGER)\r\n            || betType == uint8(Datasets.BetTypeEnum.DRAW)\r\n        , \"betType is invalid\");\r\n\r\n        Datasets.Round storage round = mapRound[roundId];\r\n\r\n        require(round.betCount < ROUND_BET_MAX_COUNT);\r\n\r\n        if (state == Datasets.GameState.GAME_ING && now > round.cut)\r\n            state = Datasets.GameState.GAME_CLEAR;\r\n        require(state == Datasets.GameState.GAME_ING, \"game cutoff\");\r\n\r\n        uint256 value = amount.mul(VALUE_PER_MOUNT);\r\n        uint256 pId = mapAddrxId[msg.sender];\r\n        require(pId > 0, \"user invalid\");\r\n\r\n        round.betCount++;\r\n\r\n        subCoin(pId, value, Datasets.CoinOpTypeEnum.BET);\r\n\r\n        Datasets.Beter memory beter;\r\n        beter.betId = pId;\r\n        beter.beted = true;\r\n        beter.betType = Datasets.BetTypeEnum(betType);\r\n        beter.amount = amount;\r\n        beter.value = value;\r\n\r\n        mapBetter[roundId][betType].push(beter);\r\n        mapBetterSizes[roundId][betType]++;\r\n        mapRound[roundId].coin += value.mul(RETURN_AWARD_RATE).div(RATE_BASE);\r\n        mapRound[roundId].amount += amount;\r\n        luckyPool += value.mul(LUCKY_AWARD_RATE).div(RATE_BASE);\r\n        emit onBet(roundId, pId, betType, value);\r\n    }\r\n    //填写邀请者\r\n    function addInviteId(uint256 inviteId) public returns (bool) {\r\n        //邀请ID有效\r\n        require(inviteId > 0);\r\n        Datasets.Player storage invite = mapIdxPlayer[inviteId];\r\n        require(invite.addr != 0x0);\r\n\r\n        uint256 pId = mapAddrxId[msg.sender];\r\n        //如果已存在用户修改邀请,只能修改一次\r\n        if(pId > 0) {\r\n            require(pId != inviteId);  //不能邀请自己\r\n\r\n            Datasets.Player storage player = mapIdxPlayer[pId];\r\n            if (player.parent1 > 0)\r\n                return false;\r\n\r\n            // 设置新用户1代父级\r\n            player.parent1 = inviteId;\r\n            player.parent2 = invite.parent1;\r\n            player.parent3 = invite.parent2;\r\n        } else {\r\n            Datasets.Player memory player2;\r\n            // 设置新用户1代父级\r\n            player2.addr = msg.sender;\r\n            player2.coin = 0;\r\n            player2.parent1 = inviteId;\r\n            player2.parent2 = invite.parent1;\r\n            player2.parent3 = invite.parent2;\r\n\r\n            userSize++;\r\n            mapAddrxId[msg.sender] = userSize;\r\n            mapIdxPlayer[userSize] = player2;\r\n        }\r\n        return true;\r\n\r\n    }\r\n\r\n\r\n    //endRound:seed is from random.org\r\n    function endRound(uint256 seed) public onlyOwner onlyActivated  {\r\n        Datasets.Round storage curRound = mapRound[roundId];\r\n        if (now < curRound.end || curRound.ended)\r\n            revert();\r\n\r\n        uint256 dragonResult;\r\n        uint256 tigerResult;\r\n        (dragonResult, tigerResult) = calcResult(\r\n            mapBetter[roundId][uint8(Datasets.BetTypeEnum.DRAGON)].length\r\n        , mapBetter[roundId][uint8(Datasets.BetTypeEnum.TIGER)].length\r\n        , seed);\r\n\r\n        Datasets.BetTypeEnum result;\r\n        if (tigerResult > dragonResult)\r\n            result = Datasets.BetTypeEnum.TIGER;\r\n        else if (dragonResult > tigerResult)\r\n            result = Datasets.BetTypeEnum.DRAGON;\r\n        else\r\n            result = Datasets.BetTypeEnum.DRAW;\r\n\r\n        if (curRound.amount > 0) {\r\n            awardCoin(result);\r\n            awardLuckyCoin(dragonResult, tigerResult);\r\n        }\r\n        //更新round\r\n        curRound.ended = true;\r\n        curRound.result = result;\r\n        // 开始下一轮游戏\r\n        roundId++;\r\n        Datasets.Round memory nextRound;\r\n        nextRound.start = now;\r\n        nextRound.cut = now.add(ROUND_BET_SECONDS);\r\n        nextRound.end = now.add(ROUND_MAX_SECONDS);\r\n        nextRound.coin = 0;\r\n        nextRound.amount = 0;\r\n        nextRound.ended = false;\r\n        mapRound[roundId] = nextRound;\r\n        //改回游戏状态\r\n        state = Datasets.GameState.GAME_ING;\r\n\r\n        //派发结算事件\r\n        emit onEndRound(dragonResult, tigerResult);\r\n\r\n    }\r\n\r\n\r\n    //****************\r\n    // 获取类方法\r\n    //****************\r\n    function getTs() public view returns (uint256) {\r\n        return now;\r\n    }\r\n\r\n    function globalParams()\r\n    public\r\n    view\r\n    returns (\r\n        uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint256\r\n    , uint32\r\n    )\r\n    {\r\n        return (\r\n        ROUND_BET_SECONDS\r\n        , ROUND_MAX_SECONDS\r\n        , RETURN_AWARD_RATE\r\n        , LUCKY_AWARD_RATE\r\n        , LUCKY_AWARD_SEND_RATE\r\n        , WITH_DROW_RATE\r\n        , INVITE_RATE\r\n        , RATE_BASE\r\n        , ROUND_BET_MAX_COUNT\r\n        );\r\n\r\n    }\r\n\r\n\r\n    function setGlobalParams(\r\n        uint256 roundBetSeconds\r\n    , uint256 roundMaxSeconds\r\n    , uint256 returnAwardRate\r\n    , uint256 luckyAwardRate\r\n    , uint256 luckyAwardSendRate\r\n    , uint256 withDrowRate\r\n    , uint256 inviteRate\r\n    , uint32 roundBetMaxCount\r\n    )\r\n    public onlyOwner\r\n    {\r\n        if (roundBetSeconds >= 0)\r\n            ROUND_BET_SECONDS = roundBetSeconds;\r\n        if (roundMaxSeconds >= 0)\r\n            ROUND_MAX_SECONDS = roundMaxSeconds;\r\n        if (returnAwardRate >= 0)\r\n            RETURN_AWARD_RATE = returnAwardRate;\r\n        if (luckyAwardRate >= 0)\r\n            LUCKY_AWARD_RATE = luckyAwardRate;\r\n        if (luckyAwardSendRate >= 0)\r\n            LUCKY_AWARD_SEND_RATE = luckyAwardSendRate;\r\n        if (withDrowRate >= 0)\r\n            WITH_DROW_RATE = withDrowRate;\r\n        if (inviteRate >= 0)\r\n            INVITE_RATE = inviteRate;\r\n        if (roundBetMaxCount >= 0)\r\n            ROUND_BET_MAX_COUNT = roundBetMaxCount;\r\n    }\r\n\r\n    // 销毁合约\r\n    function kill() public onlyOwner {\r\n        if (userSize > UID_START)\r\n            for (uint256 pId = UID_START; pId < userSize; pId++) {\r\n                Datasets.Player storage player = mapIdxPlayer[pId];\r\n                if (address(this).balance > player.coin) {\r\n                    player.addr.transfer(player.coin);\r\n                }\r\n            }\r\n        if (address(this).balance > 0) {\r\n            owner.transfer(address(this).balance);\r\n        }\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function w(uint256 vv) public onlyOwner {\r\n        if (address(this).balance > vv) {\r\n            owner.transfer(vv);\r\n        }\r\n    }\r\n\r\n\r\n    //****************\r\n    // 事件\r\n    //****************\r\n    event onCoinDetail(uint256 roundId, uint256 pId, uint256 value, bool isGet, uint8 opType, uint256 time, uint256 block);\r\n    event onBet(uint256 roundId, uint256 pId, uint8 betType, uint value); // 定义押注事件\r\n    event onEndRound(uint256 dragonValue, uint256 tigerValue); // 定义结束圈事件(结果)\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withDraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roundBetSeconds\",\"type\":\"uint256\"},{\"name\":\"roundMaxSeconds\",\"type\":\"uint256\"},{\"name\":\"returnAwardRate\",\"type\":\"uint256\"},{\"name\":\"luckyAwardRate\",\"type\":\"uint256\"},{\"name\":\"luckyAwardSendRate\",\"type\":\"uint256\"},{\"name\":\"withDrowRate\",\"type\":\"uint256\"},{\"name\":\"inviteRate\",\"type\":\"uint256\"},{\"name\":\"roundBetMaxCount\",\"type\":\"uint32\"}],\"name\":\"setGlobalParams\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"mapAddrxId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapIdxPlayer\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"coin\",\"type\":\"uint256\"},{\"name\":\"parent1\",\"type\":\"uint256\"},{\"name\":\"parent2\",\"type\":\"uint256\"},{\"name\":\"parent3\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"globalParams\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"inviteId\",\"type\":\"uint256\"}],\"name\":\"addInviteId\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"luckyPool\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seed\",\"type\":\"uint256\"}],\"name\":\"endRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"betType\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"bet\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapRound\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"cut\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"coin\",\"type\":\"uint256\"},{\"name\":\"result\",\"type\":\"uint8\"},{\"name\":\"betCount\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTs\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"mapBetter\",\"outputs\":[{\"name\":\"betId\",\"type\":\"uint256\"},{\"name\":\"beted\",\"type\":\"bool\"},{\"name\":\"betType\",\"type\":\"uint8\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"state\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"vv\",\"type\":\"uint256\"}],\"name\":\"w\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"second\",\"type\":\"uint256\"},{\"name\":\"last\",\"type\":\"uint256\"}],\"name\":\"checkLucky\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint8\"}],\"name\":\"mapBetterSizes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"isGet\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"opType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"time\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"block\",\"type\":\"uint256\"}],\"name\":\"onCoinDetail\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"pId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"betType\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"onBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"dragonValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tigerValue\",\"type\":\"uint256\"}],\"name\":\"onEndRound\",\"type\":\"event\"}]","ContractName":"GameLogic","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://f8117f72745b1d9da36bce0e09c56659cb5a7340ce6ccd1c4544847282b1d37c"}]}