{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n * @title ICO for Aumonet token based on ERC20 and ERC223 standards\r\n *\r\n * R&D performed and issued by BLOCKCHAIN INNOVATIVE TECHNOLOGIES LTD\r\n * Company number 11344164\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev https://github.com/ethereum/EIPs/issues/223\r\n * @dev Based on code from OpenZeppelin: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/StandardToken.sol\r\n *      and on code from Dexaran ERC223: https://github.com/Dexaran/ERC223-token-standard/blob/master/token/ERC223/ERC223_token.sol\r\n */\r\n\r\n/**\r\n * Contract that is working with ERC223 tokens\r\n */\r\n\r\ncontract ContractReceiver {\r\n\tfunction tokenFallback(address _from, uint _value, bytes _data)public pure {\r\n\t\t/* Fix for Mist warning */\r\n\t\t_from;\r\n\t\t_value;\r\n\t\t_data;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n\t/**\r\n\t * @dev Multiplies two numbers, throws on overflow.\r\n\t */\r\n\tfunction mul(uint256 a, uint256 b)internal pure returns(uint256 c) {\r\n\t\t// Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n\t\t// benefit is lost if 'b' is also tested.\r\n\t\t// See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n\t\tif (a == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tc = a * b;\r\n\t\tassert(c / a == b);\r\n\t\treturn c;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Integer division of two numbers, truncating the quotient.\r\n\t */\r\n\tfunction div(uint256 a, uint256 b)internal pure returns(uint256) {\r\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\r\n\t\t// uint256 c = a / b;\r\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\t\treturn a / b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n\t */\r\n\tfunction sub(uint256 a, uint256 b)internal pure returns(uint256) {\r\n\t\tassert(b <= a);\r\n\t\treturn a - b;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Adds two numbers, throws on overflow.\r\n\t */\r\n\tfunction add(uint256 a, uint256 b)internal pure returns(uint256 c) {\r\n\t\tc = a + b;\r\n\t\tassert(c >= a);\r\n\t\treturn c;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n\taddress public owner;\r\n\r\n\tevent OwnershipRenounced(address indexed previousOwner);\r\n\tevent OwnershipTransferred(address indexed previousOwner, address indexed _newOwner);\r\n\r\n\t/**\r\n\t * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n\t * account.\r\n\t */\r\n\tconstructor()public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Throws if called by any account other than the owner.\r\n\t */\r\n\tmodifier onlyOwner() {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n\t * @param _newOwner The address to transfer ownership to.\r\n\t */\r\n\tfunction transferOwnership(address _newOwner)public onlyOwner {\r\n\t\trequire(_newOwner != address(0));\r\n\t\temit OwnershipTransferred(owner, _newOwner);\r\n\t\towner = _newOwner;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Allows the current owner to relinquish control of the contract.\r\n\t */\r\n\tfunction renounceOwnership()public onlyOwner {\r\n\t\temit OwnershipRenounced(owner);\r\n\t\towner = address(0);\r\n\t}\r\n}\r\n\r\ncontract ERC223Interface {\r\n\tuint public _totalSupply;\r\n\tfunction balanceOf(address who)public view returns(uint);\r\n\r\n\tfunction totalSupply()public view returns(uint256) {\r\n\t\treturn _totalSupply;\r\n\t}\r\n\r\n\tevent Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n}\r\n\r\n/**\r\n * @title Aumonet ERC223 token\r\n *\r\n * @dev Implementation of the ERC223 token.\r\n * @dev https://github.com/ethereum/EIPs/issues/223\r\n * @dev Based on code from Dexaran ERC223: https://github.com/Dexaran/ERC223-token-standard/blob/master/token/ERC223/ERC223_token.sol\r\n */\r\ncontract AumonetERC223 is ERC223Interface {\r\n\tusing SafeMath for uint256;\r\n\r\n\t/* Contract Variables */\r\n\taddress public owner;\r\n\tmapping(address => uint256)public balances;\r\n\tmapping(address => mapping(address => uint256))public allowed;\r\n\r\n\tconstructor()public {\r\n\t\towner = msg.sender;\r\n\t}\r\n\r\n\t/* ERC20 Events */\r\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\r\n\tevent Approval(address indexed from, address indexed to, uint256 value);\r\n\r\n\t/* ERC223 Events */\r\n\tevent Transfer(address indexed from, address indexed to, uint value, bytes data);\r\n\r\n\t/* Returns the balance of a particular account */\r\n\tfunction balanceOf(address _address)public view returns(uint256 balance) {\r\n\t\treturn balances[_address];\r\n\t}\r\n\r\n\t/* Transfer the balance from the sender's address to the address _to */\r\n\tfunction transfer(address _to, uint _value)public returns(bool success) {\r\n\t\tbytes memory empty;\r\n\t\tif (isContract(_to)) {\r\n\t\t\treturn transferToContract(_to, _value, empty);\r\n\t\t} else {\r\n\t\t\treturn transferToAddress(_to, _value, empty);\r\n\t\t}\r\n\t}\r\n\r\n\t/* Withdraws to address _to form the address _from up to the amount _value */\r\n\tfunction transferFrom(address _from, address _to, uint256 _value)public returns(bool success) {\r\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to].add(_value) > balances[_to]) {\r\n\t\t\tbalances[_from] = balances[_from].sub(_value);\r\n\t\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n\t\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\t\temit Transfer(_from, _to, _value);\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\r\n\t/* Allows _spender to withdraw the _allowance amount form sender */\r\n\tfunction approve(address _spender, uint256 _allowance)public returns(bool success) {\r\n\t\tallowed[msg.sender][_spender] = _allowance;\r\n\t\temit Approval(msg.sender, _spender, _allowance);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* Checks how much _spender can withdraw from _owner */\r\n\tfunction allowance(address _owner, address _spender)public view returns(uint256 remaining) {\r\n\t\treturn allowed[_owner][_spender];\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Standard function transfer used in ERC223 with _data parameter and custom fallback\r\n\t *\r\n\t * @dev called when a user or another ERC223 contract wants to transfer tokens.\r\n\t * @dev transfer token to a specified address\r\n\t * @param _to The address to transfer to.\r\n\t * @param _value The amount to be transferred.\r\n\t * @param _data There is a way to attach bytes _data to token transaction similar to _data attached to Ether transactions.\r\n\t * @param _custom_fallback If there are defined custom fallbacks in ERC223 contracts, you specify it here.\r\n\t */\r\n\tfunction transfer(address _to, uint _value, bytes _data, string _custom_fallback)public returns(bool success) {\r\n\t\tif (isContract(_to)) {\r\n\t\t\treturn transferToContractWithCustomFallback(_to, _value, _data, _custom_fallback);\r\n\t\t} else {\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Transfer the specified amount of tokens to the specified address.\r\n\t *\r\n\t * @dev Invokes the `tokenFallback` function if the recipient is a contract.\r\n\t * The token transfer fails if the recipient is a contract\r\n\t * but does not implement the `tokenFallback` function\r\n\t * or the fallback function to receive funds.\r\n\t *\r\n\t * @param _to    Receiver address.\r\n\t * @param _value Amount of tokens that will be transferred.\r\n\t * @param _data  Transaction metadata.\r\n\t */\r\n\tfunction transfer(address _to, uint _value, bytes _data)public returns(bool) {\r\n\t\tif (isContract(_to)) {\r\n\t\t\treturn transferToContract(_to, _value, _data);\r\n\t\t} else {\r\n\t\t\treturn transferToAddress(_to, _value, _data);\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Standard check for ERC223 functions\r\n\t *\r\n\t * @param _addr The address to be checked if it is contract address or not\r\n\t */\r\n\tfunction isContract(address _addr)private view returns(bool is_contract) {\r\n\t\tuint length;\r\n\t\tassembly {\r\n\t\t\t//retrieve the size of the code on target address, this needs assembly\r\n\t\t\tlength := extcodesize(_addr)\r\n\t\t}\r\n\t\treturn (length > 0);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function that is called when transaction target is an address\r\n\t *\r\n\t * @dev called when a user or another ERC223 contract wants to transfer tokens to a wallet address.\r\n\t * @dev transfer token to a specified address\r\n\t * @param _to The address to transfer to.\r\n\t * @param _value The amount to be transferred.\r\n\t * @param _data There is a way to attach bytes _data to token transaction similar to _data attached to Ether transactions.\r\n\t */\r\n\tfunction transferToAddress(address _to, uint _value, bytes _data)private returns(bool success) {\r\n\t\trequire(balances[msg.sender] >= _value);\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function that is called when transaction target is contract\r\n\t *\r\n\t * @dev called when a user or another ERC223 contract wants to transfer tokens to a contract address.\r\n\t * @dev transfer token to a specified address\r\n\t * @param _to The address to transfer to.\r\n\t * @param _value The amount to be transferred.\r\n\t * @param _data There is a way to attach bytes _data to token transaction similar to _data attached to Ether transactions.\r\n\t */\r\n\tfunction transferToContract(address _to, uint _value, bytes _data)private returns(bool success) {\r\n\t\trequire(balances[msg.sender] >= _value);\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tContractReceiver receiver = ContractReceiver(_to);\r\n\t\treceiver.tokenFallback(msg.sender, _value, _data);\r\n\t\temit Transfer(msg.sender, _to, _value);\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function that is called when transaction target is contract with custom fallback\r\n\t *\r\n\t * @dev called when a user or another ERC223 contract wants to transfer tokens.\r\n\t * @dev transfer token to a specified address\r\n\t * @param _to The address to transfer to.\r\n\t * @param _value The amount to be transferred.\r\n\t * @param _data There is a way to attach bytes _data to token transaction similar to _data attached to Ether transactions.\r\n\t * @param _custom_fallback If there are defined custom fallbacks in ERC223 contracts, you specify it here.\r\n\t */\r\n\tfunction transferToContractWithCustomFallback(address _to, uint _value, bytes _data, string _custom_fallback)private returns(bool success) {\r\n\t\trequire(balances[msg.sender] >= _value);\r\n\t\tbalances[msg.sender] = balances[msg.sender].sub(_value);\r\n\t\tbalances[_to] = balances[_to].add(_value);\r\n\t\tassert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data));\r\n\t\temit Transfer(msg.sender, _to, _value, _data);\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/* Stops any attempt to send Ether to this contract */\r\n\tfunction ()public {\r\n\t\trevert();\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n\tusing SafeMath for uint256;\r\n\r\n\tevent Pause();\r\n\tevent Unpause();\r\n\r\n\tbool public paused = false;\r\n\r\n\tuint _pauseStartTime = 0;\r\n\tuint _pauseTime = 0;\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is not paused.\r\n\t */\r\n\tmodifier whenNotPaused() {\r\n\t\trequire(!paused);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Modifier to make a function callable only when the contract is paused.\r\n\t */\r\n\tmodifier whenPaused() {\r\n\t\trequire(paused);\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev called for get pause time\r\n\t */\r\n\tfunction pauseTime()public view returns(uint256) {\r\n\t\treturn _pauseTime;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev called by the owner to pause, triggers stopped state\r\n\t */\r\n\tfunction pause()onlyOwner whenNotPaused public {\r\n\t\t_pauseStartTime = block.timestamp;\r\n\t\tpaused = true;\r\n\t\temit Pause();\r\n\t}\r\n\r\n\t/**\r\n\t * @dev called by the owner to unpause, returns to normal state\r\n\t */\r\n\tfunction unpause()onlyOwner whenPaused public {\r\n\t\t_pauseTime = _pauseTime.add(block.timestamp.sub(_pauseStartTime));\r\n\r\n\t\tpaused = false;\r\n\t\temit Unpause();\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is AumonetERC223, Pausable {\r\n\r\n\tfunction transfer(address _to, uint256 _value)public whenNotPaused returns(bool) {\r\n\t\treturn super.transfer(_to, _value);\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint _value, bytes _data, string _custom_fallback)public whenNotPaused returns(bool) {\r\n\t\treturn super.transfer(_to, _value, _data, _custom_fallback);\r\n\t}\r\n\r\n\tfunction transfer(address _to, uint256 _value, bytes _data)public whenNotPaused returns(bool) {\r\n\t\treturn super.transfer(_to, _value, _data);\r\n\t}\r\n\r\n\tfunction transferFrom(address _from, address _to, uint256 _value)public whenNotPaused returns(bool) {\r\n\t\treturn super.transferFrom(_from, _to, _value);\r\n\t}\r\n\r\n\tfunction approve(address _spender, uint256 _value)public whenNotPaused returns(bool) {\r\n\t\treturn super.approve(_spender, _value);\r\n\t}\r\n\r\n\tfunction increaseApproval(address _spender, uint _addedValue)public whenNotPaused returns(bool success) {\r\n\t\tallowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n\r\n\tfunction decreaseApproval(address _spender, uint _subtractedValue)public whenNotPaused returns(bool success) {\r\n\t\tuint256 oldValue = allowed[msg.sender][_spender];\r\n\t\tif (_subtractedValue > oldValue) {\r\n\t\t\tallowed[msg.sender][_spender] = 0;\r\n\t\t} else {\r\n\t\t\tallowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n\t\t}\r\n\t\temit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Ownable Token\r\n * @dev Token that has modified transfer functions with onlyOwner approval.\r\n */\r\ncontract OwnableToken is PausableToken {\r\n\r\n\tevent Burn(address indexed burner, uint256 value);\r\n\r\n\t/**\r\n\t * @notice Allows the owner to transfer out any accidentally sent ERC20 tokens.\r\n\t *\r\n\t * @param _tokenAddress The address of the ERC20 contract.\r\n\t * @param _amount The amount of tokens to be transferred.\r\n\t */\r\n\tfunction transferAnyERC20Token(address _tokenAddress, uint256 _amount)onlyOwner public returns(bool success) {\r\n\t\treturn AumonetERC223(_tokenAddress).transfer(owner, _amount);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Burns a specific amount of tokens.\r\n\t * @param _value The amount of token to be burned.\r\n\t */\r\n\tfunction burn(uint256 _value)public {\r\n\t\t_burn(msg.sender, _value);\r\n\t}\r\n\r\n\tfunction _burn(address _who, uint256 _value)internal {\r\n\t\trequire(_value <= balances[_who]);\r\n\t\t// no need to require value <= totalSupply, since that would imply the\r\n\t\t// sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n\t\tbalances[_who] = balances[_who].sub(_value);\r\n\t\t_totalSupply = _totalSupply.sub(_value);\r\n\t\temit Burn(_who, _value);\r\n\t\temit Transfer(_who, address(0), _value);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title Aumonet Token\r\n * @dev Defining constants used in Aumonet smart contract.\r\n */\r\ncontract AumonetToken is OwnableToken {\r\n\r\n\t/* Contract Constants */\r\n\tstring public _name = \"Ezekiel\";\r\n\tstring public _symbol = \"EZ37\";\r\n\tuint8 public _decimals = 5;\r\n\tuint256 public _creatorSupply;\r\n\tuint256 public _icoSupply;\r\n\tuint256 public _bonusSupply = 187000 * (10 ** uint256(_decimals)); // The Bonus scheme supply is 17% (187 000 tokens);\r\n\r\n\tconstructor()public {\r\n\t\t//pause();\r\n\r\n\t\t_totalSupply = 1100000 * (10 ** uint256(_decimals));\r\n\r\n\t\t_creatorSupply = _totalSupply * 25 / 100; // The creator has 25% of tokens\r\n\t\t_icoSupply = _totalSupply * 58 / 100; // Smart contract balance is 58% of tokens (638 000 tokens)\r\n\r\n\t\t//balances[this] = _icoSupply.add(_bonusSupply); // Token balance to smart contract.\r\n\t\t//balances[msg.sender] = _creatorSupply;\r\n\t\tbalances[msg.sender] = _icoSupply.add(_bonusSupply);\r\n\t\tbalances[tx.origin] = _creatorSupply; //instead of tx.origin should be address of where will be sended money\r\n\r\n\t}\r\n\r\n\tfunction name()public view returns(string) {\r\n\t\treturn _name;\r\n\t}\r\n\r\n\tfunction symbol()public view returns(string) {\r\n\t\treturn _symbol;\r\n\t}\r\n\r\n\tfunction decimals()public view returns(uint8) {\r\n\t\treturn _decimals;\r\n\t}\r\n\r\n\tfunction bonusSupply()public view returns(uint256) {\r\n\t\treturn _bonusSupply;\r\n\t}\r\n\r\n\tfunction icoSupply()public view returns(uint256) {\r\n\t\treturn _icoSupply;\r\n\t}\r\n\r\n}\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overriden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropiate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale {\r\n\tusing SafeMath for uint256;\r\n\r\n\t// The token being sold\r\n\tAumonetToken public token;\r\n\r\n\t// start and end timestamps of crowdsale\r\n\tuint public start; // the start date of the crowdsale\r\n\tuint public end; // the end date of the crowdsale\r\n\tuint256 increaseTime; // time paused\r\n\t// Address where funds are collected\r\n\taddress public wallet;\r\n\r\n\t// How many token units a buyer gets per eth.\r\n\t// The rate is the conversion between wei and the smallest and indivisible token unit.\r\n\tuint256 public ethRate;\r\n\r\n\t// Amount of wei raised\r\n\tuint256 public totalWeiRaised; // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here.\r\n\r\n\tuint256 public tokensSold; // the number of tokens already sold\r\n\r\n\tbool public crowdsaleClosed = false; // indicates if the crowdsale has been closed already\r\n\r\n\r\n\t/**\r\n\t * Event for token purchase logging\r\n\t * @param purchaser who paid for the tokens\r\n\t * @param beneficiary who got the tokens\r\n\t * @param value weis paid for purchase\r\n\t * @param amount amount of tokens purchased\r\n\t */\r\n\tevent TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount);\r\n\r\n\t/**\r\n\t * @param _wallet Address where collected funds will be forwarded to\r\n\t * @param _startICO starting time of ICO\r\n\t * @param _endICO ending time of ICO\r\n\t */\r\n\tconstructor(address _wallet, uint _startICO, uint _endICO)public {\r\n\t\trequire(_wallet != address(0));\r\n\r\n\t\ttoken = new AumonetToken(); // creates the token to be sold.\r\n\t\tethRate = 124; // Set the rate of token to ether exchange for the ICO\r\n\t\ttotalWeiRaised = 0;\r\n\t\ttokensSold = 0;\r\n\t\tstart = _startICO; // Start of ICO is at 08.11.2018 00:00 (UTC)\r\n\t\tend = _endICO; // End of ICO is at 20.12.2018 23:59 (UTC)\r\n\t\tincreaseTime = 0;\r\n\t\twallet = _wallet;\r\n\t}\r\n\r\n\tmodifier afterDeadline() {\r\n\t\tincreaseTime = token.pauseTime();\r\n\t\trequire(block.timestamp > end.add(increaseTime));\r\n\t\t_;\r\n\t}\r\n\r\n\t// -----------------------------------------\r\n\t// Crowdsale external interface\r\n\t// -----------------------------------------\r\n\r\n\t/**\r\n\t * @dev fallback function ***DO NOT OVERRIDE***\r\n\t */\r\n\tfunction ()external payable {\r\n\t\tbuyTokens(msg.sender);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function calls other functions to calculate tokenamount to send to beneficiary. Checks if the process of buying is correct.\r\n\t *\r\n\t * @dev low level token purchase\r\n\t * @param _beneficiary Address performing the token purchase\r\n\t */\r\n\tfunction buyTokens(address _beneficiary)public payable {}\r\n\r\n\t// -----------------------------------------\r\n\t// Crowdsale internal interface (extensible)\r\n\t// -----------------------------------------\r\n\r\n\t/**\r\n\t * @notice Validation of an incoming purchase.\r\n\t *\r\n\t * @dev Use require statements to revert state when conditions are not met. Use super to concatenate validations.\r\n\t * @param _beneficiary Address performing the token purchase\r\n\t * @param _weiAmount Value in wei involved in the purchase\r\n\t */\r\n\tfunction _preValidatePurchase(address _beneficiary, uint256 _weiAmount)internal {\r\n\t\trequire(_beneficiary != address(0));\r\n\t\trequire(_weiAmount != 0);\r\n\t\tincreaseTime = token.pauseTime();\r\n\t\trequire(!crowdsaleClosed && block.timestamp >= start.add(increaseTime) && block.timestamp <= end.add(increaseTime));\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function transfers tokens from contract to beneficiary address.\r\n\t *\r\n\t * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n\t * @param _beneficiary Address performing the token purchase\r\n\t * @param _tokenAmount Number of tokens to be emitted\r\n\t */\r\n\tfunction _deliverTokens(address _beneficiary, uint256 _tokenAmount)internal {\r\n\t\ttoken.transfer(_beneficiary, _tokenAmount);\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function to calculate tokenamount from wei.\r\n\t *\r\n\t * @dev Override to extend the way in which ether is converted to tokens.\r\n\t * @param _weiAmount Value in wei to be converted into tokens\r\n\t * @return Number of tokens that can be purchased with the specified _weiAmount\r\n\t */\r\n\tfunction _getTokenAmount(uint256 _weiAmount)internal view returns(uint256) {\r\n\t\t_weiAmount = _weiAmount.mul(ethRate).div(100);\r\n\t\treturn _weiAmount.div(10 ** uint(18 - token.decimals())); //as we have other decimals number than standard 18, we need to calculate\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Determines how ETH is stored/forwarded on purchases.\r\n\t */\r\n\tfunction _forwardFunds()internal {\r\n\t\twallet.transfer(msg.value);\r\n\t}\r\n\r\n\t// @return true if crowdsale event has ended\r\n\tfunction hasEnded()public returns(bool) {\r\n\t\tincreaseTime = token.pauseTime();\r\n\t\treturn now > end.add(increaseTime);\r\n\t}\r\n}\r\n\r\n/**\r\n * @title FinalizableCrowdsale\r\n * @dev Extension of Crowdsale where an owner can do extra work\r\n * after finishing.\r\n */\r\ncontract FinalizableCrowdsale is Crowdsale, Ownable {\r\n\r\n\tbool public isFinalized = false;\r\n\r\n    event Finalized();\r\n\r\n\tconstructor()Ownable()public {}\r\n\r\n\t/**\r\n\t * @notice Failsafe transfer of tokens for the team to owner wallet.\r\n\t */\r\n\tfunction withdrawTokens()onlyOwner public returns(bool) {\r\n\t\trequire(token.transfer(owner, token.balanceOf(this)));\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function to indicate the end of ICO.\r\n\t *\r\n\t * @dev Must be called after crowdsale ends, to do some extra finalization\r\n\t * work. Calls the contract's finalization function.\r\n\t */\r\n\tfunction finalize()onlyOwner afterDeadline public {\r\n\t\trequire(!crowdsaleClosed);\r\n\r\n\t\temit Finalized();\r\n\t\twithdrawTokens();\r\n\r\n\t\tcrowdsaleClosed = true;\r\n\t\tisFinalized = true;\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Can be overridden to add finalization logic. The overriding function\r\n\t * should call super.finalization() to ensure the chain of finalization is\r\n\t * executed entirely.\r\n\t */\r\n\tfunction finalization()internal {}\r\n}\r\n\r\ncontract AumonetICO is FinalizableCrowdsale {\r\n\tusing SafeMath for uint256;\r\n\r\n\tuint256 public BONUS_TOKENS = 18700000000;\r\n\t/**\r\n\t * Defining timestamps for bonuscheme from White Paper.\r\n\t * The start of bonuses is 8 November 2018 and the end is 20 December 2018.\r\n\t * There are 2 seconds in between changing the phases.  */\r\n\tuint256 startOfFirstBonus;\r\n\tuint256 endOfFirstBonus;\r\n\tuint256 startOfSecondBonus;\r\n\tuint256 endOfSecondBonus;\r\n\tuint256 startOfThirdBonus;\r\n\tuint256 endOfThirdBonus;\r\n\tuint256 startOfFourthBonus;\r\n\tuint256 endOfFourthBonus;\r\n\tuint256 startOfFifthBonus;\r\n\tuint256 endOfFifthBonus;\r\n\r\n\t/**\r\n\t * Defining bonuses according to White Paper.\r\n\t * First week there is bonus 30%.\r\n\t * Second week there is bonus 25%.\r\n\t * Third week there is bonus 20%.\r\n\t * Fourth week there is bonus 15%.\r\n\t * Fifth week there is bonus 10%.\r\n\t * The remaining week will have bonus 3%.\r\n\t */\r\n\tuint256 firstBonus = 30;\r\n\tuint256 secondBonus = 25;\r\n\tuint256 thirdBonus = 20;\r\n\tuint256 fourthBonus = 15;\r\n\tuint256 fifthBonus = 10;\r\n\tuint256 sixthBonus = 3;\r\n\r\n\tconstructor(address _wallet, uint _startICO, uint _endICO)FinalizableCrowdsale()Crowdsale(_wallet, _startICO, _endICO)public {\r\n\t\t/*\r\n\t\t * Set bonusscheme week values\r\n\t\t */\r\n\t\tstartOfFirstBonus = _startICO;\r\n\t\tendOfFirstBonus = (startOfFirstBonus - 1) + 8 days;\r\n\t\tstartOfSecondBonus = (startOfFirstBonus + 1) + 8 days;\r\n\t\tendOfSecondBonus = (startOfSecondBonus - 1) + 8 days;\r\n\t\tstartOfThirdBonus = (startOfSecondBonus + 1) + 8 days;\r\n\t\tendOfThirdBonus = (startOfThirdBonus - 1) + 8 days;\r\n\t\tstartOfFourthBonus = (startOfThirdBonus + 1) + 8 days;\r\n\t\tendOfFourthBonus = (startOfFourthBonus - 1) + 8 days;\r\n\t\tstartOfFifthBonus = (startOfFourthBonus + 1) + 8 days;\r\n\t\tendOfFifthBonus = (startOfFifthBonus - 1) + 8 days;\r\n\r\n\t}\r\n\r\n\tevent BonusCalculated(uint256 tokenAmount);\r\n\tevent BonusSent(address indexed from, address indexed to, uint256 boughtTokens, uint256 bonusTokens);\r\n\r\n\tmodifier beforeICO() {\r\n\t\tincreaseTime = token.pauseTime();\r\n\t\trequire(block.timestamp <= start.add(increaseTime));\r\n\t\t_;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Sets how many tokens have we sold in PRE-ICO phase\r\n\t *\r\n\t * @param _soldTokens Number of tokens sold in PRE-ICO. The number needs to be multiplied by 10**number of decimals before entering it into function.\r\n\t * @param _raisedWei The amount of ETH in wei raised in PRE-ICO.\r\n\t */\r\n\tfunction setPreICOSoldAmount(uint256 _soldTokens, uint256 _raisedWei)onlyOwner beforeICO public {\r\n\t\ttokensSold = tokensSold.add(_soldTokens);\r\n\t\ttotalWeiRaised = totalWeiRaised.add(_raisedWei);\r\n\t}\r\n\r\n\t/**\r\n\t * @dev Calculates from Bonus Scheme how many tokens can be added to purchased _tokenAmount.\r\n\t * @param _tokenAmount The amount of calculated tokens to sent Ether.\r\n\t * @return Number of bonus tokens that can be granted with the specified _tokenAmount.\r\n\t */\r\n\tfunction getBonusTokens(uint256 _tokenAmount)public returns(uint256) {\r\n\t\tincreaseTime = token.pauseTime();\r\n\t\tif (block.timestamp >= startOfFirstBonus.add(increaseTime) && block.timestamp <= endOfFirstBonus.add(increaseTime)) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(firstBonus).div(100);\r\n\t\t} else if (block.timestamp >= startOfSecondBonus.add(increaseTime) && block.timestamp <= endOfSecondBonus.add(increaseTime)) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(secondBonus).div(100);\r\n\t\t} else if (block.timestamp >= startOfThirdBonus.add(increaseTime) && block.timestamp <= endOfThirdBonus.add(increaseTime)) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(thirdBonus).div(100);\r\n\t\t} else if (block.timestamp >= startOfFourthBonus.add(increaseTime) && block.timestamp <= endOfFourthBonus.add(increaseTime)) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(fourthBonus).div(100);\r\n\t\t} else if (block.timestamp >= startOfFifthBonus.add(increaseTime) && block.timestamp <= endOfFifthBonus.add(increaseTime)) {\r\n\t\t\t_tokenAmount = _tokenAmount.mul(fifthBonus).div(100);\r\n\t\t} else\r\n\t\t\t_tokenAmount = _tokenAmount.mul(sixthBonus).div(100);\r\n\t\temit BonusCalculated(_tokenAmount);\r\n\t\treturn _tokenAmount;\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function calls other functions to calculate tokenamount to send to beneficiary. Checks if the process of buying is correct.\r\n\t *\r\n\t * @dev low level token purchase\r\n\t * @param _beneficiary Address performing the token purchase\r\n\t */\r\n\tfunction buyTokens(address _beneficiary)public payable {\r\n\t\tuint256 weiAmount = msg.value;\r\n\t\t_preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n\t\tuint256 tokens = _getTokenAmount(weiAmount); // calculate token amount to be sold\r\n\r\n\t\trequire(token.balanceOf(this) >= tokens); //check if the contract has enough tokens\r\n\r\n\t\ttotalWeiRaised = totalWeiRaised.add(weiAmount); //update state\r\n\t\ttokensSold = tokensSold.add(tokens); //update state\r\n\r\n\t\t_deliverTokens(_beneficiary, tokens);\r\n\t\temit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens);\r\n\t\t_processBonus(msg.sender, tokens);\r\n\r\n\t\t_forwardFunds();\r\n\t}\r\n\r\n\t/**\r\n\t * @notice Function to calculate bonus from bought tokens.\r\n\t *\r\n\t * @dev Executed when a purchase has been validated and bonus tokens need to be calculated. Not necessarily emits/sends bonus tokens.\r\n\t * @param _beneficiary Address receiving the tokens\r\n\t * @param _tokenAmount Number of tokens from which is calculated bonus amount\r\n\t */\r\n\tfunction _processBonus(address _beneficiary, uint256 _tokenAmount)internal {\r\n\t\tuint256 bonusTokens = getBonusTokens(_tokenAmount); // Calculate bonus token amount\r\n\t\tif (BONUS_TOKENS < bonusTokens) { // If the bonus scheme does not have enough tokens, send all remaining\r\n\t\t\tbonusTokens = BONUS_TOKENS;\r\n\t\t}\r\n\t\tif (bonusTokens > 0) { // If there are no tokens left in bonus scheme, we do not need transaction.\r\n\t\t\tBONUS_TOKENS = BONUS_TOKENS.sub(bonusTokens);\r\n\t\t\ttoken.transfer(_beneficiary, bonusTokens);\r\n\t\t\temit BonusSent(address(token), _beneficiary, _tokenAmount, bonusTokens);\r\n\t\t\ttokensSold = tokensSold.add(bonusTokens); // update state of sold tokens\r\n\t\t}\r\n\t}\r\n\r\n\tfunction transferTokenOwnership(address _newOwner)public {\r\n\t\ttoken.transferOwnership(_newOwner);\r\n\t}\r\n\r\n\tfunction finalization()internal {\r\n\t\ttoken.transferOwnership(wallet);\r\n\t}\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferTokenOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokensSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalWeiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAmount\",\"type\":\"uint256\"}],\"name\":\"getBonusTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"BONUS_TOKENS\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"start\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsaleClosed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_soldTokens\",\"type\":\"uint256\"},{\"name\":\"_raisedWei\",\"type\":\"uint256\"}],\"name\":\"setPreICOSoldAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"buyTokens\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"hasEnded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_startICO\",\"type\":\"uint256\"},{\"name\":\"_endICO\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"BonusCalculated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"boughtTokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusTokens\",\"type\":\"uint256\"}],\"name\":\"BonusSent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenPurchase\",\"type\":\"event\"}]","ContractName":"AumonetICO","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000800ba6f5762d297b14c9c75dae4479e4a1ac55bb000000000000000000000000000000000000000000000000000000005be37c80000000000000000000000000000000000000000000000000000000005c1c2cc4","Library":"","SwarmSource":"bzzr://8efc5c875760e95c28c099a5af332c338fc0ccbd1c6f72113bc7023dc63d4b6b"}]}