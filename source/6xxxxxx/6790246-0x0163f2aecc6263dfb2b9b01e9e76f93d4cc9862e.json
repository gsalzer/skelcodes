{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.25;\r\n\r\nlibrary SafeMath8 {\r\n\r\n    function mul(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint8 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        uint8 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint8 a, uint8 b) internal pure returns (uint8) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint8 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath16 {\r\n\r\n    function mul(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint16 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        uint16 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint16 a, uint16 b) internal pure returns (uint16) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint16 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeMath256 {\r\n\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a / b;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function pow(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) return 0;\r\n        if (b == 0) return 1;\r\n\r\n        uint256 c = a ** b;\r\n        assert(c / (a ** (b - 1)) == a);\r\n        return c;\r\n    }\r\n}\r\n\r\nlibrary SafeConvert {\r\n\r\n    function toUint8(uint256 _value) internal pure returns (uint8) {\r\n        assert(_value <= 255);\r\n        return uint8(_value);\r\n    }\r\n\r\n    function toUint16(uint256 _value) internal pure returns (uint16) {\r\n        assert(_value <= 2**16 - 1);\r\n        return uint16(_value);\r\n    }\r\n\r\n    function toUint32(uint256 _value) internal pure returns (uint32) {\r\n        assert(_value <= 2**32 - 1);\r\n        return uint32(_value);\r\n    }\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    function _validateAddress(address _addr) internal pure {\r\n        require(_addr != address(0), \"invalid address\");\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"not a contract owner\");\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        _validateAddress(newOwner);\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Controllable is Ownable {\r\n    mapping(address => bool) controllers;\r\n\r\n    modifier onlyController {\r\n        require(_isController(msg.sender), \"no controller rights\");\r\n        _;\r\n    }\r\n\r\n    function _isController(address _controller) internal view returns (bool) {\r\n        return controllers[_controller];\r\n    }\r\n\r\n    function _setControllers(address[] _controllers) internal {\r\n        for (uint256 i = 0; i < _controllers.length; i++) {\r\n            _validateAddress(_controllers[i]);\r\n            controllers[_controllers[i]] = true;\r\n        }\r\n    }\r\n}\r\n\r\ncontract Upgradable is Controllable {\r\n    address[] internalDependencies;\r\n    address[] externalDependencies;\r\n\r\n    function getInternalDependencies() public view returns(address[]) {\r\n        return internalDependencies;\r\n    }\r\n\r\n    function getExternalDependencies() public view returns(address[]) {\r\n        return externalDependencies;\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        for (uint256 i = 0; i < _newDependencies.length; i++) {\r\n            _validateAddress(_newDependencies[i]);\r\n        }\r\n        internalDependencies = _newDependencies;\r\n    }\r\n\r\n    function setExternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        externalDependencies = _newDependencies;\r\n        _setControllers(_newDependencies);\r\n    }\r\n}\r\n\r\ncontract Getter {\r\n    function getDragonParents(uint256) external view returns (uint256[2]) {}\r\n}\r\n\r\n\r\n\r\n\r\n//////////////CONTRACT//////////////\r\n\r\n\r\n\r\n\r\ncontract DragonUtils {\r\n    using SafeMath8 for uint8;\r\n    using SafeMath256 for uint256;\r\n\r\n    using SafeConvert for uint256;\r\n\r\n\r\n    function _getActiveGene(uint8[16] _gene) internal pure returns (uint8[3] gene) {\r\n        uint8 _index = _getActiveGeneIndex(_gene); // find active gene\r\n        for (uint8 i = 0; i < 3; i++) {\r\n            gene[i] = _gene[i + (_index * 4)]; // get all data for this gene\r\n        }\r\n    }\r\n\r\n    function _getActiveGeneIndex(uint8[16] _gene) internal pure returns (uint8) {\r\n        return _gene[3] >= _gene[7] ? 0 : 1;\r\n    }\r\n\r\n    // returns 10 active genes (one for each part of the body) with the next structure:\r\n    // each gene is an array of 3 elements:\r\n    // 0 - type of dragon\r\n    // 1 - gene type\r\n    // 2 - gene level\r\n    function _getActiveGenes(uint8[16][10] _genome) internal pure returns (uint8[30] genome) {\r\n        uint8[3] memory _activeGene;\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            _activeGene = _getActiveGene(_genome[i]);\r\n            genome[i * 3] = _activeGene[0];\r\n            genome[i * 3 + 1] = _activeGene[1];\r\n            genome[i * 3 + 2] = _activeGene[2];\r\n        }\r\n    }\r\n\r\n    function _getIndexAndFactor(uint8 _counter) internal pure returns (uint8 index, uint8 factor) {\r\n        if (_counter < 44) index = 0;\r\n        else if (_counter < 88) index = 1;\r\n        else if (_counter < 132) index = 2;\r\n        else index = 3;\r\n        factor = _counter.add(1) % 4 == 0 ? 10 : 100;\r\n    }\r\n\r\n    function _parseGenome(uint256[4] _composed) internal pure returns (uint8[16][10] parsed) {\r\n        uint8 counter = 160; // 40 genes with 4 values in each one\r\n        uint8 _factor;\r\n        uint8 _index;\r\n\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            for (uint8 j = 0; j < 16; j++) {\r\n                counter = counter.sub(1);\r\n                // _index - index of value in genome array where current gene is stored\r\n                // _factor - denominator that determines the number of digits\r\n                (_index, _factor) = _getIndexAndFactor(counter);\r\n                parsed[9 - i][15 - j] = (_composed[_index] % _factor).toUint8();\r\n                _composed[_index] /= _factor;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _composeGenome(uint8[16][10] _parsed) internal pure returns (uint256[4] composed) {\r\n        uint8 counter = 0;\r\n        uint8 _index;\r\n        uint8 _factor;\r\n\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            for (uint8 j = 0; j < 16; j++) {\r\n                (_index, _factor) = _getIndexAndFactor(counter);\r\n                composed[_index] = composed[_index].mul(_factor);\r\n                composed[_index] = composed[_index].add(_parsed[i][j]);\r\n                counter = counter.add(1);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DragonGenetics is Upgradable, DragonUtils {\r\n    using SafeMath16 for uint16;\r\n    using SafeMath256 for uint256;\r\n\r\n    Getter getter;\r\n\r\n    uint8 constant MUTATION_CHANCE = 1; // 10%\r\n    uint16[7] genesWeights = [300, 240, 220, 190, 25, 15, 10];\r\n\r\n    // choose pair\r\n    function _chooseGen(uint8 _random, uint8[16] _array1, uint8[16] _array2) internal pure returns (uint8[16] gen) {\r\n        uint8 x = _random.div(2);\r\n        uint8 y = _random % 2;\r\n        for (uint8 j = 0; j < 2; j++) {\r\n            for (uint8 k = 0; k < 4; k++) {\r\n                gen[k.add(j.mul(8))] = _array1[k.add(j.mul(4)).add(x.mul(8))];\r\n                gen[k.add(j.mul(2).add(1).mul(4))] = _array2[k.add(j.mul(4)).add(y.mul(8))];\r\n            }\r\n        }\r\n    }\r\n\r\n    function _getParents(uint256 _id) internal view returns (uint256[2]) {\r\n        if (_id != 0) {\r\n            return getter.getDragonParents(_id);\r\n        }\r\n        return [uint256(0), uint256(0)];\r\n    }\r\n\r\n    function _checkInbreeding(uint256[2] memory _parents) internal view returns (uint8 chance) {\r\n        uint8 _relatives;\r\n        uint8 i;\r\n        uint256[2] memory _parents_1_1 = _getParents(_parents[0]);\r\n        uint256[2] memory _parents_1_2 = _getParents(_parents[1]);\r\n        // check grandparents\r\n        if (_parents_1_1[0] != 0 && (_parents_1_1[0] == _parents_1_2[0] || _parents_1_1[0] == _parents_1_2[1])) {\r\n            _relatives = _relatives.add(1);\r\n        }\r\n        if (_parents_1_1[1] != 0 && (_parents_1_1[1] == _parents_1_2[0] || _parents_1_1[1] == _parents_1_2[1])) {\r\n            _relatives = _relatives.add(1);\r\n        }\r\n        // check parents and grandparents\r\n        if (_parents[0] == _parents_1_2[0] || _parents[0] == _parents_1_2[1]) {\r\n            _relatives = _relatives.add(1);\r\n        }\r\n        if (_parents[1] == _parents_1_1[0] || _parents[1] == _parents_1_1[1]) {\r\n            _relatives = _relatives.add(1);\r\n        }\r\n        if (_relatives >= 2) return 8; // 80% chance of a bad mutation\r\n        if (_relatives == 1) chance = 7; // 70% chance\r\n        // check grandparents and great-grandparents\r\n        uint256[12] memory _ancestors;\r\n        uint256[2] memory _parents_2_1 = _getParents(_parents_1_1[0]);\r\n        uint256[2] memory _parents_2_2 = _getParents(_parents_1_1[1]);\r\n        uint256[2] memory _parents_2_3 = _getParents(_parents_1_2[0]);\r\n        uint256[2] memory _parents_2_4 = _getParents(_parents_1_2[1]);\r\n        for (i = 0; i < 2; i++) {\r\n            _ancestors[i.mul(6).add(0)] = _parents_1_1[i];\r\n            _ancestors[i.mul(6).add(1)] = _parents_1_2[i];\r\n            _ancestors[i.mul(6).add(2)] = _parents_2_1[i];\r\n            _ancestors[i.mul(6).add(3)] = _parents_2_2[i];\r\n            _ancestors[i.mul(6).add(4)] = _parents_2_3[i];\r\n            _ancestors[i.mul(6).add(5)] = _parents_2_4[i];\r\n        }\r\n        for (i = 0; i < 12; i++) {\r\n            for (uint8 j = i.add(1); j < 12; j++) {\r\n                if (_ancestors[i] != 0 && _ancestors[i] == _ancestors[j]) {\r\n                    _relatives = _relatives.add(1);\r\n                    _ancestors[j] = 0;\r\n                }\r\n                if (_relatives > 2 || (_relatives == 2 && chance == 0)) return 8; // 80% chance\r\n            }\r\n        }\r\n        if (_relatives == 1 && chance == 0) return 5; // 50% chance\r\n    }\r\n\r\n    function _mutateGene(uint8[16] _gene, uint8 _genType) internal pure returns (uint8[16]) {\r\n        uint8 _index = _getActiveGeneIndex(_gene);\r\n        _gene[_index.mul(4).add(1)] = _genType; // new gene type\r\n        _gene[_index.mul(4).add(2)] = 1; // reset level\r\n        return _gene;\r\n    }\r\n\r\n    // select one of 16 variations\r\n    function _calculateGen(\r\n        uint8[16] _momGen,\r\n        uint8[16] _dadGen,\r\n        uint8 _random\r\n    ) internal pure returns (uint8[16] gen) {\r\n        if (_random < 4) {\r\n            return _chooseGen(_random, _momGen, _momGen);\r\n        } else if (_random < 8) {\r\n            return _chooseGen(_random.sub(4), _momGen, _dadGen);\r\n        } else if (_random < 12) {\r\n            return _chooseGen(_random.sub(8), _dadGen, _dadGen);\r\n        } else {\r\n            return _chooseGen(_random.sub(12), _dadGen, _momGen);\r\n        }\r\n    }\r\n\r\n    function _calculateGenome(\r\n        uint8[16][10] memory _momGenome,\r\n        uint8[16][10] memory _dadGenome,\r\n        uint8 _uglinessChance,\r\n        uint256 _seed_\r\n    ) internal pure returns (uint8[16][10] genome) {\r\n        uint256 _seed = _seed_;\r\n        uint256 _random;\r\n        uint8 _mutationChance = _uglinessChance == 0 ? MUTATION_CHANCE : _uglinessChance;\r\n        uint8 _geneType;\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            (_random, _seed) = _getSpecialRandom(_seed, 4);\r\n            genome[i] = _calculateGen(_momGenome[i], _dadGenome[i], (_random % 16).toUint8());\r\n            (_random, _seed) = _getSpecialRandom(_seed, 1);\r\n            if (_random < _mutationChance) {\r\n                _geneType = 0;\r\n                if (_uglinessChance == 0) {\r\n                    (_random, _seed) = _getSpecialRandom(_seed, 2);\r\n                    _geneType = (_random % 9).add(1).toUint8(); // [1..9]\r\n                }\r\n                genome[i] = _mutateGene(genome[i], _geneType);\r\n            }\r\n        }\r\n    }\r\n\r\n    // 40 points in sum\r\n    function _calculateDragonTypes(uint8[16][10] _genome) internal pure returns (uint8[11] dragonTypesArray) {\r\n        uint8 _dragonType;\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            for (uint8 j = 0; j < 4; j++) {\r\n                _dragonType = _genome[i][j.mul(4)];\r\n                dragonTypesArray[_dragonType] = dragonTypesArray[_dragonType].add(1);\r\n            }\r\n        }\r\n    }\r\n\r\n    function createGenome(\r\n        uint256[2] _parents,\r\n        uint256[4] _momGenome,\r\n        uint256[4] _dadGenome,\r\n        uint256 _seed\r\n    ) external view returns (\r\n        uint256[4] genome,\r\n        uint8[11] dragonTypes\r\n    ) {\r\n        uint8 _uglinessChance = _checkInbreeding(_parents);\r\n        uint8[16][10] memory _parsedGenome = _calculateGenome(\r\n            _parseGenome(_momGenome),\r\n            _parseGenome(_dadGenome),\r\n            _uglinessChance,\r\n            _seed\r\n        );\r\n        genome = _composeGenome(_parsedGenome);\r\n        dragonTypes = _calculateDragonTypes(_parsedGenome);\r\n    }\r\n\r\n    function _getWeightedRandom(uint256 _random) internal view returns (uint8) {\r\n        uint16 _weight;\r\n        for (uint8 i = 1; i < 7; i++) {\r\n            _weight = _weight.add(genesWeights[i.sub(1)]);\r\n            if (_random < _weight) return i;\r\n        }\r\n        return 7;\r\n    }\r\n\r\n    function _generateGen(uint8 _dragonType, uint256 _random) internal view returns (uint8[16]) {\r\n        uint8 _geneType = _getWeightedRandom(_random); // [1..7]\r\n        return [\r\n            _dragonType, _geneType, 1, 1,\r\n            _dragonType, _geneType, 1, 0,\r\n            _dragonType, _geneType, 1, 0,\r\n            _dragonType, _geneType, 1, 0\r\n        ];\r\n    }\r\n\r\n    // max 4 digits\r\n    function _getSpecialRandom(\r\n        uint256 _seed_,\r\n        uint8 _digits\r\n    ) internal pure returns (uint256, uint256) {\r\n        uint256 _base = 10;\r\n        uint256 _seed = _seed_;\r\n        uint256 _random = _seed % _base.pow(_digits);\r\n        _seed = _seed.div(_base.pow(_digits));\r\n        return (_random, _seed);\r\n    }\r\n\r\n    function createGenomeForGenesis(uint8 _dragonType, uint256 _seed_) external view returns (uint256[4]) {\r\n        uint256 _seed = _seed_;\r\n        uint8[16][10] memory _genome;\r\n        uint256 _random;\r\n        for (uint8 i = 0; i < 10; i++) {\r\n            (_random, _seed) = _getSpecialRandom(_seed, 3);\r\n            _genome[i] = _generateGen(_dragonType, _random);\r\n        }\r\n        return _composeGenome(_genome);\r\n    }\r\n\r\n    function setInternalDependencies(address[] _newDependencies) public onlyOwner {\r\n        super.setInternalDependencies(_newDependencies);\r\n\r\n        getter = Getter(_newDependencies[0]);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_parents\",\"type\":\"uint256[2]\"},{\"name\":\"_momGenome\",\"type\":\"uint256[4]\"},{\"name\":\"_dadGenome\",\"type\":\"uint256[4]\"},{\"name\":\"_seed\",\"type\":\"uint256\"}],\"name\":\"createGenome\",\"outputs\":[{\"name\":\"genome\",\"type\":\"uint256[4]\"},{\"name\":\"dragonTypes\",\"type\":\"uint8[11]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_dragonType\",\"type\":\"uint8\"},{\"name\":\"_seed_\",\"type\":\"uint256\"}],\"name\":\"createGenomeForGenesis\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[4]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setExternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newDependencies\",\"type\":\"address[]\"}],\"name\":\"setInternalDependencies\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getInternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExternalDependencies\",\"outputs\":[{\"name\":\"\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"DragonGenetics","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://af6b427757548232cf809372b5d42285cbaa36261bf20a0f2a5239be94f54795"}]}