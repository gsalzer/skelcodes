{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n\r\ncontract Administration {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    address public owner;\r\n    address public admin;\r\n\r\n    event AdminSet(address _admin);\r\n    event OwnershipTransferred(address _previousOwner, address _newOwner);\r\n\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == owner || msg.sender == admin);\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroAddress(address _addr) {\r\n        require(_addr != address(0), \"must be non zero address\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        admin = msg.sender;\r\n    }\r\n\r\n    function setAdmin(\r\n        address _newAdmin\r\n    )\r\n        public\r\n        onlyOwner\r\n        nonZeroAddress(_newAdmin)\r\n        returns (bool)\r\n    {\r\n        require(_newAdmin != admin);\r\n        admin = _newAdmin;\r\n        emit AdminSet(_newAdmin);\r\n        return true;\r\n    }\r\n\r\n    function transferOwnership(\r\n        address _newOwner\r\n    )\r\n        public\r\n        onlyOwner\r\n        nonZeroAddress(_newOwner)\r\n        returns (bool)\r\n    {\r\n        owner = _newOwner;\r\n        emit OwnershipTransferred(msg.sender, _newOwner);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n\r\nlibrary SafeMath {\r\n\r\n  // We use `pure` bbecause it promises that the value for the function depends ONLY\r\n  // on the function arguments\r\n    function mul(uint256 a, uint256 b) internal pure  returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a / b;\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n    ERC20 Standard Token interface\r\n*/\r\ninterface ERC20Interface {\r\n    function owner() external view returns (address);\r\n    function decimals() external view returns (uint8);\r\n    function transfer(address _to, uint256 _value) external returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool);\r\n    function approve(address _spender, uint256 _amount) external returns (bool);\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address _owner) external view returns (uint256);\r\n    function allowance(address _owner, address _spender) external view returns (uint256);\r\n}\r\n\r\ninterface StakeInterface {\r\n    function activeStakes() external view returns (uint256);\r\n}\r\n\r\n/// @title RTC Token Contract\r\n/// @author Postables, RTrade Technologies Ltd\r\n/// @dev We able V5 for safety features, see https://solidity.readthedocs.io/en/v0.4.24/security-considerations.html#take-warnings-seriously\r\ncontract RTCoin is Administration {\r\n\r\n    using SafeMath for uint256;\r\n\r\n    // this is the initial supply of tokens, 61.6 Million\r\n    uint256 constant public INITIALSUPPLY = 61600000000000000000000000;\r\n    string  constant public VERSION = \"production\";\r\n\r\n    // this is the interface that allows interaction with the staking contract\r\n    StakeInterface public stake = StakeInterface(0);\r\n    // this is the address of the staking contract\r\n    address public  stakeContractAddress = address(0);\r\n    // This is the address of the merged mining contract, not yet developed\r\n    address public  mergedMinerValidatorAddress = address(0);\r\n    string  public  name = \"RTCoin\";\r\n    string  public  symbol = \"RTC\";\r\n    uint256 public  totalSupply = INITIALSUPPLY;\r\n    uint8   public  decimals = 18;\r\n    // allows transfers to be frozen, but enable them by default\r\n    bool    public  transfersFrozen = true;\r\n    bool    public  stakeFailOverRestrictionLifted = false;\r\n\r\n    mapping (address => uint256) public balances;\r\n    mapping (address => mapping (address => uint256)) public allowed;\r\n    mapping (address => bool) public minters;\r\n\r\n    event Transfer(address indexed _sender, address indexed _recipient, uint256 _amount);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\r\n    event TransfersFrozen(bool indexed _transfersFrozen);\r\n    event TransfersThawed(bool indexed _transfersThawed);\r\n    event ForeignTokenTransfer(address indexed _sender, address indexed _recipient, uint256 _amount);\r\n    event EthTransferOut(address indexed _recipient, uint256 _amount);\r\n    event MergedMinerValidatorSet(address _contractAddress);\r\n    event StakeContractSet(address _contractAddress);\r\n    event FailOverStakeContractSet(address _contractAddress);\r\n    event CoinsMinted(address indexed _stakeContract, address indexed _recipient, uint256 _mintAmount);\r\n\r\n    modifier transfersNotFrozen() {\r\n        require(!transfersFrozen, \"transfers must not be frozen\");\r\n        _;\r\n    }\r\n\r\n    modifier transfersAreFrozen() {\r\n        require(transfersFrozen, \"transfers must be frozen\");\r\n        _;\r\n    }\r\n\r\n    // makes sure that only the stake contract, or merged miner validator contract can mint coins\r\n    modifier onlyMinters() {\r\n        require(minters[msg.sender] == true, \"sender must be a valid minter\");\r\n        _;\r\n    }\r\n\r\n    modifier nonZeroAddress(address _addr) {\r\n        require(_addr != address(0), \"must be non zero address\");\r\n        _;\r\n    }\r\n\r\n    modifier nonAdminAddress(address _addr) {\r\n        require(_addr != owner && _addr != admin, \"addr cant be owner or admin\");\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        balances[msg.sender] = totalSupply;\r\n        emit Transfer(address(0), msg.sender, totalSupply);\r\n    }\r\n\r\n    /** @notice Used to transfer tokens\r\n        * @param _recipient This is the recipient of the transfer\r\n        * @param _amount This is the amount of tokens to send\r\n     */\r\n    function transfer(\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        public\r\n        transfersNotFrozen\r\n        nonZeroAddress(_recipient)\r\n        returns (bool)\r\n    {\r\n        // check that the sender has a valid balance\r\n        require(balances[msg.sender] >= _amount, \"sender does not have enough tokens\");\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_recipient] = balances[_recipient].add(_amount);\r\n        emit Transfer(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    /** @notice Used to transfer tokens on behalf of someone else\r\n        * @param _recipient This is the recipient of the transfer\r\n        * @param _amount This is the amount of tokens to send\r\n     */\r\n    function transferFrom(\r\n        address _owner,\r\n        address _recipient,\r\n        uint256 _amount\r\n    )\r\n        public\r\n        transfersNotFrozen\r\n        nonZeroAddress(_recipient)\r\n        returns (bool)\r\n    {\r\n        // ensure owner has a valid balance\r\n        require(balances[_owner] >= _amount, \"owner does not have enough tokens\");\r\n        // ensure that the spender has a valid allowance\r\n        require(allowed[_owner][msg.sender] >= _amount, \"sender does not have enough allowance\");\r\n        // reduce the allowance\r\n        allowed[_owner][msg.sender] = allowed[_owner][msg.sender].sub(_amount);\r\n        // reduce balance of owner\r\n        balances[_owner] = balances[_owner].sub(_amount);\r\n        // increase balance of recipient\r\n        balances[_recipient] = balances[_recipient].add(_amount);\r\n        emit Transfer(_owner, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    /** @notice This is used to approve someone to send tokens on your behalf\r\n        * @param _spender This is the person who can spend on your behalf\r\n        * @param _value This is the amount of tokens that they can spend\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    // NON STANDARD FUNCTIONS //\r\n\r\n    /** @notice This is used to set the merged miner validator contract\r\n        * @param _mergedMinerValidator this is the address of the mergedmining contract\r\n     */\r\n    function setMergedMinerValidator(address _mergedMinerValidator) external onlyOwner nonAdminAddress(_mergedMinerValidator) returns (bool) {\r\n        mergedMinerValidatorAddress = _mergedMinerValidator;\r\n        minters[_mergedMinerValidator] = true;\r\n        emit MergedMinerValidatorSet(_mergedMinerValidator);\r\n        return true;\r\n    }\r\n\r\n    /** @notice This is used to set the staking contract\r\n        * @param _contractAddress this is the address of the staking contract\r\n    */\r\n    function setStakeContract(address _contractAddress) external onlyOwner nonAdminAddress(_contractAddress) returns (bool) {\r\n        // this prevents us from changing contracts while there are active stakes going on\r\n        if (stakeContractAddress != address(0)) {\r\n            require(stake.activeStakes() == 0, \"staking contract already configured, to change it must have 0 active stakes\");\r\n        }\r\n        stakeContractAddress = _contractAddress;\r\n        minters[_contractAddress] = true;\r\n        stake = StakeInterface(_contractAddress);\r\n        emit StakeContractSet(_contractAddress);\r\n        return true;\r\n    }\r\n\r\n    /** @notice Emergency use function designed to prevent stake deadlocks, allowing a fail-over stake contract to be implemented\r\n        * Requires 2 transaction, the first lifts the restriction, the second enables the restriction and sets the contract\r\n        * @dev We restrict to the owner address for security reasons, and don't update the stakeContractAddress variable to avoid breaking compatability\r\n        * @param _contractAddress This is the address of the stake contract\r\n     */\r\n    function setFailOverStakeContract(address _contractAddress) external onlyOwner nonAdminAddress(_contractAddress) returns (bool) {\r\n        if (stakeFailOverRestrictionLifted == false) {\r\n            stakeFailOverRestrictionLifted = true;\r\n            return true;\r\n        } else {\r\n            minters[_contractAddress] = true;\r\n            stakeFailOverRestrictionLifted = false;\r\n            emit FailOverStakeContractSet(_contractAddress);\r\n            return true;\r\n        }\r\n    }\r\n\r\n    /** @notice This is used to mint new tokens\r\n        * @dev Can only be executed by the staking, and merged miner validator contracts\r\n        * @param _recipient This is the person who will received the mint tokens\r\n        * @param _amount This is the amount of tokens that they will receive and which will be generated\r\n     */\r\n    function mint(\r\n        address _recipient,\r\n        uint256 _amount)\r\n        public\r\n        onlyMinters\r\n        returns (bool)\r\n    {\r\n        balances[_recipient] = balances[_recipient].add(_amount);\r\n        totalSupply = totalSupply.add(_amount);\r\n        emit Transfer(address(0), _recipient, _amount);\r\n        emit CoinsMinted(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n\r\n    /** @notice Allow us to transfer tokens that someone might've accidentally sent to this contract\r\n        @param _tokenAddress this is the address of the token contract\r\n        @param _recipient This is the address of the person receiving the tokens\r\n        @param _amount This is the amount of tokens to send\r\n     */\r\n    function transferForeignToken(\r\n        address _tokenAddress,\r\n        address _recipient,\r\n        uint256 _amount)\r\n        public\r\n        onlyAdmin\r\n        nonZeroAddress(_recipient)\r\n        returns (bool)\r\n    {\r\n        // don't allow us to transfer RTC tokens\r\n        require(_tokenAddress != address(this), \"token address can't be this contract\");\r\n        ERC20Interface eI = ERC20Interface(_tokenAddress);\r\n        require(eI.transfer(_recipient, _amount), \"token transfer failed\");\r\n        emit ForeignTokenTransfer(msg.sender, _recipient, _amount);\r\n        return true;\r\n    }\r\n    \r\n    /** @notice Transfers eth that is stuck in this contract\r\n        * ETH can be sent to the address this contract resides at before the contract is deployed\r\n        * A contract can be suicided, forcefully sending ether to this contract\r\n     */\r\n    function transferOutEth()\r\n        public\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        uint256 balance = address(this).balance;\r\n        msg.sender.transfer(address(this).balance);\r\n        emit EthTransferOut(msg.sender, balance);\r\n        return true;\r\n    }\r\n\r\n    /** @notice Used to freeze token transfers\r\n     */\r\n    function freezeTransfers()\r\n        public\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        transfersFrozen = true;\r\n        emit TransfersFrozen(true);\r\n        return true;\r\n    }\r\n\r\n    /** @notice Used to thaw token transfers\r\n     */\r\n    function thawTransfers()\r\n        public\r\n        onlyAdmin\r\n        returns (bool)\r\n    {\r\n        transfersFrozen = false;\r\n        emit TransfersThawed(true);\r\n        return true;\r\n    }\r\n\r\n\r\n    /**\r\n    * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To increment\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _addedValue The amount of tokens to increase the allowance by.\r\n    */\r\n    function increaseApproval(\r\n        address _spender,\r\n        uint256 _addedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n    * approve should be called when allowed[_spender] == 0. To decrement\r\n    * allowed value is better to use this function to avoid 2 calls (and wait until\r\n    * the first transaction is mined)\r\n    * From MonolithDAO Token.sol\r\n    * @param _spender The address which will spend the funds.\r\n    * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n    */\r\n    function decreaseApproval(\r\n        address _spender,\r\n        uint256 _subtractedValue\r\n    )\r\n        public\r\n        returns (bool)\r\n    {\r\n        uint256 oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue >= oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**GETTERS */\r\n\r\n    /** @notice Used to get the total supply\r\n     */\r\n    function totalSupply()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return totalSupply;\r\n    }\r\n\r\n    /** @notice Used to get the balance of a holder\r\n        * @param _holder The address of the token holder\r\n     */\r\n    function balanceOf(\r\n        address _holder\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return balances[_holder];\r\n    }\r\n\r\n    /** @notice Used to get the allowance of someone\r\n        * @param _owner The address of the token owner\r\n        * @param _spender The address of thhe person allowed to spend funds on behalf of the owner\r\n     */\r\n    function allowance(\r\n        address _owner,\r\n        address _spender\r\n    )\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"freezeTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeContractAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stake\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"mint\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setStakeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"allowed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAdmin\",\"type\":\"address\"}],\"name\":\"setAdmin\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_holder\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"transferOutEth\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferForeignToken\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_recipient\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_mergedMinerValidator\",\"type\":\"address\"}],\"name\":\"setMergedMinerValidator\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"thawTransfers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"setFailOverStakeContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIALSUPPLY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stakeFailOverRestrictionLifted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"transfersFrozen\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mergedMinerValidatorAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"minters\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"admin\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_transfersFrozen\",\"type\":\"bool\"}],\"name\":\"TransfersFrozen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_transfersThawed\",\"type\":\"bool\"}],\"name\":\"TransfersThawed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_sender\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ForeignTokenTransfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"EthTransferOut\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"MergedMinerValidatorSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"StakeContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_contractAddress\",\"type\":\"address\"}],\"name\":\"FailOverStakeContractSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_stakeContract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_mintAmount\",\"type\":\"uint256\"}],\"name\":\"CoinsMinted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_admin\",\"type\":\"address\"}],\"name\":\"AdminSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_previousOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RTCoin","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://8f2f7d91b7c745255cce3442185ec32f0f3d35ba926c0ea86b94f4c13f020429"}]}