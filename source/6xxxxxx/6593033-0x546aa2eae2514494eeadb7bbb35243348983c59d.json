{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n// File: @aragon/os/contracts/lib/ens/AbstractENS.sol\r\ninterface AbstractENS {\r\n    function owner(bytes32 _node) public constant returns (address);\r\n    function resolver(bytes32 _node) public constant returns (address);\r\n    function ttl(bytes32 _node) public constant returns (uint64);\r\n    function setOwner(bytes32 _node, address _owner) public;\r\n    function setSubnodeOwner(bytes32 _node, bytes32 label, address _owner) public;\r\n    function setResolver(bytes32 _node, address _resolver) public;\r\n    function setTTL(bytes32 _node, uint64 _ttl) public;\r\n\r\n    // Logged when the owner of a node assigns a new owner to a subnode.\r\n    event NewOwner(bytes32 indexed _node, bytes32 indexed _label, address _owner);\r\n\r\n    // Logged when the owner of a node transfers ownership to a new account.\r\n    event Transfer(bytes32 indexed _node, address _owner);\r\n\r\n    // Logged when the resolver for a node changes.\r\n    event NewResolver(bytes32 indexed _node, address _resolver);\r\n\r\n    // Logged when the TTL of a node changes\r\n    event NewTTL(bytes32 indexed _node, uint64 _ttl);\r\n}\r\n// File: contracts/ens/IPublicResolver.sol\r\ninterface IPublicResolver {\r\n    function supportsInterface(bytes4 interfaceID) constant returns (bool);\r\n    function addr(bytes32 node) constant returns (address ret);\r\n    function setAddr(bytes32 node, address addr);\r\n    function hash(bytes32 node) constant returns (bytes32 ret);\r\n    function setHash(bytes32 node, bytes32 hash);\r\n}\r\n// File: contracts/IFIFSResolvingRegistrar.sol\r\ninterface IFIFSResolvingRegistrar {\r\n    function register(bytes32 _subnode, address _owner) external;\r\n    function registerWithResolver(bytes32 _subnode, address _owner, IPublicResolver _resolver) public;\r\n}\r\n// File: contracts/FIFSResolvingRegistrar.sol\r\n/**\r\n * A registrar that allocates subdomains and sets resolvers to the first person to claim them.\r\n *\r\n * Adapted from ENS' FIFSRegistrar:\r\n *   https://github.com/ethereum/ens/blob/master/contracts/FIFSRegistrar.sol\r\n */\r\ncontract FIFSResolvingRegistrar is IFIFSResolvingRegistrar {\r\n    bytes32 public rootNode;\r\n    AbstractENS internal ens;\r\n    IPublicResolver internal defaultResolver;\r\n\r\n    bytes4 private constant ADDR_INTERFACE_ID = 0x3b3b57de;\r\n\r\n    event ClaimSubdomain(bytes32 indexed subnode, address indexed owner, address indexed resolver);\r\n\r\n    /**\r\n     * Constructor.\r\n     * @param _ensAddr The address of the ENS registry.\r\n     * @param _defaultResolver The address of the default resolver to use for subdomains.\r\n     * @param _node The node that this registrar administers.\r\n     */\r\n    constructor(AbstractENS _ensAddr, IPublicResolver _defaultResolver, bytes32 _node)\r\n        public\r\n    {\r\n        ens = _ensAddr;\r\n        defaultResolver = _defaultResolver;\r\n        rootNode = _node;\r\n    }\r\n\r\n    /**\r\n     * Register a subdomain with the default resolver if it hasn't been claimed yet.\r\n     * @param _subnode The hash of the label to register.\r\n     * @param _owner The address of the new owner.\r\n     */\r\n    function register(bytes32 _subnode, address _owner) external {\r\n        registerWithResolver(_subnode, _owner, defaultResolver);\r\n    }\r\n\r\n    /**\r\n     * Register a subdomain if it hasn't been claimed yet.\r\n     * @param _subnode The hash of the label to register.\r\n     * @param _owner The address of the new owner.\r\n     * @param _resolver The address of the resolver.\r\n     *                  If the resolver supports the address interface, the subdomain's address will\r\n     *                  be set to the new owner.\r\n     */\r\n    function registerWithResolver(bytes32 _subnode, address _owner, IPublicResolver _resolver) public {\r\n        bytes32 node = keccak256(rootNode, _subnode);\r\n        address currentOwner = ens.owner(node);\r\n        require(currentOwner == address(0));\r\n\r\n        ens.setSubnodeOwner(rootNode, _subnode, address(this));\r\n        ens.setResolver(node, _resolver);\r\n        if (_resolver.supportsInterface(ADDR_INTERFACE_ID)) {\r\n            _resolver.setAddr(node, _owner);\r\n        }\r\n\r\n        // Give ownership to the claimer\r\n        ens.setOwner(node, _owner);\r\n\r\n        emit ClaimSubdomain(_subnode, _owner, address(_resolver));\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_subnode\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_subnode\",\"type\":\"bytes32\"},{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_resolver\",\"type\":\"address\"}],\"name\":\"registerWithResolver\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rootNode\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ensAddr\",\"type\":\"address\"},{\"name\":\"_defaultResolver\",\"type\":\"address\"},{\"name\":\"_node\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"subnode\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"resolver\",\"type\":\"address\"}],\"name\":\"ClaimSubdomain\",\"type\":\"event\"}]","ContractName":"FIFSResolvingRegistrar","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"000000000000000000000000314159265dd8dbb310642f98f50c066173c1259b0000000000000000000000001da022710df5002339274aadee8d58218e9d6ab57e74a86b6e146964fb965db04dc2590516da77f720bb6759337bf5632415fd86","Library":"","SwarmSource":"bzzr://da3d38c402030065d00aa15705c0a8d49a9d9f81cf46eea2624885aac4a19b3e"}]}