{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/// @title ERC165\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\ninterface ERC165Interface {\r\n  /// @notice Query if a contract implements an interface\r\n  /// @param interfaceID The interface identifier, as specified in ERC-165\r\n  /// @dev Interface identification is specified in ERC-165. This function\r\n  ///  uses less than 30,000 gas.\r\n  /// @return `true` if the contract implements `interfaceID` and\r\n  ///  `interfaceID` is not 0xffffffff, `false` otherwise\r\n  function supportsInterface(bytes4 interfaceID) external view returns (bool);\r\n}\r\n\r\ncontract ERC165 is ERC165Interface {\r\n  // 0x01ffc9a7 ===\r\n  // bytes4(keccak256('supportsInterface(bytes4)'))\r\n  bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7;\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x80ac58cd\r\ninterface ERC721Interface /* is ERC165 */ {\r\n  /// @dev This emits when ownership of any NFT changes by any mechanism.\r\n  ///  This event emits when NFTs are created (`from` == 0) and destroyed\r\n  ///  (`to` == 0). Exception: during contract creation, any number of NFTs\r\n  ///  may be created and assigned without emitting Transfer. At the time of\r\n  ///  any transfer, the approved address for that NFT (if any) is reset to none.\r\n  event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId);\r\n\r\n  /// @dev This emits when the approved address for an NFT is changed or\r\n  ///  reaffirmed. The zero address indicates there is no approved address.\r\n  ///  When a Transfer event emits, this also indicates that the approved\r\n  ///  address for that NFT (if any) is reset to none.\r\n  event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId);\r\n\r\n  /// @dev This emits when an operator is enabled or disabled for an owner.\r\n  ///  The operator can manage all NFTs of the owner.\r\n  event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n  /// @notice Count all NFTs assigned to an owner\r\n  /// @dev NFTs assigned to the zero address are considered invalid, and this\r\n  ///  function throws for queries about the zero address.\r\n  /// @param _owner An address for whom to query the balance\r\n  /// @return The number of NFTs owned by `_owner`, possibly zero\r\n  function balanceOf(address _owner) external view returns (uint256);\r\n\r\n  /// @notice Find the owner of an NFT\r\n  /// @dev NFTs assigned to zero address are considered invalid, and queries\r\n  ///  about them do throw.\r\n  /// @param _tokenId The identifier for an NFT\r\n  /// @return The address of the owner of the NFT\r\n  function ownerOf(uint256 _tokenId) external view returns (address);\r\n\r\n  /// @notice Transfers the ownership of an NFT from one address to another address\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  `_tokenId` is not a valid NFT. When transfer is complete, this function\r\n  ///  checks if `_to` is a smart contract (code size > 0). If so, it calls\r\n  ///  `onERC721Received` on `_to` and throws if the return value is not\r\n  ///  `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`.\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  /// @param data Additional data with no specified format, sent in call to `_to`\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external payable;\r\n\r\n  /// @notice Transfers the ownership of an NFT from one address to another address\r\n  /// @dev This works identically to the other function with an extra data parameter,\r\n  ///  except this function just sets data to \"\"\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n  /// @notice Transfer ownership of an NFT -- THE CALLER IS RESPONSIBLE\r\n  ///  TO CONFIRM THAT `_to` IS CAPABLE OF RECEIVING NFTS OR ELSE\r\n  ///  THEY MAY BE PERMANENTLY LOST\r\n  /// @dev Throws unless `msg.sender` is the current owner, an authorized\r\n  ///  operator, or the approved address for this NFT. Throws if `_from` is\r\n  ///  not the current owner. Throws if `_to` is the zero address. Throws if\r\n  ///  `_tokenId` is not a valid NFT.\r\n  /// @param _from The current owner of the NFT\r\n  /// @param _to The new owner\r\n  /// @param _tokenId The NFT to transfer\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable;\r\n\r\n  /// @notice Set or reaffirm the approved address for an NFT\r\n  /// @dev The zero address indicates there is no approved address.\r\n  /// @dev Throws unless `msg.sender` is the current NFT owner, or an authorized\r\n  ///  operator of the current owner.\r\n  /// @param _approved The new approved NFT controller\r\n  /// @param _tokenId The NFT to approve\r\n  function approve(address _approved, uint256 _tokenId) external payable;\r\n\r\n  /// @notice Enable or disable approval for a third party (\"operator\") to manage\r\n  ///  all of `msg.sender`'s assets.\r\n  /// @dev Emits the ApprovalForAll event. The contract MUST allow\r\n  ///  multiple operators per owner.\r\n  /// @param _operator Address to add to the set of authorized operators.\r\n  /// @param _approved True if the operator is approved, false to revoke approval\r\n  function setApprovalForAll(address _operator, bool _approved) external;\r\n\r\n  /// @notice Get the approved address for a single NFT\r\n  /// @dev Throws if `_tokenId` is not a valid NFT\r\n  /// @param _tokenId The NFT to find the approved address for\r\n  /// @return The approved address for this NFT, or the zero address if there is none\r\n  function getApproved(uint256 _tokenId) external view returns (address);\r\n\r\n  /// @notice Query if an address is an authorized operator for another address\r\n  /// @param _owner The address that owns the NFTs\r\n  /// @param _operator The address that acts on behalf of the owner\r\n  /// @return True if `_operator` is an approved operator for `_owner`, false otherwise\r\n  function isApprovedForAll(address _owner, address _operator) external view returns (bool);\r\n}\r\n\r\ncontract ERC721 is ERC721Interface {\r\n  // 0x80ac58cd ===\r\n  // bytes4(keccak256('balanceOf(address)')) ^\r\n  // bytes4(keccak256('ownerOf(uint256)')) ^\r\n  // bytes4(keccak256('approve(address,uint256)')) ^\r\n  // bytes4(keccak256('getApproved(uint256)')) ^\r\n  // bytes4(keccak256('setApprovalForAll(address,bool)')) ^\r\n  // bytes4(keccak256('isApprovedForAll(address,address)')) ^\r\n  // bytes4(keccak256('transferFrom(address,address,uint256)')) ^\r\n  // bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^\r\n  // bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)'))\r\n  bytes4 public constant InterfaceId_ERC721 = 0x80ac58cd;\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x780e9d63.\r\ninterface ERC721EnumerableInterface /* is ERC721 */ {\r\n  /// @notice Count NFTs tracked by this contract\r\n  /// @return A count of valid NFTs tracked by this contract, where each one of\r\n  ///  them has an assigned and queryable owner not equal to the zero address\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  /// @notice Enumerate valid NFTs\r\n  /// @dev Throws if `_index` >= `totalSupply()`.\r\n  /// @param _index A counter less than `totalSupply()`\r\n  /// @return The token identifier for the `_index`th NFT,\r\n  ///  (sort order not specified)\r\n  function tokenByIndex(uint256 _index) external view returns (uint256);\r\n\r\n  /// @notice Enumerate NFTs assigned to an owner\r\n  /// @dev Throws if `_index` >= `balanceOf(_owner)` or if\r\n  ///  `_owner` is the zero address, representing invalid NFTs.\r\n  /// @param _owner An address where we are interested in NFTs owned by them\r\n  /// @param _index A counter less than `balanceOf(_owner)`\r\n  /// @return The token identifier for the `_index`th NFT assigned to `_owner`,\r\n  ///   (sort order not specified)\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256);\r\n}\r\n\r\ncontract ERC721Enumerable is ERC721EnumerableInterface {\r\n  bytes4 public constant InterfaceId_ERC721Enumerable = 0x780e9d63;\r\n}\r\n\r\n/// @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n///  Note: the ERC-165 identifier for this interface is 0x5b5e139f.\r\ninterface ERC721MetadataInterface /* is ERC721 */ {\r\n  /// @notice A descriptive name for a collection of NFTs in this contract\r\n  function name() external view returns (string _name);\r\n\r\n  /// @notice An abbreviated name for NFTs in this contract\r\n  function symbol() external view returns (string _symbol);\r\n\r\n  /// @notice A distinct Uniform Resource Identifier (URI) for a given asset.\r\n  /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC\r\n  ///  3986. The URI may point to a JSON file that conforms to the \"ERC721\r\n  ///  Metadata JSON Schema\".\r\n  function tokenURI(uint256 _tokenId) external view returns (string);\r\n}\r\n\r\ncontract ERC721Metadata is ERC721MetadataInterface {\r\n  bytes4 public constant InterfaceId_ERC721Metadata = 0x5b5e139f;\r\n}\r\n\r\n/// @title ERC-721 Token Receiver\r\n/// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n/// @dev Note: the ERC-165 identifier for this interface is 0x150b7a02.\r\ninterface ERC721TokenReceiverInterface {\r\n  /// @notice Handle the receipt of an NFT\r\n  /// @dev The ERC721 smart contract calls this function on the\r\n  /// recipient after a `transfer`. This function MAY throw to revert and reject the transfer. Return\r\n  /// of other than the magic value MUST result in the transaction being reverted.\r\n  /// @notice The contract address is always the message sender.\r\n  /// @param _operator The address which called `safeTransferFrom` function\r\n  /// @param _from The address which previously owned the token\r\n  /// @param _tokenId The NFT identifier which is being transferred\r\n  /// @param _data Additional data with no specified format\r\n  /// @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\r\n  /// unless throwing\r\n  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4);\r\n}\r\n\r\ncontract ERC721TokenReceiver is ERC721TokenReceiverInterface {\r\n  bytes4 public constant InterfaceId_ERC721TokenReceiver = 0x150b7a02;\r\n}\r\n\r\ncontract SixPillars is ERC165, ERC721, ERC721Enumerable, ERC721Metadata, ERC721TokenReceiver {\r\n  /// This emits when minted new token.\r\n  event Mint(\r\n    address indexed _owner,\r\n    address indexed _creator,\r\n    uint256 _inscription,\r\n    uint256 _tokenId\r\n  );\r\n\r\n  /// This emits when burned any token.\r\n  event Burn(\r\n    address indexed _owner,\r\n    address indexed _creator,\r\n    uint256 _tokenId\r\n  );\r\n\r\n  /// This emits when set new creator of any token.\r\n  event CreatedBy(\r\n    address indexed _creator,\r\n    uint256 _tokenId\r\n  );\r\n\r\n  /// This emits when remove creator of any token.\r\n  event ClearCreator(\r\n    uint256 _tokenId\r\n  );\r\n\r\n  /// This emits when the approved amount for an NFT is changed or reaffirmed.\r\n  /// and it emits after `Approval` event.\r\n  event ApprovalWithAmount(\r\n    address indexed _owner,\r\n    address indexed _approved,\r\n    uint256 indexed _tokenId,\r\n    uint256 _amount\r\n  );\r\n\r\n  /// This emits when ownership of any token changes by used amount.\r\n  /// and it emits after `Transfer` event.\r\n  event TransferWithAmount(\r\n    address indexed _from,\r\n    address indexed _to,\r\n    uint256 indexed _tokenId,\r\n    uint256 _amount\r\n  );\r\n\r\n  struct Token {\r\n    uint256 id;\r\n    uint256 inscription;\r\n    uint256 amount;\r\n    uint256 ownerIndex; // ownerToTokensIndex[_owner][ownerIndex]\r\n    uint256 createdAt; // block number at created\r\n    address owner;\r\n    address creator;\r\n    address approved;\r\n    string uri;\r\n  }\r\n\r\n  Token[] internal tokens;\r\n  mapping(uint256 => uint256) internal tokenIdToIndex; // tokenId -> tokens index\r\n  uint256 internal tokenIdSeed;\r\n  uint256 internal lastMintBlockNumber;\r\n\r\n  mapping(address => uint256[]) internal ownerToTokensIndex; // owner address -> tokens index array\r\n  mapping(address => mapping(address => bool)) internal operatorApprovals; // approved address -> approve address flag mapping\r\n\r\n  mapping(bytes4 => bool) internal supportedInterfaces;\r\n\r\n  /**\r\n   * ERC165\r\n  ***/\r\n\r\n  // @override\r\n  function supportsInterface(bytes4 _interfaceId) external view returns (bool) {\r\n    return supportedInterfaces[_interfaceId];\r\n  }\r\n\r\n  function _registerInterface(bytes4 _interfaceId) internal {\r\n    require(_interfaceId != 0xffffffff);\r\n    supportedInterfaces[_interfaceId] = true;\r\n  }\r\n\r\n  /**\r\n   * ERC721Enumerable\r\n  ***/\r\n\r\n  // @override\r\n  function totalSupply() external view returns (uint256) {\r\n    return tokens.length;\r\n  }\r\n\r\n  // @override\r\n  function tokenByIndex(uint256 _index) external view returns (uint256) {\r\n    return tokenIdByIndex(_index);\r\n  }\r\n\r\n  // @override\r\n  function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) {\r\n    require(_index < ownerToTokensIndex[_owner].length);\r\n    uint256 index = ownerToTokensIndex[_owner][_index];\r\n    return tokens[index].id;\r\n  }\r\n\r\n  function tokenIdByIndex(uint256 _index) internal view returns (uint256) {\r\n    require(_index < tokens.length);\r\n    return tokens[_index].id;\r\n  }\r\n\r\n  function indexByTokenId(uint256 _tokenId) internal view returns (uint256) {\r\n    uint index = tokenIdToIndex[_tokenId];\r\n    require(index < tokens.length);\r\n    require(tokens[index].id == _tokenId);\r\n    return index;\r\n  }\r\n\r\n  /**\r\n   * ERC721Metadata\r\n  ***/\r\n\r\n  // @override\r\n  function name() public view returns (string) {\r\n    return \"SixPillars\";\r\n  }\r\n\r\n  // @override\r\n  function symbol() public view returns (string) {\r\n    return \"SPT\";\r\n  }\r\n\r\n  // @override\r\n  function tokenURI(uint256 _tokenId) external view returns (string) {\r\n    uint index = indexByTokenId(_tokenId);\r\n    return tokens[index].uri;\r\n  }\r\n\r\n  /**\r\n   * ERC721TokenReceiver\r\n  ***/\r\n\r\n  // @override\r\n  function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes _data) external returns(bytes4) {\r\n    return InterfaceId_ERC721TokenReceiver;\r\n  }\r\n\r\n  /**\r\n   * ERC721\r\n  ***/\r\n\r\n  // @override\r\n  function balanceOf(address _owner) external view returns (uint256) {\r\n    require(_owner != address(0));\r\n    return ownerToTokensIndex[_owner].length;\r\n  }\r\n\r\n  // @override\r\n  function ownerOf(uint256 _tokenId) external view returns (address) {\r\n    return internalOwnerOf(_tokenId);\r\n  }\r\n\r\n  // @override\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) external payable {\r\n    uint256 sendAmount = internalSafeTransferFrom(_from, _to, _tokenId, msg.value, _data);\r\n    if (0 < sendAmount) {\r\n      _from.transfer(sendAmount);\r\n      emit TransferWithAmount(_from, _to, _tokenId, sendAmount);\r\n    }\r\n  }\r\n\r\n  // @override\r\n  function safeTransferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n    uint256 sendAmount = internalSafeTransferFrom(_from, _to, _tokenId, msg.value, \"\");\r\n    if (0 < sendAmount) {\r\n      _from.transfer(sendAmount);\r\n      emit TransferWithAmount(_from, _to, _tokenId, sendAmount);\r\n    }\r\n  }\r\n\r\n  // @override\r\n  function transferFrom(address _from, address _to, uint256 _tokenId) external payable {\r\n    uint256 sendAmount = internalTransferFrom(_from, _to, _tokenId, msg.value);\r\n    if (0 < sendAmount) {\r\n      _from.transfer(sendAmount);\r\n      emit TransferWithAmount(_from, _to, _tokenId, sendAmount);\r\n    }\r\n  }\r\n\r\n  // @override\r\n  function approve(address _approved, uint256 _tokenId) external payable {\r\n    internalApprove(_approved, _tokenId, 0);\r\n  }\r\n\r\n  // @override\r\n  function setApprovalForAll(address _operator, bool _approved) external {\r\n    require(_operator != msg.sender);\r\n    operatorApprovals[msg.sender][_operator] = _approved;\r\n    emit ApprovalForAll(msg.sender, _operator, _approved);\r\n  }\r\n\r\n  // @override\r\n  function getApproved(uint256 _tokenId) external view returns (address) {\r\n    return internalGetApproved(_tokenId);\r\n  }\r\n\r\n  // @override\r\n  function isApprovedForAll(address _owner, address _operator) public view returns (bool) {\r\n    return internalIsApprovedForAll(_owner, _operator);\r\n  }\r\n\r\n  /**\r\n   * payment methods for ERC721\r\n  ***/\r\n\r\n  function approve(address _approved, uint256 _tokenId, uint256 _amount) external payable {\r\n    internalApprove(_approved, _tokenId, _amount);\r\n  }\r\n\r\n  function amountOf(uint256 _tokenId) external view returns (uint256) {\r\n    uint index = indexByTokenId(_tokenId);\r\n    return tokens[index].amount;\r\n  }\r\n\r\n  /**\r\n   * internal methods for ERC721 external methods\r\n  ***/\r\n\r\n  // @override\r\n  function internalOwnerOf(uint256 _tokenId) internal view returns (address) {\r\n    uint index = indexByTokenId(_tokenId);\r\n    return tokens[index].owner;\r\n  }\r\n\r\n  // @override\r\n  function internalSafeTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _value, bytes _data) internal returns (uint256) {\r\n    if (isContract(_to)) {\r\n      bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(msg.sender, _from, _tokenId, _data);\r\n      require(retval == InterfaceId_ERC721TokenReceiver, \"internalSafeTransferFrom msg.sender can not approved\");\r\n    }\r\n    return internalTransferFrom(_from, _to, _tokenId, _value);\r\n  }\r\n\r\n  function internalTransferFrom(address _from, address _to, uint256 _tokenId, uint256 _value) internal returns (uint256 sendAmount) {\r\n    uint index = indexByTokenId(_tokenId);\r\n    address owner = tokens[index].owner;\r\n    require((_from == owner) && (_from != _to));\r\n\r\n    // can transfer, if meet one of the confitions\r\n    // 1. sender is owner.\r\n    // 2. sender is approved of owner's all token transfer to \"_to\" address.\r\n    // 3. if an approved address is set,\r\n    // 3-1. and amount is set, approved sender pay token amount to owner, transfer to \"_to\" address.\r\n    // 3-2. and amount is not set, sender is approved of token transfer to \"_to\" address.\r\n    // 4. if an approved address is not set, sender to pay token amount to owner.\r\n    uint256 amount = tokens[index].amount;\r\n    tokens[index].amount = 0;\r\n    bool canTransfer = (msg.sender == owner) || internalIsApprovedForAll(owner, msg.sender);\r\n    if (canTransfer) {\r\n      // owner and approved sender, not payable.\r\n      require(_value == 0);\r\n\r\n    } else if (tokens[index].approved == msg.sender) {\r\n      sendAmount = amount;\r\n      canTransfer = (amount == _value);\r\n\r\n    } else if ((tokens[index].approved == address(0)) && (0 < amount)) {\r\n      sendAmount = amount;\r\n      canTransfer = (amount == _value);\r\n    }\r\n    require(canTransfer);\r\n\r\n    // clear approved\r\n    tokens[index].approved = address(0);\r\n\r\n    // transfer\r\n    transferToken(_from, _to, _tokenId);\r\n    emit Transfer(_from, _to, _tokenId);\r\n  }\r\n\r\n  function internalGetApproved(uint256 _tokenId) internal view returns (address) {\r\n    uint index = indexByTokenId(_tokenId);\r\n    return tokens[index].approved;\r\n  }\r\n\r\n  function internalIsApprovedForAll(address _owner, address _operator) internal view returns (bool) {\r\n    return operatorApprovals[_owner][_operator];\r\n  }\r\n\r\n  function internalApprove(address _approved, uint256 _tokenId, uint256 _amount) internal {\r\n    uint index = indexByTokenId(_tokenId);\r\n    address owner = tokens[index].owner;\r\n    require(_approved != owner);\r\n    require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\r\n    tokens[index].approved = _approved;\r\n    tokens[index].amount = _amount;\r\n    emit Approval(owner, _approved, _tokenId);\r\n    if (0 < _amount) {\r\n      emit ApprovalWithAmount(owner, _approved, _tokenId, _amount);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * internal methods for ERC721\r\n  ***/\r\n\r\n  function addTokenTo(address _toOwner, uint256 _tokenId, uint256 _inscription, bool _isSetCreator) internal {\r\n    uint index = tokenIdToIndex[_tokenId];\r\n    require(_toOwner != address(0));\r\n    if ((index == 0) && (0 < tokens.length)) {\r\n      require(tokens[0].id != _tokenId);\r\n    }\r\n\r\n    index = tokens.length;\r\n\r\n    // add token to owner\r\n    uint256 ownerIndex = ownerToTokensIndex[_toOwner].length;\r\n    ownerToTokensIndex[_toOwner].push(index);\r\n\r\n    address creator = _isSetCreator ? msg.sender : address(0);\r\n    Token memory tokenWithCreator = Token(_tokenId, _inscription, 0, ownerIndex, block.number, _toOwner, creator, address(0), \"\");\r\n    tokens.push(tokenWithCreator);\r\n    tokenIdToIndex[_tokenId] = index;\r\n  }\r\n\r\n  function removeTokenFrom(address _fromOwner, uint256 _tokenId) internal {\r\n    uint index = indexByTokenId(_tokenId);\r\n    require(tokens[index].owner == _fromOwner);\r\n\r\n    // change removeToken index <--> lastToken index for owner\r\n    uint256 removeTokenIndex = tokens[index].ownerIndex;\r\n    uint256 lastTokenIndex = ownerToTokensIndex[_fromOwner].length - 1;\r\n    if (removeTokenIndex != lastTokenIndex) {\r\n      tokens[ownerToTokensIndex[_fromOwner][lastTokenIndex] ].ownerIndex = removeTokenIndex;\r\n      ownerToTokensIndex[_fromOwner][removeTokenIndex] = ownerToTokensIndex[_fromOwner][lastTokenIndex];\r\n    }\r\n    ownerToTokensIndex[_fromOwner].length = lastTokenIndex;\r\n\r\n    // change removeToken index <--> lastToken index for all\r\n    removeTokenIndex = index;\r\n    lastTokenIndex = tokens.length - 1;\r\n    if (removeTokenIndex != lastTokenIndex) {\r\n      uint256 lastTokenId = tokens[lastTokenIndex].id;\r\n\r\n      // owner to\r\n      address lastTokenOwner = tokens[lastTokenIndex].owner;\r\n      uint256 lastTokenOwnerIndex = tokens[lastTokenIndex].ownerIndex;\r\n      ownerToTokensIndex[lastTokenOwner][lastTokenOwnerIndex] = removeTokenIndex;\r\n\r\n      // all\r\n      tokenIdToIndex[lastTokenId] = removeTokenIndex;\r\n      tokens[removeTokenIndex] = tokens[lastTokenIndex];\r\n    }\r\n    tokenIdToIndex[_tokenId] = 0;\r\n    tokens.length = lastTokenIndex;\r\n  }\r\n\r\n  function transferToken(address _fromOwner, address _toOwner, uint256 _tokenId) internal {\r\n    uint index = indexByTokenId(_tokenId);\r\n    require((_toOwner != address(0)) && (_fromOwner != _toOwner) && (tokens[index].owner == _fromOwner));\r\n\r\n    // remove from old owner\r\n    uint256 removeTokenIndex = tokens[index].ownerIndex;\r\n    uint256 lastTokenIndex = ownerToTokensIndex[_fromOwner].length - 1;\r\n\r\n    tokens[ownerToTokensIndex[_fromOwner][lastTokenIndex] ].ownerIndex = removeTokenIndex;\r\n    ownerToTokensIndex[_fromOwner][removeTokenIndex] = ownerToTokensIndex[_fromOwner][lastTokenIndex];\r\n    ownerToTokensIndex[_fromOwner].length = lastTokenIndex;\r\n\r\n    // add to new owner\r\n    uint256 ownerIndex = ownerToTokensIndex[_toOwner].length;\r\n    ownerToTokensIndex[_toOwner].push(index);\r\n    tokens[index].owner = _toOwner;\r\n    tokens[index].ownerIndex = ownerIndex;\r\n  }\r\n\r\n  function isContract(address addr) internal view returns (bool) {\r\n    uint256 size;\r\n    assembly { size := extcodesize(addr) }\r\n    return size > 0;\r\n  }\r\n\r\n  /**\r\n   * SixPillars\r\n  ***/\r\n\r\n  constructor() public {\r\n    _registerInterface(InterfaceId_ERC165);\r\n    _registerInterface(InterfaceId_ERC721);\r\n    _registerInterface(InterfaceId_ERC721Enumerable);\r\n    _registerInterface(InterfaceId_ERC721Metadata);\r\n    _registerInterface(InterfaceId_ERC721TokenReceiver);\r\n    tokenIdSeed = 722;\r\n    lastMintBlockNumber = 0;\r\n  }\r\n\r\n  function recover(bytes32 msgHash, uint8 v, bytes32 r, bytes32 s) public pure returns (address) {\r\n    return ecrecover(msgHash, v, r, s);\r\n  }\r\n\r\n  /// Mint new token.\r\n  ///\r\n  /// emit Mint(owner, creator, inscription, tokenId)\r\n  /// Throw _to is not valid.\r\n  /// Throw new token id is already used. (please try again later)\r\n  /// @param _to Owner of new token.\r\n  /// @param _inscription immutable parameter for new token.\r\n  /// @param _isSetCreator if true, creator of new token is msg.sender. if false, creator is zero address.\r\n  function mint(address _to, uint256 _inscription, bool _isSetCreator) external {\r\n    uint256 seed = tokenIdSeed;\r\n    if ((lastMintBlockNumber != 0) && (lastMintBlockNumber < block.number)) {\r\n      seed += (block.number - lastMintBlockNumber);\r\n    }\r\n    uint256 newTokenId = uint256(keccak256(abi.encodePacked(seed)));\r\n    tokenIdSeed = newTokenId;\r\n    lastMintBlockNumber = block.number;\r\n    addTokenTo(_to, newTokenId, _inscription, _isSetCreator);\r\n    emit Mint(\r\n      _to,\r\n      (_isSetCreator == true) ? msg.sender : address(0),\r\n      _inscription,\r\n      newTokenId\r\n    );\r\n  }\r\n\r\n  /// Burn your token.\r\n  ///\r\n  /// emit Burn(owner, creator, tokenId)\r\n  /// Throw token owner is not msg.sender.\r\n  /// @param _tokenId id of the token you want to burned.\r\n  function burn(uint256 _tokenId) external {\r\n    uint index = indexByTokenId(_tokenId);\r\n    address owner = tokens[index].owner;\r\n    address creator = tokens[index].creator;\r\n    require(owner == msg.sender);\r\n    removeTokenFrom(owner, _tokenId);\r\n    emit Burn(\r\n      owner,\r\n      creator,\r\n      _tokenId\r\n    );\r\n  }\r\n\r\n  /// Add creator to the token\r\n  ///\r\n  /// msg.sender is new creator.\r\n  /// emit CreatedBy(creator, tokenId)\r\n  /// Throw token creator is already added.\r\n  /// @param _tokenId id of the token you want add creator.\r\n  function createdBy(uint256 _tokenId) external {\r\n    uint index = indexByTokenId(_tokenId);\r\n    address creator = tokens[index].creator;\r\n    require(creator == address(0));\r\n    tokens[index].creator = msg.sender;\r\n    emit CreatedBy(\r\n      msg.sender,\r\n      _tokenId\r\n    );\r\n  }\r\n\r\n  /// Remove creator to the token\r\n  ///\r\n  /// creator of the token will be zero address.\r\n  /// emit ClearCreator(tokenId)\r\n  /// Throw token creator is not msg.sender.\r\n  /// @param _tokenId id of the token you want remove creator.\r\n  function clearCreator(uint256 _tokenId) external {\r\n    uint index = indexByTokenId(_tokenId);\r\n    address creator = tokens[index].creator;\r\n    require(msg.sender == creator);\r\n    tokens[index].creator = address(0);\r\n    emit ClearCreator(_tokenId);\r\n  }\r\n\r\n  /// Get inscription of the token.\r\n  /// @param _tokenId id of the token you get it.\r\n  /// @return uint256 inscription of the token.\r\n  function inscription(uint256 _tokenId) external view returns(uint256) {\r\n    uint index = indexByTokenId(_tokenId);\r\n    return tokens[index].inscription;\r\n  }\r\n\r\n  /// Get creator of the token.\r\n  /// @param _tokenId id of the token you get it.\r\n  /// @return address creator of the token.\r\n  function creator(uint256 _tokenId) external view returns(address) {\r\n    uint index = indexByTokenId(_tokenId);\r\n    return tokens[index].creator;\r\n  }\r\n\r\n  /// Get block number of the token at created.\r\n  /// @param _tokenId id of the token you get it.\r\n  /// @return uint256 block number of the token at created.\r\n  function createdAt(uint256 _tokenId) external view returns(uint256) {\r\n    uint index = indexByTokenId(_tokenId);\r\n    return tokens[index].createdAt;\r\n  }\r\n\r\n  /// Set new url for your token.\r\n  ///\r\n  /// Throw token owner is not msg.sender.\r\n  /// @param _tokenId id of the token you set it.\r\n  /// @param _uri new uri.\r\n  function setTokenURI(uint256 _tokenId, string _uri) external {\r\n    uint index = indexByTokenId(_tokenId);\r\n    require(tokens[index].owner == msg.sender);\r\n    tokens[index].uri = _uri;\r\n  }\r\n\r\n  /// Token balance of creator.\r\n  ///\r\n  /// Throw creator is not valid.\r\n  /// @param _creator creator of the tokens.\r\n  /// @return uint256 balance.\r\n  function balanceOfCreator(address _creator) external view returns (uint256) {\r\n    require(_creator != address(0));\r\n    uint256 count = 0;\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      if (tokens[i].creator == _creator) {\r\n        count++;\r\n      }\r\n    }\r\n    return count;\r\n  }\r\n\r\n  /// Get token ID of the specified creator and index.\r\n  ///\r\n  /// Throw owner is not valid.\r\n  /// Throw overflow index.\r\n  /// @param _creator creator of the token.\r\n  /// @param _index index of the creator tokens.\r\n  /// @return uint256 token id.\r\n  function tokenOfCreatorByIndex(address _creator, uint256 _index) external view returns (uint256) {\r\n    require(_creator != address(0));\r\n    uint256 count = 0;\r\n    for (uint256 i = 0; i < tokens.length; i++) {\r\n      if (tokens[i].creator == _creator) {\r\n        if (count == _index) {\r\n          return tokens[i].id;\r\n        }\r\n        count++;\r\n      }\r\n    }\r\n    revert();\r\n  }\r\n\r\n  /// Token balance of owner and creator.\r\n  ///\r\n  /// Throw owner is not valid.\r\n  /// Throw creator is not valid.\r\n  /// @param _owner owner of the tokens.\r\n  /// @param _creator creator of the tokens.\r\n  /// @return uint256 balance of `token.owner == _owner` and `token.creator == _creator` tokens.\r\n  function balanceOfOwnerAndCreator(address _owner, address _creator) external view returns (uint256) {\r\n    require((_owner != address(0)) && (_creator != address(0)));\r\n    uint256 balance = 0;\r\n    for (uint256 i = 0; i < ownerToTokensIndex[_owner].length; i++) {\r\n      uint256 index = ownerToTokensIndex[_owner][i];\r\n      if (tokens[index].creator == _creator) {\r\n        balance++;\r\n      }\r\n    }\r\n    return balance;\r\n  }\r\n\r\n  /// Get token ID of the specified owner, creator, and index.\r\n  ///\r\n  /// Throw owner is not valid.\r\n  /// Throw creator is not valid.\r\n  /// Throw overflow index.\r\n  /// @param _owner owner of the token.\r\n  /// @param _creator creator of the token, you can use zero address.\r\n  /// @param _index index of the creator tokens.\r\n  /// @return uint256 token id.\r\n  function tokenOfOwnerAndCreatorByIndex(address _owner, address _creator, uint256 _index) external view returns (uint256) {\r\n    require((_owner != address(0)) && (_creator != address(0)));\r\n    uint256 count = 0;\r\n    for (uint256 i = 0; i < ownerToTokensIndex[_owner].length; i++) {\r\n      uint256 index = ownerToTokensIndex[_owner][i];\r\n      if (tokens[index].creator == _creator) {\r\n        if (count == _index) {\r\n          return tokens[index].id;\r\n        }\r\n        count++;\r\n      }\r\n    }\r\n    revert();\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"createdBy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_interfaceId\",\"type\":\"bytes4\"}],\"name\":\"supportsInterface\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"clearCreator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_uri\",\"type\":\"string\"}],\"name\":\"setTokenURI\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC165\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_approved\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfCreatorByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"createdAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"creator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC721Enumerable\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC721TokenReceiver\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"balanceOfCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC721\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_creator\",\"type\":\"address\"},{\"name\":\"_index\",\"type\":\"uint256\"}],\"name\":\"tokenOfOwnerAndCreatorByIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"inscription\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_creator\",\"type\":\"address\"}],\"name\":\"balanceOfOwnerAndCreator\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"setApprovalForAll\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"safeTransferFrom\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"InterfaceId_ERC721Metadata\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"msgHash\",\"type\":\"bytes32\"},{\"name\":\"v\",\"type\":\"uint8\"},{\"name\":\"r\",\"type\":\"bytes32\"},{\"name\":\"s\",\"type\":\"bytes32\"}],\"name\":\"recover\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"tokenURI\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_inscription\",\"type\":\"uint256\"},{\"name\":\"_isSetCreator\",\"type\":\"bool\"}],\"name\":\"mint\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"amountOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_operator\",\"type\":\"address\"}],\"name\":\"isApprovedForAll\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_inscription\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Mint\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Burn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_creator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"CreatedBy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ClearCreator\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"ApprovalWithAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"TransferWithAmount\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_approved\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_operator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_approved\",\"type\":\"bool\"}],\"name\":\"ApprovalForAll\",\"type\":\"event\"}]","ContractName":"SixPillars","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://2a8cbe845f838b767bef61fa7596a5dd7eb0d4e4118bd09d582eae20eda2dba5"}]}