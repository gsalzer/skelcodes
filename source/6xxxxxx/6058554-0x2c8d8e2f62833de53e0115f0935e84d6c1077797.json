{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0 || b == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender account.\r\n     */\r\n    function Ownable() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Invalid owner\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0), \"Zero address\");\r\n        emit OwnershipTransferred(owner, newOwner);  \r\n        owner = newOwner;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256);\r\n\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract EyeToken is ERC20, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    struct Frozen {\r\n        bool frozen;\r\n        uint until;\r\n    }\r\n\r\n    string public name = \"EYE Token\";\r\n    string public symbol = \"EYE\";\r\n    uint8 public decimals = 18;\r\n\r\n    mapping(address => uint256) internal balances;\r\n    mapping(address => mapping(address => uint256)) internal allowed;\r\n    mapping(address => Frozen) public frozenAccounts;\r\n    uint256 internal totalSupplyTokens;\r\n    bool internal isICO;\r\n    address public wallet;\r\n\r\n    function EyeToken() public Ownable() {\r\n        wallet = msg.sender;\r\n        isICO = true;\r\n        totalSupplyTokens = 10000000000 * 10 ** uint256(decimals);\r\n        balances[wallet] = totalSupplyTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize ICO\r\n     */\r\n    function finalizeICO() public onlyOwner {\r\n        isICO = false;\r\n    }\r\n\r\n    /**\r\n    * @dev Total number of tokens in existence\r\n    */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupplyTokens;\r\n    }\r\n\r\n    /**\r\n     * @dev Freeze account, make transfers from this account unavailable\r\n     * @param _account Given account\r\n     */\r\n    function freeze(address _account) public onlyOwner {\r\n        freeze(_account, 0);\r\n    }\r\n\r\n    /**\r\n     * @dev  Temporary freeze account, make transfers from this account unavailable for a time\r\n     * @param _account Given account\r\n     * @param _until Time until\r\n     */\r\n    function freeze(address _account, uint _until) public onlyOwner {\r\n        if (_until == 0 || (_until != 0 && _until > now)) {\r\n            frozenAccounts[_account] = Frozen(true, _until);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Unfreeze account, make transfers from this account available\r\n     * @param _account Given account\r\n     */\r\n    function unfreeze(address _account) public onlyOwner {\r\n        if (frozenAccounts[_account].frozen) {\r\n            delete frozenAccounts[_account];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev allow transfer tokens or not\r\n     * @param _from The address to transfer from.\r\n     */\r\n    modifier allowTransfer(address _from) {\r\n        require(!isICO, \"ICO phase\");\r\n        if (frozenAccounts[_from].frozen) {\r\n            require(frozenAccounts[_from].until != 0 && frozenAccounts[_from].until < now, \"Frozen account\");\r\n            delete frozenAccounts[_from];\r\n        }\r\n        _;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer tokens for a specified address\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        bool result = _transfer(msg.sender, _to, _value);\r\n        emit Transfer(msg.sender, _to, _value); \r\n        return result;\r\n    }\r\n\r\n    /**\r\n    * @dev transfer tokens for a specified address in ICO mode\r\n    * @param _to The address to transfer to.\r\n    * @param _value The amount to be transferred.\r\n    */\r\n    function transferICO(address _to, uint256 _value) public onlyOwner returns (bool) {\r\n        require(isICO, \"Not ICO phase\");\r\n        require(_to != address(0), \"Zero address 'To'\");\r\n        require(_value <= balances[wallet], \"Not enought balance\");\r\n        balances[wallet] = balances[wallet].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(wallet, _to, _value);  \r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * @dev Gets the balance of the specified address.\r\n    * @param _owner The address to query the the balance of.\r\n    * @return An uint256 representing the amount owned by the passed address.\r\n    */\r\n    function balanceOf(address _owner) public view returns (uint256) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public allowTransfer(_from) returns (bool) {\r\n        require(_value <= allowed[_from][msg.sender], \"Not enought allowance\");\r\n        bool result = _transfer(_from, _to, _value);\r\n        if (result) {\r\n            allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n            emit Transfer(_from, _to, _value);  \r\n        }\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);  \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);  \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);  \r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param _from The address to transfer from.\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function _transfer(address _from, address _to, uint256 _value) internal allowTransfer(_from) returns (bool) {\r\n        require(_to != address(0), \"Zero address 'To'\");\r\n        require(_from != address(0), \"Zero address 'From'\");\r\n        require(_value <= balances[_from], \"Not enought balance\");\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        return true;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Crowd-sale\r\n *\r\n * @dev Crowd-sale contract for tokens\r\n */\r\ncontract CrowdSale is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    event Payment(\r\n        address wallet,\r\n        uint date,\r\n        uint256 amountEth,\r\n        uint256 amountCoin,\r\n        uint8 bonusPercent\r\n    );\r\n\r\n    uint constant internal MIN_TOKEN_AMOUNT = 5000;\r\n    uint constant internal SECONDS_IN_DAY = 86400; // 24 * 60 * 60\r\n    uint constant internal SECONDS_IN_YEAR = 31557600; // ( 365 * 24 + 6 ) * 60 * 60\r\n    int8 constant internal PHASE_NOT_STARTED = -5;\r\n    int8 constant internal PHASE_BEFORE_PRESALE = -4;\r\n    int8 constant internal PHASE_BETWEEN_PRESALE_ICO = -3;\r\n    int8 constant internal PHASE_ICO_FINISHED = -2;\r\n    int8 constant internal PHASE_FINISHED = -1;\r\n    int8 constant internal PHASE_PRESALE = 0;\r\n    int8 constant internal PHASE_ICO_1 = 1;\r\n    int8 constant internal PHASE_ICO_2 = 2;\r\n    int8 constant internal PHASE_ICO_3 = 3;\r\n    int8 constant internal PHASE_ICO_4 = 4;\r\n    int8 constant internal PHASE_ICO_5 = 5;\r\n\r\n    address internal manager;\r\n\r\n    EyeToken internal token;\r\n    address internal base_wallet;\r\n    uint256 internal dec_mul;\r\n    address internal vest_1;\r\n    address internal vest_2;\r\n    address internal vest_3;\r\n    address internal vest_4;\r\n\r\n    int8 internal phase_i; // see PHASE_XXX\r\n\r\n    uint internal presale_start = 1533020400; // 2018-07-31 07:00 UTC\r\n    uint internal presale_end = 1534316400; // 2018-08-15 07:00 UTC\r\n    uint internal ico_start = 1537254000; // 2018-09-18 07:00 UTC\r\n    uint internal ico_phase_1_days = 7;\r\n    uint internal ico_phase_2_days = 7;\r\n    uint internal ico_phase_3_days = 7;\r\n    uint internal ico_phase_4_days = 7;\r\n    uint internal ico_phase_5_days = 7;\r\n    uint internal ico_phase_1_end;\r\n    uint internal ico_phase_2_end;\r\n    uint internal ico_phase_3_end;\r\n    uint internal ico_phase_4_end;\r\n    uint internal ico_phase_5_end;\r\n    uint8[6] public bonus_percents = [50, 40, 30, 20, 10, 0];\r\n    uint internal finish_date;\r\n    uint public exchange_rate;  //  tokens in one ethereum * 1000\r\n    uint256 public lastPayerOverflow = 0;\r\n\r\n    /**\r\n     * @dev Crowd-sale constructor\r\n     */\r\n    function CrowdSale() Ownable() public {\r\n        phase_i = PHASE_NOT_STARTED;\r\n        manager = address(0);\r\n    }\r\n\r\n    /**\r\n     * @dev Allow only for owner or manager\r\n     */\r\n    modifier onlyOwnerOrManager(){\r\n        require(msg.sender == owner || (msg.sender == manager && manager != address(0)), \"Invalid owner or manager\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Returns current manager\r\n     */\r\n    function getManager() public view onlyOwnerOrManager returns (address) {\r\n        return manager;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets new manager\r\n     * @param _manager New manager\r\n     */\r\n    function setManager(address _manager) public onlyOwner {\r\n        manager = _manager;\r\n    }\r\n\r\n    /**\r\n     * @dev Set exchange rate\r\n     * @param _rate New exchange rate\r\n     *\r\n     * executed by CRM\r\n     */\r\n    function setRate(uint _rate) public onlyOwnerOrManager {\r\n        require(_rate > 0, \"Invalid exchange rate\");\r\n        exchange_rate = _rate;\r\n    }\r\n\r\n    function _addPayment(address wallet, uint256 amountEth, uint256 amountCoin, uint8 bonusPercent) internal {\r\n        emit Payment(wallet, now, amountEth, amountCoin, bonusPercent);\r\n    }\r\n\r\n    /**\r\n     * @dev Start crowd-sale\r\n     * @param _token Coin's contract\r\n     * @param _rate current exchange rate\r\n     */\r\n    function start(address _token, uint256 _rate) public onlyOwnerOrManager {\r\n        require(_rate > 0, \"Invalid exchange rate\");\r\n        require(phase_i == PHASE_NOT_STARTED, \"Bad phase\");\r\n\r\n        token = EyeToken(_token);\r\n        base_wallet = token.wallet();\r\n        dec_mul = 10 ** uint256(token.decimals());\r\n\r\n        // Organizasional expenses\r\n        address org_exp = 0xeb967ECF00e86F58F6EB8019d003c48186679A96;\r\n        // Early birds\r\n        address ear_brd = 0x469A97b357C2056B927fF4CA097513BD927db99E;\r\n        // Community development\r\n        address com_dev = 0x877D6a4865478f50219a20870Bdd16E6f7aa954F;\r\n        // Special coins\r\n        address special = 0x5D2C58e6aCC5BcC1aaA9b54B007e0c9c3E091adE;\r\n        // Team lock\r\n        vest_1 = 0x47997109aE9bEd21efbBBA362957F1b20F435BF3;\r\n        vest_2 = 0xd031B38d0520aa10450046Dc0328447C3FF59147;\r\n        vest_3 = 0x32FcE00BfE1fEC48A45DC543224748f280a5c69E;\r\n        vest_4 = 0x07B489712235197736E207836f3B71ffaC6b1220;\r\n\r\n        token.transferICO(org_exp, 600000000 * dec_mul);\r\n        token.transferICO(ear_brd, 1000000000 * dec_mul);\r\n        token.transferICO(com_dev, 1000000000 * dec_mul);\r\n        token.transferICO(special, 800000000 * dec_mul);\r\n        token.transferICO(vest_1, 500000000 * dec_mul);\r\n        token.transferICO(vest_2, 500000000 * dec_mul);\r\n        token.transferICO(vest_3, 500000000 * dec_mul);\r\n        token.transferICO(vest_4, 500000000 * dec_mul);\r\n\r\n        exchange_rate = _rate;\r\n\r\n        phase_i = PHASE_BEFORE_PRESALE;\r\n        _updatePhaseTimes();\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize ICO\r\n     */\r\n    function _finalizeICO() internal {\r\n        require(phase_i != PHASE_NOT_STARTED && phase_i != PHASE_FINISHED, \"Bad phase\");\r\n        phase_i = PHASE_ICO_FINISHED;\r\n        uint curr_date = now;\r\n        finish_date = (curr_date < ico_phase_5_end ? ico_phase_5_end : curr_date).add(SECONDS_IN_DAY * 10);\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize crowd-sale\r\n     */\r\n    function _finalize() internal {\r\n        require(phase_i != PHASE_NOT_STARTED && phase_i != PHASE_FINISHED, \"Bad phase\");\r\n\r\n        uint date = now.add(SECONDS_IN_YEAR);\r\n        token.freeze(vest_1, date);\r\n        date = date.add(SECONDS_IN_YEAR);\r\n        token.freeze(vest_2, date);\r\n        date = date.add(SECONDS_IN_YEAR);\r\n        token.freeze(vest_3, date);\r\n        date = date.add(SECONDS_IN_YEAR);\r\n        token.freeze(vest_4, date);\r\n\r\n        token.finalizeICO();\r\n        token.transferOwnership(base_wallet);\r\n\r\n        phase_i = PHASE_FINISHED;\r\n    }\r\n\r\n    /**\r\n     * @dev Finalize crowd-sale\r\n     */\r\n    function finalize() public onlyOwner {\r\n        _finalize();\r\n    }\r\n\r\n    function _calcPhase() internal view returns (int8) {\r\n        if (phase_i == PHASE_FINISHED || phase_i == PHASE_NOT_STARTED)\r\n            return phase_i;\r\n        uint curr_date = now;\r\n        if (curr_date >= ico_phase_5_end || token.balanceOf(base_wallet) == 0)\r\n            return PHASE_ICO_FINISHED;\r\n        if (curr_date < presale_start)\r\n            return PHASE_BEFORE_PRESALE;\r\n        if (curr_date <= presale_end)\r\n            return PHASE_PRESALE;\r\n        if (curr_date < ico_start)\r\n            return PHASE_BETWEEN_PRESALE_ICO;\r\n        if (curr_date < ico_phase_1_end)\r\n            return PHASE_ICO_1;\r\n        if (curr_date < ico_phase_2_end)\r\n            return PHASE_ICO_2;\r\n        if (curr_date < ico_phase_3_end)\r\n            return PHASE_ICO_3;\r\n        if (curr_date < ico_phase_4_end)\r\n            return PHASE_ICO_4;\r\n        return PHASE_ICO_5;\r\n    }\r\n\r\n    function phase() public view returns (int8) {\r\n        return _calcPhase();\r\n    }\r\n\r\n    /**\r\n     * @dev Recalculate phase\r\n     */\r\n    function _updatePhase(bool check_can_sale) internal {\r\n        uint curr_date = now;\r\n        if (phase_i == PHASE_ICO_FINISHED) {\r\n            if (curr_date >= finish_date)\r\n                _finalize();\r\n        }\r\n        else\r\n            if (phase_i != PHASE_NOT_STARTED && phase_i != PHASE_FINISHED) {\r\n                int8 new_phase = _calcPhase();\r\n                if (new_phase == PHASE_ICO_FINISHED && phase_i != PHASE_ICO_FINISHED)\r\n                    _finalizeICO();\r\n                else\r\n                    phase_i = new_phase;\r\n            }\r\n        if (check_can_sale)\r\n            require(phase_i >= 0, \"Bad phase\");\r\n    }\r\n\r\n    /**\r\n     * @dev Update phase end times\r\n     */\r\n    function _updatePhaseTimes() internal {\r\n        require(phase_i != PHASE_NOT_STARTED && phase_i != PHASE_FINISHED, \"Bad phase\");\r\n        if (phase_i < PHASE_ICO_1)\r\n            ico_phase_1_end = ico_start.add(SECONDS_IN_DAY.mul(ico_phase_1_days));\r\n        if (phase_i < PHASE_ICO_2)\r\n            ico_phase_2_end = ico_phase_1_end.add(SECONDS_IN_DAY.mul(ico_phase_2_days));\r\n        if (phase_i < PHASE_ICO_3)\r\n            ico_phase_3_end = ico_phase_2_end.add(SECONDS_IN_DAY.mul(ico_phase_3_days));\r\n        if (phase_i < PHASE_ICO_4)\r\n            ico_phase_4_end = ico_phase_3_end.add(SECONDS_IN_DAY.mul(ico_phase_4_days));\r\n        if (phase_i < PHASE_ICO_5)\r\n            ico_phase_5_end = ico_phase_4_end.add(SECONDS_IN_DAY.mul(ico_phase_5_days));\r\n        if (phase_i != PHASE_ICO_FINISHED)\r\n            finish_date = ico_phase_5_end.add(SECONDS_IN_DAY.mul(10));\r\n        _updatePhase(false);\r\n    }\r\n\r\n    /**\r\n     * @dev Send tokens to the specified address\r\n     *\r\n     * @param _to Address sent to\r\n     * @param _amount_coin Amount of tockens\r\n     * @return excess coins\r\n     *\r\n     * executed by CRM\r\n     */\r\n    function transferICO(address _to, uint256 _amount_coin) public onlyOwnerOrManager {\r\n        _updatePhase(true);\r\n        uint256 remainedCoin = token.balanceOf(base_wallet);\r\n        require(remainedCoin >= _amount_coin, \"Not enough coins\");\r\n        token.transferICO(_to, _amount_coin);\r\n        if (remainedCoin == _amount_coin)\r\n            _finalizeICO();\r\n    }\r\n\r\n    /**\r\n     * @dev Default contract function. Buy tokens by sending ethereums\r\n     */\r\n    function() public payable {\r\n        _updatePhase(true);\r\n        address sender = msg.sender;\r\n        uint256 amountEth = msg.value;\r\n        uint256 remainedCoin = token.balanceOf(base_wallet);\r\n        if (remainedCoin == 0) {\r\n            sender.transfer(amountEth);\r\n            _finalizeICO();\r\n        } else {\r\n            uint8 percent = bonus_percents[uint256(phase_i)];\r\n            uint256 amountCoin = calcTokensFromEth(amountEth);\r\n            assert(amountCoin >= MIN_TOKEN_AMOUNT);\r\n            if (amountCoin > remainedCoin) {\r\n                lastPayerOverflow = amountCoin.sub(remainedCoin);\r\n                amountCoin = remainedCoin;\r\n            }\r\n            base_wallet.transfer(amountEth);\r\n            token.transferICO(sender, amountCoin);\r\n            _addPayment(sender, amountEth, amountCoin, percent);\r\n            if (amountCoin == remainedCoin)\r\n                _finalizeICO();\r\n        }\r\n    }\r\n\r\n    function calcTokensFromEth(uint256 ethAmount) internal view returns (uint256) {\r\n        uint8 percent = bonus_percents[uint256(phase_i)];\r\n        uint256 bonusRate = uint256(percent).add(100);\r\n        uint256 totalCoins = ethAmount.mul(exchange_rate).div(1000);\r\n        uint256 totalFullCoins = (totalCoins.add(dec_mul.div(2))).div(dec_mul);\r\n        uint256 tokensWithBonusX100 = bonusRate.mul(totalFullCoins);\r\n        uint256 fullCoins = (tokensWithBonusX100.add(50)).div(100);\r\n        return fullCoins.mul(dec_mul);\r\n    }\r\n\r\n    /**\r\n     * @dev Freeze the account\r\n     * @param _accounts Given accounts\r\n     *\r\n     * executed by CRM\r\n     */\r\n    function freeze(address[] _accounts) public onlyOwnerOrManager {\r\n        require(phase_i != PHASE_NOT_STARTED && phase_i != PHASE_FINISHED, \"Bad phase\");\r\n        uint i;\r\n        for (i = 0; i < _accounts.length; i++) {\r\n            require(_accounts[i] != address(0), \"Zero address\");\r\n            require(_accounts[i] != base_wallet, \"Freeze self\");\r\n        }\r\n        for (i = 0; i < _accounts.length; i++) {\r\n            token.freeze(_accounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Unfreeze the account\r\n     * @param _accounts Given accounts\r\n     */\r\n    function unfreeze(address[] _accounts) public onlyOwnerOrManager {\r\n        require(phase_i != PHASE_NOT_STARTED && phase_i != PHASE_FINISHED, \"Bad phase\");\r\n        uint i;\r\n        for (i = 0; i < _accounts.length; i++) {\r\n            require(_accounts[i] != address(0), \"Zero address\");\r\n            require(_accounts[i] != base_wallet, \"Freeze self\");\r\n        }\r\n        for (i = 0; i < _accounts.length; i++) {\r\n            token.unfreeze(_accounts[i]);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev get ICO times\r\n     * @return presale_start, presale_end, ico_start, ico_phase_1_end, ico_phase_2_end, ico_phase_3_end, ico_phase_4_end, ico_phase_5_end\r\n     */\r\n    function getTimes() public view returns (uint, uint, uint, uint, uint, uint, uint, uint) {\r\n        return (presale_start, presale_end, ico_start, ico_phase_1_end, ico_phase_2_end, ico_phase_3_end, ico_phase_4_end, ico_phase_5_end);\r\n    }\r\n\r\n    /**\r\n     * @dev Sets start and end dates for pre-sale phase_i\r\n     * @param _presale_start Pre-sale sart date\r\n     * @param _presale_end Pre-sale end date\r\n     */\r\n    function setPresaleDates(uint _presale_start, uint _presale_end) public onlyOwnerOrManager {\r\n        _updatePhase(false);\r\n        require(phase_i == PHASE_BEFORE_PRESALE, \"Bad phase\");\r\n        // require(_presale_start >= now);\r\n        require(_presale_start < _presale_end, \"Invalid presale dates\");\r\n        require(_presale_end < ico_start, \"Invalid dates\");\r\n        presale_start = _presale_start;\r\n        presale_end = _presale_end;\r\n    }\r\n\r\n    /**\r\n     * @dev Sets start date for ICO phases\r\n     * @param _ico_start ICO start date\r\n     * @param _ico_1_days Days of ICO phase 1\r\n     * @param _ico_2_days Days of ICO phase 2\r\n     * @param _ico_3_days Days of ICO phase 3\r\n     * @param _ico_4_days Days of ICO phase 4\r\n     * @param _ico_5_days Days of ICO phase 5\r\n     */\r\n    function setICODates(uint _ico_start, uint _ico_1_days, uint _ico_2_days, uint _ico_3_days, uint _ico_4_days, uint _ico_5_days) public onlyOwnerOrManager {\r\n        _updatePhase(false);\r\n        require(phase_i != PHASE_FINISHED && phase_i != PHASE_ICO_FINISHED && phase_i < PHASE_ICO_1, \"Bad phase\");\r\n        require(presale_end < _ico_start, \"Invalid dates\");\r\n        ico_start = _ico_start;\r\n        ico_phase_1_days = _ico_1_days;\r\n        ico_phase_2_days = _ico_2_days;\r\n        ico_phase_3_days = _ico_3_days;\r\n        ico_phase_4_days = _ico_4_days;\r\n        ico_phase_5_days = _ico_5_days;\r\n        _updatePhaseTimes();\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount_coin\",\"type\":\"uint256\"}],\"name\":\"transferICO\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchange_rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"freeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"setRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_rate\",\"type\":\"uint256\"}],\"name\":\"start\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"bonus_percents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastPayerOverflow\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ico_start\",\"type\":\"uint256\"},{\"name\":\"_ico_1_days\",\"type\":\"uint256\"},{\"name\":\"_ico_2_days\",\"type\":\"uint256\"},{\"name\":\"_ico_3_days\",\"type\":\"uint256\"},{\"name\":\"_ico_4_days\",\"type\":\"uint256\"},{\"name\":\"_ico_5_days\",\"type\":\"uint256\"}],\"name\":\"setICODates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_accounts\",\"type\":\"address[]\"}],\"name\":\"unfreeze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"phase\",\"outputs\":[{\"name\":\"\",\"type\":\"int8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_manager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_presale_start\",\"type\":\"uint256\"},{\"name\":\"_presale_end\",\"type\":\"uint256\"}],\"name\":\"setPresaleDates\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimes\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountEth\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountCoin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusPercent\",\"type\":\"uint8\"}],\"name\":\"Payment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"CrowdSale","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://333e5cdbc4b8321e17c752722702de270e8d9b6c20bd0e57a7ae24d37462cc6d"}]}