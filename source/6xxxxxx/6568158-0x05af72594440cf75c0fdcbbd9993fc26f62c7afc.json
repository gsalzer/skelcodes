{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/*\r\n* https://12hourauction.github.io\r\n*/\r\n// THT Token Owners 10% (instantly)\r\n// Referral 10% (can withdraw instantly)\r\n// Key holdersâ€™ dividend: 30% (instantly? Till the end?)\r\n// Marketing: 5%\r\n// Final pot: 30%\r\n// Next pot: 15%\r\n// Total: 100%\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n}\r\ninterface TwelveHourTokenInterface {\r\n     function fallback() external payable; \r\n     function buy(address _referredBy) external payable returns (uint256);\r\n     function exit() external;\r\n}\r\n\r\ncontract TwelveHourAuction {\r\n\r\n    bool init = false;\r\n    using SafeMath for uint256;\r\n    \r\n    address owner;\r\n    uint256 public round     = 0;\r\n    uint256 public nextPot   = 0;\r\n    uint256 public profitTHT = 0;\r\n    // setting percent twelve hour auction\r\n    uint256 constant private THT_TOKEN_OWNERS     = 10;\r\n    uint256 constant private KEY_HOLDERS_DIVIDEND = 30;\r\n    uint256 constant private REFERRAL             = 10;\r\n    uint256 constant private FINAL_POT            = 30;\r\n    // uint256 constant private NEXT_POT             = 15;\r\n    uint256 constant private MARKETING            = 5;\r\n\r\n    uint256 constant private MAGINITUDE           = 2 ** 64;\r\n    uint256 constant private HALF_TIME            = 12 hours;\r\n    uint256 constant private KEY_PRICE_DEFAULT    = 0.005 ether;\r\n    uint256 constant private VERIFY_REFERRAL_PRICE= 0.01 ether;\r\n    // uint256 public stakingRequirement = 2 ether;\r\n    address public twelveHourTokenAddress;\r\n    TwelveHourTokenInterface public TwelveHourToken; \r\n\r\n    /** \r\n    * @dev game information\r\n    */\r\n    mapping(uint256 => Game) public games;\r\n    // bonus info\r\n    mapping(address => Player) public players;\r\n\r\n    mapping(address => bool) public referrals;\r\n\r\n    address[10] public teamMarketing;\r\n\r\n    struct Game {\r\n        uint256 round;\r\n        uint256 finalPot;\r\n        uint256 profitPerShare;\r\n        address keyHolder;\r\n        uint256 keyLevel;\r\n        uint256 endTime;\r\n        bool ended; \r\n    }\r\n    // distribute gen portion to key holders\r\n    struct Player {\r\n      uint256 curentRound;\r\n      uint256 lastRound;\r\n      uint256 bonus;\r\n      uint256 keys; // total key in round\r\n      uint256 dividends;\r\n      uint256 referrals;\r\n      int256 payouts;\r\n    }\r\n    event Buy(uint256 round, address buyer, uint256 amount, uint256 keyLevel);\r\n    event EndRound(uint256 round, uint256 finalPot, address keyHolder, uint256 keyLevel, uint256 endTime);\r\n    event Withdraw(address player, uint256 amount);\r\n    event WithdrawReferral(address player, uint256 amount);\r\n    modifier onlyOwner() \r\n    {\r\n      require(msg.sender == owner);\r\n      _;\r\n    }\r\n    modifier disableContract()\r\n    {\r\n      require(tx.origin == msg.sender);\r\n      _;\r\n    }\r\n    constructor() public \r\n    {\r\n      owner = msg.sender;\r\n      // setting default team marketing\r\n      for (uint256 idx = 0; idx < 10; idx++) {\r\n        teamMarketing[idx] = owner;\r\n      }\r\n    }\r\n    function () public payable\r\n    {\r\n        if (msg.sender != twelveHourTokenAddress) buy(0x0);\r\n    }\r\n    /**\r\n    * @dev set TwelveHourToken contract\r\n    * @param _addr TwelveHourToken address\r\n    */\r\n    function setTwelveHourToken(address _addr) public onlyOwner\r\n    {\r\n      twelveHourTokenAddress = _addr;\r\n      TwelveHourToken = TwelveHourTokenInterface(twelveHourTokenAddress);  \r\n    }\r\n    function setTeamMaketing(address _addr, uint256 _idx) public onlyOwner\r\n    {\r\n      teamMarketing[_idx] = _addr;\r\n    }\r\n    function verifyReferrals() public payable disableContract\r\n    {\r\n      require(msg.value >= VERIFY_REFERRAL_PRICE);\r\n      referrals[msg.sender] = true;\r\n      owner.transfer(msg.value);\r\n    }\r\n    // --------------------------------------------------------------------------\r\n    // SETUP GAME\r\n    // --------------------------------------------------------------------------\r\n    function startGame() public onlyOwner\r\n    {\r\n      require(init == false);\r\n      init = true;\r\n      games[round].ended = true;\r\n      startRound();\r\n    }\r\n    function startRound() private\r\n    {\r\n      require(games[round].ended == true);\r\n       \r\n      round = round + 1;\r\n      uint256 endTime = now + HALF_TIME;\r\n \r\n      games[round] = Game(round, nextPot, 0, 0x0, 1, endTime, false);\r\n      nextPot = 0;\r\n    }\r\n    function endRound() private disableContract\r\n    {\r\n      require(games[round].ended == false && games[round].endTime <= now);\r\n\r\n      Game storage g = games[round];\r\n      address keyHolder = g.keyHolder;\r\n      g.ended = true;\r\n      players[keyHolder].bonus += g.finalPot;\r\n      startRound();\r\n\r\n      // uint256 round, uint256 finalPot, address keyHolder, uint256 keyLevel, uint256 endTime\r\n\r\n      emit EndRound(g.round, g.finalPot, g.keyHolder, g.keyLevel, g.endTime);\r\n    }\r\n    // ------------------------------------------------------------------------------\r\n    // BUY KEY\r\n    // ------------------------------------------------------------------------------\r\n    function buy(address _referral) public payable disableContract\r\n    {\r\n      require(init == true);\r\n      require(games[round].ended == false);\r\n      require(msg.sender != _referral);\r\n\r\n      if (games[round].endTime <= now) endRound();\r\n      Game storage g   = games[round];\r\n\r\n      uint256 keyPrice       = SafeMath.mul(g.keyLevel, KEY_PRICE_DEFAULT);\r\n      uint256 repay          = SafeMath.sub(msg.value, keyPrice); \r\n      //\r\n      uint256 _referralBonus = SafeMath.div(SafeMath.mul(keyPrice, REFERRAL), 100);\r\n      uint256 _profitTHT     = SafeMath.div(SafeMath.mul(keyPrice, THT_TOKEN_OWNERS), 100);\r\n      uint256 _dividends     = SafeMath.div(SafeMath.mul(keyPrice, KEY_HOLDERS_DIVIDEND), 100);\r\n      uint256 _marketingFee  = SafeMath.div(SafeMath.mul(keyPrice, MARKETING), 100);\r\n      uint256 _finalPot      = SafeMath.div(SafeMath.mul(keyPrice, FINAL_POT), 100); \r\n      uint256 _nextPot       = keyPrice - (_referralBonus + _profitTHT + _dividends + _marketingFee + _finalPot);\r\n      if (msg.value < keyPrice) revert();\r\n      if (repay > 0) msg.sender.transfer(repay); // repay to player\r\n      if (_referral != 0x0 && referrals[_referral] == true) players[_referral].referrals += _referralBonus;\r\n      else owner.transfer(_referralBonus);\r\n\r\n      uint256 _fee = _dividends * MAGINITUDE;\r\n      nextPot = SafeMath.add(nextPot, _nextPot);\r\n      profitTHT = SafeMath.add(profitTHT, _profitTHT);\r\n\r\n      if (g.keyLevel > 1) {            \r\n        g.profitPerShare += (_dividends * MAGINITUDE / g.keyLevel);\r\n        _fee = _fee - (_fee - (1 * (_dividends * MAGINITUDE / g.keyLevel)));\r\n      }\r\n      int256 _updatedPayouts = (int256) (g.profitPerShare * 1 - _fee);\r\n      updatePlayer(msg.sender, _updatedPayouts);\r\n      // update game\r\n      updateGame(_finalPot);\r\n\r\n      sendToTeamMaketing(_marketingFee);\r\n\r\n      sendProfitTTH();\r\n      \r\n      emit Buy(round, msg.sender, keyPrice, games[round].keyLevel);\r\n    }\r\n    function withdraw() public disableContract\r\n\r\n    {\r\n      if (games[round].ended == false && games[round].endTime <= now) endRound();\r\n      \r\n      if (games[players[msg.sender].curentRound].ended == true) updatePlayerEndRound(msg.sender);\r\n\r\n      Player storage p = players[msg.sender];\r\n      uint256 _dividends = calculateDividends(msg.sender, p.curentRound);\r\n      uint256 balance    = SafeMath.add(p.bonus, _dividends);\r\n      balance = SafeMath.add(balance, p.dividends);\r\n\r\n      require(balance > 0);\r\n      if (address(this).balance >= balance) {\r\n        p.bonus = 0;\r\n        p.dividends = 0;\r\n        if (p.curentRound == round) p.payouts += (int256) (_dividends * MAGINITUDE);\r\n        msg.sender.transfer(balance);\r\n        emit Withdraw(msg.sender, balance);\r\n      }\r\n    }\r\n    function withdrawReferral() public disableContract\r\n    {\r\n      Player storage p = players[msg.sender];\r\n      uint256 balance = p.referrals;\r\n\r\n      require(balance > 0);\r\n      if (address(this).balance >= balance) {\r\n        p.referrals = 0;\r\n        msg.sender.transfer(balance);\r\n        emit WithdrawReferral(msg.sender, balance);\r\n      }\r\n    }\r\n    function myDividends(address _addr) \r\n    public \r\n    view\r\n    returns(\r\n      uint256 _dividends // bonus + dividends\r\n    ) {\r\n      Player memory p = players[_addr];\r\n      Game memory g = games[p.curentRound];\r\n      _dividends = p.bonus + p.dividends;\r\n      _dividends+= calculateDividends(_addr, p.curentRound);\r\n      if (\r\n        g.ended == false &&\r\n        g.endTime <= now &&\r\n        g.keyHolder == _addr \r\n        ) {\r\n        _dividends += games[p.curentRound].finalPot;\r\n      } \r\n    }\r\n    function getData(address _addr) \r\n    public \r\n    view\r\n    returns(\r\n      uint256 _round,\r\n      uint256 _finalPot,\r\n      uint256 _endTime,\r\n      uint256 _keyLevel,\r\n      uint256 _keyPrice,\r\n      address _keyHolder,\r\n      bool _ended,\r\n      // player info\r\n      uint256 _playerDividends,\r\n      uint256 _playerReferrals\r\n    ) {\r\n      _round = round;\r\n      Game memory g = games[_round];\r\n      _finalPot = g.finalPot;\r\n      _endTime  = g.endTime;\r\n      _keyLevel = g.keyLevel;\r\n      _keyPrice = _keyLevel * KEY_PRICE_DEFAULT;\r\n      _keyHolder= g.keyHolder;\r\n      _ended    = g.ended;\r\n      // player\r\n      _playerReferrals = players[_addr].referrals;\r\n      _playerDividends = myDividends(_addr);\r\n    } \r\n    function calculateDividends(address _addr, uint256 _round) public view returns(uint256 _devidends)\r\n    {\r\n      Game memory g   = games[_round];\r\n      Player memory p = players[_addr];\r\n      if (p.curentRound == _round && p.lastRound < _round && _round != 0 ) \r\n        _devidends = (uint256) ((int256) (g.profitPerShare * p.keys) - p.payouts) / MAGINITUDE;\r\n    }\r\n    function totalEthereumBalance() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    // ---------------------------------------------------------------------------------------------\r\n    // INTERNAL FUNCTION\r\n    // ---------------------------------------------------------------------------------------------\r\n\r\n    function updatePlayer(address _addr, int256 _updatedPayouts) private\r\n    {\r\n      Player storage p = players[_addr];\r\n      if (games[p.curentRound].ended == true) updatePlayerEndRound(_addr);\r\n      if (p.curentRound != round) p.curentRound = round;\r\n      p.keys       += 1;\r\n      p.payouts    += (int256)(_updatedPayouts); \r\n    }\r\n    function updatePlayerEndRound(address _addr) private\r\n    {\r\n      Player storage p = players[_addr];\r\n\r\n      uint256 dividends = calculateDividends(_addr, p.curentRound);\r\n      p.dividends       = SafeMath.add(p.dividends, dividends);\r\n      p.lastRound       = p.curentRound;\r\n      p.keys            = 0;\r\n      p.payouts         = 0;\r\n    }\r\n    function updateGame(uint256 _finalPot) private \r\n    {\r\n      Game storage g   = games[round];\r\n      // Final pot: 30%\r\n      g.finalPot = SafeMath.add(g.finalPot, _finalPot);\r\n      // update key holder\r\n      g.keyHolder = msg.sender;\r\n      // reset end time game\r\n      uint256 endTime = now + HALF_TIME;\r\n      endTime = endTime - 10 * g.keyLevel;\r\n      if (endTime <= now) endTime = now;\r\n      g.endTime = endTime;\r\n      // update key level\r\n      g.keyLevel += 1;\r\n    }\r\n    function sendToTeamMaketing(uint256 _marketingFee) private\r\n    {\r\n      // price * maketing / 100 * 10 /100 = price * maketing * 10 / 10000\r\n      uint256 profit = SafeMath.div(SafeMath.mul(_marketingFee, 10), 100);\r\n      for (uint256 idx = 0; idx < 10; idx++) {\r\n        teamMarketing[idx].transfer(profit);\r\n      }\r\n    }\r\n    function sendProfitTTH() private\r\n    {\r\n        uint256 balanceContract = totalEthereumBalance();\r\n        buyTHT(calEthSendToTHT(profitTHT));\r\n        exitTHT();\r\n        uint256 currentBalanceContract = totalEthereumBalance();\r\n        uint256 ethSendToTHT = SafeMath.sub(balanceContract, currentBalanceContract);\r\n        if (ethSendToTHT > profitTHT) {\r\n          // reset profit THT\r\n          profitTHT = 0;\r\n          nextPot = SafeMath.sub(nextPot, SafeMath.sub(ethSendToTHT, profitTHT));\r\n        } else {\r\n          profitTHT = SafeMath.sub(profitTHT, ethSendToTHT);\r\n        }\r\n    }\r\n    /**\r\n    * @dev calculate dividend eth for THT owner\r\n    * @param _eth value want share\r\n    * value = _eth * 100 / 64\r\n    */\r\n    function calEthSendToTHT(uint256 _eth) private pure returns(uint256 _value)\r\n    {\r\n      _value = SafeMath.div(SafeMath.mul(_eth, 100), 64);\r\n    }\r\n    // conect to tht contract\r\n    function buyTHT(uint256 _value) private\r\n    {\r\n      TwelveHourToken.fallback.value(_value)();\r\n    }\r\n    function exitTHT() private\r\n    {\r\n      TwelveHourToken.exit();\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"teamMarketing\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"games\",\"outputs\":[{\"name\":\"round\",\"type\":\"uint256\"},{\"name\":\"finalPot\",\"type\":\"uint256\"},{\"name\":\"profitPerShare\",\"type\":\"uint256\"},{\"name\":\"keyHolder\",\"type\":\"address\"},{\"name\":\"keyLevel\",\"type\":\"uint256\"},{\"name\":\"endTime\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"round\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getData\",\"outputs\":[{\"name\":\"_round\",\"type\":\"uint256\"},{\"name\":\"_finalPot\",\"type\":\"uint256\"},{\"name\":\"_endTime\",\"type\":\"uint256\"},{\"name\":\"_keyLevel\",\"type\":\"uint256\"},{\"name\":\"_keyPrice\",\"type\":\"uint256\"},{\"name\":\"_keyHolder\",\"type\":\"address\"},{\"name\":\"_ended\",\"type\":\"bool\"},{\"name\":\"_playerDividends\",\"type\":\"uint256\"},{\"name\":\"_playerReferrals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"profitTHT\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"twelveHourTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEthereumBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"referrals\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawReferral\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_idx\",\"type\":\"uint256\"}],\"name\":\"setTeamMaketing\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextPot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TwelveHourToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"myDividends\",\"outputs\":[{\"name\":\"_dividends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_round\",\"type\":\"uint256\"}],\"name\":\"calculateDividends\",\"outputs\":[{\"name\":\"_devidends\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startGame\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"players\",\"outputs\":[{\"name\":\"curentRound\",\"type\":\"uint256\"},{\"name\":\"lastRound\",\"type\":\"uint256\"},{\"name\":\"bonus\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"dividends\",\"type\":\"uint256\"},{\"name\":\"referrals\",\"type\":\"uint256\"},{\"name\":\"payouts\",\"type\":\"int256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_referral\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"setTwelveHourToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"verifyReferrals\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keyLevel\",\"type\":\"uint256\"}],\"name\":\"Buy\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"round\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"finalPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keyHolder\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"keyLevel\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endTime\",\"type\":\"uint256\"}],\"name\":\"EndRound\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"WithdrawReferral\",\"type\":\"event\"}]","ContractName":"TwelveHourAuction","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9ae51f6721136374d9ee9bb2275dd35ce6a39216efa0e2f6008f9685d5620de8"}]}