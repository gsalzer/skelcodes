{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract BasicTokenInterface{\r\n    \r\n    string public name;                   //fancy name: eg Simon Bucks\r\n    uint8 public decimals;                //How many decimals to show.\r\n    string public symbol;                 //An identifier: eg SBX\r\n    uint public totalSupply;\r\n    mapping (address => uint256) internal balances;\r\n    \r\n    modifier checkpayloadsize(uint size) {\r\n        assert(msg.data.length >= size + 4);\r\n        _;\r\n    } \r\n    function balanceOf(address tokenOwner) public view returns (uint balance);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n}\r\n\r\n\r\n// Contract function to receive approval and execute function in one call\r\n//\r\n// Borrowed from MiniMeToken\r\n// ----------------------------------------------------------------------------\r\ncontract ApproveAndCallFallBack {\r\n    event ApprovalReceived(address indexed from, uint256 indexed amount, address indexed tokenAddr, bytes data);\r\n    function receiveApproval(address from, uint256 amount, address tokenAddr, bytes data) public{\r\n        emit ApprovalReceived(from, amount, tokenAddr, data);\r\n    }\r\n}\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\r\n// ----------------------------------------------------------------------------\r\ncontract ERC20TokenInterface is BasicTokenInterface, ApproveAndCallFallBack{\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint256 public totalSupply;\r\n\r\n    function allowance(address tokenOwner, address spender) public view returns (uint remaining);   \r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n    function transferTokens(address token, uint amount) public returns (bool success);\r\n    function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\ncontract ManagedInterface{\r\n    address manager;\r\n    event ManagerChanged(address indexed oldManager, address indexed newManager);\r\n    modifier restricted(){\r\n        require(msg.sender == manager,\"Function can only be used by manager\");\r\n        _;\r\n    }\r\n\r\n    //Sweep out any other ERC20 tokens that got sent to the contract, sends to the manager\r\n    function sweepTokens(address token, address destination) public restricted {\r\n        uint balance = ERC20TokenInterface(token).balanceOf(address(this));\r\n        ERC20TokenInterface(token).transfer(destination,balance);\r\n    }\r\n\r\n    //Manager may drain the ETH on the contract\r\n    function sweepFunds(address destination, uint amount) public restricted{\r\n        amount = amount > address(this).balance ? address(this).balance : amount;\r\n        address(destination).transfer(amount);\r\n    }\r\n    \r\n    function setManager(address newManager) public;\r\n\r\n}\r\n\r\ncontract ManagedContract is ManagedInterface{\r\n    \r\n    constructor(address creator) public{\r\n        manager = creator;\r\n    }\r\n\r\n    function setManager(address newManager) public restricted{\r\n        address oldManager = manager; \r\n        manager = newManager;\r\n        emit ManagerChanged(oldManager,manager);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    \r\n    //Guard overflow by making 0 an impassable barrier\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        return (c >= a && c >= b) ? c : 0;\r\n    }\r\n\r\n    //Guard underflow by making 0 an impassable barrier\r\n    function sub(uint a, uint b) internal pure returns (uint) {\r\n        return (a >=b) ? (a - b): 0;\r\n    }\r\n\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || b == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(a > 0 && b > 0);\r\n        c = a / b;\r\n        return c;\r\n    }\r\n}\r\n\r\ncontract AVIVAccountInterface is ManagedInterface{\r\n    using SafeMath for uint;\r\n    uint verified_users;\r\n    uint public alias_price = 100000000000000000;\r\n    struct Account{\r\n        string name;\r\n        string country;\r\n        mapping(string => byte[]) pubkeys;\r\n        mapping(address => bool) communities;\r\n        bool verified;\r\n        uint donations;\r\n    }\r\n    \r\n    mapping(string => address) internal names;\r\n    mapping(address => Account) internal accounts;\r\n\r\n    //Emitted when manager verifies account\r\n    event AccountVerified(address user, string name, string country);\r\n\r\n    //Emitted when user changes keys\r\n    event KeyChanged(address user, string label, byte[] key);\r\n\r\n    //Emitted when user joins a community\r\n    event JoinedCommunity(string name, address community);\r\n\r\n    //Emitted when user leaves a community\r\n    event LeftCommunity(string name, address community);\r\n\r\n    event DonationReceived(address sender, uint value);\r\n\r\n    //Emitted when an alias is purchased\r\n    event NewAlias(address user, string name);\r\n    \r\n    function() public payable{\r\n        accounts[msg.sender].donations = accounts[msg.sender].donations.add(msg.value);\r\n        emit DonationReceived(msg.sender,msg.value);\r\n    }\r\n\r\n    //Manager can set minimum donation price to purchase an alias\r\n    function setAliasPrice(uint price) public;\r\n    \r\n    //Names can be set by anyone for a donation, manager does this for free in order to reserve names\r\n    function addAlias(address user, string alias) public payable;\r\n\r\n    //Only the manager can verify accounts, this is restricted in the implementation\r\n    function verifyAccount(address holder, string name, string country) public restricted;\r\n\r\n    //Accounts function as part of PKI, this is the PK in PKI\r\n    function changeKeys(string label, byte[] key) public;\r\n\r\n    //Joining a community allows the community to credit or debit your AVIV and VIP balances\r\n    function joinCommunity(address community) public;\r\n\r\n    //Leaving a community prevents that community from crediting or debiting your AVIV and VIP balances\r\n    function leaveCommunity(address community) public;\r\n\r\n    //are they part of a community\r\n    function inCommunity(address user, address community) public view returns (bool);\r\n\r\n     //get the name of an account\r\n    function getName(address user) public view returns (string);\r\n\r\n    //get the address of an account alias\r\n    function getByAlias(string name) public view returns (address);\r\n\r\n    //Is the account verified\r\n    function isVerified(address user) public view returns (bool);\r\n\r\n    //get the total of donations from a user\r\n    function donationsFrom(address user) public view returns (uint);\r\n\r\n}\r\n\r\ncontract AVIVAccount is ManagedContract(msg.sender), AVIVAccountInterface{\r\n \r\n    //Only the manager can verify accounts\r\n    function verifyAccount(address holder, string name, string country) public restricted{\r\n        require((names[name] == address(0) || names[name] == holder),\"NAMEINUSE\");\r\n        names[name] = holder;\r\n        Account storage account = accounts[holder];\r\n        account.name = name;\r\n        account.verified = true;\r\n        verified_users++;\r\n        emit AccountVerified(holder, name, country);\r\n        emit NewAlias(holder, name);\r\n    }\r\n\r\n    //Manager can set minimum donation price to purchase an alias\r\n    function setAliasPrice(uint price) public restricted{\r\n        alias_price = price;\r\n    }    \r\n\r\n    //Names can be set by anyone for a donation, manager does this for free in order to reserve names\r\n    function addAlias(address user, string alias) public payable{\r\n        if(msg.sender != manager){\r\n            require(msg.value >= alias_price,\"MINIMUMDONATIONREQUIRED\");\r\n            emit DonationReceived(msg.sender, msg.value);\r\n        }\r\n        require(names[alias] == address(0),\"NAMEINUSE\");\r\n        names[alias] = user; //This will not set the name attribute on the account\r\n        emit NewAlias(user, alias);\r\n    }\r\n\r\n    //Allows a user to specify a key mapped to a label, useful for PKI, not a good place to share a symmetric key\r\n    function changeKeys(string label, byte[] key) public{\r\n        accounts[msg.sender].pubkeys[label] = key;\r\n        emit KeyChanged(msg.sender,label,key);    \r\n    }\r\n\r\n    //Joining a community allows the community to credit or debit your AVIV and VIP balances\r\n    function joinCommunity(address community) public{\r\n        accounts[msg.sender].communities[community] = true;\r\n        emit JoinedCommunity(accounts[msg.sender].name, community);\r\n    }\r\n\r\n    //Leaving a community prevents that community from crediting or debiting your AVIV and VIP balances\r\n    function leaveCommunity(address community) public{\r\n        accounts[msg.sender].communities[community] = true;\r\n        emit LeftCommunity(accounts[msg.sender].name, community);\r\n    }\r\n\r\n    //are they part of a community\r\n    function inCommunity(address user, address community) public view returns (bool){\r\n        return accounts[user].communities[community];\r\n    }\r\n\r\n    //key with a specific label\r\n    function getKey(address user, string label) public view returns (byte[]){\r\n        return accounts[user].pubkeys[label];\r\n    }\r\n\r\n    //get the name of an account\r\n    function getName(address user) public view returns (string){\r\n        return accounts[user].name;\r\n    }\r\n\r\n    //get the address of an account alias\r\n    function getByAlias(string name) public view returns (address){\r\n        return names[name];\r\n    }\r\n\r\n    //check if user is verified\r\n    function isVerified(address user) public view returns (bool){\r\n        return accounts[user].verified;\r\n    }\r\n    \r\n    //return the total that this user has donated\r\n    function donationsFrom(address user) public view returns (uint){\r\n        return accounts[user].donations;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"community\",\"type\":\"address\"}],\"name\":\"inCommunity\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"destination\",\"type\":\"address\"}],\"name\":\"sweepTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setAliasPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"holder\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"country\",\"type\":\"string\"}],\"name\":\"verifyAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"destination\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sweepFunds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"label\",\"type\":\"string\"},{\"name\":\"key\",\"type\":\"bytes1[]\"}],\"name\":\"changeKeys\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"alias\",\"type\":\"string\"}],\"name\":\"addAlias\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"getName\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"community\",\"type\":\"address\"}],\"name\":\"joinCommunity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"},{\"name\":\"label\",\"type\":\"string\"}],\"name\":\"getKey\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes1[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"name\",\"type\":\"string\"}],\"name\":\"getByAlias\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"isVerified\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"community\",\"type\":\"address\"}],\"name\":\"leaveCommunity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"setManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"donationsFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"alias_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"country\",\"type\":\"string\"}],\"name\":\"AccountVerified\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"label\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"key\",\"type\":\"bytes1[]\"}],\"name\":\"KeyChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"community\",\"type\":\"address\"}],\"name\":\"JoinedCommunity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"community\",\"type\":\"address\"}],\"name\":\"LeftCommunity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"DonationReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"}],\"name\":\"NewAlias\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"oldManager\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newManager\",\"type\":\"address\"}],\"name\":\"ManagerChanged\",\"type\":\"event\"}]","ContractName":"AVIVAccount","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://680985cc569b2cf7aebaca6b24d2f9fddf631f5ea1b49cb312da55eb2152fdb5"}]}