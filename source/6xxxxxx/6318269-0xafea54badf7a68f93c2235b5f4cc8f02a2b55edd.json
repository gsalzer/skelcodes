{"status":"1","message":"OK","result":[{"SourceCode":"// File: contracts/generic/Restricted.sol\r\n\r\n/*\r\n    Generic contract to authorise calls to certain functions only from a given address.\r\n    The address authorised must be a contract (multisig or not, depending on the permission), except for local test\r\n\r\n    deployment works as:\r\n           1. contract deployer account deploys contracts\r\n           2. constructor grants \"PermissionGranter\" permission to deployer account\r\n           3. deployer account executes initial setup (no multiSig)\r\n           4. deployer account grants PermissionGranter permission for the MultiSig contract\r\n                (e.g. StabilityBoardProxy or PreTokenProxy)\r\n           5. deployer account revokes its own PermissionGranter permission\r\n*/\r\n\r\npragma solidity 0.4.24;\r\n\r\n\r\ncontract Restricted {\r\n\r\n    // NB: using bytes32 rather than the string type because it's cheaper gas-wise:\r\n    mapping (address => mapping (bytes32 => bool)) public permissions;\r\n\r\n    event PermissionGranted(address indexed agent, bytes32 grantedPermission);\r\n    event PermissionRevoked(address indexed agent, bytes32 revokedPermission);\r\n\r\n    modifier restrict(bytes32 requiredPermission) {\r\n        require(permissions[msg.sender][requiredPermission], \"msg.sender must have permission\");\r\n        _;\r\n    }\r\n\r\n    constructor(address permissionGranterContract) public {\r\n        require(permissionGranterContract != address(0), \"permissionGranterContract must be set\");\r\n        permissions[permissionGranterContract][\"PermissionGranter\"] = true;\r\n        emit PermissionGranted(permissionGranterContract, \"PermissionGranter\");\r\n    }\r\n\r\n    function grantPermission(address agent, bytes32 requiredPermission) public {\r\n        require(permissions[msg.sender][\"PermissionGranter\"],\r\n            \"msg.sender must have PermissionGranter permission\");\r\n        permissions[agent][requiredPermission] = true;\r\n        emit PermissionGranted(agent, requiredPermission);\r\n    }\r\n\r\n    function grantMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\r\n        require(permissions[msg.sender][\"PermissionGranter\"],\r\n            \"msg.sender must have PermissionGranter permission\");\r\n        uint256 length = requiredPermissions.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            grantPermission(agent, requiredPermissions[i]);\r\n        }\r\n    }\r\n\r\n    function revokePermission(address agent, bytes32 requiredPermission) public {\r\n        require(permissions[msg.sender][\"PermissionGranter\"],\r\n            \"msg.sender must have PermissionGranter permission\");\r\n        permissions[agent][requiredPermission] = false;\r\n        emit PermissionRevoked(agent, requiredPermission);\r\n    }\r\n\r\n    function revokeMultiplePermissions(address agent, bytes32[] requiredPermissions) public {\r\n        uint256 length = requiredPermissions.length;\r\n        for (uint256 i = 0; i < length; i++) {\r\n            revokePermission(agent, requiredPermissions[i]);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/generic/SafeMath.sol\r\n\r\n/**\r\n* @title SafeMath\r\n* @dev Math operations with safety checks that throw on error\r\n\r\n    TODO: check against ds-math: https://blog.dapphub.com/ds-math/\r\n    TODO: move roundedDiv to a sep lib? (eg. Math.sol)\r\n    TODO: more unit tests!\r\n*/\r\npragma solidity 0.4.24;\r\n\r\n\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        require(a == 0 || c / a == b, \"mul overflow\");\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div by 0\"); // Solidity automatically throws for div by 0 but require to emit reason\r\n        uint256 c = a / b;\r\n        // require(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a, \"sub underflow\");\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        require(c >= a, \"add overflow\");\r\n        return c;\r\n    }\r\n\r\n    // Division, round to nearest integer, round half up\r\n    function roundedDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div by 0\"); // Solidity automatically throws for div by 0 but require to emit reason\r\n        uint256 halfB = (b % 2 == 0) ? (b / 2) : (b / 2 + 1);\r\n        return (a % b >= halfB) ? (a / b + 1) : (a / b);\r\n    }\r\n\r\n    // Division, always rounds up\r\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b > 0, \"div by 0\"); // Solidity automatically throws for div by 0 but require to emit reason\r\n        return (a % b != 0) ? (a / b + 1) : (a / b);\r\n    }\r\n\r\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? a : b;\r\n    }\r\n\r\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        return a < b ? b : a;\r\n    }    \r\n}\r\n\r\n// File: contracts/Rates.sol\r\n\r\n/*\r\n Generic symbol / WEI rates contract.\r\n only callable by trusted price oracles.\r\n Being regularly called by a price oracle\r\n    TODO: trustless/decentrilezed price Oracle\r\n    TODO: shall we use blockNumber instead of now for lastUpdated?\r\n    TODO: consider if we need storing rates with variable decimals instead of fixed 4\r\n    TODO: could we emit 1 RateChanged event from setMultipleRates (symbols and newrates arrays)?\r\n*/\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\ncontract Rates is Restricted {\r\n    using SafeMath for uint256;\r\n\r\n    struct RateInfo {\r\n        uint rate; // how much 1 WEI worth 1 unit , i.e. symbol/ETH rate\r\n                    // 0 rate means no rate info available\r\n        uint lastUpdated;\r\n    }\r\n\r\n    // mapping currency symbol => rate. all rates are stored with 2 decimals. i.e. EUR/ETH = 989.12 then rate = 98912\r\n    mapping(bytes32 => RateInfo) public rates;\r\n\r\n    event RateChanged(bytes32 symbol, uint newRate);\r\n\r\n    constructor(address permissionGranterContract) public Restricted(permissionGranterContract) {} // solhint-disable-line no-empty-blocks\r\n\r\n    function setRate(bytes32 symbol, uint newRate) external restrict(\"RatesFeeder\") {\r\n        rates[symbol] = RateInfo(newRate, now);\r\n        emit RateChanged(symbol, newRate);\r\n    }\r\n\r\n    function setMultipleRates(bytes32[] symbols, uint[] newRates) external restrict(\"RatesFeeder\") {\r\n        require(symbols.length == newRates.length, \"symobls and newRates lengths must be equal\");\r\n        for (uint256 i = 0; i < symbols.length; i++) {\r\n            rates[symbols[i]] = RateInfo(newRates[i], now);\r\n            emit RateChanged(symbols[i], newRates[i]);\r\n        }\r\n    }\r\n\r\n    function convertFromWei(bytes32 bSymbol, uint weiValue) external view returns(uint value) {\r\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\r\n        return weiValue.mul(rates[bSymbol].rate).roundedDiv(1000000000000000000);\r\n    }\r\n\r\n    function convertToWei(bytes32 bSymbol, uint value) external view returns(uint weiValue) {\r\n        // next line would revert with div by zero but require to emit reason\r\n        require(rates[bSymbol].rate > 0, \"rates[bSymbol] must be > 0\");\r\n        /* TODO: can we make this not loosing max scale? */\r\n        return value.mul(1000000000000000000).roundedDiv(rates[bSymbol].rate);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/TransferFeeInterface.sol\r\n\r\n/*\r\n *  transfer fee calculation interface\r\n *\r\n */\r\npragma solidity 0.4.24;\r\n\r\n\r\ninterface TransferFeeInterface {\r\n    function calculateTransferFee(address from, address to, uint amount) external view returns (uint256 fee);\r\n}\r\n\r\n// File: contracts/interfaces/ERC20Interface.sol\r\n\r\n/*\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n */\r\npragma solidity 0.4.24;\r\n\r\n\r\ninterface ERC20Interface {\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n\r\n    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function balanceOf(address who) external view returns (uint);\r\n    function allowance(address _owner, address _spender) external view returns (uint remaining);\r\n\r\n}\r\n\r\n// File: contracts/interfaces/TokenReceiver.sol\r\n\r\n/*\r\n *  receiver contract interface\r\n * see https://github.com/ethereum/EIPs/issues/677\r\n */\r\npragma solidity 0.4.24;\r\n\r\n\r\ninterface TokenReceiver {\r\n    function transferNotification(address from, uint256 amount, uint data) external;\r\n}\r\n\r\n// File: contracts/interfaces/AugmintTokenInterface.sol\r\n\r\n/* Augmint Token interface (abstract contract)\r\n\r\nTODO: overload transfer() & transferFrom() instead of transferWithNarrative() & transferFromWithNarrative()\r\n      when this fix available in web3& truffle also uses that web3: https://github.com/ethereum/web3.js/pull/1185\r\nTODO: shall we use bytes for narrative?\r\n */\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract AugmintTokenInterface is Restricted, ERC20Interface {\r\n    using SafeMath for uint256;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    bytes32 public peggedSymbol;\r\n    uint8 public decimals;\r\n\r\n    uint public totalSupply;\r\n    mapping(address => uint256) public balances; // Balances for each account\r\n    mapping(address => mapping (address => uint256)) public allowed; // allowances added with approve()\r\n\r\n    TransferFeeInterface public feeAccount;\r\n    mapping(bytes32 => bool) public delegatedTxHashesUsed; // record txHashes used by delegatedTransfer\r\n\r\n    event TransferFeesChanged(uint transferFeePt, uint transferFeeMin, uint transferFeeMax);\r\n    event Transfer(address indexed from, address indexed to, uint amount);\r\n    event AugmintTransfer(address indexed from, address indexed to, uint amount, string narrative, uint fee);\r\n    event TokenIssued(uint amount);\r\n    event TokenBurned(uint amount);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    function transfer(address to, uint value) external returns (bool); // solhint-disable-line no-simple-event-func-name\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n    function approve(address spender, uint value) external returns (bool);\r\n\r\n    function delegatedTransfer(address from, address to, uint amount, string narrative,\r\n                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\r\n                                    bytes32 nonce, /* random nonce generated by client */\r\n                                    /* ^^^^ end of signed data ^^^^ */\r\n                                    bytes signature,\r\n                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\r\n                                ) external;\r\n\r\n    function delegatedTransferAndNotify(address from, TokenReceiver target, uint amount, uint data,\r\n                                    uint maxExecutorFeeInToken, /* client provided max fee for executing the tx */\r\n                                    bytes32 nonce, /* random nonce generated by client */\r\n                                    /* ^^^^ end of signed data ^^^^ */\r\n                                    bytes signature,\r\n                                    uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */\r\n                                ) external;\r\n\r\n    function increaseApproval(address spender, uint addedValue) external returns (bool);\r\n    function decreaseApproval(address spender, uint subtractedValue) external returns (bool);\r\n\r\n    function issueTo(address to, uint amount) external; // restrict it to \"MonetarySupervisor\" in impl.;\r\n    function burn(uint amount) external;\r\n\r\n    function transferAndNotify(TokenReceiver target, uint amount, uint data) external;\r\n\r\n    function transferWithNarrative(address to, uint256 amount, string narrative) external;\r\n    function transferFromWithNarrative(address from, address to, uint256 amount, string narrative) external;\r\n\r\n    function setName(string _name) external;\r\n    function setSymbol(string _symbol) external;\r\n\r\n    function allowance(address owner, address spender) external view returns (uint256 remaining);\r\n\r\n    function balanceOf(address who) external view returns (uint);\r\n\r\n\r\n}\r\n\r\n// File: contracts/Exchange.sol\r\n\r\n/* Augmint's Internal Exchange\r\n\r\n  For flows see: https://github.com/Augmint/augmint-contracts/blob/master/docs/exchangeFlow.png\r\n\r\n    TODO:\r\n        - change to wihtdrawal pattern, see: https://github.com/Augmint/augmint-contracts/issues/17\r\n        - deduct fee\r\n        - consider take funcs (frequent rate changes with takeBuyToken? send more and send back remainder?)\r\n        - use Rates interface?\r\n*/\r\npragma solidity 0.4.24;\r\n\r\n\r\n\r\n\r\n\r\n\r\ncontract Exchange is Restricted {\r\n    using SafeMath for uint256;\r\n\r\n    AugmintTokenInterface public augmintToken;\r\n    Rates public rates;\r\n\r\n    uint public constant CHUNK_SIZE = 100;\r\n\r\n    struct Order {\r\n        uint64 index;\r\n        address maker;\r\n\r\n        // % of published current peggedSymbol/ETH rates published by Rates contract. Stored as parts per million\r\n        // I.e. 1,000,000 = 100% (parity), 990,000 = 1% below parity\r\n        uint32 price;\r\n\r\n        // buy order: amount in wei\r\n        // sell order: token amount\r\n        uint amount;\r\n    }\r\n\r\n    uint64 public orderCount;\r\n    mapping(uint64 => Order) public buyTokenOrders;\r\n    mapping(uint64 => Order) public sellTokenOrders;\r\n\r\n    uint64[] private activeBuyOrders;\r\n    uint64[] private activeSellOrders;\r\n\r\n    /* used to stop executing matchMultiple when running out of gas.\r\n        actual is much less, just leaving enough matchMultipleOrders() to finish TODO: fine tune & test it*/\r\n    uint32 private constant ORDER_MATCH_WORST_GAS = 100000;\r\n\r\n    event NewOrder(uint64 indexed orderId, address indexed maker, uint32 price, uint tokenAmount, uint weiAmount);\r\n\r\n    event OrderFill(address indexed tokenBuyer, address indexed tokenSeller, uint64 buyTokenOrderId,\r\n        uint64 sellTokenOrderId, uint publishedRate, uint32 price, uint weiAmount, uint tokenAmount);\r\n\r\n    event CancelledOrder(uint64 indexed orderId, address indexed maker, uint tokenAmount, uint weiAmount);\r\n\r\n    event RatesContractChanged(Rates newRatesContract);\r\n\r\n    constructor(address permissionGranterContract, AugmintTokenInterface _augmintToken, Rates _rates)\r\n    public Restricted(permissionGranterContract) {\r\n        augmintToken = _augmintToken;\r\n        rates = _rates;\r\n    }\r\n\r\n    /* to allow upgrade of Rates  contract */\r\n    function setRatesContract(Rates newRatesContract)\r\n    external restrict(\"StabilityBoard\") {\r\n        rates = newRatesContract;\r\n        emit RatesContractChanged(newRatesContract);\r\n    }\r\n\r\n    function placeBuyTokenOrder(uint32 price) external payable returns (uint64 orderId) {\r\n        require(price > 0, \"price must be > 0\");\r\n        require(msg.value > 0, \"msg.value must be > 0\");\r\n\r\n        orderId = ++orderCount;\r\n        buyTokenOrders[orderId] = Order(uint64(activeBuyOrders.length), msg.sender, price, msg.value);\r\n        activeBuyOrders.push(orderId);\r\n\r\n        emit NewOrder(orderId, msg.sender, price, 0, msg.value);\r\n    }\r\n\r\n    /* this function requires previous approval to transfer tokens */\r\n    function placeSellTokenOrder(uint32 price, uint tokenAmount) external returns (uint orderId) {\r\n        augmintToken.transferFrom(msg.sender, this, tokenAmount);\r\n        return _placeSellTokenOrder(msg.sender, price, tokenAmount);\r\n    }\r\n\r\n    /* place sell token order called from AugmintToken's transferAndNotify\r\n     Flow:\r\n        1) user calls token contract's transferAndNotify price passed in data arg\r\n        2) transferAndNotify transfers tokens to the Exchange contract\r\n        3) transferAndNotify calls Exchange.transferNotification with lockProductId\r\n    */\r\n    function transferNotification(address maker, uint tokenAmount, uint price) external {\r\n        require(msg.sender == address(augmintToken), \"msg.sender must be augmintToken\");\r\n        _placeSellTokenOrder(maker, uint32(price), tokenAmount);\r\n    }\r\n\r\n    function cancelBuyTokenOrder(uint64 buyTokenId) external {\r\n        Order storage order = buyTokenOrders[buyTokenId];\r\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\r\n        require(order.amount > 0, \"buy order already removed\");\r\n\r\n        uint amount = order.amount;\r\n        order.amount = 0;\r\n        _removeBuyOrder(order);\r\n\r\n        msg.sender.transfer(amount);\r\n\r\n        emit CancelledOrder(buyTokenId, msg.sender, 0, amount);\r\n    }\r\n\r\n    function cancelSellTokenOrder(uint64 sellTokenId) external {\r\n        Order storage order = sellTokenOrders[sellTokenId];\r\n        require(order.maker == msg.sender, \"msg.sender must be order.maker\");\r\n        require(order.amount > 0, \"sell order already removed\");\r\n\r\n        uint amount = order.amount;\r\n        order.amount = 0;\r\n        _removeSellOrder(order);\r\n\r\n        augmintToken.transferWithNarrative(msg.sender, amount, \"Sell token order cancelled\");\r\n\r\n        emit CancelledOrder(sellTokenId, msg.sender, amount, 0);\r\n    }\r\n\r\n    /* matches any two orders if the sell price >= buy price\r\n        trade price is the price of the maker (the order placed earlier)\r\n        reverts if any of the orders have been removed\r\n    */\r\n    function matchOrders(uint64 buyTokenId, uint64 sellTokenId) external {\r\n        require(_fillOrder(buyTokenId, sellTokenId), \"fill order failed\");\r\n    }\r\n\r\n    /*  matches as many orders as possible from the passed orders\r\n        Runs as long as gas is available for the call.\r\n        Reverts if any match is invalid (e.g sell price > buy price)\r\n        Skips match if any of the matched orders is removed / already filled (i.e. amount = 0)\r\n    */\r\n    function matchMultipleOrders(uint64[] buyTokenIds, uint64[] sellTokenIds) external returns(uint matchCount) {\r\n        uint len = buyTokenIds.length;\r\n        require(len == sellTokenIds.length, \"buyTokenIds and sellTokenIds lengths must be equal\");\r\n\r\n        for (uint i = 0; i < len && gasleft() > ORDER_MATCH_WORST_GAS; i++) {\r\n            if(_fillOrder(buyTokenIds[i], sellTokenIds[i])) {\r\n                matchCount++;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getActiveOrderCounts() external view returns(uint buyTokenOrderCount, uint sellTokenOrderCount) {\r\n        return(activeBuyOrders.length, activeSellOrders.length);\r\n    }\r\n\r\n    // returns CHUNK_SIZE orders starting from offset\r\n    // orders are encoded as [id, maker, price, amount]\r\n    function getActiveBuyOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\r\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeBuyOrders.length; i++) {\r\n            uint64 orderId = activeBuyOrders[offset + i];\r\n            Order storage order = buyTokenOrders[orderId];\r\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\r\n        }\r\n    }\r\n\r\n    function getActiveSellOrders(uint offset) external view returns (uint[4][CHUNK_SIZE] response) {\r\n        for (uint8 i = 0; i < CHUNK_SIZE && i + offset < activeSellOrders.length; i++) {\r\n            uint64 orderId = activeSellOrders[offset + i];\r\n            Order storage order = sellTokenOrders[orderId];\r\n            response[i] = [orderId, uint(order.maker), order.price, order.amount];\r\n        }\r\n    }\r\n\r\n    uint private constant E12 = 1000000000000;\r\n\r\n    function _fillOrder(uint64 buyTokenId, uint64 sellTokenId) private returns(bool success) {\r\n        Order storage buy = buyTokenOrders[buyTokenId];\r\n        Order storage sell = sellTokenOrders[sellTokenId];\r\n        if( buy.amount == 0 || sell.amount == 0 ) {\r\n            return false; // one order is already filled and removed.\r\n                          // we let matchMultiple continue, indivudal match will revert\r\n        }\r\n\r\n        require(buy.price >= sell.price, \"buy price must be >= sell price\");\r\n\r\n        // pick maker's price (whoever placed order sooner considered as maker)\r\n        uint32 price = buyTokenId > sellTokenId ? sell.price : buy.price;\r\n\r\n        uint publishedRate;\r\n        (publishedRate, ) = rates.rates(augmintToken.peggedSymbol());\r\n        // fillRate = publishedRate * 1000000 / price\r\n\r\n        uint sellWei = sell.amount.mul(uint(price)).mul(E12).roundedDiv(publishedRate);\r\n\r\n        uint tradedWei;\r\n        uint tradedTokens;\r\n        if (sellWei <= buy.amount) {\r\n            tradedWei = sellWei;\r\n            tradedTokens = sell.amount;\r\n        } else {\r\n            tradedWei = buy.amount;\r\n            tradedTokens = buy.amount.mul(publishedRate).roundedDiv(uint(price).mul(E12));\r\n        }\r\n\r\n        buy.amount = buy.amount.sub(tradedWei);\r\n        if (buy.amount == 0) {\r\n            _removeBuyOrder(buy);\r\n        }\r\n\r\n        sell.amount = sell.amount.sub(tradedTokens);\r\n        if (sell.amount == 0) {\r\n            _removeSellOrder(sell);\r\n        }\r\n\r\n        augmintToken.transferWithNarrative(buy.maker, tradedTokens, \"Buy token order fill\");\r\n        sell.maker.transfer(tradedWei);\r\n\r\n        emit OrderFill(buy.maker, sell.maker, buyTokenId,\r\n            sellTokenId, publishedRate, price, tradedWei, tradedTokens);\r\n\r\n        return true;\r\n    }\r\n\r\n    function _placeSellTokenOrder(address maker, uint32 price, uint tokenAmount)\r\n    private returns (uint64 orderId) {\r\n        require(price > 0, \"price must be > 0\");\r\n        require(tokenAmount > 0, \"tokenAmount must be > 0\");\r\n\r\n        orderId = ++orderCount;\r\n        sellTokenOrders[orderId] = Order(uint64(activeSellOrders.length), maker, price, tokenAmount);\r\n        activeSellOrders.push(orderId);\r\n\r\n        emit NewOrder(orderId, maker, price, tokenAmount, 0);\r\n    }\r\n\r\n    function _removeBuyOrder(Order storage order) private {\r\n        uint lastIndex = activeBuyOrders.length - 1;\r\n        if (order.index < lastIndex) {\r\n            uint64 movedOrderId = activeBuyOrders[lastIndex];\r\n            activeBuyOrders[order.index] = movedOrderId;\r\n            buyTokenOrders[movedOrderId].index = order.index;\r\n        }\r\n        activeBuyOrders.length--;\r\n    }\r\n\r\n    function _removeSellOrder(Order storage order) private {\r\n        uint lastIndex = activeSellOrders.length - 1;\r\n        if (order.index < lastIndex) {\r\n            uint64 movedOrderId = activeSellOrders[lastIndex];\r\n            activeSellOrders[order.index] = movedOrderId;\r\n            sellTokenOrders[movedOrderId].index = order.index;\r\n        }\r\n        activeSellOrders.length--;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"buyTokenId\",\"type\":\"uint64\"},{\"name\":\"sellTokenId\",\"type\":\"uint64\"}],\"name\":\"matchOrders\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"buyTokenOrders\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint64\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"orderCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyTokenId\",\"type\":\"uint64\"}],\"name\":\"cancelBuyTokenOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint32\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"placeSellTokenOrder\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rates\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"permissions\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"},{\"name\":\"requiredPermission\",\"type\":\"bytes32\"}],\"name\":\"revokePermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"transferNotification\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"getActiveSellOrders\",\"outputs\":[{\"name\":\"response\",\"type\":\"uint256[4][100]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"augmintToken\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getActiveOrderCounts\",\"outputs\":[{\"name\":\"buyTokenOrderCount\",\"type\":\"uint256\"},{\"name\":\"sellTokenOrderCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"},{\"name\":\"requiredPermissions\",\"type\":\"bytes32[]\"}],\"name\":\"revokeMultiplePermissions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"},{\"name\":\"requiredPermissions\",\"type\":\"bytes32[]\"}],\"name\":\"grantMultiplePermissions\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRatesContract\",\"type\":\"address\"}],\"name\":\"setRatesContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint32\"}],\"name\":\"placeBuyTokenOrder\",\"outputs\":[{\"name\":\"orderId\",\"type\":\"uint64\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"name\":\"sellTokenOrders\",\"outputs\":[{\"name\":\"index\",\"type\":\"uint64\"},{\"name\":\"maker\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellTokenId\",\"type\":\"uint64\"}],\"name\":\"cancelSellTokenOrder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"buyTokenIds\",\"type\":\"uint64[]\"},{\"name\":\"sellTokenIds\",\"type\":\"uint64[]\"}],\"name\":\"matchMultipleOrders\",\"outputs\":[{\"name\":\"matchCount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"offset\",\"type\":\"uint256\"}],\"name\":\"getActiveBuyOrders\",\"outputs\":[{\"name\":\"response\",\"type\":\"uint256[4][100]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CHUNK_SIZE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"agent\",\"type\":\"address\"},{\"name\":\"requiredPermission\",\"type\":\"bytes32\"}],\"name\":\"grantPermission\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"permissionGranterContract\",\"type\":\"address\"},{\"name\":\"_augmintToken\",\"type\":\"address\"},{\"name\":\"_rates\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderId\",\"type\":\"uint64\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"NewOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenBuyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenSeller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"buyTokenOrderId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"sellTokenOrderId\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"publishedRate\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint32\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"}],\"name\":\"OrderFill\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"orderId\",\"type\":\"uint64\"},{\"indexed\":true,\"name\":\"maker\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"weiAmount\",\"type\":\"uint256\"}],\"name\":\"CancelledOrder\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newRatesContract\",\"type\":\"address\"}],\"name\":\"RatesContractChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"grantedPermission\",\"type\":\"bytes32\"}],\"name\":\"PermissionGranted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"revokedPermission\",\"type\":\"bytes32\"}],\"name\":\"PermissionRevoked\",\"type\":\"event\"}]","ContractName":"Exchange","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000004686f017d456331ed2c1de66e134d8d05b24413d00000000000000000000000086a635eccefffa70ff8a6db29da9c8db288e40d00000000000000000000000004babbe57453e2b6af125b4e304256fcbdf744480","Library":"","SwarmSource":"bzzr://3675c79c84f14dc23155c91ffc1f5b90b0f2c3a62f91041dc821e514d8598034"}]}