{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.18;\r\n\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  function Ownable() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address newOwner) public onlyOwner {\r\n    if (newOwner != address(0)) {\r\n      owner = newOwner;\r\n    }\r\n  }\r\n\r\n}\r\n\r\ncontract DefconPro is Ownable {\r\n  event Defcon(uint64 blockNumber, uint16 defconLevel);\r\n\r\n  uint16 public defcon = 5;//default defcon level of 5 means everything is cool, no problems\r\n\r\n  //if defcon is set to 4 or lower then function is paused\r\n  modifier defcon4() {//use this for high risk functions\r\n    require(defcon > 4);\r\n    _;\r\n  }\r\n\r\n  //if defcon is set to 3 or lower then function is paused\r\n  modifier defcon3() {\r\n    require(defcon > 3);\r\n    _;\r\n  }\r\n  \r\n  //if defcon is set to 2 or lower then function is paused\r\n   modifier defcon2() {\r\n    require(defcon > 2);\r\n    _;\r\n  }\r\n  \r\n  //if defcon is set to 1 or lower then function is paused\r\n  modifier defcon1() {//use this for low risk functions\r\n    require(defcon > 1);\r\n    _;\r\n  }\r\n\r\n  //set the defcon level, 5 is unpaused, 1 is EVERYTHING is paused\r\n  function setDefconLevel(uint16 _defcon) onlyOwner public {\r\n    defcon = _defcon;\r\n    Defcon(uint64(block.number), _defcon);\r\n  }\r\n\r\n}\r\n\r\n\r\ncontract bigBankLittleBank is DefconPro {\r\n    \r\n    using SafeMath for uint;\r\n    \r\n    uint public houseFee = 2; //Fee is 2%\r\n    uint public houseCommission = 0; //keeps track of commission\r\n    uint public bookKeeper = 0; //keeping track of what the balance should be to tie into auto pause script if it doesn't match contracte balance\r\n    \r\n    bytes32 emptyBet = 0x0000000000000000000000000000000000000000000000000000000000000000;\r\n    \r\n    //main event, listing off winners/losers\r\n    event BigBankBet(uint blockNumber, address indexed winner, address indexed loser, uint winningBetId1, uint losingBetId2, uint total);\r\n    //event to show users deposit history\r\n    event Deposit(address indexed user, uint amount);\r\n    //event to show users withdraw history\r\n    event Withdraw(address indexed user, uint amount);\r\n    \r\n    //Private struct that keeps track of each users bet\r\n    BetBank[] private betBanks;\r\n    \r\n    //bet Struct\r\n    struct BetBank {\r\n        bytes32 bet;\r\n        address owner;\r\n    }\r\n \r\n    //gets the user balance, requires that the user be the msg.sender, should make it a bit harder to get users balance\r\n    function userBalance() public view returns(uint) {\r\n        return userBank[msg.sender];\r\n    }\r\n    \r\n    //setting up internal bank struct, should prevent prying eyes from seeing other users banks\r\n    mapping (address => uint) public userBank;\r\n\r\n    //main deposit function\r\n    function depositBank() public defcon4 payable {\r\n        if(userBank[msg.sender] == 0) {//if the user doesn't have funds\r\n            userBank[msg.sender] = msg.value;//make balance = the funds\r\n        } else {\r\n            userBank[msg.sender] = (userBank[msg.sender]).add(msg.value);//if user already has funds, add to what exists\r\n        }\r\n        bookKeeper = bookKeeper.add(msg.value);//bookkeeper to prevent catastrophic exploits from going too far\r\n        Deposit(msg.sender, msg.value);//broadcast the deposit event\r\n    }\r\n    \r\n    //widthdraw what is in users bank\r\n    function withdrawBank(uint amount) public defcon2 returns(bool) {\r\n        require(userBank[msg.sender] >= amount);//require that the user has enough to withdraw\r\n        bookKeeper = bookKeeper.sub(amount);//update the bookkeeper\r\n        userBank[msg.sender] = userBank[msg.sender].sub(amount);//reduce users account balance\r\n        Withdraw(msg.sender, amount);//broadcast Withdraw event\r\n        (msg.sender).transfer(amount);//transfer the amount to user\r\n        return true;\r\n    }\r\n    \r\n    //create a bet\r\n    function startBet(uint _bet) public defcon3 returns(uint betId) {\r\n        require(userBank[msg.sender] >= _bet);//require user has enough to create the bet\r\n        require(_bet > 0);\r\n        userBank[msg.sender] = (userBank[msg.sender]).sub(_bet);//reduce users bank by the bet amount\r\n        uint convertedAddr = uint(msg.sender);\r\n        uint combinedBet = convertedAddr.add(_bet)*7;\r\n        BetBank memory betBank = BetBank({//birth the bet token\r\n            bet: bytes32(combinedBet),//_bet,\r\n            owner: msg.sender\r\n        });\r\n        //push new bet and get betId\r\n        betId = betBanks.push(betBank).sub(1);//push the bet token and get the Id\r\n    }\r\n   \r\n    //internal function to delete the bet token\r\n    function _endBetListing(uint betId) private returns(bool){\r\n        delete betBanks[betId];//delete that token\r\n    }\r\n    \r\n    //bet a users token against another users token\r\n    function betAgainstUser(uint _betId1, uint _betId2) public defcon3 returns(bool){\r\n        require(betBanks[_betId1].bet != emptyBet && betBanks[_betId2].bet != emptyBet);//require that both tokens are active and hold funds\r\n        require(betBanks[_betId1].owner == msg.sender || betBanks[_betId2].owner == msg.sender); //require that the user submitting is the owner of one of the tokens\r\n        require(betBanks[_betId1].owner != betBanks[_betId2].owner);//prevent a user from betting 2 tokens he owns, prevent possible exploits\r\n        require(_betId1 != _betId2);//require that user doesn't bet token against itself\r\n    \r\n        //unhash the bets to calculate winner\r\n        uint bet1ConvertedAddr = uint(betBanks[_betId1].owner);\r\n        uint bet1 = (uint(betBanks[_betId1].bet)/7).sub(bet1ConvertedAddr);\r\n        uint bet2ConvertedAddr = uint(betBanks[_betId2].owner);\r\n        uint bet2 = (uint(betBanks[_betId2].bet)/7).sub(bet2ConvertedAddr);  \r\n        \r\n        uint take = (bet1).add(bet2);//calculate the total rewards for winning\r\n        uint fee = (take.mul(houseFee)).div(100);//calculate the fee\r\n        houseCommission = houseCommission.add(fee);//add fee to commission\r\n        if(bet1 != bet2) {//if no tie\r\n            if(bet1 > bet2) {//if betId1 wins\r\n                _payoutWinner(_betId1, _betId2, take, fee);//payout betId1\r\n            } else {\r\n                _payoutWinner(_betId2, _betId1, take, fee);//payout betId2\r\n            }\r\n        } else {//if its a tie\r\n            if(_random() == 0) {//choose a random winner\r\n                _payoutWinner(_betId1, _betId2, take, fee);//payout betId1\r\n            } else {\r\n                _payoutWinner(_betId2, _betId1, take, fee);//payout betId2\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n\r\n    //internal function to pay out the winner\r\n    function _payoutWinner(uint winner, uint loser, uint take, uint fee) private returns(bool) {\r\n        BigBankBet(block.number, betBanks[winner].owner, betBanks[loser].owner, winner, loser, take.sub(fee));//broadcast the BigBankBet event\r\n        address winnerAddr = betBanks[winner].owner;//save the winner address\r\n        _endBetListing(winner);//end the token\r\n        _endBetListing(loser);//end the token\r\n        userBank[winnerAddr] = (userBank[winnerAddr]).add(take.sub(fee));//pay out the winner\r\n        return true;\r\n    }\r\n    \r\n    //set the fee\r\n    function setHouseFee(uint newFee)public onlyOwner returns(bool) {\r\n        require(msg.sender == owner);//redundant require owner\r\n        houseFee = newFee;//set the house fee\r\n        return true;\r\n    }\r\n    \r\n    //withdraw the commission\r\n    function withdrawCommission()public onlyOwner returns(bool) {\r\n        require(msg.sender == owner);//again redundant owner check because who trusts modifiers\r\n        bookKeeper = bookKeeper.sub(houseCommission);//update ;the bookKeeper\r\n        uint holding = houseCommission;//get the commission balance\r\n        houseCommission = 0;//empty the balance\r\n        owner.transfer(holding);//transfer to owner\r\n        return true;\r\n    }\r\n    \r\n    //random function for tiebreaker\r\n    function _random() private view returns (uint8) {\r\n        return uint8(uint256(keccak256(block.timestamp, block.difficulty))%2);\r\n    }\r\n    \r\n    //get amount of active bet tokens\r\n    function _totalActiveBets() private view returns(uint total) {\r\n        total = 0;\r\n        for(uint i=0; i<betBanks.length; i++) {//loop through bets \r\n            if(betBanks[i].bet != emptyBet && betBanks[i].owner != msg.sender) {//if there is a bet and the owner is not the msg.sender\r\n                total++;//increase quantity\r\n            }\r\n        }\r\n    }\r\n    \r\n    //get list of active bet tokens\r\n    function listActiveBets() public view returns(uint[]) {\r\n        uint256 total = _totalActiveBets();\r\n        if (total == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](total);\r\n            uint rc = 0;\r\n            for (uint idx=0; idx < betBanks.length; idx++) {//loop through bets\r\n                if(betBanks[idx].bet != emptyBet && betBanks[idx].owner != msg.sender) {//if there is a bet and the owner is not the msg.sender\r\n                    result[rc] = idx;//add token to list\r\n                    rc++;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n    //total open bets of user\r\n    function _totalUsersBets() private view returns(uint total) {\r\n        total = 0;\r\n        for(uint i=0; i<betBanks.length; i++) {//loop through bets\r\n            if(betBanks[i].owner == msg.sender && betBanks[i].bet != emptyBet) {//if the bet is over 0 and the owner is msg.sender\r\n                total++;//increase quantity\r\n            }\r\n        }\r\n    }\r\n    \r\n    //get list of active bet tokens\r\n    function listUsersBets() public view returns(uint[]) {\r\n        uint256 total = _totalUsersBets();\r\n        if (total == 0) {\r\n            return new uint256[](0);\r\n        } else {\r\n            uint256[] memory result = new uint256[](total);\r\n            uint rc = 0;\r\n            for (uint idx=0; idx < betBanks.length; idx++) {//loop through bets\r\n                if(betBanks[idx].owner == msg.sender && betBanks[idx].bet != emptyBet) {//if the bet is over 0 and owner is msg.sender\r\n                    result[rc] = idx;//add to list\r\n                    rc++;\r\n                }\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    \r\n}\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_defcon\",\"type\":\"uint16\"}],\"name\":\"setDefconLevel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseFee\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"defcon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"userBank\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawCommission\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newFee\",\"type\":\"uint256\"}],\"name\":\"setHouseFee\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listUsersBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"houseCommission\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"depositBank\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"listActiveBets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_betId1\",\"type\":\"uint256\"},{\"name\":\"_betId2\",\"type\":\"uint256\"}],\"name\":\"betAgainstUser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdrawBank\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"userBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_bet\",\"type\":\"uint256\"}],\"name\":\"startBet\",\"outputs\":[{\"name\":\"betId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bookKeeper\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"loser\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winningBetId1\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"losingBetId2\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"total\",\"type\":\"uint256\"}],\"name\":\"BigBankBet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"user\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"blockNumber\",\"type\":\"uint64\"},{\"indexed\":false,\"name\":\"defconLevel\",\"type\":\"uint16\"}],\"name\":\"Defcon\",\"type\":\"event\"}]","ContractName":"bigBankLittleBank","CompilerVersion":"v0.4.18+commit.9cf6e910","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://a5c35f125c3aaea5c38de352c6d90bb25ca450a17d8bd426935039c6e8063462"}]}