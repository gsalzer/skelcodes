{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\ncontract Draw {\r\n    using SafeMath for *;\r\n\r\n    event JoinRet(bool ret, uint256 inviteCode, address addr);\r\n    event InviteEvent(address origin, address player);\r\n    event Result(uint256 roundId, uint256 ts, uint256 amount, address winnerPid, uint256 winnerValue, address mostInvitePid, \r\n    uint256 mostInviteValue, address laffPid, uint256 laffValue);\r\n    event RoundStop(uint256 roundId);\r\n\r\n    struct Player {\r\n        address addr;   // player address\r\n        uint256 vault;    // vault\r\n        uint256 totalVault;\r\n        uint256 laff;   // affiliate pid \r\n        uint256 joinTime; //join time \r\n        uint256 drawCount; // draw timtes\r\n        uint256 remainInviteCount; \r\n        uint256 inviteDraw;  // invite draw Count\r\n        bool selfDraw; // self draw\r\n        uint256 inviteCode; \r\n        uint256 inviteCount; // invite count\r\n        uint256 newInviteCount; // new round invite count \r\n        uint256 inviteTs; // last invite time \r\n        //uint256 totalDrawCount; \r\n    }\r\n    \r\n    mapping (address => uint256) public pIDxAddr_; //玩家地址-ID映射\r\n    mapping (uint256 => uint256) public pIDxCount_; //玩家ID-抽奖次数映射\r\n\r\n    uint256 public totalPot_ = 0;\r\n    uint256 public beginTime_ = 0;\r\n    uint256 public endTime_ = 0;\r\n    uint256 public pIdIter_ = 0;  //pid自增器\r\n    uint256 public fund_  = 0;  //总奖池基金\r\n\r\n    // draw times\r\n    uint64 public times_ = 0;   \r\n    uint256 public drawNum_ = 0; //抽奖人次\r\n\r\n    mapping (uint256 => uint256) pInvitexID_;  //(inviteID => ID) \r\n    \r\n    mapping (bytes32 => address) pNamexAddr_;  //(name => addr) \r\n    mapping (uint256 => Player) public plyr_;  \r\n    \r\n    mapping (address => uint256) pAddrxFund_;  \r\n\r\n    uint256[3] public winners_;  //抽奖一二三等奖的玩家ID\r\n\r\n    uint256 public dayLimit_; //每日限额\r\n\r\n    uint256[] public joinPlys_;\r\n\r\n    uint256 public inviteIter_; //邀请计数\r\n\r\n    uint256 public roundId_ = 0; \r\n\r\n    //uint256 public constant gapTime_ = 24 hours;\r\n    uint256 public constant gapTime_ = 24 hours;\r\n\r\n    address private owner_;\r\n    \r\n    constructor () public {\r\n        beginTime_ = now;\r\n        endTime_ = beginTime_ + gapTime_;\r\n        roundId_ = 1;\r\n        owner_ = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting with fomo3d \r\n     */\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        \r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    uint256 public newMostInviter_ = 0;\r\n    uint256 public newMostInviteTimes_ = 0;\r\n    function determineNewRoundMostInviter (uint256 pid, uint256 times) \r\n        private\r\n    {\r\n        if (times > newMostInviteTimes_) {\r\n            newMostInviter_ = pid;\r\n            newMostInviteTimes_ = times;\r\n        }\r\n    }\r\n\r\n    function joinDraw(uint256 _affCode) \r\n        public\r\n        isHuman() \r\n    {\r\n        uint256 _pID = determinePID();\r\n        Player storage player = plyr_[_pID];\r\n\r\n         //邀请一个新玩家，抽奖次数加1\r\n        if (_affCode != 0 && _affCode != plyr_[_pID].inviteCode && player.joinTime == 0) {\r\n            uint256 _affPID = pInvitexID_[_affCode];\r\n            if (_affPID != 0) {\r\n                Player storage laffPlayer = plyr_[_affPID];\r\n                laffPlayer.inviteCount = laffPlayer.inviteCount + 1;\r\n                laffPlayer.remainInviteCount = laffPlayer.remainInviteCount + 1;\r\n\r\n                if (laffPlayer.inviteTs < beginTime_) {\r\n                    laffPlayer.newInviteCount = 0;\r\n                }\r\n                laffPlayer.newInviteCount += 1;\r\n                laffPlayer.inviteTs = now;\r\n                player.laff = _affCode;\r\n                determineNewRoundMostInviter(_affPID, laffPlayer.newInviteCount);\r\n\r\n                emit InviteEvent(laffPlayer.addr, player.addr);\r\n            }\r\n        }\r\n\r\n        if (player.joinTime <= beginTime_) {\r\n            player.drawCount = 0;\r\n            player.selfDraw = false;\r\n        } \r\n\r\n        bool joinRet = false;\r\n        if (player.drawCount < 5) {\r\n            //if (player.selfDraw == true && player.remainInviteCount == 0) {\r\n            require((player.selfDraw == false || player.remainInviteCount > 0), \"have no chance times\");\r\n            //}\r\n\r\n            uint256 remainCount = 5 - player.drawCount;\r\n            //if (remainCount <= 0) {\r\n            require(remainCount > 0, \"have no chance times 2\");\r\n            //;}\r\n\r\n            uint256 times = 0;\r\n            if (player.selfDraw == true) {\r\n                if (player.remainInviteCount >= remainCount) {\r\n                    player.remainInviteCount = player.remainInviteCount - remainCount;\r\n                    times = remainCount;\r\n                    player.inviteDraw = player.inviteDraw + remainCount;\r\n                } else {\r\n                    times = player.remainInviteCount;\r\n                    player.remainInviteCount = 0;\r\n                    player.inviteDraw = player.inviteDraw + player.remainInviteCount;\r\n                }\r\n            } else {\r\n                if (player.remainInviteCount + 1 >= remainCount) {\r\n                    player.remainInviteCount = player.remainInviteCount - remainCount + 1;\r\n                    times = remainCount;\r\n                    player.selfDraw = true;\r\n                    player.inviteDraw = player.inviteDraw + remainCount - 1;\r\n                } else {\r\n                    times = 1 + player.remainInviteCount;\r\n                    player.remainInviteCount = 0;\r\n                    player.selfDraw = true;\r\n                    player.inviteDraw = player.inviteDraw + player.remainInviteCount;\r\n                }\r\n            }\r\n\r\n            joinRet = true;\r\n            player.joinTime = now;\r\n\r\n            player.drawCount += times;\r\n            times = times > 5 ? 5 : times;\r\n            while(times > 0) {\r\n                joinPlys_.push(_pID);\r\n                times--;\r\n            } \r\n            emit JoinRet(true, player.inviteCode, player.addr);\r\n        } else {\r\n            emit JoinRet(false, player.inviteCode, player.addr);\r\n        }\r\n        //require (joinRet == true, \"joinDraw not success\");\r\n    }\r\n\r\n    function roundEnd() private {\r\n        emit RoundStop(roundId_);\r\n    }\r\n\r\n    function charge()\r\n        public\r\n        isHuman() \r\n        payable\r\n    {\r\n        uint256 _eth = msg.value;\r\n        fund_ = fund_.add(_eth);\r\n    }\r\n\r\n    function setParam(uint256 dayLimit) public {\r\n        //admin\r\n        require (\r\n            msg.sender == 0xf8636155ab3bda8035b02fc92b334f3758b5e1f3 ||\r\n            msg.sender == 0x0421b755b2c7813df34f8d9b81065f81b5a28d80 || \r\n            msg.sender == 0xf6eac1c72616c4fd2d389a8836af4c3345d79d92,\r\n            \"only amdin can do this\"\r\n        );\r\n\r\n        dayLimit_ = dayLimit;\r\n    }\r\n\r\n    modifier havePlay() {\r\n        require (joinPlys_.length > 0, \"must have at least 1 player\");\r\n        _;\r\n    } \r\n\r\n    function random() \r\n        private\r\n        havePlay()\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 _seed = uint256(keccak256(abi.encodePacked(\r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n\r\n        require(joinPlys_.length != 0, \"no one join draw\");\r\n\r\n        uint256 _rand = _seed % joinPlys_.length;\r\n        return _rand;\r\n    }\r\n\r\n    function joinCount() \r\n        public \r\n        view \r\n        returns (uint256)\r\n    {\r\n        return joinPlys_.length;\r\n    }\r\n\r\n    modifier haveFund() {\r\n        require (fund_ > 0, \"fund must more than 0\");\r\n        _;\r\n    }\r\n    \r\n    //开奖\r\n    function onDraw() \r\n        public\r\n        haveFund() \r\n    {\r\n        //admin\r\n        require (\r\n            msg.sender == 0xf8636155ab3bda8035b02fc92b334f3758b5e1f3 ||\r\n            msg.sender == 0x0421b755b2c7813df34f8d9b81065f81b5a28d80 || \r\n            msg.sender == 0xf6eac1c72616c4fd2d389a8836af4c3345d79d92,\r\n            \"only amdin can do this\"\r\n        );\r\n\r\n        require(joinPlys_.length > 0, \"no one join draw\");\r\n        require (fund_ > 0, \"fund must more than zero\");\r\n\r\n        if (dayLimit_ == 0) {\r\n            dayLimit_ = 0.1 ether;\r\n        }\r\n        \r\n        winners_[0] = 0;\r\n        winners_[1] = 0;\r\n        winners_[2] = 0;\r\n\r\n        uint256 _rand = random();\r\n        uint256 _winner =  joinPlys_[_rand];\r\n\r\n        winners_[0] = _winner;\r\n        winners_[1] = newMostInviter_;\r\n        winners_[2] = plyr_[_winner].laff;\r\n\r\n        uint256 _tempValue = 0;\r\n        uint256 _winnerValue = 0;\r\n        uint256 _mostInviteValue = 0;\r\n        uint256 _laffValue = 0;\r\n        uint256 _amount = 0;\r\n        address _winAddr;\r\n        address _mostAddr;\r\n        address _laffAddr;\r\n        //if (true) {\r\n        if (fund_ >= dayLimit_) {\r\n            _amount = dayLimit_;\r\n            fund_ = fund_.sub(dayLimit_);\r\n            _winnerValue = dayLimit_.mul(7).div(10);\r\n            _mostInviteValue = dayLimit_.mul(2).div(10);\r\n            _laffValue = dayLimit_.div(10);\r\n            plyr_[winners_[0]].vault = plyr_[winners_[0]].vault.add(_winnerValue);\r\n            plyr_[winners_[0]].totalVault = plyr_[winners_[0]].totalVault.add(_winnerValue);\r\n            _winAddr = plyr_[winners_[0]].addr;\r\n            if (winners_[1] == 0) {\r\n                _mostInviteValue = 0;\r\n            } else {\r\n                _mostAddr = plyr_[winners_[1]].addr;\r\n                plyr_[winners_[1]].vault = plyr_[winners_[1]].vault.add(_mostInviteValue);\r\n                plyr_[winners_[1]].totalVault = plyr_[winners_[1]].totalVault.add(_mostInviteValue);\r\n            }\r\n            if (winners_[2] == 0) { \r\n                _laffValue = 0;\r\n            } else {\r\n                _laffAddr = plyr_[winners_[2]].addr;\r\n                plyr_[winners_[2]].vault = plyr_[winners_[2]].vault.add(_laffValue);\r\n                plyr_[winners_[2]].totalVault = plyr_[winners_[2]].totalVault.add(_laffValue);\r\n            \r\n            }\r\n        } else {\r\n            _amount = fund_;\r\n            _tempValue = fund_;\r\n            fund_ = 0;\r\n            _winnerValue = _tempValue.mul(7).div(10);\r\n            _mostInviteValue = _tempValue.mul(2).div(10);\r\n            _laffValue = _tempValue.div(10);\r\n            plyr_[winners_[0]].vault = plyr_[winners_[0]].vault.add(_winnerValue);\r\n            plyr_[winners_[0]].totalVault = plyr_[winners_[0]].totalVault.add(_winnerValue);\r\n            _winAddr = plyr_[winners_[0]].addr;\r\n            if (winners_[1] == 0) {\r\n                _mostInviteValue = 0;\r\n            } else {\r\n                _mostAddr = plyr_[winners_[1]].addr;\r\n                plyr_[winners_[1]].vault = plyr_[winners_[1]].vault.add(_mostInviteValue);\r\n                plyr_[winners_[1]].totalVault = plyr_[winners_[1]].totalVault.add(_mostInviteValue);\r\n           \r\n            }\r\n            if (winners_[2] == 0) {\r\n                _laffValue = 0;\r\n            } else {\r\n                plyr_[winners_[2]].vault = plyr_[winners_[2]].vault.add(_laffValue);\r\n                plyr_[winners_[2]].totalVault = plyr_[winners_[2]].totalVault.add(_laffValue);\r\n                _laffAddr = plyr_[winners_[2]].addr;\r\n            }\r\n        }\r\n\r\n        emit Result(roundId_, endTime_, _amount, _winAddr, _winnerValue, _mostAddr, _mostInviteValue, _laffAddr, _laffValue);\r\n\r\n        nextRound();\r\n    }\r\n\r\n    function nextRound() \r\n        private \r\n    {\r\n        beginTime_ = now;\r\n        endTime_ = now + gapTime_;\r\n\r\n        delete joinPlys_;\r\n        \r\n        newMostInviteTimes_ = 0;\r\n        newMostInviter_ = 0;\r\n\r\n        roundId_++;\r\n        beginTime_ = now;\r\n        endTime_ = beginTime_ + gapTime_;\r\n    }\r\n\r\n    function withDraw()\r\n        public \r\n        isHuman()\r\n        returns(bool) \r\n    {\r\n        uint256 _now = now;\r\n        uint256 _pID = determinePID();\r\n        \r\n        if (_pID == 0) {\r\n            return;\r\n        }\r\n        \r\n        if (endTime_ > _now && fund_ > 0) {\r\n            roundEnd();\r\n        }\r\n\r\n        if (plyr_[_pID].vault != 0) {\r\n            uint256 vault = plyr_[_pID].vault;\r\n            plyr_[_pID].vault = 0;\r\n            msg.sender.transfer(vault);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function getRemainCount(address addr) \r\n        public\r\n        view\r\n        returns(uint256)  \r\n    {\r\n        uint256 pID = pIDxAddr_[addr];\r\n        if (pID == 0) {\r\n            return 1;\r\n        }\r\n        \r\n        uint256 remainCount = 0;\r\n\r\n        if (plyr_[pID].joinTime <= beginTime_) {\r\n            remainCount = plyr_[pID].remainInviteCount < 4 ? plyr_[pID].remainInviteCount + 1 : 5;\r\n        } else {\r\n            if (plyr_[pID].remainInviteCount == 0) {\r\n                remainCount = (plyr_[pID].drawCount == 0 ? 1 : 0);\r\n            } else {\r\n                if (plyr_[pID].drawCount >= 5) {\r\n                    remainCount = 0;\r\n                } else {\r\n                    uint256 temp = (5 - plyr_[pID].drawCount);\r\n                    remainCount = (plyr_[pID].remainInviteCount > temp ? temp :  plyr_[pID].remainInviteCount);\r\n                }\r\n            }  \r\n        } \r\n\r\n        return remainCount;\r\n    }\r\n\r\n     /**\r\n     * @dev gets existing or registers new pID.  use this when a player may be new\r\n     * @return pID \r\n     */\r\n    function determinePID()\r\n        private\r\n        returns(uint256)\r\n    {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        if (_pID == 0) {\r\n            pIdIter_ = pIdIter_ + 1;\r\n            _pID = pIdIter_;\r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n            inviteIter_ = inviteIter_.add(1);\r\n            plyr_[_pID].inviteCode = inviteIter_;\r\n            pInvitexID_[inviteIter_] = _pID;\r\n        }\r\n\r\n        return _pID;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"joinCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"times_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint64\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withDraw\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"dayLimit_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pIDxCount_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"drawNum_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dayLimit\",\"type\":\"uint256\"}],\"name\":\"setParam\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"charge\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"}],\"name\":\"joinDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"getRemainCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"inviteIter_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"winners_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beginTime_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pIdIter_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newMostInviter_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"gapTime_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newMostInviteTimes_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fund_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"endTime_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"vault\",\"type\":\"uint256\"},{\"name\":\"totalVault\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"joinTime\",\"type\":\"uint256\"},{\"name\":\"drawCount\",\"type\":\"uint256\"},{\"name\":\"remainInviteCount\",\"type\":\"uint256\"},{\"name\":\"inviteDraw\",\"type\":\"uint256\"},{\"name\":\"selfDraw\",\"type\":\"bool\"},{\"name\":\"inviteCode\",\"type\":\"uint256\"},{\"name\":\"inviteCount\",\"type\":\"uint256\"},{\"name\":\"newInviteCount\",\"type\":\"uint256\"},{\"name\":\"inviteTs\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"roundId_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"joinPlys_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"onDraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"ret\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"inviteCode\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"JoinRet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"origin\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"player\",\"type\":\"address\"}],\"name\":\"InviteEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ts\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerPid\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"mostInvitePid\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"mostInviteValue\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"laffPid\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"laffValue\",\"type\":\"uint256\"}],\"name\":\"Result\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundId\",\"type\":\"uint256\"}],\"name\":\"RoundStop\",\"type\":\"event\"}]","ContractName":"Draw","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://6b9d185891d9a74fbfe21da60e8106e1957a9ebe68bd39267d231dfe94be2666"}]}