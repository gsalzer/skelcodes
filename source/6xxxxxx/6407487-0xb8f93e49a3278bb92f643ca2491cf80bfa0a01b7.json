{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n/**\r\n *\r\n *  https://fairdapp.com/bank/  https://fairdapp.com/bank/   https://fairdapp.com/bank/\r\n *   \r\n *       _______     _       ______  _______ ______ ______  \r\n *      (_______)   (_)     (______)(_______|_____ (_____ \\ \r\n *       _____ _____ _  ____ _     _ _______ _____) )____) )\r\n *      |  ___|____ | |/ ___) |   | |  ___  |  ____/  ____/ \r\n *      | |   / ___ | | |   | |__/ /| |   | | |    | |      \r\n *      |_|   \\_____|_|_|   |_____/ |_|   |_|_|    |_|      \r\n *                                                     \r\n *               ______              _                              \r\n *              (____  \\            | |                             \r\n *               ____)  )_____ ____ | |  _                          \r\n *              |  __  ((____ |  _ \\| |_/ )                         \r\n *              | |__)  ) ___ | | | |  _ (                          \r\n *              |______/\\_____|_| |_|_| \\_)                         \r\n *                                                    \r\n *         ______ _             _                            \r\n *        / _____|_)           | |         _                 \r\n *       ( (____  _ ____  _   _| | _____ _| |_ ___   ____    \r\n *        \\____ \\| |    \\| | | | |(____ (_   _) _ \\ / ___)   \r\n *        _____) ) | | | | |_| | |/ ___ | | || |_| | |       \r\n *       (______/|_|_|_|_|____/ \\_)_____|  \\__)___/|_|       \r\n *                                                   \r\n *   \r\n *  Warning:\r\n *     \r\n *  FairDAPP – Bank Simulator (actually this probably has more resemblance \r\n *  of a government bond simulator but Bank is a more catchy name)\r\n *  is a system designed to explore how a real world financial bank would\r\n *  operate during a financial collapse without quantitative easing and bail outs.\r\n *  This system is simulated through open source smart contract codes and pre-defined rules.\r\n *  This contract may only be used internally for study purposes and all could be \r\n *  lost by sending anything to this contract address. \r\n *  All users are prohibited to interact with this contract if this \r\n *  contract is in conflict with user’s local regulations or laws.\r\n * \r\n *  -Original Contract built by the FairDAPP Community\r\n *  -Code Audited by 8Bit & Etherguy (formula calculations are excluded from the audit)\r\n *  \r\n *  -The contract has an activation switch to activate the system.\r\n *  -The resetTime and reduceTime functions have an on and off switch which the developer owner can control.\r\n *  -No one can change anything else once the contract has been deployed.\r\n *  \r\n *  -No anti-whales and almost no restrictions on what a user can do!\r\n *  -There is no need to FOMO, early players have no significant advantage over later players.\r\n *      -Scaling is slow, the system is designed for players to stake many stages. \r\n *  -The contract is fully solvent in any event (assuming there are no bugs).\r\n *      -ie. The contract will always payout what it owes. \r\n *\r\n**/\r\n\r\n\r\ncontract ERC721{\r\n    \r\n    function totalSupply() public view returns (uint256 total);\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address owner);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function takeOwnership(uint256 _tokenId) public;\r\n    function transfer(address _to, uint256 _tokenId) public;\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    \r\n    event Transfer(address from, address to, uint256 tokenId);\r\n    event Approval(address owner, address approved, uint256 tokenId);\r\n}\r\n\r\ncontract FairBank is ERC721{\r\n    using SafeMath for uint256;\r\n    using NameFilter for string;\r\n    address public developerAddr;\r\n\r\n    string public name = \"FairDAPP - Bank Simulator\";\r\n    string public symbol = \"FBank\";\r\n    \r\n    uint256 public stageDuration;\r\n    uint256 public standardProtectRatio;\r\n    bool public activated = false;\r\n    bool public modifyCountdown = false;\r\n    \r\n    uint256 public rId;\r\n    uint256 public sId;\r\n    \r\n    mapping (uint256 => FBankdatasets.Round) public round;\r\n    mapping (uint256 => mapping (uint256 => FBankdatasets.Stage)) public stage;\r\n    \r\n    mapping (address => bytes32) public register;\r\n    mapping (bytes32 => address) public playerName;\r\n    \r\n    mapping (address => uint256[]) public playerGoodsList;\r\n    mapping (address => uint256[]) public playerWithdrawList;\r\n    \r\n    /**\r\n     * Anti clone protection.\r\n     * Do not clone this contract without permission even if you manage to break the conceal. \r\n     * The concealed code contains core calculations necessary for this contract to function, read line 1058. \r\n     * This contract can be licensed for a fee, contact us instead of cloning!\r\n     */ \r\n    FairBankCompute constant private bankCompute = FairBankCompute(0x26DA117A72DBcB686c2FCF88c4BFC6110cAe0464);\r\n    \r\n    FBankdatasets.Goods[] public goodsList;\r\n    \r\n    FBankdatasets.Card[6] public cardList;\r\n    mapping (uint256 => address) public cardIndexToApproved;\r\n    \r\n    modifier registerVerify() {\r\n        require(msg.value == 10000000000000000, \"registration fee is 0.01 ether, please set the exact amount\");\r\n        _;\r\n    }\r\n    \r\n    modifier isActivated() {\r\n        require(activated == true, \"FairBank its not ready yet.  check ?eta in discord\"); \r\n        _;\r\n    }\r\n    \r\n    modifier isDeveloperAddr() {\r\n        require(msg.sender == developerAddr, \"Permission denied\");\r\n        _;\r\n    }\r\n    \r\n    modifier modifyCountdownVerify() {\r\n        require(modifyCountdown == true, \"this feature is not turned on or has been turned off\"); \r\n        _;\r\n    }\r\n     \r\n    modifier senderVerify() {\r\n        require (msg.sender == tx.origin, \"sender does not meet the rules\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * Don't toy or spam the contract, it may raise the gas cost for everyone else.\r\n     * The scientists will take anything below 0.001 ETH sent to the contract.\r\n     * Thank you for your donation.\r\n     */\r\n    modifier amountVerify() {\r\n        if(msg.value < 1000000000000000){\r\n            developerAddr.send(msg.value);\r\n        }else{\r\n            require(msg.value >= 1000000000000000, \"minimum amount is 0.001 ether\");\r\n            _;\r\n        }\r\n    }\r\n    \r\n    modifier playerVerify() {\r\n        require(playerGoodsList[msg.sender].length > 0, \"user has not purchased the product or has completed the withdrawal\");\r\n        _;\r\n    }\r\n    \r\n    modifier stepSizeVerify(uint256 _stepSize) {\r\n        require(_stepSize <= 1000000, \"step size must not exceed 1000000\");\r\n        _;\r\n    }\r\n    \r\n    constructor()\r\n        public\r\n    {\r\n        developerAddr = msg.sender;\r\n        \r\n        stageDuration = 64800;\r\n        standardProtectRatio = 57;\r\n        uint256 i;\r\n        while(i < cardList.length){\r\n            cardList[i].playerAddress = developerAddr;\r\n            cardList[i].amount = 5000000000000000000; \r\n            i++;\r\n        }\r\n    }\r\n    \r\n    function registered(string _playerName)\r\n        senderVerify()\r\n        registerVerify()\r\n        payable\r\n        public\r\n    {\r\n        bytes32 _name = _playerName.nameFilter();\r\n        require(_name != bytes32(0), \"name cannot be empty\");\r\n        require(playerName[_name] == address(0), \"this name has already been registered\");\r\n        require(register[msg.sender] == bytes32(0), \"please do not repeat registration\");\r\n        \r\n        playerName[_name] = msg.sender;\r\n        register[msg.sender] = _name;\r\n        developerAddr.send(msg.value);\r\n    }\r\n    \r\n    /**\r\n     * Activation of contract with settings\r\n     */\r\n    function activate()\r\n        senderVerify()\r\n        isDeveloperAddr()\r\n        public\r\n    {\r\n        require(activated == false, \"FairBank already activated\");\r\n        \r\n        activated = true;\r\n        rId = 1;\r\n        sId = 1;\r\n        round[rId].start = now;\r\n        stage[rId][sId].start = now;\r\n    }\r\n    \r\n    function openModifyCountdown()\r\n        senderVerify()\r\n        isDeveloperAddr()\r\n        public\r\n    {\r\n        require(modifyCountdown == false, \"Time service is already open\");\r\n        \r\n        modifyCountdown = true;\r\n        \r\n    }\r\n    \r\n    function closeModifyCountdown()\r\n        senderVerify()\r\n        isDeveloperAddr()\r\n        public\r\n    {\r\n        require(modifyCountdown == true, \"Time service is already open\");\r\n        \r\n        modifyCountdown = false;\r\n        \r\n    }\r\n    \r\n    function purchaseCard(uint256 _cId)\r\n        isActivated()\r\n        senderVerify()\r\n        payable\r\n        public\r\n    {\r\n        \r\n        address _player = msg.sender;\r\n        uint256 _amount = msg.value;\r\n        uint256 _purchasePrice = cardList[_cId].amount.mul(110) / 100;\r\n        \r\n        require(\r\n            cardList[_cId].playerAddress != address(0) \r\n            && cardList[_cId].playerAddress != _player \r\n            && _amount >= _purchasePrice, \r\n            \"Failed purchase\"\r\n        );\r\n        \r\n        if(cardIndexToApproved[_cId] != address(0)){\r\n            cardIndexToApproved[_cId].send(\r\n                cardList[_cId].amount.mul(105) / 100\r\n                );\r\n            delete cardIndexToApproved[_cId];\r\n        }else\r\n            cardList[_cId].playerAddress.send(\r\n                cardList[_cId].amount.mul(105) / 100\r\n                );\r\n                \r\n        developerAddr.send(cardList[_cId].amount.mul(5) / 100);\r\n        if(_amount > _purchasePrice)\r\n            _player.send(_amount.sub(_purchasePrice));\r\n            \r\n        cardList[_cId].amount = _purchasePrice;\r\n        cardList[_cId].playerAddress = _player;\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Fallback function to handle ethereum that was send straight to the contract\r\n     * Unfortunately we cannot use a referral address this way.\r\n     */\r\n    function()\r\n        isActivated()\r\n        senderVerify()\r\n        amountVerify()\r\n        payable\r\n        public\r\n    {\r\n        buyAnalysis(100, standardProtectRatio, address(0));\r\n    }\r\n\r\n    function buy(uint256 _stepSize, uint256 _protectRatio, address _recommendAddr)\r\n        isActivated()\r\n        senderVerify()\r\n        amountVerify()\r\n        stepSizeVerify(_stepSize)\r\n        public\r\n        payable\r\n    {\r\n        buyAnalysis(\r\n            _stepSize <= 0 ? 100 : _stepSize, \r\n            _protectRatio <= 100 ? _protectRatio : standardProtectRatio, \r\n            _recommendAddr\r\n            );\r\n    }\r\n    \r\n    function buyXname(uint256 _stepSize, uint256 _protectRatio, string _recommendName)\r\n        isActivated()\r\n        senderVerify()\r\n        amountVerify()\r\n        stepSizeVerify(_stepSize)\r\n        public\r\n        payable\r\n    {\r\n        buyAnalysis(\r\n            _stepSize <= 0 ? 100 : _stepSize, \r\n            _protectRatio <= 100 ? _protectRatio : standardProtectRatio, \r\n            playerName[_recommendName.nameFilter()]\r\n            );\r\n    }\r\n    \r\n    /**\r\n     * Standard withdraw function.\r\n     */\r\n    function withdraw()\r\n        isActivated()\r\n        senderVerify()\r\n        playerVerify()\r\n        public\r\n    {\r\n        \r\n        address _player = msg.sender;\r\n        uint256[] memory _playerGoodsList = playerGoodsList[_player];\r\n        uint256 length = _playerGoodsList.length;\r\n        uint256 _totalAmount;\r\n        uint256 _amount;\r\n        uint256 _withdrawSid;\r\n        uint256 _reachAmount;\r\n        bool _finish;\r\n        uint256 i;\r\n        \r\n        delete playerGoodsList[_player];\r\n        while(i < length){\r\n            \r\n            (_amount, _withdrawSid, _reachAmount, _finish) = getEarningsAmountByGoodsIndex(_playerGoodsList[i]);\r\n            \r\n            if(_finish == true){\r\n                playerWithdrawList[_player].push(_playerGoodsList[i]);\r\n            }else{\r\n                goodsList[_playerGoodsList[i]].withdrawSid = _withdrawSid;\r\n                goodsList[_playerGoodsList[i]].reachAmount = _reachAmount;\r\n                playerGoodsList[_player].push(_playerGoodsList[i]);\r\n            }\r\n            \r\n            _totalAmount = _totalAmount.add(_amount);\r\n            i++;\r\n        }\r\n        _player.transfer(_totalAmount);\r\n    }\r\n     \r\n     /**\r\n     * Backup withdraw function in case gas is too high to use standard withdraw.\r\n     */\r\n    function withdrawByGid(uint256 _gId)\r\n        isActivated()\r\n        senderVerify()\r\n        playerVerify()\r\n        public\r\n    {\r\n        address _player = msg.sender;\r\n        uint256 _amount;\r\n        uint256 _withdrawSid;\r\n        uint256 _reachAmount;\r\n        bool _finish;\r\n        \r\n        (_amount, _withdrawSid, _reachAmount, _finish) = getEarningsAmountByGoodsIndex(_gId);\r\n            \r\n        if(_finish == true){\r\n            \r\n            for(uint256 i = 0; i < playerGoodsList[_player].length; i++){\r\n                if(playerGoodsList[_player][i] == _gId)\r\n                    break;\r\n            }\r\n            require(i < playerGoodsList[_player].length, \"gid is wrong\");\r\n            \r\n            playerWithdrawList[_player].push(_gId);\r\n            playerGoodsList[_player][i] = playerGoodsList[_player][playerGoodsList[_player].length - 1];\r\n            playerGoodsList[_player].length--;\r\n        }else{\r\n            goodsList[_gId].withdrawSid = _withdrawSid;\r\n            goodsList[_gId].reachAmount = _reachAmount;\r\n        }\r\n        \r\n        _player.transfer(_amount);\r\n    }\r\n    \r\n    function resetTime()\r\n        modifyCountdownVerify()\r\n        senderVerify()\r\n        public\r\n        payable\r\n    {\r\n        uint256 _rId = rId;\r\n        uint256 _sId = sId;\r\n        uint256 _amount = msg.value;\r\n        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);\r\n        uint256 _targetAmount = \r\n            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ? \r\n            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;\r\n            _targetAmount = _targetAmount.mul(100) / 88;\r\n        uint256 _costAmount = _targetAmount.mul(20) / 100;\r\n        \r\n        if(_costAmount > 3 ether)\r\n            _costAmount = 3 ether;\r\n        require(_amount >= _costAmount, \"Not enough price\");\r\n        \r\n        stage[_rId][_sId].start = now;\r\n        \r\n        cardList[5].playerAddress.send(_costAmount / 2);\r\n        developerAddr.send(_costAmount / 2);\r\n        \r\n        if(_amount > _costAmount)\r\n            msg.sender.send(_amount.sub(_costAmount));\r\n        \r\n    }\r\n    \r\n    function reduceTime()\r\n        modifyCountdownVerify()\r\n        senderVerify()\r\n        public\r\n        payable\r\n    {\r\n        uint256 _rId = rId;\r\n        uint256 _sId = sId;\r\n        uint256 _amount = msg.value;\r\n        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);\r\n        uint256 _targetAmount = \r\n            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ?\r\n            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;\r\n            _targetAmount = _targetAmount.mul(100) / 88;\r\n        uint256 _costAmount = _targetAmount.mul(30) / 100;\r\n        \r\n        if(_costAmount > 3 ether)\r\n            _costAmount = 3 ether;\r\n        require(_amount >= _costAmount, \"Not enough price\");\r\n        \r\n        stage[_rId][_sId].start = now - stageDuration + 1800;\r\n        \r\n        cardList[5].playerAddress.send(_costAmount / 2);\r\n        developerAddr.send(_costAmount / 2);\r\n        \r\n        if(_amount > _costAmount)\r\n            msg.sender.send(_amount.sub(_costAmount));\r\n        \r\n    }\r\n    \r\n    /**\r\n     * Core logic to analyse buy behaviour. \r\n     */\r\n    function buyAnalysis(uint256 _stepSize, uint256 _protectRatio, address _recommendAddr)\r\n        private\r\n    {\r\n        uint256 _rId = rId;\r\n        uint256 _sId = sId;\r\n        uint256 _targetExpectedAmount = getStageTargetAmount(_sId);\r\n        uint256 _targetAmount = \r\n            stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ? \r\n            _targetExpectedAmount : stage[_rId][_sId].dividendAmount;\r\n            _targetAmount = _targetAmount.mul(100) / 88;\r\n        uint256 _stageTargetBalance = \r\n            stage[_rId][_sId].amount > 0 ? \r\n            _targetAmount.sub(stage[_rId][_sId].amount) : _targetAmount;\r\n        \r\n        if(now > stage[_rId][_sId].start.add(stageDuration) \r\n            && _targetAmount > stage[_rId][_sId].amount\r\n        ){\r\n            \r\n            endRound(_rId, _sId);\r\n            \r\n            _rId = rId;\r\n            _sId = sId;\r\n            stage[_rId][_sId].start = now;\r\n            \r\n            _targetExpectedAmount = getStageTargetAmount(_sId);\r\n            _targetAmount = \r\n                stage[_rId][_sId].dividendAmount <= _targetExpectedAmount ? \r\n                _targetExpectedAmount : stage[_rId][_sId].dividendAmount;\r\n            _targetAmount = _targetAmount.mul(100) / 88;\r\n            _stageTargetBalance = \r\n                stage[_rId][_sId].amount > 0 ? \r\n                _targetAmount.sub(stage[_rId][_sId].amount) : _targetAmount;\r\n        }\r\n        if(_stageTargetBalance > msg.value)\r\n            buyDataRecord(\r\n                _rId, \r\n                _sId, \r\n                _targetAmount, \r\n                msg.value, \r\n                _stepSize, \r\n                _protectRatio\r\n                );\r\n        else\r\n            multiStake(\r\n                msg.value, \r\n                _stepSize, \r\n                _protectRatio, \r\n                _targetAmount, \r\n                _stageTargetBalance\r\n                );\r\n        /* This is a backstop check to ensure that the contract will always be solvent.\r\n        It would reject any stakes with a protection ratio that the contract may not be able to repay.\r\n        This backstop should never be needed under current settings. */\r\n        require(\r\n            (\r\n                round[_rId].jackpotAmount.add(round[_rId].amount.mul(88) / 100)\r\n                .sub(round[_rId].protectAmount)\r\n                .sub(round[_rId].dividendAmount)\r\n            ) > 0, \"data error\"\r\n        );    \r\n        bankerFeeDataRecord(_recommendAddr, msg.value, _protectRatio);    \r\n    }\r\n    \r\n    function multiStake(uint256 _amount, uint256 _stepSize, uint256 _protectRatio, uint256 _targetAmount, uint256 _stageTargetBalance)\r\n        private\r\n    {\r\n        uint256 _rId = rId;\r\n        uint256 _sId = sId;\r\n        uint256 _crossStageNum = 1;\r\n        uint256 _protectTotalAmount;\r\n        uint256 _dividendTotalAmount;\r\n            \r\n        while(true){\r\n\r\n            if(_crossStageNum == 1){\r\n                playerDataRecord(\r\n                    _rId, \r\n                    _sId, \r\n                    _amount, \r\n                    _stageTargetBalance, \r\n                    _stepSize, \r\n                    _protectRatio, \r\n                    _crossStageNum\r\n                    );\r\n                round[_rId].amount = round[_rId].amount.add(_amount);\r\n                round[_rId].protectAmount = round[_rId].protectAmount.add(\r\n                    _amount.mul(_protectRatio.mul(88)) / 10000);    \r\n            }\r\n                \r\n            buyStageDataRecord(\r\n                _rId, \r\n                _sId, \r\n                _targetAmount, \r\n                _stageTargetBalance, \r\n                _sId.\r\n                add(_stepSize), \r\n                _protectRatio\r\n                );\r\n            _dividendTotalAmount = _dividendTotalAmount.add(stage[_rId][_sId].dividendAmount);\r\n            _protectTotalAmount = _protectTotalAmount.add(stage[_rId][_sId].protectAmount);\r\n            \r\n            _sId++;\r\n            _amount = _amount.sub(_stageTargetBalance);\r\n            _targetAmount = \r\n                stage[_rId][_sId].dividendAmount <= getStageTargetAmount(_sId) ? \r\n                getStageTargetAmount(_sId) : stage[_rId][_sId].dividendAmount;\r\n            _targetAmount = _targetAmount.mul(100) / 88;\r\n            _stageTargetBalance = _targetAmount;\r\n            _crossStageNum++;\r\n            if(_stageTargetBalance >= _amount){\r\n                buyStageDataRecord(\r\n                    _rId, \r\n                    _sId, \r\n                    _targetAmount, \r\n                    _amount, \r\n                    _sId.add(_stepSize), \r\n                    _protectRatio\r\n                    );\r\n                playerDataRecord(\r\n                    _rId, \r\n                    _sId, \r\n                    0, \r\n                    _amount, \r\n                    _stepSize, \r\n                    _protectRatio, \r\n                    _crossStageNum\r\n                    );\r\n                    \r\n                if(_targetAmount == _amount)\r\n                    _sId++;\r\n                    \r\n                stage[_rId][_sId].start = now;\r\n                sId = _sId;\r\n                \r\n                round[_rId].protectAmount = round[_rId].protectAmount.sub(_protectTotalAmount);\r\n                round[_rId].dividendAmount = round[_rId].dividendAmount.add(_dividendTotalAmount);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * Records all data.\r\n     */\r\n    function buyDataRecord(uint256 _rId, uint256 _sId, uint256 _targetAmount, uint256 _amount, uint256 _stepSize, uint256 _protectRatio)\r\n        private\r\n    {\r\n        uint256 _expectEndSid = _sId.add(_stepSize);\r\n        uint256 _protectAmount = _amount.mul(_protectRatio.mul(88)) / 10000;\r\n        \r\n        round[_rId].amount = round[_rId].amount.add(_amount);\r\n        round[_rId].protectAmount = round[_rId].protectAmount.add(_protectAmount);\r\n        \r\n        stage[_rId][_sId].amount = stage[_rId][_sId].amount.add(_amount);\r\n        stage[_rId][_expectEndSid].protectAmount = stage[_rId][_expectEndSid].protectAmount.add(_protectAmount);\r\n        stage[_rId][_expectEndSid].dividendAmount = \r\n            stage[_rId][_expectEndSid].dividendAmount.add(\r\n                computeEarningsAmount(_sId, \r\n                _amount, \r\n                _targetAmount, \r\n                _expectEndSid, \r\n                100 - _protectRatio\r\n                )\r\n                );\r\n                \r\n        FBankdatasets.Goods memory _goods;\r\n        _goods.rId = _rId;\r\n        _goods.startSid = _sId;\r\n        _goods.amount = _amount;\r\n        _goods.endSid = _expectEndSid;\r\n        _goods.protectRatio = _protectRatio;\r\n        playerGoodsList[msg.sender].push(goodsList.push(_goods) - 1);\r\n    }\r\n    \r\n    /**\r\n     * Records the stage data.\r\n     */\r\n    function buyStageDataRecord(uint256 _rId, uint256 _sId, uint256 _targetAmount, uint256 _amount, uint256 _expectEndSid, uint256 _protectRatio)\r\n        private\r\n    {\r\n        uint256 _protectAmount = _amount.mul(_protectRatio.mul(88)) / 10000;\r\n        \r\n        if(_targetAmount != _amount)\r\n            stage[_rId][_sId].amount = stage[_rId][_sId].amount.add(_amount);\r\n        stage[_rId][_expectEndSid].protectAmount = stage[_rId][_expectEndSid].protectAmount.add(_protectAmount);\r\n        stage[_rId][_expectEndSid].dividendAmount = \r\n            stage[_rId][_expectEndSid].dividendAmount.add(\r\n                computeEarningsAmount(\r\n                    _sId, \r\n                    _amount, \r\n                    _targetAmount, \r\n                    _expectEndSid, \r\n                    100 - _protectRatio\r\n                    )\r\n                );\r\n    }\r\n    \r\n    /**\r\n     * Records the player data.\r\n     */\r\n    function playerDataRecord(uint256 _rId, uint256 _sId, uint256 _totalAmount, uint256 _stageBuyAmount, uint256 _stepSize, uint256 _protectRatio, uint256 _crossStageNum)\r\n        private\r\n    {    \r\n        if(_crossStageNum <= 1){\r\n            FBankdatasets.Goods memory _goods;\r\n            _goods.rId = _rId;\r\n            _goods.startSid = _sId;\r\n            _goods.amount = _totalAmount;\r\n            _goods.stepSize = _stepSize;\r\n            _goods.protectRatio = _protectRatio;\r\n            if(_crossStageNum == 1)\r\n                _goods.startAmount = _stageBuyAmount;\r\n            playerGoodsList[msg.sender].push(goodsList.push(_goods) - 1);\r\n        }\r\n        else{\r\n            uint256 _goodsIndex = goodsList.length - 1;\r\n            goodsList[_goodsIndex].endAmount = _stageBuyAmount;\r\n            goodsList[_goodsIndex].endSid = _sId;\r\n        }\r\n        \r\n    }\r\n    \r\n    function bankerFeeDataRecord(address _recommendAddr, uint256 _amount, uint256 _protectRatio)\r\n        private\r\n    {\r\n        uint256 _jackpotProportion = 80;\r\n        if(_recommendAddr != address(0) \r\n            && _recommendAddr != msg.sender \r\n            && (register[_recommendAddr] != bytes32(0))\r\n        ){\r\n            _recommendAddr.send(_amount / 50);\r\n            msg.sender.send(_amount / 100);\r\n        }\r\n        else\r\n            _jackpotProportion = 110;\r\n            \r\n        round[rId].jackpotAmount = round[rId].jackpotAmount.add(_amount.mul(_jackpotProportion).div(1000));\r\n\r\n        uint256 _cardAmount = _amount / 200;\r\n        if(_protectRatio == 0)\r\n            cardList[0].playerAddress.send(_cardAmount);\r\n        else if(_protectRatio > 0 && _protectRatio < 57)\r\n            cardList[1].playerAddress.send(_cardAmount);   \r\n        else if(_protectRatio == 57)\r\n            cardList[2].playerAddress.send(_cardAmount);   \r\n        else if(_protectRatio > 57 && _protectRatio < 100)\r\n            cardList[3].playerAddress.send(_cardAmount);   \r\n        else if(_protectRatio == 100)\r\n            cardList[4].playerAddress.send(_cardAmount);   \r\n        \r\n        developerAddr.send(_amount / 200);\r\n    }\r\n    \r\n    function endRound(uint256 _rId, uint256 _sId)\r\n        private\r\n    {\r\n        round[_rId].end = now;\r\n        round[_rId].ended = true;\r\n        round[_rId].endSid = _sId;\r\n        \r\n        if(stage[_rId][_sId].amount > 0)\r\n            round[_rId + 1].jackpotAmount = (\r\n                round[_rId].jackpotAmount.add(round[_rId].amount.mul(88) / 100)\r\n                .sub(round[_rId].protectAmount)\r\n                .sub(round[_rId].dividendAmount)\r\n            ).mul(20).div(100);\r\n        else\r\n            round[_rId + 1].jackpotAmount = (\r\n                round[_rId].jackpotAmount.add(round[_rId].amount.mul(88) / 100)\r\n                .sub(round[_rId].protectAmount)\r\n                .sub(round[_rId].dividendAmount)\r\n            );\r\n        \r\n        round[_rId + 1].start = now;\r\n        rId++;\r\n        sId = 1;\r\n    }\r\n    \r\n    function getStageTargetAmount(uint256 _sId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return bankCompute.getStageTargetAmount(_sId);\r\n    }\r\n    \r\n    function computeEarningsAmount(uint256 _sId, uint256 _amount, uint256 _currentTargetAmount, uint256 _expectEndSid, uint256 _ratio)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return bankCompute.computeEarningsAmount(_sId, _amount, _currentTargetAmount, _expectEndSid, _ratio);\r\n    }\r\n    \r\n    function getEarningsAmountByGoodsIndex(uint256 _goodsIndex)\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, bool)\r\n    {\r\n        FBankdatasets.Goods memory _goods = goodsList[_goodsIndex];\r\n        uint256 _sId = sId;\r\n        uint256 _amount;\r\n        uint256 _targetExpectedAmount;\r\n        uint256 _targetAmount;\r\n        if(_goods.stepSize == 0){\r\n            if(round[_goods.rId].ended == true){\r\n                if(round[_goods.rId].endSid > _goods.endSid){\r\n                    _targetExpectedAmount = getStageTargetAmount(_goods.startSid);\r\n                    _targetAmount = \r\n                        stage[_goods.rId][_goods.startSid].dividendAmount <= _targetExpectedAmount ? \r\n                        _targetExpectedAmount : stage[_goods.rId][_goods.startSid].dividendAmount;\r\n                    _targetAmount = _targetAmount.mul(100) / 88;\r\n                    _amount = computeEarningsAmount(\r\n                        _goods.startSid, \r\n                        _goods.amount, \r\n                        _targetAmount, \r\n                        _goods.endSid, \r\n                        100 - _goods.protectRatio\r\n                        );\r\n                    \r\n                }else\r\n                    _amount = _goods.amount.mul(_goods.protectRatio.mul(88)) / 10000;\r\n                    \r\n                if(round[_goods.rId].endSid == _goods.startSid)\r\n                    _amount = _amount.add(\r\n                        _goods.amount.mul(\r\n                            getRoundJackpot(_goods.rId)\r\n                            ).div(stage[_goods.rId][_goods.startSid].amount)\r\n                            );\r\n                \r\n                return (_amount, 0, 0, true);\r\n            }else{\r\n                if(_sId > _goods.endSid){\r\n                    _targetExpectedAmount = getStageTargetAmount(_goods.startSid);\r\n                    _targetAmount = \r\n                        stage[_goods.rId][_goods.startSid].dividendAmount <= _targetExpectedAmount ?\r\n                        _targetExpectedAmount : stage[_goods.rId][_goods.startSid].dividendAmount;\r\n                    _targetAmount = _targetAmount.mul(100) / 88;\r\n                    _amount = computeEarningsAmount(\r\n                        _goods.startSid, \r\n                        _goods.amount, \r\n                        _targetAmount, \r\n                        _goods.endSid, \r\n                        100 - _goods.protectRatio\r\n                        );\r\n                }else\r\n                    return (0, 0, 0, false);\r\n            }\r\n            return (_amount, 0, 0, true);\r\n            \r\n        }else{\r\n            \r\n            uint256 _startSid = _goods.withdrawSid == 0 ? _goods.startSid : _goods.withdrawSid;\r\n            uint256 _ratio = 100 - _goods.protectRatio;\r\n            uint256 _reachAmount = _goods.reachAmount;\r\n            if(round[_goods.rId].ended == true){\r\n                \r\n                while(true){\r\n                    \r\n                    if(_startSid - (_goods.withdrawSid == 0 ? _goods.startSid : _goods.withdrawSid) > 100){\r\n                        return (_amount, _startSid, _reachAmount, false);\r\n                    }\r\n                    \r\n                    if(round[_goods.rId].endSid > _startSid.add(_goods.stepSize)){\r\n                        _targetExpectedAmount = getStageTargetAmount(_startSid);\r\n                        _targetAmount = \r\n                            stage[_goods.rId][_startSid].dividendAmount <= _targetExpectedAmount ? \r\n                            _targetExpectedAmount : stage[_goods.rId][_startSid].dividendAmount;\r\n                        _targetAmount = _targetAmount.mul(100) / 88;\r\n                        if(_startSid == _goods.endSid){\r\n                            _amount = _amount.add(\r\n                                computeEarningsAmount(\r\n                                    _startSid, \r\n                                    _goods.endAmount, \r\n                                    _targetAmount, \r\n                                    _startSid.add(_goods.stepSize), \r\n                                    _ratio\r\n                                    )\r\n                                );\r\n                            return (_amount, _goods.endSid, 0, true);\r\n                        }\r\n                        _amount = _amount.add(\r\n                            computeEarningsAmount(\r\n                                _startSid, \r\n                                _startSid == _goods.startSid ? _goods.startAmount : _targetAmount, \r\n                                _targetAmount, \r\n                                _startSid.add(_goods.stepSize), \r\n                                _ratio\r\n                                )\r\n                            );\r\n                        _reachAmount = \r\n                            _reachAmount.add(\r\n                                _startSid == _goods.startSid ? _goods.startAmount : _targetAmount\r\n                            );\r\n                    }else{\r\n                        \r\n                        _amount = _amount.add(\r\n                            (_goods.amount.sub(_reachAmount))\r\n                            .mul(_goods.protectRatio.mul(88)) / 10000\r\n                            );\r\n                        \r\n                        if(round[_goods.rId].endSid == _goods.endSid)\r\n                            _amount = _amount.add(\r\n                                _goods.endAmount.mul(getRoundJackpot(_goods.rId))\r\n                                .div(stage[_goods.rId][_goods.endSid].amount)\r\n                                );\r\n                        \r\n                        return (_amount, _goods.endSid, 0, true);\r\n                    }\r\n                    \r\n                    _startSid++;\r\n                }\r\n                \r\n            }else{\r\n                while(true){\r\n                    \r\n                    if(_startSid - (_goods.withdrawSid == 0 ? _goods.startSid : _goods.withdrawSid) > 100){\r\n                        return (_amount, _startSid, _reachAmount, false);\r\n                    }\r\n                    \r\n                    if(_sId > _startSid.add(_goods.stepSize)){\r\n                        _targetExpectedAmount = getStageTargetAmount(_startSid);\r\n                        _targetAmount = \r\n                            stage[_goods.rId][_startSid].dividendAmount <= _targetExpectedAmount ? \r\n                            _targetExpectedAmount : stage[_goods.rId][_startSid].dividendAmount;\r\n                        _targetAmount = _targetAmount.mul(100) / 88;\r\n                        if(_startSid == _goods.endSid){\r\n                            _amount = _amount.add(\r\n                                computeEarningsAmount(\r\n                                    _startSid, \r\n                                    _goods.endAmount, \r\n                                    _targetAmount, \r\n                                    _startSid.add(_goods.stepSize), \r\n                                    _ratio\r\n                                    )\r\n                                );\r\n                            return (_amount, _goods.endSid, 0, true);\r\n                        }\r\n                        _amount = _amount.add(\r\n                            computeEarningsAmount(\r\n                                _startSid, \r\n                                _startSid == _goods.startSid ? _goods.startAmount : _targetAmount, \r\n                                _targetAmount, \r\n                                _startSid.add(_goods.stepSize), \r\n                                _ratio\r\n                                )\r\n                            );\r\n                        _reachAmount = \r\n                            _reachAmount.add(\r\n                                _startSid == _goods.startSid ? \r\n                                _goods.startAmount : _targetAmount\r\n                            );\r\n                    }else    \r\n                        return (_amount, _startSid, _reachAmount, false);\r\n                    \r\n                    _startSid++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    \r\n    function getRoundJackpot(uint256 _rId)\r\n        public\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return (\r\n            (\r\n                round[_rId].jackpotAmount\r\n                .add(round[_rId].amount.mul(88) / 100))\r\n                .sub(round[_rId].protectAmount)\r\n                .sub(round[_rId].dividendAmount)\r\n            ).mul(80).div(100);\r\n    }\r\n    \r\n    function getHeadInfo()\r\n        public\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256)\r\n    {\r\n        uint256 _targetExpectedAmount = getStageTargetAmount(sId);\r\n        \r\n        return\r\n            (\r\n                rId,\r\n                sId,\r\n                stage[rId][sId].start.add(stageDuration),\r\n                stage[rId][sId].amount,\r\n                (\r\n                    stage[rId][sId].dividendAmount <= _targetExpectedAmount ? \r\n                    _targetExpectedAmount : stage[rId][sId].dividendAmount\r\n                ).mul(100) / 88,\r\n                round[rId].jackpotAmount.add(round[rId].amount.mul(88) / 100)\r\n                .sub(round[rId].protectAmount)\r\n                .sub(round[rId].dividendAmount)\r\n            );\r\n    }\r\n    \r\n    function getPlayerGoodList(address _player)\r\n        public\r\n        view\r\n        returns(uint256[])\r\n    {\r\n        return playerGoodsList[_player];\r\n    }\r\n\r\n    function totalSupply() \r\n        public \r\n        view \r\n        returns (uint256 total)\r\n    {\r\n        return cardList.length;\r\n    }\r\n    \r\n    function balanceOf(address _owner) \r\n        public \r\n        view \r\n        returns (uint256 balance)\r\n    {\r\n        uint256 _length = cardList.length;\r\n        uint256 _count;\r\n        for(uint256 i = 0; i < _length; i++){\r\n            if(cardList[i].playerAddress == _owner)\r\n                _count++;\r\n        }\r\n        \r\n        return _count;\r\n    }\r\n    \r\n    function ownerOf(uint256 _tokenId) \r\n        public \r\n        view \r\n        returns (address owner)\r\n    {\r\n        require(cardList.length > _tokenId, \"tokenId error\");\r\n        owner = cardList[_tokenId].playerAddress;\r\n        require(owner != address(0), \"No owner\");\r\n    }\r\n    \r\n    function approve(address _to, uint256 _tokenId)\r\n        senderVerify()\r\n        public\r\n    {\r\n        require (register[_to] != bytes32(0), \"Not a registered user\");\r\n        require (msg.sender == cardList[_tokenId].playerAddress, \"The card does not belong to you\");\r\n        require (cardList.length > _tokenId, \"tokenId error\");\r\n        require (cardIndexToApproved[_tokenId] == address(0), \"Approved\");\r\n        \r\n        cardIndexToApproved[_tokenId] = _to;\r\n        \r\n        emit Approval(msg.sender, _to, _tokenId);\r\n    }\r\n    \r\n    function takeOwnership(uint256 _tokenId)\r\n        senderVerify()\r\n        public\r\n    {\r\n        address _newOwner = msg.sender;\r\n        address _oldOwner = cardList[_tokenId].playerAddress;\r\n        \r\n        require(_newOwner != address(0), \"Address error\");\r\n        require(_newOwner == cardIndexToApproved[_tokenId], \"Without permission\");\r\n        \r\n        cardList[_tokenId].playerAddress = _newOwner;\r\n        delete cardIndexToApproved[_tokenId];\r\n        \r\n        emit Transfer(_oldOwner, _newOwner, _tokenId);\r\n    }\r\n    \r\n    function transfer(address _to, uint256 _tokenId) \r\n        senderVerify()\r\n        public\r\n    {\r\n        require (msg.sender == cardList[_tokenId].playerAddress, \"The card does not belong to you\");\r\n        require(_to != address(0), \"Address error\");\r\n        require(_to == cardIndexToApproved[_tokenId], \"Without permission\");\r\n        \r\n        cardList[_tokenId].playerAddress = _to;\r\n        \r\n        if(cardIndexToApproved[_tokenId] != address(0))\r\n            delete cardIndexToApproved[_tokenId];\r\n        \r\n        emit Transfer(msg.sender, _to, _tokenId);\r\n    }\r\n    \r\n    function transferFrom(address _from, address _to, uint256 _tokenId)\r\n        senderVerify()\r\n        public\r\n    {\r\n        require (_from == cardList[_tokenId].playerAddress, \"Owner error\");\r\n        require(_to != address(0), \"Address error\");\r\n        require(_to == cardIndexToApproved[_tokenId], \"Without permission\");\r\n        \r\n        cardList[_tokenId].playerAddress = _to;\r\n        delete cardIndexToApproved[_tokenId];\r\n        \r\n        emit Transfer(_from, _to, _tokenId);\r\n    }\r\n    \r\n}\r\n\r\nlibrary FBankdatasets {\r\n    \r\n    struct Round {\r\n        uint256 start;\r\n        uint256 end;\r\n        bool ended;\r\n        uint256 endSid;\r\n        uint256 amount;\r\n        uint256 protectAmount;\r\n        uint256 dividendAmount;\r\n        uint256 jackpotAmount;\r\n    }\r\n    \r\n    struct Stage {\r\n        uint256 start;\r\n        uint256 amount;\r\n        uint256 protectAmount;\r\n        uint256 dividendAmount;\r\n    }\r\n    \r\n    struct Goods {\r\n        uint256 rId;\r\n        uint256 startSid;\r\n        uint256 endSid;\r\n        uint256 withdrawSid;\r\n        uint256 amount;\r\n        uint256 startAmount;\r\n        uint256 endAmount;\r\n        uint256 reachAmount;\r\n        uint256 stepSize;\r\n        uint256 protectRatio;\r\n    }\r\n    \r\n    struct Card {\r\n        address playerAddress;\r\n        uint256 amount;\r\n    }\r\n}\r\n\r\n/**\r\n * Anti clone protection.\r\n * Do not clone this contract without permission even if you manage to break the conceal. \r\n * The concealed code contains core calculations necessary for this contract to function. \r\n * This contract can be licensed for a fee, contact us instead of cloning!\r\n */ \r\ninterface FairBankCompute {\r\n    function getStageTargetAmount(uint256 _sId) external view returns(uint256);\r\n    function computeEarningsAmount(uint256 _sId, uint256 _amount, uint256 _currentTargetAmount, uint256 _expectEndSid, uint256 _ratio) external view returns(uint256);\r\n}\r\n\r\nlibrary NameFilter {\r\n    \r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 3, \"string must be between 4 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            require\r\n            (\r\n                // OR uppercase A-Z\r\n                (_temp[i] > 0x40 && _temp[i] < 0x5b) ||\r\n                // OR lowercase a-z\r\n                (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                // or 0-9\r\n                (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                \"string contains invalid characters\"\r\n            );\r\n        }\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256) \r\n    {\r\n        assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"playerName\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getPlayerGoodList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"total\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerWithdrawList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"goodsList\",\"outputs\":[{\"name\":\"rId\",\"type\":\"uint256\"},{\"name\":\"startSid\",\"type\":\"uint256\"},{\"name\":\"endSid\",\"type\":\"uint256\"},{\"name\":\"withdrawSid\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"startAmount\",\"type\":\"uint256\"},{\"name\":\"endAmount\",\"type\":\"uint256\"},{\"name\":\"reachAmount\",\"type\":\"uint256\"},{\"name\":\"stepSize\",\"type\":\"uint256\"},{\"name\":\"protectRatio\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"closeModifyCountdown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"developerAddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"stage\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protectAmount\",\"type\":\"uint256\"},{\"name\":\"dividendAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round\",\"outputs\":[{\"name\":\"start\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"endSid\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"protectAmount\",\"type\":\"uint256\"},{\"name\":\"dividendAmount\",\"type\":\"uint256\"},{\"name\":\"jackpotAmount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cardIndexToApproved\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"register\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standardProtectRatio\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stepSize\",\"type\":\"uint256\"},{\"name\":\"_protectRatio\",\"type\":\"uint256\"},{\"name\":\"_recommendAddr\",\"type\":\"address\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_playerName\",\"type\":\"string\"}],\"name\":\"registered\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"ownerOf\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"resetTime\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_goodsIndex\",\"type\":\"uint256\"}],\"name\":\"getEarningsAmountByGoodsIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sId\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_currentTargetAmount\",\"type\":\"uint256\"},{\"name\":\"_expectEndSid\",\"type\":\"uint256\"},{\"name\":\"_ratio\",\"type\":\"uint256\"}],\"name\":\"computeEarningsAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rId\",\"type\":\"uint256\"}],\"name\":\"getRoundJackpot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cId\",\"type\":\"uint256\"}],\"name\":\"purchaseCard\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stageDuration\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"takeOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_gId\",\"type\":\"uint256\"}],\"name\":\"withdrawByGid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"modifyCountdown\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_stepSize\",\"type\":\"uint256\"},{\"name\":\"_protectRatio\",\"type\":\"uint256\"},{\"name\":\"_recommendName\",\"type\":\"string\"}],\"name\":\"buyXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"playerGoodsList\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getHeadInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sId\",\"type\":\"uint256\"}],\"name\":\"getStageTargetAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cardList\",\"outputs\":[{\"name\":\"playerAddress\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"openModifyCountdown\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reduceTime\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"approved\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"FairBank","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://33daa80fc25b9a9d27088a7b1891f5a6aaf17fe9090c3c043aa082068865c9c9"}]}