{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract pyramidMKII {\r\n    address owner;\r\n\t\r\n\tstruct blockinfo {\r\n        uint256 outstanding;                                                    // remaining debt at block\r\n        uint256 dividend;                                                      \t// % dividend all previous can claim, 1 ether \r\n\t\tuint256 value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// actual ether value at block\r\n\t\tuint256 index;                                                          // used in frontend bc async checks\r\n\t}\r\n\tstruct debtinfo {\r\n\t\tuint256 idx;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// dividend array position\r\n\t\tuint256 pending;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// pending balance at block\r\n\t\tuint256 initial;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// initial ammount for stats\r\n\t}\r\n    struct account {\r\n        uint256 ebalance;                                                       // ether balance\r\n\t\tmapping(uint256=>debtinfo) owed;\t\t\t\t\t\t\t\t\t\t// keeps track of outstanding debt \r\n    }\r\n\t\r\n\tuint256 public blksze;\t\t\t\t\t\t\t\t\t\t\t\t\t\t// block size\r\n\tuint256 public surplus;\r\n\tuint256 public IDX;\t\t\t\t\t\t\t\t\t\t\t\t\t\t    // current dividend block\r\n\tmapping(uint256=>blockinfo) public blockData;\t\t\t\t\t\t\t\t// dividend block data\r\n\tmapping(address=>account) public balances;\r\n\t\r\n\tbytes32 public consul_nme;\r\n\tuint256 public consul_price;\r\n\taddress public consul;\r\n\taddress patrician;\r\n\t\r\n    string public standard = 'PYRAMIDMKII';\r\n    string public name = 'PYRAMIDMKII';\r\n    string public symbol = 'PM2';\r\n    uint8 public decimals = 0 ;\r\n\t\r\n\tconstructor() public {                                                     \r\n        owner = msg.sender;  \r\n        blksze = 1 ether; \r\n        consul= owner;                                                          // owner is 1st consul    \r\n        patrician = owner;                                                      // owner is 1st patrician\r\n\t}\r\n\t\r\n\tfunction addSurplus() public payable { surplus += msg.value; }              // used to pay off the debt in final round\r\n\t\r\n\tfunction callSurplus() public {                                             // if there's enough surplus \r\n\t    require(surplus >= blksze, \"not enough surplus\");                       // users can call this to make a new block \r\n\t    blockData[IDX].value += blksze;                                         // without increasing outstanding\r\n\t    surplus -= blksze;\r\n\t    nextBlock();\r\n\t}\r\n\t    \r\n\tfunction owedAt(uint256 blk) public view returns(uint256, uint256, uint256)\r\n\t\t{ return (\tbalances[msg.sender].owed[blk].idx, \r\n\t\t\t\t\tbalances[msg.sender].owed[blk].pending, \r\n\t\t\t\t\tbalances[msg.sender].owed[blk].initial); }\r\n\t\r\n\tfunction setBlockSze(uint256 _sze) public {\r\n\t\trequire(msg.sender == owner && _sze >= 1 ether, \"error blksze\");\r\n\t\tblksze = _sze;\r\n\t}\r\n\t\r\n\tfunction withdraw() public {\r\n\t\trequire(balances[msg.sender].ebalance > 0, \"not enough divs claimed\");\r\n        uint256 sval = balances[msg.sender].ebalance;\r\n        balances[msg.sender].ebalance = 0;\r\n        msg.sender.transfer(sval);\r\n        emit event_withdraw(msg.sender, sval);\r\n\t}\r\n\t\r\n\tfunction chkConsul(address addr, uint256 val, bytes32 usrmsg) internal returns(uint256) {\r\n\t    if(val <= consul_price) return val;\r\n\t    balances[owner].ebalance += val/4;                                      // 25% for fund\r\n\t    balances[consul].ebalance += val/4;                                     // 25% for current consul\r\n\t    consul = addr;\r\n\t    consul_price = val;\r\n\t    consul_nme = usrmsg;\r\n\t    balances[addr].owed[IDX].pending += (val/2) + (val/4);                  // compensates for val/2\r\n\t    balances[addr].owed[IDX].initial += (val/2) + (val/4);\r\n\t    blockData[IDX].outstanding += (val/2) + (val/4);\r\n\t    emit event_consul(val, usrmsg);\r\n\t    return val/2;\r\n\t}\r\n\t\r\n\tfunction nextBlock() internal {\r\n\t    if(blockData[IDX].value>= blksze) { \r\n\t\t\tsurplus += blockData[IDX].value - blksze;\r\n\t\t\tblockData[IDX].value = blksze;\r\n\t\t\tif(IDX > 0) \r\n\t\t\t    blockData[IDX].outstanding -= \r\n\t\t\t        (blockData[IDX-1].outstanding * blockData[IDX-1].dividend)/100 ether;\r\n\t\t\tblockData[IDX].dividend = \r\n\t\t\t\t(blksze * 100 ether) / blockData[IDX].outstanding;\t\t\t\t// blocksize as % of total outstanding\r\n\t\t\tIDX += 1;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// filled block, next\r\n\t\t\tblockData[IDX].index = IDX;                                         // to avoid rechecking on frontend\r\n\t\t\tblockData[IDX].outstanding = blockData[IDX-1].outstanding;\t\t\t// debt rolls over\r\n\t\t\tif(IDX % 200 == 0 && IDX != 0) blksze += 1 ether;                   // to keep a proper div distribution\r\n\t\t\temit event_divblk(IDX);\r\n\t\t}\r\n\t}\r\n\t\r\n\tfunction pyramid(address addr, uint256 val, bytes32 usrmsg) internal {\r\n\t    val = chkConsul(addr, val, usrmsg);\r\n\t\tuint256 mval = val - (val/10);                                          // 10% in patrician, consul && fund money\r\n\t\tuint256 tval = val + (val/2);\r\n\t\tbalances[owner].ebalance += (val/100);                                  // 1% for hedge fund\r\n\t\tbalances[consul].ebalance += (val*7)/100 ;                              // 7% for consul\r\n\t\tbalances[patrician].ebalance+= (val/50);                                // 2% for patrician\r\n\t\tpatrician = addr;                                                       // now you're the patrician\r\n\t\tuint256 nsurp = (mval < blksze)? blksze-mval : (surplus < blksze)? surplus : 0;\r\n\t\tnsurp = (surplus >= nsurp)? nsurp : 0;\r\n\t\tmval += nsurp;                                                          // complete a block using surplus\r\n\t\tsurplus-= nsurp;                                                        \r\n\t\tblockData[IDX].value += mval;\r\n        blockData[IDX].outstanding += tval;                                     // block outstanding debt increases until block fills\r\n\t\tbalances[addr].owed[IDX].idx = IDX;\t\t\t\t\t\t\t            // user can claim when block is full\r\n\t\tbalances[addr].owed[IDX].pending += tval;                               // 1.5x for user\r\n\t\tbalances[addr].owed[IDX].initial += tval;\r\n\t\tnextBlock();\r\n\t\temit event_deposit(val, usrmsg);\r\n\t}\r\n\t\r\n\tfunction deposit(bytes32 usrmsg) public payable {\r\n\t\trequire(msg.value >= 0.001 ether, \"not enough ether\");\r\n\t\tpyramid(msg.sender, msg.value, usrmsg);\r\n\t}\r\n\t\r\n\tfunction reinvest(uint256 val, bytes32 usrmsg) public {\r\n\t\trequire(val <= balances[msg.sender].ebalance && \r\n\t\t\t\tval > 0.001 ether, \"no funds\");\r\n\t\tbalances[msg.sender].ebalance -= val;\r\n\t\tpyramid(msg.sender, val, usrmsg);\r\n\t}\t\r\n\t\r\n\tfunction mine1000(uint256 blk) public {\r\n\t\trequire(balances[msg.sender].owed[blk].idx < IDX && blk < IDX, \"current block\");\r\n\t\trequire(balances[msg.sender].owed[blk].pending > 0.001 ether, \"no more divs\");\r\n\t\tuint256 cdiv = 0;\r\n\t\tfor(uint256 i = 0; i < 1000; i++) {\r\n\t\t\tcdiv = (balances[msg.sender].owed[blk].pending *\r\n                    blockData[balances[msg.sender].owed[blk].idx].dividend ) / 100 ether; // get %\r\n\t\t\tcdiv = (cdiv > balances[msg.sender].owed[blk].pending)?     \r\n\t\t\t\t\t\tbalances[msg.sender].owed[blk].pending : cdiv;          // check for overflow\r\n\t\t\tbalances[msg.sender].owed[blk].idx += 1;                            // update the index\r\n\t\t\tbalances[msg.sender].owed[blk].pending -= cdiv;\r\n\t\t\tbalances[msg.sender].ebalance += cdiv;\r\n\t\t\tif( balances[msg.sender].owed[blk].pending == 0 || \r\n\t\t\t    balances[msg.sender].owed[blk].idx >= IDX ) \r\n\t\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\r\n    // events ------------------------------------------------------------------\r\n    event event_withdraw(address addr, uint256 val);\r\n    event event_deposit(uint256 val, bytes32 umsg);\r\n    event event_consul(uint256 val, bytes32 umsg);\r\n    event event_divblk(uint256 idx);\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"consul_price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"surplus\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sze\",\"type\":\"uint256\"}],\"name\":\"setBlockSze\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balances\",\"outputs\":[{\"name\":\"ebalance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IDX\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blksze\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"val\",\"type\":\"uint256\"},{\"name\":\"usrmsg\",\"type\":\"bytes32\"}],\"name\":\"reinvest\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addSurplus\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"standard\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"callSurplus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blk\",\"type\":\"uint256\"}],\"name\":\"owedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"blockData\",\"outputs\":[{\"name\":\"outstanding\",\"type\":\"uint256\"},{\"name\":\"dividend\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"consul\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"usrmsg\",\"type\":\"bytes32\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"consul_nme\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"blk\",\"type\":\"uint256\"}],\"name\":\"mine1000\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"}],\"name\":\"event_withdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"umsg\",\"type\":\"bytes32\"}],\"name\":\"event_deposit\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"val\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"umsg\",\"type\":\"bytes32\"}],\"name\":\"event_consul\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"event_divblk\",\"type\":\"event\"}]","ContractName":"pyramidMKII","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ea618a675910796cf67abc40659b68bd6fc923619ec393110660785a7651cd2d"}]}