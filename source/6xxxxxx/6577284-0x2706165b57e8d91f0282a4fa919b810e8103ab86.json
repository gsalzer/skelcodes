{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) internal balances;\r\n\r\n  uint256 internal totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_value <= balances[msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n    require(_to != address(0));\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue >= oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Mintable token\r\n * @dev Simple ERC20 Token example, with mintable token creation\r\n * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol\r\n */\r\ncontract MintableToken is StandardToken, Ownable {\r\n  event Mint(address indexed to, uint256 amount);\r\n  event MintFinished();\r\n\r\n  bool public mintingFinished = false;\r\n\r\n\r\n  modifier canMint() {\r\n    require(!mintingFinished);\r\n    _;\r\n  }\r\n\r\n  modifier hasMintPermission() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to mint tokens\r\n   * @param _to The address that will receive the minted tokens.\r\n   * @param _amount The amount of tokens to mint.\r\n   * @return A boolean that indicates if the operation was successful.\r\n   */\r\n  function mint(\r\n    address _to,\r\n    uint256 _amount\r\n  )\r\n    public\r\n    hasMintPermission\r\n    canMint\r\n    returns (bool)\r\n  {\r\n    totalSupply_ = totalSupply_.add(_amount);\r\n    balances[_to] = balances[_to].add(_amount);\r\n    emit Mint(_to, _amount);\r\n    emit Transfer(address(0), _to, _amount);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to stop minting new tokens.\r\n   * @return True if the operation was successful.\r\n   */\r\n  function finishMinting() public onlyOwner canMint returns (bool) {\r\n    mintingFinished = true;\r\n    emit MintFinished();\r\n    return true;\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title MintAndBurnToken\r\n *\r\n * @dev StandardToken that is mintable and burnable\r\n */\r\ncontract MintAndBurnToken is MintableToken {\r\n\r\n  // -----------------------------------\r\n  // BURN FUNCTIONS\r\n  // https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/BurnableToken.sol\r\n  // -----------------------------------\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who], \"must have balance greater than burn value\");\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\n\r\n/**\r\n * @title BabyloniaToken\r\n */\r\ncontract BabyloniaToken is MintAndBurnToken {\r\n\r\n  // DetailedERC20 variables\r\n  string public name = \"Babylonia Token\";\r\n  string public symbol = \"BBY\";\r\n  uint8 public decimals = 18;\r\n}\r\n\r\n/**\r\n * @title EthPriceOracleI\r\n * @dev Interface for interacting with MakerDAO's on-chain price oracle\r\n */\r\ncontract EthPriceOracleI {\r\n    function compute() public view returns (bytes32, bool);\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyOwner whenNotPaused {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyOwner whenPaused {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Babylon\r\n *\r\n * @dev This contract manages the exchange of Helbiz tokens for Babylonia tokens, with a locking period\r\n * in place before tokens can be claimed\r\n */\r\ncontract Babylon is Pausable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for BabyloniaToken;\r\n\r\n  event TokenExchangeCreated(address indexed recipient, uint amount, uint releasedAt);\r\n  event TokenExchangeReleased(address indexed recipient);\r\n\r\n  BabyloniaToken private babyloniaToken;\r\n  StandardToken private helbizToken;\r\n  EthPriceOracleI private ethPriceOracle;\r\n\r\n  uint public INITIAL_CIRCULATION_BBY = 80000000; // the amount of BBY tokens available for the token swap\r\n  uint public MIN_EXCHANGE_BBY = SafeMath.mul(1000, 10**18); // minimum amount of BBY tokens for an exchange\r\n\r\n  uint public exchangeRate;          // HBZ tokens we receive per BBY\r\n  uint8 public usdCentsExchangeRate; // USD cents we receive per BBY\r\n  uint32 public exchangeLockTime;    // time (seconds) after an exchange before the sender can claim their BBY tokens\r\n  uint public babyloniaTokensLocked; // the amount of BBY tokens locked for exchange\r\n  bool public ethExchangeEnabled;    // whether we are accepting ETH for BBY\r\n\r\n  struct TokenExchange {\r\n    address recipient; // the address to receive BBY in exchange for HBZ\r\n    uint amountHBZ;    // amount in HBZ\r\n    uint amountBBY;    // amount in BBY\r\n    uint amountWei;    // amount in Wei\r\n    uint createdAt;    // datetime created\r\n    uint releasedAt;   // datetime when BBY can be redeemed\r\n  }\r\n\r\n  mapping(address => uint) private activeTokenExchanges;\r\n  TokenExchange[] private tokenExchanges;\r\n\r\n  modifier activeTokenExchange() {\r\n    require(activeTokenExchanges[msg.sender] != 0, \"must be an active token exchange\");\r\n    _;\r\n  }\r\n\r\n  modifier noActiveTokenExchange() {\r\n    require(activeTokenExchanges[msg.sender] == 0, \"must not have an active token exchange\");\r\n    _;\r\n  }\r\n\r\n  modifier whenEthEnabled() {\r\n    require(ethExchangeEnabled);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Contract constructor\r\n   * Instantiates instance of HelbizCoin (HBZ) and BabyloniaToken (BBY) contracts\r\n   * Sets the cap for the total circulation\r\n   * Mints 50% of the cap for this contract\r\n   * @param _helbizCoinAddress Address of deployed HelbizCoin contract\r\n   * @param _babyloniaTokenAddress Address of deployed BabyloniaToken contract\r\n   * @param _ethPriceOracleAddress Address of deployed EthPriceOracle contract\r\n   * @param _exchangeRate x HBZ => 1 BBY rate\r\n   * @param _exchangeLockTime Number of seconds the exchanged BBY tokens are locked up for\r\n   */\r\n  constructor(\r\n    address _helbizCoinAddress,\r\n    address _babyloniaTokenAddress,\r\n    address _ethPriceOracleAddress,\r\n    uint8 _exchangeRate,\r\n    uint8 _usdCentsExchangeRate,\r\n    uint32 _exchangeLockTime\r\n  ) public {\r\n    helbizToken = StandardToken(_helbizCoinAddress);\r\n    babyloniaToken = BabyloniaToken(_babyloniaTokenAddress);\r\n    ethPriceOracle = EthPriceOracleI(_ethPriceOracleAddress);\r\n    exchangeRate = _exchangeRate;\r\n    usdCentsExchangeRate = _usdCentsExchangeRate;\r\n    exchangeLockTime = _exchangeLockTime;\r\n    paused = true;\r\n\r\n    // take care of zero-index for storage array\r\n    tokenExchanges.push(TokenExchange({\r\n      recipient: address(0),\r\n      amountHBZ: 0,\r\n      amountBBY: 0,\r\n      amountWei: 0,\r\n      createdAt: 0,\r\n      releasedAt: 0\r\n    }));\r\n  }\r\n\r\n  /**\r\n   * Do not accept ETH\r\n   */\r\n  function() public payable {\r\n    require(msg.value == 0, \"not accepting ETH\");\r\n  }\r\n\r\n  /**\r\n   * Transfers all of this contract's owned HBZ to the given address\r\n   * @param _to The address to transfer this contract's HBZ to\r\n   */\r\n  function withdrawHBZ(address _to) external onlyOwner {\r\n    require(_to != address(0), \"invalid _to address\");\r\n    require(helbizToken.transfer(_to, helbizToken.balanceOf(address(this))));\r\n  }\r\n\r\n  /**\r\n   * Transfers all of this contract's ETH to the given address\r\n   * @param _to The address to transfer all this contract's ETH to\r\n   */\r\n  function withdrawETH(address _to) external onlyOwner {\r\n    require(_to != address(0), \"invalid _to address\");\r\n    _to.transfer(address(this).balance);\r\n  }\r\n\r\n  /**\r\n   * Transfers all of this contract's BBY MINUS locked tokens to the given address\r\n   * @param _to The address to transfer BBY to\r\n   * @param _amountBBY The amount of BBY to transfer\r\n   */\r\n  function withdrawBBY(address _to, uint _amountBBY) external onlyOwner {\r\n    require(_to != address(0), \"invalid _to address\");\r\n    require(_amountBBY > 0, \"_amountBBY must be greater than 0\");\r\n    require(babyloniaToken.transfer(_to, _amountBBY));\r\n  }\r\n\r\n  /**\r\n   * Burns the remainder of BBY owned by this contract MINUS locked tokens\r\n   */\r\n  function burnRemainderBBY() public onlyOwner {\r\n    uint amountBBY = SafeMath.sub(babyloniaToken.balanceOf(address(this)), babyloniaTokensLocked);\r\n    babyloniaToken.burn(amountBBY);\r\n  }\r\n\r\n  /**\r\n   * Sets a new exchange rate\r\n   * @param _newRate 1 BBY => _newRate\r\n   */\r\n  function setExchangeRate(uint8 _newRate) external onlyOwner {\r\n    require(_newRate > 0, \"new rate must not be 0\");\r\n    exchangeRate = _newRate;\r\n  }\r\n\r\n  /**\r\n   * Sets the exchange rate in USD cents (for ETH payments)\r\n   * @param _newRate 1 BBY => _newRate\r\n   */\r\n  function setUSDCentsExchangeRate(uint8 _newRate) external onlyOwner {\r\n    require(_newRate > 0, \"new rate must not be 0\");\r\n    usdCentsExchangeRate = _newRate;\r\n  }\r\n\r\n  /**\r\n   * Sets a new exchange lock time\r\n   * @param _newLockTime Number of seconds the exchanged BBY tokens are locked up for\r\n   */\r\n  function setExchangeLockTime(uint32 _newLockTime) external onlyOwner {\r\n    require(_newLockTime > 0, \"new lock time must not be 0\");\r\n    exchangeLockTime = _newLockTime;\r\n  }\r\n\r\n  /**\r\n   * Sets whether we are accepting ETH for the exchange\r\n   * @param _enabled Is ETH enabled\r\n   */\r\n  function setEthExchangeEnabled(bool _enabled) external onlyOwner {\r\n    ethExchangeEnabled = _enabled;\r\n  }\r\n\r\n  /**\r\n   * Return the address of the BabyloniaToken contract\r\n   */\r\n  function getTokenAddress() public view returns(address) {\r\n    return address(babyloniaToken);\r\n  }\r\n\r\n  /**\r\n   * Transfers HBZ from the sender equal to _amountHBZ to this contract and creates a record for TokenExchange\r\n   * NOTE: the address must have already approved the transfer with hbzToken.approve()\r\n   * @param _amountHBZ Amount of HBZ tokens\r\n   */\r\n  function exchangeTokens(uint _amountHBZ) public whenNotPaused noActiveTokenExchange {\r\n    // sanity check\r\n    require(_amountHBZ >= MIN_EXCHANGE_BBY, \"_amountHBZ must be greater than or equal to MIN_EXCHANGE_BBY\");\r\n\r\n    // the contract must have enough tokens - considering the locked ones\r\n    uint amountBBY = SafeMath.div(_amountHBZ, exchangeRate);\r\n    uint contractBalanceBBY = babyloniaToken.balanceOf(address(this));\r\n    require(SafeMath.sub(contractBalanceBBY, babyloniaTokensLocked) >= amountBBY, \"contract has insufficient BBY\");\r\n\r\n    // transfer the HBZ tokens to this contract\r\n    require(helbizToken.transferFrom(msg.sender, address(this), _amountHBZ));\r\n\r\n    _createExchangeRecord(_amountHBZ, amountBBY, 0);\r\n  }\r\n\r\n  /**\r\n   * Accepts ETH in exchange for BBY tokens and creates a record for TokenExchange\r\n   * NOTE: this function can only be called when the contract is paused, preventing sales in ETH during the token swap\r\n   * @param _amountBBY Amount of BBY tokens\r\n   */\r\n  function exchangeEth(uint _amountBBY) public whenNotPaused whenEthEnabled noActiveTokenExchange payable {\r\n    // sanity check\r\n    require(_amountBBY > 0, \"_amountBBY must be greater than 0\");\r\n\r\n    bytes32 val;\r\n    (val,) = ethPriceOracle.compute();\r\n    // divide to get the number of cents in 1 ETH\r\n    uint256 usdCentsPerETH = SafeMath.div(uint256(val), 10**16);\r\n\r\n    // calculate the price of BBY in Wei\r\n    uint256 priceInWeiPerBBY = SafeMath.div(10**18, SafeMath.div(usdCentsPerETH, usdCentsExchangeRate));\r\n\r\n    // total cost in Wei for _amountBBY\r\n    uint256 totalPriceInWei = SafeMath.mul(priceInWeiPerBBY, _amountBBY);\r\n\r\n    // ensure the user sent enough funds and that we have enough BBY\r\n    require(msg.value >= totalPriceInWei, \"Insufficient ETH value\");\r\n    require(SafeMath.sub(babyloniaToken.balanceOf(address(this)), babyloniaTokensLocked) >= _amountBBY, \"contract has insufficient BBY\");\r\n\r\n    // refund any overpayment\r\n    if (msg.value > totalPriceInWei) msg.sender.transfer(msg.value - totalPriceInWei);\r\n\r\n    _createExchangeRecord(0, _amountBBY, totalPriceInWei);\r\n  }\r\n\r\n  /**\r\n   * Transfers BBY tokens to the sender\r\n   */\r\n  function claimTokens() public whenNotPaused activeTokenExchange {\r\n    TokenExchange storage tokenExchange = tokenExchanges[activeTokenExchanges[msg.sender]];\r\n    uint amountBBY = tokenExchange.amountBBY;\r\n\r\n    // assert that we're past the lock period\r\n    /* solium-disable-next-line security/no-block-members */\r\n    require(block.timestamp >= tokenExchange.releasedAt, \"not past locking period\");\r\n\r\n    // decrease the counter\r\n    babyloniaTokensLocked = SafeMath.sub(babyloniaTokensLocked, tokenExchange.amountBBY);\r\n\r\n    // delete from storage and lookup\r\n    delete tokenExchanges[activeTokenExchanges[msg.sender]];\r\n    delete activeTokenExchanges[msg.sender];\r\n\r\n    // transfer BBY tokens to the sender\r\n    babyloniaToken.safeTransfer(msg.sender, amountBBY);\r\n\r\n    emit TokenExchangeReleased(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Return the id of the owned active token exchange\r\n   */\r\n  function getActiveTokenExchangeId() public view activeTokenExchange returns(uint) {\r\n    return activeTokenExchanges[msg.sender];\r\n  }\r\n\r\n  /**\r\n   * Returns a token exchange with the given id\r\n   * @param _id the id of the record to retrieve (optional)\r\n   */\r\n  function getActiveTokenExchangeById(uint _id)\r\n    public\r\n    view\r\n    returns(\r\n      address recipient,\r\n      uint amountHBZ,\r\n      uint amountBBY,\r\n      uint amountWei,\r\n      uint createdAt,\r\n      uint releasedAt\r\n    )\r\n  {\r\n    // sanity check\r\n    require(tokenExchanges[_id].recipient != address(0));\r\n\r\n    TokenExchange storage tokenExchange = tokenExchanges[_id];\r\n\r\n    recipient = tokenExchange.recipient;\r\n    amountHBZ = tokenExchange.amountHBZ;\r\n    amountBBY = tokenExchange.amountBBY;\r\n    amountWei = tokenExchange.amountWei;\r\n    createdAt = tokenExchange.createdAt;\r\n    releasedAt = tokenExchange.releasedAt;\r\n  }\r\n\r\n  /**\r\n   * Returns the number of token exchanges in the storage array\r\n   * NOTE: the length will be inaccurate as we are deleting array elements, leaving gaps\r\n   */\r\n  function getTokenExchangesCount() public view onlyOwner returns(uint) {\r\n    return tokenExchanges.length;\r\n  }\r\n\r\n  /**\r\n   * Creates a record for the token exchange\r\n   * @param _amountHBZ The amount of HBZ tokens\r\n   * @param _amountBBY The amount of BBY tokens\r\n   * @param _amountWei The amount of Wei (optional - in place of _amountHBZ)\r\n   */\r\n  function _createExchangeRecord(uint _amountHBZ, uint _amountBBY, uint _amountWei) internal {\r\n    /* solium-disable-next-line security/no-block-members */\r\n    uint releasedAt = SafeMath.add(block.timestamp, exchangeLockTime);\r\n    TokenExchange memory tokenExchange = TokenExchange({\r\n      recipient: msg.sender,\r\n      amountHBZ: _amountHBZ,\r\n      amountBBY: _amountBBY,\r\n      amountWei: _amountWei,\r\n      createdAt: block.timestamp, // solium-disable-line security/no-block-members, whitespace\r\n      releasedAt: releasedAt\r\n    });\r\n    // add to storage and lookup\r\n    activeTokenExchanges[msg.sender] = tokenExchanges.push(tokenExchange) - 1;\r\n\r\n    // increase the counter\r\n    babyloniaTokensLocked = SafeMath.add(babyloniaTokensLocked, _amountBBY);\r\n\r\n    emit TokenExchangeCreated(msg.sender, _amountHBZ, releasedAt);\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint8\"}],\"name\":\"setUSDCentsExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"babyloniaTokensLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRate\",\"type\":\"uint8\"}],\"name\":\"setExchangeRate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountHBZ\",\"type\":\"uint256\"}],\"name\":\"exchangeTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getActiveTokenExchangeId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_id\",\"type\":\"uint256\"}],\"name\":\"getActiveTokenExchangeById\",\"outputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"amountHBZ\",\"type\":\"uint256\"},{\"name\":\"amountBBY\",\"type\":\"uint256\"},{\"name\":\"amountWei\",\"type\":\"uint256\"},{\"name\":\"createdAt\",\"type\":\"uint256\"},{\"name\":\"releasedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawHBZ\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"withdrawETH\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newLockTime\",\"type\":\"uint32\"}],\"name\":\"setExchangeLockTime\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"INITIAL_CIRCULATION_BBY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"burnRemainderBBY\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethExchangeEnabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_enabled\",\"type\":\"bool\"}],\"name\":\"setEthExchangeEnabled\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amountBBY\",\"type\":\"uint256\"}],\"name\":\"exchangeEth\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"exchangeLockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amountBBY\",\"type\":\"uint256\"}],\"name\":\"withdrawBBY\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenExchangesCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MIN_EXCHANGE_BBY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"usdCentsExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_helbizCoinAddress\",\"type\":\"address\"},{\"name\":\"_babyloniaTokenAddress\",\"type\":\"address\"},{\"name\":\"_ethPriceOracleAddress\",\"type\":\"address\"},{\"name\":\"_exchangeRate\",\"type\":\"uint8\"},{\"name\":\"_usdCentsExchangeRate\",\"type\":\"uint8\"},{\"name\":\"_exchangeLockTime\",\"type\":\"uint32\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"releasedAt\",\"type\":\"uint256\"}],\"name\":\"TokenExchangeCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"recipient\",\"type\":\"address\"}],\"name\":\"TokenExchangeReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Babylon","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000e34e1944e776f39b9252790a0527ebda647ae6680000000000000000000000004f8a05b6163f2fdbd4ef1555b8ac1ad845d56ff5000000000000000000000000724dd897afa7ae9634a0569b9e2f78143fea68e30000000000000000000000000000000000000000000000000000000000000008000000000000000000000000000000000000000000000000000000000000007800000000000000000000000000000000000000000000000000000000003b5380","Library":"","SwarmSource":"bzzr://9c57525e0434e35b11f2bd5d9d6f61262fa9d6f7e19ef019149feb5a3b087130"}]}