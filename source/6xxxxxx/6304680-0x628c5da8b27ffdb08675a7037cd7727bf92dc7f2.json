{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.20;\r\n\r\n// File: contracts/ERC20Token.sol\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal  pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure  returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract Owned {\r\n\r\n    address public owner;\r\n    address newOwner;\r\n\r\n    modifier only(address _allowed) {\r\n        require(msg.sender == _allowed);\r\n        _;\r\n    }\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) only(owner) public {\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() only(newOwner) public {\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n    event OwnershipTransferred(address indexed _from, address indexed _to);\r\n\r\n}\r\n\r\ncontract ERC20 is Owned {\r\n    using SafeMath for uint;\r\n\r\n    uint public totalSupply;\r\n    bool public isStarted = false;\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n\r\n    modifier isStartedOnly() {\r\n        require(isStarted);\r\n        _;\r\n    }\r\n\r\n    modifier isNotStartedOnly() {\r\n        require(!isStarted);\r\n        _;\r\n    }\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    function transfer(address _to, uint _value) isStartedOnly public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) isStartedOnly public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve_fixed(address _spender, uint _currentValue, uint _value) isStartedOnly public returns (bool success) {\r\n        if(allowed[msg.sender][_spender] == _currentValue){\r\n            allowed[msg.sender][_spender] = _value;\r\n            emit Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint _value) isStartedOnly public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n}\r\n\r\ncontract Token is ERC20 {\r\n    using SafeMath for uint;\r\n\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n\r\n    constructor(string _name, string _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function start() public only(owner) isNotStartedOnly {\r\n        isStarted = true;\r\n    }\r\n\r\n    //================= Crowdsale Only =================\r\n    function mint(address _to, uint _amount) public only(owner) isNotStartedOnly returns(bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function multimint(address[] dests, uint[] values) public only(owner) isNotStartedOnly returns (uint) {\r\n        uint i = 0;\r\n        while (i < dests.length) {\r\n           mint(dests[i], values[i]);\r\n           i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n}\r\n\r\ncontract TokenWithoutStart is Owned {\r\n    using SafeMath for uint;\r\n\r\n    mapping (address => uint) balances;\r\n    mapping (address => mapping (address => uint)) allowed;\r\n    string public name;\r\n    string public symbol;\r\n    uint8 public decimals;\r\n    uint public totalSupply;\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint _value);\r\n\r\n    constructor(string _name, string _symbol, uint8 _decimals) public {\r\n        name = _name;\r\n        symbol = _symbol;\r\n        decimals = _decimals;\r\n    }\r\n\r\n    function transfer(address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer(msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        require(_to != address(0));\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    function balanceOf(address _owner) public view returns (uint balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n    function approve_fixed(address _spender, uint _currentValue, uint _value) public returns (bool success) {\r\n        if(allowed[msg.sender][_spender] == _currentValue){\r\n            allowed[msg.sender][_spender] = _value;\r\n            emit Approval(msg.sender, _spender, _value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    function allowance(address _owner, address _spender) public view returns (uint remaining) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    function mint(address _to, uint _amount) public only(owner) returns(bool) {\r\n        totalSupply = totalSupply.add(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        return true;\r\n    }\r\n\r\n    function multimint(address[] dests, uint[] values) public only(owner) returns (uint) {\r\n        uint i = 0;\r\n        while (i < dests.length) {\r\n           mint(dests[i], values[i]);\r\n           i += 1;\r\n        }\r\n        return(i);\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/ArchXArch2.sol\r\n\r\n// DEPLOYED BY JURY.ONLINE\r\ncontract ICOContractX {\r\n    // GENERAL ICO PARAMS ------------------------------------------------------\r\n\r\n    string public name;\r\n\r\n    address public operator; // the ICO operator\r\n    address public projectWallet; // the wallet that receives ICO Funds\r\n    Token public token; // ICO token\r\n    address public juryOnlineWallet; // JuryOnline Wallet for commission\r\n    address public arbitrationAddress; // Address of Arbitration Contract\r\n    uint public currentCycle; // current cycle\r\n\r\n    struct Cycle {\r\n        bool exists;\r\n        bool approved;\r\n        address icoRoundAddress;\r\n    }\r\n\r\n    mapping(uint => Cycle) public cycles; // stores the approved Cycles\r\n\r\n    // DEPLOYED BY JURY.ONLINE\r\n    // PARAMS:\r\n    // address _operator\r\n    // address _projectWallet\r\n    // address _tokenAddress\r\n    // address _arbitrationAddress\r\n    // address _juryOnlineWallet\r\n    constructor(string _name, address _operator, address _projectWallet, address _tokenAddress, address _arbitrationAddress, address _juryOnlineWallet) public {\r\n        name = _name;\r\n        operator = _operator;\r\n        projectWallet = _projectWallet;\r\n        token = Token(_tokenAddress);\r\n        arbitrationAddress = _arbitrationAddress;\r\n        juryOnlineWallet = _juryOnlineWallet;\r\n    }\r\n\r\n    // CALLED BY CYCLE CONTRACT\r\n    function addRound() public {\r\n        cycles[currentCycle].exists = true;\r\n        cycles[currentCycle].icoRoundAddress = msg.sender;\r\n    }\r\n\r\n    // CALLED BY ICO OPERATOR, approves CYCLE Contract and adds it to cycles\r\n    function approveRound(address _icoRoundAddress) public {\r\n        require(msg.sender == operator);\r\n        require(cycles[currentCycle].icoRoundAddress == _icoRoundAddress);\r\n        currentCycle +=1;\r\n    }\r\n\r\n}\r\n// DEPLOYED BY JURY.ONLINE\r\ncontract ICOCycle {\r\n\r\n    using SafeMath for uint;\r\n\r\n    // GENERAL CYCLE VARIABLES -------------------------------------------------\r\n\r\n    address public juryOperator; // assists in operation\r\n    address public operator; // cycle operator, same as ICO operator\r\n    address public icoAddress; // to associate Cycle with ICO\r\n    address public juryOnlineWallet; // juryOnlineWallet for commission\r\n    address public projectWallet; // taken from ICO contract\r\n    address public arbitrationAddress; // taken from ICO contract\r\n    Token public token; // taken from ICO contract\r\n\r\n    address public swapper; // address for JOT commission\r\n\r\n    bool public saveMe; // if true, gives Jury.Online control of contract\r\n\r\n    struct Milestone {\r\n        uint etherAmount; //how many Ether is needed for this milestone\r\n        uint tokenAmount; //how many tokens releases this milestone\r\n        uint startTime; //real time when milestone has started, set upon start\r\n        uint finishTime; //real time when milestone has finished, set upon finish\r\n        uint duration; //assumed duration for milestone implementation, set upon milestone creation\r\n        string description;\r\n        string result;\r\n    }\r\n\r\n    Milestone[] public milestones; // List of Milestones\r\n    uint public currentMilestone;\r\n\r\n    uint public sealTimestamp; // the moment the Cycle is Sealed by operator\r\n\r\n    uint public ethForMilestone; // Amount to be withdraw by operator for each milestone\r\n    uint public postDisputeEth; // in case of dispute in favor of ico project\r\n\r\n    // INVESTOR struct stores information about each Investor\r\n    // Investor can have more than one deals, but only one right to dispute\r\n    struct Investor {\r\n        bool disputing;\r\n        uint tokenAllowance;\r\n        uint etherUsed;\r\n        uint sumEther;\r\n        uint sumToken;\r\n        bool verdictForProject;\r\n        bool verdictForInvestor;\r\n        uint numberOfDeals;\r\n    }\r\n\r\n    struct Deal {\r\n        address investor;\r\n        uint etherAmount;\r\n        uint tokenAmount;\r\n        bool accepted;\r\n    }\r\n\r\n    mapping(address => Investor) public deals; // map of information of investors with deals\r\n    address[] public dealsList; // list of investors with deals\r\n    mapping(address => mapping(uint => Deal)) public offers; // pending offers\r\n\r\n    // COMMISSION ARRAYS\r\n    // amounts stores as percentage\r\n    // If length == 1, commission paid when investment is accepted\r\n    // If length > 1, each element is commission to corresponding milestone\r\n    // ETH commission is transferred to Jury.Online wallet\r\n    // JOT commission is transferred to a Swapper contract that swaps eth for jot\r\n    uint[] public commissionEth;\r\n    uint[] public commissionJot;\r\n    uint public etherAllowance; // Amount that Jury.Online can withdraw as commission in ETH\r\n    uint public jotAllowance; // Amount that Jury.Online can withdraw as commission in JOT\r\n\r\n    uint public totalEther; // Sum of ether in milestones\r\n    uint public totalToken; // Sum of tokens in milestones\r\n\r\n    uint public promisedTokens; // Sum of tokens promised by accepting offer\r\n    uint public raisedEther; // Sum of ether raised by accepting offer\r\n\r\n    uint public rate; // eth to token rate in current Funding Round\r\n    bool public tokenReleaseAtStart; // whether to release tokens at start or by each milestone\r\n    uint public currentFundingRound;\r\n\r\n    bool public roundFailedToStart;\r\n\r\n    // Stores amount of ether and tokens per milestone for each investor\r\n    mapping(address => uint[]) public etherPartition;\r\n    mapping(address => uint[]) public tokenPartition;\r\n\r\n    // Funding Rounds can be added with start, end time, rate, and whitelist\r\n    struct FundingRound {\r\n        uint startTime;\r\n        uint endTime;\r\n        uint rate;\r\n        bool hasWhitelist;\r\n    }\r\n\r\n    FundingRound[] public roundPrices;  // stores list of funding rounds\r\n    mapping(uint => mapping(address => bool)) public whitelist; // stores whitelists\r\n\r\n    // -------------------------------------------------------------------------\r\n    // MODIFIERS\r\n    modifier onlyOperator() {\r\n        require(msg.sender == operator || msg.sender == juryOperator);\r\n        _;\r\n    }\r\n\r\n    modifier onlyAdmin() {\r\n        require(msg.sender == operator || msg.sender == juryOperator);\r\n        _;\r\n    }\r\n\r\n    modifier sealed() {\r\n        require(sealTimestamp != 0);\r\n        /* require(now > sealTimestamp); */\r\n        _;\r\n    }\r\n\r\n    modifier notSealed() {\r\n        require(sealTimestamp == 0);\r\n        /* require(now <= sealTimestamp); */\r\n        _;\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    // DEPLOYED BY JURY.ONLINE\r\n    // PARAMS:\r\n    // address _icoAddress\r\n    // address _operator\r\n    // uint _rate\r\n    // address _swapper\r\n    // uint[] _commissionEth\r\n    // uint[] _commissionJot\r\n    constructor( address _icoAddress, address _operator, uint _rate, address _swapper, uint[] _commissionEth, uint[] _commissionJot) public {\r\n        require(_commissionEth.length == _commissionJot.length);\r\n        juryOperator = msg.sender;\r\n        icoAddress = _icoAddress;\r\n        operator = _operator;\r\n        rate = _rate;\r\n        swapper = _swapper;\r\n        commissionEth = _commissionEth;\r\n        commissionJot = _commissionJot;\r\n        roundPrices.push(FundingRound(0,0,0,false));\r\n        tokenReleaseAtStart = true;\r\n    }\r\n\r\n    // CALLED BY JURY.ONLINE TO SET SWAPPER ADDRESS FOR JOT COMMISSION\r\n    function setSwapper(address _swapper) public {\r\n        require(msg.sender == juryOperator);\r\n        swapper = _swapper;\r\n    }\r\n\r\n    // CALLED BY ADMIN TO RETRIEVE INFORMATION FROM ICOADDRESS AND ADD ITSELF\r\n    // TO LIST OF CYCLES IN ICO\r\n    function activate() onlyAdmin notSealed public {\r\n        ICOContractX icoContract = ICOContractX(icoAddress);\r\n        require(icoContract.operator() == operator);\r\n        juryOnlineWallet = icoContract.juryOnlineWallet();\r\n        projectWallet = icoContract.projectWallet();\r\n        arbitrationAddress = icoContract.arbitrationAddress();\r\n        token = icoContract.token();\r\n        icoContract.addRound();\r\n    }\r\n\r\n    // CALLED BY JURY.ONLINE TO RETRIEVE COMMISSION\r\n    // CALLED BY ICO OPERATOR TO RETRIEVE FUNDS\r\n    // CALLED BY INVESTOR TO RETRIEVE FUNDS AFTER DISPUTE\r\n    function withdrawEther() public {\r\n        if (roundFailedToStart == true) {\r\n            require(msg.sender.send(deals[msg.sender].sumEther));\r\n        }\r\n        if (msg.sender == operator) {\r\n            require(projectWallet.send(ethForMilestone+postDisputeEth));\r\n            ethForMilestone = 0;\r\n            postDisputeEth = 0;\r\n        }\r\n        if (msg.sender == juryOnlineWallet) {\r\n            require(juryOnlineWallet.send(etherAllowance));\r\n            require(swapper.call.value(jotAllowance)(abi.encodeWithSignature(\"swapMe()\")));\r\n            etherAllowance = 0;\r\n            jotAllowance = 0;\r\n        }\r\n        if (deals[msg.sender].verdictForInvestor == true) {\r\n            require(msg.sender.send(deals[msg.sender].sumEther - deals[msg.sender].etherUsed));\r\n        }\r\n    }\r\n\r\n    // CALLED BY INVESTOR TO RETRIEVE TOKENS\r\n    function withdrawToken() public {\r\n        require(token.transfer(msg.sender,deals[msg.sender].tokenAllowance));\r\n        deals[msg.sender].tokenAllowance = 0;\r\n    }\r\n\r\n    // CALLED BY ICO OPERATOR TO ADD FUNDING ROUNDS WITH _startTime,_endTime,_price,_whitelist\r\n    function addRoundPrice(uint _startTime,uint _endTime, uint _price, address[] _whitelist) public onlyOperator {\r\n        if (_whitelist.length == 0) {\r\n            roundPrices.push(FundingRound(_startTime, _endTime,_price,false));\r\n        } else {\r\n            for (uint i=0 ; i < _whitelist.length ; i++ ) {\r\n                whitelist[roundPrices.length][_whitelist[i]] = true;\r\n            }\r\n            roundPrices.push(FundingRound(_startTime, _endTime,_price,true));\r\n        }\r\n    }\r\n\r\n    // CALLED BY ICO OPERATOR TO SET RATE WITHOUT SETTING FUNDING ROUND\r\n    function setRate(uint _rate) onlyOperator public {\r\n        rate = _rate;\r\n    }\r\n\r\n    // CALLED BY ICO OPERATOR TO APPLY WHITELIST AND PRICE OF FUNDING ROUND\r\n    function setCurrentFundingRound(uint _fundingRound) public onlyOperator {\r\n        require(roundPrices.length > _fundingRound);\r\n        currentFundingRound = _fundingRound;\r\n    }\r\n\r\n    // RECEIVES FUNDS AND CREATES OFFER\r\n    function () public payable {\r\n        require(msg.value > 0);\r\n        if (roundPrices[currentFundingRound].hasWhitelist == true) {\r\n            require(whitelist[currentFundingRound][msg.sender] == true);\r\n        }\r\n        uint dealNumber = deals[msg.sender].numberOfDeals;\r\n        offers[msg.sender][dealNumber].investor = msg.sender;\r\n        offers[msg.sender][dealNumber].etherAmount = msg.value;\r\n        deals[msg.sender].numberOfDeals += 1;\r\n    }\r\n\r\n    // CALCULATES AMOUNT OF TOKENS FOR GIVEN ETH\r\n    function calculateTokens(uint256 _weiAmount) constant public returns (uint256) {\r\n\r\n        uint256 tokens = _weiAmount.mul(rate).mul(100).div(75).div(100 finney);\r\n        if(tokens.div(100000000) < 5000)\r\n            return _weiAmount.mul(rate).mul(100).div(80).div(100 finney);\r\n\r\n        tokens = _weiAmount.mul(rate).mul(100).div(73).div(100 finney);\r\n        if(tokens.div(100000000) < 25000)\r\n            return _weiAmount.mul(rate).mul(100).div(75).div(100 finney);\r\n\r\n        tokens = _weiAmount.mul(rate).mul(100).div(70).div(100 finney);\r\n        if(tokens.div(100000000) < 50000)\r\n            return _weiAmount.mul(rate).mul(100).div(73).div(100 finney);\r\n\r\n        tokens = _weiAmount.mul(rate).mul(100).div(65).div(100 finney);\r\n        if(tokens.div(100000000) < 250000)\r\n            return _weiAmount.mul(rate).mul(100).div(70).div(100 finney);\r\n\r\n        tokens = _weiAmount.mul(rate).mul(100).div(60).div(100 finney);\r\n        if(tokens.div(100000000) < 500000)\r\n            return _weiAmount.mul(rate).mul(100).div(65).div(100 finney);\r\n\r\n        return _weiAmount.mul(rate).mul(100).div(60).div(100 finney);\r\n    }\r\n\r\n    // IF OFFER NOT ACCEPTED, CAN BE WITHDRAWN\r\n    function withdrawOffer(uint _offerNumber) public {\r\n        require(offers[msg.sender][_offerNumber].accepted == false);\r\n        require(msg.sender.send(offers[msg.sender][_offerNumber].etherAmount));\r\n        offers[msg.sender][_offerNumber].etherAmount = 0;\r\n        /* offers[msg.sender][_offerNumber].tokenAmount = 0; */\r\n    }\r\n\r\n    // ARBITRATION\r\n    // CALLED BY ARBITRATION ADDRESS\r\n    function disputeOpened(address _investor) public {\r\n        require(msg.sender == arbitrationAddress);\r\n        deals[_investor].disputing = true;\r\n    }\r\n\r\n    // CALLED BY ARBITRATION ADDRESS\r\n    function verdictExecuted(address _investor, bool _verdictForInvestor,uint _milestoneDispute) public {\r\n        require(msg.sender == arbitrationAddress);\r\n        require(deals[_investor].disputing == true);\r\n        if (_verdictForInvestor) {\r\n            deals[_investor].verdictForInvestor = true;\r\n        } else {\r\n            deals[_investor].verdictForProject = true;\r\n            for (uint i = _milestoneDispute; i < currentMilestone; i++) {\r\n                postDisputeEth += etherPartition[_investor][i];\r\n                deals[_investor].etherUsed += etherPartition[_investor][i];\r\n            }\r\n        }\r\n        deals[_investor].disputing = false;\r\n    }\r\n\r\n    // OPERATOR\r\n    // TO ADD MILESTONES\r\n    function addMilestone(uint _etherAmount, uint _tokenAmount, uint _startTime, uint _duration, string _description) public notSealed onlyOperator returns(uint) {\r\n        totalEther = totalEther.add(_etherAmount);\r\n        totalToken = totalToken.add(_tokenAmount);\r\n        return milestones.push(Milestone(_etherAmount, _tokenAmount, _startTime, 0, _duration, _description, \"\"));\r\n    }\r\n\r\n    // TO SEAL\r\n    function seal() public notSealed onlyOperator {\r\n        require(milestones.length > 0);\r\n        require(token.balanceOf(address(this)) >= totalToken);\r\n        sealTimestamp = now;\r\n    }\r\n\r\n    // TO ACCEPT OFFER\r\n    function acceptOffer(address _investor, uint _offerNumber) public sealed onlyOperator {\r\n        // REQUIRE THAT OFFER HAS NOT BEEN APPROVED\r\n        require(offers[_investor][_offerNumber].etherAmount > 0);\r\n        require(offers[_investor][_offerNumber].accepted != true);\r\n        // APPROVE OFFER\r\n        offers[_investor][_offerNumber].accepted = true;\r\n        // CALCULATE TOKENS\r\n        uint  _etherAmount = offers[_investor][_offerNumber].etherAmount;\r\n        uint _tokenAmount = calculateTokens(_etherAmount);\r\n        offers[_investor][_offerNumber].tokenAmount = _tokenAmount;\r\n        //require(token.balanceOf(address(this)) >= promisedTokens + _tokenAmount);\r\n        // CALCULATE COMMISSION\r\n        if (commissionEth.length == 1) {\r\n            uint etherCommission = _etherAmount.mul(commissionEth[0]).div(100);\r\n            uint jotCommission = _etherAmount.mul(commissionJot[0]).div(100);\r\n            _etherAmount = _etherAmount.sub(etherCommission).sub(jotCommission);\r\n            offers[_investor][_offerNumber].etherAmount = _etherAmount;\r\n\r\n            etherAllowance += etherCommission;\r\n            jotAllowance += jotCommission;\r\n        }\r\n        assignPartition(_investor, _etherAmount, _tokenAmount);\r\n        if (!(deals[_investor].sumEther > 0)) dealsList.push(_investor);\r\n        if (tokenReleaseAtStart == true) {\r\n            deals[_investor].tokenAllowance = _tokenAmount;\r\n        }\r\n        /* deals[_investor].numberOfDeals += 1; */\r\n        deals[_investor].sumEther += _etherAmount;\r\n        deals[_investor].sumToken += _tokenAmount;\r\n    }\r\n\r\n    // TO START MILESTONE\r\n    function startMilestone() public sealed onlyOperator {\r\n        // UNCOMMENT 2 LINES BELOW FOR PROJECT FAILS START IF totalEther < raisedEther\r\n        // if (currentMilestone == 0 && totalEther < raisedEther) { roundFailedToStart = true; }\r\n        // require(!roundFailedToStart);\r\n        if (currentMilestone != 0 ) {require(milestones[currentMilestone-1].finishTime > 0);}\r\n        for (uint i=0; i < dealsList.length ; i++) {\r\n            address investor = dealsList[i];\r\n            if (deals[investor].disputing == false) {\r\n                if (deals[investor].verdictForInvestor != true) {\r\n                    ethForMilestone += etherPartition[investor][currentMilestone];\r\n                    deals[investor].etherUsed += etherPartition[investor][currentMilestone];\r\n                    if (tokenReleaseAtStart == false) {\r\n                        deals[investor].tokenAllowance += tokenPartition[investor][currentMilestone];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        currentMilestone +=1;\r\n        //ethAfterCommission = payCommission();\r\n    }\r\n\r\n    // TO FINISH MILESTONE\r\n    function finishMilestone(string _result) public onlyOperator {\r\n        require(milestones[currentMilestone-1].finishTime == 0);\r\n        milestones[currentMilestone-1].finishTime = now;\r\n        milestones[currentMilestone-1].result = _result;\r\n    }\r\n    // -------------------------------------------------------------------------\r\n    //\r\n    // HELPERS -----------------------------------------------------------------\r\n    function failSafe() public onlyAdmin {\r\n        if (msg.sender == operator) {\r\n            saveMe = true;\r\n        }\r\n        if (msg.sender == juryOperator) {\r\n            require(saveMe == true);\r\n            require(juryOperator.send(address(this).balance));\r\n            uint allTheLockedTokens = token.balanceOf(this);\r\n            require(token.transfer(juryOperator,allTheLockedTokens));\r\n        }\r\n    }\r\n    function milestonesLength() public view returns(uint) {\r\n        return milestones.length;\r\n    }\r\n    function assignPartition(address _investor, uint _etherAmount, uint _tokenAmount) internal {\r\n        uint milestoneEtherAmount; //How much Ether does investor send for a milestone\r\n\t\tuint milestoneTokenAmount; //How many Tokens does investor receive for a milestone\r\n\t\tuint milestoneEtherTarget; //How much TOTAL Ether a milestone needs\r\n\t\tuint milestoneTokenTarget; //How many TOTAL tokens a milestone releases\r\n\t\tuint totalEtherInvestment;\r\n\t\tuint totalTokenInvestment;\r\n        for(uint i=currentMilestone; i<milestones.length; i++) {\r\n\t\t\tmilestoneEtherTarget = milestones[i].etherAmount;\r\n            milestoneTokenTarget = milestones[i].tokenAmount;\r\n\t\t\tmilestoneEtherAmount = _etherAmount.mul(milestoneEtherTarget).div(totalEther);\r\n\t\t\tmilestoneTokenAmount = _tokenAmount.mul(milestoneTokenTarget).div(totalToken);\r\n\t\t\ttotalEtherInvestment = totalEtherInvestment.add(milestoneEtherAmount); //used to prevent rounding errors\r\n\t\t\ttotalTokenInvestment = totalTokenInvestment.add(milestoneTokenAmount); //used to prevent rounding errors\r\n            if (deals[_investor].sumEther > 0) {\r\n                etherPartition[_investor][i] += milestoneEtherAmount;\r\n    \t\t\ttokenPartition[_investor][i] += milestoneTokenAmount;\r\n            } else {\r\n                etherPartition[_investor].push(milestoneEtherAmount);\r\n    \t\t\ttokenPartition[_investor].push(milestoneTokenAmount);\r\n            }\r\n\r\n\t\t}\r\n        /* roundingErrors += _etherAmount - totalEtherInvestment; */\r\n\t\tetherPartition[_investor][currentMilestone] += _etherAmount - totalEtherInvestment; //rounding error is added to the first milestone\r\n\t\ttokenPartition[_investor][currentMilestone] += _tokenAmount - totalTokenInvestment; //rounding error is added to the first milestone\r\n    }\r\n    function isDisputing(address _investor) public view returns(bool) {\r\n        return deals[_investor].disputing;\r\n    }\r\n    // CHECK TO SEE IF INVESTOR IS IN WHITELIST (for debugging)\r\n    /* function isInWhitelist(uint _fundingRound, address _investor) public view returns(bool) {\r\n        return whitelist[_fundingRound][_investor];\r\n    } */\r\n    /* function commissionCheck() internal view returns(bool) {\r\n        for ( uint i=0 ; i < commissionEth.length ; i++ ) {\r\n            uint percentToBeReleased = milestones[i].etherAmount.mul(100).div(totalEther);\r\n            uint percentToPay = commissionEth[i] + commissionJot[i];\r\n            require(percentToPay <= percentToBeReleased);\r\n        }\r\n        return true;\r\n    } */\r\n}\r\n\r\ncontract ArbitrationX {\r\n    address public operator;\r\n    uint public quorum = 3;\r\n    //uint public counter;\r\n    struct Dispute {\r\n        address icoRoundAddress;\r\n        address investorAddress;\r\n        bool pending;\r\n        uint timestamp;\r\n        uint milestone;\r\n        string reason;\r\n        uint votesForProject;\r\n        uint votesForInvestor;\r\n        // bool verdictForProject;\r\n        // bool verdictForInvestor;\r\n        mapping(address => bool) voters;\r\n    }\r\n    mapping(uint => Dispute) public disputes;\r\n    uint public disputeLength;\r\n    mapping(address => mapping(address => bool)) public arbiterPool;\r\n\r\n    constructor() public {\r\n        operator = msg.sender;\r\n    }\r\n    // OPERATOR\r\n    function setArbiters(address _icoRoundAddress, address[] _arbiters) public {\r\n        for (uint i = 0; i < _arbiters.length ; i++) {\r\n            arbiterPool[_icoRoundAddress][_arbiters[i]] = true;\r\n        }\r\n    }\r\n    // ARBITER\r\n    function vote(uint _disputeId, bool _voteForInvestor) public {\r\n        require(disputes[_disputeId].pending == true);\r\n        /* require(arbiterPool[disputes[_disputeId].icoRoundAddress][msg.sender] == true); */\r\n        require(disputes[_disputeId].voters[msg.sender] != true);\r\n        if (_voteForInvestor == true) { disputes[_disputeId].votesForInvestor += 1; }\r\n        else { disputes[_disputeId].votesForProject += 1; }\r\n        if (disputes[_disputeId].votesForInvestor == quorum) {\r\n            executeVerdict(_disputeId,true);\r\n        }\r\n        if (disputes[_disputeId].votesForProject == quorum) {\r\n            executeVerdict(_disputeId,false);\r\n        }\r\n        disputes[_disputeId].voters[msg.sender] == true;\r\n    }\r\n    // INVESTOR\r\n    function openDispute(address _icoRoundAddress, string _reason) public {\r\n        ICOCycle icoRound = ICOCycle(_icoRoundAddress);\r\n        uint milestoneDispute = icoRound.currentMilestone();\r\n        require(milestoneDispute > 0);\r\n        disputes[disputeLength].milestone = milestoneDispute;\r\n\r\n        disputes[disputeLength].icoRoundAddress = _icoRoundAddress;\r\n        disputes[disputeLength].investorAddress = msg.sender;\r\n        disputes[disputeLength].timestamp = now;\r\n        disputes[disputeLength].reason = _reason;\r\n        disputes[disputeLength].pending = true;\r\n\r\n        icoRound.disputeOpened(msg.sender);\r\n        disputeLength +=1;\r\n    }\r\n    // INTERNAL\r\n    function executeVerdict(uint _disputeId, bool _verdictForInvestor) internal {\r\n        disputes[_disputeId].pending = false;\r\n        uint milestoneDispute = disputes[_disputeId].milestone;\r\n        ICOCycle icoRound = ICOCycle(disputes[_disputeId].icoRoundAddress);\r\n        icoRound.verdictExecuted(disputes[_disputeId].investorAddress,_verdictForInvestor,milestoneDispute);\r\n        //counter +=1;\r\n    }\r\n    function isPending(uint _disputedId) public view returns(bool) {\r\n        return disputes[_disputedId].pending;\r\n    }\r\n}\r\n\r\ncontract Swapper {\r\n    // for an ethToJot of 2,443.0336457941, Aug 21, 2018\r\n    Token public token;\r\n    uint public ethToJot = 2443;\r\n    address public myBal;\r\n    address public owner;\r\n    uint public myJot;\r\n    uint public ujot;\r\n    constructor(address _jotAddress) public {\r\n        owner = msg.sender;\r\n        token = Token(_jotAddress);\r\n        myBal = address(this);\r\n        /* myJot = token.balanceOf(myBal); */\r\n    }\r\n    /* function() payable public { */\r\n        /* myBal = address(this); */\r\n        /* myJot = token.balanceOf(myBal); */\r\n        /* require(token.balanceOf(myBal) >= jot); */\r\n        /* require(token.transfer(msg.sender,jot)); */\r\n\r\n    function swapMe() public payable {\r\n        uint jot = msg.value * ethToJot;\r\n        myJot = token.balanceOf(myBal);\r\n        ujot = jot;\r\n        require(token.transfer(owner,jot));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_icoRoundAddress\",\"type\":\"address\"}],\"name\":\"approveRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbitrationAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"juryOnlineWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"cycles\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"},{\"name\":\"approved\",\"type\":\"bool\"},{\"name\":\"icoRoundAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentCycle\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"projectWallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"addRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_operator\",\"type\":\"address\"},{\"name\":\"_projectWallet\",\"type\":\"address\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_arbitrationAddress\",\"type\":\"address\"},{\"name\":\"_juryOnlineWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ICOContractX","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000c00000000000000000000000005b007da9dbf09842cb4751bd5bcd6ea2808256f50000000000000000000000005b007da9dbf09842cb4751bd5bcd6ea2808256f5000000000000000000000000d1e7eda2251fe98168e86a579c49ec88dd3d6fd30000000000000000000000005f8a93087c32dd3100a790953dd0436d3e70039c000000000000000000000000ff26720636f2f1fd855bfedefbfbd6e175633d7400000000000000000000000000000000000000000000000000000000000000074b56414e544f5200000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://b9b7a4fdd75a6579b4e8df5ee67da01a5af353219609bb666a72d3dee3350432"}]}