{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.13;\r\n\r\nlibrary CertsLib {\r\n  struct SignatureData {\r\n    /* \r\n     * status == 0x0 => UNKNOWN\r\n     * status == 0x1 => PENDING\r\n     * status == 0x2 => SIGNED\r\n     * Otherwise     => Purpose (sha-256 of data)\r\n     */\r\n    bytes32 status;\r\n    uint exp; // Expiration Date\r\n  }\r\n\r\n  struct TransferData {\r\n    address newOwner;\r\n    uint newEntityId;\r\n  }\r\n\r\n  struct CertData {\r\n    /*\r\n     * owner == 0 => POE_CERTIFICATE\r\n     * owner != 0 => PROPIETARY_CERTIFICATE\r\n     */\r\n    address owner; // owner of the certificate (in case of being a peer)\r\n    uint entityId; // owner of the certificate (in case of being an entity)\r\n    bytes32 certHash; // sha256 checksum of the certificate JSON data\r\n    string ipfsCertHash; // ipfs multihash address of certificate in json format\r\n    bytes32 dataHash; // sha256 hash of certified data\r\n    string ipfsDataHash; // ipfs multihash address of certified data\r\n    mapping(uint => SignatureData) entities; // signatures from signing entities and their expiration date\r\n    uint[] entitiesArr;\r\n    mapping(address => SignatureData) signatures; // signatures from peers and their expiration date\r\n    address[] signaturesArr;\r\n  }\r\n\r\n  struct Data {\r\n    mapping(uint => CertData) certificates;\r\n    mapping(uint => TransferData) transferRequests;\r\n    uint nCerts;\r\n  }\r\n\r\n  // METHODS\r\n\r\n  /**\r\n   * Creates a new POE certificate\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param dataHash {bytes32} - The hash of the certified data\r\n   * @param certHash {bytes32} - The sha256 hash of the json certificate\r\n   * @param ipfsDataHash {string} - The ipfs multihash address of the data (0x00 means unkwon)\r\n   * @param ipfsCertHash {string} - The ipfs multihash address of the certificate in json format (0x00 means unkwon)\r\n   * @return The id of the created certificate     \r\n   */\r\n  function createPOECertificate(Data storage self, bytes32 dataHash, bytes32 certHash, string ipfsDataHash, string ipfsCertHash) public returns (uint) {\r\n    require (hasData(dataHash, certHash, ipfsDataHash, ipfsCertHash));\r\n\r\n    uint certId = ++self.nCerts;\r\n    self.certificates[certId] = CertData({\r\n      owner: 0,\r\n      entityId: 0,\r\n      certHash: certHash,\r\n      ipfsCertHash: ipfsCertHash,\r\n      dataHash: dataHash,\r\n      ipfsDataHash: ipfsDataHash,\r\n      entitiesArr: new uint[](0),\r\n      signaturesArr: new address[](0)\r\n    });\r\n\r\n    POECertificate(certId);\r\n    return certId;\r\n  }\r\n\r\n  /**\r\n   * Creates a new certificate (with known owner). The owner will be the sender unless the entityId (issuer) is supplied.\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param dataHash {bytes32} - The hash of the certified data\r\n   * @param certHash {bytes32} - The sha256 hash of the json certificate\r\n   * @param ipfsDataHash {string} - The ipfs multihash address of the data (0x00 means unkwon)\r\n   * @param ipfsCertHash {string} - The ipfs multihash address of the certificate in json format (0x00 means unkwon)\r\n   * @param entityId {uint} - The entity id which issues the certificate (0 if not issued by an entity)\r\n   * @return {uint} The id of the created certificate     \r\n   */\r\n  function createCertificate(Data storage self, EntityLib.Data storage ed, bytes32 dataHash, bytes32 certHash, string ipfsDataHash, string ipfsCertHash, uint entityId) senderCanIssueEntityCerts(ed, entityId) public returns (uint) {\r\n    require (hasData(dataHash, certHash, ipfsDataHash, ipfsCertHash));\r\n\r\n    uint certId = ++self.nCerts;\r\n    self.certificates[certId] = CertData({\r\n      owner: entityId == 0 ? msg.sender : 0,\r\n      entityId: entityId,\r\n      certHash: certHash,\r\n      ipfsCertHash: ipfsCertHash,\r\n      dataHash: dataHash,\r\n      ipfsDataHash: ipfsDataHash,\r\n      entitiesArr: new uint[](0),\r\n      signaturesArr: new address[](0)\r\n    });\r\n\r\n    Certificate(certId);\r\n    return certId;\r\n  }\r\n\r\n  /**\r\n   * Transfers a certificate owner. The owner can be a peer or an entity (never both), so only one of newOwner or newEntity must be different than 0.\r\n   * If the specified certificateId belongs to an entity, the msg.sender must be a valid signer for the entity. Otherwise the msg.sender must be the current owner.\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param certificateId {uint} - The id of the certificate to transfer\r\n   * @param newOwner {address} - The address of the new owner\r\n   */\r\n  function requestCertificateTransferToPeer(Data storage self, EntityLib.Data storage ed, uint certificateId, address newOwner) canTransferCertificate(self, ed, certificateId) public {\r\n    self.transferRequests[certificateId] = TransferData({\r\n      newOwner: newOwner,\r\n      newEntityId: 0\r\n    });\r\n\r\n    CertificateTransferRequestedToPeer(certificateId, newOwner);\r\n  }\r\n\r\n  /**\r\n   * Transfers a certificate owner. The owner can be a peer or an entity (never both), so only one of newOwner or newEntity must be different than 0.\r\n   * If the specified certificateId belongs to an entity, the msg.sender must be a valid signer for the entity. Otherwise the msg.sender must be the current owner.\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param certificateId {uint} - The id of the certificate to transfer\r\n   * @param newEntityId {uint} - The id of the new entity\r\n   */\r\n  function requestCertificateTransferToEntity(Data storage self, EntityLib.Data storage ed, uint certificateId, uint newEntityId) entityExists(ed, newEntityId) canTransferCertificate(self, ed, certificateId) public {\r\n    self.transferRequests[certificateId] = TransferData({\r\n      newOwner: 0,\r\n      newEntityId: newEntityId\r\n    });\r\n\r\n    CertificateTransferRequestedToEntity(certificateId, newEntityId);\r\n  }\r\n\r\n  /**\r\n   * Accept the certificate transfer\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param certificateId {uint} - The id of the certificate to transfer\r\n   */\r\n  function acceptCertificateTransfer(Data storage self, EntityLib.Data storage ed, uint certificateId) canAcceptTransfer(self, ed, certificateId) public {\r\n    TransferData storage reqData = self.transferRequests[certificateId];\r\n    self.certificates[certificateId].owner = reqData.newOwner;\r\n    self.certificates[certificateId].entityId = reqData.newEntityId;    \r\n    CertificateTransferAccepted(certificateId, reqData.newOwner, reqData.newEntityId);\r\n    delete self.transferRequests[certificateId];\r\n  }\r\n\r\n  /**\r\n   * Cancel any certificate transfer request\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param certificateId {uint} - The id of the certificate to transfer\r\n   */\r\n  function cancelCertificateTransfer(Data storage self, EntityLib.Data storage ed, uint certificateId) canTransferCertificate(self, ed, certificateId) public {\r\n    self.transferRequests[certificateId] = TransferData({\r\n      newOwner: 0,\r\n      newEntityId: 0\r\n    });\r\n\r\n    CertificateTransferCancelled(certificateId);\r\n  }\r\n\r\n  /**\r\n   * Updates ipfs multihashes of a particular certificate\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param certId {uint} - The id of the certificate\r\n   * @param ipfsDataHash {string} - The ipfs multihash address of the data (0x00 means unkwon)\r\n   * @param ipfsCertHash {string} - The ipfs multihash address of the certificate in json format (0x00 means unkwon)\r\n   */\r\n  function setIPFSData(Data storage self, uint certId, string ipfsDataHash, string ipfsCertHash) ownsCertificate(self, certId) public {\r\n      self.certificates[certId].ipfsDataHash = ipfsDataHash;\r\n      self.certificates[certId].ipfsCertHash = ipfsCertHash;\r\n      UpdatedIPFSData(certId);\r\n  }\r\n\r\n  // HELPERS\r\n\r\n  /**\r\n   * Returns true if the certificate has valid data\r\n   * @param dataHash {bytes32} - The hash of the certified data\r\n   * @param certHash {bytes32} - The sha256 hash of the json certificate\r\n   * @param ipfsDataHash {string} - The ipfs multihash address of the data (0x00 means unkwon)\r\n   * @param ipfsCertHash {string} - The ipfs multihash address of the certificate in json format (0x00 means unkwon)   * @return {bool} - True if the certificate contains valid data\r\n   */\r\n  function hasData(bytes32 dataHash, bytes32 certHash, string ipfsDataHash, string ipfsCertHash) pure public returns (bool) {\r\n    return certHash != 0\r\n    || dataHash != 0\r\n    || bytes(ipfsDataHash).length != 0\r\n    || bytes(ipfsCertHash).length != 0;\r\n  }\r\n\r\n  // MODIFIERS\r\n  \r\n /**\r\n   * Returns True if msg.sender is the owner of the specified certificate. False otherwise.\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param id {uint} - The id of the certificate \r\n   */\r\n  modifier ownsCertificate(Data storage self, uint id) {\r\n    require (self.certificates[id].owner == msg.sender);\r\n    _;\r\n  }\r\n\r\n\r\n  /**\r\n   * Returns TRUE if the specified entity is valid and the sender is a valid signer from the entity.\r\n   * If the entityId is 0 (not provided), it also returns TRUE\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The entityId which will issue the certificate\r\n   */\r\n  modifier senderCanIssueEntityCerts(EntityLib.Data storage ed, uint entityId) {\r\n    require (entityId == 0 \r\n     || (EntityLib.isValid(ed, entityId) && ed.entities[entityId].signers[msg.sender].status == 2));\r\n    _;    \r\n  }\r\n\r\n  /**\r\n   * Returns TRUE if the certificate has data and can be transfered to the new owner:\r\n   * - When the certificate is owned by a peer: the sender must be the owner of the certificate\r\n   * - When the certificate belongs to an entity: the entity must be valid \r\n   *   AND the signer must be a valid signer of the entity\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param certificateId {uint} - The certificateId which transfer is required\r\n   */\r\n  modifier canTransferCertificate(Data storage self, EntityLib.Data storage ed, uint certificateId) {\r\n    CertData storage cert = self.certificates[certificateId];\r\n    require (hasData(cert.dataHash, cert.certHash, cert.ipfsDataHash, cert.ipfsCertHash));\r\n\r\n    if (cert.owner != 0) {\r\n      require (cert.owner == msg.sender);\r\n      _;\r\n    } else if (cert.entityId != 0) {\r\n      EntityLib.EntityData storage entity = ed.entities[cert.entityId];\r\n      require (EntityLib.isValid(ed, cert.entityId) && entity.signers[msg.sender].status == 2);\r\n      _;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Returns TRUE if the entity exists\r\n   */\r\n  modifier entityExists(EntityLib.Data storage ed, uint entityId) {\r\n    require (EntityLib.exists(ed, entityId));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Returns TRUE if the msg.sender can accept the certificate transfer\r\n   * @param self {object} - The data containing the certificate mappings\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param certificateId {uint} - The certificateId which transfer is required\r\n   */\r\n  modifier canAcceptTransfer(Data storage self, EntityLib.Data storage ed, uint certificateId) {\r\n    CertData storage cert = self.certificates[certificateId];\r\n    require (hasData(cert.dataHash, cert.certHash, cert.ipfsDataHash, cert.ipfsCertHash));\r\n\r\n    TransferData storage reqData = self.transferRequests[certificateId];\r\n    require(reqData.newEntityId != 0 || reqData.newOwner != 0);\r\n\r\n    if (reqData.newOwner == msg.sender) {\r\n      _;\r\n    } else if (reqData.newEntityId != 0) {      \r\n      EntityLib.EntityData storage newEntity = ed.entities[reqData.newEntityId];\r\n      require (EntityLib.isValid(ed, reqData.newEntityId) && newEntity.signers[msg.sender].status == 2);\r\n       _;\r\n    }\r\n  }\r\n\r\n  // EVENTS\r\n\r\n  event POECertificate(uint indexed certificateId);\r\n  event Certificate(uint indexed certificateId);\r\n  event CertificateTransferRequestedToPeer(uint indexed certificateId, address newOwner);\r\n  event CertificateTransferRequestedToEntity(uint indexed certificateId, uint newEntityId);\r\n  event CertificateTransferAccepted(uint indexed certificateId, address newOwner, uint newEntityId);\r\n  event CertificateTransferCancelled(uint indexed certificateId);\r\n  event UpdatedIPFSData(uint indexed certificateId);\r\n}\r\n\r\nlibrary EntityLib {\r\n  struct SignerData {\r\n    string signerDataHash;\r\n    /*\r\n     * status == 0 => NOT_VALID\r\n     * status == 1 => VALIDATION_PENDING\r\n     * status == 2 => VALID\r\n     * status == 3 => DATA_UPDATED\r\n     */\r\n    uint status;\r\n  }\r\n\r\n  struct EntityData {\r\n    address owner;\r\n    string dataHash; // hash entity data\r\n    /*\r\n      * status == 0 => NOT_VALID\r\n      * status == 1 => VALIDATION_PENDING\r\n      * status == 2 => VALID\r\n      * status == 4 => RENEWAL_REQUESTED\r\n      * status == 8 => CLOSED\r\n      * otherwise => UNKNOWN\r\n      */\r\n    uint status;\r\n    bytes32 urlHash;         // hash url only\r\n    uint expiration;         // Expiration date\r\n    uint renewalPeriod;      // Renewal period to be used for 3rd party renewals (3rd party paying the validation expenses)\r\n    bytes32 oraclizeQueryId; // Last query Id from oraclize. We will only process the last request\r\n\r\n    /*\r\n      * signers[a] == 0;\r\n      * signers[a] = ipfs multihash address for signer data file in json format\r\n      */\r\n    mapping(address => SignerData) signers;\r\n    address[] signersArr;\r\n  }\r\n\r\n  struct Data {\r\n    mapping(uint => EntityData) entities;\r\n    mapping(bytes32 => uint) entityIds;\r\n    uint nEntities;\r\n  }\r\n\r\n  // METHODS\r\n\r\n  /**\r\n   * Creates a new entity\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entitDatayHash {string} - The ipfs multihash address of the entity information in json format\r\n   * @param urlHash {bytes32} - The sha256 hash of the URL of the entity\r\n   * @param expirationDate {uint} - The expiration date of the current entity\r\n   * @param renewalPeriod {uint} - The time period which will be added to the current date or expiration date when a renewal is requested\r\n   * @return {uint} The id of the created entity\r\n   */\r\n  function create(Data storage self, uint entityId, string entitDatayHash, bytes32 urlHash, uint expirationDate, uint renewalPeriod) isExpirationDateValid(expirationDate) isRenewalPeriodValid(renewalPeriod) public {\r\n    self.entities[entityId] = EntityData({\r\n        owner: msg.sender,\r\n        dataHash: entitDatayHash,\r\n        urlHash: urlHash,\r\n        status: 1,\r\n        expiration: expirationDate,\r\n        renewalPeriod: renewalPeriod,\r\n        oraclizeQueryId: 0,\r\n        signersArr: new address[](0)\r\n    });\r\n    EntityCreated(entityId);\r\n  }\r\n\r\n  /**\r\n   * Process validation after the oraclize callback\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param queryId {bytes32} - The id of the oraclize query (returned by the call to oraclize_query method)\r\n   * @param result {string} - The result of the query\r\n   */\r\n  function processValidation(Data storage self, bytes32 queryId, string result) public {\r\n    uint entityId = self.entityIds[queryId];\r\n    self.entityIds[queryId] = 0;\r\n    \r\n    EntityData storage entity = self.entities[entityId];\r\n\r\n    require (queryId == entity.oraclizeQueryId);\r\n\r\n    string memory entityIdStr = uintToString(entityId);\r\n    string memory toCompare = strConcat(entityIdStr, \":\", entity.dataHash); \r\n\r\n    if (stringsEqual(result, toCompare)) {\r\n      if (entity.status == 4) { // if entity is waiting for renewal\r\n        uint initDate = max(entity.expiration, now);\r\n        entity.expiration = initDate + entity.renewalPeriod;\r\n      }\r\n\r\n      entity.status = 2; // set entity status to valid\r\n      EntityValidated(entityId);\r\n    } else {\r\n      entity.status = 1;  // set entity status to validation pending\r\n      EntityInvalid(entityId);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Sets a new expiration date for the entity. It will trigger an entity validation through the oracle, so it must be paid.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param expirationDate {uint} - The new expiration date of the entity\r\n   */\r\n  function setExpiration (Data storage self, uint entityId, uint expirationDate) isNotClosed(self, entityId) onlyEntity(self, entityId) isExpirationDateValid(expirationDate) public {\r\n    EntityData storage entity = self.entities[entityId];\r\n    entity.status = 1;\r\n    entity.expiration = expirationDate;\r\n    EntityExpirationSet(entityId);\r\n  }\r\n  \r\n  /**\r\n   * Sets a new renewal interval\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param renewalPeriod {uint} - The new renewal interval (in seconds)\r\n   */\r\n  function setRenewalPeriod (Data storage self, uint entityId, uint renewalPeriod) isNotClosed(self, entityId) onlyEntity(self, entityId) isRenewalPeriodValid(renewalPeriod) public {\r\n    EntityData storage entity = self.entities[entityId];\r\n    entity.renewalPeriod = renewalPeriod;\r\n    EntityRenewalSet(entityId);\r\n  }\r\n\r\n  /**\r\n   * Close an entity. This status will not allow further operations on the entity.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   */\r\n  function closeEntity(Data storage self, uint entityId) isNotClosed(self, entityId) onlyEntity(self, entityId) public {\r\n    self.entities[entityId].status = 8;\r\n    EntityClosed(entityId);\r\n  }\r\n\r\n  /**\r\n   * Registers a new signer in an entity\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer to be registered\r\n   * @param signerDataHash {uint} - The IPFS multihash address of signer information in json format\r\n   */\r\n  function registerSigner(Data storage self, uint entityId, address signerAddress, string signerDataHash) isValidEntity(self, entityId) onlyEntity(self, entityId) signerIsNotYetRegistered(self, entityId, signerAddress) public {\r\n    self.entities[entityId].signersArr.push(signerAddress);\r\n    self.entities[entityId].signers[signerAddress] = SignerData({\r\n      signerDataHash: signerDataHash,\r\n      status: 1\r\n    });\r\n    SignerAdded(entityId, signerAddress);\r\n  }\r\n\r\n  /**\r\n   * Confirms signer registration\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerDataHash {string} - The ipfs data hash of the signer to confirm\r\n   */\r\n  function confirmSignerRegistration(Data storage self, uint entityId, string signerDataHash) isValidEntity(self, entityId) isWaitingConfirmation(self, entityId, signerDataHash) public {\r\n    self.entities[entityId].signers[msg.sender].status = 2;\r\n    SignerConfirmed(entityId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Removes a signer from an entity\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer to be removed\r\n   */\r\n  function removeSigner(Data storage self, uint entityId, address signerAddress) isValidEntity(self, entityId) onlyEntity(self, entityId) public {\r\n    internalRemoveSigner(self, entityId, signerAddress);\r\n  }\r\n\r\n\r\n  /**\r\n   * Removes a signer from an entity (internal use, without modifiers)\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer to be removed\r\n   */\r\n  function internalRemoveSigner(Data storage self, uint entityId, address signerAddress) private {\r\n    EntityData storage entity = self.entities[entityId];\r\n    address[] storage signersArr = entity.signersArr;\r\n    SignerData storage signer = entity.signers[signerAddress];\r\n\r\n    if (bytes(signer.signerDataHash).length != 0 || signer.status != 0) {\r\n      signer.status = 0;\r\n      signer.signerDataHash = '';\r\n      delete entity.signers[signerAddress];\r\n\r\n      // Update array for iterator\r\n      uint i = 0;\r\n      for (i; signerAddress != signersArr[i]; i++) {}\r\n      signersArr[i] = signersArr[signersArr.length - 1];\r\n      signersArr[signersArr.length - 1] = 0;\r\n      signersArr.length = signersArr.length - 1;\r\n      \r\n      SignerRemoved(entityId, signerAddress);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Leave the specified entity (remove signer if found)\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   */\r\n  function leaveEntity(Data storage self, uint entityId) signerBelongsToEntity(self, entityId) public {\r\n    internalRemoveSigner(self, entityId, msg.sender);\r\n  }\r\n\r\n  /**\r\n    * Checks if an entity can be validated\r\n    * @param entityId {uint} - The id of the entity to validate\r\n    * @param url {string} - The URL of the entity\r\n    * @return {bytes32} - The id of the oraclize query\r\n    */\r\n  function canValidateSigningEntity(Data storage self, uint entityId, string url) isNotClosed(self, entityId) isRegisteredURL(self, entityId, url) view public returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if an entity validity can be renewed\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to validate\r\n   * @param url {string} - The URL of the entity\r\n   * @return {bool} - True if renewal is possible\r\n   */\r\n  function canRenew(Data storage self, uint entityId, string url) isValidatedEntity(self, entityId) isRenewalPeriod(self, entityId) isRegisteredURL(self, entityId, url) view public returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Checks if an entity can issue certificate (from its signers)\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to check\r\n   * @return {bool} - True if issuance is possible\r\n   */\r\n  function canIssueCertificates(Data storage self, uint entityId) isNotClosed(self, entityId) notExpired(self, entityId) signerBelongsToEntity(self, entityId) view public returns (bool) {\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Updates entity data\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param entityDataHash {string} - The ipfs multihash address of the entity information in json format\r\n   * @param urlHash {bytes32} - The sha256 hash of the URL of the entity\r\n   */\r\n  function updateEntityData(Data storage self, uint entityId, string entityDataHash, bytes32 urlHash) isNotClosed(self, entityId) onlyEntity(self, entityId) public {\r\n    EntityData storage entity = self.entities[entityId];\r\n    entity.dataHash = entityDataHash;\r\n    entity.urlHash = urlHash;\r\n    entity.status = 1;\r\n    EntityDataUpdated(entityId);\r\n  }\r\n\r\n\r\n  /**\r\n   * Update the signer data in the requestes entities\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityIds {array} - The ids of the entities to update\r\n   * @param signerDataHash {string} - The ipfs multihash of the new signer data\r\n   */\r\n  function updateSignerData(Data storage self, uint[] entityIds, string signerDataHash) signerBelongsToEntities(self, entityIds) public {\r\n    uint[] memory updated = new uint[](entityIds.length);\r\n    for (uint i = 0; i < entityIds.length; i++) {\r\n      uint entityId = entityIds[i];\r\n      SignerData storage signer = self.entities[entityId].signers[msg.sender];\r\n\r\n      if (signer.status != 2) {\r\n        continue;\r\n      }\r\n      signer.status = 3;\r\n      signer.signerDataHash = signerDataHash;\r\n      updated[i] = entityId;\r\n    }\r\n    SignerDataUpdated(updated, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Accepts a new signer data update in the entity\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer update to be accepted\r\n   * @param signerDataHash {uint} - The IPFS multihash address of signer information in json format to be accepted\r\n   */\r\n  function acceptSignerUpdate(Data storage self, uint entityId, address signerAddress, string signerDataHash) onlyEntity(self, entityId) notExpired(self, entityId) signerUpdateCanBeAccepted(self, entityId, signerAddress, signerDataHash) public {\r\n    EntityData storage entity = self.entities[entityId];\r\n    entity.signers[signerAddress].status = 2;\r\n    SignerUpdateAccepted(entityId, signerAddress);\r\n  }\r\n\r\n  // HELPER METHODS\r\n\r\n  /**\r\n   * Returns the max of two numbers\r\n   * @param a {uint} - Input number a\r\n   * @param b {uint} - Input number b\r\n   * @return {uint} - The maximum of the two inputs\r\n   */\r\n  function max(uint a, uint b) pure public returns(uint) {\r\n    if (a > b) {\r\n      return a;\r\n    } else {\r\n      return b;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Compares two strings\r\n   * @param _a {string} - One of the strings\r\n   * @param _b {string} - The other string\r\n   * @return {bool} True if the two strings are equal, false otherwise\r\n   */\r\n  function stringsEqual(string memory _a, string memory _b) pure internal returns (bool) {\r\n    bytes memory a = bytes(_a);\r\n    bytes memory b = bytes(_b);\r\n    if (a.length != b.length)\r\n      return false;\r\n    for (uint i = 0; i < a.length; i ++) {\r\n      if (a[i] != b[i])\r\n        return false;\r\n        }\r\n    return true;\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c, string _d, string _e) pure internal returns (string){\r\n    bytes memory _ba = bytes(_a);\r\n    bytes memory _bb = bytes(_b);\r\n    bytes memory _bc = bytes(_c);\r\n    bytes memory _bd = bytes(_d);\r\n    bytes memory _be = bytes(_e);\r\n    string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n    bytes memory babcde = bytes(abcde);\r\n    uint k = 0;\r\n    for (uint i = 0; i < _ba.length; i++) {babcde[k++] = _ba[i];}\r\n    for (i = 0; i < _bb.length; i++) {babcde[k++] = _bb[i];}\r\n    for (i = 0; i < _bc.length; i++) {babcde[k++] = _bc[i];}\r\n    for (i = 0; i < _bd.length; i++) {babcde[k++] = _bd[i];}\r\n    for (i = 0; i < _be.length; i++) {babcde[k++] = _be[i];}\r\n    return string(babcde);\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c, string _d) pure internal returns (string) {\r\n      return strConcat(_a, _b, _c, _d, \"\");\r\n  }\r\n\r\n  function strConcat(string _a, string _b, string _c) pure internal returns (string) {\r\n      return strConcat(_a, _b, _c, \"\", \"\");\r\n  }\r\n\r\n  function strConcat(string _a, string _b) pure internal returns (string) {\r\n      return strConcat(_a, _b, \"\", \"\", \"\");\r\n  }\r\n\r\n  // uint to string\r\n  function uintToString(uint v) pure public returns (string) {\r\n    uint maxlength = 100;\r\n    bytes memory reversed = new bytes(maxlength);\r\n    uint i = 0;\r\n    while (v != 0) {\r\n      uint remainder = v % 10;\r\n      v = v / 10;\r\n      reversed[i++] = byte(48 + remainder);\r\n    }\r\n    bytes memory s = new bytes(i); // i + 1 is inefficient\r\n    for (uint j = 0; j < i; j++) {\r\n        s[j] = reversed[i - j - 1]; // to avoid the off-by-one error\r\n    }\r\n    string memory str = string(s); // memory isn't implicitly convertible to storage\r\n    return str;\r\n  }\r\n\r\n  /**\r\n   * Set the oraclize query id of the last request\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity\r\n   * @param queryId {bytes32} - The query id from the oraclize request\r\n   */\r\n  function setOraclizeQueryId(Data storage self, uint id, bytes32 queryId) public {\r\n    self.entities[id].oraclizeQueryId = queryId;\r\n  }\r\n\r\n  // Helper functions\r\n\r\n  /**\r\n   * Returns True if specified entity is validated or waiting to be renewed. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   * @return {bool} - True if the entity is validated\r\n   */\r\n  function isValidated(Data storage self, uint id) view public returns (bool) {\r\n    return (id > 0 && (self.entities[id].status == 2 || self.entities[id].status == 4));\r\n  }\r\n\r\n /**\r\n  * Returns True if specified entity is not expired. False otherwise.\r\n  * @param self {object} - The data containing the entity mappings\r\n  * @param id {uint} - The id of the entity to check \r\n  * @return {bool} - True if the entity is not expired\r\n  */\r\n  function isExpired(Data storage self, uint id) view public returns (bool) {\r\n    return (id > 0 && (self.entities[id].expiration < now));\r\n  }\r\n\r\n  /**\r\n  * Returns True if specified entity is closed.\r\n  * @param self {object} - The data containing the entity mappings\r\n  * @param id {uint} - The id of the entity to check \r\n  * @return {bool} - True if the entity is closed\r\n  */\r\n  function isClosed(Data storage self, uint id) view public returns (bool) {\r\n    return self.entities[id].status == 8;\r\n  }\r\n\r\n /**\r\n   * Returns True if specified entity is validated and not expired\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   * @return {bool} - True if the entity is validated\r\n   */\r\n  function isValid(Data storage self, uint id) view public returns (bool) {\r\n    return isValidated(self, id) && !isExpired(self, id) && !isClosed(self, id);\r\n  }\r\n\r\n /**\r\n   * Returns True if specified entity exists\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   * @return {bool} - True if the entity exists\r\n   */\r\n  function exists(Data storage self, uint id) view public returns(bool) {\r\n    EntityData storage entity = self.entities[id];\r\n    return entity.status > 0;\r\n  }\r\n\r\n  // MODIFIERS\r\n  \r\n  /**\r\n   * Valid if the renewal period is less than 31 days\r\n   * @param renewalPeriod {uint} - The renewal period to check (in seconds)\r\n   */\r\n  modifier isRenewalPeriodValid(uint renewalPeriod) {\r\n    require(renewalPeriod >= 0 && renewalPeriod <= 32 * 24 * 60 * 60); // Renewal period less than 32 days\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Valid if the expiration date is in less than 31 days\r\n   * @param expiration {uint} - The expiration date (in seconds)\r\n   */\r\n  modifier isExpirationDateValid(uint expiration) {\r\n    require(expiration - now > 0 && expiration - now <= 32 * 24 * 60 * 60); // Expiration date is in less than 32 days in the future\r\n    _;\r\n  }\r\n  \r\n  /**\r\n   * Returns True if specified entity is validated or waiting to be renewed. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   */\r\n  modifier isValidatedEntity(Data storage self, uint id) {\r\n    require (isValidated(self, id));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Returns True if specified entity is validated or waiting to be renewed, not expired and not closed. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   */\r\n  modifier isValidEntity(Data storage self, uint id) {\r\n    require (isValid(self, id));\r\n    _;\r\n  }\r\n\r\n  /**\r\n  * Returns True if specified entity is validated. False otherwise.\r\n  * @param self {object} - The data containing the entity mappings\r\n  * @param id {uint} - The id of the entity to check \r\n  */\r\n  modifier notExpired(Data storage self, uint id) {\r\n    require (!isExpired(self, id));\r\n    _;  \r\n  }\r\n\r\n  /**\r\n    * Returns True if tansaction sent by owner of entity. False otherwise.\r\n    * @param self {object} - The data containing the entity mappings\r\n    * @param id {uint} - The id of the entity to check\r\n    */\r\n  modifier onlyEntity(Data storage self, uint id) {\r\n    require (msg.sender == self.entities[id].owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n    * Returns True if an URL is the one associated to the entity. False otherwise.\r\n    * @param self {object} - The data containing the entity mappings\r\n    * @param entityId {uint} - The id of the entity\r\n    * @param url {string} - The  URL\r\n    */\r\n  modifier isRegisteredURL(Data storage self, uint entityId, string url) {\r\n    require (self.entities[entityId].urlHash == sha256(url));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Returns True if current time is in renewal period for a valid entity. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to check \r\n   */\r\n  modifier isRenewalPeriod(Data storage self, uint entityId) {\r\n    EntityData storage entity = self.entities[entityId];\r\n    require (entity.renewalPeriod > 0 && entityId > 0 && (entity.expiration - entity.renewalPeriod < now) && entity.status == 2);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if sender is registered in entity. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity \r\n   */\r\n  modifier signerBelongsToEntity(Data storage self, uint entityId) {\r\n    EntityData storage entity = self.entities[entityId];\r\n    require (entityId > 0 && (bytes(entity.signers[msg.sender].signerDataHash).length != 0) && (entity.signers[msg.sender].status == 2));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if sender is registered in all the entities. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityIds {array} - The ids of the entities\r\n   */\r\n  modifier signerBelongsToEntities(Data storage self, uint[] entityIds) {\r\n    for (uint i = 0; i < entityIds.length; i++) {\r\n      uint entityId = entityIds[i];\r\n      EntityData storage entity = self.entities[entityId];\r\n      require (entityId > 0 && (entity.signers[msg.sender].status != 0));\r\n    }\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if the signer was not yet added to an entity.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity \r\n   * @param signerAddress {address} - The signer to check\r\n   */\r\n  modifier signerIsNotYetRegistered(Data storage self, uint entityId, address signerAddress) {\r\n    EntityData storage entity = self.entities[entityId];\r\n    require (entity.signers[signerAddress].status == 0);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if the entity is validated AND the signer has a pending update with a matching IPFS data hash\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity \r\n   * @param signerAddress {address} - The signer to check\r\n   * @param signerDataHash {string} - The signer IPFS data pending of confirmation\r\n   */\r\n  modifier signerUpdateCanBeAccepted(Data storage self, uint entityId, address signerAddress, string signerDataHash) {\r\n    require (isValid(self, entityId));\r\n    EntityData storage entity = self.entities[entityId];\r\n    string memory oldSignerDatHash = entity.signers[signerAddress].signerDataHash;\r\n    require (entity.signers[signerAddress].status == 3 && stringsEqual(oldSignerDatHash, signerDataHash));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if the sender is registered as a signer in entityId and the status is VALIDATION_PENDING. False otherwise.\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to check\r\n   */\r\n  modifier isWaitingConfirmation(Data storage self, uint entityId, string signerDataHash) {\r\n    EntityData storage entity = self.entities[entityId];\r\n    SignerData storage signer = entity.signers[msg.sender];\r\n    require ((bytes(signer.signerDataHash).length != 0) && (signer.status == 1) && stringsEqual(signer.signerDataHash, signerDataHash));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if the entity has not been closed\r\n   * @param self {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity to check\r\n   */\r\n  modifier isNotClosed(Data storage self, uint entityId) {\r\n    require(!isClosed(self, entityId));\r\n    _;\r\n  }\r\n\r\n  // EVENTS\r\n\r\n  event EntityCreated(uint indexed entityId);\r\n  event EntityValidated(uint indexed entityId);\r\n  event EntityDataUpdated(uint indexed entityId);\r\n  event EntityInvalid(uint indexed entityId);\r\n  event SignerAdded(uint indexed entityId, address indexed signerAddress);\r\n  event SignerDataUpdated(uint[] entities, address indexed signerAddress);\r\n  event SignerUpdateAccepted(uint indexed entityId, address indexed signerAddress);\r\n  event SignerRemoved(uint indexed entityId, address signerAddress);\r\n  event EntityClosed(uint indexed entityId);\r\n  event SignerConfirmed(uint indexed entityId, address signerAddress);\r\n  event EntityExpirationSet(uint indexed entityId);\r\n  event EntityRenewalSet(uint indexed entityId);  \r\n }\r\n\r\nlibrary SignLib {\r\n\r\n  // METHODS\r\n\r\n  /**\r\n   * Requests the signature for a certificate to an entity.\r\n   * Only one request possible (future ones are renewals)\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param cd {object} - The data containing the certificate mappings\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param entityId {uint} - The id of the entity\r\n   */\r\n  function requestSignatureToEntity(EntityLib.Data storage ed, CertsLib.Data storage cd, uint certificateId, uint entityId) canRequestSignature(ed, cd, certificateId) isValid(ed, entityId) notHasSigningRequest(cd, certificateId, entityId) public {\r\n    CertsLib.CertData storage certificate = cd.certificates[certificateId];\r\n    addMissingSignature(certificate, entityId, 0x1, 0);\r\n    EntitySignatureRequested(certificateId, entityId);\r\n  }\r\n\r\n  /**\r\n   * Requests the signature for a certificate to a peer\r\n   * Only one request possible (future ones are renewals)\r\n   * @param cd {object} - The data containing the certificate mappings\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param peer {address} - The address of the peer\r\n   */\r\n  function requestSignatureToPeer(EntityLib.Data storage ed, CertsLib.Data storage cd, uint certificateId, address peer) canRequestSignature(ed, cd, certificateId) notHasPeerSignature(cd, certificateId, peer) public {\r\n    CertsLib.CertData storage certificate = cd.certificates[certificateId];\r\n    addMissingPeerSignature(certificate, peer, 0x1, 0);\r\n    PeerSignatureRequested(certificateId, peer);\r\n  }\r\n\r\n    /**\r\n    * Entity signs a certificate with pending request\r\n    * @param ed {object} - The data containing the entity mappings\r\n    * @param cd {object} - The data containing the certificate mappings\r\n    * @param entityId {uint} - The id of the entity\r\n    * @param certificateId {uint} - The id of the certificate\r\n    * @param expiration {uint} - The expiration time of the signature (in seconds)\r\n    * @param _purpose {bytes32} - The sha-256 hash of the purpose data\r\n    */\r\n  function signCertificateAsEntity(EntityLib.Data storage ed, CertsLib.Data storage cd, uint entityId, uint certificateId, uint expiration, bytes32 _purpose) isValid(ed, entityId) signerBelongsToEntity(ed, entityId) hasPendingSignatureOrIsOwner(ed, cd, certificateId, entityId) public {\r\n    CertsLib.CertData storage certificate = cd.certificates[certificateId];\r\n    bytes32 purpose = (_purpose == 0x0 || _purpose == 0x1) ? bytes32(0x2) : _purpose;\r\n    addMissingSignature(certificate, entityId, purpose, expiration);\r\n    CertificateSignedByEntity(certificateId, entityId, msg.sender);\r\n  }\r\n\r\n  /**\r\n   * Peer signs a certificate with pending request\r\n   * @param cd {object} - The data containing the certificate mappings\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param expiration {uint} - The expiration time of the signature (in seconds)\r\n   * @param _purpose {bytes32} - The sha-256 hash of the purpose data\r\n   */\r\n  function signCertificateAsPeer(CertsLib.Data storage cd, uint certificateId, uint expiration, bytes32 _purpose) hasPendingPeerSignatureOrIsOwner(cd, certificateId) public {\r\n    CertsLib.CertData storage certificate = cd.certificates[certificateId];\r\n    bytes32 purpose = (_purpose == 0x0 || _purpose == 0x1) ? bytes32(0x2) : _purpose;\r\n    addMissingPeerSignature(certificate, msg.sender, purpose, expiration);\r\n    CertificateSignedByPeer(certificateId, msg.sender);\r\n  }\r\n\r\n  // HELPER FUNCTIONS\r\n\r\n  /**\r\n   * Add an entity signature to the entity signatures array (if missing) and set the specified status and expiration\r\n   * @param certificate {object} - The certificate to add the peer signature\r\n   * @param entityId {uint} - The id of the entity signing the certificate\r\n   * @param status {uint} - The status/purpose of the signature\r\n   * @param expiration {uint} - The expiration time of the signature (in seconds)\r\n   */\r\n  function addMissingSignature(CertsLib.CertData storage certificate, uint entityId, bytes32 status, uint expiration) private {\r\n    uint[] storage entitiesArr = certificate.entitiesArr;\r\n    for (uint i = 0; i < entitiesArr.length && entitiesArr[i] != entityId; i++) {}\r\n    if (i == entitiesArr.length) {\r\n      entitiesArr.push(entityId);\r\n    }\r\n    certificate.entities[entityId].status = status;\r\n    certificate.entities[entityId].exp = expiration;\r\n  }\r\n\r\n  /**\r\n   * Add a peer signature to the signatures array (if missing) and set the specified status and expiration\r\n   * @param certificate {object} - The certificate to add the peer signature\r\n   * @param peer {address} - The address of the peer to add signature\r\n   * @param status {uint} - The status/purpose of the signature\r\n   * @param expiration {uint} - The expiration time of the signature (in seconds)\r\n   */\r\n  function addMissingPeerSignature(CertsLib.CertData storage certificate, address peer, bytes32 status, uint expiration) private {\r\n    address[] storage signaturesArr = certificate.signaturesArr;\r\n    for (uint i = 0; i < signaturesArr.length && signaturesArr[i] != peer; i++) {}\r\n    if (i == signaturesArr.length) {\r\n      signaturesArr.push(peer);\r\n    }\r\n    certificate.signatures[peer].status = status;\r\n    certificate.signatures[peer].exp = expiration;\r\n  }\r\n\r\n  // MODIFIERS\r\n\r\n  /**\r\n   * Returns True if msg.sender is the owner of the specified certificate or the sender is a confirmed signer of certificate entity. False otherwise.\r\n   * @param cd {object} - The data containing the certificate mappings\r\n   * @param id {uint} - The id of the certificate\r\n   */\r\n  modifier canRequestSignature(EntityLib.Data storage ed, CertsLib.Data storage cd, uint id) {\r\n    require (cd.certificates[id].owner == msg.sender ||\r\n      (cd.certificates[id].entityId > 0 && EntityLib.isValid(ed, cd.certificates[id].entityId) && ed.entities[cd.certificates[id].entityId].signers[msg.sender].status == 0x2)\r\n    );\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Returns True if specified entity is validated or waiting to be renewed, not expired and not closed. False otherwise.\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param id {uint} - The id of the entity to check \r\n   */\r\n  modifier isValid(EntityLib.Data storage ed, uint id) {\r\n    require (EntityLib.isValid(ed, id));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * Returns True if specified certificate has not been validated yet by entity. False otherwise.\r\n   * @param cd {object} - The data containing the certificate mappings\r\n   * @param certificateId {uint} - The id of the certificate to check\r\n   * @param entityId {uint} - The id of the entity to check\r\n   */\r\n  modifier notHasSigningRequest(CertsLib.Data storage cd, uint certificateId, uint entityId) {\r\n    require (cd.certificates[certificateId].entities[entityId].status != 0x1);\r\n    _;    \r\n  }\r\n\r\n  /**\r\n   * Returns True if specified certificate has not been signed yet. False otherwise;   \r\n   * @param cd {object} - The data containing the certificate mappings\r\n   * @param certificateId {uint} - The id of the certificate to check\r\n   * @param signerAddress {address} - The id of the certificate to check\r\n   */\r\n  modifier notHasPeerSignature(CertsLib.Data storage cd, uint certificateId, address signerAddress) {    \r\n    require (cd.certificates[certificateId].signatures[signerAddress].status != 0x1);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if sender address is the owner of the entity or is a signer registered in entity. False otherwise.\r\n   * @param ed {object} - The data containing the entity mappings\r\n   * @param entityId {uint} - The id of the entity \r\n   */\r\n  modifier signerBelongsToEntity(EntityLib.Data storage ed, uint entityId) {\r\n    require (entityId > 0 && (bytes(ed.entities[entityId].signers[msg.sender].signerDataHash).length != 0) && (ed.entities[entityId].signers[msg.sender].status == 0x2));\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if a signature request has been sent to entity or the issuer of the certificate is requested entity itself. False otherwise.\r\n   * @param cd {object} - The data containing the certificate mappings\r\n   * @param certificateId {uint} - The id of the certificate to check\r\n   * @param entityId {uint} - The id of the entity to check\r\n   */\r\n  modifier hasPendingSignatureOrIsOwner(EntityLib.Data storage ed, CertsLib.Data storage cd, uint certificateId, uint entityId) {\r\n    require (cd.certificates[certificateId].entities[entityId].status == 0x1 || cd.certificates[certificateId].entityId == entityId);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * True if a signature is pending for the sender or the sender is the owner. False otherwise.\r\n   * @param cd {object} - The data containing the certificate mappings\r\n   * @param certificateId {uint} - The id of the certificate to check\r\n   */\r\n  modifier hasPendingPeerSignatureOrIsOwner(CertsLib.Data storage cd, uint certificateId) {\r\n    require (cd.certificates[certificateId].signatures[msg.sender].status == 0x1 || cd.certificates[certificateId].owner == msg.sender);\r\n    _;\r\n  }\r\n\r\n  // EVENTS\r\n  event EntitySignatureRequested(uint indexed certificateId, uint indexed entityId);\r\n  event PeerSignatureRequested(uint indexed certificateId, address indexed signerAddress);\r\n  event CertificateSignedByEntity(uint indexed certificateId, uint indexed entityId, address indexed signerAddress);\r\n  event CertificateSignedByPeer(uint indexed certificateId, address indexed signerAddress);\r\n}\r\n\r\ncontract OraclizeI {\r\n    address public cbAddress;\r\n    function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id);\r\n    function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id);\r\n    function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id);\r\n    function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id);\r\n    function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id);\r\n    function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id);\r\n    function getPrice(string _datasource) returns (uint _dsprice);\r\n    function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice);\r\n    function useCoupon(string _coupon);\r\n    function setProofType(byte _proofType);\r\n    function setConfig(bytes32 _config);\r\n    function setCustomGasPrice(uint _gasPrice);\r\n    function randomDS_getSessionPubKeyHash() returns(bytes32);\r\n}\r\n\r\ncontract OraclizeAddrResolverI {\r\n    function getAddress() returns (address _addr);\r\n}\r\n\r\nlibrary Buffer {\r\n    struct buffer {\r\n        bytes buf;\r\n        uint capacity;\r\n    }\r\n\r\n    function init(buffer memory buf, uint capacity) internal constant {\r\n        if(capacity % 32 != 0) capacity += 32 - (capacity % 32);\r\n        // Allocate space for the buffer data\r\n        buf.capacity = capacity;\r\n        assembly {\r\n            let ptr := mload(0x40)\r\n            mstore(buf, ptr)\r\n            mstore(0x40, add(ptr, capacity))\r\n        }\r\n    }\r\n\r\n    function resize(buffer memory buf, uint capacity) private constant {\r\n        bytes memory oldbuf = buf.buf;\r\n        init(buf, capacity);\r\n        append(buf, oldbuf);\r\n    }\r\n\r\n    function max(uint a, uint b) private constant returns(uint) {\r\n        if(a > b) {\r\n            return a;\r\n        }\r\n        return b;\r\n    }\r\n\r\n    /**\r\n     * @dev Appends a byte array to the end of the buffer. Reverts if doing so\r\n     *      would exceed the capacity of the buffer.\r\n     * @param buf The buffer to append to.\r\n     * @param data The data to append.\r\n     * @return The original buffer.\r\n     */\r\n    function append(buffer memory buf, bytes data) internal constant returns(buffer memory) {\r\n        if(data.length + buf.buf.length > buf.capacity) {\r\n            resize(buf, max(buf.capacity, data.length) * 2);\r\n        }\r\n\r\n        uint dest;\r\n        uint src;\r\n        uint len = data.length;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Start address = buffer address + buffer length + sizeof(buffer length)\r\n            dest := add(add(bufptr, buflen), 32)\r\n            // Update buffer length\r\n            mstore(bufptr, add(buflen, mload(data)))\r\n            src := add(data, 32)\r\n        }\r\n\r\n        // Copy word-length chunks while possible\r\n        for(; len >= 32; len -= 32) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += 32;\r\n            src += 32;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint mask = 256 ** (32 - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n\r\n        return buf;\r\n    }\r\n\r\n    /**\r\n     * @dev Appends a byte to the end of the buffer. Reverts if doing so would\r\n     * exceed the capacity of the buffer.\r\n     * @param buf The buffer to append to.\r\n     * @param data The data to append.\r\n     * @return The original buffer.\r\n     */\r\n    function append(buffer memory buf, uint8 data) internal constant {\r\n        if(buf.buf.length + 1 > buf.capacity) {\r\n            resize(buf, buf.capacity * 2);\r\n        }\r\n\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + buffer length + sizeof(buffer length)\r\n            let dest := add(add(bufptr, buflen), 32)\r\n            mstore8(dest, data)\r\n            // Update buffer length\r\n            mstore(bufptr, add(buflen, 1))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Appends a byte to the end of the buffer. Reverts if doing so would\r\n     * exceed the capacity of the buffer.\r\n     * @param buf The buffer to append to.\r\n     * @param data The data to append.\r\n     * @return The original buffer.\r\n     */\r\n    function appendInt(buffer memory buf, uint data, uint len) internal constant returns(buffer memory) {\r\n        if(len + buf.buf.length > buf.capacity) {\r\n            resize(buf, max(buf.capacity, len) * 2);\r\n        }\r\n\r\n        uint mask = 256 ** len - 1;\r\n        assembly {\r\n            // Memory address of the buffer data\r\n            let bufptr := mload(buf)\r\n            // Length of existing buffer data\r\n            let buflen := mload(bufptr)\r\n            // Address = buffer address + buffer length + sizeof(buffer length) + len\r\n            let dest := add(add(bufptr, buflen), len)\r\n            mstore(dest, or(and(mload(dest), not(mask)), data))\r\n            // Update buffer length\r\n            mstore(bufptr, add(buflen, len))\r\n        }\r\n        return buf;\r\n    }\r\n}\r\n\r\nlibrary CBOR {\r\n    using Buffer for Buffer.buffer;\r\n\r\n    uint8 private constant MAJOR_TYPE_INT = 0;\r\n    uint8 private constant MAJOR_TYPE_NEGATIVE_INT = 1;\r\n    uint8 private constant MAJOR_TYPE_BYTES = 2;\r\n    uint8 private constant MAJOR_TYPE_STRING = 3;\r\n    uint8 private constant MAJOR_TYPE_ARRAY = 4;\r\n    uint8 private constant MAJOR_TYPE_MAP = 5;\r\n    uint8 private constant MAJOR_TYPE_CONTENT_FREE = 7;\r\n\r\n    function shl8(uint8 x, uint8 y) private constant returns (uint8) {\r\n        return x * (2 ** y);\r\n    }\r\n\r\n    function encodeType(Buffer.buffer memory buf, uint8 major, uint value) private constant {\r\n        if(value <= 23) {\r\n            buf.append(uint8(shl8(major, 5) | value));\r\n        } else if(value <= 0xFF) {\r\n            buf.append(uint8(shl8(major, 5) | 24));\r\n            buf.appendInt(value, 1);\r\n        } else if(value <= 0xFFFF) {\r\n            buf.append(uint8(shl8(major, 5) | 25));\r\n            buf.appendInt(value, 2);\r\n        } else if(value <= 0xFFFFFFFF) {\r\n            buf.append(uint8(shl8(major, 5) | 26));\r\n            buf.appendInt(value, 4);\r\n        } else if(value <= 0xFFFFFFFFFFFFFFFF) {\r\n            buf.append(uint8(shl8(major, 5) | 27));\r\n            buf.appendInt(value, 8);\r\n        }\r\n    }\r\n\r\n    function encodeIndefiniteLengthType(Buffer.buffer memory buf, uint8 major) private constant {\r\n        buf.append(uint8(shl8(major, 5) | 31));\r\n    }\r\n\r\n    function encodeUInt(Buffer.buffer memory buf, uint value) internal constant {\r\n        encodeType(buf, MAJOR_TYPE_INT, value);\r\n    }\r\n\r\n    function encodeInt(Buffer.buffer memory buf, int value) internal constant {\r\n        if(value >= 0) {\r\n            encodeType(buf, MAJOR_TYPE_INT, uint(value));\r\n        } else {\r\n            encodeType(buf, MAJOR_TYPE_NEGATIVE_INT, uint(-1 - value));\r\n        }\r\n    }\r\n\r\n    function encodeBytes(Buffer.buffer memory buf, bytes value) internal constant {\r\n        encodeType(buf, MAJOR_TYPE_BYTES, value.length);\r\n        buf.append(value);\r\n    }\r\n\r\n    function encodeString(Buffer.buffer memory buf, string value) internal constant {\r\n        encodeType(buf, MAJOR_TYPE_STRING, bytes(value).length);\r\n        buf.append(bytes(value));\r\n    }\r\n\r\n    function startArray(Buffer.buffer memory buf) internal constant {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_ARRAY);\r\n    }\r\n\r\n    function startMap(Buffer.buffer memory buf) internal constant {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_MAP);\r\n    }\r\n\r\n    function endSequence(Buffer.buffer memory buf) internal constant {\r\n        encodeIndefiniteLengthType(buf, MAJOR_TYPE_CONTENT_FREE);\r\n    }\r\n}\r\n\r\ncontract usingOraclize {\r\n    uint constant day = 60*60*24;\r\n    uint constant week = 60*60*24*7;\r\n    uint constant month = 60*60*24*30;\r\n    byte constant proofType_NONE = 0x00;\r\n    byte constant proofType_TLSNotary = 0x10;\r\n    byte constant proofType_Android = 0x20;\r\n    byte constant proofType_Ledger = 0x30;\r\n    byte constant proofType_Native = 0xF0;\r\n    byte constant proofStorage_IPFS = 0x01;\r\n    uint8 constant networkID_auto = 0;\r\n    uint8 constant networkID_mainnet = 1;\r\n    uint8 constant networkID_testnet = 2;\r\n    uint8 constant networkID_morden = 2;\r\n    uint8 constant networkID_consensys = 161;\r\n\r\n    OraclizeAddrResolverI OAR;\r\n\r\n    OraclizeI oraclize;\r\n    modifier oraclizeAPI {\r\n        if((address(OAR)==0)||(getCodeSize(address(OAR))==0))\r\n            oraclize_setNetwork(networkID_auto);\r\n\r\n        if(address(oraclize) != OAR.getAddress())\r\n            oraclize = OraclizeI(OAR.getAddress());\r\n\r\n        _;\r\n    }\r\n    modifier coupon(string code){\r\n        oraclize = OraclizeI(OAR.getAddress());\r\n        oraclize.useCoupon(code);\r\n        _;\r\n    }\r\n\r\n    function oraclize_setNetwork(uint8 networkID) internal returns(bool){\r\n        if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet\r\n            OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed);\r\n            oraclize_setNetworkName(\"eth_mainnet\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet\r\n            OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1);\r\n            oraclize_setNetworkName(\"eth_ropsten3\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet\r\n            OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e);\r\n            oraclize_setNetworkName(\"eth_kovan\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet\r\n            OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48);\r\n            oraclize_setNetworkName(\"eth_rinkeby\");\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge\r\n            OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide\r\n            OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF);\r\n            return true;\r\n        }\r\n        if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity\r\n            OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function __callback(bytes32 myid, string result) {\r\n        __callback(myid, result, new bytes(0));\r\n    }\r\n    function __callback(bytes32 myid, string result, bytes proof) {\r\n    }\r\n\r\n    function oraclize_useCoupon(string code) oraclizeAPI internal {\r\n        oraclize.useCoupon(code);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource);\r\n    }\r\n\r\n    function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){\r\n        return oraclize.getPrice(datasource, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(0, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query.value(price)(timestamp, datasource, arg);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(0, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = stra2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        string[] memory dynargs = new string[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(0, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource);\r\n        if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN.value(price)(timestamp, datasource, args);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){\r\n        uint price = oraclize.getPrice(datasource, gaslimit);\r\n        if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price\r\n        bytes memory args = ba2cbor(argN);\r\n        return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](1);\r\n        dynargs[0] = args[0];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](2);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](3);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](4);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs);\r\n    }\r\n    function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(timestamp, datasource, dynargs, gaslimit);\r\n    }\r\n    function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) {\r\n        bytes[] memory dynargs = new bytes[](5);\r\n        dynargs[0] = args[0];\r\n        dynargs[1] = args[1];\r\n        dynargs[2] = args[2];\r\n        dynargs[3] = args[3];\r\n        dynargs[4] = args[4];\r\n        return oraclize_query(datasource, dynargs, gaslimit);\r\n    }\r\n\r\n    function oraclize_cbAddress() oraclizeAPI internal returns (address){\r\n        return oraclize.cbAddress();\r\n    }\r\n    function oraclize_setProof(byte proofP) oraclizeAPI internal {\r\n        return oraclize.setProofType(proofP);\r\n    }\r\n    function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal {\r\n        return oraclize.setCustomGasPrice(gasPrice);\r\n    }\r\n    function oraclize_setConfig(bytes32 config) oraclizeAPI internal {\r\n        return oraclize.setConfig(config);\r\n    }\r\n\r\n    function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){\r\n        return oraclize.randomDS_getSessionPubKeyHash();\r\n    }\r\n\r\n    function getCodeSize(address _addr) constant internal returns(uint _size) {\r\n        assembly {\r\n            _size := extcodesize(_addr)\r\n        }\r\n    }\r\n\r\n    function parseAddr(string _a) internal returns (address){\r\n        bytes memory tmp = bytes(_a);\r\n        uint160 iaddr = 0;\r\n        uint160 b1;\r\n        uint160 b2;\r\n        for (uint i=2; i<2+2*20; i+=2){\r\n            iaddr *= 256;\r\n            b1 = uint160(tmp[i]);\r\n            b2 = uint160(tmp[i+1]);\r\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\r\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\r\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\r\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\r\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\r\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\r\n            iaddr += (b1*16+b2);\r\n        }\r\n        return address(iaddr);\r\n    }\r\n\r\n    function strCompare(string _a, string _b) internal returns (int) {\r\n        bytes memory a = bytes(_a);\r\n        bytes memory b = bytes(_b);\r\n        uint minLength = a.length;\r\n        if (b.length < minLength) minLength = b.length;\r\n        for (uint i = 0; i < minLength; i ++)\r\n            if (a[i] < b[i])\r\n                return -1;\r\n            else if (a[i] > b[i])\r\n                return 1;\r\n        if (a.length < b.length)\r\n            return -1;\r\n        else if (a.length > b.length)\r\n            return 1;\r\n        else\r\n            return 0;\r\n    }\r\n\r\n    function indexOf(string _haystack, string _needle) internal returns (int) {\r\n        bytes memory h = bytes(_haystack);\r\n        bytes memory n = bytes(_needle);\r\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\r\n            return -1;\r\n        else if(h.length > (2**128 -1))\r\n            return -1;\r\n        else\r\n        {\r\n            uint subindex = 0;\r\n            for (uint i = 0; i < h.length; i ++)\r\n            {\r\n                if (h[i] == n[0])\r\n                {\r\n                    subindex = 1;\r\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\r\n                    {\r\n                        subindex++;\r\n                    }\r\n                    if(subindex == n.length)\r\n                        return int(i);\r\n                }\r\n            }\r\n            return -1;\r\n        }\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) {\r\n        bytes memory _ba = bytes(_a);\r\n        bytes memory _bb = bytes(_b);\r\n        bytes memory _bc = bytes(_c);\r\n        bytes memory _bd = bytes(_d);\r\n        bytes memory _be = bytes(_e);\r\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\r\n        bytes memory babcde = bytes(abcde);\r\n        uint k = 0;\r\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\r\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\r\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\r\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\r\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\r\n        return string(babcde);\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c, string _d) internal returns (string) {\r\n        return strConcat(_a, _b, _c, _d, \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b, string _c) internal returns (string) {\r\n        return strConcat(_a, _b, _c, \"\", \"\");\r\n    }\r\n\r\n    function strConcat(string _a, string _b) internal returns (string) {\r\n        return strConcat(_a, _b, \"\", \"\", \"\");\r\n    }\r\n\r\n    // parseInt\r\n    function parseInt(string _a) internal returns (uint) {\r\n        return parseInt(_a, 0);\r\n    }\r\n\r\n    // parseInt(parseFloat*10^_b)\r\n    function parseInt(string _a, uint _b) internal returns (uint) {\r\n        bytes memory bresult = bytes(_a);\r\n        uint mint = 0;\r\n        bool decimals = false;\r\n        for (uint i=0; i<bresult.length; i++){\r\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\r\n                if (decimals){\r\n                   if (_b == 0) break;\r\n                    else _b--;\r\n                }\r\n                mint *= 10;\r\n                mint += uint(bresult[i]) - 48;\r\n            } else if (bresult[i] == 46) decimals = true;\r\n        }\r\n        if (_b > 0) mint *= 10**_b;\r\n        return mint;\r\n    }\r\n\r\n    function uint2str(uint i) internal returns (string){\r\n        if (i == 0) return \"0\";\r\n        uint j = i;\r\n        uint len;\r\n        while (j != 0){\r\n            len++;\r\n            j /= 10;\r\n        }\r\n        bytes memory bstr = new bytes(len);\r\n        uint k = len - 1;\r\n        while (i != 0){\r\n            bstr[k--] = byte(48 + i % 10);\r\n            i /= 10;\r\n        }\r\n        return string(bstr);\r\n    }\r\n\r\n    using CBOR for Buffer.buffer;\r\n    function stra2cbor(string[] arr) internal constant returns (bytes) {\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i < arr.length; i++) {\r\n            buf.encodeString(arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    function ba2cbor(bytes[] arr) internal constant returns (bytes) {\r\n        Buffer.buffer memory buf;\r\n        Buffer.init(buf, 1024);\r\n        buf.startArray();\r\n        for (uint i = 0; i < arr.length; i++) {\r\n            buf.encodeBytes(arr[i]);\r\n        }\r\n        buf.endSequence();\r\n        return buf.buf;\r\n    }\r\n\r\n    string oraclize_network_name;\r\n    function oraclize_setNetworkName(string _network_name) internal {\r\n        oraclize_network_name = _network_name;\r\n    }\r\n\r\n    function oraclize_getNetworkName() internal returns (string) {\r\n        return oraclize_network_name;\r\n    }\r\n\r\n    function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){\r\n        if ((_nbytes == 0)||(_nbytes > 32)) throw;\r\n\t// Convert from seconds to ledger timer ticks\r\n        _delay *= 10;\r\n        bytes memory nbytes = new bytes(1);\r\n        nbytes[0] = byte(_nbytes);\r\n        bytes memory unonce = new bytes(32);\r\n        bytes memory sessionKeyHash = new bytes(32);\r\n        bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash();\r\n        assembly {\r\n            mstore(unonce, 0x20)\r\n            // the following variables can be relaxed\r\n            // check relaxed random contract under ethereum-examples repo\r\n            // for an idea on how to override and replace comit hash vars\r\n            mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp)))\r\n            mstore(sessionKeyHash, 0x20)\r\n            mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32)\r\n        }\r\n        bytes memory delay = new bytes(32);\r\n        assembly {\r\n            mstore(add(delay, 0x20), _delay)\r\n        }\r\n\r\n        bytes memory delay_bytes8 = new bytes(8);\r\n        copyBytes(delay, 24, 8, delay_bytes8, 0);\r\n\r\n        bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay];\r\n        bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit);\r\n\r\n        bytes memory delay_bytes8_left = new bytes(8);\r\n\r\n        assembly {\r\n            let x := mload(add(delay_bytes8, 0x20))\r\n            mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000))\r\n            mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000))\r\n\r\n        }\r\n\r\n        oraclize_randomDS_setCommitment(queryId, sha3(delay_bytes8_left, args[1], sha256(args[0]), args[2]));\r\n        return queryId;\r\n    }\r\n\r\n    function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal {\r\n        oraclize_randomDS_args[queryId] = commitment;\r\n    }\r\n\r\n    mapping(bytes32=>bytes32) oraclize_randomDS_args;\r\n    mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified;\r\n\r\n    function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){\r\n        bool sigok;\r\n        address signer;\r\n\r\n        bytes32 sigr;\r\n        bytes32 sigs;\r\n\r\n        bytes memory sigr_ = new bytes(32);\r\n        uint offset = 4+(uint(dersig[3]) - 0x20);\r\n        sigr_ = copyBytes(dersig, offset, 32, sigr_, 0);\r\n        bytes memory sigs_ = new bytes(32);\r\n        offset += 32 + 2;\r\n        sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0);\r\n\r\n        assembly {\r\n            sigr := mload(add(sigr_, 32))\r\n            sigs := mload(add(sigs_, 32))\r\n        }\r\n\r\n\r\n        (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs);\r\n        if (address(sha3(pubkey)) == signer) return true;\r\n        else {\r\n            (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs);\r\n            return (address(sha3(pubkey)) == signer);\r\n        }\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) {\r\n        bool sigok;\r\n\r\n        // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH)\r\n        bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2);\r\n        copyBytes(proof, sig2offset, sig2.length, sig2, 0);\r\n\r\n        bytes memory appkey1_pubkey = new bytes(64);\r\n        copyBytes(proof, 3+1, 64, appkey1_pubkey, 0);\r\n\r\n        bytes memory tosign2 = new bytes(1+65+32);\r\n        tosign2[0] = 1; //role\r\n        copyBytes(proof, sig2offset-65, 65, tosign2, 1);\r\n        bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\";\r\n        copyBytes(CODEHASH, 0, 32, tosign2, 1+65);\r\n        sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey);\r\n\r\n        if (sigok == false) return false;\r\n\r\n\r\n        // Step 7: verify the APPKEY1 provenance (must be signed by Ledger)\r\n        bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\";\r\n\r\n        bytes memory tosign3 = new bytes(1+65);\r\n        tosign3[0] = 0xFE;\r\n        copyBytes(proof, 3, 65, tosign3, 1);\r\n\r\n        bytes memory sig3 = new bytes(uint(proof[3+65+1])+2);\r\n        copyBytes(proof, 3+65, sig3.length, sig3, 0);\r\n\r\n        sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY);\r\n\r\n        return sigok;\r\n    }\r\n\r\n    modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) {\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw;\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        if (proofVerified == false) throw;\r\n\r\n        _;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){\r\n        // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1)\r\n        if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1;\r\n\r\n        bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName());\r\n        if (proofVerified == false) return 2;\r\n\r\n        return 0;\r\n    }\r\n\r\n    function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal returns (bool){\r\n        bool match_ = true;\r\n\r\n\tif (prefix.length != n_random_bytes) throw;\r\n\r\n        for (uint256 i=0; i< n_random_bytes; i++) {\r\n            if (content[i] != prefix[i]) match_ = false;\r\n        }\r\n\r\n        return match_;\r\n    }\r\n\r\n    function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){\r\n\r\n        // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId)\r\n        uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32;\r\n        bytes memory keyhash = new bytes(32);\r\n        copyBytes(proof, ledgerProofLength, 32, keyhash, 0);\r\n        if (!(sha3(keyhash) == sha3(sha256(context_name, queryId)))) return false;\r\n\r\n        bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2);\r\n        copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0);\r\n\r\n        // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1)\r\n        if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false;\r\n\r\n        // Step 4: commitment match verification, sha3(delay, nbytes, unonce, sessionKeyHash) == commitment in storage.\r\n        // This is to verify that the computed args match with the ones specified in the query.\r\n        bytes memory commitmentSlice1 = new bytes(8+1+32);\r\n        copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0);\r\n\r\n        bytes memory sessionPubkey = new bytes(64);\r\n        uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65;\r\n        copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0);\r\n\r\n        bytes32 sessionPubkeyHash = sha256(sessionPubkey);\r\n        if (oraclize_randomDS_args[queryId] == sha3(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match\r\n            delete oraclize_randomDS_args[queryId];\r\n        } else return false;\r\n\r\n\r\n        // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey)\r\n        bytes memory tosign1 = new bytes(32+8+1+32);\r\n        copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0);\r\n        if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false;\r\n\r\n        // verify if sessionPubkeyHash was verified already, if not.. let's do it!\r\n        if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){\r\n            oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset);\r\n        }\r\n\r\n        return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash];\r\n    }\r\n\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) {\r\n        uint minLength = length + toOffset;\r\n\r\n        if (to.length < minLength) {\r\n            // Buffer too small\r\n            throw; // Should be a better way?\r\n        }\r\n\r\n        // NOTE: the offset 32 is added to skip the `size` field of both bytes variables\r\n        uint i = 32 + fromOffset;\r\n        uint j = 32 + toOffset;\r\n\r\n        while (i < (32 + fromOffset + length)) {\r\n            assembly {\r\n                let tmp := mload(add(from, i))\r\n                mstore(add(to, j), tmp)\r\n            }\r\n            i += 32;\r\n            j += 32;\r\n        }\r\n\r\n        return to;\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    // Duplicate Solidity's ecrecover, but catching the CALL return value\r\n    function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) {\r\n        // We do our own memory management here. Solidity uses memory offset\r\n        // 0x40 to store the current end of memory. We write past it (as\r\n        // writes are memory extensions), but don't update the offset so\r\n        // Solidity will reuse it. The memory used here is only needed for\r\n        // this context.\r\n\r\n        // FIXME: inline assembly can't access return values\r\n        bool ret;\r\n        address addr;\r\n\r\n        assembly {\r\n            let size := mload(0x40)\r\n            mstore(size, hash)\r\n            mstore(add(size, 32), v)\r\n            mstore(add(size, 64), r)\r\n            mstore(add(size, 96), s)\r\n\r\n            // NOTE: we can reuse the request memory because we deal with\r\n            //       the return code\r\n            ret := call(3000, 1, 0, size, 128, size, 32)\r\n            addr := mload(size)\r\n        }\r\n\r\n        return (ret, addr);\r\n    }\r\n\r\n    // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license\r\n    function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) {\r\n        bytes32 r;\r\n        bytes32 s;\r\n        uint8 v;\r\n\r\n        if (sig.length != 65)\r\n          return (false, 0);\r\n\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        assembly {\r\n            r := mload(add(sig, 32))\r\n            s := mload(add(sig, 64))\r\n\r\n            // Here we are loading the last 32 bytes. We exploit the fact that\r\n            // 'mload' will pad with zeroes if we overread.\r\n            // There is no 'mload8' to do this, but that would be nicer.\r\n            v := byte(0, mload(add(sig, 96)))\r\n\r\n            // Alternative solution:\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            // v := and(mload(add(sig, 65)), 255)\r\n        }\r\n\r\n        // albeit non-transactional signatures are not specified by the YP, one would expect it\r\n        // to match the YP range of [27, 28]\r\n        //\r\n        // geth uses [0, 1] and some clients have followed. This might change, see:\r\n        //  https://github.com/ethereum/go-ethereum/issues/2053\r\n        if (v < 27)\r\n          v += 27;\r\n\r\n        if (v != 27 && v != 28)\r\n            return (false, 0);\r\n\r\n        return safer_ecrecover(hash, v, r, s);\r\n    }\r\n\r\n}\r\n\r\ncontract Ethertify is usingOraclize {\r\n  EntityLib.Data ed;\r\n  CertsLib.Data cd;\r\n\r\n  /** \r\n   * Creates a contract\r\n   */\r\n  function Ethertify() public {\r\n    ed.nEntities = 0;\r\n    cd.nCerts = 0;\r\n  }\r\n\r\n  // MODIFIERS\r\n\r\n /**\r\n   * True if the method is executed by oraclize. False otherwise.\r\n   */\r\n  modifier isOraclize() {\r\n    require (msg.sender == oraclize_cbAddress());\r\n    _;\r\n  }\r\n\r\n  // ENTITY METHODS\r\n\r\n  /**\r\n   * Creates a new entity\r\n   * @param entityHash {string} - The ipfs multihash address of the entity information in json format\r\n   * @param urlHash {bytes32} - The sha256 hash of the URL of the entityç\r\n   * @param expirationDate {uint} - The expiration date of the current entity\r\n   * @param renewalPeriod {uint} - The time period which will be added to the current date or expiration date when a renewal is requested\r\n   * @return {uint} The id of the created entity\r\n   */\r\n  function createSigningEntity(string entityHash, bytes32 urlHash, uint expirationDate, uint renewalPeriod) public returns (uint) {\r\n    uint entityId = ++ed.nEntities;\r\n    EntityLib.create(ed, entityId, entityHash, urlHash, expirationDate, renewalPeriod);      \r\n    return entityId;\r\n  }\r\n\r\n  /**\r\n   * Sets a new expiration date for the entity. It will trigger an entity validation through the oracle, so it must be paid\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param expirationDate {uint} - The new expiration date of the entity\r\n   * @param url {string} - The URL of the entity (for validation through the oracle)\r\n   * @param oraclizeGas {uint} - The maximum gas to use during the oraclize callback execution. Will default to 90000 if not provided.\r\n   * @param oraclizeGasPrice {uint} - The gas price to use during the oraclize callback invocation.\r\n   * @return {bytes32} - The id of the oraclize query\r\n   */\r\n  function setExpiration(uint entityId, uint expirationDate, string url, uint oraclizeGas, uint oraclizeGasPrice) public payable returns (bytes32) {\r\n    EntityLib.setExpiration(ed, entityId, expirationDate);\r\n    return validateSigningEntity(entityId, url, oraclizeGas, oraclizeGasPrice);\r\n  }\r\n  \r\n  /**\r\n   * Sets a new renewal interval\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param renewalPeriod {uint} - The new renewal interval (in seconds)\r\n   */\r\n  function setRenewalPeriod (uint entityId, uint renewalPeriod) public {\r\n    EntityLib.setRenewalPeriod(ed, entityId, renewalPeriod);\r\n  }\r\n\r\n\r\n  /**\r\n   * Requests the validation of a signing entity\r\n   * @param entityId {uint} - The id of the entity to validate\r\n   * @param url {string} - The URL of the entity\r\n   * @param oraclizeGas {uint} - The maximum gas to use during the oraclize callback execution. Will default to 90000 if not provided.\r\n   * @param oraclizeGasPrice {uint} - The gas price to use during the oraclize callback invocation.\r\n   * @return {bytes32} - The id of the oraclize query\r\n   */\r\n  function validateSigningEntity(uint entityId, string url, uint oraclizeGas, uint oraclizeGasPrice) public payable returns (bytes32) {\r\n    uint maxGas = oraclizeGas == 0 ? 88000 : oraclizeGas; // 67000 gas from the process validation callback + 21000 for the transfer\r\n    \r\n    if (EntityLib.canValidateSigningEntity(ed, entityId, url)) {\r\n      oraclize_setCustomGasPrice(oraclizeGasPrice);\r\n      uint queryCost = oraclize_getPrice(\"URL\", maxGas);\r\n      if (queryCost > msg.value) {\r\n        OraclizeNotEnoughFunds(entityId, queryCost);\r\n        return 0;\r\n      }\r\n\r\n      string memory query = strConcat(\"html(\", url, \").xpath(/html/head/meta[@name='ethertify-entity']/@content)\");\r\n      bytes32 queryId = oraclize_query(\"URL\", query, maxGas);\r\n      ed.entityIds[queryId] = entityId;\r\n      EntityLib.setOraclizeQueryId(ed, entityId, queryId);\r\n      return queryId;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Updates entity data\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param entityHash {string} - The ipfs multihash address of the entity information in json format\r\n   * @param urlHash {bytes32} - The sha256 hash of the URL of the entity\r\n   * @param oraclizeGas {uint} - The maximum gas to use during the oraclize callback execution. Will default to 90000 if not provided.\r\n   * @param oraclizeGasPrice {uint} - The gas price to use during the oraclize callback invocation.\r\n   * @param url {string} - The url used during the validation (after setting the data)\r\n   */\r\n  function updateEntityData(uint entityId, string entityHash, bytes32 urlHash, string url, uint oraclizeGas, uint oraclizeGasPrice) public payable {\r\n    EntityLib.updateEntityData(ed, entityId, entityHash, urlHash);\r\n    validateSigningEntity(entityId, url, oraclizeGas, oraclizeGasPrice);\r\n  }\r\n\r\n  /**\r\n   * Update the signer data in the requestes entities\r\n   * @param entityIds {array} - The ids of the entities to update\r\n   * @param signerDataHash {string} - The ipfs multihash of the new signer data\r\n   */\r\n  function updateSignerData(uint[] entityIds, string signerDataHash) public {\r\n    EntityLib.updateSignerData(ed, entityIds, signerDataHash);\r\n  }\r\n\r\n  /**\r\n   * Accepts a new signer data update in the entity\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer update to be accepted\r\n   * @param signerDataHash {uint} - The IPFS multihash address of signer information in json format to be accepted\r\n   */\r\n  function acceptSignerUpdate(uint entityId, address signerAddress, string signerDataHash) public {\r\n    EntityLib.acceptSignerUpdate(ed, entityId, signerAddress, signerDataHash);\r\n  }\r\n\r\n  /**\r\n   * Requests the renewal of a signing entity\r\n   * @param entityId {uint} - The id of the entity to validate\r\n   * @param url {string} - The URL of the entity\r\n   * @param oraclizeGas {uint} - The maximum gas to use during the oraclize callback execution. Will default to 90000 if not provided.\r\n   * @param oraclizeGasPrice {uint} - The gas price to use during the oraclize callback invocation.\r\n   * @return {bytes32} - The id of the oraclize query\r\n   */\r\n  function requestRenewal(uint entityId, string url, uint oraclizeGas, uint oraclizeGasPrice) public payable returns (bytes32) {\r\n    if (EntityLib.canRenew(ed, entityId, url)) {\r\n      ed.entities[entityId].status = 4;\r\n      return validateSigningEntity(entityId, url, oraclizeGas, oraclizeGasPrice); \r\n    }\r\n  }\r\n\r\n  /**\r\n   * Close an entity. This status will not allow further operations on the entity.\r\n   * @param entityId {uint} - The id of the entity\r\n   */\r\n  function closeEntity(uint entityId) public {\r\n    EntityLib.closeEntity(ed, entityId);\r\n  }\r\n  \r\n  /**\r\n   * Executes automatically when oraclize query is finished\r\n   * @param queryId {bytes32} - The id of the oraclize query (returned by the call to oraclize_query method)\r\n   * @param result {string} - The result of the query\r\n   */\r\n  function __callback(bytes32 queryId, string result) isOraclize() public {\r\n    EntityLib.processValidation(ed, queryId, result);\r\n  }\r\n\r\n  /**\r\n   * Registers a new signer in an entity\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer to be registered\r\n   * @param signerDataHash {uint} - The IPFS multihash address of signer information in json format\r\n   */\r\n  function registerSigner(uint entityId, address signerAddress, string signerDataHash) public {\r\n    EntityLib.registerSigner(ed, entityId, signerAddress, signerDataHash);\r\n  }\r\n\r\n  /**\r\n   * Removes a signer from an entity\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer to be removed\r\n   */\r\n  function removeSigner(uint entityId, address signerAddress) public {\r\n    EntityLib.removeSigner(ed, entityId, signerAddress);\r\n  }\r\n\r\n  /**\r\n   * Leave the specified entity (remove signer if found)\r\n   * @param entityId {uint} - The id of the entity\r\n   */\r\n  function leaveEntity(uint entityId) public {\r\n    EntityLib.leaveEntity(ed, entityId);\r\n  }\r\n\r\n  /**\r\n   * Confirms signer registration\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerDataHash {string} - The ipfs data hash of the signer to confirm\r\n   */\r\n  function confirmSignerRegistration(uint entityId, string signerDataHash) public {\r\n    EntityLib.confirmSignerRegistration(ed, entityId, signerDataHash);\r\n  }\r\n\r\n  // CERTIFICATE METHODS\r\n\r\n  /**\r\n   * Creates a new POE certificate\r\n   * @param dataHash {bytes32} - The hash of the certified data\r\n   * @param certHash {bytes32} - The sha256 hash of the json certificate\r\n   * @param ipfsDataHash {string} - The ipfs multihash address of the data (0x00 means unkwon)\r\n   * @param ipfsCertHash {string} - The ipfs multihash address of the certificate in json format (0x00 means unkwon)\r\n   * @return The id of the created certificate     \r\n   */\r\n  function createPOECertificate(bytes32 dataHash, bytes32 certHash, string ipfsDataHash, string ipfsCertHash) public returns (uint) {\r\n    return CertsLib.createPOECertificate(cd, dataHash, certHash, ipfsDataHash, ipfsCertHash);\r\n  }\r\n  \r\n  /**\r\n   * Creates a new certificate (with known owner)\r\n   * @param dataHash {bytes32} - The hash of the certified data\r\n   * @param certHash {bytes32} - The sha256 hash of the json certificate\r\n   * @param ipfsDataHash {string} - The ipfs multihash address of the data (0x00 means unkwon)\r\n   * @param ipfsCertHash {string} - The ipfs multihash address of the certificate in json format (0x00 means unkwon)\r\n   * @param entityId {uint} - The entity id which issues the certificate (0 if not issued by an entity)\r\n   * @return {uint} The id of the created certificate     \r\n   */\r\n  function createCertificate(bytes32 dataHash, bytes32 certHash, string ipfsDataHash, string ipfsCertHash, uint entityId) public returns (uint) {\r\n    return CertsLib.createCertificate(cd, ed, dataHash, certHash, ipfsDataHash, ipfsCertHash, entityId);\r\n  }\r\n\r\n  /**\r\n   * Request transfering the ownership of a certificate.\r\n   * The owner can be a peer or an entity (never both), so only one of newOwner or newEntity must be different than 0.\r\n   * If the specified certificateId belongs to an entity, the msg.sender must be a valid signer for the entity. Otherwise the msg.sender must be the current owner.\r\n   * @param certificateId {uint} - The id of the certificate to transfer\r\n   * @param newOwner {address} - The address of the new owner\r\n   */\r\n  function requestCertificateTransferToPeer(uint certificateId, address newOwner) public {\r\n    return CertsLib.requestCertificateTransferToPeer(cd, ed, certificateId, newOwner);\r\n  }\r\n\r\n  /**\r\n   * Request transfering the ownership of a certificate.\r\n   * The owner can be a peer or an entity (never both), so only one of newOwner or newEntity must be different than 0.\r\n   * If the specified certificateId belongs to an entity, the msg.sender must be a valid signer for the entity. Otherwise the msg.sender must be the current owner.\r\n   * @param certificateId {uint} - The id of the certificate to transfer\r\n   * @param newEntityId {uint} - The id of the new entity\r\n   */\r\n  function requestCertificateTransferToEntity(uint certificateId, uint newEntityId) public {\r\n    return CertsLib.requestCertificateTransferToEntity(cd, ed, certificateId, newEntityId);\r\n  }\r\n\r\n  /**\r\n   * Accept the certificate transfer\r\n   * @param certificateId {uint} - The id of the certificate to transfer\r\n   */\r\n  function acceptCertificateTransfer(uint certificateId) public {\r\n    return CertsLib.acceptCertificateTransfer(cd, ed, certificateId);\r\n  }\r\n\r\n  /**\r\n   * Cancel the certificate transfer\r\n   * @param certificateId {uint} - The id of the certificate to transfer\r\n   */\r\n  function cancelCertificateTransfer(uint certificateId) public {\r\n    return CertsLib.cancelCertificateTransfer(cd, ed, certificateId);\r\n  }\r\n\r\n  /**\r\n   * Updates ipfs multihashes of a particular certificate\r\n   * @param certId {uint} - The id of the certificate\r\n   * @param ipfsDataHash {string} - The ipfs multihash address of the data (0x00 means unkwon)\r\n   * @param ipfsCertHash {string} - The ipfs multihash address of the certificate in json format (0x00 means unkwon)\r\n   */\r\n  function setIPFSData(uint certId, string ipfsDataHash, string ipfsCertHash) public {\r\n    CertsLib.setIPFSData(cd, certId, ipfsDataHash, ipfsCertHash);\r\n  }\r\n  \r\n  // SIGNATURE METHODS\r\n\r\n  /**\r\n   * Requests the signature for a certificate to an entity\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param entityId {uint} - The id of the entity\r\n   */\r\n  function requestSignatureToEntity(uint certificateId, uint entityId) public {\r\n    SignLib.requestSignatureToEntity(ed, cd, certificateId, entityId);\r\n  }\r\n\r\n  /**\r\n   * Requests the signature for a certificate to a peer\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param peer {address} - The address of the peer\r\n   */\r\n  function requestSignatureToPeer(uint certificateId, address peer) public {\r\n    SignLib.requestSignatureToPeer(ed, cd, certificateId, peer);\r\n  }\r\n\r\n  /**\r\n   * Entity signs a certificate with pending request\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param expiration {uint} - The expiration time of the signature (in seconds)\r\n   * @param purpose {bytes32} - The sha-256 hash of the purpose data\r\n   */\r\n  function signCertificateAsEntity(uint entityId, uint certificateId, uint expiration, bytes32 purpose) public {\r\n    SignLib.signCertificateAsEntity(ed, cd, entityId, certificateId, expiration, purpose);\r\n  }\r\n\r\n  /**\r\n   * Peer signs a certificate with pending request\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param expiration {uint} - The expiration time of the signature (in seconds)\r\n   * @param purpose {bytes32} - The sha-256 hash of the purpose data\r\n   */\r\n  function signCertificateAsPeer(uint certificateId, uint expiration, bytes32 purpose) public {\r\n    SignLib.signCertificateAsPeer(cd, certificateId, expiration, purpose);\r\n  }\r\n\r\n  // CUSTOM GETTERS\r\n  /**\r\n   * Get default info from internal contract\r\n   */\r\n  function internalState() constant public returns (uint numEntities, uint numCertificates) {\r\n    return (\r\n      ed.nEntities,\r\n      cd.nCerts\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets the entity data by id\r\n   * @param entityId {uint} - The id of the entity\r\n   * @return {object} The data of a signing entity\r\n   */\r\n  function getSigningEntityInfo(uint entityId) constant public returns (address owner, string dataHash, uint status, bytes32 urlHash, uint expiration, uint renewalPeriod, uint numSigners) {\r\n    return (\r\n      ed.entities[entityId].owner,\r\n      ed.entities[entityId].dataHash,\r\n      ed.entities[entityId].status,\r\n      ed.entities[entityId].urlHash,\r\n      ed.entities[entityId].expiration,\r\n      ed.entities[entityId].renewalPeriod,\r\n      ed.entities[entityId].signersArr.length\r\n    );\r\n  }\r\n\r\n  /**\r\n  * Get the last oraclize query Id of the specified entity\r\n  * @param entityId {uint} - The id of the entity\r\n  * @return {bytes32} The last oraclize query id of the entity\r\n  */\r\n  function getOraclizeQuery(uint entityId) constant public returns (bytes32 oraclizeQueryId) {\r\n    return ed.entities[entityId].oraclizeQueryId;\r\n  }\r\n\r\n  /**\r\n   * Gets the signers data from an entity (by address or index)\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param signerAddress {address} - The address of the signer (if known)\r\n   * @param index {uint} - The index of the signer\r\n   * @return {object} The signer details\r\n   */  \r\n  function getSignerData(uint entityId, address signerAddress, uint index) constant public returns (address signer, uint status, string ipfsMultiHash) {\r\n    uint s = 0;\r\n    string memory h = \"\";\r\n    \r\n    if (signerAddress != 0) {      \r\n      s = ed.entities[entityId].signers[signerAddress].status;\r\n      h = ed.entities[entityId].signers[signerAddress].signerDataHash;\r\n    } else if (signerAddress == 0 && index < ed.entities[entityId].signersArr.length) {\r\n      signerAddress = ed.entities[entityId].signersArr[index];\r\n      s = ed.entities[entityId].signers[signerAddress].status;\r\n      h = ed.entities[entityId].signers[signerAddress].signerDataHash;\r\n    }\r\n\r\n    return (signerAddress, s, h);\r\n  }\r\n\r\n  /**\r\n   * Gets the certificate data by id\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @return {object} The data of a certificate\r\n   */\r\n  function getCertificateInfo(uint certificateId) constant public returns (address owner, uint entityId, bytes32 certHash, string ipfsCertHash, bytes32 dataHash, string ipfsDataHash, uint numEntitySignatures, uint numPeerSignatures, address newOwnerTransferRequest, uint newEntityTransferRequest) {\r\n    CertsLib.CertData storage cert = cd.certificates[certificateId];\r\n    CertsLib.TransferData storage req = cd.transferRequests[certificateId];\r\n    return (\r\n      cert.owner,\r\n      cert.entityId,\r\n      cert.certHash,\r\n      cert.ipfsCertHash,\r\n      cert.dataHash,\r\n      cert.ipfsDataHash,\r\n      cert.entitiesArr.length,\r\n      cert.signaturesArr.length,\r\n      req.newOwner,\r\n      req.newEntityId\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Gets the entity signature info from a certificate and signing entity\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param entityId {uint} - The id of the entity\r\n   * @param entityIndex {uint} - The index of the entity in the array\r\n   * @return {uint, uint} The status/purpose and expiration date\r\n   */\r\n  function getEntitySignatureInfoFromCertificate(uint certificateId, uint entityId, uint entityIndex) constant public returns (uint id, bytes32 status, uint expiration) {\r\n    bytes32 s = 0x0;\r\n    uint e = 0;\r\n    if (entityId != 0 ) {\r\n      s = cd.certificates[certificateId].entities[entityId].status;\r\n      e = cd.certificates[certificateId].entities[entityId].exp;\r\n    } else if (entityId == 0) {\r\n      entityId = cd.certificates[certificateId].entitiesArr[entityIndex];\r\n      s = cd.certificates[certificateId].entities[entityId].status;\r\n      e = cd.certificates[certificateId].entities[entityId].exp;\r\n    } else {\r\n      entityId = 0;\r\n    }   \r\n    return (entityId, s, e);\r\n  }\r\n\r\n    /**\r\n   * Gets the peer signature info from a certificate and signing entity\r\n   * @param certificateId {uint} - The id of the certificate\r\n   * @param peerAddress {address} - If the address is supplied the info is retrieved from the peer\r\n   * @param peerIndex {uint} - The index of the peer to retrieve data from\r\n   * @return {uint, uint} The status/purpose and expiration date\r\n   */\r\n  function getPeerSignatureInfoFromCertificate(uint certificateId, address peerAddress, uint peerIndex) constant public returns (address addr, bytes32 status, uint expiration) {\r\n    bytes32 s = 0x0;\r\n    uint e = 0;\r\n    if (peerAddress != 0) {\r\n      s = cd.certificates[certificateId].signatures[peerAddress].status;\r\n      e = cd.certificates[certificateId].signatures[peerAddress].exp;\r\n    } else if (peerAddress == 0) {\r\n      peerAddress = cd.certificates[certificateId].signaturesArr[peerIndex];\r\n      s = cd.certificates[certificateId].signatures[peerAddress].status;\r\n      e = cd.certificates[certificateId].signatures[peerAddress].exp;\r\n    }\r\n    return (peerAddress, s, e);\r\n  }\r\n\r\n  // EVENTS  \r\n  event EntityCreated(uint indexed entityId);\r\n  event EntityValidated(uint indexed entityId);\r\n  event EntityDataUpdated(uint indexed entityId);\r\n  event EntityInvalid(uint indexed entityId);\r\n  event SignerAdded(uint indexed entityId, address indexed signerAddress);\r\n  event SignerDataUpdated(uint[] entities, address indexed signerAddress);\r\n  event SignerUpdateAccepted(uint indexed entityId, address indexed signerAddress);\r\n  event SignerRemoved(uint indexed entityId, address signerAddress);\r\n  event EntityClosed(uint indexed entityId);\r\n  event SignerConfirmed(uint indexed entityId, address signerAddress);\r\n  event EntityExpirationSet(uint indexed entityId);\r\n  event EntityRenewalSet(uint indexed entityId);\r\n\r\n  event POECertificate(uint indexed certificateId);\r\n  event Certificate(uint indexed certificateId);\r\n  event CertificateTransferRequestedToPeer(uint indexed certificateId, address newOwner);\r\n  event CertificateTransferRequestedToEntity(uint indexed certificateId, uint newEntityId);\r\n  event CertificateTransferAccepted(uint indexed certificateId, address newOwner, uint newEntityId);\r\n  event CertificateTransferCancelled(uint indexed certificateId);\r\n\r\n  event EntitySignatureRequested(uint indexed certificateId, uint indexed entityId);\r\n  event PeerSignatureRequested(uint indexed certificateId, address indexed signerAddress);\r\n  event CertificateSignedByEntity(uint indexed certificateId, uint indexed entityId, address indexed signerAddress);\r\n  event CertificateSignedByPeer(uint indexed certificateId, address indexed signerAddress);\r\n\r\n  event OraclizeNotEnoughFunds(uint indexed entityId, uint queryCost);\r\n }","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerAddress\",\"type\":\"address\"},{\"name\":\"signerDataHash\",\"type\":\"string\"}],\"name\":\"acceptSignerUpdate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certId\",\"type\":\"uint256\"},{\"name\":\"ipfsDataHash\",\"type\":\"string\"},{\"name\":\"ipfsCertHash\",\"type\":\"string\"}],\"name\":\"setIPFSData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"internalState\",\"outputs\":[{\"name\":\"numEntities\",\"type\":\"uint256\"},{\"name\":\"numCertificates\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"queryId\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"entityHash\",\"type\":\"string\"},{\"name\":\"urlHash\",\"type\":\"bytes32\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"oraclizeGas\",\"type\":\"uint256\"},{\"name\":\"oraclizeGasPrice\",\"type\":\"uint256\"}],\"name\":\"updateEntityData\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerAddress\",\"type\":\"address\"},{\"name\":\"signerDataHash\",\"type\":\"string\"}],\"name\":\"registerSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"removeSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerDataHash\",\"type\":\"string\"}],\"name\":\"confirmSignerRegistration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"myid\",\"type\":\"bytes32\"},{\"name\":\"result\",\"type\":\"string\"},{\"name\":\"proof\",\"type\":\"bytes\"}],\"name\":\"__callback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"oraclizeGas\",\"type\":\"uint256\"},{\"name\":\"oraclizeGasPrice\",\"type\":\"uint256\"}],\"name\":\"requestRenewal\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"closeEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityIds\",\"type\":\"uint256[]\"},{\"name\":\"signerDataHash\",\"type\":\"string\"}],\"name\":\"updateSignerData\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"purpose\",\"type\":\"bytes32\"}],\"name\":\"signCertificateAsPeer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"leaveEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"name\":\"certHash\",\"type\":\"bytes32\"},{\"name\":\"ipfsDataHash\",\"type\":\"string\"},{\"name\":\"ipfsCertHash\",\"type\":\"string\"}],\"name\":\"createPOECertificate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"entityIndex\",\"type\":\"uint256\"}],\"name\":\"getEntitySignatureInfoFromCertificate\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"status\",\"type\":\"bytes32\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"requestCertificateTransferToPeer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"getOraclizeQuery\",\"outputs\":[{\"name\":\"oraclizeQueryId\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"certificateId\",\"type\":\"uint256\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"purpose\",\"type\":\"bytes32\"}],\"name\":\"signCertificateAsEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"},{\"name\":\"peerAddress\",\"type\":\"address\"},{\"name\":\"peerIndex\",\"type\":\"uint256\"}],\"name\":\"getPeerSignatureInfoFromCertificate\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"bytes32\"},{\"name\":\"expiration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityHash\",\"type\":\"string\"},{\"name\":\"urlHash\",\"type\":\"bytes32\"},{\"name\":\"expirationDate\",\"type\":\"uint256\"},{\"name\":\"renewalPeriod\",\"type\":\"uint256\"}],\"name\":\"createSigningEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"getSigningEntityInfo\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"dataHash\",\"type\":\"string\"},{\"name\":\"status\",\"type\":\"uint256\"},{\"name\":\"urlHash\",\"type\":\"bytes32\"},{\"name\":\"expiration\",\"type\":\"uint256\"},{\"name\":\"renewalPeriod\",\"type\":\"uint256\"},{\"name\":\"numSigners\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"oraclizeGas\",\"type\":\"uint256\"},{\"name\":\"oraclizeGasPrice\",\"type\":\"uint256\"}],\"name\":\"validateSigningEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"}],\"name\":\"acceptCertificateTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"renewalPeriod\",\"type\":\"uint256\"}],\"name\":\"setRenewalPeriod\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"},{\"name\":\"peer\",\"type\":\"address\"}],\"name\":\"requestSignatureToPeer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"},{\"name\":\"newEntityId\",\"type\":\"uint256\"}],\"name\":\"requestCertificateTransferToEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"expirationDate\",\"type\":\"uint256\"},{\"name\":\"url\",\"type\":\"string\"},{\"name\":\"oraclizeGas\",\"type\":\"uint256\"},{\"name\":\"oraclizeGasPrice\",\"type\":\"uint256\"}],\"name\":\"setExpiration\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"name\":\"certHash\",\"type\":\"bytes32\"},{\"name\":\"ipfsDataHash\",\"type\":\"string\"},{\"name\":\"ipfsCertHash\",\"type\":\"string\"},{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"createCertificate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"}],\"name\":\"getCertificateInfo\",\"outputs\":[{\"name\":\"owner\",\"type\":\"address\"},{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"certHash\",\"type\":\"bytes32\"},{\"name\":\"ipfsCertHash\",\"type\":\"string\"},{\"name\":\"dataHash\",\"type\":\"bytes32\"},{\"name\":\"ipfsDataHash\",\"type\":\"string\"},{\"name\":\"numEntitySignatures\",\"type\":\"uint256\"},{\"name\":\"numPeerSignatures\",\"type\":\"uint256\"},{\"name\":\"newOwnerTransferRequest\",\"type\":\"address\"},{\"name\":\"newEntityTransferRequest\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"},{\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"requestSignatureToEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"entityId\",\"type\":\"uint256\"},{\"name\":\"signerAddress\",\"type\":\"address\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getSignerData\",\"outputs\":[{\"name\":\"signer\",\"type\":\"address\"},{\"name\":\"status\",\"type\":\"uint256\"},{\"name\":\"ipfsMultiHash\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"certificateId\",\"type\":\"uint256\"}],\"name\":\"cancelCertificateTransfer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityValidated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityDataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityInvalid\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"entities\",\"type\":\"uint256[]\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerDataUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerUpdateAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"SignerConfirmed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityExpirationSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntityRenewalSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"}],\"name\":\"POECertificate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"}],\"name\":\"Certificate\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"CertificateTransferRequestedToPeer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newEntityId\",\"type\":\"uint256\"}],\"name\":\"CertificateTransferRequestedToEntity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newEntityId\",\"type\":\"uint256\"}],\"name\":\"CertificateTransferAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"}],\"name\":\"CertificateTransferCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"}],\"name\":\"EntitySignatureRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"PeerSignatureRequested\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"CertificateSignedByEntity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"certificateId\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"signerAddress\",\"type\":\"address\"}],\"name\":\"CertificateSignedByPeer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"entityId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"queryCost\",\"type\":\"uint256\"}],\"name\":\"OraclizeNotEnoughFunds\",\"type\":\"event\"}]","ContractName":"Ethertify","CompilerVersion":"v0.4.19+commit.c4cbbb05","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"EntityLib:aa163942ef4ccd8e9d6cc06cf5ebaca2dc31009f;CertsLib:8d501654960ce6052529709463ee3642cf90f18f;SignLib:f28f417936b21a676749dea0242a7c0968fd5433","SwarmSource":"bzzr://23a326849b20cb632a514e3bd20314e23f3f5d693296dacad13a4a272d8ce295"}]}