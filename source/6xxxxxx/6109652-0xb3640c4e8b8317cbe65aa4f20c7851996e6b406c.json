{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/***********************************************************\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n ***********************************************************/\r\n library SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n/***********************************************************\r\n * NameFilter library\r\n ***********************************************************/\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.  \r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x \r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n        \r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n        \r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n        \r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n                \r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 || \r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n                \r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;    \r\n            }\r\n        }\r\n        \r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n        \r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n/***********************************************************\r\n * NTech3DDatasets library\r\n ***********************************************************/\r\nlibrary NTech3DDatasets {\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 NTAmount;          // amount distributed to nt\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // last affiliate id used\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask \r\n        uint256 ico;    // ICO phase investment\r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 team;   // tID of team in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 ico;    // total eth sent in during ICO phase\r\n        uint256 icoGen; // total eth for gen during ICO phase\r\n        uint256 icoAvg; // average key price for ICO phase\r\n        uint256 prevres;    // 上一轮或者奖池互换流入本轮的奖金\r\n    }\r\n    struct TeamFee {\r\n        uint256 gen;    // % of buy in thats paid to key holders of current round\r\n        uint256 nt;    // % of buy in thats paid to nt holders\r\n    }\r\n    struct PotSplit {\r\n        uint256 gen;    // % of pot thats paid to key holders of current round\r\n        uint256 nt;     // % of pot thats paid to NT foundation \r\n    }\r\n}\r\n/***********************************************************\r\n interface : OtherNTech3D\r\n 主要用作奖池互换\r\n ***********************************************************/\r\ninterface OtherNTech3D {\r\n    function potSwap() external payable;\r\n}\r\n/***********************************************************\r\n * NTech3DKeysCalcLong library\r\n ***********************************************************/\r\nlibrary NTech3DKeysCalcLong {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\n/***********************************************************\r\n * ERC20 interface\r\n * see https://github.com/ethereum/EIPs/issues/20\r\n ***********************************************************/\r\ncontract ERC20 {\r\n    function totalSupply() public view returns (uint supply);\r\n    function balanceOf( address who ) public view returns (uint value);\r\n    function allowance( address owner, address spender ) public view returns (uint _allowance);\r\n\r\n    function transfer( address to, uint value) public returns (bool ok);\r\n    function transferFrom( address from, address to, uint value) public returns (bool ok);\r\n    function approve( address spender, uint value ) public returns (bool ok);\r\n\r\n    event Transfer( address indexed from, address indexed to, uint value);\r\n    event Approval( address indexed owner, address indexed spender, uint value);\r\n}\r\n/***********************************************************\r\n interface : PlayerBookInterface\r\n ***********************************************************/\r\ninterface PlayerBookInterface {\r\n    function getPlayerID(address _addr) external returns (uint256);\r\n    function getPlayerName(uint256 _pID) external view returns (bytes32);\r\n    function getPlayerLAff(uint256 _pID) external view returns (uint256);\r\n    function getPlayerAddr(uint256 _pID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n}\r\n/***********************************************************\r\n * NTech3DLong contract\r\n ***********************************************************/\r\ncontract NTech3DLong {\r\n    /****************************************************************************************** \r\n     导入的库\r\n     */\r\n    using SafeMath              for *;\r\n    using NameFilter            for string;\r\n    using NTech3DKeysCalcLong   for uint256;\r\n    /****************************************************************************************** \r\n     事件\r\n     */\r\n    // 当玩家注册名字时调用\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n    // 购买完成后或者再次载入时调用\r\n    event onEndTx\r\n    (\r\n        uint256 compressedData,     \r\n        uint256 compressedIDs,      \r\n        bytes32 playerName,\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 NTAmount,\r\n        uint256 genAmount,\r\n        uint256 potAmount,\r\n        uint256 airDropPot\r\n    );\r\n    \r\n    // 撤退时调用\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // 当撤退并且分发时调用\r\n    event onWithdrawAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 NTAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // 当一轮时间过后，有玩家试图购买时调用\r\n    event onBuyAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethIn,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 NTAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    //当一轮时间过后，有玩家重载时调用\r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 NTAmount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    // 附属账号有支付时调用\r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // 收到奖池存款调用\r\n    event onPotSwapDeposit\r\n    (\r\n        uint256 roundID,\r\n        uint256 amountAddedToPot\r\n    );\r\n    /******************************************************************************************\r\n     合约权限管理\r\n     设计：会设计用户权限管理，\r\n        9 => 管理员角色\r\n        0 => 没有任何权限\r\n     */\r\n    // 用户地址到角色的表\r\n    mapping(address => uint256)     private users ;\r\n    // 初始化\r\n    function initUsers() private {\r\n        // 初始化下列地址帐户为管理员\r\n        users[0x89b2E7Ee504afd522E07F80Ae7b9d4D228AF3fe2] = 9 ;\r\n        users[msg.sender] = 9 ;\r\n    }\r\n    // 是否是管理员\r\n    modifier isAdmin() {\r\n        uint256 role = users[msg.sender];\r\n        require((role==9), \"Must be admin.\");\r\n        _;\r\n    }\r\n    /******************************************************************************************\r\n     检查是帐户地址还是合约地址   \r\n     */\r\n    modifier isHuman {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"Humans only\");\r\n        _;\r\n    }\r\n    /******************************************************************************************\r\n     关联合约定义\r\n     */\r\n    // 玩家信息数据库合约\r\n    PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x410526CD583AF0bE0530166d53Efcd7da969F7B7);\r\n    \r\n    /******************************************************************************************\r\n     社区地址\r\n     NT基金地址\r\n     代币空投的收款地址\r\n     */\r\n    address public communityAddr_;\r\n    address public NTFoundationAddr_;\r\n    address private NTTokenSeller_ ;\r\n    /****************************************************************************************** \r\n     设置代币地址\r\n     条件：\r\n     1. 地址不能为空\r\n     2. 管理员\r\n    */ \r\n    ERC20 private NTToken_ ;\r\n    function setNTToken(address addr) isAdmin() public {\r\n        require(address(addr) != address(0x0), \"Empty address not allowed.\");\r\n        NTToken_ = ERC20(addr);\r\n    }\r\n    /** \r\n     将游戏合约中的未用完的代币转走\r\n     条件：\r\n     1. 数值大于0\r\n     2. 管理员\r\n     */\r\n    function transfer(address toAddr, uint256 amount) isAdmin() public returns (bool) {\r\n        require(amount > 0, \"Must > 0 \");\r\n        NTToken_.transfer(toAddr, amount);\r\n        return true ;\r\n    }\r\n    /******************************************************************************************\r\n     启动\r\n     */\r\n    bool public activated_ = false;\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not active yet.\"); \r\n        _;\r\n    }\r\n    /**\r\n     TODO\r\n     激活游戏\r\n     条件：\r\n     1、要是管理员\r\n     2、要设定代币地址\r\n     3、要设定用作奖池呼唤的游戏地址\r\n     4、只可以激活一次\r\n     */\r\n    function activate() isAdmin() public {\r\n        // 必须设定代币地址\r\n        require(address(NTToken_) != address(0x0), \"Must setup NTToken.\");\r\n        // 必须设定社区基金地址\r\n        require(address(communityAddr_) != address(0x0), \"Must setup CommunityAddr_.\");\r\n        // 必须设定购买NT地址\r\n        require(address(NTTokenSeller_) != address(0x0), \"Must setup NTTokenSeller.\");\r\n        // 必须设定NT基金地址\r\n        require(address(NTFoundationAddr_) != address(0x0), \"Must setup NTFoundationAddr.\");\r\n        // 只能激活一次\r\n        require(activated_ == false, \"Only once\");\r\n        //\r\n        activated_ = true ;\r\n        // 初始化开始轮信息\r\n        rID_ = 1;\r\n        round_[1].strt = now ;\r\n        round_[1].end = now + rndMax_;\r\n    }\r\n    /******************************************************************************************\r\n     合约信息\r\n     */\r\n    string constant public name = \"NTech 3D Long Official\";  // 合约名称\r\n    string constant public symbol = \"NT3D\";                 // 合约符号\r\n    /**\r\n     */\r\n    uint256 constant private rndInc_    = 1 minutes;                  // 每购买一个key延迟的时间\r\n    uint256 constant private rndMax_    = 6 hours;                     // 一轮的最长时间\r\n\r\n    uint256 private ntOf1Ether_ = 30000;                            // 一个以太兑换30000代币\r\n    /******************************************************************************************\r\n     奖池互换\r\n     */\r\n    OtherNTech3D private otherNTech3D_ ;    // 另外一个游戏接口，主要用作奖池呼唤\r\n    /** \r\n     设定奖池呼唤的另外一个游戏合约地址\r\n     条件\r\n     1. 管理员权限\r\n     2. 之前没有设定过\r\n     3. 设定的地址不能为空\r\n     */\r\n    function setOtherNTech3D(address _otherNTech3D) isAdmin() public {\r\n        require(address(_otherNTech3D) != address(0x0), \"Empty address not allowed.\");\r\n        require(address(otherNTech3D_) == address(0x0), \"OtherNTech3D has been set.\");\r\n        otherNTech3D_ = OtherNTech3D(_otherNTech3D);\r\n    }\r\n    /******************************************************************************************\r\n     判断金额\r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"Too little\");\r\n        require(_eth <= 100000000000000000000000, \"Too much\");\r\n        _;    \r\n    }\r\n\r\n    /******************************************************************************************\r\n     玩家信息\r\n     */\r\n    // 玩家地址 => 玩家ID \r\n    mapping (address => uint256) public pIDxAddr_;  \r\n    // 玩家名称 => 玩家ID\r\n    mapping (bytes32 => uint256) public pIDxName_;  \r\n    // 玩家ID => 玩家信息\r\n    mapping (uint256 => NTech3DDatasets.Player) public plyr_; \r\n    // 玩家ID => 游戏轮编号 => 玩家游戏轮信息\r\n    mapping (uint256 => mapping (uint256 => NTech3DDatasets.PlayerRounds)) public plyrRnds_;\r\n    // 玩家ID => 玩家名称 => \r\n    mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_;\r\n    /******************************************************************************************\r\n     游戏信息\r\n     */\r\n    uint256 public rID_;                    // 当前游戏轮编号 \r\n    uint256 public airDropPot_;             // 空投小奖池\r\n    uint256 public airDropTracker_ = 0;     // 空投小奖池计数\r\n    // 游戏每轮ID => 游戏轮 \r\n    mapping (uint256 => NTech3DDatasets.Round) public round_;\r\n    // 游戏每轮ID -> 团队ID => ETH\r\n    mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\r\n    /******************************************************************************************\r\n     团队信息\r\n     0 ： 水鲸队\r\n     1 ： 懒熊队\r\n     2 ： 玩蛇队\r\n     3 ： 疯牛队\r\n     */\r\n    // 团队ID => 分配规则 \r\n    mapping (uint256 => NTech3DDatasets.TeamFee) public fees_; \r\n    // 团队ID => 分配规则\r\n    mapping (uint256 => NTech3DDatasets.PotSplit) public potSplit_;\r\n    /******************************************************************************************\r\n     构造函数\r\n     */\r\n    \r\n    constructor() public {\r\n        // 水鲸：本轮玩家 30%  空投 6%\r\n        fees_[0] = NTech3DDatasets.TeamFee(30,6);\r\n        // 懒熊：本轮玩家 43%  空投 0%\r\n        fees_[1] = NTech3DDatasets.TeamFee(43,0);\r\n        // 玩蛇：本轮玩家 56%  空投 10%\r\n        fees_[2] = NTech3DDatasets.TeamFee(56,10);\r\n        // 疯牛：本轮玩家 43%  空投 8%\r\n        fees_[3] = NTech3DDatasets.TeamFee(43,8);\r\n        // 此轮奖池分配：\r\n        // 水鲸：本轮玩家 25%\r\n        potSplit_[0] = NTech3DDatasets.PotSplit(15,10);\r\n        // 懒熊：本轮玩家 25%\r\n        potSplit_[1] = NTech3DDatasets.PotSplit(25,0); \r\n        // 玩蛇：本轮玩家 40%\r\n        potSplit_[2] = NTech3DDatasets.PotSplit(20,20);\r\n        // 疯牛：本轮玩家 40%\r\n        potSplit_[3] = NTech3DDatasets.PotSplit(30,10);\r\n        // 初始化用户管理\r\n        initUsers();\r\n        /**\r\n         */\r\n        NTToken_ = ERC20(address(0x09341B5d43a9b2362141675b9276B777470222Be));\r\n        \r\n        communityAddr_ = address(0x3C07f9f7164Bf72FDBefd9438658fAcD94Ed4439);\r\n        NTTokenSeller_ = address(0x531100a6b3686E6140f170B0920962A5D7A2DD25);\r\n        NTFoundationAddr_ = address(0x89b2E7Ee504afd522E07F80Ae7b9d4D228AF3fe2);\r\n    }\r\n    /******************************************************************************************\r\n     购买\r\n     */\r\n    function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\r\n        NTech3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        if (_affCode == 0 || _affCode == _pID){\r\n            _affCode = plyr_[_pID].laff;\r\n        }else if (_affCode != plyr_[_pID].laff) {\r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n        _team = verifyTeam(_team);\r\n        buyCore(_pID, _affCode, _team, _eventData_);\r\n    }\r\n    \r\n    function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\r\n        NTech3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _affID;\r\n        if (_affCode == address(0) || _affCode == msg.sender){\r\n            _affID = plyr_[_pID].laff;\r\n        }else{\r\n             _affID = pIDxAddr_[_affCode];\r\n             if (_affID != plyr_[_pID].laff){\r\n                 plyr_[_pID].laff = _affID;\r\n             }\r\n        }\r\n         _team = verifyTeam(_team);\r\n         buyCore(_pID, _affID, _team, _eventData_);\r\n    }\r\n\r\n    function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\r\n        NTech3DDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _affID;\r\n        if (_affCode == '' || _affCode == plyr_[_pID].name){\r\n            _affID = plyr_[_pID].laff;\r\n        }else{\r\n            _affID = pIDxName_[_affCode];\r\n            if (_affID != plyr_[_pID].laff){\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        _team = verifyTeam(_team);\r\n        buyCore(_pID, _affID, _team, _eventData_);\r\n    }\r\n\r\n    function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public {\r\n        NTech3DDatasets.EventReturns memory _eventData_;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        if (_affCode == 0 || _affCode == _pID){\r\n            _affCode = plyr_[_pID].laff;\r\n        }else if (_affCode != plyr_[_pID].laff) {\r\n            plyr_[_pID].laff = _affCode;\r\n        }\r\n        _team = verifyTeam(_team);\r\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\r\n    }\r\n\r\n    function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public {\r\n        NTech3DDatasets.EventReturns memory _eventData_;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _affID;\r\n        if (_affCode == address(0) || _affCode == msg.sender){\r\n            _affID = plyr_[_pID].laff;\r\n        }else{\r\n            _affID = pIDxAddr_[_affCode];\r\n            if (_affID != plyr_[_pID].laff){\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        _team = verifyTeam(_team);\r\n        reLoadCore(_pID, _affID, _team, _eth, _eventData_);\r\n    }\r\n\r\n    function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public {\r\n        NTech3DDatasets.EventReturns memory _eventData_;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _affID;\r\n        if (_affCode == '' || _affCode == plyr_[_pID].name){\r\n            _affID = plyr_[_pID].laff;\r\n        }else{\r\n            _affID = pIDxName_[_affCode];\r\n            if (_affID != plyr_[_pID].laff){\r\n                plyr_[_pID].laff = _affID;\r\n            }\r\n        }\r\n        _team = verifyTeam(_team);\r\n        reLoadCore(_pID, _affID, _team, _eth, _eventData_);\r\n    }\r\n    /**\r\n     撤退\r\n     */\r\n    function withdraw() isActivated() isHuman() public {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _eth;\r\n        \r\n        if (_now > round_[_rID].end && (round_[_rID].ended == false) && round_[_rID].plyr != 0){\r\n            NTech3DDatasets.EventReturns memory _eventData_;\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            emit onWithdrawAndDistribute(\r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eth, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.NTAmount, \r\n                _eventData_.genAmount\r\n            );                \r\n        }else{\r\n            _eth = withdrawEarnings(_pID);\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n            emit onWithdraw(\r\n                _pID, \r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eth, \r\n                _now\r\n            );\r\n        }\r\n    }\r\n    /******************************************************************************************\r\n     注册\r\n     */\r\n    function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable{\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all);\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        emit onNewName(\r\n            _pID, \r\n            _addr, \r\n            _name, \r\n            _isNewPlayer, \r\n            _affID, \r\n            plyr_[_affID].addr, \r\n            plyr_[_affID].name, \r\n            _paid, \r\n            now\r\n        );\r\n    }\r\n\r\n    function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable{\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        emit onNewName(\r\n            _pID, \r\n            _addr, \r\n            _name, \r\n            _isNewPlayer, \r\n            _affID, \r\n            plyr_[_affID].addr, \r\n            plyr_[_affID].name, \r\n            _paid, \r\n            now\r\n        );\r\n    }\r\n\r\n    function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable{\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _addr = msg.sender;\r\n        uint256 _paid = msg.value;\r\n        (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all);\r\n        \r\n        uint256 _pID = pIDxAddr_[_addr];\r\n        \r\n        emit onNewName(\r\n            _pID, \r\n            _addr, \r\n            _name, \r\n            _isNewPlayer, \r\n            _affID, \r\n            plyr_[_affID].addr, \r\n            plyr_[_affID].name, \r\n            _paid, \r\n            now\r\n        );\r\n    }\r\n    /******************************************************************************************\r\n     获取购买价格\r\n     */\r\n    function getBuyPrice() public view  returns(uint256) {  \r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n\r\n        //if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\r\n        else // rounds over.  need price for new round\r\n            return ( 75000000000000 ); // init\r\n    }\r\n    /******************************************************************************************\r\n     得到剩余时间\r\n     */\r\n    function getTimeLeft() public view returns(uint256) {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n\r\n        if (_now < round_[_rID].end)\r\n            //if (_now > round_[_rID].strt + rndGap_)\r\n            if (_now > round_[_rID].strt)\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                //return( (round_[_rID].strt + rndGap_).sub(_now) );\r\n                return( (round_[_rID].end).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n\r\n    function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) {\r\n        uint256 _rID = rID_;\r\n        if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0){\r\n            // if player is winner \r\n            if (round_[_rID].plyr == _pID){\r\n                // Added by Huwei\r\n                uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n                return\r\n                (\r\n                    // Fix by huwei\r\n                    //(plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ),\r\n                    (plyr_[_pID].win).add( ((_pot).mul(48)) / 100 ),\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            // if player is not the winner\r\n            } else {\r\n                return(\r\n                    plyr_[_pID].win,\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            }\r\n            \r\n        // if round is still going on, or round has ended and round end has been ran\r\n        } else {\r\n            return(\r\n                plyr_[_pID].win,\r\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n                plyr_[_pID].aff\r\n            );\r\n        }\r\n    }\r\n\r\n    function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) {\r\n        // Fixed by Huwei\r\n        uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n        return(  ((((round_[_rID].mask).add(((((_pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );\r\n        //return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );\r\n    }\r\n    /**\r\n     得到当前此轮信息\r\n     */\r\n    function getCurrentRoundInfo() public view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) {\r\n        uint256 _rID = rID_;            \r\n        return\r\n            (\r\n                round_[_rID].ico,             \r\n                _rID,             \r\n                round_[_rID].keys,             \r\n                round_[_rID].end, \r\n                round_[_rID].strt, \r\n                round_[_rID].pot,             \r\n                (round_[_rID].team + (round_[_rID].plyr * 10)),\r\n                plyr_[round_[_rID].plyr].addr,\r\n                plyr_[round_[_rID].plyr].name,\r\n                rndTmEth_[_rID][0],\r\n                rndTmEth_[_rID][1],\r\n                rndTmEth_[_rID][2],\r\n                rndTmEth_[_rID][3],\r\n                airDropTracker_ + (airDropPot_ * 1000)\r\n            );     \r\n    }\r\n\r\n    function getPlayerInfoByAddress(address _addr) public  view  returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256){\r\n        uint256 _rID = rID_;\r\n        if (_addr == address(0)) {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        return (\r\n            _pID,\r\n            plyr_[_pID].name,\r\n            plyrRnds_[_pID][_rID].keys,\r\n            plyr_[_pID].win,\r\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n            plyr_[_pID].aff,\r\n            plyrRnds_[_pID][_rID].eth\r\n        );\r\n    }\r\n\r\n    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, NTech3DDatasets.EventReturns memory _eventData_) private {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        //if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\r\n            if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\r\n            core(_rID, _pID, msg.value, _affID, _team, _eventData_);\r\n        }else{\r\n            if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n                round_[_rID].ended = true;\r\n                _eventData_ = endRound(_eventData_);\r\n\r\n                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                emit onBuyAndDistribute(\r\n                    msg.sender, \r\n                    plyr_[_pID].name, \r\n                    msg.value, \r\n                    _eventData_.compressedData, \r\n                    _eventData_.compressedIDs, \r\n                    _eventData_.winnerAddr, \r\n                    _eventData_.winnerName, \r\n                    _eventData_.amountWon, \r\n                    _eventData_.newPot, \r\n                    _eventData_.NTAmount, \r\n                    _eventData_.genAmount\r\n                );\r\n            }\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n\r\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, NTech3DDatasets.EventReturns memory _eventData_) private {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        //if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\r\n            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\r\n            core(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n        }else if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            emit onReLoadAndDistribute(\r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.NTAmount, \r\n                _eventData_.genAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, NTech3DDatasets.EventReturns memory _eventData_) private{\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n            _eventData_ = managePlayer(_pID, _eventData_);\r\n        // 每轮早期的限制 (5 ether 以下)\r\n        // 智能合约收到的总额达到100 ETH之前，每个以太坊地址最多只能购买总额10个ETH的Key。\r\n        if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 10000000000000000000){\r\n            uint256 _availableLimit = (10000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\r\n            uint256 _refund = _eth.sub(_availableLimit);\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\r\n            _eth = _availableLimit;\r\n        }\r\n        if (_eth > 1000000000) {\r\n            uint256 _keys = (round_[_rID].eth).keysRec(_eth);\r\n\r\n            if (_keys >= 1000000000000000000){\r\n                updateTimer(_keys, _rID);\r\n                if (round_[_rID].plyr != _pID)\r\n                    round_[_rID].plyr = _pID;  \r\n                if (round_[_rID].team != _team)\r\n                    round_[_rID].team = _team; \r\n                _eventData_.compressedData = _eventData_.compressedData + 100;\r\n            }\r\n\r\n            if (_eth >= 100000000000000000){\r\n                // > 0.1 ether, 才有空投\r\n                airDropTracker_++;\r\n                if (airdrop() == true){\r\n                    uint256 _prize;\r\n                    if (_eth >= 10000000000000000000){\r\n                        // <= 10 ether\r\n                        _prize = ((airDropPot_).mul(75)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    }else if(_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n                        // >= 1 ether and < 10 ether\r\n                        _prize = ((airDropPot_).mul(50)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 200000000000000000000000000000000;\r\n\r\n                    }else if(_eth >= 100000000000000000 && _eth < 1000000000000000000){\r\n                        // >= 0.1 ether and < 1 ether\r\n                        _prize = ((airDropPot_).mul(25)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    }\r\n\r\n                    _eventData_.compressedData += 10000000000000000000000000000000;\r\n\r\n                    _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\r\n\r\n                    airDropTracker_ = 0;\r\n                }\r\n            }\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\r\n\r\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n\r\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\r\n\r\n            // distribute eth\r\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\r\n\r\n            endTx(_pID, _team, _eth, _keys, _eventData_);\r\n        }\r\n\r\n    }\r\n\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) {\r\n        // round_[_rIDlast].mask * plyrRnds_[_pID][_rIDlast].keys / 1000000000000000000 - plyrRnds_[_pID][_rIDlast].mask\r\n        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );\r\n    }\r\n\r\n    function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256){\r\n        uint256 _now = now;\r\n        //if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].eth).keysRec(_eth) );\r\n        else // rounds over.  need keys for new round\r\n            return ( (_eth).keys() );\r\n    }\r\n\r\n    function iWantXKeys(uint256 _keys) public view returns(uint256) {\r\n        uint256 _rID = rID_;\r\n\r\n        uint256 _now = now;\r\n\r\n        //if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n    /**\r\n     interface : PlayerBookReceiverInterface\r\n     */\r\n    function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external {\r\n        require (msg.sender == address(PlayerBook), \"Called from PlayerBook only\");\r\n        if (pIDxAddr_[_addr] != _pID)\r\n            pIDxAddr_[_addr] = _pID;\r\n        if (pIDxName_[_name] != _pID)\r\n            pIDxName_[_name] = _pID;\r\n        if (plyr_[_pID].addr != _addr)\r\n            plyr_[_pID].addr = _addr;\r\n        if (plyr_[_pID].name != _name)\r\n            plyr_[_pID].name = _name;\r\n        if (plyr_[_pID].laff != _laff)\r\n            plyr_[_pID].laff = _laff;\r\n        if (plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n\r\n    function receivePlayerNameList(uint256 _pID, bytes32 _name) external {\r\n        require (msg.sender == address(PlayerBook), \"Called from PlayerBook only\");\r\n        if(plyrNames_[_pID][_name] == false)\r\n            plyrNames_[_pID][_name] = true;\r\n    }\r\n    /**\r\n     识别玩家\r\n     */\r\n    function determinePID(NTech3DDatasets.EventReturns memory _eventData_) private returns (NTech3DDatasets.EventReturns) {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        if (_pID == 0){\r\n            _pID = PlayerBook.getPlayerID(msg.sender);\r\n            bytes32 _name = PlayerBook.getPlayerName(_pID);\r\n            uint256 _laff = PlayerBook.getPlayerLAff(_pID);\r\n            pIDxAddr_[msg.sender] = _pID;\r\n            plyr_[_pID].addr = msg.sender;\r\n            if (_name != \"\"){\r\n                pIDxName_[_name] = _pID;\r\n                plyr_[_pID].name = _name;\r\n                plyrNames_[_pID][_name] = true;\r\n            }\r\n            if (_laff != 0 && _laff != _pID)\r\n                plyr_[_pID].laff = _laff;\r\n            // set the new player bool to true    \r\n            _eventData_.compressedData = _eventData_.compressedData + 1;                \r\n        } \r\n        return _eventData_ ;\r\n    }\r\n    /**\r\n     识别团队，默认是玩蛇队\r\n     */\r\n    function verifyTeam(uint256 _team) private pure returns (uint256) {\r\n        if (_team < 0 || _team > 3) \r\n            return(2);\r\n        else\r\n            return(_team);\r\n    }\r\n\r\n    function managePlayer(uint256 _pID, NTech3DDatasets.EventReturns memory _eventData_) private returns (NTech3DDatasets.EventReturns) {\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        plyr_[_pID].lrnd = rID_;\r\n\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n\r\n        return _eventData_ ;\r\n    }\r\n    /**\r\n     这轮游戏结束\r\n     */\r\n    function endRound(NTech3DDatasets.EventReturns memory _eventData_) private returns (NTech3DDatasets.EventReturns) {\r\n        uint256 _rID = rID_;\r\n        uint256 _winPID = round_[_rID].plyr;\r\n        uint256 _winTID = round_[_rID].team;\r\n        // grab our pot amount\r\n        // Fixed by Huwei\r\n        //uint256 _pot = round_[_rID].pot;\r\n        uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n\r\n        // 赢家获取奖池的48%\r\n        uint256 _win = (_pot.mul(48)) / 100;\r\n        // 社区基金获取2%\r\n        uint256 _com = (_pot / 50);\r\n        // 这轮游戏玩家获取的奖金\r\n        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\r\n        // NT基金获取的奖金\r\n        uint256 _nt = (_pot.mul(potSplit_[_winTID].nt)) / 100;\r\n        // 剩下的奖金\r\n        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_nt);\r\n        // calculate ppt for round mask\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\r\n        if (_dust > 0){\r\n            _gen = _gen.sub(_dust);\r\n            _res = _res.add(_dust);\r\n        }\r\n\r\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\r\n        if(address(communityAddr_)!=address(0x0)) {\r\n            // 将社区基金奖金发到社区奖金地址\r\n            communityAddr_.transfer(_com);\r\n            _com = 0 ;\r\n        }else{\r\n            // 如果没有设置社区地址，那么资金分给下一轮\r\n            _res = SafeMath.add(_res,_com);\r\n            _com = 0 ;\r\n        }\r\n        if(_nt > 0) {\r\n            if(address(NTFoundationAddr_) != address(0x0)) {\r\n                // 分配NT基金奖金\r\n                NTFoundationAddr_.transfer(_nt);\r\n            }else{\r\n                // 如果没有设定，那么资金计入下一轮\r\n                _res = SafeMath.add(_res,_nt);    \r\n                _nt = 0 ; \r\n            }\r\n        }\r\n\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.winnerName = plyr_[_winPID].name;\r\n        _eventData_.amountWon = _win;\r\n        _eventData_.genAmount = _gen;\r\n        _eventData_.NTAmount = 0;\r\n        _eventData_.newPot = _res;\r\n        // 下一轮\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndMax_);\r\n        //round_[_rID].end = now.add(rndInit_).add(rndGap_);\r\n        // Fixed by Huwei\r\n        //round_[_rID].pot = _res;\r\n        round_[_rID].prevres = _res;\r\n\r\n        return(_eventData_);\r\n    }\r\n\r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast) private {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0){\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n\r\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\r\n\r\n        }\r\n    }\r\n\r\n    function updateTimer(uint256 _keys, uint256 _rID) private {\r\n        uint256 _now = now;\r\n\r\n        uint256 _newTime;\r\n\r\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\r\n\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n    /**\r\n     计算空投小奖池\r\n     */\r\n    function airdrop() private  view  returns(bool) {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n    /**\r\n     社区基金\r\n     奖池互换\r\n     分享\r\n     空投\r\n     */ \r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, NTech3DDatasets.EventReturns memory _eventData_) \r\n        private returns(NTech3DDatasets.EventReturns){\r\n        // 社区基金2%, 如果没有设置社区基金，则这份空投到用户地址\r\n        uint256 _com = _eth / 50;\r\n        // 奖池互换，如果没有设置，进入到社区基金\r\n        uint256 _long = _eth / 100;\r\n        if(address(otherNTech3D_)!=address(0x0)){\r\n            otherNTech3D_.potSwap.value(_long)();\r\n        }else{\r\n            _com = _com.add(_long);\r\n        }\r\n        // 分享，如果没有分享，进入到社区基金\r\n        uint256 _aff = _eth / 10;\r\n        if (_affID != _pID && plyr_[_affID].name != '') {\r\n            plyr_[_affID].aff = _aff.add(plyr_[_affID].aff);\r\n            emit onAffiliatePayout(\r\n                _affID, \r\n                plyr_[_affID].addr, \r\n                plyr_[_affID].name, \r\n                _rID, \r\n                _pID, \r\n                _aff, \r\n                now\r\n            );\r\n        } else {\r\n            _com = _com.add(_aff);\r\n        }\r\n        // 空投（如果没有设置社区基金地址，那么放入空投）\r\n        uint256 _nt = (_eth.mul(fees_[_team].nt)).div(100);\r\n        if(_com>0){\r\n            if(address(communityAddr_)!=address(0x0)) {\r\n                communityAddr_.transfer(_com);\r\n            }else{\r\n                _nt = _nt.add(_com);      \r\n            }\r\n        }\r\n        if(_nt > 0 ){\r\n            // amount = _nt * ntOf1Ether_ ;\r\n            uint256 amount = _nt.mul(ntOf1Ether_);\r\n            _eventData_.NTAmount = amount.add(_eventData_.NTAmount);\r\n            NTToken_.transfer(msg.sender,amount);\r\n            //\r\n            address(NTTokenSeller_).transfer(_nt);\r\n        }\r\n\r\n        return (_eventData_) ; \r\n\r\n    }\r\n    /**\r\n     奖池互换\r\n     */\r\n    function potSwap() external payable {\r\n        // 奖池互换放入下一轮\r\n        uint256 _rID = rID_ + 1;\r\n        // Fixed by Huwei\r\n        //round_[_rID].pot = round_[_rID].pot.add(msg.value);\r\n        round_[_rID].prevres = round_[_rID].prevres.add(msg.value);\r\n        emit onPotSwapDeposit(\r\n            _rID, \r\n            msg.value\r\n        );\r\n    }\r\n    /** \r\n     持有者\r\n     空投小奖池\r\n     终极奖池\r\n     */ \r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, NTech3DDatasets.EventReturns memory _eventData_)\r\n        private returns(NTech3DDatasets.EventReturns) {\r\n        // 持有者的份额 \r\n        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;    \r\n        // 空投小奖池 1%\r\n        uint256 _air = (_eth / 100);\r\n        airDropPot_ = airDropPot_.add(_air);\r\n        // 14% = 2% 社区 + 10% 佣金 + 1% 奖池互换 + 1% 空投小奖池\r\n        _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].nt)) / 100));\r\n        // 奖池\r\n        uint256 _pot = _eth.sub(_gen);\r\n\r\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n        \r\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\r\n\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n\r\n        return(_eventData_);\r\n    }\r\n    \r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) {\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\r\n        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\r\n    }\r\n    /**\r\n     撤退时的收益\r\n     */\r\n    function withdrawEarnings(uint256 _pID) private returns(uint256) {\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0){\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n        return(_earnings);\r\n    }\r\n    /**\r\n     完成交易\r\n     */\r\n    function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, NTech3DDatasets.EventReturns memory _eventData_) private {\r\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\r\n\r\n        emit onEndTx(\r\n            _eventData_.compressedData,\r\n            _eventData_.compressedIDs,\r\n            plyr_[_pID].name,\r\n            msg.sender,\r\n            _eth,\r\n            _keys,\r\n            _eventData_.winnerAddr,\r\n            _eventData_.winnerName,\r\n            _eventData_.amountWon,\r\n            _eventData_.newPot,\r\n            _eventData_.NTAmount,\r\n            _eventData_.genAmount,\r\n            _eventData_.potAmount,\r\n            airDropPot_\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXname\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_otherNTech3D\",\"type\":\"address\"}],\"name\":\"setOtherNTech3D\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"},{\"name\":\"icoGen\",\"type\":\"uint256\"},{\"name\":\"icoAvg\",\"type\":\"uint256\"},{\"name\":\"prevres\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"plyrNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fees_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"nt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"pIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_laff\",\"type\":\"uint256\"}],\"name\":\"receivePlayerInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndTmEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NTFoundationAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXaddr\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"receivePlayerNameList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"},{\"name\":\"_affCode\",\"type\":\"uint256\"},{\"name\":\"_all\",\"type\":\"bool\"}],\"name\":\"registerNameXID\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addr\",\"type\":\"address\"}],\"name\":\"setNTToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"bytes32\"},{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buyXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"toAddr\",\"type\":\"address\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potSplit_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"nt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcKeysReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"potSwap\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"NTAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"airDropPot\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"NTAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"NTAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"NTAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountAddedToPot\",\"type\":\"uint256\"}],\"name\":\"onPotSwapDeposit\",\"type\":\"event\"}]","ContractName":"NTech3DLong","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://14785a19f98eb6f4f9adfc80b78a9a7005075298cadf6f3146e6f2cbd1ee8fce"}]}