{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.22;\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n    \r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n    \r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Token  {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    uint256 public totalSupply;\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n    function increaseApproval (address _spender, uint _addedValue) public returns (bool success);\r\n    function decreaseApproval (address _spender, uint _subtractedValue)public returns (bool success);\r\n\r\n}\r\n\r\ncontract EternalStorage {\r\n\r\n    /**** Storage Types *******/\r\n\r\n    address public owner;\r\n\r\n    mapping(bytes32 => uint256)    private uIntStorage;\r\n    mapping(bytes32 => uint8)      private uInt8Storage;\r\n    mapping(bytes32 => string)     private stringStorage;\r\n    mapping(bytes32 => address)    private addressStorage;\r\n    mapping(bytes32 => bytes)      private bytesStorage;\r\n    mapping(bytes32 => bool)       private boolStorage;\r\n    mapping(bytes32 => int256)     private intStorage;\r\n    mapping(bytes32 => bytes32)    private bytes32Storage;\r\n\r\n\r\n    /*** Modifiers ************/\r\n\r\n    /// @dev Only allow access from the latest version of a contract after deployment\r\n    modifier onlyLatestContract() {\r\n        require(addressStorage[keccak256(abi.encodePacked(\"contract.address\", msg.sender))] != 0x0 || msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /// @dev constructor\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        addressStorage[keccak256(abi.encodePacked(\"contract.address\", msg.sender))] = msg.sender;\r\n    }\r\n\r\n    function setOwner() public {\r\n        require(msg.sender == owner);\r\n        addressStorage[keccak256(abi.encodePacked(\"contract.address\", owner))] = 0x0;\r\n        owner = msg.sender;\r\n        addressStorage[keccak256(abi.encodePacked(\"contract.address\", msg.sender))] = msg.sender;\r\n    }\r\n\r\n    /**** Get Methods ***********/\r\n\r\n    /// @param _key The key for the record\r\n    function getAddress(bytes32 _key) external view returns (address) {\r\n        return addressStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function getUint(bytes32 _key) external view returns (uint) {\r\n        return uIntStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function getUint8(bytes32 _key) external view returns (uint8) {\r\n        return uInt8Storage[_key];\r\n    }\r\n\r\n\r\n    /// @param _key The key for the record\r\n    function getString(bytes32 _key) external view returns (string) {\r\n        return stringStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function getBytes(bytes32 _key) external view returns (bytes) {\r\n        return bytesStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function getBytes32(bytes32 _key) external view returns (bytes32) {\r\n        return bytes32Storage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function getBool(bytes32 _key) external view returns (bool) {\r\n        return boolStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function getInt(bytes32 _key) external view returns (int) {\r\n        return intStorage[_key];\r\n    }\r\n\r\n    /**** Set Methods ***********/\r\n\r\n    /// @param _key The key for the record\r\n    function setAddress(bytes32 _key, address _value) onlyLatestContract external {\r\n        addressStorage[_key] = _value;\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function setUint(bytes32 _key, uint _value) onlyLatestContract external {\r\n        uIntStorage[_key] = _value;\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function setUint8(bytes32 _key, uint8 _value) onlyLatestContract external {\r\n        uInt8Storage[_key] = _value;\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function setString(bytes32 _key, string _value) onlyLatestContract external {\r\n        stringStorage[_key] = _value;\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function setBytes(bytes32 _key, bytes _value) onlyLatestContract external {\r\n        bytesStorage[_key] = _value;\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function setBytes32(bytes32 _key, bytes32 _value) onlyLatestContract external {\r\n        bytes32Storage[_key] = _value;\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function setBool(bytes32 _key, bool _value) onlyLatestContract external {\r\n        boolStorage[_key] = _value;\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function setInt(bytes32 _key, int _value) onlyLatestContract external {\r\n        intStorage[_key] = _value;\r\n    }\r\n\r\n    /**** Delete Methods ***********/\r\n\r\n    /// @param _key The key for the record\r\n    function deleteAddress(bytes32 _key) onlyLatestContract external {\r\n        delete addressStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function deleteUint(bytes32 _key) onlyLatestContract external {\r\n        delete uIntStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function deleteUint8(bytes32 _key) onlyLatestContract external {\r\n        delete uInt8Storage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function deleteString(bytes32 _key) onlyLatestContract external {\r\n        delete stringStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function deleteBytes(bytes32 _key) onlyLatestContract external {\r\n        delete bytesStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function deleteBytes32(bytes32 _key) onlyLatestContract external {\r\n        delete bytes32Storage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function deleteBool(bytes32 _key) onlyLatestContract external {\r\n        delete boolStorage[_key];\r\n    }\r\n\r\n    /// @param _key The key for the record\r\n    function deleteInt(bytes32 _key) onlyLatestContract external {\r\n        delete intStorage[_key];\r\n    }\r\n}\r\n\r\ncontract PaymentHolder is Ownable {\r\n\r\n    modifier onlyAllowed() {\r\n        require(allowed[msg.sender]);\r\n        _;\r\n    }\r\n\r\n    modifier onlyUpdater() {\r\n        require(msg.sender == updater);\r\n        _;\r\n    }\r\n\r\n    mapping(address => bool) public allowed;\r\n    address public updater;\r\n\r\n    /*-----------------MAINTAIN METHODS------------------*/\r\n\r\n    function setUpdater(address _updater)\r\n    external onlyOwner {\r\n        updater = _updater;\r\n    }\r\n\r\n    function migrate(address newHolder, address[] tokens, address[] _allowed)\r\n    external onlyOwner {\r\n        require(PaymentHolder(newHolder).update.value(address(this).balance)(_allowed));\r\n        for (uint256 i = 0; i < tokens.length; i++) {\r\n            address token = tokens[i];\r\n            uint256 balance = Token(token).balanceOf(this);\r\n            if (balance > 0) {\r\n                require(Token(token).transfer(newHolder, balance));\r\n            }\r\n        }\r\n    }\r\n\r\n    function update(address[] _allowed)\r\n    external payable onlyUpdater returns(bool) {\r\n        for (uint256 i = 0; i < _allowed.length; i++) {\r\n            allowed[_allowed[i]] = true;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /*-----------------OWNER FLOW------------------*/\r\n\r\n    function allow(address to) \r\n    external onlyOwner { allowed[to] = true; }\r\n\r\n    function prohibit(address to)\r\n    external onlyOwner { allowed[to] = false; }\r\n\r\n    /*-----------------ALLOWED FLOW------------------*/\r\n\r\n    function depositEth()\r\n    public payable onlyAllowed returns (bool) {\r\n        //Default function to receive eth\r\n        return true;\r\n    }\r\n\r\n    function withdrawEth(address to, uint256 amount)\r\n    public onlyAllowed returns(bool) {\r\n        require(address(this).balance >= amount, \"Not enough ETH balance\");\r\n        to.transfer(amount);\r\n        return true;\r\n    }\r\n\r\n    function withdrawToken(address to, uint256 amount, address token)\r\n    public onlyAllowed returns(bool) {\r\n        require(Token(token).balanceOf(this) >= amount, \"Not enough token balance\");\r\n        require(Token(token).transfer(to, amount));\r\n        return true;\r\n    }\r\n}\r\n\r\nlibrary EscrowConfigLib {\r\n\r\n    function getPaymentFee(address storageAddress) public view returns (uint8) {\r\n        return EternalStorage(storageAddress).getUint8(keccak256(abi.encodePacked(\"escrow.config.payment.fee\")));\r\n    }\r\n\r\n    function setPaymentFee(address storageAddress, uint8 value) public {\r\n        EternalStorage(storageAddress).setUint8(keccak256(abi.encodePacked(\"escrow.config.payment.fee\")), value);\r\n    }\r\n\r\n}\r\n\r\ncontract ICourt is Ownable {\r\n\r\n    function getCaseId(address applicant, address respondent, bytes32 deal, uint256 date, bytes32 title, uint256 amount) \r\n        public pure returns(bytes32);\r\n\r\n    function getCaseStatus(bytes32 caseId) public view returns(uint8);\r\n\r\n    function getCaseVerdict(bytes32 caseId) public view returns(bool);\r\n}\r\n\r\ncontract EscrowConfig is Ownable {\r\n\r\n    using EscrowConfigLib for address;\r\n\r\n    address public config;\r\n\r\n    constructor(address storageAddress) public {\r\n        config = storageAddress;\r\n    }\r\n\r\n    function resetValuesToDefault() external onlyOwner {\r\n        config.setPaymentFee(2);//%\r\n    }\r\n\r\n    function setStorageAddress(address storageAddress) external onlyOwner {\r\n        config = storageAddress;\r\n    }\r\n\r\n    function getPaymentFee() external view returns (uint8) {\r\n        return config.getPaymentFee();\r\n    }\r\n\r\n    //value - % of payment amount\r\n    function setPaymentFee(uint8 value) external onlyOwner {\r\n        require(value >= 0 && value < 100, \"Fee in % of payment amount must be >= 0 and < 100\");\r\n        config.setPaymentFee(value);\r\n    }\r\n}\r\n\r\ncontract Withdrawable is Ownable {\r\n    function withdrawEth(uint value) external onlyOwner {\r\n        require(address(this).balance >= value);\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    function withdrawToken(address token, uint value) external onlyOwner {\r\n        require(Token(token).balanceOf(address(this)) >= value, \"Not enough tokens\");\r\n        require(Token(token).transfer(msg.sender, value));\r\n    }\r\n}\r\n\r\nlibrary PaymentLib {\r\n\r\n    function getPaymentId(address[3] addresses, bytes32 deal, uint256 amount) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(addresses[0], addresses[1], addresses[2], deal, amount));\r\n    }\r\n\r\n    function createPayment(\r\n        address storageAddress, bytes32 paymentId, uint8 fee, uint8 status, bool feePayed\r\n    ) public {\r\n        setPaymentStatus(storageAddress, paymentId, status);\r\n        setPaymentFee(storageAddress, paymentId, fee);\r\n        if (feePayed) {\r\n            setFeePayed(storageAddress, paymentId, true);\r\n        }\r\n    }\r\n\r\n    function isCancelRequested(address storageAddress, bytes32 paymentId, address party)\r\n    public view returns(bool) {\r\n        return EternalStorage(storageAddress).getBool(keccak256(abi.encodePacked(\"payment.cance\", paymentId, party)));\r\n    }\r\n\r\n    function setCancelRequested(address storageAddress, bytes32 paymentId, address party, bool value)\r\n    public {\r\n        EternalStorage(storageAddress).setBool(keccak256(abi.encodePacked(\"payment.cance\", paymentId, party)), value);\r\n    }\r\n\r\n    function getPaymentFee(address storageAddress, bytes32 paymentId)\r\n    public view returns (uint8) {\r\n        return EternalStorage(storageAddress).getUint8(keccak256(abi.encodePacked(\"payment.fee\", paymentId)));\r\n    }\r\n\r\n    function setPaymentFee(address storageAddress, bytes32 paymentId, uint8 value)\r\n    public {\r\n        EternalStorage(storageAddress).setUint8(keccak256(abi.encodePacked(\"payment.fee\", paymentId)), value);\r\n    }\r\n\r\n    function isFeePayed(address storageAddress, bytes32 paymentId)\r\n    public view returns (bool) {\r\n        return EternalStorage(storageAddress).getBool(keccak256(abi.encodePacked(\"payment.fee.payed\", paymentId)));\r\n    }\r\n\r\n    function setFeePayed(address storageAddress, bytes32 paymentId, bool value)\r\n    public {\r\n        EternalStorage(storageAddress).setBool(keccak256(abi.encodePacked(\"payment.fee.payed\", paymentId)), value);\r\n    }\r\n\r\n    function isDeposited(address storageAddress, bytes32 paymentId)\r\n    public view returns (bool) {\r\n        return EternalStorage(storageAddress).getBool(keccak256(abi.encodePacked(\"payment.deposited\", paymentId)));\r\n    }\r\n\r\n    function setDeposited(address storageAddress, bytes32 paymentId, bool value)\r\n    public {\r\n        EternalStorage(storageAddress).setBool(keccak256(abi.encodePacked(\"payment.deposited\", paymentId)), value);\r\n    }\r\n\r\n    function isSigned(address storageAddress, bytes32 paymentId)\r\n    public view returns (bool) {\r\n        return EternalStorage(storageAddress).getBool(keccak256(abi.encodePacked(\"payment.signed\", paymentId)));\r\n    }\r\n\r\n    function setSigned(address storageAddress, bytes32 paymentId, bool value)\r\n    public {\r\n        EternalStorage(storageAddress).setBool(keccak256(abi.encodePacked(\"payment.signed\", paymentId)), value);\r\n    }\r\n\r\n    function getPaymentStatus(address storageAddress, bytes32 paymentId)\r\n    public view returns (uint8) {\r\n        return EternalStorage(storageAddress).getUint8(keccak256(abi.encodePacked(\"payment.status\", paymentId)));\r\n    }\r\n\r\n    function setPaymentStatus(address storageAddress, bytes32 paymentId, uint8 status)\r\n    public {\r\n        EternalStorage(storageAddress).setUint8(keccak256(abi.encodePacked(\"payment.status\", paymentId)), status);\r\n    }\r\n\r\n    function getOfferAmount(address storageAddress, bytes32 paymentId, address user)\r\n    public view returns (uint256) {\r\n        return EternalStorage(storageAddress).getUint(keccak256(abi.encodePacked(\"payment.amount.refund\", paymentId, user)));\r\n    }\r\n\r\n    function setOfferAmount(address storageAddress, bytes32 paymentId, address user, uint256 amount)\r\n    public {\r\n        EternalStorage(storageAddress).setUint(keccak256(abi.encodePacked(\"payment.amount.refund\", paymentId, user)), amount);\r\n    }\r\n\r\n    function getWithdrawAmount(address storageAddress, bytes32 paymentId, address user)\r\n    public view returns (uint256) {\r\n        return EternalStorage(storageAddress).getUint(keccak256(abi.encodePacked(\"payment.amount.withdraw\", paymentId, user)));\r\n    }\r\n\r\n    function setWithdrawAmount(address storageAddress, bytes32 paymentId, address user, uint256 amount)\r\n    public {\r\n        EternalStorage(storageAddress).setUint(keccak256(abi.encodePacked(\"payment.amount.withdraw\", paymentId, user)), amount);\r\n    }\r\n\r\n    function isWithdrawn(address storageAddress, bytes32 paymentId, address user)\r\n    public view returns (bool) {\r\n        return EternalStorage(storageAddress).getBool(keccak256(abi.encodePacked(\"payment.withdrawed\", paymentId, user)));\r\n    }\r\n\r\n    function setWithdrawn(address storageAddress, bytes32 paymentId, address user, bool value)\r\n    public {\r\n        EternalStorage(storageAddress).setBool(keccak256(abi.encodePacked(\"payment.withdrawed\", paymentId, user)), value);\r\n    }\r\n\r\n    function getPayment(address storageAddress, bytes32 paymentId)\r\n    public view returns(\r\n        uint8 status, uint8 fee, bool feePayed, bool signed, bool deposited\r\n    ) {\r\n        status = uint8(getPaymentStatus(storageAddress, paymentId));\r\n        fee = getPaymentFee(storageAddress, paymentId);\r\n        feePayed = isFeePayed(storageAddress, paymentId);\r\n        signed = isSigned(storageAddress, paymentId);\r\n        deposited = isDeposited(storageAddress, paymentId);\r\n    }\r\n\r\n    function getPaymentOffers(address storageAddress, address depositor, address beneficiary, bytes32 paymentId)\r\n    public view returns(uint256 depositorOffer, uint256 beneficiaryOffer) {\r\n        depositorOffer = getOfferAmount(storageAddress, paymentId, depositor);\r\n        beneficiaryOffer = getOfferAmount(storageAddress, paymentId, beneficiary);\r\n    }\r\n}\r\n\r\ncontract IEscrow is Withdrawable {\r\n\r\n    /*----------------------PAYMENT STATUSES----------------------*/\r\n\r\n    //SIGNED status kept for backward compatibility\r\n    enum PaymentStatus {NONE/*code=0*/, CREATED/*code=1*/, SIGNED/*code=2*/, CONFIRMED/*code=3*/, RELEASED/*code=4*/, RELEASED_BY_DISPUTE /*code=5*/, CLOSED/*code=6*/, CANCELED/*code=7*/}\r\n\r\n    /*----------------------EVENTS----------------------*/\r\n\r\n    event PaymentCreated(bytes32 paymentId, address depositor, address beneficiary, address token, bytes32 deal, uint256 amount, uint8 fee, bool feePayed);\r\n    event PaymentSigned(bytes32 paymentId, bool confirmed);\r\n    event PaymentDeposited(bytes32 paymentId, uint256 depositedAmount, bool confirmed);\r\n    event PaymentReleased(bytes32 paymentId);\r\n    event PaymentOffer(bytes32 paymentId, uint256 offerAmount);\r\n    event PaymentOfferCanceled(bytes32 paymentId);\r\n    event PaymentOwnOfferCanceled(bytes32 paymentId);\r\n    event PaymentOfferAccepted(bytes32 paymentId, uint256 releaseToBeneficiary, uint256 refundToDepositor);\r\n    event PaymentWithdrawn(bytes32 paymentId, uint256 amount);\r\n    event PaymentWithdrawnByDispute(bytes32 paymentId, uint256 amount, bytes32 dispute);\r\n    event PaymentCanceled(bytes32 paymentId);\r\n    event PaymentClosed(bytes32 paymentId);\r\n    event PaymentClosedByDispute(bytes32 paymentId, bytes32 dispute);\r\n\r\n    /*----------------------PUBLIC STATE----------------------*/\r\n\r\n    address public lib;\r\n    address public courtAddress;\r\n    address public paymentHolder;\r\n\r\n\r\n    /*----------------------CONFIGURATION METHODS (only owner) ----------------------*/\r\n    function setStorageAddress(address _storageAddress) external;\r\n\r\n    function setCourtAddress(address _courtAddress) external;\r\n\r\n    /*----------------------PUBLIC USER METHODS----------------------*/\r\n    /** @dev Depositor creates escrow payment. Set token as 0x0 in case of ETH amount.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      * @param depositorPayFee If true, depositor have to send (amount + (amount * fee) / 100).\r\n      */\r\n    function createPayment(address[3] addresses, bytes32 deal, uint256 amount, bool depositorPayFee) external;\r\n\r\n    /** @dev Beneficiary signs escrow payment as consent for taking part.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function sign(address[3] addresses, bytes32 deal, uint256 amount) external;\r\n\r\n    /** @dev Depositor deposits payment amount only after it was signed by beneficiary.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function deposit(address[3] addresses, bytes32 deal, uint256 amount) external payable;\r\n\r\n    /** @dev Depositor or Beneficiary requests payment cancellation after payment was signed by beneficiary.\r\n      *      Payment is closed, if depositor and beneficiary both request cancellation.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function cancel(address[3] addresses, bytes32 deal, uint256 amount) external;\r\n\r\n    /** @dev Depositor close payment though transfer payment amount to another party.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function release(address[3] addresses, bytes32 deal, uint256 amount) external;\r\n\r\n    /** @dev Depositor or beneficiary offers partial closing payment with offerAmount.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      * @param offerAmount Amount of partial closing offer in currency of payment (ETH or token).\r\n      */\r\n    function offer(address[3] addresses, bytes32 deal, uint256 amount, uint256 offerAmount) external;\r\n\r\n    /** @dev Depositor or beneficiary canceles another party offer.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function cancelOffer(address[3] addresses, bytes32 deal, uint256 amount) external;\r\n\r\n    /** @dev Depositor or beneficiary cancels own offer.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function cancelOwnOffer(address[3] addresses, bytes32 deal, uint256 amount) external;\r\n\r\n    /** @dev Depositor or beneficiary accepts opposite party offer.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function acceptOffer(address[3] addresses, bytes32 deal, uint256 amount) external;\r\n\r\n\r\n    /** @dev Depositor or beneficiary withdraw amounts.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function withdraw(address[3] addresses, bytes32 deal, uint256 amount) external;\r\n\r\n    /** @dev Depositor or Beneficiary withdraw amounts according dispute verdict.\r\n      * @dev Have to use fucking arrays due to \"stack too deep\" issue.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      * @param disputeParties [applicant, respondent]\r\n      * @param uints [paymentAmount, disputeAmount, disputeCreatedAt]\r\n      * @param byts [deal, disputeTitle]\r\n      */\r\n    function withdrawByDispute(address[3] addresses, address[2] disputeParties, uint256[3] uints, bytes32[2] byts) external;\r\n}\r\n\r\ncontract Escrow is IEscrow {\r\n    using PaymentLib for address;\r\n    using EscrowConfigLib for address;\r\n\r\n    constructor(address storageAddress, address _paymentHolder, address _courtAddress) public {\r\n        lib = storageAddress;\r\n        courtAddress = _courtAddress;\r\n        paymentHolder = _paymentHolder;\r\n    }\r\n\r\n    /*----------------------CONFIGURATION METHODS----------------------*/\r\n\r\n    function setStorageAddress(address _storageAddress) external onlyOwner {\r\n        lib = _storageAddress;\r\n    }\r\n\r\n    function setPaymentHolder(address _paymentHolder) external onlyOwner {\r\n        paymentHolder = _paymentHolder;\r\n    }\r\n\r\n    function setCourtAddress(address _courtAddress) external onlyOwner {\r\n        courtAddress = _courtAddress;\r\n    }\r\n\r\n    /*----------------------PUBLIC USER METHODS----------------------*/\r\n\r\n    /** @dev Depositor creates escrow payment. Set token as 0x0 in case of ETH amount.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      * @param depositorPayFee If true, depositor have to send (amount + (amount * fee) / 100).\r\n      */\r\n    function createPayment(address[3] addresses, bytes32 deal, uint256 amount, bool depositorPayFee)\r\n    external {\r\n        onlyParties(addresses);\r\n        require(addresses[0] != address(0), \"Depositor can not be 0x0 address\");\r\n        require(addresses[1] != address(0), \"Beneficiary can not be 0x0 address\");\r\n        require(addresses[0] != addresses[1], \"Depositor and beneficiary can not be the same\");\r\n        require(deal != 0x0, \"deal can not be 0x0\");\r\n        require(amount != 0, \"amount can not be 0\");\r\n        bytes32 paymentId = getPaymentId(addresses, deal, amount);\r\n        checkStatus(paymentId, PaymentStatus.NONE);\r\n        uint8 fee = lib.getPaymentFee();\r\n        lib.createPayment(paymentId, fee, uint8(PaymentStatus.CREATED), depositorPayFee);\r\n        emit PaymentCreated(paymentId, addresses[0], addresses[1], addresses[2], deal, amount, fee, depositorPayFee);\r\n    }\r\n\r\n    /** @dev Beneficiary signs escrow payment as consent for taking part.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function sign(address[3] addresses, bytes32 deal, uint256 amount)\r\n    external {\r\n        onlyBeneficiary(addresses);\r\n        bytes32 paymentId = getPaymentId(addresses, deal, amount);\r\n        require(!lib.isSigned(paymentId), \"Payment can be signed only once\");\r\n        checkStatus(paymentId, PaymentStatus.CREATED);\r\n        lib.setSigned(paymentId, true);\r\n        bool confirmed = lib.isDeposited(paymentId);\r\n        if (confirmed) {\r\n            setPaymentStatus(paymentId, PaymentStatus.CONFIRMED);\r\n        }\r\n        emit PaymentSigned(paymentId, confirmed);\r\n    }\r\n\r\n    /** @dev Depositor deposits payment amount only after it was signed by beneficiary\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function deposit(address[3] addresses, bytes32 deal, uint256 amount)\r\n    external payable {\r\n        onlyDepositor(addresses);\r\n        bytes32 paymentId = getPaymentId(addresses, deal, amount);\r\n        PaymentStatus status = getPaymentStatus(paymentId);\r\n        require(!lib.isDeposited(paymentId), \"Payment can be deposited only once\");\r\n        require(status == PaymentStatus.CREATED || status == PaymentStatus.SIGNED, \"Invalid current payment status\");\r\n        uint256 depositAmount = amount;\r\n        if (lib.isFeePayed(paymentId)) {\r\n            depositAmount = amount + calcFee(amount, lib.getPaymentFee(paymentId));\r\n        }\r\n        address token = getToken(addresses);\r\n        if (token == address(0)) {\r\n            require(msg.value == depositAmount, \"ETH amount must be equal amount\");\r\n            require(PaymentHolder(paymentHolder).depositEth.value(msg.value)(), \"Not enough eth\");\r\n        } else {\r\n            require(msg.value == 0, \"ETH amount must be 0 for token transfer\");\r\n            require(Token(token).allowance(msg.sender, address(this)) >= depositAmount, \"Not enough token allowance\");\r\n            require(Token(token).balanceOf(msg.sender) >= depositAmount, \"No enough tokens\");\r\n            require(Token(token).transferFrom(msg.sender, paymentHolder, depositAmount), \"Error during transafer tokens\");\r\n        }\r\n        lib.setDeposited(paymentId, true);\r\n        bool confirmed = lib.isSigned(paymentId);\r\n        if (confirmed) {\r\n            setPaymentStatus(paymentId, PaymentStatus.CONFIRMED);\r\n        }\r\n        emit PaymentDeposited(paymentId, depositAmount, confirmed);\r\n    }\r\n\r\n    /** @dev Depositor or Beneficiary requests payment cancellation after payment was signed by beneficiary.\r\n      *      Payment is closed, if depositor and beneficiary both request cancellation.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function cancel(address[3] addresses, bytes32 deal, uint256 amount)\r\n    external {\r\n        onlyParties(addresses);\r\n        bytes32 paymentId = getPaymentId(addresses, deal, amount);\r\n        checkStatus(paymentId, PaymentStatus.CREATED);\r\n        setPaymentStatus(paymentId, PaymentStatus.CANCELED);\r\n        if (lib.isDeposited(paymentId)) {\r\n            uint256 amountToRefund = amount;\r\n            if (lib.isFeePayed(paymentId)) {\r\n                amountToRefund = amount + calcFee(amount, lib.getPaymentFee(paymentId));\r\n            }\r\n            transfer(getDepositor(addresses), amountToRefund, getToken(addresses));\r\n        }\r\n        setPaymentStatus(paymentId, PaymentStatus.CANCELED);\r\n        emit PaymentCanceled(paymentId);\r\n        emit PaymentCanceled(paymentId);\r\n    }\r\n\r\n    /** @dev Depositor close payment though transfer payment amount to another party.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function release(address[3] addresses, bytes32 deal, uint256 amount)\r\n    external {\r\n        onlyDepositor(addresses);\r\n        bytes32 paymentId = getPaymentId(addresses, deal, amount);\r\n        checkStatus(paymentId, PaymentStatus.CONFIRMED);\r\n        doRelease(addresses, [amount, 0], paymentId);\r\n        emit PaymentReleased(paymentId);\r\n    }\r\n\r\n    /** @dev Depositor or beneficiary offers partial closing payment with offerAmount.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      * @param offerAmount Amount of partial closing offer in currency of payment (ETH or token).\r\n      */\r\n    function offer(address[3] addresses, bytes32 deal, uint256 amount, uint256 offerAmount)\r\n    external {\r\n        onlyParties(addresses);\r\n        require(offerAmount >= 0 && offerAmount <= amount, \"Offer amount must be >= 0 and <= payment amount\");\r\n        bytes32 paymentId = getPaymentId(addresses, deal, amount);\r\n        uint256 anotherOfferAmount = lib.getOfferAmount(paymentId, getAnotherParty(addresses));\r\n        require(anotherOfferAmount == 0, \"Sender can not make offer if another party has done the same before\");\r\n        lib.setOfferAmount(paymentId, msg.sender, offerAmount);\r\n        emit PaymentOffer(paymentId, offerAmount);\r\n    }\r\n\r\n    /** @dev Depositor or beneficiary cancels opposite party offer.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function cancelOffer(address[3] addresses, bytes32 deal, uint256 amount)\r\n    external {\r\n        bytes32 paymentId = doCancelOffer(addresses, deal, amount, getAnotherParty(addresses));\r\n        emit PaymentOfferCanceled(paymentId);\r\n    }\r\n\r\n    /** @dev Depositor or beneficiary cancels own offer.\r\n    * @param addresses [depositor, beneficiary, token]\r\n    */\r\n    function cancelOwnOffer(address[3] addresses, bytes32 deal, uint256 amount)\r\n    external {\r\n        bytes32 paymentId = doCancelOffer(addresses, deal, amount, msg.sender);\r\n        emit PaymentOwnOfferCanceled(paymentId);\r\n    }\r\n\r\n    /** @dev Depositor or beneficiary accepts opposite party offer.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function acceptOffer(address[3] addresses, bytes32 deal, uint256 amount)\r\n    external {\r\n        onlyParties(addresses);\r\n        bytes32 paymentId = getPaymentId(addresses, deal, amount);\r\n        checkStatus(paymentId, PaymentStatus.CONFIRMED);\r\n        uint256 offerAmount = lib.getOfferAmount(paymentId, getAnotherParty(addresses));\r\n        require(offerAmount != 0, \"Sender can not accept another party offer of 0\");\r\n        uint256 toBeneficiary = offerAmount;\r\n        uint256 toDepositor = amount - offerAmount;\r\n        //if sender is beneficiary\r\n        if (msg.sender == addresses[1]) {\r\n            toBeneficiary = amount - offerAmount;\r\n            toDepositor = offerAmount;\r\n        }\r\n        doRelease(addresses, [toBeneficiary, toDepositor], paymentId);\r\n        emit PaymentOfferAccepted(paymentId, toBeneficiary, toDepositor);\r\n    }\r\n\r\n    /** @dev Depositor or beneficiary withdraw amounts.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      */\r\n    function withdraw(address[3] addresses, bytes32 deal, uint256 amount)\r\n    external {\r\n        onlyParties(addresses);\r\n        bytes32 paymentId = getPaymentId(addresses, deal, amount);\r\n        checkStatus(paymentId, PaymentStatus.RELEASED);\r\n        require(!lib.isWithdrawn(paymentId, msg.sender), \"User can not withdraw twice.\");\r\n        uint256 withdrawAmount = lib.getWithdrawAmount(paymentId, msg.sender);\r\n        withdrawAmount = transferWithFee(msg.sender, withdrawAmount, addresses[2], paymentId);\r\n        emit PaymentWithdrawn(paymentId, withdrawAmount);\r\n        lib.setWithdrawn(paymentId, msg.sender, true);\r\n        address anotherParty = getAnotherParty(addresses);\r\n        if (lib.getWithdrawAmount(paymentId, anotherParty) == 0 || lib.isWithdrawn(paymentId, anotherParty)) {\r\n            setPaymentStatus(paymentId, PaymentStatus.CLOSED);\r\n            emit PaymentClosed(paymentId);\r\n        }\r\n    }\r\n\r\n    /** @dev Depositor or Beneficiary withdraw amounts according dispute verdict.\r\n      * @dev Have to use fucking arrays due to \"stack too deep\" issue.\r\n      * @param addresses [depositor, beneficiary, token]\r\n      * @param disputeParties [applicant, respondent]\r\n      * @param uints [paymentAmount, disputeAmount, disputeCreatedAt]\r\n      * @param byts [deal, disputeTitle]\r\n      */\r\n    function withdrawByDispute(address[3] addresses, address[2] disputeParties, uint256[3] uints, bytes32[2] byts)\r\n    external {\r\n        onlyParties(addresses);\r\n        require(\r\n            addresses[0] == disputeParties[0] && addresses[1] == disputeParties[1] || addresses[0] == disputeParties[1] && addresses[1] == disputeParties[0],\r\n            \"Depositor and beneficiary must be dispute parties\"\r\n        );\r\n        bytes32 paymentId = getPaymentId(addresses, byts[0], uints[0]);\r\n        PaymentStatus paymentStatus = getPaymentStatus(paymentId);\r\n        require(paymentStatus == PaymentStatus.CONFIRMED || paymentStatus == PaymentStatus.RELEASED_BY_DISPUTE, \"Invalid current payment status\");\r\n        require(!lib.isWithdrawn(paymentId, msg.sender), \"User can not withdraw twice.\");\r\n        bytes32 dispute = ICourt(courtAddress).getCaseId(\r\n            disputeParties[0] /*applicant*/, disputeParties[1]/*respondent*/,\r\n            paymentId/*deal*/, uints[2]/*disputeCreatedAt*/,\r\n            byts[1]/*disputeTitle*/, uints[1]/*disputeAmount*/\r\n        );\r\n        require(ICourt(courtAddress).getCaseStatus(dispute) == 3, \"Case must be closed\");\r\n        /*[releaseAmount, refundAmount]*/\r\n        uint256[2] memory withdrawAmounts = [uint256(0), 0];\r\n        bool won = ICourt(courtAddress).getCaseVerdict(dispute);\r\n        //depositor == applicant\r\n        if (won) {\r\n            //use paymentAmount if disputeAmount is greater\r\n            withdrawAmounts[0] = uints[1] > uints[0] ? uints[0] : uints[1];\r\n            withdrawAmounts[1] = uints[0] - withdrawAmounts[0];\r\n        } else {\r\n            //make full release\r\n            withdrawAmounts[1] = uints[0];\r\n        }\r\n        if (msg.sender != disputeParties[0]) {\r\n            withdrawAmounts[0] = withdrawAmounts[0] + withdrawAmounts[1];\r\n            withdrawAmounts[1] = withdrawAmounts[0] - withdrawAmounts[1];\r\n            withdrawAmounts[0] = withdrawAmounts[0] - withdrawAmounts[1];\r\n        }\r\n        address anotherParty = getAnotherParty(addresses);\r\n        //if sender is depositor\r\n        withdrawAmounts[0] = transferWithFee(msg.sender, withdrawAmounts[0], addresses[2], paymentId);\r\n        emit PaymentWithdrawnByDispute(paymentId, withdrawAmounts[0], dispute);\r\n        lib.setWithdrawn(paymentId, msg.sender, true);\r\n        if (withdrawAmounts[1] == 0 || lib.isWithdrawn(paymentId, anotherParty)) {\r\n            setPaymentStatus(paymentId, PaymentStatus.CLOSED);\r\n            emit PaymentClosedByDispute(paymentId, dispute);\r\n        } else {\r\n            //need to prevent withdraw by another flow, e.g. simple release or offer accepting\r\n            setPaymentStatus(paymentId, PaymentStatus.RELEASED_BY_DISPUTE);\r\n        }\r\n    }\r\n\r\n    /*------------------PRIVATE METHODS----------------------*/\r\n    function getPaymentId(address[3] addresses, bytes32 deal, uint256 amount)\r\n    public pure returns (bytes32) {return PaymentLib.getPaymentId(addresses, deal, amount);}\r\n\r\n    function getDepositor(address[3] addresses) private pure returns (address) {return addresses[0];}\r\n\r\n    function getBeneficiary(address[3] addresses) private pure returns (address) {return addresses[1];}\r\n\r\n    function getToken(address[3] addresses) private pure returns (address) {return addresses[2];}\r\n\r\n    function getAnotherParty(address[3] addresses) private view returns (address) {\r\n        return msg.sender == addresses[0] ? addresses[1] : addresses[0];\r\n    }\r\n\r\n    function onlyParties(address[3] addresses) private view {require(msg.sender == addresses[0] || msg.sender == addresses[1]);}\r\n\r\n    function onlyDepositor(address[3] addresses) private view {require(msg.sender == addresses[0]);}\r\n\r\n    function onlyBeneficiary(address[3] addresses) private view {require(msg.sender == addresses[1]);}\r\n\r\n    function getPaymentStatus(bytes32 paymentId)\r\n    private view returns (PaymentStatus) {\r\n        return PaymentStatus(lib.getPaymentStatus(paymentId));\r\n    }\r\n\r\n    function setPaymentStatus(bytes32 paymentId, PaymentStatus status)\r\n    private {\r\n        lib.setPaymentStatus(paymentId, uint8(status));\r\n    }\r\n\r\n    function checkStatus(bytes32 paymentId, PaymentStatus status)\r\n    private view {\r\n        require(lib.getPaymentStatus(paymentId) == uint8(status), \"Required status does not match actual one\");\r\n    }\r\n\r\n    function doCancelOffer(address[3] addresses, bytes32 deal, uint256 amount, address from)\r\n    private returns(bytes32 paymentId) {\r\n        onlyParties(addresses);\r\n        paymentId = getPaymentId(addresses, deal, amount);\r\n        checkStatus(paymentId, PaymentStatus.CONFIRMED);\r\n        uint256 offerAmount = lib.getOfferAmount(paymentId, from);\r\n        require(offerAmount != 0, \"Sender can not cancel offer of 0\");\r\n        lib.setOfferAmount(paymentId, from, 0);\r\n    }\r\n\r\n    /** @param addresses [depositor, beneficiary, token]\r\n      * @param amounts [releaseAmount, refundAmount]\r\n      */\r\n    function doRelease(address[3] addresses, uint256[2] amounts, bytes32 paymentId)\r\n    private {\r\n        setPaymentStatus(paymentId, PaymentStatus.RELEASED);\r\n        lib.setWithdrawAmount(paymentId, getBeneficiary(addresses), amounts[0]);\r\n        lib.setWithdrawAmount(paymentId, getDepositor(addresses), amounts[1]);\r\n    }\r\n\r\n    function transferWithFee(address to, uint256 amount, address token, bytes32 paymentId)\r\n    private returns (uint256 amountMinusFee) {\r\n        require(amount != 0, \"There is sense to invoke this method if withdraw amount is 0.\");\r\n        uint8 fee = 0;\r\n        if (!lib.isFeePayed(paymentId)) {\r\n            fee = lib.getPaymentFee(paymentId);\r\n        }\r\n        amountMinusFee = amount - calcFee(amount, fee);\r\n        transfer(to, amountMinusFee, token);\r\n    }\r\n\r\n    function transfer(address to, uint256 amount, address token)\r\n    private {\r\n        if (amount == 0) {\r\n            return;\r\n        }\r\n        if (token == address(0)) {\r\n            require(PaymentHolder(paymentHolder).withdrawEth(to, amount), \"Error during withdraw ETH\");\r\n        } else {\r\n            require(PaymentHolder(paymentHolder).withdrawToken(to, amount, token), \"Error during withdraw Token\");\r\n        }\r\n    }\r\n\r\n    function calcFee(uint amount, uint fee)\r\n    private pure returns (uint256) {\r\n        return ((amount * fee) / 100);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"sign\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"disputeParties\",\"type\":\"address[2]\"},{\"name\":\"uints\",\"type\":\"uint256[3]\"},{\"name\":\"byts\",\"type\":\"bytes32[2]\"}],\"name\":\"withdrawByDispute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"depositorPayFee\",\"type\":\"bool\"}],\"name\":\"createPayment\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_storageAddress\",\"type\":\"address\"}],\"name\":\"setStorageAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancelOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"getPaymentId\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paymentHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_paymentHolder\",\"type\":\"address\"}],\"name\":\"setPaymentHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_courtAddress\",\"type\":\"address\"}],\"name\":\"setCourtAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lib\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"token\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawToken\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"acceptOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"courtAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"cancelOwnOffer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"withdrawEth\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"release\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"addresses\",\"type\":\"address[3]\"},{\"name\":\"deal\",\"type\":\"bytes32\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"offerAmount\",\"type\":\"uint256\"}],\"name\":\"offer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"storageAddress\",\"type\":\"address\"},{\"name\":\"_paymentHolder\",\"type\":\"address\"},{\"name\":\"_courtAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"depositor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"deal\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"fee\",\"type\":\"uint8\"},{\"indexed\":false,\"name\":\"feePayed\",\"type\":\"bool\"}],\"name\":\"PaymentCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"confirmed\",\"type\":\"bool\"}],\"name\":\"PaymentSigned\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"depositedAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"confirmed\",\"type\":\"bool\"}],\"name\":\"PaymentDeposited\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"PaymentReleased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"offerAmount\",\"type\":\"uint256\"}],\"name\":\"PaymentOffer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"PaymentOfferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"PaymentOwnOfferCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"releaseToBeneficiary\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"refundToDepositor\",\"type\":\"uint256\"}],\"name\":\"PaymentOfferAccepted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PaymentWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dispute\",\"type\":\"bytes32\"}],\"name\":\"PaymentWithdrawnByDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"PaymentCanceled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"}],\"name\":\"PaymentClosed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"paymentId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"dispute\",\"type\":\"bytes32\"}],\"name\":\"PaymentClosedByDispute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Escrow","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007a690e2f34cf4277a15733d926926f39810635a7000000000000000000000000a40a4959b20f565d371ef8967604c76560896c64000000000000000000000000df7b14d1101e22d502234240385dd72f05cfc0d2","Library":"PaymentLib:70edf62a31c67116e2c1abdd16721dcefbd40b7c;EscrowConfigLib:37ca21783f23ac3455c97deea6484ae4a2571835","SwarmSource":"bzzr://df5d282251da892bb5bd4c981514810000e1f5e7fc6d2bc4fb98136f3ba215cc"}]}