{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall,\r\n        Create\r\n    }\r\n}\r\n\r\ncontract EtherPaymentFallback {\r\n\r\n    /// @dev Fallback function accepts Ether transactions.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n\r\n    }\r\n}\r\n\r\ncontract Executor is EtherPaymentFallback {\r\n\r\n    event ContractCreation(address newContract);\r\n\r\n    function execute(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else {\r\n            address newContract = executeCreate(data);\r\n            success = newContract != 0;\r\n            emit ContractCreation(newContract);\r\n        }\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeCreate(bytes data)\r\n        internal\r\n        returns (address newContract)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            newContract := create(0, add(data, 0x20), mload(data))\r\n        }\r\n    }\r\n}\r\n\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n\r\n    address public constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address => address) internal modules;\r\n    \r\n    function setupModules(address to, bytes data)\r\n        internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == 0, \"Modules have already been initialized\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != 0)\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != 0 && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        // Module cannot be added twice.\r\n        require(modules[module] == 0, \"Module has already been added\");\r\n        modules[module] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = module;\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != 0 && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        require(modules[prevModule] == address(module), \"Invalid prevModule, module pair provided\");\r\n        modules[prevModule] = modules[module];\r\n        modules[module] = 0;\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes data, Enum.Operation operation)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(modules[msg.sender] != 0, \"Method can only be called from an enabled module\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        // Calculate module count\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        address[] memory array = new address[](moduleCount);\r\n\r\n        // populate return array\r\n        moduleCount = 0;\r\n        currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\ncontract OwnerManager is SelfAuthorized {\r\n\r\n    event AddedOwner(address owner);\r\n    event RemovedOwner(address owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    address public constant SENTINEL_OWNERS = address(0x1);\r\n\r\n    mapping(address => address) internal owners;\r\n    uint256 ownerCount;\r\n    uint256 internal threshold;\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _owners List of Safe owners.\r\n    /// @param _threshold Number of required confirmations for a Safe transaction.\r\n    function setupOwners(address[] _owners, uint256 _threshold)\r\n        internal\r\n    {\r\n        // Threshold can only be 0 at initialization.\r\n        // Check ensures that setup function can only be called once.\r\n        require(threshold == 0, \"Owners have already been setup\");\r\n        // Validate that threshold is smaller than number of added owners.\r\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        // Initializing Safe owners.\r\n        address currentOwner = SENTINEL_OWNERS;\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            // Owner address cannot be null.\r\n            address owner = _owners[i];\r\n            require(owner != 0 && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n            // No duplicate owners allowed.\r\n            require(owners[owner] == 0, \"Duplicate owner address provided\");\r\n            owners[currentOwner] = owner;\r\n            currentOwner = owner;\r\n        }\r\n        owners[currentOwner] = SENTINEL_OWNERS;\r\n        ownerCount = _owners.length;\r\n        threshold = _threshold;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param owner New owner address.\r\n    /// @param _threshold New threshold.\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(owner != 0 && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[owner] == 0, \"Address is already an owner\");\r\n        owners[owner] = owners[SENTINEL_OWNERS];\r\n        owners[SENTINEL_OWNERS] = owner;\r\n        ownerCount++;\r\n        emit AddedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n    /// @param owner Owner address to be removed.\r\n    /// @param _threshold New threshold.\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Only allow to remove an owner, if threshold can still be reached.\r\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\r\n        // Validate owner address and check that it corresponds to owner index.\r\n        require(owner != 0 && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[prevOwner] = owners[owner];\r\n        owners[owner] = 0;\r\n        ownerCount--;\r\n        emit RemovedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n    /// @param oldOwner Owner address to be replaced.\r\n    /// @param newOwner New owner address.\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\r\n        public\r\n        authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(newOwner != 0 && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[newOwner] == 0, \"Address is already an owner\");\r\n        // Validate oldOwner address and check that it corresponds to owner index.\r\n        require(oldOwner != 0 && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[newOwner] = owners[oldOwner];\r\n        owners[prevOwner] = newOwner;\r\n        owners[oldOwner] = 0;\r\n        emit RemovedOwner(oldOwner);\r\n        emit AddedOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to update the number of required confirmations by Safe owners.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param _threshold New threshold.\r\n    function changeThreshold(uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate that threshold is smaller than number of owners.\r\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        threshold = _threshold;\r\n        emit ChangedThreshold(threshold);\r\n    }\r\n\r\n    function getThreshold()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return threshold;\r\n    }\r\n\r\n    function isOwner(address owner)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return owners[owner] != 0;\r\n    }\r\n\r\n    /// @dev Returns array of owners.\r\n    /// @return Array of Safe owners.\r\n    function getOwners()\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        address[] memory array = new address[](ownerCount);\r\n\r\n        // populate return array\r\n        uint256 index = 0;\r\n        address currentOwner = owners[SENTINEL_OWNERS];\r\n        while(currentOwner != SENTINEL_OWNERS) {\r\n            array[index] = currentOwner;\r\n            currentOwner = owners[currentOwner];\r\n            index ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\ncontract MasterCopy is SelfAuthorized {\r\n  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n  // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address masterCopy;\r\n\r\n  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n  /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != 0, \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n}\r\n\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n        internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == 0, \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\ncontract SocialRecoveryModule is Module {\r\n\r\n    string public constant NAME = \"Social Recovery Module\";\r\n    string public constant VERSION = \"0.0.2\";\r\n\r\n    uint256 public threshold;\r\n    address[] public friends;\r\n\r\n    // isFriend mapping maps friend's address to friend status.\r\n    mapping (address => bool) public isFriend;\r\n    // isExecuted mapping maps data hash to execution status.\r\n    mapping (bytes32 => bool) public isExecuted;\r\n    // isConfirmed mapping maps data hash to friend's address to confirmation status.\r\n    mapping (bytes32 => mapping (address => bool)) public isConfirmed;\r\n\r\n    modifier onlyFriend() {\r\n        require(isFriend[msg.sender], \"Method can only be called by a friend\");\r\n        _;\r\n    }\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _friends List of friends' addresses.\r\n    /// @param _threshold Required number of friends to confirm replacement.\r\n    function setup(address[] _friends, uint256 _threshold)\r\n        public\r\n    {\r\n        require(_threshold <= _friends.length, \"Threshold cannot exceed friends count\");\r\n        require(_threshold >= 2, \"At least 2 friends required\");\r\n        setManager();\r\n        // Set allowed friends.\r\n        for (uint256 i = 0; i < _friends.length; i++) {\r\n            address friend = _friends[i];\r\n            require(friend != 0, \"Invalid friend address provided\");\r\n            require(!isFriend[friend], \"Duplicate friend address provided\");\r\n            isFriend[friend] = true;\r\n        }\r\n        friends = _friends;\r\n        threshold = _threshold;\r\n    }\r\n\r\n    /// @dev Allows a friend to confirm a Safe transaction.\r\n    /// @param dataHash Safe transaction hash.\r\n    function confirmTransaction(bytes32 dataHash)\r\n        public\r\n        onlyFriend\r\n    {\r\n        require(!isExecuted[dataHash], \"Recovery already executed\");\r\n        isConfirmed[dataHash][msg.sender] = true;\r\n    }\r\n\r\n    /// @dev Returns if Safe transaction is a valid owner replacement transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n    /// @param oldOwner Owner address to be replaced.\r\n    /// @param newOwner New owner address.\r\n    /// @return Returns if transaction can be executed.\r\n    function recoverAccess(address prevOwner, address oldOwner, address newOwner)\r\n        public\r\n        onlyFriend\r\n    {\r\n        bytes memory data = abi.encodeWithSignature(\"swapOwner(address,address,address)\", prevOwner, oldOwner, newOwner);\r\n        bytes32 dataHash = getDataHash(data);\r\n        require(!isExecuted[dataHash], \"Recovery already executed\");\r\n        require(isConfirmedByRequiredFriends(dataHash), \"Recovery has not enough confirmations\");\r\n        isExecuted[dataHash] = true;\r\n        require(manager.execTransactionFromModule(address(manager), 0, data, Enum.Operation.Call), \"Could not execute recovery\");\r\n    }\r\n\r\n    /// @dev Returns if Safe transaction is a valid owner replacement transaction.\r\n    /// @param dataHash Data hash.\r\n    /// @return Confirmation status.\r\n    function isConfirmedByRequiredFriends(bytes32 dataHash)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        uint256 confirmationCount;\r\n        for (uint256 i = 0; i < friends.length; i++) {\r\n            if (isConfirmed[dataHash][friends[i]])\r\n                confirmationCount++;\r\n            if (confirmationCount == threshold)\r\n                return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /// @dev Returns hash of data encoding owner replacement.\r\n    /// @param data Data payload.\r\n    /// @return Data hash.\r\n    function getDataHash(bytes data)\r\n        public\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(data);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"threshold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_friends\",\"type\":\"address[]\"},{\"name\":\"_threshold\",\"type\":\"uint256\"}],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isFriend\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"prevOwner\",\"type\":\"address\"},{\"name\":\"oldOwner\",\"type\":\"address\"},{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"recoverAccess\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"confirmTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"changeMasterCopy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"dataHash\",\"type\":\"bytes32\"}],\"name\":\"isConfirmedByRequiredFriends\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"getDataHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isConfirmed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"friends\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isExecuted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"SocialRecoveryModule","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://99d8cc17559a51f9880a265b61389096d8d4a80a214327a8f7ca1f84a083a963"}]}