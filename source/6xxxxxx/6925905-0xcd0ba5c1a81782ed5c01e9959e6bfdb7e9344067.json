{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b > 0); // Solidity only automatically asserts when dividing by 0\r\n    uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Divides two numbers and returns the remainder (unsigned integer modulo),\r\n  * reverts when dividing by zero.\r\n  */\r\n  function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b != 0);\r\n    return a % b;\r\n  }\r\n}\r\n\r\n// File: solidity-rlp/contracts/RLPReader.sol\r\n\r\n/*\r\n* @author Hamdi Allam hamdi.allam97@gmail.com\r\n* Please reach out with any questions or concerns\r\n*/\r\npragma solidity ^0.4.24;\r\n\r\nlibrary RLPReader {\r\n    uint8 constant STRING_SHORT_START = 0x80;\r\n    uint8 constant STRING_LONG_START  = 0xb8;\r\n    uint8 constant LIST_SHORT_START   = 0xc0;\r\n    uint8 constant LIST_LONG_START    = 0xf8;\r\n\r\n    uint8 constant WORD_SIZE = 32;\r\n\r\n    struct RLPItem {\r\n        uint len;\r\n        uint memPtr;\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded bytes\r\n    */\r\n    function toRlpItem(bytes memory item) internal pure returns (RLPItem memory) {\r\n        if (item.length == 0) \r\n            return RLPItem(0, 0);\r\n\r\n        uint memPtr;\r\n        assembly {\r\n            memPtr := add(item, 0x20)\r\n        }\r\n\r\n        return RLPItem(item.length, memPtr);\r\n    }\r\n\r\n    /*\r\n    * @param item RLP encoded list in bytes\r\n    */\r\n    function toList(RLPItem memory item) internal pure returns (RLPItem[] memory result) {\r\n        require(isList(item));\r\n\r\n        uint items = numItems(item);\r\n        result = new RLPItem[](items);\r\n\r\n        uint memPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint dataLen;\r\n        for (uint i = 0; i < items; i++) {\r\n            dataLen = _itemLength(memPtr);\r\n            result[i] = RLPItem(dataLen, memPtr); \r\n            memPtr = memPtr + dataLen;\r\n        }\r\n    }\r\n\r\n    /*\r\n    * Helpers\r\n    */\r\n\r\n    // @return indicator whether encoded payload is a list. negate this function call for isData.\r\n    function isList(RLPItem memory item) internal pure returns (bool) {\r\n        uint8 byte0;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < LIST_SHORT_START)\r\n            return false;\r\n        return true;\r\n    }\r\n\r\n    // @return number of payload items inside an encoded list.\r\n    function numItems(RLPItem memory item) internal pure returns (uint) {\r\n        uint count = 0;\r\n        uint currPtr = item.memPtr + _payloadOffset(item.memPtr);\r\n        uint endPtr = item.memPtr + item.len;\r\n        while (currPtr < endPtr) {\r\n           currPtr = currPtr + _itemLength(currPtr); // skip over an item\r\n           count++;\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    // @return entire rlp item byte length\r\n    function _itemLength(uint memPtr) internal pure returns (uint len) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START)\r\n            return 1;\r\n        \r\n        else if (byte0 < STRING_LONG_START)\r\n            return byte0 - STRING_SHORT_START + 1;\r\n\r\n        else if (byte0 < LIST_SHORT_START) {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xb7) // # of bytes the actual length is\r\n                memPtr := add(memPtr, 1) // skip over the first byte\r\n                \r\n                /* 32 byte word size */\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to get the len\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n\r\n        else if (byte0 < LIST_LONG_START) {\r\n            return byte0 - LIST_SHORT_START + 1;\r\n        } \r\n\r\n        else {\r\n            assembly {\r\n                let byteLen := sub(byte0, 0xf7)\r\n                memPtr := add(memPtr, 1)\r\n\r\n                let dataLen := div(mload(memPtr), exp(256, sub(32, byteLen))) // right shifting to the correct length\r\n                len := add(dataLen, add(byteLen, 1))\r\n            }\r\n        }\r\n    }\r\n\r\n    // @return number of bytes until the data\r\n    function _payloadOffset(uint memPtr) internal pure returns (uint) {\r\n        uint byte0;\r\n        assembly {\r\n            byte0 := byte(0, mload(memPtr))\r\n        }\r\n\r\n        if (byte0 < STRING_SHORT_START) \r\n            return 0;\r\n        else if (byte0 < STRING_LONG_START || (byte0 >= LIST_SHORT_START && byte0 < LIST_LONG_START))\r\n            return 1;\r\n        else if (byte0 < LIST_SHORT_START)  // being explicit\r\n            return byte0 - (STRING_LONG_START - 1) + 1;\r\n        else\r\n            return byte0 - (LIST_LONG_START - 1) + 1;\r\n    }\r\n\r\n    /** RLPItem conversions into data types **/\r\n\r\n    // @returns raw rlp encoding in bytes\r\n    function toRlpBytes(RLPItem memory item) internal pure returns (bytes) {\r\n        bytes memory result = new bytes(item.len);\r\n        \r\n        uint ptr;\r\n        assembly {\r\n            ptr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr, ptr, item.len);\r\n        return result;\r\n    }\r\n\r\n    function toBoolean(RLPItem memory item) internal pure returns (bool) {\r\n        require(item.len == 1, \"Invalid RLPItem. Booleans are encoded in 1 byte\");\r\n        uint result;\r\n        uint memPtr = item.memPtr;\r\n        assembly {\r\n            result := byte(0, mload(memPtr))\r\n        }\r\n\r\n        return result == 0 ? false : true;\r\n    }\r\n\r\n    function toAddress(RLPItem memory item) internal pure returns (address) {\r\n        // 1 byte for the length prefix according to RLP spec\r\n        require(item.len <= 21, \"Invalid RLPItem. Addresses are encoded in 20 bytes or less\");\r\n\r\n        return address(toUint(item));\r\n    }\r\n\r\n    function toUint(RLPItem memory item) internal pure returns (uint) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset;\r\n        uint memPtr = item.memPtr + offset;\r\n\r\n        uint result;\r\n        assembly {\r\n            result := div(mload(memPtr), exp(256, sub(32, len))) // shift to the correct location\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    function toBytes(RLPItem memory item) internal pure returns (bytes) {\r\n        uint offset = _payloadOffset(item.memPtr);\r\n        uint len = item.len - offset; // data length\r\n        bytes memory result = new bytes(len);\r\n\r\n        uint destPtr;\r\n        assembly {\r\n            destPtr := add(0x20, result)\r\n        }\r\n\r\n        copy(item.memPtr + offset, destPtr, len);\r\n        return result;\r\n    }\r\n\r\n\r\n    /*\r\n    * @param src Pointer to source\r\n    * @param dest Pointer to destination\r\n    * @param len Amount of memory to copy from the source\r\n    */\r\n    function copy(uint src, uint dest, uint len) internal pure {\r\n        // copy as many word sizes as possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n\r\n            src += WORD_SIZE;\r\n            dest += WORD_SIZE;\r\n        }\r\n\r\n        // left over bytes. Mask is used to remove unwanted bytes from the word\r\n        uint mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask)) // zero out src\r\n            let destpart := and(mload(dest), mask) // retrieve the bytes\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n}\r\n\r\n// File: contracts/BlockHash.sol\r\n\r\ncontract BlockHash {\r\n    using SafeMath for uint256;\r\n    using RLPReader for RLPReader.RLPItem;\r\n\r\n    mapping (uint256 => bytes32) private _hashes;\r\n\r\n    function blockhashes(\r\n        uint256 blockNumber\r\n    )\r\n        public\r\n        view\r\n        returns(bytes32)\r\n    {\r\n        if (blockNumber >= block.number.sub(256)) {\r\n            return blockhash(blockNumber);\r\n        }\r\n\r\n        return _hashes[blockNumber];\r\n    }\r\n\r\n    function addBlocks(\r\n        uint256 blockNumber,\r\n        bytes blocksData,\r\n        uint256[] starts\r\n    )\r\n        public\r\n    {\r\n        require(starts.length > 0 && starts[starts.length - 1] == blocksData.length, \"Wrong starts argument\");\r\n\r\n        bytes32 expectedHash = blockhashes(blockNumber);\r\n        for (uint i = 0; i < starts.length - 1; i++) {\r\n            uint256 offset = starts[i];\r\n            uint256 length = starts[i + 1].sub(starts[i]);\r\n            bytes32 result;\r\n            uint256 ptr;\r\n            assembly {\r\n                ptr := add(add(blocksData, 0x20), offset)\r\n                result := keccak256(ptr, length)\r\n            }\r\n\r\n            require(result == expectedHash, \"Blockhash didn't match\");\r\n            expectedHash = bytes32(RLPReader.RLPItem({len: length, memPtr: ptr}).toList()[0].toUint());\r\n        }\r\n        \r\n        uint256 index = blockNumber.add(1).sub(starts.length);\r\n        if (_hashes[index] == 0) {\r\n            _hashes[index] = expectedHash;\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"blocksData\",\"type\":\"bytes\"},{\"name\":\"starts\",\"type\":\"uint256[]\"}],\"name\":\"addBlocks\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"name\":\"blockhashes\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BlockHash","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://03903c449a71e669dcfcfd82b397e6e9f18791dfe60084090c65557e7223b48f"}]}