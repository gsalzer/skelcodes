{"status":"1","message":"OK","result":[{"SourceCode":"contract RNG{\r\n\r\n    /** @dev Contribute to the reward of a random number.\r\n     *  @param _block Block the random number is linked to.\r\n     */\r\n    function contribute(uint _block) public payable;\r\n\r\n    /** @dev Request a random number.\r\n     *  @param _block Block linked to the request.\r\n     */\r\n    function requestRN(uint _block) public payable {\r\n        contribute(_block);\r\n    }\r\n\r\n    /** @dev Get the random number.\r\n     *  @param _block Block the random number is linked to.\r\n     *  @return RN Random Number. If the number is not ready or has not been required 0 instead.\r\n     */\r\n    function getRN(uint _block) public returns (uint RN);\r\n\r\n    /** @dev Get a uncorrelated random number. Act like getRN but give a different number for each sender.\r\n     *  This is to prevent users from getting correlated numbers.\r\n     *  @param _block Block the random number is linked to.\r\n     *  @return RN Random Number. If the number is not ready or has not been required 0 instead.\r\n     */\r\n    function getUncorrelatedRN(uint _block) public returns (uint RN) {\r\n        uint baseRN=getRN(_block);\r\n        if (baseRN==0)\r\n            return 0;\r\n        else\r\n            return uint(keccak256(msg.sender,baseRN));\r\n    }\r\n\r\n }\r\n\r\n/** Simple Random Number Generator returning the blockhash.\r\n *  Allows saving the random number for use in the future.\r\n *  It allows the contract to still access the blockhash even after 256 blocks.\r\n *  The first party to call the save function gets the reward.\r\n */\r\ncontract BlockHashRNG is RNG {\r\n\r\n    mapping (uint => uint) public randomNumber; // randomNumber[block] is the random number for this block, 0 otherwise.\r\n    mapping (uint => uint) public reward; // reward[block] is the amount to be paid to the party w.\r\n\r\n\r\n\r\n    /** @dev Contribute to the reward of a random number.\r\n     *  @param _block Block the random number is linked to.\r\n     */\r\n    function contribute(uint _block) public payable { reward[_block]+=msg.value; }\r\n\r\n\r\n    /** @dev Return the random number. If it has not been saved and is still computable compute it.\r\n     *  @param _block Block the random number is linked to.\r\n     *  @return RN Random Number. If the number is not ready or has not been requested 0 instead.\r\n     */\r\n    function getRN(uint _block) public returns (uint RN) {\r\n        RN=randomNumber[_block];\r\n        if (RN==0){\r\n            saveRN(_block);\r\n            return randomNumber[_block];\r\n        }\r\n        else\r\n            return RN;\r\n    }\r\n\r\n    /** @dev Save the random number for this blockhash and give the reward to the caller.\r\n     *  @param _block Block the random number is linked to.\r\n     */\r\n    function saveRN(uint _block) public {\r\n        if (blockhash(_block) != 0x0)\r\n            randomNumber[_block] = uint(blockhash(_block));\r\n        if (randomNumber[_block] != 0) { // If the number is set.\r\n            uint rewardToSend = reward[_block];\r\n            reward[_block] = 0;\r\n            msg.sender.send(rewardToSend); // Note that the use of send is on purpose as we don't want to block in case msg.sender has a fallback issue.\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n/** Random Number Generator returning the blockhash with a backup behaviour.\r\n *  Allows saving the random number for use in the future. \r\n *  It allows the contract to still access the blockhash even after 256 blocks.\r\n *  The first party to call the save function gets the reward.\r\n *  If no one calls the contract within 256 blocks, the contract fallback in returning the blockhash of the previous block.\r\n */\r\ncontract BlockHashRNGFallback is BlockHashRNG {\r\n    \r\n    /** @dev Save the random number for this blockhash and give the reward to the caller.\r\n     *  @param _block Block the random number is linked to.\r\n     */\r\n    function saveRN(uint _block) public {\r\n        if (_block<block.number && randomNumber[_block]==0) {// If the random number is not already set and can be.\r\n            if (blockhash(_block)!=0x0) // Normal case.\r\n                randomNumber[_block]=uint(blockhash(_block));\r\n            else // The contract was not called in time. Fallback to returning previous blockhash.\r\n                randomNumber[_block]=uint(blockhash(block.number-1));\r\n        }\r\n        if (randomNumber[_block] != 0) { // If the random number is set.\r\n            uint rewardToSend=reward[_block];\r\n            reward[_block]=0;\r\n            msg.sender.send(rewardToSend); // Note that the use of send is on purpose as we don't want to block in case the msg.sender has a fallback issue.\r\n        }\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"getUncorrelatedRN\",\"outputs\":[{\"name\":\"RN\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"requestRN\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"reward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"saveRN\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"contribute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_block\",\"type\":\"uint256\"}],\"name\":\"getRN\",\"outputs\":[{\"name\":\"RN\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"randomNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"BlockHashRNGFallback","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://cab53dc4914892d9aee658acc497654d9c50fc1d85bdda5cb91ac532036960e8"}]}