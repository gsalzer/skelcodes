{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract ERC721Basic {\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\r\n    event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\r\n    event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n\r\n    function approve(address _to, uint256 _tokenId) public;\r\n\r\n    function getApproved(uint256 _tokenId) public view returns (address _operator);\r\n\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n\r\n    function isApprovedForAll(address _owner, address _operator) public view returns (bool);\r\n\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n\r\n    //    function safeTransferFrom(\r\n    //        address _from,\r\n    //        address _to,\r\n    //        uint256 _tokenId,\r\n    //        bytes _data\r\n    //    )\r\n    //    public;\r\n}\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Enumerable is ERC721Basic {\r\n    function totalSupply() public view returns (uint256);\r\n\r\n    function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId);\r\n\r\n    function tokenByIndex(uint256 _index) public view returns (uint256);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721Metadata is ERC721Basic {\r\n    function name() public view returns (string _name);\r\n\r\n    function symbol() public view returns (string _symbol);\r\n\r\n    function tokenURI(uint256 _tokenId) public view returns (string);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC-721 Non-Fungible Token Standard, full implementation interface\r\n * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md\r\n */\r\ncontract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata {\r\n}\r\n\r\ncontract ToonInterface is ERC721 {\r\n\r\n    function isToonInterface() external pure returns (bool);\r\n\r\n    /**\r\n    * @notice   Returns an address of the toon author. 0x0 if\r\n    *           the toon has been created by us.\r\n    */\r\n    function authorAddress() external view returns (address);\r\n\r\n    /**\r\n    * @notice   Returns maximum supply. In other words there will\r\n    *           be never more toons that that number. It has to\r\n    *           be constant.\r\n    *           If there is no limit function returns 0.\r\n    */\r\n    function maxSupply() external view returns (uint256);\r\n\r\n    function getToonInfo(uint _id) external view returns (\r\n        uint genes,\r\n        uint birthTime,\r\n        address owner\r\n    );\r\n\r\n}\r\n\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n     * @param newOwner The address to transfer ownership to.\r\n     */\r\n    function transferOwnership(address newOwner) public onlyOwner {\r\n        require(newOwner != address(0));\r\n        emit OwnershipTransferred(owner, newOwner);\r\n        owner = newOwner;\r\n    }\r\n\r\n}\r\n\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS paused\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev modifier to allow actions only when the contract IS NOT paused\r\n     */\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() public onlyOwner whenNotPaused returns (bool) {\r\n        paused = true;\r\n        emit Pause();\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() public onlyOwner whenPaused returns (bool) {\r\n        paused = false;\r\n        emit Unpause();\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract Withdrawable {\r\n\r\n    mapping(address => uint) private pendingWithdrawals;\r\n\r\n    event Withdrawal(address indexed receiver, uint amount);\r\n    event BalanceChanged(address indexed _address, uint oldBalance, uint newBalance);\r\n\r\n    /**\r\n    * Returns amount of wei that given address is able to withdraw.\r\n    */\r\n    function getPendingWithdrawal(address _address) public view returns (uint) {\r\n        return pendingWithdrawals[_address];\r\n    }\r\n\r\n    /**\r\n    * Add pending withdrawal for an address.\r\n    */\r\n    function addPendingWithdrawal(address _address, uint _amount) internal {\r\n        require(_address != 0x0);\r\n\r\n        uint oldBalance = pendingWithdrawals[_address];\r\n        pendingWithdrawals[_address] += _amount;\r\n\r\n        emit BalanceChanged(_address, oldBalance, oldBalance + _amount);\r\n    }\r\n\r\n    /**\r\n    * Withdraws all pending withdrawals.\r\n    */\r\n    function withdraw() external {\r\n        uint amount = getPendingWithdrawal(msg.sender);\r\n        require(amount > 0);\r\n\r\n        pendingWithdrawals[msg.sender] = 0;\r\n        msg.sender.transfer(amount);\r\n\r\n        emit Withdrawal(msg.sender, amount);\r\n        emit BalanceChanged(msg.sender, amount, 0);\r\n    }\r\n\r\n}\r\n\r\ncontract ClockAuctionBase is Withdrawable, Pausable {\r\n\r\n    // Represents an auction on an NFT\r\n    struct Auction {\r\n        // Address of a contract\r\n        address _contract;\r\n        // Current owner of NFT\r\n        address seller;\r\n        // Price (in wei) at beginning of auction\r\n        uint128 startingPrice;\r\n        // Price (in wei) at end of auction\r\n        uint128 endingPrice;\r\n        // Duration (in seconds) of auction\r\n        uint64 duration;\r\n        // Time when auction started\r\n        // NOTE: 0 if this auction has been concluded\r\n        uint64 startedAt;\r\n    }\r\n\r\n    // Reference to contract tracking NFT ownership\r\n    ToonInterface[] public toonContracts;\r\n    mapping(address => uint256) addressToIndex;\r\n\r\n    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).\r\n    // Values 0-10,000 map to 0%-100%\r\n    uint256 public ownerCut;\r\n\r\n    // Values 0-10,000 map to 0%-100%\r\n    // Author's share from the owner cut.\r\n    uint256 public authorShare;\r\n\r\n    // Map from token ID to their corresponding auction.\r\n    //    mapping(uint256 => Auction) tokenIdToAuction;\r\n    mapping(address => mapping(uint256 => Auction)) tokenToAuction;\r\n\r\n    event AuctionCreated(address indexed _contract, uint256 indexed tokenId,\r\n        uint256 startingPrice, uint256 endingPrice, uint256 duration);\r\n    event AuctionSuccessful(address indexed _contract, uint256 indexed tokenId,\r\n        uint256 totalPrice, address indexed winner);\r\n    event AuctionCancelled(address indexed _contract, uint256 indexed tokenId);\r\n\r\n    /**\r\n    * @notice   Adds a new toon contract.\r\n    */\r\n    function addToonContract(address _toonContractAddress) external onlyOwner {\r\n        ToonInterface _interface = ToonInterface(_toonContractAddress);\r\n        require(_interface.isToonInterface());\r\n\r\n        uint _index = toonContracts.push(_interface) - 1;\r\n        addressToIndex[_toonContractAddress] = _index;\r\n    }\r\n\r\n    /// @dev Returns true if the claimant owns the token.\r\n    /// @param _contract - address of a toon contract\r\n    /// @param _claimant - Address claiming to own the token.\r\n    /// @param _tokenId - ID of token whose ownership to verify.\r\n    function _owns(address _contract, address _claimant, uint256 _tokenId)\r\n    internal\r\n    view\r\n    returns (bool) {\r\n        ToonInterface _interface = _interfaceByAddress(_contract);\r\n        address _owner = _interface.ownerOf(_tokenId);\r\n\r\n        return (_owner == _claimant);\r\n    }\r\n\r\n    /// @dev Escrows the NFT, assigning ownership to this contract.\r\n    /// Throws if the escrow fails.\r\n    /// @param _owner - Current owner address of token to escrow.\r\n    /// @param _tokenId - ID of token whose approval to verify.\r\n    function _escrow(address _contract, address _owner, uint256 _tokenId) internal {\r\n        ToonInterface _interface = _interfaceByAddress(_contract);\r\n        // it will throw if transfer fails\r\n        _interface.transferFrom(_owner, this, _tokenId);\r\n    }\r\n\r\n    /// @dev Transfers an NFT owned by this contract to another address.\r\n    /// Returns true if the transfer succeeds.\r\n    /// @param _receiver - Address to transfer NFT to.\r\n    /// @param _tokenId - ID of token to transfer.\r\n    function _transfer(address _contract, address _receiver, uint256 _tokenId) internal {\r\n        ToonInterface _interface = _interfaceByAddress(_contract);\r\n        // it will throw if transfer fails\r\n        _interface.transferFrom(this, _receiver, _tokenId);\r\n    }\r\n\r\n    /// @dev Adds an auction to the list of open auctions. Also fires the\r\n    ///  AuctionCreated event.\r\n    /// @param _tokenId The ID of the token to be put on auction.\r\n    /// @param _auction Auction to add.\r\n    function _addAuction(address _contract, uint256 _tokenId, Auction _auction) internal {\r\n        // Require that all auctions have a duration of\r\n        // at least one minute. (Keeps our math from getting hairy!)\r\n        require(_auction.duration >= 1 minutes);\r\n\r\n        _isAddressSupportedContract(_contract);\r\n        tokenToAuction[_contract][_tokenId] = _auction;\r\n\r\n        emit AuctionCreated(\r\n            _contract,\r\n            uint256(_tokenId),\r\n            uint256(_auction.startingPrice),\r\n            uint256(_auction.endingPrice),\r\n            uint256(_auction.duration)\r\n        );\r\n    }\r\n\r\n    /// @dev Cancels an auction unconditionally.\r\n    function _cancelAuction(address _contract, uint256 _tokenId, address _seller) internal {\r\n        _removeAuction(_contract, _tokenId);\r\n        _transfer(_contract, _seller, _tokenId);\r\n        emit AuctionCancelled(_contract, _tokenId);\r\n    }\r\n\r\n    /// @dev Computes the price and transfers winnings.\r\n    /// Does NOT transfer ownership of token.\r\n    function _bid(address _contract, uint256 _tokenId, uint256 _bidAmount)\r\n    internal\r\n    returns (uint256)\r\n    {\r\n        // Get a reference to the auction struct\r\n        Auction storage auction = tokenToAuction[_contract][_tokenId];\r\n        ToonInterface _interface = _interfaceByAddress(auction._contract);\r\n\r\n        // Explicitly check that this auction is currently live.\r\n        // (Because of how Ethereum mappings work, we can't just count\r\n        // on the lookup above failing. An invalid _tokenId will just\r\n        // return an auction object that is all zeros.)\r\n        require(_isOnAuction(auction));\r\n\r\n        // Check that the bid is greater than or equal to the current price\r\n        uint256 price = _currentPrice(auction);\r\n        require(_bidAmount >= price);\r\n\r\n        // Grab a reference to the seller before the auction struct\r\n        // gets deleted.\r\n        address seller = auction.seller;\r\n\r\n        // The bid is good! Remove the auction before sending the fees\r\n        // to the sender so we can't have a reentrancy attack.\r\n        _removeAuction(_contract, _tokenId);\r\n\r\n        // Transfer proceeds to seller (if there are any!)\r\n        if (price > 0) {\r\n            // Calculate the auctioneer's cut.\r\n            // (NOTE: _computeCut() is guaranteed to return a\r\n            // value <= price, so this subtraction can't go negative.)\r\n            uint256 auctioneerCut;\r\n            uint256 authorCut;\r\n            uint256 sellerProceeds;\r\n            (auctioneerCut, authorCut, sellerProceeds) = _computeCut(_interface, price);\r\n\r\n            if (authorCut > 0) {\r\n                address authorAddress = _interface.authorAddress();\r\n                addPendingWithdrawal(authorAddress, authorCut);\r\n            }\r\n\r\n            addPendingWithdrawal(owner, auctioneerCut);\r\n\r\n            // NOTE: Doing a transfer() in the middle of a complex\r\n            // method like this is generally discouraged because of\r\n            // reentrancy attacks and DoS attacks if the seller is\r\n            // a contract with an invalid fallback function. We explicitly\r\n            // guard against reentrancy attacks by removing the auction\r\n            // before calling transfer(), and the only thing the seller\r\n            // can DoS is the sale of their own asset! (And if it's an\r\n            // accident, they can call cancelAuction(). )\r\n            seller.transfer(sellerProceeds);\r\n        }\r\n\r\n        // Calculate any excess funds included with the bid. If the excess\r\n        // is anything worth worrying about, transfer it back to bidder.\r\n        // NOTE: We checked above that the bid amount is greater than or\r\n        // equal to the price so this cannot underflow.\r\n        uint256 bidExcess = _bidAmount - price;\r\n\r\n        // Return the funds. Similar to the previous transfer, this is\r\n        // not susceptible to a re-entry attack because the auction is\r\n        // removed before any transfers occur.\r\n        msg.sender.transfer(bidExcess);\r\n\r\n        // Tell the world!\r\n        emit AuctionSuccessful(_contract, _tokenId, price, msg.sender);\r\n\r\n        return price;\r\n    }\r\n\r\n    /// @dev Removes an auction from the list of open auctions.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function _removeAuction(address _contract, uint256 _tokenId) internal {\r\n        delete tokenToAuction[_contract][_tokenId];\r\n    }\r\n\r\n    /// @dev Returns true if the NFT is on auction.\r\n    /// @param _auction - Auction to check.\r\n    function _isOnAuction(Auction storage _auction) internal view returns (bool) {\r\n        return (_auction.startedAt > 0);\r\n    }\r\n\r\n    /// @dev Returns current price of an NFT on auction. Broken into two\r\n    ///  functions (this one, that computes the duration from the auction\r\n    ///  structure, and the other that does the price computation) so we\r\n    ///  can easily test that the price computation works correctly.\r\n    function _currentPrice(Auction storage _auction)\r\n    internal\r\n    view\r\n    returns (uint256)\r\n    {\r\n        uint256 secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarnatees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _auction.startedAt) {\r\n            secondsPassed = now - _auction.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _auction.startingPrice,\r\n            _auction.endingPrice,\r\n            _auction.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    /// @dev Computes the current price of an auction. Factored out\r\n    ///  from _currentPrice so we can run extensive unit tests.\r\n    ///  When testing, make this function public and turn on\r\n    ///  `Current price computation` test suite.\r\n    function _computeCurrentPrice(\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        uint256 _secondsPassed\r\n    )\r\n    internal\r\n    pure\r\n    returns (uint256)\r\n    {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our public functions carefully cap the maximum values for\r\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\r\n        //  also known to be non-zero (see the require() statement in\r\n        //  _addAuction())\r\n        if (_secondsPassed >= _duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the auction, just return the end price.\r\n            return _endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that _startingPrice. Thus, this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    /// @dev Computes owner's cut of a sale.\r\n    /// @param _price - Sale price of NFT.\r\n    function _computeCut(ToonInterface _interface, uint256 _price) internal view returns (\r\n        uint256 ownerCutValue,\r\n        uint256 authorCutValue,\r\n        uint256 sellerProceeds\r\n    ) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our entry functions carefully cap the maximum values for\r\n        //  currency (at 128-bits), and ownerCut <= 10000 (see the require()\r\n        //  statement in the ClockAuction constructor). The result of this\r\n        //  function is always guaranteed to be <= _price.\r\n\r\n        uint256 _totalCut = _price * ownerCut / 10000;\r\n        uint256 _authorCut = 0;\r\n        uint256 _ownerCut = 0;\r\n        if (_interface.authorAddress() != 0x0) {\r\n            _authorCut = _totalCut * authorShare / 10000;\r\n        }\r\n\r\n        _ownerCut = _totalCut - _authorCut;\r\n        uint256 _sellerProfit = _price - _ownerCut - _authorCut;\r\n        require(_sellerProfit + _ownerCut + _authorCut == _price);\r\n\r\n        return (_ownerCut, _authorCut, _sellerProfit);\r\n    }\r\n\r\n    function _interfaceByAddress(address _address) internal view returns (ToonInterface) {\r\n        uint _index = addressToIndex[_address];\r\n        ToonInterface _interface = toonContracts[_index];\r\n        require(_address == address(_interface));\r\n\r\n        return _interface;\r\n    }\r\n\r\n    function _isAddressSupportedContract(address _address) internal view returns (bool) {\r\n        uint _index = addressToIndex[_address];\r\n        ToonInterface _interface = toonContracts[_index];\r\n        return _address == address(_interface);\r\n    }\r\n}\r\n\r\ncontract ClockAuction is ClockAuctionBase {\r\n\r\n    /// @dev The ERC-165 interface signature for ERC-721.\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/165\r\n    ///  Ref: https://github.com/ethereum/EIPs/issues/721\r\n    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);\r\n\r\n    bool public isSaleClockAuction = true;\r\n\r\n    /// @dev Constructor creates a reference to the NFT ownership contract\r\n    ///  and verifies the owner cut is in the valid range.\r\n    /// @param _ownerCut - percent cut the owner takes on each auction, must be\r\n    ///  between 0-10,000.\r\n    /// @param _authorShare - percent share of the author of the toon.\r\n    ///  Calculated from the ownerCut\r\n    constructor(uint256 _ownerCut, uint256 _authorShare) public {\r\n        require(_ownerCut <= 10000);\r\n        require(_authorShare <= 10000);\r\n\r\n        ownerCut = _ownerCut;\r\n        authorShare = _authorShare;\r\n    }\r\n\r\n    /// @dev Creates and begins a new auction.\r\n    /// @param _tokenId - ID of token to auction, sender must be owner.\r\n    /// @param _startingPrice - Price of item (in wei) at beginning of auction.\r\n    /// @param _endingPrice - Price of item (in wei) at end of auction.\r\n    /// @param _duration - Length of time to move between starting\r\n    ///  price and ending price (in seconds).\r\n    /// @param _seller - Seller, if not the message sender\r\n    function createAuction(\r\n        address _contract,\r\n        uint256 _tokenId,\r\n        uint256 _startingPrice,\r\n        uint256 _endingPrice,\r\n        uint256 _duration,\r\n        address _seller\r\n    )\r\n    external\r\n    whenNotPaused\r\n    {\r\n        require(_isAddressSupportedContract(_contract));\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the auction struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        _escrow(_contract, _seller, _tokenId);\r\n\r\n        Auction memory auction = Auction(\r\n            _contract,\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now)\r\n        );\r\n        _addAuction(_contract, _tokenId, auction);\r\n    }\r\n\r\n    /// @dev Bids on an open auction, completing the auction and transferring\r\n    ///  ownership of the NFT if enough Ether is supplied.\r\n    /// @param _tokenId - ID of token to bid on.\r\n    function bid(address _contract, uint256 _tokenId)\r\n    external\r\n    payable\r\n    whenNotPaused\r\n    {\r\n        // _bid will throw if the bid or funds transfer fails\r\n        _bid(_contract, _tokenId, msg.value);\r\n        _transfer(_contract, msg.sender, _tokenId);\r\n    }\r\n\r\n    /// @dev Cancels an auction that hasn't been won yet.\r\n    ///  Returns the NFT to original owner.\r\n    /// @notice This is a state-modifying function that can\r\n    ///  be called while the contract is paused.\r\n    /// @param _tokenId - ID of token on auction\r\n    function cancelAuction(address _contract, uint256 _tokenId)\r\n    external\r\n    {\r\n        Auction storage auction = tokenToAuction[_contract][_tokenId];\r\n        require(_isOnAuction(auction));\r\n        address seller = auction.seller;\r\n        require(msg.sender == seller);\r\n        _cancelAuction(_contract, _tokenId, seller);\r\n    }\r\n\r\n    /// @dev Cancels an auction when the contract is paused.\r\n    ///  Only the owner may do this, and NFTs are returned to\r\n    ///  the seller. This should only be used in emergencies.\r\n    /// @param _tokenId - ID of the NFT on auction to cancel.\r\n    function cancelAuctionWhenPaused(address _contract, uint256 _tokenId)\r\n    whenPaused\r\n    onlyOwner\r\n    external\r\n    {\r\n        Auction storage auction = tokenToAuction[_contract][_tokenId];\r\n        require(_isOnAuction(auction));\r\n        _cancelAuction(_contract, _tokenId, auction.seller);\r\n    }\r\n\r\n    /// @dev Returns auction info for an NFT on auction.\r\n    /// @param _tokenId - ID of NFT on auction.\r\n    function getAuction(address _contract, uint256 _tokenId)\r\n    external\r\n    view\r\n    returns\r\n    (\r\n        address seller,\r\n        uint256 startingPrice,\r\n        uint256 endingPrice,\r\n        uint256 duration,\r\n        uint256 startedAt,\r\n        uint256 currentPrice\r\n    ) {\r\n        Auction storage auction = tokenToAuction[_contract][_tokenId];\r\n\r\n        if (!_isOnAuction(auction)) {\r\n            return (0x0, 0, 0, 0, 0, 0);\r\n        }\r\n\r\n        return (\r\n        auction.seller,\r\n        auction.startingPrice,\r\n        auction.endingPrice,\r\n        auction.duration,\r\n        auction.startedAt,\r\n        getCurrentPrice(_contract, _tokenId)\r\n        );\r\n    }\r\n\r\n    /// @dev Returns the current price of an auction.\r\n    /// @param _tokenId - ID of the token price we are checking.\r\n    function getCurrentPrice(address _contract, uint256 _tokenId)\r\n    public\r\n    view\r\n    returns (uint256)\r\n    {\r\n        Auction storage auction = tokenToAuction[_contract][_tokenId];\r\n        require(_isOnAuction(auction));\r\n        return _currentPrice(auction);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuctionWhenPaused\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authorShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"bid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_toonContractAddress\",\"type\":\"address\"}],\"name\":\"addToonContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getCurrentPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"getAuction\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"currentPrice\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"getPendingWithdrawal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ownerCut\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"}],\"name\":\"cancelAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isSaleClockAuction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"toonContracts\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"createAuction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ownerCut\",\"type\":\"uint256\"},{\"name\":\"_authorShare\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"}],\"name\":\"AuctionCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"totalPrice\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"}],\"name\":\"AuctionSuccessful\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_contract\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"tokenId\",\"type\":\"uint256\"}],\"name\":\"AuctionCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"receiver\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"Withdrawal\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_address\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"oldBalance\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newBalance\",\"type\":\"uint256\"}],\"name\":\"BalanceChanged\",\"type\":\"event\"}]","ContractName":"ClockAuction","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000001860000000000000000000000000000000000000000000000000000000000001388","Library":"","SwarmSource":"bzzr://21f396a3455aca6911e0ebbe73041d60fefce0ce0da05fc938f7f1fb9e5b89c0"}]}