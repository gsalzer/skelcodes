{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.5.0;\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Integer division of two numbers, truncating the quotient.\r\n     */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n     */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n     * @dev Adds two numbers, throws on overflow.\r\n     */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n\r\n     \r\n\r\n \r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n    address public owner;\r\n\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n\r\n    /**\r\n     * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n     * account.\r\n     */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    /**\r\n     * @dev Throws if called by any account other than the owner.\r\n     */\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n    using SafeMath for uint256;\r\n\r\n    mapping(address => uint256) balances;\r\n\r\n    uint256 public totalSupply_;\r\n\r\n    /**\r\n     * @dev total number of tokens in existence\r\n     */\r\n    function totalSupply() public view returns (uint256) {\r\n        return totalSupply_;\r\n    }\r\n\r\n    /**\r\n     * @dev transfer token for a specified address\r\n     * @param _to The address to transfer to.\r\n     * @param _value The amount to be transferred.\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[msg.sender]);\r\n\r\n        // SafeMath.sub will throw if there is not enough balance.\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        emit Transfer (msg.sender, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Gets the balance of the specified address.\r\n     * @param _owner The address to query the the balance of.\r\n     * @return An uint256 representing the amount owned by the passed address.\r\n     */\r\n    function balanceOf(address _owner) public view returns (uint256 balance) {\r\n        return balances[_owner];\r\n    }\r\n\r\n}\r\n\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * @dev https://github.com/ethereum/EIPs/issues/20\r\n * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n    mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n    /**\r\n     * @dev Transfer tokens from one address to another\r\n     * @param _from address The address which you want to send tokens from\r\n     * @param _to address The address which you want to transfer to\r\n     * @param _value uint256 the amount of tokens to be transferred\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n        require(_to != address(0));\r\n        require(_value <= balances[_from]);\r\n        require(_value <= allowed[_from][msg.sender]);\r\n\r\n        balances[_from] = balances[_from].sub(_value);\r\n        balances[_to] = balances[_to].add(_value);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n        emit Transfer(_from, _to, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n     *\r\n     * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n     * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n     * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _value The amount of tokens to be spent.\r\n     */\r\n    function approve(address _spender, uint256 _value) public returns (bool) {\r\n        require(_value==0||allowed[msg.sender][_spender]==0);\r\n        allowed[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n     * @param _owner address The address which owns the funds.\r\n     * @param _spender address The address which will spend the funds.\r\n     * @return A uint256 specifying the amount of tokens still available for the spender.\r\n     */\r\n    function allowance(address _owner, address _spender) public view returns (uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n\r\n    /**\r\n     * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To increment\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _addedValue The amount of tokens to increase the allowance by.\r\n     */\r\n    function increaseApproval(address _spender, uint _addedValue) public returns (bool) {\r\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n     *\r\n     * approve should be called when allowed[_spender] == 0. To decrement\r\n     * allowed value is better to use this function to avoid 2 calls (and wait until\r\n     * the first transaction is mined)\r\n     * From MonolithDAO Token.sol\r\n     * @param _spender The address which will spend the funds.\r\n     * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n     */\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) {\r\n        uint oldValue = allowed[msg.sender][_spender];\r\n        if (_subtractedValue > oldValue) {\r\n            allowed[msg.sender][_spender] = 0;\r\n        } else {\r\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n        }\r\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n        return true;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n    event Pause();\r\n    event Unpause();\r\n\r\n    bool public paused = false;\r\n\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is not paused.\r\n     */\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev Modifier to make a function callable only when the contract is paused.\r\n     */\r\n    modifier whenPaused() {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to pause, triggers stopped state\r\n     */\r\n    function pause() onlyOwner whenNotPaused public {\r\n        paused = true;\r\n        emit Pause();\r\n    }\r\n\r\n    /**\r\n     * @dev called by the owner to unpause, returns to normal state\r\n     */\r\n    function unpause() onlyOwner whenPaused public {\r\n        paused = false;\r\n        emit Unpause();\r\n    }\r\n}\r\n\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n    function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transfer(_to, _value);\r\n    }\r\n\r\n    function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.transferFrom(_from, _to, _value);\r\n    }\r\n\r\n    function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) {\r\n        return super.approve(_spender, _value);\r\n    }\r\n\r\n    function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) {\r\n        return super.increaseApproval(_spender, _addedValue);\r\n    }\r\n\r\n    function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) {\r\n        return super.decreaseApproval(_spender, _subtractedValue);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Lock token\r\n * @dev Lock  which is defined the lock logic\r\n **/\r\ncontract  Lock is PausableToken{\r\n\r\n    mapping(address => uint256) public teamLockTime; // Lock start time\r\n    mapping(address => uint256) public fundLockTime; // Lock start time\r\n    uint256 public issueDate =0 ;//issueDate\r\n    mapping(address => uint256) public teamLocked;// Total Team lock \r\n    mapping(address => uint256) public fundLocked;// Total fund lock\r\n    mapping(address => uint256) public teamUsed;   // Team Used\r\n    mapping(address => uint256) public fundUsed;   // Fund Used\r\n    mapping(address => uint256) public teamReverse;   // Team reserve\r\n    mapping(address => uint256) public fundReverse;   // Fund reserve\r\n    \r\n\r\n   /**\r\n    * @dev Calculate the number of Tokens available for teamAccount\r\n    * @param _to teamAccount's address\r\n   */\r\n    function teamAvailable(address _to) internal view returns (uint256) {\r\n        require(teamLockTime[_to]>0);\r\n    \r\n        uint256 now1 = block.timestamp;\r\n        uint256 lockTime = teamLockTime[_to];\r\n        uint256 time = now1.sub(lockTime);\r\n        //Unlocked 20% first\r\n        uint256 percent = 20;\r\n        // 20% per 180 days after issue\r\n        if(time >= 180 days) {\r\n          percent =  (time.div(9 days)) .add(1);\r\n        }\r\n        percent = percent > 100 ? 100 : percent;\r\n        uint256 avail = teamLocked[_to];\r\n        require(avail>0);\r\n        avail = avail.mul(percent).div(100).sub(teamUsed[_to]);\r\n        return avail ;\r\n    }\r\n    \r\n    /**\r\n     * @dev Get the number of Tokens available for the current private fund account \r\n     * @param _to SLGCFundAccount's address\r\n    **/\r\n    function fundAvailable(address _to) internal view returns (uint256) {\r\n        require(fundLockTime[_to]>0);\r\n\r\n        //The start time of the lock position\r\n        uint256 lockTime = fundLockTime[_to];\r\n        //The interval between the current time and the start time of the lockout\r\n        uint256 time = block.timestamp.sub(lockTime);\r\n\r\n        //Unlocked 5% first\r\n        uint256 percent = 5000;\r\n        //unlocking 58/100000 per day\r\n        if(time >= 1 days) {\r\n            percent = percent.add( (((time.sub(1 days)).div (1 days)).add (1)).mul (58));\r\n        }\r\n        percent = percent > 100000 ? 100000 : percent;\r\n        uint256 avail = fundLocked[_to];\r\n        require(avail>0);\r\n        avail = avail.mul(percent).div(100000).sub(fundUsed[_to]);\r\n        return avail ;\r\n    }\r\n\r\n    /**\r\n      * @dev Team lock\r\n      * @param _to  team lock account's address\r\n      * @param _value the number of Token\r\n     */\r\n    function teamLock(address _to,uint256 _value) internal {\r\n        require(_value>0);\r\n        teamLocked[_to] = teamLocked[_to].add(_value);\r\n        teamReverse[_to] = teamReverse[_to].add(_value);\r\n        teamLockTime[_to] = block.timestamp;  // Lock start time\r\n    }\r\n\r\n    /**\r\n      * @dev  Privately offered fund lock\r\n      * @param _to  Privately offered fund account's address\r\n      * @param _value the number of Token\r\n     */\r\n    function fundLock(address _to,uint256 _value) internal {\r\n        require(_value>0);\r\n        fundLocked[_to] =fundLocked[_to].add(_value);\r\n        fundReverse[_to] = fundReverse[_to].add(_value);\r\n        if(fundLockTime[_to] == 0)\r\n          fundLockTime[_to] = block.timestamp;  // Lock start time\r\n    }\r\n\r\n    /**\r\n     * @dev Team account transaction\r\n     * @param _to  The accept token address\r\n     * @param _value Number of transactions\r\n     */\r\n    function teamLockTransfer(address _to, uint256 _value) internal returns (bool) {\r\n        //The remaining part\r\n       uint256 availReverse = balances[msg.sender].sub((teamLocked[msg.sender].sub(teamUsed[msg.sender]))+(fundLocked[msg.sender].sub(fundUsed[msg.sender])));\r\n       uint256 totalAvail=0;\r\n       uint256 availTeam =0;\r\n       if(issueDate==0)\r\n        {\r\n             totalAvail = availReverse;\r\n        }\r\n        else{\r\n            //the number of Tokens available for teamAccount'Locked part\r\n             availTeam = teamAvailable(msg.sender);\r\n             //the number of Tokens available for teamAccount\r\n             totalAvail = availTeam.add(availReverse);\r\n        }\r\n        require(_value <= totalAvail);\r\n        bool ret = super.transfer(_to,_value);\r\n        if(ret == true && issueDate>0) {\r\n            //If over the teamAccount's released part\r\n            if(_value > availTeam){\r\n                teamUsed[msg.sender] = teamUsed[msg.sender].add(availTeam);\r\n                teamReverse[msg.sender] = teamReverse[msg.sender].sub(availTeam);\r\n            }\r\n            //If in the teamAccount's released part\r\n            else{\r\n                teamUsed[msg.sender] = teamUsed[msg.sender].add(_value);\r\n                teamReverse[msg.sender] = teamReverse[msg.sender].sub(_value);\r\n            }\r\n        }\r\n        if(teamUsed[msg.sender] >= teamLocked[msg.sender]){\r\n            delete teamLockTime[msg.sender];\r\n            delete teamReverse[msg.sender];\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev Team account authorization transaction\r\n     * @param _from The give token address\r\n     * @param _to  The accept token address\r\n     * @param _value Number of transactions\r\n     */\r\n    function teamLockTransferFrom(address _from,address _to, uint256 _value) internal returns (bool) {\r\n       //The remaining part\r\n       uint256 availReverse = balances[_from].sub((teamLocked[_from].sub(teamUsed[_from]))+(fundLocked[_from].sub(fundUsed[_from])));\r\n       uint256 totalAvail=0;\r\n       uint256 availTeam =0;\r\n        if(issueDate==0)\r\n        {\r\n             totalAvail = availReverse;\r\n        }\r\n        else{\r\n            //the number of Tokens available for teamAccount'Locked part\r\n             availTeam = teamAvailable(_from);\r\n              //the number of Tokens available for teamAccount\r\n             totalAvail = availTeam.add(availReverse);\r\n        }\r\n       require(_value <= totalAvail);\r\n        bool ret = super.transferFrom(_from,_to,_value);\r\n        if(ret == true && issueDate>0) {\r\n            //If over the teamAccount's released part\r\n            if(_value > availTeam){\r\n                teamUsed[_from] = teamUsed[_from].add(availTeam);\r\n                teamReverse[_from] = teamReverse[_from].sub(availTeam);\r\n           }\r\n            //If in the teamAccount's released part\r\n            else{\r\n                teamUsed[_from] = teamUsed[_from].add(_value);\r\n                teamReverse[_from] = teamReverse[_from].sub(_value);\r\n            }\r\n        }\r\n        if(teamUsed[_from] >= teamLocked[_from]){\r\n            delete teamLockTime[_from];\r\n            delete teamReverse[_from];\r\n        }\r\n        return ret;\r\n    }\r\n\r\n    /**\r\n     * @dev Privately Offered Fund Transfer Token\r\n     * @param _to The accept token address\r\n     * @param _value Number of transactions\r\n     */\r\n    function fundLockTransfer(address _to, uint256 _value) internal returns (bool) {\r\n      //The remaining part\r\n       uint256 availReverse = balances[msg.sender].sub((teamLocked[msg.sender].sub(teamUsed[msg.sender]))+(fundLocked[msg.sender].sub(fundUsed[msg.sender])));\r\n       uint256 totalAvail=0;\r\n       uint256 availFund = 0;\r\n        if(issueDate==0)\r\n        {\r\n             totalAvail = availReverse;\r\n        }\r\n        else{\r\n             require(now>issueDate);\r\n            //the number of Tokens available for SLGCFundAccount'Locked part\r\n             availFund = fundAvailable(msg.sender);\r\n             //the number of Tokens available for SLGCFundAccount\r\n             totalAvail = availFund.add(availReverse);\r\n        }\r\n        require(_value <= totalAvail);\r\n        bool ret = super.transfer(_to,_value);\r\n        if(ret == true && issueDate>0) {\r\n            //If over the SLGCFundAccount's released part\r\n            if(_value > availFund){\r\n                fundUsed[msg.sender] = fundUsed[msg.sender].add(availFund);\r\n                fundReverse[msg.sender] = fundReverse[msg.sender].sub(availFund);\r\n             }\r\n            //If in the SLGCFundAccount's released part\r\n            else{\r\n                fundUsed[msg.sender] =  fundUsed[msg.sender].add(_value);\r\n                fundReverse[msg.sender] = fundReverse[msg.sender].sub(_value);\r\n            }\r\n        }\r\n        if(fundUsed[msg.sender] >= fundLocked[msg.sender]){\r\n            delete fundLockTime[msg.sender];\r\n            delete fundReverse[msg.sender];\r\n        }\r\n        return ret;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Privately Offered Fund Transfer Token\r\n     * @param _from The give token address\r\n     * @param _to The accept token address\r\n     * @param _value Number of transactions\r\n     */\r\n    function fundLockTransferFrom(address _from,address _to, uint256 _value) internal returns (bool) {\r\n        //The remaining part\r\n        uint256 availReverse =  balances[_from].sub((teamLocked[_from].sub(teamUsed[_from]))+(fundLocked[_from].sub(fundUsed[_from])));\r\n        uint256 totalAvail=0;\r\n        uint256 availFund = 0;\r\n        if(issueDate==0)\r\n        {\r\n             totalAvail = availReverse;\r\n        }\r\n        else{\r\n             require(now>issueDate);\r\n             //the number of Tokens available for SLGCFundAccount'Locked part\r\n             availFund = fundAvailable(_from);\r\n              //the number of Tokens available for SLGCFundAccount\r\n             totalAvail = availFund.add(availReverse);\r\n        }\r\n      \r\n        require(_value <= totalAvail);\r\n        bool ret = super.transferFrom(_from,_to,_value);\r\n        if(ret == true && issueDate>0) {\r\n           //If over the SLGCFundAccount's released part\r\n            if(_value > availFund){\r\n                fundUsed[_from] = fundUsed[_from].add(availFund);\r\n                fundReverse[_from] = fundReverse[_from].sub(availFund);\r\n            }\r\n            //If in the SLGCFundAccount's released part\r\n            else{\r\n                fundUsed[_from] =  fundUsed[_from].add(_value);\r\n                fundReverse[_from] = fundReverse[_from].sub(_value);\r\n            }\r\n        }\r\n        if(fundUsed[_from] >= fundLocked[_from]){\r\n            delete fundLockTime[_from];\r\n        }\r\n        return ret;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Simulation Game Coin\r\n * @dev SLGC Contract\r\n **/\r\ncontract SLGCToken is Lock {\r\n    bytes32 public name = \"Simulation Game Coin\";\r\n    bytes32 public symbol = \"SLGC\";\r\n    uint8 public decimals = 8;\r\n    // Proportional accuracy\r\n    uint256 public precentDecimal = 2;\r\n\r\n    // firstFundPrecent\r\n    uint256 public firstFundPrecent = 500; \r\n    // secondFundPrecent\r\n    uint256 public secondFundPrecent = 1000; \r\n    //stableFundPrecent\r\n    uint256 public stableFundPrecent = 300; \r\n    //ecologyFundPrecent\r\n    uint256 public ecologyFundPrecent = 1100; \r\n    //devTeamPrecent\r\n    uint256 public devTeamPrecent = 600;\r\n    //SLGCFoundationPrecent\r\n    uint256 public SLGCFoundationPrecent = 6500;\r\n    //firstFundBalance\r\n    uint256 public firstFundBalance;\r\n    //secondFundBalance\r\n    uint256 public secondFundBalance;\r\n    //stableFundBalance\r\n    uint256 public stableFundBalance;\r\n    //ecologyFundBalance\r\n    uint256 public ecologyFundBalance;\r\n    //devTeamBalance\r\n    uint256 public devTeamBalance;\r\n    //SLGCFoundationBalance\r\n    uint256 public SLGCFoundationBalance;\r\n    //SLGCFundAccount\r\n    address public SLGCFundAccount;\r\n    \r\n\r\n    /**\r\n     *  @dev Contract constructor\r\n     *  @param _initialSupply token's initialSupply\r\n     *  @param _teamAccount  teamAccount\r\n     *  @param _firstFundAccount firstFundAccount\r\n     *  @param _secondFundAccount secondFundAccount\r\n     *  @param _stableFundAccount stableFundAccount\r\n     *  @param _ecologyFundAccount ecologyFundAccount\r\n     *  @param _SLGCFoundationAccount SLGCFoundationAccount\r\n    */\r\n    constructor(uint256 _initialSupply,address _teamAccount,address _firstFundAccount,address _secondFundAccount,address _stableFundAccount,address _ecologyFundAccount,address _SLGCFoundationAccount) public {\r\n        //Define a SLGCFundAccount\r\n        SLGCFundAccount = _SLGCFoundationAccount;\r\n\r\n        //Calculated according to accuracy, if the precision is 18, it is _initialSupply x 10 to the power of 18\r\n        totalSupply_ = _initialSupply * 10 ** uint256(decimals);\r\n\r\n        //Calculate the total value of firstFund\r\n        firstFundBalance =  totalSupply_.mul(firstFundPrecent).div(100* 10 ** precentDecimal);\r\n        //Calculate the total value of secondFund\r\n        secondFundBalance =  totalSupply_.mul(secondFundPrecent).div(100* 10 ** precentDecimal);\r\n        //Calculate the total value of stableFund\r\n        stableFundBalance =  totalSupply_.mul(stableFundPrecent).div(100* 10 ** precentDecimal);\r\n        //Calculate the total value of ecologyFund\r\n        ecologyFundBalance =  totalSupply_.mul(ecologyFundPrecent).div(100* 10 ** precentDecimal);\r\n        //Calculate the total value of devTeamBalance\r\n        devTeamBalance =  totalSupply_.mul(devTeamPrecent).div(100* 10 ** precentDecimal);\r\n        //Calculate the total value of SLGCFoundationBalance\r\n        SLGCFoundationBalance = totalSupply_.mul(SLGCFoundationPrecent).div(100* 10 ** precentDecimal) ;\r\n        //Initially put the SLGCFoundationBalance into the SLGCFoundationAccount\r\n        balances[_SLGCFoundationAccount] = SLGCFoundationBalance; \r\n\r\n        //Initially put the devTeamBalance into the teamAccount\r\n        balances[_teamAccount] = devTeamBalance;\r\n\r\n        //Initially put the firstFundBalance into the firstFundAccount\r\n        balances[_firstFundAccount]=firstFundBalance;\r\n\r\n        //Initially put the secondFundBalance into the secondFundAccount\r\n        balances[_secondFundAccount]=secondFundBalance;\r\n\r\n        //Initially put the stableFundBalance into the stableFundAccount\r\n        balances[_stableFundAccount]=stableFundBalance;\r\n\r\n        //Initially put the ecologyFundBalance into the ecologyFundAccount\r\n        balances[_ecologyFundAccount]=ecologyFundBalance;\r\n\r\n        //Initially lock the team account\r\n        teamLock(_teamAccount,devTeamBalance);\r\n        \r\n    }\r\n\r\n    /**\r\n      * @dev destroy the msg sender's token onlyOwner\r\n      * @param _value the number of the destroy token\r\n     */\r\n    function burn(uint256 _value) public onlyOwner returns (bool) {\r\n        balances[msg.sender] = balances[msg.sender].sub(_value);\r\n        balances[address(0)] = balances[address(0)].add(_value);\r\n        emit Transfer(msg.sender, address(0), _value);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token\r\n     * @param _to the accept token address\r\n     * @param _value the number of transfer token\r\n     */\r\n    function transfer(address _to, uint256 _value) public returns (bool) {\r\n        if(issueDate==0)\r\n        {\r\n            //the SLGCFundAccounts is not allowed to transfer before issued\r\n            require(msg.sender != SLGCFundAccount);\r\n        }\r\n\r\n        if(teamLockTime[msg.sender] > 0){\r\n            return super.teamLockTransfer(_to,_value);\r\n        }else if(fundLockTime[msg.sender] > 0){\r\n            return super.fundLockTransfer(_to,_value);\r\n        }else {\r\n            return super.transfer(_to, _value);    \r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Transfer token\r\n     * @param _from the give token address\r\n     * @param _to the accept token address\r\n     * @param _value the number of transfer token\r\n     */\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\r\n          if(issueDate==0)\r\n        {\r\n            //the SLGCFundAccounts is not allowed to transfer before issued\r\n            require(_from != SLGCFundAccount);\r\n        }\r\n      \r\n        if(teamLockTime[_from] > 0){\r\n            return super.teamLockTransferFrom(_from,_to,_value);\r\n        }else if(fundLockTime[_from] > 0 ){  \r\n            return super.fundLockTransferFrom(_from,_to,_value);\r\n        }else{\r\n            return super.transferFrom(_from, _to, _value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     *  @dev Privately offered Fund \r\n     *  @param _to the accept token address\r\n     *  @param _value the number of transfer token\r\n     */\r\n    function mintFund(address _to, uint256 _value) public  returns (bool){\r\n        require(_value >0);\r\n        require(msg.sender==SLGCFundAccount);\r\n        require(SLGCFoundationBalance >0);\r\n        if(_value <= SLGCFoundationBalance){\r\n            super.transfer(_to,_value);\r\n            fundLock(_to,_value);\r\n            SLGCFoundationBalance = SLGCFoundationBalance.sub(_value);\r\n        }\r\n    }\r\n\r\n    /**\r\n    * @dev Issue the token \r\n    */\r\n    function issue() public onlyOwner  returns (uint){\r\n        //Only one time \r\n        require(issueDate==0);\r\n        issueDate = now;\r\n        return now;\r\n    }\r\n     \r\n     /**avoid mis-transfer*/\r\n     function() external payable{\r\n         revert();\r\n     }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"precentDecimal\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTeamPrecent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devTeamBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fundReverse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fundUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"burn\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fundLockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_subtractedValue\",\"type\":\"uint256\"}],\"name\":\"decreaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ecologyFundPrecent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstFundBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondFundBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stableFundBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issueDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ecologyFundBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"secondFundPrecent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"firstFundPrecent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"stableFundPrecent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamUsed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SLGCFoundationPrecent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SLGCFoundationBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"issue\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"fundLocked\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_addedValue\",\"type\":\"uint256\"}],\"name\":\"increaseApproval\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintFund\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SLGCFundAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamLockTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"teamReverse\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_initialSupply\",\"type\":\"uint256\"},{\"name\":\"_teamAccount\",\"type\":\"address\"},{\"name\":\"_firstFundAccount\",\"type\":\"address\"},{\"name\":\"_secondFundAccount\",\"type\":\"address\"},{\"name\":\"_stableFundAccount\",\"type\":\"address\"},{\"name\":\"_ecologyFundAccount\",\"type\":\"address\"},{\"name\":\"_SLGCFoundationAccount\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Pause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpause\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"}]","ContractName":"SLGCToken","CompilerVersion":"v0.5.0+commit.1d4f565a","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000002540be400000000000000000000000000319ef2456beed2aa9809e9d2684ecdc19016410b000000000000000000000000bfd5c5f2b75c1c57e523b1758fd3f7cf0cda281300000000000000000000000070036d073a9c0b6acbe7225cad68a7bf1d2f32b400000000000000000000000080ccd97608b7f0860d35b71d14727425319a8dc20000000000000000000000000cbbe74f8803f2512458e2087ce6c0aaa7c3ac8c00000000000000000000000022e1995901116a645ffd1d10c5411e967da2ea98","Library":"","SwarmSource":"bzzr://a2f3d6a2711cd581a2f0f145a9ffca3c2f8477ed2b4351196a5ad905c018cf77"}]}