{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n/****\r\nThis is an interesting project. \r\n&#x5C0F;&#x8D4C;&#x4F24;&#x795E;&#xFF0C;&#x5927;&#x8D4C;&#x4F24;&#x8D22;\r\n****/\r\n\r\n\r\nlibrary SafeMath {\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a * b;\r\n    assert(a == 0 || c / a == b);\r\n    return c;\r\n  }\r\n\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a / b;\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\ncontract ETHDice{\r\n    \r\n    using SafeMath for *;\r\n    \r\n    constructor() public {\r\n        nonce = 3000e8;\r\n        owner = msg.sender;\r\n        RandNonce = uint(keccak256(abi.encodePacked(now)));\r\n        RandNonce = RandNonce**10;\r\n    }\r\n    \r\n    address owner = msg.sender;\r\n    bool internal EndPlay = false;\r\n    uint256 StartEth = 0.002 ether;\r\n    uint256 nonce;\r\n    uint256 private RandNonce;\r\n    \r\n    modifier canPlay() {\r\n        require(!EndPlay);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    function finishDistribution() onlyOwner canPlay public returns (bool) {\r\n        EndPlay = true;\r\n        return true;\r\n    }\r\n    function startDistribution() onlyOwner  public returns (bool) {\r\n        EndPlay = false;\r\n        return true;\r\n    }\r\n    \r\n    function () external payable {\r\n            play();\r\n    }  \r\n    \r\n    function isContract(address _addr) private view returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length > 0);\r\n    }\r\n     \r\n    function play() payable canPlay public {\r\n        if (nonce < 5e8) {\r\n            nonce = 3000e8;\r\n        }\r\n        uint256 etherValue=msg.value;\r\n        address sender = msg.sender;\r\n        require(sender == tx.origin && !isContract(sender));\r\n        address myAddress = this;\r\n        uint256 etherBalance = myAddress.balance;\r\n        if(sender == owner){\r\n            \r\n        }else{\r\n            if(etherValue>StartEth){\r\n                RandNonce = RandNonce.add(nonce);\r\n                uint256 random1 = uint(keccak256(abi.encodePacked(blockhash(RandNonce % 100),RandNonce,sender))) % 10;\r\n                RandNonce = RandNonce.add(random1);\r\n                if(random1 < 5) {\r\n                    etherValue = etherValue.add(etherValue);\r\n                    nonce = nonce.div(100000).mul(99999);\r\n                    if(etherValue <= etherBalance.mul(5).div(100)){\r\n                        msg.sender.transfer(etherValue);\r\n                    }else{\r\n                        etherValue = etherValue.div(2);\r\n                        msg.sender.transfer(etherBalance.mul(5).div(100).add(etherValue));\r\n                    }\r\n                }\r\n\r\n            }else{\r\n                msg.sender.transfer(etherValue);\r\n            }\r\n        }\r\n    }\r\n    \r\n    function withdraw() onlyOwner public {\r\n        address myAddress = this;\r\n        uint256 etherBalance = myAddress.balance;\r\n        owner.transfer(etherBalance);\r\n    }\r\n    \r\n    function destroy() onlyOwner public{\r\n        selfdestruct(owner);\r\n    }\r\n    \r\n}","ABI":"[{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"play\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"ETHDice","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://57b5eb9daa79a7408af291fdd36cf73b71e6ba3b325039e58f338563535ce94b"}]}