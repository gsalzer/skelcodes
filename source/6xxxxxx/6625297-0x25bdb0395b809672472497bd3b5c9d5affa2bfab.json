{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: solidity-shared-lib/contracts/ERC20Interface.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n/// @title Defines an interface for EIP20 token smart contract\r\ncontract ERC20Interface {\r\n    \r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed from, address indexed spender, uint256 value);\r\n\r\n    string public symbol;\r\n\r\n    function decimals() public view returns (uint8);\r\n    function totalSupply() public view returns (uint256 supply);\r\n\r\n    function balanceOf(address _owner) public view returns (uint256 balance);\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining);\r\n}\r\n\r\n// File: solidity-shared-lib/contracts/Owned.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.23;\r\n\r\n\r\n\r\n/// @title Owned contract with safe ownership pass.\r\n///\r\n/// Note: all the non constant functions return false instead of throwing in case if state change\r\n/// didn't happen yet.\r\ncontract Owned {\r\n\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    address public contractOwner;\r\n    address public pendingContractOwner;\r\n\r\n    modifier onlyContractOwner {\r\n        if (msg.sender == contractOwner) {\r\n            _;\r\n        }\r\n    }\r\n\r\n    constructor()\r\n    public\r\n    {\r\n        contractOwner = msg.sender;\r\n    }\r\n\r\n    /// @notice Prepares ownership pass.\r\n    /// Can only be called by current owner.\r\n    /// @param _to address of the next owner.\r\n    /// @return success.\r\n    function changeContractOwnership(address _to)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (_to == 0x0) {\r\n            return false;\r\n        }\r\n        pendingContractOwner = _to;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Finalize ownership pass.\r\n    /// Can only be called by pending owner.\r\n    /// @return success.\r\n    function claimContractOwnership()\r\n    public\r\n    returns (bool)\r\n    {\r\n        if (msg.sender != pendingContractOwner) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, pendingContractOwner);\r\n        contractOwner = pendingContractOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Allows the current owner to transfer control of the contract to a newOwner.\r\n    /// @param newOwner The address to transfer ownership to.\r\n    function transferOwnership(address newOwner)\r\n    public\r\n    onlyContractOwner\r\n    returns (bool)\r\n    {\r\n        if (newOwner == 0x0) {\r\n            return false;\r\n        }\r\n\r\n        emit OwnershipTransferred(contractOwner, newOwner);\r\n        contractOwner = newOwner;\r\n        delete pendingContractOwner;\r\n        return true;\r\n    }\r\n\r\n    /// @notice Withdraw given tokens from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawTokens(address[] tokens)\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        address _contractOwner = contractOwner;\r\n        for (uint i = 0; i < tokens.length; i++) {\r\n            ERC20Interface token = ERC20Interface(tokens[i]);\r\n            uint balance = token.balanceOf(this);\r\n            if (balance > 0) {\r\n                token.transfer(_contractOwner, balance);\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Withdraw ether from contract to owner.\r\n    /// This method is only allowed for contact owner.\r\n    function withdrawEther()\r\n    public\r\n    onlyContractOwner\r\n    {\r\n        uint balance = address(this).balance;\r\n        if (balance > 0)  {\r\n            contractOwner.transfer(balance);\r\n        }\r\n    }\r\n\r\n    /// @notice Transfers ether to another address.\r\n    /// Allowed only for contract owners.\r\n    /// @param _to recepient address\r\n    /// @param _value wei to transfer; must be less or equal to total balance on the contract\r\n    function transferEther(address _to, uint256 _value) \r\n    public \r\n    onlyContractOwner \r\n    {\r\n        require(_to != 0x0, \"INVALID_ETHER_RECEPIENT_ADDRESS\");\r\n        if (_value > address(this).balance) {\r\n            revert(\"INVALID_VALUE_TO_TRANSFER_ETHER\");\r\n        }\r\n        \r\n        _to.transfer(_value);\r\n    }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/Roles.sol\r\n\r\n/**\r\n * @title Roles\r\n * @dev Library for managing addresses assigned to a Role.\r\n */\r\nlibrary Roles {\r\n  struct Role {\r\n    mapping (address => bool) bearer;\r\n  }\r\n\r\n  /**\r\n   * @dev give an account access to this role\r\n   */\r\n  function add(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    role.bearer[account] = true;\r\n  }\r\n\r\n  /**\r\n   * @dev remove an account's access to this role\r\n   */\r\n  function remove(Role storage role, address account) internal {\r\n    require(account != address(0));\r\n    role.bearer[account] = false;\r\n  }\r\n\r\n  /**\r\n   * @dev check if an account has this role\r\n   * @return bool\r\n   */\r\n  function has(Role storage role, address account)\r\n    internal\r\n    view\r\n    returns (bool)\r\n  {\r\n    require(account != address(0));\r\n    return role.bearer[account];\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/SignerRole.sol\r\n\r\ncontract SignerRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event SignerAdded(address indexed account);\r\n  event SignerRemoved(address indexed account);\r\n\r\n  Roles.Role private signers;\r\n\r\n  constructor() public {\r\n    _addSigner(msg.sender);\r\n  }\r\n\r\n  modifier onlySigner() {\r\n    require(isSigner(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isSigner(address account) public view returns (bool) {\r\n    return signers.has(account);\r\n  }\r\n\r\n  function addSigner(address account) public onlySigner {\r\n    _addSigner(account);\r\n  }\r\n\r\n  function renounceSigner() public {\r\n    _removeSigner(msg.sender);\r\n  }\r\n\r\n  function _addSigner(address account) internal {\r\n    signers.add(account);\r\n    emit SignerAdded(account);\r\n  }\r\n\r\n  function _removeSigner(address account) internal {\r\n    signers.remove(account);\r\n    emit SignerRemoved(account);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/access/roles/PauserRole.sol\r\n\r\ncontract PauserRole {\r\n  using Roles for Roles.Role;\r\n\r\n  event PauserAdded(address indexed account);\r\n  event PauserRemoved(address indexed account);\r\n\r\n  Roles.Role private pausers;\r\n\r\n  constructor() public {\r\n    _addPauser(msg.sender);\r\n  }\r\n\r\n  modifier onlyPauser() {\r\n    require(isPauser(msg.sender));\r\n    _;\r\n  }\r\n\r\n  function isPauser(address account) public view returns (bool) {\r\n    return pausers.has(account);\r\n  }\r\n\r\n  function addPauser(address account) public onlyPauser {\r\n    _addPauser(account);\r\n  }\r\n\r\n  function renouncePauser() public {\r\n    _removePauser(msg.sender);\r\n  }\r\n\r\n  function _addPauser(address account) internal {\r\n    pausers.add(account);\r\n    emit PauserAdded(account);\r\n  }\r\n\r\n  function _removePauser(address account) internal {\r\n    pausers.remove(account);\r\n    emit PauserRemoved(account);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is PauserRole {\r\n  event Paused();\r\n  event Unpaused();\r\n\r\n  bool private _paused = false;\r\n\r\n\r\n  /**\r\n   * @return true if the contract is paused, false otherwise.\r\n   */\r\n  function paused() public view returns(bool) {\r\n    return _paused;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(_paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() public onlyPauser whenNotPaused {\r\n    _paused = true;\r\n    emit Paused();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() public onlyPauser whenPaused {\r\n    _paused = false;\r\n    emit Unpaused();\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/IERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ninterface IERC20 {\r\n  function totalSupply() external view returns (uint256);\r\n\r\n  function balanceOf(address who) external view returns (uint256);\r\n\r\n  function allowance(address owner, address spender)\r\n    external view returns (uint256);\r\n\r\n  function transfer(address to, uint256 value) external returns (bool);\r\n\r\n  function approve(address spender, uint256 value)\r\n    external returns (bool);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    external returns (bool);\r\n\r\n  event Transfer(\r\n    address indexed from,\r\n    address indexed to,\r\n    uint256 value\r\n  );\r\n\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: @laborx/airdrop/contracts/ERC223ReceivingContract.sol\r\n\r\n/**\r\n * @title Contract that will work with ERC223 tokens.\r\n */\r\n\r\ninterface ERC223ReceivingContract {\r\n/**\r\n * @dev Standard ERC223 function that will handle incoming token transfers.\r\n *\r\n * @param _from  Token sender address.\r\n * @param _value Amount of tokens.\r\n * @param _data  Transaction metadata.\r\n */\r\n    function tokenFallback(address _from, uint _value, bytes _data) external;\r\n}\r\n\r\n// File: @laborx/airdrop/contracts/Airdrop.sol\r\n\r\n/// @title Airdrop contract based on Merkle tree and merkle proof of addresses and amount of tokens to withdraw.\r\n///     Contract requires that merkle tree was built on leafs keccak256(position, recepient address, amount)\r\n///     Supports ERC223 token standard that allows to receive/not receive tokens that allowed (supported) by smart\r\n///     contracts, so no dummy or mistyped token transfers.\r\ncontract Airdrop is Owned, SignerRole, Pausable, ERC223ReceivingContract {\r\n\r\n    uint constant OK = 1;\r\n\r\n    /// @dev Log when airdrop\r\n    event LogAirdropClaimed(address indexed initiator, bytes32 operationId, uint amount);\r\n    /// @dev Log when merkle root will be updated\r\n    event LogMerkleRootUpdated(bytes32 to, address by);\r\n\r\n    /// @dev Version of the contract. Allows to distinguish between releases.\r\n    bytes32 public version = \"0.2.0\";\r\n    /// @dev Token to airdrop to.\r\n    IERC20 public token;\r\n    /// @dev Merkle root of the airdrop\r\n    bytes32 public merkleRoot;\r\n    /// @dev (operation id => completed)\r\n    mapping(bytes32 => bool) public completedAirdrops;\r\n\r\n    /// @notice Creates airdrop contract. Fails if token `_token` is 0x0.\r\n    /// @param _token token address to airdrop; supports ERC223 token contracts\r\n    constructor(address _token)\r\n    public\r\n    {\r\n        require(_token != 0x0, \"AIRDROP_INVALID_TOKEN_ADDRESS\");\r\n        token = IERC20(_token);\r\n    }\r\n\r\n    /// @notice Updates merkle root after changes in airdrop records.\r\n    ///     Emits 'LogMerkleRootUpdated' event.\r\n    ///     Only signer allowed to call.\r\n    /// @param _updatedMerkleRoot new merkle root hash calculated on updated airdrop records.\r\n    ///     Could be set empty if you need to stop withraws.\r\n    function setMerkleRoot(bytes32 _updatedMerkleRoot)\r\n    external\r\n    onlySigner\r\n    returns (uint)\r\n    {\r\n        merkleRoot = _updatedMerkleRoot;\r\n\r\n        emit LogMerkleRootUpdated(_updatedMerkleRoot, msg.sender);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Claim tokens held by airdrop contract based on proof provided\r\n    ///     by sender `msg.sender` based on position `_position` in airdrop list.\r\n    ///     Emits 'LogAirdropClaimed' event when withdraw claim is successful.\r\n    /// @param _proof merkle proof list of hashes\r\n    /// @param _operationId unique withrawal operation ID\r\n    /// @param _position position of airdrop record that is included in proof calculations\r\n    /// @param _amount amount of tokens to withdraw\r\n    /// @return result code of an operation. OK (1) if all went good.\r\n    function claimTokensByMerkleProof(\r\n        bytes32[] _proof,\r\n        bytes32 _operationId,\r\n        uint _position,\r\n        uint _amount\r\n    )\r\n    external\r\n    whenNotPaused\r\n    returns (uint)\r\n    {\r\n        bytes32 leaf = _calculateMerkleLeaf(_operationId, _position, msg.sender, _amount);\r\n\r\n        require(completedAirdrops[_operationId] == false, \"AIRDROP_ALREADY_CLAIMED\");\r\n        require(checkMerkleProof(merkleRoot, _proof, _position, leaf), \"AIRDROP_INVALID_PROOF\");\r\n        require(token.transfer(msg.sender, _amount), \"AIRDROP_TRANSFER_FAILURE\");\r\n\r\n        // Mark operation as completed\r\n        completedAirdrops[_operationId] = true;\r\n\r\n        emit LogAirdropClaimed(msg.sender, _operationId, _amount);\r\n        return OK;\r\n    }\r\n\r\n    /// @notice Checks merkle proof based on the latest merkle root set up.\r\n    /// @param _merkleRoot merkle root hash to compare result with\r\n    /// @param _proof merkle proof list of hashes\r\n    /// @param _position position of airdrop record that is included in proof calculations\r\n    /// @param _leaf leaf hash that should be tested for containment in merkle tree\r\n    /// @return true if leaf `_leaf` is included in merkle tree, false otherwise\r\n    function checkMerkleProof(\r\n        bytes32 _merkleRoot,\r\n        bytes32[] _proof,\r\n        uint _position,\r\n        bytes32 _leaf\r\n    )\r\n    public\r\n    pure\r\n    returns (bool)\r\n    {\r\n        bytes32 _computedHash = _leaf;\r\n        uint _checkedPosition = _position;\r\n\r\n        for (uint i = 0; i < _proof.length; i += 1) {\r\n            bytes32 _proofElement = _proof[i];\r\n\r\n            if (_checkedPosition % 2 == 0) {\r\n                _computedHash = keccak256(abi.encodePacked(_computedHash, _proofElement));\r\n            } else {\r\n                _computedHash = keccak256(abi.encodePacked(_proofElement, _computedHash));\r\n            }\r\n\r\n            _checkedPosition /= 2;\r\n        }\r\n\r\n        return _computedHash == _merkleRoot;\r\n    }\r\n\r\n    /*\r\n        ERC223 token\r\n\r\n        https://github.com/ethereum/EIPs/issues/223\r\n    */\r\n\r\n    /// @notice Guards smart contract from accepting non-allowed tokens (if they support ERC223 interface)\r\n    function tokenFallback(address /*_from*/, uint /*_value*/, bytes /*_data*/)\r\n    external\r\n    whenNotPaused\r\n    {\r\n        require(msg.sender == address(token), \"AIRDROP_TOKEN_NOT_SUPPORTED\");\r\n    }\r\n\r\n    /* PRIVATE */\r\n\r\n    /// @notice Gets merkle leaf based on index `_index`, destination address `_address` and\r\n    ///     amount of tokens to transfer `_amount`\r\n    function _calculateMerkleLeaf(bytes32 _operationId, uint _index, address _address, uint _amount)\r\n    private\r\n    pure\r\n    returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(_operationId, _index, _address, _amount));\r\n    }\r\n}\r\n\r\n// File: contracts/Import.sol\r\n\r\n/**\r\n* Copyright 2017–2018, LaborX PTY\r\n* Licensed under the AGPL Version 3 license.\r\n*/\r\n\r\npragma solidity ^0.4.24;","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"merkleRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claimContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isPauser\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"version\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"changeContractOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingContractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tokens\",\"type\":\"address[]\"}],\"name\":\"withdrawTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renouncePauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_updatedMerkleRoot\",\"type\":\"bytes32\"}],\"name\":\"setMerkleRoot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"isSigner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addPauser\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"completedAirdrops\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_merkleRoot\",\"type\":\"bytes32\"},{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_position\",\"type\":\"uint256\"},{\"name\":\"_leaf\",\"type\":\"bytes32\"}],\"name\":\"checkMerkleProof\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"tokenFallback\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contractOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_proof\",\"type\":\"bytes32[]\"},{\"name\":\"_operationId\",\"type\":\"bytes32\"},{\"name\":\"_position\",\"type\":\"uint256\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"claimTokensByMerkleProof\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"account\",\"type\":\"address\"}],\"name\":\"addSigner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"initiator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"operationId\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LogAirdropClaimed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"to\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"}],\"name\":\"LogMerkleRootUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Paused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Unpaused\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"PauserRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SignerAdded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"account\",\"type\":\"address\"}],\"name\":\"SignerRemoved\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"Airdrop","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000042f9d07c5d4f4c7c5827b9199ed79600bb9f1517","Library":"","SwarmSource":"bzzr://05490f0de5b9880af027913ba4859be9478bd6001c4a48dac026bf56312b7746"}]}