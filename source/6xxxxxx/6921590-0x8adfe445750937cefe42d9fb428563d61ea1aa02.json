{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\n\n\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n/**\n * @title Modifiable\n * @notice A contract with basic modifiers\n */\ncontract Modifiable {\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier notNullAddress(address _address) {\n        require(_address != address(0));\n        _;\n    }\n\n    modifier notThisAddress(address _address) {\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notNullOrThisAddress(address _address) {\n        require(_address != address(0));\n        require(_address != address(this));\n        _;\n    }\n\n    modifier notSameAddresses(address _address1, address _address2) {\n        if (_address1 != _address2)\n            _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n/**\n * @title SelfDestructible\n * @notice Contract that allows for self-destruction\n */\ncontract SelfDestructible {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    bool public selfDestructionDisabled;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SelfDestructionDisabledEvent(address wallet);\n    event TriggerSelfDestructionEvent(address wallet);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Get the address of the destructor role\n    function destructor()\n    public\n    view\n    returns (address);\n\n    /// @notice Disable self-destruction of this contract\n    /// @dev This operation can not be undone\n    function disableSelfDestruction()\n    public\n    {\n        // Require that sender is the assigned destructor\n        require(destructor() == msg.sender);\n\n        // Disable self-destruction\n        selfDestructionDisabled = true;\n\n        // Emit event\n        emit SelfDestructionDisabledEvent(msg.sender);\n    }\n\n    /// @notice Destroy this contract\n    function triggerSelfDestruction()\n    public\n    {\n        // Require that sender is the assigned destructor\n        require(destructor() == msg.sender);\n\n        // Require that self-destruction has not been disabled\n        require(!selfDestructionDisabled);\n\n        // Emit event\n        emit TriggerSelfDestructionEvent(msg.sender);\n\n        // Self-destruct and reward destructor\n        selfdestruct(msg.sender);\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n/**\n * @title Ownable\n * @notice A modifiable that has ownership roles\n */\ncontract Ownable is Modifiable, SelfDestructible {\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    address public deployer;\n    address public operator;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event SetDeployerEvent(address oldDeployer, address newDeployer);\n    event SetOperatorEvent(address oldOperator, address newOperator);\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address _deployer) internal notNullOrThisAddress(_deployer) {\n        deployer = _deployer;\n        operator = _deployer;\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Return the address that is able to initiate self-destruction\n    function destructor()\n    public\n    view\n    returns (address)\n    {\n        return deployer;\n    }\n\n    /// @notice Set the deployer of this contract\n    /// @param newDeployer The address of the new deployer\n    function setDeployer(address newDeployer)\n    public\n    onlyDeployer\n    notNullOrThisAddress(newDeployer)\n    {\n        if (newDeployer != deployer) {\n            // Set new deployer\n            address oldDeployer = deployer;\n            deployer = newDeployer;\n\n            // Emit event\n            emit SetDeployerEvent(oldDeployer, newDeployer);\n        }\n    }\n\n    /// @notice Set the operator of this contract\n    /// @param newOperator The address of the new operator\n    function setOperator(address newOperator)\n    public\n    onlyOperator\n    notNullOrThisAddress(newOperator)\n    {\n        if (newOperator != operator) {\n            // Set new operator\n            address oldOperator = operator;\n            operator = newOperator;\n\n            // Emit event\n            emit SetOperatorEvent(oldOperator, newOperator);\n        }\n    }\n\n    /// @notice Gauge whether message sender is deployer or not\n    /// @return true if msg.sender is deployer, else false\n    function isDeployer()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == deployer;\n    }\n\n    /// @notice Gauge whether message sender is operator or not\n    /// @return true if msg.sender is operator, else false\n    function isOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return msg.sender == operator;\n    }\n\n    /// @notice Gauge whether message sender is operator or deployer on the one hand, or none of these on these on\n    /// on the other hand\n    /// @return true if msg.sender is operator, else false\n    function isDeployerOrOperator()\n    internal\n    view\n    returns (bool)\n    {\n        return isDeployer() || isOperator();\n    }\n\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyDeployer() {\n        require(isDeployer());\n        _;\n    }\n\n    modifier notDeployer() {\n        require(!isDeployer());\n        _;\n    }\n\n    modifier onlyOperator() {\n        require(isOperator());\n        _;\n    }\n\n    modifier notOperator() {\n        require(!isOperator());\n        _;\n    }\n\n    modifier onlyDeployerOrOperator() {\n        require(isDeployerOrOperator());\n        _;\n    }\n\n    modifier notDeployerOrOperator() {\n        require(!isDeployerOrOperator());\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n/**\n * @title Servable\n * @notice An ownable that contains registered services and their actions\n */\ncontract Servable is Ownable {\n    //\n    // Types\n    // -----------------------------------------------------------------------------------------------------------------\n    struct ServiceInfo {\n        bool registered;\n        uint256 activationTimestamp;\n        mapping(bytes32 => bool) actionsEnabledMap;\n        bytes32[] actionsList;\n    }\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    mapping(address => ServiceInfo) internal registeredServicesMap;\n    uint256 public serviceActivationTimeout;\n\n    //\n    // Events\n    // -----------------------------------------------------------------------------------------------------------------\n    event ServiceActivationTimeoutEvent(uint256 timeoutInSeconds);\n    event RegisterServiceEvent(address service);\n    event RegisterServiceDeferredEvent(address service, uint256 timeout);\n    event DeregisterServiceEvent(address service);\n    event EnableServiceActionEvent(address service, string action);\n    event DisableServiceActionEvent(address service, string action);\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Set the service activation timeout\n    /// @param timeoutInSeconds The set timeout in unit of seconds\n    function setServiceActivationTimeout(uint256 timeoutInSeconds)\n    public\n    onlyDeployer\n    {\n        serviceActivationTimeout = timeoutInSeconds;\n\n        // Emit event\n        emit ServiceActivationTimeoutEvent(timeoutInSeconds);\n    }\n\n    /// @notice Register a service contract whose activation is immediate\n    /// @param service The address of the service contract to be registered\n    function registerService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, 0);\n\n        // Emit event\n        emit RegisterServiceEvent(service);\n    }\n\n    /// @notice Register a service contract whose activation is deferred by the service activation timeout\n    /// @param service The address of the service contract to be registered\n    function registerServiceDeferred(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        _registerService(service, serviceActivationTimeout);\n\n        // Emit event\n        emit RegisterServiceDeferredEvent(service, serviceActivationTimeout);\n    }\n\n    /// @notice Deregister a service contract\n    /// @param service The address of the service contract to be deregistered\n    function deregisterService(address service)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        registeredServicesMap[service].registered = false;\n\n        // Emit event\n        emit DeregisterServiceEvent(service);\n    }\n\n    /// @notice Enable a named action in an already registered service contract\n    /// @param service The address of the registered service contract\n    /// @param action The name of the action to be enabled\n    function enableServiceAction(address service, string action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        require(registeredServicesMap[service].registered);\n\n        bytes32 actionHash = hashString(action);\n\n        require(!registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = true;\n        registeredServicesMap[service].actionsList.push(actionHash);\n\n        // Emit event\n        emit EnableServiceActionEvent(service, action);\n    }\n\n    /// @notice Enable a named action in a service contract\n    /// @param service The address of the service contract\n    /// @param action The name of the action to be disabled\n    function disableServiceAction(address service, string action)\n    public\n    onlyDeployer\n    notNullOrThisAddress(service)\n    {\n        bytes32 actionHash = hashString(action);\n\n        require(registeredServicesMap[service].actionsEnabledMap[actionHash]);\n\n        registeredServicesMap[service].actionsEnabledMap[actionHash] = false;\n\n        // Emit event\n        emit DisableServiceActionEvent(service, action);\n    }\n\n    /// @notice Gauge whether a service contract is registered\n    /// @param service The address of the service contract\n    /// @return true if service is registered, else false\n    function isRegisteredService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return registeredServicesMap[service].registered;\n    }\n\n    /// @notice Gauge whether a service contract is registered and active\n    /// @param service The address of the service contract\n    /// @return true if service is registered and activate, else false\n    function isRegisteredActiveService(address service)\n    public\n    view\n    returns (bool)\n    {\n        return isRegisteredService(service) && block.timestamp >= registeredServicesMap[service].activationTimestamp;\n    }\n\n    /// @notice Gauge whether a service contract action is enabled which implies also registered and active\n    /// @param service The address of the service contract\n    /// @param action The name of action\n    function isEnabledServiceAction(address service, string action)\n    public\n    view\n    returns (bool)\n    {\n        bytes32 actionHash = hashString(action);\n        return isRegisteredActiveService(service) && registeredServicesMap[service].actionsEnabledMap[actionHash];\n    }\n\n    //\n    // Internal functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function hashString(string _string)\n    internal\n    pure\n    returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(_string));\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _registerService(address service, uint256 timeout)\n    private\n    {\n        if (!registeredServicesMap[service].registered) {\n            registeredServicesMap[service].registered = true;\n            registeredServicesMap[service].activationTimestamp = block.timestamp + timeout;\n        }\n    }\n\n    //\n    // Modifiers\n    // -----------------------------------------------------------------------------------------------------------------\n    modifier onlyActiveService() {\n        require(isRegisteredActiveService(msg.sender));\n        _;\n    }\n\n    modifier onlyEnabledServiceAction(string action) {\n        require(isEnabledServiceAction(msg.sender, action));\n        _;\n    }\n}\n\n/*\n * Hubii Nahmii\n *\n * Compliant with the Hubii Nahmii specification v0.12.\n *\n * Copyright (C) 2017-2018 Hubii AS\n */\n\n\n\n\n\n\n/**\n * @title Transaction tracker\n * @notice An ownable to track transactions of generic types\n */\ncontract TransactionTracker is Ownable, Servable {\n\n    //\n    // Structures\n    // -----------------------------------------------------------------------------------------------------------------\n    struct TransactionRecord {\n        int256 value;\n        uint256 blockNumber;\n        address currencyCt;\n        uint256 currencyId;\n    }\n\n    struct TransactionLog {\n        TransactionRecord[] records;\n        mapping(address => mapping(uint256 => uint256[])) recordIndicesByCurrency;\n    }\n\n    //\n    // Constants\n    // -----------------------------------------------------------------------------------------------------------------\n    string constant public DEPOSIT_TRANSACTION_TYPE = \"deposit\";\n    string constant public WITHDRAWAL_TRANSACTION_TYPE = \"withdrawal\";\n\n    //\n    // Variables\n    // -----------------------------------------------------------------------------------------------------------------\n    bytes32 public depositTransactionType;\n    bytes32 public withdrawalTransactionType;\n\n    mapping(address => mapping(bytes32 => TransactionLog)) private transactionLogByWalletType;\n\n    //\n    // Constructor\n    // -----------------------------------------------------------------------------------------------------------------\n    constructor(address deployer) Ownable(deployer)\n    public\n    {\n        depositTransactionType = keccak256(abi.encodePacked(DEPOSIT_TRANSACTION_TYPE));\n        withdrawalTransactionType = keccak256(abi.encodePacked(WITHDRAWAL_TRANSACTION_TYPE));\n    }\n\n    //\n    // Functions\n    // -----------------------------------------------------------------------------------------------------------------\n    /// @notice Add a transaction record of the given wallet, type, value and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The transaction type\n    /// @param value The concerned value (amount of fungible, id of non-fungible)\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    function add(address wallet, bytes32 _type, int256 value, address currencyCt,\n        uint256 currencyId)\n    public\n    onlyActiveService\n    {\n        transactionLogByWalletType[wallet][_type].records.length++;\n\n        uint256 index = transactionLogByWalletType[wallet][_type].records.length - 1;\n\n        transactionLogByWalletType[wallet][_type].records[index].value = value;\n        transactionLogByWalletType[wallet][_type].records[index].blockNumber = block.number;\n        transactionLogByWalletType[wallet][_type].records[index].currencyCt = currencyCt;\n        transactionLogByWalletType[wallet][_type].records[index].currencyId = currencyId;\n\n        transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId].push(index);\n    }\n\n    /// @notice Get the number of transaction records for the given wallet and type\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The transaction type\n    /// @return The count of transaction records\n    function count(address wallet, bytes32 _type)\n    public\n    view\n    returns (uint256)\n    {\n        return transactionLogByWalletType[wallet][_type].records.length;\n    }\n\n    /// @notice Get the transaction record for the given wallet and type by the given index\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The transaction type\n    /// @param index The concerned log index\n    /// @return The transaction record\n    function getByIndex(address wallet, bytes32 _type, uint256 index)\n    public\n    view\n    returns (int256 value, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        TransactionRecord storage entry = transactionLogByWalletType[wallet][_type].records[index];\n        value = entry.value;\n        blockNumber = entry.blockNumber;\n        currencyCt = entry.currencyCt;\n        currencyId = entry.currencyId;\n    }\n\n    /// @notice Get the transaction record for the given wallet and type by the given block number\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The transaction type\n    /// @param _blockNumber The concerned block number\n    /// @return The transaction record\n    function getByBlockNumber(address wallet, bytes32 _type, uint256 _blockNumber)\n    public\n    view\n    returns (int256 value, uint256 blockNumber, address currencyCt, uint256 currencyId)\n    {\n        return getByIndex(wallet, _type, _indexByBlockNumber(wallet, _type, _blockNumber));\n    }\n\n    /// @notice Get the number of transaction records for the given wallet, type and currency\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The transaction type\n    /// @param currencyCt The address of the concerned currency contract (address(0) == ETH)\n    /// @param currencyId The ID of the concerned currency (0 for ETH and ERC20)\n    /// @return The count of transaction records\n    function countByCurrency(address wallet, bytes32 _type, address currencyCt,\n        uint256 currencyId)\n    public\n    view\n    returns (uint256)\n    {\n        return transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId].length;\n    }\n\n    /// @notice Get the transaction record for the given wallet, type and currency by the given index\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The transaction type\n    /// @param index The concerned log index\n    /// @return The transaction record\n    function getByCurrencyIndex(address wallet, bytes32 _type, address currencyCt,\n        uint256 currencyId, uint256 index)\n    public\n    view\n    returns (int256 value, uint256 blockNumber)\n    {\n        uint256 entryIndex = transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId][index];\n\n        TransactionRecord storage entry = transactionLogByWalletType[wallet][_type].records[entryIndex];\n        value = entry.value;\n        blockNumber = entry.blockNumber;\n    }\n\n    /// @notice Get the transaction record for the given wallet, type and currency by the given block number\n    /// @param wallet The address of the concerned wallet\n    /// @param _type The transaction type\n    /// @param _blockNumber The concerned block number\n    /// @return The transaction record\n    function getByCurrencyBlockNumber(address wallet, bytes32 _type, address currencyCt,\n        uint256 currencyId, uint256 _blockNumber)\n    public\n    view\n    returns (int256 value, uint256 blockNumber)\n    {\n        return getByCurrencyIndex(\n            wallet, _type, currencyCt, currencyId,\n            _indexByCurrencyBlockNumber(\n                wallet, _type, currencyCt, currencyId, _blockNumber\n            )\n        );\n    }\n\n    //\n    // Private functions\n    // -----------------------------------------------------------------------------------------------------------------\n    function _indexByBlockNumber(address wallet, bytes32 _type, uint256 blockNumber)\n    private\n    view\n    returns (uint256)\n    {\n        require(0 < transactionLogByWalletType[wallet][_type].records.length);\n        for (uint256 i = transactionLogByWalletType[wallet][_type].records.length - 1; i >= 0; i--)\n            if (blockNumber >= transactionLogByWalletType[wallet][_type].records[i].blockNumber)\n                return i;\n        revert();\n    }\n\n    function _indexByCurrencyBlockNumber(address wallet, bytes32 _type, address currencyCt,\n        uint256 currencyId, uint256 blockNumber)\n    private\n    view\n    returns (uint256)\n    {\n        require(0 < transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId].length);\n        for (uint256 i = transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId].length - 1; i >= 0; i--) {\n            uint256 j = transactionLogByWalletType[wallet][_type].recordIndicesByCurrency[currencyCt][currencyId][i];\n            if (blockNumber >= transactionLogByWalletType[wallet][_type].records[j].blockNumber)\n                return j;\n        }\n        revert();\n    }\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"bytes32\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getByCurrencyBlockNumber\",\"outputs\":[{\"name\":\"value\",\"type\":\"int256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredActiveService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"triggerSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"enableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"isRegisteredService\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"selfDestructionDisabled\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositTransactionType\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"disableServiceAction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"serviceActivationTimeout\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"destructor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"bytes32\"},{\"name\":\"_blockNumber\",\"type\":\"uint256\"}],\"name\":\"getByBlockNumber\",\"outputs\":[{\"name\":\"value\",\"type\":\"int256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"deregisterService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"operator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"},{\"name\":\"action\",\"type\":\"string\"}],\"name\":\"isEnabledServiceAction\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEPOSIT_TRANSACTION_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"disableSelfDestruction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"setServiceActivationTimeout\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerServiceDeferred\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"setDeployer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"bytes32\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"countByCurrency\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"bytes32\"},{\"name\":\"value\",\"type\":\"int256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"name\":\"add\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"bytes32\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getByCurrencyIndex\",\"outputs\":[{\"name\":\"value\",\"type\":\"int256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"bytes32\"},{\"name\":\"index\",\"type\":\"uint256\"}],\"name\":\"getByIndex\",\"outputs\":[{\"name\":\"value\",\"type\":\"int256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"currencyCt\",\"type\":\"address\"},{\"name\":\"currencyId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"setOperator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"WITHDRAWAL_TRANSACTION_TYPE\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawalTransactionType\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"wallet\",\"type\":\"address\"},{\"name\":\"_type\",\"type\":\"bytes32\"}],\"name\":\"count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"deployer\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"service\",\"type\":\"address\"}],\"name\":\"registerService\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"deployer\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"timeoutInSeconds\",\"type\":\"uint256\"}],\"name\":\"ServiceActivationTimeoutEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"RegisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeout\",\"type\":\"uint256\"}],\"name\":\"RegisterServiceDeferredEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"}],\"name\":\"DeregisterServiceEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"EnableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"service\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"action\",\"type\":\"string\"}],\"name\":\"DisableServiceActionEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldDeployer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newDeployer\",\"type\":\"address\"}],\"name\":\"SetDeployerEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"oldOperator\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newOperator\",\"type\":\"address\"}],\"name\":\"SetOperatorEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"SelfDestructionDisabledEvent\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"wallet\",\"type\":\"address\"}],\"name\":\"TriggerSelfDestructionEvent\",\"type\":\"event\"}]","ContractName":"TransactionTracker","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"0","ConstructorArguments":"000000000000000000000000f05179bac3d1fbef58a2fcd7ad0f769840027cc6","Library":"","SwarmSource":"bzzr://ae54f0932d893b5fdd8fefbdbe09853515701d34b33260eb8385f33c795eb7a9"}]}