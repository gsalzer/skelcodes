{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n/***********************************************************\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n ***********************************************************/\r\n library SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\n/***********************************************************\r\n * F3GDatasets library\r\n ***********************************************************/\r\nlibrary F3GDatasets {\r\n    struct EventReturns {\r\n        uint256 compressedData;\r\n        uint256 compressedIDs;\r\n        address winnerAddr;         // winner address\r\n        bytes32 winnerName;         // winner name\r\n        uint256 amountWon;          // amount won\r\n        uint256 newPot;             // amount in new pot\r\n        uint256 R3Amount;          // amount distributed to nt\r\n        uint256 genAmount;          // amount distributed to gen\r\n        uint256 potAmount;          // amount added to pot\r\n    }\r\n    struct Player {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lrnd;   // last round played\r\n        uint256 laff;   // affiliate id used\r\n        uint256 aff1sum;\r\n        uint256 aff2sum;\r\n        uint256 aff3sum;\r\n        uint256 aff4sum;\r\n        uint256 aff5sum;\r\n    }\r\n    struct PlayerRounds {\r\n        uint256 eth;    // eth player has added to round (used for eth limiter)\r\n        uint256 keys;   // keys\r\n        uint256 mask;   // player mask \r\n        uint256 ico;    // ICO phase investment\r\n    }\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 team;   // tID of team in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 ico;    // total eth sent in during ICO phase\r\n        uint256 icoGen; // total eth for gen during ICO phase\r\n        uint256 icoAvg; // average key price for ICO phase\r\n        uint256 prevres;    // 上一轮或者奖池互换流入本轮的奖金\r\n    }\r\n    struct TeamFee {\r\n        uint256 gen;    // % of buy in thats paid to key holders of current round\r\n        uint256 dev;    // % of buy in thats paid to dev\r\n    }\r\n    struct PotSplit {\r\n        uint256 gen;    // % of pot thats paid to key holders of current round\r\n        uint256 dev;     // % of pot thats paid to dev\r\n    }\r\n}\r\n\r\n\r\n/***********************************************************\r\n * F3GKeysCalc library\r\n ***********************************************************/\r\nlibrary F3GKeysCalc {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth \r\n     * @param _curEth current amount of eth in contract \r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys \r\n     * @param _curKeys current amount of keys that exist \r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth) \r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n    \r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\" \r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys) \r\n        internal\r\n        pure\r\n        returns(uint256)  \r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\n/***********************************************************\r\n * F3G contract\r\n ***********************************************************/\r\ncontract F3G {\r\n    using SafeMath              for *;\r\n    using F3GKeysCalc        for uint256;\r\n    event onNewName\r\n    (\r\n        uint256 indexed playerID,\r\n        address indexed playerAddress,\r\n        bytes32 indexed playerName,\r\n        bool isNewPlayer,\r\n        uint256 affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 amountPaid,\r\n        uint256 timeStamp\r\n    );\r\n    event onEndTx\r\n    (\r\n        uint256 compressedData,     \r\n        uint256 compressedIDs,      \r\n        bytes32 playerName,\r\n        address playerAddress,\r\n        uint256 ethIn,\r\n        uint256 keysBought,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 R3Amount,\r\n        uint256 genAmount,\r\n        uint256 potAmount,\r\n        uint256 airDropPot\r\n    );\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed playerID,\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    event onWithdrawAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethOut,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 R3Amount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onBuyAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 ethIn,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 R3Amount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onReLoadAndDistribute\r\n    (\r\n        address playerAddress,\r\n        bytes32 playerName,\r\n        uint256 compressedData,\r\n        uint256 compressedIDs,\r\n        address winnerAddr,\r\n        bytes32 winnerName,\r\n        uint256 amountWon,\r\n        uint256 newPot,\r\n        uint256 R3Amount,\r\n        uint256 genAmount\r\n    );\r\n    \r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        address affiliateAddress,\r\n        bytes32 affiliateName,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    event onPotSwapDeposit\r\n    (\r\n        uint256 roundID,\r\n        uint256 amountAddedToPot\r\n    );\r\n    mapping(address => uint256)     private g_users ;\r\n    function initUsers() private {\r\n        g_users[msg.sender] = 9 ;\r\n        \r\n        uint256 pId = G_NowUserId;\r\n        pIDxAddr_[msg.sender] = pId;\r\n        plyr_[pId].addr = msg.sender;\r\n    }\r\n    modifier isAdmin() {\r\n        uint256 role = g_users[msg.sender];\r\n        require((role==9), \"Must be admin.\");\r\n        _;\r\n    }\r\n    modifier isHuman {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"Humans only\");\r\n        _;\r\n    }\r\n\r\n    address public commAddr_ = address(0x9e27E6b1219dDd2419C278C5B3D74169F6900F4d);\r\n    address public devAddr_ = address(0xe6CE2a354a0BF26B5b383015B7E61701F6adb39C);\r\n    address public affiAddr_ = address(0x08F521636a2B117B554d04dc9E54fa4061161859);\r\n\r\n    //合作伙伴\r\n    address public partnerAddr_ = address(0xD4c195777FB7856391390307BAbefA044DaD8DC1);\r\n\r\n    bool public activated_ = false;\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not active yet.\"); \r\n        _;\r\n    }\r\n    function activate() isAdmin() public {\r\n        require(address(commAddr_) != address(0x0), \"Must setup commAddr_.\");\r\n        require(address(devAddr_) != address(0x0), \"Must setup devAddr_.\");\r\n        require(address(partnerAddr_) != address(0x0), \"Must setup partnerAddr_.\");\r\n        require(address(affiAddr_) != address(0x0), \"Must setup affiAddr_.\");\r\n        require(activated_ == false, \"Only once\");\r\n        activated_ = true ;\r\n        rID_ = 1;\r\n        // ----\r\n        round_[1].strt = now ;                    \r\n        round_[1].end = round_[1].strt + rndMax_;   \r\n    }\r\n    string constant public name   = \"Fomo 3G Official\";                  // 合约名称\r\n    string constant public symbol = \"F3G\";                               // 合约符号\r\n\r\n    uint256 constant private rndInc_    = 1 minutes;                    // 每购买一个key延迟的时间\r\n    uint256 constant private rndMax_    = 5 hours;                      // 一轮的最长时间\r\n\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000, \"Too little\");\r\n        require(_eth <= 100000000000000000000000, \"Too much\");\r\n        _;    \r\n    }\r\n\r\n    uint256 public G_NowUserId = 1000; //当前用户编号\r\n    \r\n    mapping (address => uint256) public pIDxAddr_;  \r\n    mapping (uint256 => F3GDatasets.Player) public plyr_; \r\n    mapping (uint256 => mapping (uint256 => F3GDatasets.PlayerRounds)) public plyrRnds_;\r\n    uint256 public rID_;                    // 当前游戏轮编号 \r\n    uint256 public airDropPot_;             // 空投小奖池\r\n    uint256 public airDropTracker_ = 0;     // 空投小奖池计数\r\n    mapping (uint256 => F3GDatasets.Round) public round_;\r\n    mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;\r\n    mapping (uint256 => F3GDatasets.TeamFee) public fees_; \r\n    mapping (uint256 => F3GDatasets.PotSplit) public potSplit_;\r\n    \r\n    constructor() public {\r\n\r\n\t\t// Team allocation percentages\r\n        // (F3G, dev) + (Pot , Referrals, Community)\r\n            // Referrals / Community rewards are mathematically designed to come from the winner's share of the pot.\r\n        fees_[0] = F3GDatasets.TeamFee(36,3); //40% to pot, 15% to aff, 3% to com, 2% to 合作伙伴, 1% to air drop pot\r\n        fees_[1] = F3GDatasets.TeamFee(43,3);  //33% to pot, 15% to aff, 3% to com, 2% to 合作伙伴, 1% to air drop pot\r\n        fees_[2] = F3GDatasets.TeamFee(66,3); //10% to pot, 15% to aff, 3% to com, 2% to  合作伙伴, 1% to air drop pot\r\n\r\n        // how to split up the final pot based on which team was picked\r\n        // (F3G, dev)\r\n        potSplit_[0] = F3GDatasets.PotSplit(21,3);  //48% to winner, 25% to next round, 3% to com\r\n        potSplit_[1] = F3GDatasets.PotSplit(29,3);   //48% to winner, 17% to next round, 3% to com\r\n        potSplit_[2] = F3GDatasets.PotSplit(36,3);  //48% to winner, 10% to next round, 3% to com\r\n\r\n        initUsers();\r\n    }\r\n\r\n    function() isActivated() isHuman() isWithinLimits(msg.value) public payable {\r\n        F3GDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _team = 2;\r\n        buyCore(_pID, 0, _team, _eventData_);\r\n    }\r\n    function buy(uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable {\r\n        F3GDatasets.EventReturns memory _eventData_ = determinePID(_eventData_);\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        uint256 _affCode = plyr_[_pID].laff;\r\n        \r\n        require(_affCode != 0, \"must registration before\");\r\n\r\n        _team = verifyTeam(_team);\r\n        buyCore(_pID, _affCode, _team, _eventData_);\r\n    }\r\n    \r\n    function reLoadXid(uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public {\r\n        F3GDatasets.EventReturns memory _eventData_;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        uint256 _affCode = plyr_[_pID].laff;\r\n\r\n        require(_affCode != 0, \"must registration before\");\r\n\r\n        _team = verifyTeam(_team);\r\n        reLoadCore(_pID, _affCode, _team, _eth, _eventData_);\r\n    }\r\n\r\n    function withdraw() isActivated() isHuman() public {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n        uint256 _eth;\r\n        \r\n        if (_now > round_[_rID].end && (round_[_rID].ended == false) && round_[_rID].plyr != 0){\r\n            F3GDatasets.EventReturns memory _eventData_;\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n            // get their earnings\r\n            _eth = withdrawEarnings(_pID);\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            emit onWithdrawAndDistribute(\r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eth, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.R3Amount, \r\n                _eventData_.genAmount\r\n            );                \r\n        }else{\r\n            _eth = withdrawEarnings(_pID);\r\n            if (_eth > 0)\r\n                plyr_[_pID].addr.transfer(_eth);\r\n            emit onWithdraw(\r\n                _pID, \r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eth, \r\n                _now\r\n            );\r\n        }\r\n    }\r\n\r\n    function register(uint256 _affCode) isHuman() public payable{\r\n        \r\n        require(msg.value == 0, \"registration fee is 0 ether, please set the exact amount\");\r\n        require(_affCode != 0, \"error aff code\");\r\n        require(plyr_[_affCode].addr != address(0x0), \"error aff code\");\r\n        \r\n        G_NowUserId = G_NowUserId.add(1);\r\n        \r\n        address _addr = msg.sender;\r\n        \r\n        pIDxAddr_[_addr] = G_NowUserId;\r\n\r\n        plyr_[G_NowUserId].addr = _addr;\r\n        plyr_[G_NowUserId].laff = _affCode;\r\n        \r\n        uint256 _affID1 = _affCode;\r\n        uint256 _affID2 = plyr_[_affID1].laff;\r\n        uint256 _affID3 = plyr_[_affID2].laff;\r\n        uint256 _affID4 = plyr_[_affID3].laff;\r\n        uint256 _affID5 = plyr_[_affID4].laff;\r\n        \r\n        plyr_[_affID1].aff1sum = plyr_[_affID1].aff1sum.add(1);\r\n        plyr_[_affID2].aff2sum = plyr_[_affID2].aff2sum.add(1);\r\n        plyr_[_affID3].aff3sum = plyr_[_affID3].aff3sum.add(1);\r\n        plyr_[_affID4].aff4sum = plyr_[_affID4].aff4sum.add(1);\r\n        plyr_[_affID5].aff5sum = plyr_[_affID5].aff5sum.add(1);\r\n\r\n    }\r\n    \r\n    function getBuyPrice() public view  returns(uint256) {  \r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) );\r\n        else // rounds over.  need price for new round\r\n            return ( 75000000000000 ); // init\r\n    }\r\n    function getTimeLeft() public view returns(uint256) {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now ;\r\n        if(_rID == 1 && _now < round_[_rID].strt ) return (0);\r\n\r\n        if (_now < round_[_rID].end)\r\n            if (_now > round_[_rID].strt)\r\n                return( (round_[_rID].end).sub(_now) );\r\n            else\r\n                return( (round_[_rID].end).sub(_now) );\r\n        else\r\n            return(0);\r\n    }\r\n\r\n    function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) {\r\n        uint256 _rID = rID_;\r\n        if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0){\r\n            // if player is winner \r\n            if (round_[_rID].plyr == _pID){\r\n                uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n                return\r\n                (\r\n                    (plyr_[_pID].win).add( ((_pot).mul(48)) / 100 ),\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            // if player is not the winner\r\n            } else {\r\n                return(\r\n                    plyr_[_pID].win,\r\n                    (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ),\r\n                    plyr_[_pID].aff\r\n                );\r\n            }\r\n            \r\n        // if round is still going on, or round has ended and round end has been ran\r\n        } else {\r\n            return(\r\n                plyr_[_pID].win,\r\n                (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n                plyr_[_pID].aff\r\n            );\r\n        }\r\n    }\r\n\r\n    function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) {\r\n        uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n        return(  ((((round_[_rID].mask).add(((((_pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  );\r\n    }\r\n    function getCurrentRoundInfo() public view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) {\r\n        uint256 _rID = rID_;       \r\n        return\r\n            (\r\n                round_[_rID].ico,             \r\n                _rID,             \r\n                round_[_rID].keys,             \r\n                ((_rID == 1) && (now < round_[_rID].strt) ) ? 0 : round_[_rID].end,\r\n                ((_rID == 1) && (now < round_[_rID].strt) ) ? 0 : round_[_rID].strt,\r\n                round_[_rID].pot,             \r\n                (round_[_rID].team + (round_[_rID].plyr * 10)),\r\n                plyr_[round_[_rID].plyr].addr,\r\n                plyr_[round_[_rID].plyr].name,\r\n                rndTmEth_[_rID][0],\r\n                rndTmEth_[_rID][1],\r\n                rndTmEth_[_rID][2],\r\n                rndTmEth_[_rID][3],\r\n                airDropTracker_ + (airDropPot_ * 1000)\r\n            );     \r\n    }\r\n    function getPlayerInfoByAddress(address _addr) public  view  returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256){\r\n        uint256 _rID = rID_;\r\n        if (_addr == address(0)) {\r\n            _addr == msg.sender;\r\n        }\r\n        uint256 _pID = pIDxAddr_[_addr];\r\n\r\n        return (\r\n            _pID,\r\n            plyr_[_pID].name,\r\n            plyrRnds_[_pID][_rID].keys,\r\n            plyr_[_pID].win,\r\n            (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),\r\n            plyr_[_pID].aff,\r\n            plyrRnds_[_pID][_rID].eth\r\n        );\r\n    }\r\n\r\n    function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3GDatasets.EventReturns memory _eventData_) private {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\r\n            core(_rID, _pID, msg.value, _affID, _team, _eventData_);\r\n        }else{\r\n            if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n                round_[_rID].ended = true;\r\n                _eventData_ = endRound(_eventData_);\r\n\r\n                _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n                _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n                emit onBuyAndDistribute(\r\n                    msg.sender, \r\n                    plyr_[_pID].name, \r\n                    msg.value, \r\n                    _eventData_.compressedData, \r\n                    _eventData_.compressedIDs, \r\n                    _eventData_.winnerAddr, \r\n                    _eventData_.winnerName, \r\n                    _eventData_.amountWon, \r\n                    _eventData_.newPot, \r\n                    _eventData_.R3Amount, \r\n                    _eventData_.genAmount\r\n                );\r\n            }\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value);\r\n        }\r\n    }\r\n\r\n    function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3GDatasets.EventReturns memory _eventData_) private {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) {\r\n            plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth);\r\n            core(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n        }else if (_now > round_[_rID].end && round_[_rID].ended == false) {\r\n            round_[_rID].ended = true;\r\n            _eventData_ = endRound(_eventData_);\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000);\r\n            _eventData_.compressedIDs = _eventData_.compressedIDs + _pID;\r\n\r\n            emit onReLoadAndDistribute(\r\n                msg.sender, \r\n                plyr_[_pID].name, \r\n                _eventData_.compressedData, \r\n                _eventData_.compressedIDs, \r\n                _eventData_.winnerAddr, \r\n                _eventData_.winnerName, \r\n                _eventData_.amountWon, \r\n                _eventData_.newPot, \r\n                _eventData_.R3Amount, \r\n                _eventData_.genAmount\r\n            );\r\n        }\r\n    }\r\n\r\n    function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3GDatasets.EventReturns memory _eventData_) private{\r\n        if (plyrRnds_[_pID][_rID].keys == 0)\r\n            _eventData_ = managePlayer(_pID, _eventData_);\r\n        if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 5000000000000000000){\r\n            uint256 _availableLimit = (5000000000000000000).sub(plyrRnds_[_pID][_rID].eth);\r\n            uint256 _refund = _eth.sub(_availableLimit);\r\n            plyr_[_pID].gen = plyr_[_pID].gen.add(_refund);\r\n            _eth = _availableLimit;\r\n        }\r\n        if (_eth > 1000000000) {\r\n            uint256 _keys = (round_[_rID].eth).keysRec(_eth);\r\n\r\n            if (_keys >= 1000000000000000000){\r\n                updateTimer(_keys, _rID);\r\n                if (round_[_rID].plyr != _pID)\r\n                    round_[_rID].plyr = _pID;  \r\n                if (round_[_rID].team != _team)\r\n                    round_[_rID].team = _team; \r\n                _eventData_.compressedData = _eventData_.compressedData + 100;\r\n            }\r\n\r\n            if (_eth >= 100000000000000000){\r\n                // > 0.1 ether, 才有空投\r\n                airDropTracker_++;\r\n                if (airdrop() == true){\r\n                    uint256 _prize;\r\n                    if (_eth >= 10000000000000000000){\r\n                        // <= 10 ether\r\n                        _prize = ((airDropPot_).mul(75)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    }else if(_eth >= 1000000000000000000 && _eth < 10000000000000000000) {\r\n                        // >= 1 ether and < 10 ether\r\n                        _prize = ((airDropPot_).mul(50)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 200000000000000000000000000000000;\r\n\r\n                    }else if(_eth >= 100000000000000000 && _eth < 1000000000000000000){\r\n                        // >= 0.1 ether and < 1 ether\r\n                        _prize = ((airDropPot_).mul(25)) / 100;\r\n                        plyr_[_pID].win = (plyr_[_pID].win).add(_prize);\r\n\r\n                        airDropPot_ = (airDropPot_).sub(_prize);\r\n\r\n                        _eventData_.compressedData += 300000000000000000000000000000000;\r\n                    }\r\n\r\n                    _eventData_.compressedData += 10000000000000000000000000000000;\r\n\r\n                    _eventData_.compressedData += _prize * 1000000000000000000000000000000000;\r\n\r\n                    airDropTracker_ = 0;\r\n                }\r\n            }\r\n\r\n            _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000);\r\n\r\n            plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys);\r\n            plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth);\r\n\r\n            round_[_rID].keys = _keys.add(round_[_rID].keys);\r\n            round_[_rID].eth = _eth.add(round_[_rID].eth);\r\n            rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]);\r\n\r\n            // distribute eth\r\n            _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_);\r\n            _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_);\r\n\r\n            endTx(_pID, _team, _eth, _keys, _eventData_);\r\n        }\r\n\r\n    }\r\n\r\n    function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) {\r\n        return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  );\r\n    }\r\n\r\n    function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256){\r\n        uint256 _now = now;\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].eth).keysRec(_eth) );\r\n        else // rounds over.  need keys for new round\r\n            return ( (_eth).keys() );\r\n    }\r\n\r\n    function iWantXKeys(uint256 _keys) public view returns(uint256) {\r\n        uint256 _rID = rID_;\r\n        uint256 _now = now;\r\n\r\n        if (_now > round_[_rID].strt && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0)))\r\n            return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) );\r\n        else // rounds over.  need price for new round\r\n            return ( (_keys).eth() );\r\n    }\r\n\r\n    function determinePID(F3GDatasets.EventReturns memory _eventData_) private returns (F3GDatasets.EventReturns) {\r\n        uint256 _pID = pIDxAddr_[msg.sender];\r\n\r\n        return _eventData_ ;\r\n    }\r\n    function verifyTeam(uint256 _team) private pure returns (uint256) {\r\n        if (_team < 0 || _team > 2) \r\n            return(2);\r\n        else\r\n            return(_team);\r\n    }\r\n\r\n    function managePlayer(uint256 _pID, F3GDatasets.EventReturns memory _eventData_) private returns (F3GDatasets.EventReturns) {\r\n        if (plyr_[_pID].lrnd != 0)\r\n            updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        \r\n        plyr_[_pID].lrnd = rID_;\r\n\r\n        _eventData_.compressedData = _eventData_.compressedData + 10;\r\n\r\n        return _eventData_ ;\r\n    }\r\n    function endRound(F3GDatasets.EventReturns memory _eventData_) private returns (F3GDatasets.EventReturns) {\r\n        uint256 _rID = rID_;\r\n        uint256 _winPID = round_[_rID].plyr;\r\n        uint256 _winTID = round_[_rID].team;\r\n        // grab our pot amount\r\n        uint256 _pot = round_[_rID].pot.add(round_[_rID].prevres);\r\n\r\n        uint256 _win = (_pot.mul(48)) / 100;\r\n        uint256 _com = (_pot.mul(3)) / 100;\r\n        uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100;\r\n        uint256 _dev = (_pot.mul(potSplit_[_winTID].dev)) / 100;\r\n        uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_dev);\r\n        // calculate ppt for round mask\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000);\r\n        if (_dust > 0){\r\n            _gen = _gen.sub(_dust);\r\n            _res = _res.add(_dust);\r\n        }\r\n\r\n        plyr_[_winPID].win = _win.add(plyr_[_winPID].win);\r\n        if(_com>0) {\r\n            commAddr_.transfer(_com);\r\n            _com = 0 ;\r\n        }\r\n\r\n        if(_dev > 0) {\r\n            devAddr_.transfer(_dev);\r\n        }\r\n\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n\r\n        _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000);\r\n        _eventData_.winnerAddr = plyr_[_winPID].addr;\r\n        _eventData_.winnerName = plyr_[_winPID].name;\r\n        _eventData_.amountWon = _win;\r\n        _eventData_.genAmount = _gen;\r\n        _eventData_.R3Amount = 0;\r\n        _eventData_.newPot = _res;\r\n        // 下一轮\r\n        rID_++;\r\n        _rID++;\r\n        round_[_rID].strt = now;\r\n        round_[_rID].end = now.add(rndMax_);\r\n        round_[_rID].prevres = _res;\r\n\r\n        return(_eventData_);\r\n    }\r\n\r\n    function updateGenVault(uint256 _pID, uint256 _rIDlast) private {\r\n        uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast);\r\n        if (_earnings > 0){\r\n            plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen);\r\n\r\n            plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask);\r\n\r\n        }\r\n    }\r\n\r\n    function updateTimer(uint256 _keys, uint256 _rID) private {\r\n        uint256 _now = now;\r\n\r\n        uint256 _newTime;\r\n\r\n        if (_now > round_[_rID].end && round_[_rID].plyr == 0)\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now);\r\n        else\r\n            _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end);\r\n\r\n        if (_newTime < (rndMax_).add(_now))\r\n            round_[_rID].end = _newTime;\r\n        else\r\n            round_[_rID].end = rndMax_.add(_now);\r\n    }\r\n\r\n    function airdrop() private  view  returns(bool) {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n            \r\n        )));\r\n        if((seed - ((seed / 1000) * 1000)) < airDropTracker_)\r\n            return(true);\r\n        else\r\n            return(false);\r\n    }\r\n    \r\n    function distributeRef(uint256 _eth, uint256 _affID) private{\r\n        \r\n        uint256 _allaff = (_eth.mul(15)).div(100);\r\n        \r\n        //五级返佣\r\n        uint256 _affID1 = _affID;\r\n        uint256 _affID2 = plyr_[_affID1].laff;\r\n        uint256 _affID3 = plyr_[_affID2].laff;\r\n        uint256 _affID4 = plyr_[_affID3].laff;\r\n        uint256 _affID5 = plyr_[_affID4].laff;\r\n        uint256 _aff = 0;\r\n\r\n        if (_affID1 != 0) {   \r\n            _aff = (_eth.mul(5)).div(100);\r\n            _allaff = _allaff.sub(_aff);\r\n            plyr_[_affID1].aff = _aff.add(plyr_[_affID1].aff);\r\n        }\r\n\r\n        if (_affID2 != 0) {   \r\n            _aff = (_eth.mul(2)).div(100);\r\n            _allaff = _allaff.sub(_aff);\r\n            plyr_[_affID2].aff = _aff.add(plyr_[_affID2].aff);\r\n        }\r\n\r\n        if (_affID3 != 0) {   \r\n            _aff = (_eth.mul(1)).div(100);\r\n            _allaff = _allaff.sub(_aff);\r\n            plyr_[_affID3].aff = _aff.add(plyr_[_affID3].aff);\r\n        }\r\n\r\n        if (_affID4 != 0) {   \r\n            _aff = (_eth.mul(2)).div(100);\r\n            _allaff = _allaff.sub(_aff);\r\n            plyr_[_affID4].aff = _aff.add(plyr_[_affID4].aff);\r\n        }\r\n\r\n        if (_affID5 != 0) {   \r\n            _aff = (_eth.mul(5)).div(100);\r\n            _allaff = _allaff.sub(_aff);\r\n            plyr_[_affID5].aff = _aff.add(plyr_[_affID5].aff);\r\n        }\r\n        \r\n        if(_allaff > 0 ){\r\n            affiAddr_.transfer(_allaff);\r\n        }          \r\n    }\r\n    \r\n    function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3GDatasets.EventReturns memory _eventData_) \r\n        private returns(F3GDatasets.EventReturns){\r\n\r\n        uint256 _comm = (_eth.mul(3)).div(100);\r\n        if (_comm > 0) {\r\n            commAddr_.transfer(_comm);\r\n        }\r\n        \r\n        distributeRef(_eth, _affID);\r\n\r\n        // partner\r\n        uint256 _partner = (_eth.mul(2)).div(100);\r\n        partnerAddr_.transfer(_partner);\r\n\r\n        uint256 _dev = (_eth.mul(fees_[_team].dev)).div(100);\r\n        if(_dev>0){\r\n            devAddr_.transfer(_dev);\r\n        }\r\n        return (_eventData_) ; \r\n\r\n    }\r\n\r\n    function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3GDatasets.EventReturns memory _eventData_)\r\n        private returns(F3GDatasets.EventReturns) {\r\n        // 持有者的份额 \r\n        uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100;    \r\n        // 空投小奖池 1%\r\n        uint256 _air = (_eth / 100);\r\n        airDropPot_ = airDropPot_.add(_air);\r\n        // 21% = aff airpot etc.\r\n        _eth = _eth.sub(((_eth.mul(21)) / 100).add((_eth.mul(fees_[_team].dev)) / 100));\r\n        // 奖池\r\n        uint256 _pot = _eth.sub(_gen);\r\n\r\n        uint256 _dust = updateMasks(_rID, _pID, _gen, _keys);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n        \r\n        round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot);\r\n\r\n        _eventData_.genAmount = _gen.add(_eventData_.genAmount);\r\n        _eventData_.potAmount = _pot;\r\n\r\n        return(_eventData_);\r\n    }\r\n    \r\n    function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) {\r\n        uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys);\r\n        round_[_rID].mask = _ppt.add(round_[_rID].mask);\r\n        uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000);\r\n        plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask);\r\n        return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)));\r\n    }\r\n    function withdrawEarnings(uint256 _pID) private returns(uint256) {\r\n        updateGenVault(_pID, plyr_[_pID].lrnd);\r\n        uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff);\r\n        if (_earnings > 0){\r\n            plyr_[_pID].win = 0;\r\n            plyr_[_pID].gen = 0;\r\n            plyr_[_pID].aff = 0;\r\n        }\r\n        return(_earnings);\r\n    }\r\n    function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3GDatasets.EventReturns memory _eventData_) private {\r\n        _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000);\r\n        _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000);\r\n\r\n        emit onEndTx(\r\n            _eventData_.compressedData,\r\n            _eventData_.compressedIDs,\r\n            plyr_[_pID].name,\r\n            msg.sender,\r\n            _eth,\r\n            _keys,\r\n            _eventData_.winnerAddr,\r\n            _eventData_.winnerName,\r\n            _eventData_.amountWon,\r\n            _eventData_.newPot,\r\n            _eventData_.R3Amount,\r\n            _eventData_.genAmount,\r\n            _eventData_.potAmount,\r\n            airDropPot_\r\n        );\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropTracker_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"plyr\",\"type\":\"uint256\"},{\"name\":\"team\",\"type\":\"uint256\"},{\"name\":\"end\",\"type\":\"uint256\"},{\"name\":\"ended\",\"type\":\"bool\"},{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"},{\"name\":\"icoGen\",\"type\":\"uint256\"},{\"name\":\"icoAvg\",\"type\":\"uint256\"},{\"name\":\"prevres\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"fees_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"dev\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rndTmEth_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"partnerAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_pID\",\"type\":\"uint256\"}],\"name\":\"getPlayerVaults\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"G_NowUserId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_team\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"reLoadXid\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyrRnds_\",\"outputs\":[{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"ico\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"potSplit_\",\"outputs\":[{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"dev\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTimeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"commAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_rID\",\"type\":\"uint256\"},{\"name\":\"_eth\",\"type\":\"uint256\"}],\"name\":\"calcKeysReceived\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_keys\",\"type\":\"uint256\"}],\"name\":\"iWantXKeys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"airDropPot_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_team\",\"type\":\"uint256\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"plyr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lrnd\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"aff1sum\",\"type\":\"uint256\"},{\"name\":\"aff2sum\",\"type\":\"uint256\"},{\"name\":\"aff3sum\",\"type\":\"uint256\"},{\"name\":\"aff4sum\",\"type\":\"uint256\"},{\"name\":\"aff5sum\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getPlayerInfoByAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"uint256\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"affiAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"isNewPlayer\",\"type\":\"bool\"},{\"indexed\":false,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountPaid\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onNewName\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"keysBought\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"R3Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"potAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"airDropPot\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"playerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"R3Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onWithdrawAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"R3Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onBuyAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"playerAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"playerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"compressedData\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"compressedIDs\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"winnerAddr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"winnerName\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"amountWon\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"newPot\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"R3Amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"genAmount\",\"type\":\"uint256\"}],\"name\":\"onReLoadAndDistribute\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"affiliateAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"affiliateName\",\"type\":\"bytes32\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amountAddedToPot\",\"type\":\"uint256\"}],\"name\":\"onPotSwapDeposit\",\"type\":\"event\"}]","ContractName":"F3G","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://ac9124109cae7d30aa7757c1dd2633051c3c8dc742f0b51f5e418809bbed6191"}]}