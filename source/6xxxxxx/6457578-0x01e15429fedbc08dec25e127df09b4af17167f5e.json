{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n\r\n/**\r\n* VOXTrader for the talketh.io ICO by Horizon-Globex.com of Switzerland.\r\n*\r\n* An ERC20 compliant DEcentralized eXchange [DEX] https://talketh.io/dex\r\n*\r\n* ICO issuers that utilize the Swiss token issuance standard from Horizon Globex\r\n* are supplied with a complete KYC+AML platform, an ERC20 token issuance platform,\r\n* a Transfer Agent service, and a post-ICO ERC20 DEX for their investor exit strategy.\r\n*\r\n* Trade events shall be rebroadcast on issuers Twitter feed https://twitter.com/talkethICO\r\n*\r\n* -- DEX Platform Notes --\r\n* 1. By default, only KYC'ed hodlers of tokens may participate on this DEX.\r\n*    - Issuer is free to relax this restriction subject to counsels Legal Opinion.\r\n* 2. The issuer has sole discretion to set a minimum bid and a maximum ask. \r\n* 3. Seller shall pay a trade execution fee in ETH which is automatically deducted herein. \r\n*    - Issuer is free to amend the trade execution fee percentage from time to time.\r\n*\r\n*/\r\n\r\n// ----------------------------------------------------------------------------\r\n// ERC Token Standard #20 Interface\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20.sol\r\n// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/token/ERC20/ERC20Basic.sol\r\n// \r\n// ----------------------------------------------------------------------------\r\ncontract ERC20Interface {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function allowance(address approver, address spender) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n\r\n    // solhint-disable-next-line no-simple-event-func-name\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed approver, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\n\r\n//\r\n// base contract for all our horizon contracts and tokens\r\n//\r\ncontract HorizonContractBase {\r\n    // The owner of the contract, set at contract creation to the creator.\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // Contract authorization - only allow the owner to perform certain actions.\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner, \"Only the owner can call this function.\");\r\n        _;\r\n    }\r\n}\r\n\r\n\r\n\r\n\r\n \r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n *\r\n * Source: https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\r\n */\r\nlibrary SafeMath {\r\n    /**\r\n     * @dev Multiplies two numbers, throws on overflow.\r\n     */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n/// math.sol -- mixin for inline numerical wizardry\r\n\r\n// Taken from: https://dapp.tools/dappsys/ds-math.html\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\n\r\n\r\nlibrary DSMath {\r\n    \r\n    function dsAdd(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n\r\n    function dsMul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = dsAdd(dsMul(x, y), WAD / 2) / WAD;\r\n    }\r\n\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = dsAdd(dsMul(x, WAD), y / 2) / y;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n* VOXTrader for the talketh.io ICO by Horizon-Globex.com of Switzerland.\r\n*\r\n* An ERC20 compliant DEcentralized eXchange [DEX] https://talketh.io/dex\r\n*\r\n* ICO issuers that utilize the Swiss token issuance standard from Horizon Globex\r\n* are supplied with a complete KYC+AML platform, an ERC20 token issuance platform,\r\n* a Transfer Agent service, and a post-ICO ERC20 DEX for their investor exit strategy.\r\n*\r\n* Trade events shall be rebroadcast on issuers Twitter feed https://twitter.com/talkethICO\r\n*\r\n* -- DEX Platform Notes --\r\n* 1. By default, only KYC'ed hodlers of tokens may participate on this DEX.\r\n*    - Issuer is free to relax this restriction subject to counsels Legal Opinion.\r\n* 2. The issuer has sole discretion to set a minimum bid and a maximum ask. \r\n* 3. Seller shall pay a trade execution fee in ETH which is automatically deducted herein. \r\n*    - Issuer is free to amend the trade execution fee percentage from time to time.\r\n*\r\n*/\r\ncontract VOXTrader is HorizonContractBase {\r\n    using SafeMath for uint256;\r\n    using DSMath for uint256;\r\n\r\n    struct TradeOrder {\r\n        uint256 quantity;\r\n        uint256 price;\r\n        uint256 expiry;\r\n    }\r\n\r\n    // The owner of this contract.\r\n    address public owner;\r\n\r\n    // The balances of all accounts.\r\n    mapping (address => TradeOrder) public orderBook;\r\n\r\n    // The contract containing the tokens that we trade.\r\n    address public tokenContract;\r\n\r\n    // The price paid for the last sale of tokens on this contract.\r\n    uint256 public lastSellPrice;\r\n\r\n    // The highest price an asks can be placed.\r\n    uint256 public sellCeiling;\r\n\r\n    // The lowest price an ask can be placed.\r\n    uint256 public sellFloor;\r\n\r\n    // The percentage taken off the cost of buying tokens in Ether.\r\n    uint256 public etherFeePercent;\r\n    \r\n    // The minimum Ether fee when buying tokens (if the calculated percent is less than this value);\r\n    uint256 public etherFeeMin;\r\n\r\n    // Both buying and selling tokens is restricted to only those who have successfully passed KYC.\r\n    bool public enforceKyc;\r\n\r\n    // The addresses of those allowed to trade using this contract.\r\n    mapping (address => bool) public tradingWhitelist;\r\n\r\n    // A sell order was put into the order book.\r\n    event TokensOffered(address indexed who, uint256 quantity, uint256 price, uint256 expiry);\r\n\r\n    // A user bought tokens from another user.\r\n    event TokensPurchased(address indexed purchaser, address indexed seller, uint256 quantity, uint256 price);\r\n\r\n    // A user updated their ask.\r\n    event TokenOfferChanged(address who, uint256 quantity, uint256 price, uint256 expiry);\r\n\r\n    // A user bought phone credit using a top-up voucher, buy VOX Tokens on thier behalf to convert to phone credit.\r\n    event VoucherRedeemed(uint256 voucherCode, address voucherOwner, address tokenSeller, uint256 quantity);\r\n\r\n    // The contract has been shut down.\r\n    event ContractRetired(address newAddcontract);\r\n\r\n\r\n    /**\r\n     * @notice Set owner and the target ERC20 contract containing the tokens it trades.\r\n     *\r\n     * @param tokenContract_    The ERC20 contract whose tokens this contract trades.\r\n     */\r\n    constructor(address tokenContract_) public {\r\n        owner = msg.sender;\r\n        tokenContract = tokenContract_;\r\n\r\n        // On publication the only person allowed trade is the issuer/owner.\r\n        enforceKyc = true;\r\n        setTradingAllowed(msg.sender, true);\r\n    }\r\n\r\n    /**\r\n     * @notice Get the trade order for the specified address.\r\n     *\r\n     * @param who    The address to get the trade order of.\r\n     */\r\n    function getOrder(address who) public view returns (uint256 quantity, uint256 price, uint256 expiry) {\r\n        TradeOrder memory order = orderBook[who];\r\n        return (order.quantity, order.price, order.expiry);\r\n    }\r\n\r\n    /**\r\n     * @notice Offer tokens for sale, you must call approve on the ERC20 contract first, giving approval to\r\n     * the address of this contract.\r\n     *\r\n     * @param quantity  The number of tokens to offer for sale.\r\n     * @param price     The unit price of the tokens.\r\n     * @param expiry    The date and time this order ends.\r\n     */\r\n    function offer(uint256 quantity, uint256 price, uint256 expiry) public {\r\n        require(enforceKyc == false || isAllowedTrade(msg.sender), \"You are unknown and not allowed to trade.\");\r\n        require(quantity > 0, \"You must supply a quantity.\");\r\n        require(price > 0, \"The sale price cannot be zero.\");\r\n        require(expiry > block.timestamp, \"Cannot have an expiry date in the past.\");\r\n        require(price >= sellFloor, \"The ask is below the minimum allowed.\");\r\n        require(sellCeiling == 0 || price <= sellCeiling, \"The ask is above the maximum allowed.\");\r\n\r\n        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, this);\r\n        require(allowed >= quantity, \"You must approve the transfer of tokens before offering them for sale.\");\r\n\r\n        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);\r\n        require(balance >= quantity, \"Not enough tokens owned to complete the order.\");\r\n\r\n        orderBook[msg.sender] = TradeOrder(quantity, price, expiry);\r\n        emit TokensOffered(msg.sender, quantity, price, expiry);\r\n    }\r\n\r\n    /**\r\n     * @notice Buy tokens from an existing sell order.\r\n     *\r\n     * @param seller    The current owner of the tokens for sale.\r\n     * @param quantity  The number of tokens to buy.\r\n     * @param price     The ask price of the tokens.\r\n    */\r\n    function execute(address seller, uint256 quantity, uint256 price) public payable {\r\n        require(enforceKyc == false || (isAllowedTrade(msg.sender) && isAllowedTrade(seller)), \"Buyer and Seller must be approved to trade on this exchange.\");\r\n        TradeOrder memory order = orderBook[seller];\r\n        require(order.price == price, \"Buy price does not match the listed sell price.\");\r\n        require(block.timestamp < order.expiry, \"Sell order has expired.\");\r\n        require(price >= sellFloor, \"The bid is below the minimum allowed.\");\r\n        require(sellCeiling == 0 || price <= sellCeiling, \"The bid is above the maximum allowed.\");\r\n\r\n        // Deduct the sold tokens from the sell order immediateley to prevent re-entrancy.\r\n        uint256 tradeQuantity = order.quantity > quantity ? quantity : order.quantity;\r\n        order.quantity = order.quantity.sub(tradeQuantity);\r\n        if (order.quantity == 0) {\r\n            order.price = 0;\r\n            order.expiry = 0;\r\n        }\r\n        orderBook[seller] = order;\r\n\r\n        uint256 cost = tradeQuantity.wmul(order.price);\r\n        require(msg.value >= cost, \"You did not send enough Ether to purchase the tokens.\");\r\n\r\n        uint256 etherFee = calculateFee(cost);\r\n\r\n        if(!ERC20Interface(tokenContract).transferFrom(seller, msg.sender, tradeQuantity)) {\r\n            revert(\"Unable to transfer tokens from seller to buyer.\");\r\n        }\r\n\r\n        // Pay the seller and if applicable the fee to the issuer.\r\n        seller.transfer(cost.sub(etherFee));\r\n        if(etherFee > 0)\r\n            owner.transfer(etherFee);\r\n\r\n        lastSellPrice = price;\r\n\r\n        emit TokensPurchased(msg.sender, seller, tradeQuantity, price);\r\n    }\r\n\r\n    /**\r\n     * @notice Cancel an outstanding order.\r\n     */\r\n    function cancel() public {\r\n        orderBook[msg.sender] = TradeOrder(0, 0, 0);\r\n\r\n        TradeOrder memory order = orderBook[msg.sender];\r\n        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);\r\n    }\r\n\r\n    /** @notice Allow/disallow users from participating in trading.\r\n     *\r\n     * @param who       The user \r\n     * @param canTrade  True to allow trading, false to disallow.\r\n    */\r\n    function setTradingAllowed(address who, bool canTrade) public onlyOwner {\r\n        tradingWhitelist[who] = canTrade;\r\n    }\r\n\r\n    /**\r\n     * @notice Check if a user is allowed to trade.\r\n     *\r\n     * @param who   The user to check.\r\n     */\r\n    function isAllowedTrade(address who) public view returns (bool) {\r\n        return tradingWhitelist[who];\r\n    }\r\n\r\n    /**\r\n     * @notice Restrict trading to only those who are whitelisted.  This is true during the ICO.\r\n     *\r\n     * @param enforce   True to restrict trading, false to open it up.\r\n    */\r\n    function setEnforceKyc(bool enforce) public onlyOwner {\r\n        enforceKyc = enforce;\r\n    }\r\n\r\n    /**\r\n     * @notice Modify the price of an existing ask.\r\n     *\r\n     * @param price     The new price.\r\n     */\r\n    function setOfferPrice(uint256 price) public {\r\n        require(enforceKyc == false || isAllowedTrade(msg.sender), \"You are unknown and not allowed to trade.\");\r\n        require(price >= sellFloor && (sellCeiling == 0 || price <= sellCeiling), \"Updated price is out of range.\");\r\n\r\n        TradeOrder memory order = orderBook[msg.sender];\r\n        require(order.price != 0 || order.expiry != 0, \"There is no existing order to modify.\");\r\n        \r\n        order.price = price;\r\n        orderBook[msg.sender] = order;\r\n\r\n        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);\r\n    }\r\n\r\n    /**\r\n     * @notice Change the number of VOX Tokens offered by this user.  NOTE: to set the quantity to zero use cancel().\r\n     *\r\n     * @param quantity  The new quantity of the ask.\r\n     */\r\n    function setOfferSize(uint256 quantity) public {\r\n        require(enforceKyc == false || isAllowedTrade(msg.sender), \"You are unknown and not allowed to trade.\");\r\n        require(quantity > 0, \"Size must be greater than zero, change rejected.\");\r\n        uint256 balance = ERC20Interface(tokenContract).balanceOf(msg.sender);\r\n        require(balance >= quantity, \"Not enough tokens owned to complete the order change.\");\r\n        uint256 allowed = ERC20Interface(tokenContract).allowance(msg.sender, this);\r\n        require(allowed >= quantity, \"You must approve the transfer of tokens before offering them for sale.\");\r\n\r\n        TradeOrder memory order = orderBook[msg.sender];\r\n        order.quantity = quantity;\r\n        orderBook[msg.sender] = order;\r\n\r\n        emit TokenOfferChanged(msg.sender, quantity, order.price, order.expiry);\r\n    }\r\n\r\n    /**\r\n     * @notice Modify the expiry date of an existing ask.\r\n     *\r\n     * @param expiry    The new expiry date.\r\n     */\r\n    function setOfferExpiry(uint256 expiry) public {\r\n        require(enforceKyc == false || isAllowedTrade(msg.sender), \"You are unknown and not allowed to trade.\");\r\n        require(expiry > block.timestamp, \"Cannot have an expiry date in the past.\");\r\n\r\n        TradeOrder memory order = orderBook[msg.sender];\r\n        order.expiry = expiry;\r\n        orderBook[msg.sender] = order;\r\n\r\n        emit TokenOfferChanged(msg.sender, order.quantity, order.price, order.expiry);        \r\n    }\r\n\r\n    /**\r\n     * @notice Set the percent fee applied to the Ether used to pay for tokens.\r\n     *\r\n     * @param percent   The new percentage value at 18 decimal places.\r\n     */\r\n    function setEtherFeePercent(uint256 percent) public onlyOwner {\r\n        require(percent <= 100000000000000000000, \"Percent must be between 0 and 100.\");\r\n        etherFeePercent = percent;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the minimum amount of Ether to be deducted during a buy.\r\n     *\r\n     * @param min   The new minimum value.\r\n     */\r\n    function setEtherFeeMin(uint256 min) public onlyOwner {\r\n        etherFeeMin = min;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate the company's fee for facilitating the transfer of tokens.  The fee is in Ether so\r\n     * is deducted from the seller of the tokens.\r\n     *\r\n     * @param ethers    The amount of Ether to pay for the tokens.\r\n     * @return fee      The amount of Ether taken as a fee during a transfer.\r\n     */\r\n    function calculateFee(uint256 ethers) public view returns (uint256 fee) {\r\n\r\n        fee = ethers.wmul(etherFeePercent / 100);\r\n        if(fee < etherFeeMin)\r\n            fee = etherFeeMin;            \r\n\r\n        return fee;\r\n    }\r\n\r\n    /**\r\n     * @notice Buy from multiple sellers at once to fill a single large order.\r\n     *\r\n     * @dev This function is to reduce the transaction costs and to make the purchase a single transaction.\r\n     *\r\n     * @param sellers       The list of sellers whose tokens make up this buy.\r\n     * @param lastQuantity  The quantity of tokens to buy from the last seller on the list (the other asks\r\n     *                      are bought in full).\r\n     */\r\n    function multiExecute(address[] sellers, uint256 lastQuantity) public payable returns (uint256 totalVouchers) {\r\n        require(enforceKyc == false || isAllowedTrade(msg.sender), \"You are unknown and not allowed to trade.\");\r\n\r\n        totalVouchers = 0;\r\n\r\n        for (uint i = 0; i < sellers.length; i++) {\r\n            TradeOrder memory to = orderBook[sellers[i]];\r\n            if(i == sellers.length-1) {\r\n                execute(sellers[i], lastQuantity, to.price);\r\n                totalVouchers += lastQuantity;\r\n            }\r\n            else {\r\n                execute(sellers[i], to.quantity, to.price);\r\n                totalVouchers += to.quantity;\r\n            }\r\n        }\r\n\r\n        return totalVouchers;\r\n    }\r\n\r\n    /**\r\n     * @notice A user has redeemed a top-up voucher for phone credit.  This is executed by the owner as it is an internal process\r\n     * to convert a voucher to phone credit via VOX Tokens.\r\n     *\r\n     * @param voucherCode   The code on the e.g. scratch card that is to be redeemed for call credit.\r\n     * @param voucherOwner  The wallet id of the user redeeming the voucher.\r\n     * @param seller        The wallet id selling the VOX Tokens needed to fill the voucher.\r\n     * @param quantity      The quantity of VOX tokens needed to fill the voucher.\r\n     */\r\n    function redeemVoucherSingle(uint256 voucherCode, address voucherOwner, address seller, uint256 quantity) public onlyOwner payable {\r\n\r\n        // Send ether to the token owner and as we buy them as the owner they get burned.\r\n        TradeOrder memory order = orderBook[seller];\r\n        execute(seller, quantity, order.price);\r\n\r\n        // Log the event so the system can detect the successful top-up and transfer credit to the voucher owner.\r\n        emit VoucherRedeemed(voucherCode, voucherOwner, seller, quantity);\r\n    }\r\n\r\n    /**\r\n     * @notice A user has redeemed a top-up voucher for phone credit.  This is executed by the owner as it is an internal process\r\n     * to convert a voucher to phone credit via VOX Tokens.\r\n     *\r\n     * @param voucherCode   The code on the e.g. scratch card that is to be redeemed for call credit.\r\n     * @param voucherOwner  The wallet id of the user redeeming the voucher.\r\n     * @param sellers       The wallet id(s) selling the VOX Tokens needed to fill the voucher.\r\n     * @param lastQuantity  The quantity of the last seller's ask to use, the other orders are used in full.\r\n     */\r\n    function redeemVoucher(uint256 voucherCode, address voucherOwner, address[] sellers, uint256 lastQuantity) public onlyOwner payable {\r\n\r\n        // Send ether to the token owner and as we buy them as the owner they get burned.\r\n        uint256 totalVouchers = multiExecute(sellers, lastQuantity);\r\n\r\n        // If we fill the voucher from multiple sellers we set the seller address to zero, the associated\r\n        // TokensPurchased events will contain the details of the orders filled.\r\n        address seller = sellers.length == 1 ? sellers[0] : 0;\r\n        emit VoucherRedeemed(voucherCode, voucherOwner, seller, totalVouchers);\r\n    }\r\n\r\n    /**\r\n     * @notice Set the highest price an ask can be listed.\r\n     *\r\n     * @param ceiling   The new maximum price allowed for a sale.\r\n     */\r\n    function setSellCeiling(uint256 ceiling) public onlyOwner {\r\n        sellCeiling = ceiling;\r\n    }\r\n\r\n    /**\r\n     * @notice Set the lowest price an ask can be listed.\r\n     *\r\n     * @param floor   The new minimum price allowed for a sale.\r\n     */\r\n    function setSellFloor(uint256 floor) public onlyOwner {\r\n        sellFloor = floor;\r\n    }\r\n\r\n    /**\r\n    * @dev A newer version of this contract is available and this contract is now discontinued.\r\n    *\r\n    * @param recipient      Which account would get any ether from this contract (it shouldn't have any).\r\n    * @param newContract    The address of the newer version of this contract.\r\n    */\r\n    function retire(address recipient, address newContract) public onlyOwner {\r\n        emit ContractRetired(newContract);\r\n\r\n        selfdestruct(recipient);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"etherFeeMin\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ceiling\",\"type\":\"uint256\"}],\"name\":\"setSellCeiling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"sellers\",\"type\":\"address[]\"},{\"name\":\"lastQuantity\",\"type\":\"uint256\"}],\"name\":\"multiExecute\",\"outputs\":[{\"name\":\"totalVouchers\",\"type\":\"uint256\"}],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"getOrder\",\"outputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"tradingWhitelist\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"orderBook\",\"outputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"},{\"name\":\"canTrade\",\"type\":\"bool\"}],\"name\":\"setTradingAllowed\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"offer\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"voucherCode\",\"type\":\"uint256\"},{\"name\":\"voucherOwner\",\"type\":\"address\"},{\"name\":\"sellers\",\"type\":\"address[]\"},{\"name\":\"lastQuantity\",\"type\":\"uint256\"}],\"name\":\"redeemVoucher\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lastSellPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"setOfferPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"ethers\",\"type\":\"uint256\"}],\"name\":\"calculateFee\",\"outputs\":[{\"name\":\"fee\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"recipient\",\"type\":\"address\"},{\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"retire\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"enforce\",\"type\":\"bool\"}],\"name\":\"setEnforceKyc\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellFloor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"floor\",\"type\":\"uint256\"}],\"name\":\"setSellFloor\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sellCeiling\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"min\",\"type\":\"uint256\"}],\"name\":\"setEtherFeeMin\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"quantity\",\"type\":\"uint256\"},{\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"execute\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"etherFeePercent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"setOfferExpiry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"voucherCode\",\"type\":\"uint256\"},{\"name\":\"voucherOwner\",\"type\":\"address\"},{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"redeemVoucherSingle\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"enforceKyc\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"percent\",\"type\":\"uint256\"}],\"name\":\"setEtherFeePercent\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"who\",\"type\":\"address\"}],\"name\":\"isAllowedTrade\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"setOfferSize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"tokenContract_\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"TokensOffered\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"purchaser\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"}],\"name\":\"TokensPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"who\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"price\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"expiry\",\"type\":\"uint256\"}],\"name\":\"TokenOfferChanged\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"voucherCode\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voucherOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenSeller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"quantity\",\"type\":\"uint256\"}],\"name\":\"VoucherRedeemed\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newAddcontract\",\"type\":\"address\"}],\"name\":\"ContractRetired\",\"type\":\"event\"}]","ContractName":"VOXTrader","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"0000000000000000000000009e17d13b638fc9f0ca941d4fe1c3e4da827cece1","Library":"","SwarmSource":"bzzr://576a982a80e98d368667b6db31be4fbdf96348a7264e60afa1f5ea385cdc7df3"}]}