{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\nlibrary Math {\r\n  function min(uint a, uint b) internal pure returns(uint) {\r\n    if (a > b) {\r\n      return b;\r\n    }\r\n    return a;\r\n  }\r\n  \r\n  function max(uint a, uint b) internal pure returns(uint) {\r\n    if (a > b) {\r\n      return a;\r\n    }\r\n    return b;\r\n  }\r\n}\r\n\r\nlibrary Percent {\r\n  // Solidity automatically throws when dividing by 0\r\n  struct percent {\r\n    uint num;\r\n    uint den;\r\n  }\r\n  \r\n  // storage\r\n  function mul(percent storage p, uint a) internal view returns (uint) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n    return a*p.num/p.den;\r\n  }\r\n\r\n    function toMemory(percent storage p) internal view returns (Percent.percent memory) {\r\n    return Percent.percent(p.num, p.den);\r\n  }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, reverts on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = _a * _b;\r\n    require(c / _a == _b);\r\n\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, reverts on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    uint256 c = _a + _b;\r\n    require(c >= _a);\r\n\r\n    return c;\r\n  }\r\n  \r\n  /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        require(b <= a);\r\n        uint256 c = a - b;\r\n\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() internal {\r\n    owner = msg.sender;\r\n    emit OwnershipTransferred(address(0), owner);\r\n  }\r\n\r\n  /**\r\n   * @return the address of the owner.\r\n   */\r\n  function owner() public view returns(address) {\r\n    return owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(isOwner());\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @return true if `msg.sender` is the owner of the contract.\r\n   */\r\n  function isOwner() public view returns(bool) {\r\n    return msg.sender == owner;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipTransferred(owner, address(0));\r\n    owner = address(0);\r\n  }\r\n}\r\n\r\n//шаблон контракта \r\ncontract distribution is Ownable {\r\n    using SafeMath for uint;\r\n    \r\n    uint public currentPaymentIndex = 0;\r\n    uint public depositorsCount;\r\n    uint public amountForDistribution = 0;\r\n    uint public amountRaised = 0;\r\n    \r\n    struct Deposite {\r\n        address depositor;\r\n        uint amount;\r\n        uint depositeTime;\r\n        uint paimentTime;\r\n    }\r\n    \r\n    Deposite[] public deposites;\r\n\r\n    mapping ( address => uint[]) public depositors;\r\n    \r\n    function getAllDepositesCount() public view returns (uint) ;\r\n    \r\n    function getLastDepositId() public view returns (uint) ;\r\n\r\n    function getDeposit(uint _id) public view returns (address, uint, uint, uint);\r\n}\r\n\r\ncontract FromResponsibleInvestors is Ownable {\r\n    using Percent for Percent.percent;\r\n    using SafeMath for uint;\r\n    using Math for uint;\r\n    \r\n    //Address for advertising and admins expences\r\n    address constant public advertisingAddress = address(0x43571AfEA3c3c6F02569bdC59325F4f95463014d); //test wallet\r\n    address constant public adminsAddress = address(0x8008BD6FdDF2C26382B4c19d714A1BfeA317ec57); //test wallet\r\n    \r\n    //Percent for promo expences\r\n    Percent.percent private m_adminsPercent = Percent.percent(3, 100);       //   3/100  *100% = 3%\r\n    Percent.percent private m_advertisingPercent = Percent.percent(5, 100);// 5/100  *100% = 5%\r\n    //How many percent for your deposit to be multiplied\r\n    Percent.percent public MULTIPLIER = Percent.percent(120, 100); // 120/100 * 100% = 120%\r\n    \r\n    //flag for end migration deposits from oldContract\r\n    bool public migrationFinished = false; \r\n    \r\n    uint public amountRaised = 0;\r\n    uint public advertAmountRaised = 0; //for advertising all\r\n    //The deposit structure holds all the info about the deposit made\r\n    struct Deposit {\r\n        address depositor; //The depositor address\r\n        uint deposit;   //The deposit amount\r\n        uint expects;    //How much we should pay out (initially it is 120% of deposit)\r\n        uint paymentTime; //when payment\r\n    }\r\n\r\n    Deposit[] private ImportedQueue;  //The queue for imported investments\r\n    Deposit[] private Queue;  //The queue for new investments\r\n    // list of deposites for 1 user\r\n    mapping(address => uint[]) public depositors;\r\n    \r\n    uint public depositorsCount = 0;\r\n    \r\n    uint public currentImportedReceiverIndex = 0; //The index of the first depositor in OldQueue. The receiver of investments!\r\n    uint public currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!\r\n    \r\n    uint public minBalanceForDistribution = 24 ether; //первый минимально необходимый баланс должен быть достаточным для выплаты по 12 ETH из каждой очереди\r\n\r\n    // more events for easy read from blockchain\r\n    event LogNewInvesment(address indexed addr, uint when, uint investment, uint value);\r\n    event LogImportInvestorsPartComplete(uint when, uint howmuch, uint lastIndex);\r\n    event LogNewInvestor(address indexed addr, uint when);\r\n\r\n    constructor() public {\r\n    }\r\n\r\n    //создаем депозит инвестора в основной очереди\r\n    function () public payable {\r\n        if(msg.value > 0){\r\n            require(msg.value >= 0.01 ether, \"investment must be >= 0.01 ether\"); //ограничение минимального депозита\r\n            require(msg.value <= 10 ether, \"investment must be <= 10 ether\"); //ограничение максимального депозита\r\n\r\n            //к выплате 120% от депозита\r\n            uint expect = MULTIPLIER.mul(msg.value);\r\n            Queue.push(Deposit({depositor:msg.sender, deposit:msg.value, expects:expect, paymentTime:0}));\r\n            amountRaised += msg.value;\r\n            if (depositors[msg.sender].length == 0) depositorsCount += 1;\r\n            depositors[msg.sender].push(Queue.length - 1);\r\n            \r\n            uint advertperc = m_advertisingPercent.mul(msg.value);\r\n            advertisingAddress.send(advertperc);\r\n            adminsAddress.send(m_adminsPercent.mul(msg.value));\r\n            advertAmountRaised += advertperc;\r\n        } \r\n    }\r\n\r\n    //выплаты инвесторам\r\n    //в каждой транзакции выплачивается не менее 1 депозита из каждой очереди, но не более 100 выплат из каждой очереди.\r\n    function distribute(uint maxIterations) public {\r\n        require(maxIterations <= 100, \"no more than 100 iterations\"); //ограничение в 100 итераций максимум\r\n        uint money = address(this).balance;\r\n        require(money >= minBalanceForDistribution, \"Not enough funds to pay\");//на балансе недостаточно денег для выплат\r\n        uint ImportedQueueLen = ImportedQueue.length;\r\n        uint QueueLen = Queue.length;\r\n        uint toSend = 0;\r\n        maxIterations = maxIterations.max(5);//минимум 5 итераций\r\n        \r\n        for (uint i = 0; i < maxIterations; i++) {\r\n            if (currentImportedReceiverIndex < ImportedQueueLen){\r\n                toSend = ImportedQueue[currentImportedReceiverIndex].expects;\r\n                if (money >= toSend){\r\n                    money = money.sub(toSend);\r\n                    ImportedQueue[currentImportedReceiverIndex].paymentTime = now;\r\n                    ImportedQueue[currentImportedReceiverIndex].depositor.send(toSend);\r\n                    currentImportedReceiverIndex += 1;\r\n                }\r\n            }\r\n            if (currentReceiverIndex < QueueLen){\r\n                toSend = Queue[currentReceiverIndex].expects;\r\n                if (money >= toSend){\r\n                    money = money.sub(toSend);\r\n                    Queue[currentReceiverIndex].paymentTime = now;\r\n                    Queue[currentReceiverIndex].depositor.send(toSend);\r\n                    currentReceiverIndex += 1;\r\n                }\r\n            }\r\n        }\r\n        setMinBalanceForDistribution();\r\n    }\r\n    //пересчитываем минимально необходимый баланс для выплат по одному депозиту из каждой очереди.\r\n    function setMinBalanceForDistribution() private {\r\n        uint importedExpects = 0;\r\n        \r\n        if (currentImportedReceiverIndex < ImportedQueue.length) {\r\n            importedExpects = ImportedQueue[currentImportedReceiverIndex].expects;\r\n        } \r\n        \r\n        if (currentReceiverIndex < Queue.length) {\r\n            minBalanceForDistribution = Queue[currentReceiverIndex].expects;\r\n        } else {\r\n            minBalanceForDistribution = 12 ether; //максимально возможная выплата основной очереди\r\n        }\r\n        \r\n        if (importedExpects > 0){\r\n            minBalanceForDistribution = minBalanceForDistribution.add(importedExpects);\r\n        }\r\n    }\r\n    \r\n    //перенос очереди из проекта MMM3.0Reload\r\n    function FromMMM30Reload(address _ImportContract, uint _from, uint _to) public onlyOwner {\r\n        require(!migrationFinished);\r\n        distribution ImportContract = distribution(_ImportContract);\r\n        \r\n        address depositor;\r\n        uint amount;\r\n        uint depositeTime;\r\n        uint paymentTime;\r\n        uint c = 0;\r\n        uint maxLen = ImportContract.getLastDepositId();\r\n        _to = _to.min(maxLen);\r\n        \r\n        for (uint i = _from; i <= _to; i++) {\r\n                (depositor, amount, depositeTime, paymentTime) = ImportContract.getDeposit(i);\r\n                //кошельки администрации проекта MMM3.0Reload исключаем из переноса\r\n                if ((depositor != address(0x494A7A2D0599f2447487D7fA10BaEAfCB301c41B)) && \r\n                    (depositor != address(0xFd3093a4A3bd68b46dB42B7E59e2d88c6D58A99E)) && \r\n                    (depositor != address(0xBaa2CB97B6e28ef5c0A7b957398edf7Ab5F01A1B)) && \r\n                    (depositor != address(0xFDd46866C279C90f463a08518e151bC78A1a5f38)) && \r\n                    (depositor != address(0xdFa5662B5495E34C2aA8f06Feb358A6D90A6d62e))) {\r\n                    ImportedQueue.push(Deposit({depositor:depositor, deposit:uint(amount), expects:uint(MULTIPLIER.mul(amount)), paymentTime:0}));\r\n                    depositors[depositor].push(ImportedQueue.length - 1);\r\n                    c++;\r\n                }\r\n        }\r\n        emit LogImportInvestorsPartComplete(now, c, _to);\r\n    }\r\n\r\n    //после окончания переноса очереди - отказ от владения контрактом\r\n    function finishMigration() public onlyOwner {\r\n        migrationFinished = true;\r\n        renounceOwnership();\r\n    }\r\n\r\n    //баланс контракта\r\n    function getBalance() public view returns (uint) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    //баланс кошелька рекламного бюджета\r\n    function getAdvertisingBalance() public view returns (uint) {\r\n        return advertisingAddress.balance;\r\n    }\r\n    \r\n    //Количество невыплаченных депозитов в основной очереди\r\n    function getDepositsCount() public view returns (uint) {\r\n        return Queue.length.sub(currentReceiverIndex);\r\n    }\r\n    \r\n    //Количество невыплаченных депозитов в перенесенной очереди\r\n    function getImportedDepositsCount() public view returns (uint) {\r\n        return ImportedQueue.length.sub(currentImportedReceiverIndex);\r\n    }\r\n    \r\n    //данные о депозите основной очереди по порядковому номеру \r\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect, uint paymentTime){\r\n        Deposit storage dep = Queue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expects, dep.paymentTime);\r\n    }\r\n    \r\n    //данные о депозите перенесенной очереди по порядковому номеру \r\n    function getImportedDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect, uint paymentTime){\r\n        Deposit storage dep = ImportedQueue[idx];\r\n        return (dep.depositor, dep.deposit, dep.expects, dep.paymentTime);\r\n    }\r\n    \r\n    //Последний выплаченный депозит основной очереди, lastIndex - смещение номера в очереди (0 - последняя выплата, 1 - предпоследняя выплата)\r\n    function getLastPayments(uint lastIndex) public view returns (address, uint, uint) {\r\n        uint depositeIndex = currentReceiverIndex.sub(lastIndex).sub(1);\r\n        return (Queue[depositeIndex].depositor, Queue[depositeIndex].paymentTime, Queue[depositeIndex].expects);\r\n    }\r\n\r\n    //Последний выплаченный депозит перенесенной очереди, lastIndex - смещение номера в очереди (0 - последняя выплата, 1 - предпоследняя выплата)\r\n    function getLastImportedPayments(uint lastIndex) public view returns (address, uint, uint) {\r\n        uint depositeIndex = currentImportedReceiverIndex.sub(lastIndex).sub(1);\r\n        return (ImportedQueue[depositeIndex].depositor, ImportedQueue[depositeIndex].paymentTime, ImportedQueue[depositeIndex].expects);\r\n    }\r\n\r\n    //общее количество депозитов в основной очереди у кошелька depositor\r\n    function getUserDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=0; i<Queue.length; ++i){\r\n            if(Queue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n    \r\n    //общее количество депозитов в перенесенной очереди у кошелька depositor\r\n    function getImportedUserDepositsCount(address depositor) public view returns (uint) {\r\n        uint c = 0;\r\n        for(uint i=0; i<ImportedQueue.length; ++i){\r\n            if(ImportedQueue[i].depositor == depositor)\r\n                c++;\r\n        }\r\n        return c;\r\n    }\r\n\r\n    //Все депозиты основной очереди кошелька depositor в виде массива\r\n    function getUserDeposits(address depositor) public view returns (uint[] idxs, uint[] paymentTime, uint[] amount, uint[] expects) {\r\n        uint c = getUserDepositsCount(depositor);\r\n\r\n        idxs = new uint[](c);\r\n        paymentTime = new uint[](c);\r\n        expects = new uint[](c);\r\n        amount = new uint[](c);\r\n        uint num = 0;\r\n\r\n        if(c > 0) {\r\n            uint j = 0;\r\n            for(uint i=0; i<c; ++i){\r\n                num = depositors[depositor][i];\r\n                Deposit storage dep = Queue[num];\r\n                idxs[j] = i;\r\n                paymentTime[j] = dep.paymentTime;\r\n                amount[j] = dep.deposit;\r\n                expects[j] = dep.expects;\r\n                j++;\r\n            }\r\n        }\r\n    }\r\n    \r\n    //Все депозиты перенесенной очереди кошелька depositor в виде массива\r\n    function getImportedUserDeposits(address depositor) public view returns (uint[] idxs, uint[] paymentTime, uint[] amount, uint[] expects) {\r\n        uint c = getImportedUserDepositsCount(depositor);\r\n\r\n        idxs = new uint[](c);\r\n        paymentTime = new uint[](c);\r\n        expects = new uint[](c);\r\n        amount = new uint[](c);\r\n\r\n        if(c > 0) {\r\n            uint j = 0;\r\n            for(uint i=0; i<ImportedQueue.length; ++i){\r\n                Deposit storage dep = ImportedQueue[i];\r\n                if(dep.depositor == depositor){\r\n                    idxs[j] = i;\r\n                    paymentTime[j] = dep.paymentTime;\r\n                    amount[j] = dep.deposit;\r\n                    expects[j] = dep.expects;\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"name\":\"num\",\"type\":\"uint256\"},{\"name\":\"den\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertisingAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minBalanceForDistribution\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getUserDeposits\",\"outputs\":[{\"name\":\"idxs\",\"type\":\"uint256[]\"},{\"name\":\"paymentTime\",\"type\":\"uint256[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"expects\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentImportedReceiverIndex\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"depositorsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"migrationFinished\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"depositors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"adminsAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_ImportContract\",\"type\":\"address\"},{\"name\":\"_from\",\"type\":\"uint256\"},{\"name\":\"_to\",\"type\":\"uint256\"}],\"name\":\"FromMMM30Reload\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getImportedDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getImportedUserDeposits\",\"outputs\":[{\"name\":\"idxs\",\"type\":\"uint256[]\"},{\"name\":\"paymentTime\",\"type\":\"uint256[]\"},{\"name\":\"amount\",\"type\":\"uint256[]\"},{\"name\":\"expects\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finishMigration\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lastIndex\",\"type\":\"uint256\"}],\"name\":\"getLastImportedPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"maxIterations\",\"type\":\"uint256\"}],\"name\":\"distribute\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"advertAmountRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"idx\",\"type\":\"uint256\"}],\"name\":\"getDeposit\",\"outputs\":[{\"name\":\"depositor\",\"type\":\"address\"},{\"name\":\"deposit\",\"type\":\"uint256\"},{\"name\":\"expect\",\"type\":\"uint256\"},{\"name\":\"paymentTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getUserDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"lastIndex\",\"type\":\"uint256\"}],\"name\":\"getLastPayments\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAdvertisingBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"depositor\",\"type\":\"address\"}],\"name\":\"getImportedUserDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getImportedDepositsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"investment\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogNewInvesment\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"howmuch\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"lastIndex\",\"type\":\"uint256\"}],\"name\":\"LogImportInvestorsPartComplete\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"addr\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"when\",\"type\":\"uint256\"}],\"name\":\"LogNewInvestor\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FromResponsibleInvestors","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e2b201962e6bcdea88e7f7122b1c1cb12e0cc6317d8fea8db896b7aee9e14a9c"}]}