{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.5.2;\r\n\r\ninterface ERC223Handler { \r\n    function tokenFallback(address _from, uint _value, bytes calldata _data) external;\r\n}\r\n\r\ninterface ICOStickers {\r\n    function giveSticker(address _to, uint256 _property) external;\r\n}\r\n\r\n\r\ncontract ICOToken{\r\n    using SafeMath for uint256;\r\n    using SafeMath for uint;\r\n    \r\n\tmodifier onlyOwner {\r\n\t\trequire(msg.sender == owner);\r\n\t\t_;\r\n\t}\r\n    \r\n    constructor(address _s) public{\r\n        stickers = ICOStickers(_s);\r\n        totalSupply = 0;\r\n        owner = msg.sender;\r\n    }\r\n\taddress owner;\r\n\taddress newOwner;\r\n    \r\n    uint256 constant internal MAX_UINT256 = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;\r\n    uint256 constant internal TOKEN_PRICE = 0.0001 ether;\r\n    uint256 constant public fundingCap = 2000 ether;\r\n\r\n    uint256 constant public IcoStartTime = 1546628400; // Jan 04 2019 20:00:00 GMT+0100\r\n    uint256 constant public IcoEndTime = 1550084400; // Feb 13 2019 20:00:00 GMT+0100\r\n\r\n\r\n    ICOStickers internal stickers;\r\n    mapping(address => uint256) internal beneficiaryWithdrawAmount;\r\n    mapping(address => uint256) public beneficiaryShares;\r\n    uint256 public beneficiaryTotalShares;\r\n    uint256 public beneficiaryPayoutPerShare;\r\n    uint256 public icoFunding;\r\n    \r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => uint256) public etherSpent;\r\n    mapping(address => mapping (address => uint256)) internal allowances;\r\n    string constant public name = \"0xchan ICO\";\r\n    string constant public symbol = \"ZCI\";\r\n    uint8 constant public decimals = 18;\r\n    uint256 public totalSupply;\r\n    \r\n    // --Events\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value, bytes indexed data);\r\n    \r\n    event onICOBuy(address indexed from, uint256 tokens, uint256 bonusTokens);\r\n    // --Events--\r\n    \r\n    // --Owner only functions\r\n    function setNewOwner(address o) public onlyOwner {\r\n\t\tnewOwner = o;\r\n\t}\r\n\r\n\tfunction acceptNewOwner() public {\r\n\t\trequire(msg.sender == newOwner);\r\n\t\towner = msg.sender;\r\n\t}\r\n\t\r\n    // For the 0xchan ICO, the following beneficieries will be added.\r\n    // 3 - Aritz\r\n    // 3 - Sumpunk\r\n    // 2 - Multisig wallet for bounties/audit payments\r\n\tfunction addBeneficiary(address b, uint256 shares) public onlyOwner {\r\n\t   require(block.timestamp < IcoStartTime, \"ICO has started\");\r\n\t   require(beneficiaryWithdrawAmount[b] == 0, \"Already a beneficiary\");\r\n\t   beneficiaryWithdrawAmount[b] = MAX_UINT256;\r\n\t   beneficiaryShares[b] = shares;\r\n\t   beneficiaryTotalShares += shares;\r\n\t}\r\n\t\r\n\tfunction removeBeneficiary(address b, uint256 shares) public onlyOwner {\r\n\t   require(block.timestamp < IcoStartTime, \"ICO has started\");\r\n\t   require(beneficiaryWithdrawAmount[b] != 0, \"Not a beneficiary\");\r\n\t   delete beneficiaryWithdrawAmount[b];\r\n\t   delete beneficiaryShares[b];\r\n\t   beneficiaryTotalShares -= shares;\r\n\t}\r\n\t\r\n\t// --Owner only functions--\r\n    \r\n    // --Public write functions\r\n    function withdrawFunding(uint256 _amount) public {\r\n        if (icoFunding == 0){\r\n            require(address(this).balance >= fundingCap || block.timestamp >= IcoEndTime, \"ICO hasn't ended\");\r\n            icoFunding = address(this).balance;\r\n        }\r\n        require(beneficiaryWithdrawAmount[msg.sender] > 0, \"You're not a beneficiary\");\r\n        uint256 stash = beneficiaryStash(msg.sender);\r\n        if (_amount >= stash){\r\n            beneficiaryWithdrawAmount[msg.sender] = beneficiaryPayoutPerShare * beneficiaryShares[msg.sender];\r\n            msg.sender.transfer(stash);\r\n        }else{\r\n            if (beneficiaryWithdrawAmount[msg.sender] == MAX_UINT256){\r\n                beneficiaryWithdrawAmount[msg.sender] = _amount;\r\n            }else{\r\n                beneficiaryWithdrawAmount[msg.sender] += _amount;\r\n            }\r\n            msg.sender.transfer(_amount);\r\n        }\r\n    }\r\n    \r\n    function() payable external{\r\n        require(block.timestamp >= IcoStartTime, \"ICO hasn't started yet\");\r\n        require(icoFunding == 0 && block.timestamp < IcoEndTime, \"ICO has ended\");\r\n        require(msg.value != 0 && ((msg.value % TOKEN_PRICE) == 0), \"Must be a multiple of 0.0001 ETH\");\r\n        \r\n        uint256 thisBalance = address(this).balance; \r\n        uint256 msgValue = msg.value;\r\n        \r\n        // While the extra ETH is appriciated, we set ourselves a hardcap and we're gonna stick to it!\r\n        if (thisBalance > fundingCap){\r\n            msgValue -= (thisBalance - fundingCap);\r\n            require(msgValue != 0, \"Funding cap has been reached\");\r\n            thisBalance = fundingCap;\r\n        }\r\n        \r\n        uint256 oldBalance = thisBalance - msgValue;\r\n        uint256 tokensToGive = (msgValue / TOKEN_PRICE) * 1e18;\r\n        uint256 bonusTokens;\r\n        \r\n        uint256 difference;\r\n        \r\n        while (oldBalance < thisBalance){\r\n            if (oldBalance < 500 ether){\r\n                difference = min(500 ether, thisBalance) - oldBalance;\r\n                bonusTokens += ((difference / TOKEN_PRICE) * 1e18) / 2;\r\n                oldBalance += difference;\r\n            }else if(oldBalance < 1250 ether){\r\n                difference = min(1250 ether, thisBalance) - oldBalance;\r\n                bonusTokens += ((difference / TOKEN_PRICE) * 1e18) / 5;\r\n                oldBalance += difference;\r\n            }else{\r\n                difference = thisBalance - oldBalance;\r\n                bonusTokens += ((difference / TOKEN_PRICE) * 1e18) / 10;\r\n                oldBalance += difference;\r\n            }\r\n        }\r\n        emit onICOBuy(msg.sender, tokensToGive, bonusTokens);\r\n        \r\n        tokensToGive += bonusTokens;\r\n        balanceOf[msg.sender] += tokensToGive;\r\n        totalSupply += tokensToGive;\r\n        \r\n        if (address(stickers) != address(0)){\r\n            stickers.giveSticker(msg.sender, msgValue);\r\n        }\r\n        emit Transfer(address(this), msg.sender, tokensToGive, \"\");\r\n        emit Transfer(address(this), msg.sender, tokensToGive);\r\n        \r\n        beneficiaryPayoutPerShare = thisBalance / beneficiaryTotalShares;\r\n        etherSpent[msg.sender] += msgValue;\r\n        if (msgValue != msg.value){\r\n            // Finally return any extra ETH sent.\r\n            msg.sender.transfer(msg.value - msgValue); \r\n        }\r\n    }\r\n    \r\n    function transfer(address _to, uint _value, bytes memory _data, string memory _function) public returns(bool ok){\r\n        actualTransfer(msg.sender, _to, _value, _data, _function, true);\r\n        return true;\r\n    }\r\n    \r\n    function transfer(address _to, uint _value, bytes memory _data) public returns(bool ok){\r\n        actualTransfer(msg.sender, _to, _value, _data, \"\", true);\r\n        return true;\r\n    }\r\n    function transfer(address _to, uint _value) public returns(bool ok){\r\n        actualTransfer(msg.sender, _to, _value, \"\", \"\", true);\r\n        return true;\r\n    }\r\n    \r\n    function approve(address _spender, uint _value) public returns (bool success) {\r\n        allowances[msg.sender][_spender] = _value;\r\n        emit Approval(msg.sender, _spender, _value);\r\n        return true;\r\n    }\r\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\r\n        uint256 _allowance = allowances[_from][msg.sender];\r\n        require(_allowance > 0, \"Not approved\");\r\n        require(_allowance >= _value, \"Over spending limit\");\r\n        allowances[_from][msg.sender] = _allowance.sub(_value);\r\n        actualTransfer(_from, _to, _value, \"\", \"\", false);\r\n        return true;\r\n    }\r\n    \r\n    // --Public write functions--\r\n     \r\n    // --Public read-only functions\r\n    function beneficiaryStash(address b) public view returns (uint256){\r\n        uint256 withdrawAmount = beneficiaryWithdrawAmount[b];\r\n        if (withdrawAmount == 0){\r\n            return 0;\r\n        }\r\n        if (withdrawAmount == MAX_UINT256){\r\n            return beneficiaryPayoutPerShare * beneficiaryShares[b];\r\n        }\r\n        return (beneficiaryPayoutPerShare * beneficiaryShares[b]) - withdrawAmount;\r\n    }\r\n    \r\n    function allowance(address _sugardaddy, address _spender) public view returns (uint remaining) {\r\n        return allowances[_sugardaddy][_spender];\r\n    }\r\n    \r\n    // --Public read-only functions--\r\n    \r\n    \r\n    \r\n    // Internal functions\r\n    \r\n    function actualTransfer (address _from, address _to, uint _value, bytes memory _data, string memory _function, bool _careAboutHumanity) private {\r\n        // You can only transfer this token after the ICO has ended.\r\n        require(icoFunding != 0 || address(this).balance >= fundingCap || block.timestamp >= IcoEndTime, \"ICO hasn't ended\");\r\n        require(balanceOf[_from] >= _value, \"Insufficient balance\");\r\n        require(_to != address(this), \"You can't sell back your tokens\");\r\n        \r\n        // Throwing an exception undos all changes. Otherwise changing the balance now would be a shitshow\r\n        balanceOf[_from] = balanceOf[_from].sub(_value);\r\n        balanceOf[_to] = balanceOf[_to].add(_value);\r\n        \r\n        if(_careAboutHumanity && isContract(_to)) {\r\n            if (bytes(_function).length == 0){\r\n                ERC223Handler receiver = ERC223Handler(_to);\r\n                receiver.tokenFallback(_from, _value, _data);\r\n            }else{\r\n                bool success;\r\n                bytes memory returnData;\r\n                (success, returnData) = _to.call.value(0)(abi.encodeWithSignature(_function, _from, _value, _data));\r\n                assert(success);\r\n            }\r\n        }\r\n        emit Transfer(_from, _to, _value, _data);\r\n        emit Transfer(_from, _to, _value);\r\n    }\r\n    \r\n    //assemble the given address bytecode. If bytecode exists then the _addr is a contract.\r\n    function isContract(address _addr) private view returns (bool is_contract) {\r\n        uint length;\r\n        assembly {\r\n            //retrieve the size of the code on target address, this needs assembly\r\n            length := extcodesize(_addr)\r\n        }\r\n        return (length>0);\r\n    }\r\n    \r\n    function min(uint256 i1, uint256 i2) private pure returns (uint256) {\r\n        if (i1 < i2){\r\n            return i1;\r\n        }\r\n        return i2;\r\n    }\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0 || b == 0) {\r\n           return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n    \r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiaryPayoutPerShare\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"withdrawFunding\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"etherSpent\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"b\",\"type\":\"address\"}],\"name\":\"beneficiaryStash\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"b\",\"type\":\"address\"},{\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"removeBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"b\",\"type\":\"address\"},{\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"addBeneficiary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoFunding\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IcoEndTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaryShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_sugardaddy\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"remaining\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"beneficiaryTotalShares\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fundingCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"IcoStartTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"o\",\"type\":\"address\"}],\"name\":\"setNewOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_data\",\"type\":\"bytes\"},{\"name\":\"_function\",\"type\":\"string\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"ok\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_s\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"tokenOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"bonusTokens\",\"type\":\"uint256\"}],\"name\":\"onICOBuy\",\"type\":\"event\"}]","ContractName":"ICOToken","CompilerVersion":"v0.5.2+commit.1df8f40c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000007ea3243fda451d34fd1127add91a8e9a73168ff9","Library":"","SwarmSource":"bzzr://c764b85cb4f8aaadac100943d3aefdee4864b76aaeef96ff6713832741165e84"}]}