{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// ----------------------------------------------------------------------------\r\n// ExchangeArbitrage token contract\r\n//\r\n// Symbol      : EXARB\r\n// Name        : Exchange Arbitrage Token\r\n// Decimals    : 18\r\n//\r\n// ----------------------------------------------------------------------------\r\n\r\n\r\nlibrary SafeMath {\r\n    function add(uint a, uint b) internal pure returns (uint c) {\r\n        c = a + b;\r\n        require(c >= a);\r\n    }\r\n    function sub(uint a, uint b) internal pure returns (uint c) {\r\n        require(b <= a);\r\n        c = a - b;\r\n    }\r\n    function mul(uint a, uint b) internal pure returns (uint c) {\r\n        c = a * b;\r\n        require(a == 0 || c / a == b);\r\n    }\r\n    function div(uint a, uint b) internal pure returns (uint c) {\r\n        require(b > 0);\r\n        c = a / b;\r\n    }\r\n}\r\n\r\ncontract Owned {\r\n    address public owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ExchangeArbitrageToken is Owned {\r\n    using SafeMath for uint;\r\n\r\n    string public symbol = \"EXARB\";\r\n    string public  name = \"Exchange Arbitrage Token\";\r\n    uint8 public decimals = 18;\r\n\r\n    uint minted_tokens;\r\n    uint max_investors;\r\n    uint minimum_wei;\r\n    uint exchange_rate;\r\n    uint total_investors;\r\n    uint cashout_rate;\r\n    uint launch_date;\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event MintTokens(address from, uint coin, uint amount);\r\n\r\n    event ExchangeRateSet(uint exchange_rate);\r\n    event CashoutRateSet(uint exchange_rate);\r\n    event MaxInvestorsSet(uint max_investors);\r\n    event MinimumInvestmentWEISet(uint minimum_wei);\r\n    event LaunchDateSet(uint launch_date);\r\n\r\n    // historical tracking of balances at a particular block\r\n    mapping(address => BlockBalance[]) block_balances;\r\n    struct BlockBalance {\r\n        uint block_id;\r\n        uint balance;\r\n    }\r\n\r\n    // keep track of which token owners picked up their payout amounts\r\n    // ( token_owner => ( payout_id => paid_out_amount ) )\r\n    mapping(address => mapping(uint16 => uint)) collected_payouts;\r\n\r\n    // basic array that has all of the payout ids\r\n    uint16[] payout_ids;\r\n\r\n    // mapping that has the payout details.\r\n    mapping(uint16 => PayoutBlock) payouts;\r\n    struct PayoutBlock {\r\n        uint block_id;\r\n        uint amount;\r\n        uint minted_tokens;\r\n    }\r\n\r\n    constructor() public payable {\r\n        minted_tokens = 0;\r\n        minimum_wei = 200000000000000000;\r\n        max_investors = 2500;\r\n        exchange_rate = 230; // Roughly USD\r\n        cashout_rate = 50000000000000;\r\n        total_investors = 0;\r\n        launch_date = 1539604800;\r\n        emit MinimumInvestmentWEISet(minimum_wei);\r\n        emit MaxInvestorsSet(max_investors);\r\n        emit ExchangeRateSet(exchange_rate);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint) {\r\n        return minted_tokens;\r\n    }\r\n\r\n    function balanceOf(address tokenOwner) public view returns (uint balance) {\r\n        return getTokenBalanceOf(tokenOwner);\r\n    }\r\n\r\n    function ownershipPercentageOf(address tokenOwner) public view returns (uint percentage_8_decimals) {\r\n        return balanceOf(tokenOwner).mul(10000000000).div(minted_tokens);\r\n    }\r\n\r\n    function totalInvestors() public view returns (uint) {\r\n        return total_investors;\r\n    }\r\n\r\n    function allPayoutIds() public view returns (uint16[]) {\r\n        return payout_ids;\r\n    }\r\n\r\n    function getPayoutAmountForId(uint16 payout_id) public view returns (uint) {\r\n        return payouts[payout_id].amount;\r\n    }\r\n\r\n    function getPayoutBlockForId(uint16 payout_id) public view returns (uint) {\r\n        return payouts[payout_id].block_id;\r\n    }\r\n\r\n    function ethToTokenExchangeRate() public view returns (uint) {\r\n        return exchange_rate;\r\n    }\r\n\r\n    function limitMaxInvestors() public view returns (uint) {\r\n        return max_investors;\r\n    }\r\n\r\n    function limitMinimumInvestmentWEI() public view returns (uint) {\r\n        return minimum_wei;\r\n    }\r\n\r\n    function limitCashoutRate() public view returns (uint) {\r\n        return cashout_rate;\r\n    }\r\n\r\n    function launchDate() public view returns (uint) {\r\n        return launch_date;\r\n    }\r\n\r\n    function payoutAmountFor(uint16 payout_id) public view returns (uint) {\r\n        require(payouts[payout_id].block_id > 0, \"Invalid payout_id\");\r\n        require(block_balances[msg.sender].length > 0, \"This address has no history on this contract.\");\r\n\r\n        PayoutBlock storage payout_block = payouts[payout_id];\r\n        BlockBalance memory relevant_block;\r\n        for(uint i = 0; i < block_balances[msg.sender].length; i++) {\r\n            if (block_balances[msg.sender][i].block_id < payout_block.block_id  ) {\r\n                relevant_block = block_balances[msg.sender][i];\r\n            }\r\n        }\r\n        return relevant_block.balance.mul(payout_block.amount).div(payout_block.minted_tokens);\r\n    }\r\n\r\n    function payoutCollected(uint16 payout_id) public view returns (bool) {\r\n        return collected_payouts[msg.sender][payout_id] > 0;\r\n    }\r\n\r\n    function payoutCollect(uint16 payout_id) public returns (bool success) {\r\n        require(collected_payouts[msg.sender][payout_id] == 0, \"Payment already collected\");\r\n        uint payout = payoutAmountFor(payout_id);\r\n        require(address(this).balance >= payout, \"Balance is too low.\");\r\n        collected_payouts[msg.sender][payout_id] = payout;\r\n        msg.sender.transfer(payout);\r\n        return true;\r\n    }\r\n\r\n    function calculateCashout() public view returns (uint amount) {\r\n        uint current_token_balance = getTokenBalanceOf(msg.sender);\r\n        uint payout = current_token_balance.mul(cashout_rate).div(1000000000000000000);\r\n        return payout;\r\n    }\r\n\r\n    function cashout() public returns (bool success) {\r\n        uint current_token_balance = getTokenBalanceOf(msg.sender);\r\n        require(current_token_balance > 0, 'Address has no balance');\r\n        uint payout = current_token_balance.mul(cashout_rate).div(1000000000000000000);\r\n        subtractTokenBalanceFrom(msg.sender, current_token_balance);\r\n        minted_tokens = minted_tokens.sub(current_token_balance);\r\n        total_investors--;\r\n        msg.sender.transfer(payout);\r\n        return true;\r\n    }\r\n\r\n    // Allow anyone to transfer to anyone else as long as they have enough balance.\r\n    function transfer(address to, uint tokens) public returns (bool success) {\r\n        require(tokens > 0, \"Transfer must be positive.\");\r\n        uint original_to_blance = balanceOf(to);\r\n        if (original_to_blance == 0) { total_investors++; }\r\n\r\n        subtractTokenBalanceFrom(msg.sender, tokens);\r\n        addTokenBalanceTo(to, tokens);\r\n\r\n        uint new_sender_balance = balanceOf(msg.sender);\r\n        if (new_sender_balance == 0) { total_investors--; }\r\n\r\n        emit Transfer(msg.sender, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function () public payable {\r\n        if (msg.sender != owner){\r\n            // only mint tokens if msg.value is greather than minimum investment\r\n            //   and we are past the launch date\r\n            if (msg.value >= minimum_wei && block.timestamp > launch_date){\r\n                require(total_investors < max_investors, \"Max Investors Hit\");\r\n                mint(msg.sender, msg.value);\r\n            }\r\n            if (!owner.send(msg.value)) { revert(); }\r\n        } else {\r\n            // owner send funds.  keep for payouts.\r\n            require(msg.value > 0);\r\n        }\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    //   private functions\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function mint(address sender, uint value) private {\r\n        uint current_balance = balanceOf(sender);\r\n        if (current_balance == 0) { total_investors++; }\r\n        uint tokens = value.mul(exchange_rate);\r\n        addTokenBalanceTo(sender, tokens);\r\n        minted_tokens = minted_tokens.add(tokens);\r\n        emit MintTokens(sender, value, tokens);\r\n    }\r\n\r\n    function getTokenBalanceOf(address tokenOwner) private view returns (uint tokens) {\r\n        uint owner_block_balance_length = block_balances[tokenOwner].length;\r\n        if (owner_block_balance_length == 0) {\r\n            return 0;\r\n        } else {\r\n            return block_balances[tokenOwner][owner_block_balance_length-1].balance;\r\n        }\r\n    }\r\n\r\n    function addTokenBalanceTo(address tokenOwner, uint value) private {\r\n        uint owner_block_balance_length = block_balances[tokenOwner].length;\r\n        if (owner_block_balance_length == 0) {\r\n            block_balances[tokenOwner].push(BlockBalance({ block_id: block.number, balance: value }));\r\n        } else {\r\n            BlockBalance storage owner_last_block_balance = block_balances[tokenOwner][owner_block_balance_length-1];\r\n\r\n            uint owner_current_balance = getTokenBalanceOf(tokenOwner);\r\n\r\n            // if we have never had any payouts or there has been no payout since the last time the user sent eth.\r\n            //   --> reuse the last location\r\n            // else --> create a new location\r\n            if (payout_ids.length == 0 || owner_last_block_balance.block_id > payouts[payout_ids[payout_ids.length-1]].block_id ) {\r\n                // overwrite last item in the array.\r\n                block_balances[tokenOwner][owner_block_balance_length-1] = BlockBalance({ block_id: block.number, balance: owner_current_balance.add(value) });\r\n            } else {\r\n                block_balances[tokenOwner].push(BlockBalance({ block_id: block.number, balance: owner_current_balance.add(value) }));\r\n            }\r\n        }\r\n    }\r\n\r\n    function subtractTokenBalanceFrom(address tokenOwner, uint value) private {\r\n        uint owner_block_balance_length = block_balances[tokenOwner].length;\r\n        if (owner_block_balance_length == 0) {\r\n            revert('Can not remove balance from an address with no history.');\r\n        } else {\r\n            BlockBalance storage owner_last_block_balance = block_balances[tokenOwner][owner_block_balance_length-1];\r\n\r\n            uint owner_current_balance = getTokenBalanceOf(tokenOwner);\r\n\r\n            // if we have never had any payouts or there has been no payout since the last time the user sent eth.\r\n            //   --> reuse the last location\r\n            // else --> create a new location\r\n            if (payout_ids.length == 0 || owner_last_block_balance.block_id > payouts[payout_ids[payout_ids.length-1]].block_id ) {\r\n                // overwrite last item in the array.\r\n                block_balances[tokenOwner][owner_block_balance_length-1] = BlockBalance({ block_id: block.number, balance: owner_current_balance.sub(value) });\r\n            } else {\r\n                block_balances[tokenOwner].push(BlockBalance({ block_id: block.number, balance: owner_current_balance.sub(value) }));\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    // ----------------------------------------------------------------------------\r\n    //   onlyOwner functions.\r\n    // ----------------------------------------------------------------------------\r\n\r\n    function payout(uint16 payout_id, uint amount) public onlyOwner returns (bool success) {\r\n        // make sure this payout ID hasn't already been used.\r\n        require(payouts[payout_id].block_id == 0);\r\n        payouts[payout_id] = PayoutBlock({ block_id: block.number, amount: amount, minted_tokens: minted_tokens });\r\n        payout_ids.push(payout_id);\r\n        return true;\r\n    }\r\n\r\n    // How many tokens per ether get sent to the user.  ~1 USD / token.\r\n    function setExchangeRate(uint newRate) public onlyOwner returns (bool success) {\r\n        exchange_rate = newRate;\r\n        emit ExchangeRateSet(newRate);\r\n        return true;\r\n    }\r\n\r\n    // How many tokens per ether get sent to the user.  ~1 USD / token.\r\n    function setCashoutRate(uint newRate) public onlyOwner returns (bool success) {\r\n        cashout_rate = newRate;\r\n        emit CashoutRateSet(newRate);\r\n        return true;\r\n    }\r\n\r\n    function setMaxInvestors(uint newMaxInvestors) public onlyOwner returns (bool success) {\r\n        max_investors = newMaxInvestors;\r\n        emit MaxInvestorsSet(max_investors);\r\n        return true;\r\n    }\r\n\r\n    function setMinimumInvesementWEI(uint newMinimumWEI) public onlyOwner returns (bool success) {\r\n        minimum_wei = newMinimumWEI;\r\n        emit MinimumInvestmentWEISet(minimum_wei);\r\n        return true;\r\n    }\r\n\r\n    function setLaunchDate(uint newLaunchDate) public onlyOwner returns (bool success){\r\n        launch_date = newLaunchDate;\r\n        emit LaunchDateSet(launch_date);\r\n        return true;\r\n    }\r\n\r\n    function ownerTransfer(address from, address to, uint tokens) public onlyOwner returns (bool success) {\r\n        require(tokens > 0, \"Transfer must be positive.\");\r\n        uint original_to_blance = balanceOf(to);\r\n        if (original_to_blance == 0) { total_investors++; }\r\n\r\n        subtractTokenBalanceFrom(from, tokens);\r\n        addTokenBalanceTo(to, tokens);\r\n\r\n        uint new_from_balance = balanceOf(from);\r\n        if (new_from_balance == 0) { total_investors--; }\r\n\r\n        emit Transfer(from, to, tokens);\r\n        return true;\r\n    }\r\n\r\n    function destroy() public onlyOwner {\r\n        selfdestruct(owner);\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMaxInvestors\",\"type\":\"uint256\"}],\"name\":\"setMaxInvestors\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"calculateCashout\",\"outputs\":[{\"name\":\"amount\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newMinimumWEI\",\"type\":\"uint256\"}],\"name\":\"setMinimumInvesementWEI\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"getPayoutAmountForId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitMinimumInvestmentWEI\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"balance\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitMaxInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setCashoutRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"tokenOwner\",\"type\":\"address\"}],\"name\":\"ownershipPercentageOf\",\"outputs\":[{\"name\":\"percentage_8_decimals\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"destroy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"cashout\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"payoutCollected\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"ownerTransfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"getPayoutBlockForId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLaunchDate\",\"type\":\"uint256\"}],\"name\":\"setLaunchDate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"allPayoutIds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"payoutCollect\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"payout\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newRate\",\"type\":\"uint256\"}],\"name\":\"setExchangeRate\",\"outputs\":[{\"name\":\"success\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"payout_id\",\"type\":\"uint16\"}],\"name\":\"payoutAmountFor\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"limitCashoutRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"launchDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethToTokenExchangeRate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokens\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"from\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"coin\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"MintTokens\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"exchange_rate\",\"type\":\"uint256\"}],\"name\":\"ExchangeRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"exchange_rate\",\"type\":\"uint256\"}],\"name\":\"CashoutRateSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"max_investors\",\"type\":\"uint256\"}],\"name\":\"MaxInvestorsSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"minimum_wei\",\"type\":\"uint256\"}],\"name\":\"MinimumInvestmentWEISet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"launch_date\",\"type\":\"uint256\"}],\"name\":\"LaunchDateSet\",\"type\":\"event\"}]","ContractName":"ExchangeArbitrageToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9103cd8bec58993b119b949b89f18fccf7ddd1150a597c25d4917db7e28d9418"}]}