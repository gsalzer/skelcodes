{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Owned {\r\n    \r\n    /// 'owner' is the only address that can call a function with \r\n    /// this modifier\r\n    address public owner;\r\n    address internal newOwner;\r\n    \r\n    ///@notice The constructor assigns the message sender to be 'owner'\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    event updateOwner(address _oldOwner, address _newOwner);\r\n    \r\n    ///change the owner\r\n    function changeOwner(address _newOwner) public onlyOwner returns(bool) {\r\n        require(owner != _newOwner);\r\n        newOwner = _newOwner;\r\n        return true;\r\n    }\r\n    \r\n    /// accept the ownership\r\n    function acceptNewOwner() public returns(bool) {\r\n        require(msg.sender == newOwner);\r\n        emit updateOwner(owner, newOwner);\r\n        owner = newOwner;\r\n        return true;\r\n    }\r\n}\r\n\r\ncontract SafeMath {\r\n    function safeMul(uint a, uint b) pure internal returns (uint) {\r\n        uint c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n    \r\n    function safeSub(uint a, uint b) pure internal returns (uint) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n    \r\n    function safeAdd(uint a, uint b) pure internal returns (uint) {\r\n        uint c = a + b;\r\n        assert(c>=a && c>=b);\r\n        return c;\r\n    }\r\n\r\n}\r\n\r\ncontract ERC20Token {\r\n    /* This is a slight change to the ERC20 base standard.\r\n    function totalSupply() constant returns (uint256 supply);\r\n    is replaced with:\r\n    uint256 public totalSupply;\r\n    This automatically creates a getter function for the totalSupply.\r\n    This is moved to the base contract since public getter functions are not\r\n    currently recognised as an implementation of the matching abstract\r\n    function by the compiler.\r\n    */\r\n    /// total amount of tokens\r\n    uint256 public totalSupply;\r\n    \r\n    /// user tokens\r\n    mapping (address => uint256) public balances;\r\n    \r\n    /// @param _owner The address from which the balance will be retrieved\r\n    /// @return The balance\r\n    function balanceOf(address _owner) constant public returns (uint256 balance);\r\n\r\n    /// @notice send `_value` token to `_to` from `msg.sender`\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transfer(address _to, uint256 _value) public returns (bool success);\r\n    \r\n    /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from`\r\n    /// @param _from The address of the sender\r\n    /// @param _to The address of the recipient\r\n    /// @param _value The amount of token to be transferred\r\n    /// @return Whether the transfer was successful or not\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success);\r\n\r\n    /// @notice `msg.sender` approves `_spender` to spend `_value` tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @param _value The amount of tokens to be approved for transfer\r\n    /// @return Whether the approval was successful or not\r\n    function approve(address _spender, uint256 _value) public returns (bool success);\r\n\r\n    /// @param _owner The address of the account owning tokens\r\n    /// @param _spender The address of the account able to transfer the tokens\r\n    /// @return Amount of remaining tokens allowed to spent\r\n    function allowance(address _owner, address _spender) constant public returns (uint256 remaining);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ncontract DateTime {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         */\r\n        struct _DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) internal pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function leapYearsBefore(uint year) internal pure returns (uint) {\r\n                year -= 1;\r\n                return year / 4 - year / 100 + year / 400;\r\n        }\r\n\r\n        function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) {\r\n                if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) {\r\n                        return 31;\r\n                }\r\n                else if (month == 4 || month == 6 || month == 9 || month == 11) {\r\n                        return 30;\r\n                }\r\n                else if (isLeapYear(year)) {\r\n                        return 29;\r\n                }\r\n                else {\r\n                        return 28;\r\n                }\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                // Year\r\n                dt.year = getYear(timestamp);\r\n                buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf);\r\n\r\n                // Month\r\n                uint secondsInMonth;\r\n                for (i = 1; i <= 12; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year);\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n        }\r\n\r\n        function getYear(uint timestamp) internal pure returns (uint16) {\r\n                uint secondsAccountedFor = 0;\r\n                uint16 year;\r\n                uint numLeapYears;\r\n\r\n                // Year\r\n                year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS);\r\n                numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR);\r\n\r\n                secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears;\r\n                secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears);\r\n\r\n                while (secondsAccountedFor > timestamp) {\r\n                        if (isLeapYear(uint16(year - 1))) {\r\n                                secondsAccountedFor -= LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                secondsAccountedFor -= YEAR_IN_SECONDS;\r\n                        }\r\n                        year -= 1;\r\n                }\r\n                return year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) internal pure returns (uint8) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n}\r\n\r\ncontract CUSEexerciseContract is Owned,SafeMath,DateTime {\r\n    \r\n    /// @dev name of CUSEexec contract\r\n    string public name = \"CUSE_Exercise_Option\";\r\n    /// @dev decimal of CUSE\r\n    uint256 decimals = 18;\r\n\r\n    /// @dev token holder\r\n    address public CUSEaddr          = 0x6081dEd2d0a57fC4b63765B182D8773E72327fE2;\r\n    address constant public USEaddr  = 0xd9485499499d66B175Cf5ED54c0a19f1a6Bcb61A;\r\n    address public tokenHolder       = 0x89Ead717c9DC15a222926221897c68F9486E7229;\r\n    address public officialAddress   = 0x41eFD65d4f101ff729D93e7a2b7F9e22f9033332;\r\n    \r\n    /// @dev exercise price of Each Month\r\n    \r\n    mapping (uint => mapping(uint => uint)) public eachExercisePrice;\r\n    \r\n    constructor (uint[] _year, uint[] _month, uint[] _exercisePrice) public {\r\n        require (_year.length == _month.length);\r\n        require (_month.length == _exercisePrice.length);\r\n        for (uint i=0; i<_month.length; i++) {\r\n            eachExercisePrice[_year[i]][_month[i]] = _exercisePrice[i];\r\n        }\r\n    }\r\n    \r\n    function () public payable {\r\n        address _user = msg.sender;\r\n        uint    _value = msg.value;\r\n        require(exerciseCUSE(_user, _value) == true);\r\n    }\r\n    \r\n    /// @dev internal function: exercise option of CUSE\r\n    function exerciseCUSE(address _user, uint _ether) internal returns (bool) {\r\n        /// @dev get CUSE price\r\n        uint _exercisePrice = getPrice();\r\n        \r\n        /// @dev get CUSE of msg.sender\r\n        \r\n        uint _CUSE = ERC20Token(CUSEaddr).balanceOf(_user);\r\n        // ETH user send\r\n        (uint _use, uint _refoundETH) = calcUSE(_CUSE, _ether, _exercisePrice);\r\n        \r\n        // do exercise\r\n        require (ERC20Token(CUSEaddr).transferFrom(_user, officialAddress, _use) == true);\r\n        require (ERC20Token(USEaddr).transferFrom(tokenHolder, _user, _use) == true);\r\n        \r\n        // refound ETH\r\n        needRefoundETH(_user, _refoundETH);\r\n        officialAddress.transfer(safeSub(_ether, _refoundETH));\r\n        return true;\r\n    }\r\n    \r\n    /// @dev get exercise price\r\n    function getPrice() internal view returns(uint) {\r\n        uint _year = getYear(now);\r\n        uint _month = getMonth(now);\r\n        return eachExercisePrice[_year][_month];\r\n    }\r\n    \r\n    /// @dev Calculate USE value\r\n    function calcUSE(uint _cuse, uint _ether, uint _exercisePrice) internal pure returns (uint _use, uint _refoundETH) {\r\n        uint _amount = _ether / _exercisePrice;\r\n        require (_amount > 0);\r\n        require (safeMul(_amount, _exercisePrice) <= _ether);\r\n        \r\n        // Check Whether msg.sender Have Enough CUSE\r\n        if (safeMul(_amount, 10**18) <= _cuse) {\r\n            _use = safeMul(_amount, 10**18);\r\n            _refoundETH = 0;\r\n        } else {\r\n            _use = _cuse;\r\n            _refoundETH = safeMul(safeSub(_amount, _use/(10**18)), _exercisePrice);\r\n        }\r\n    }\r\n    \r\n    function needRefoundETH(address _user, uint _refoundETH) internal {\r\n        if (_refoundETH > 0) {\r\n            _user.transfer(_refoundETH);\r\n        }\r\n    }\r\n    \r\n    /// @dev Change Exercise Price\r\n    function changeExerciseprice(uint[] _year, uint[] _month, uint[] _exercisePrice) public onlyOwner {\r\n        require (_year.length == _month.length);\r\n        require (_month.length == _exercisePrice.length);\r\n        for (uint i=0; i<_month.length; i++) {\r\n            eachExercisePrice[_year[i]][_month[i]] = _exercisePrice[i];\r\n        }\r\n    }\r\n    \r\n    function changeCUSEaddress(address _cuseAddr) public onlyOwner {\r\n        CUSEaddr = _cuseAddr;\r\n    }\r\n    \r\n    /// @dev Change token holder\r\n    function changeTokenHolder(address _tokenHolder) public onlyOwner {\r\n        tokenHolder = _tokenHolder;\r\n    }\r\n    \r\n    /// @dev Change Official Address If Necessary\r\n    function changeOfficialAddressIfNecessary(address _officialAddress) public onlyOwner {\r\n        officialAddress = _officialAddress;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"USEaddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_year\",\"type\":\"uint256[]\"},{\"name\":\"_month\",\"type\":\"uint256[]\"},{\"name\":\"_exercisePrice\",\"type\":\"uint256[]\"}],\"name\":\"changeExerciseprice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenHolder\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"CUSEaddr\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenHolder\",\"type\":\"address\"}],\"name\":\"changeTokenHolder\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_cuseAddr\",\"type\":\"address\"}],\"name\":\"changeCUSEaddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"eachExercisePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_officialAddress\",\"type\":\"address\"}],\"name\":\"changeOfficialAddressIfNecessary\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptNewOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"officialAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_year\",\"type\":\"uint256[]\"},{\"name\":\"_month\",\"type\":\"uint256[]\"},{\"name\":\"_exercisePrice\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_oldOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"updateOwner\",\"type\":\"event\"}]","ContractName":"CUSEexerciseContract","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000001600000000000000000000000000000000000000000000000000000000000000260000000000000000000000000000000000000000000000000000000000000000700000000000000000000000000000000000000000000000000000000000007e200000000000000000000000000000000000000000000000000000000000007e200000000000000000000000000000000000000000000000000000000000007e200000000000000000000000000000000000000000000000000000000000007e200000000000000000000000000000000000000000000000000000000000007e300000000000000000000000000000000000000000000000000000000000007e300000000000000000000000000000000000000000000000000000000000007e300000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000000000000009000000000000000000000000000000000000000000000000000000000000000a000000000000000000000000000000000000000000000000000000000000000b000000000000000000000000000000000000000000000000000000000000000c00000000000000000000000000000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000002000000000000000000000000000000000000000000000000000000000000000300000000000000000000000000000000000000000000000000000000000000070000000000000000000000000000000000000000000000000000065dd08370000000000000000000000000000000000000000000000000000000065dd0837000000000000000000000000000000000000000000000000000000009184e72a00000000000000000000000000000000000000000000000000000000c2054ba920000000000000000000000000000000000000000000000000000000cbba106e00000000000000000000000000000000000000000000000000000000cbba106e00000000000000000000000000000000000000000000000000000000cbba106e000","Library":"","SwarmSource":"bzzr://730cc2d89e5352b0e2acca93b303364c358366ac5419d7ccbabc9b72eb493123"}]}