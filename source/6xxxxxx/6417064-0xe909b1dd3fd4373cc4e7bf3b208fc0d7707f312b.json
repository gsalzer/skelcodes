{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n// File: contracts/interfaces/IOwned.sol\r\n\r\n/*\r\n    Owned Contract Interface\r\n*/\r\ncontract IOwned {\r\n    function transferOwnership(address _newOwner) public;\r\n    function acceptOwnership() public;\r\n    function transferOwnershipNow(address newContractOwner) public;\r\n}\r\n\r\n// File: contracts/utility/Owned.sol\r\n\r\n/*\r\n    This is the \"owned\" utility contract used by bancor with one additional function - transferOwnershipNow()\r\n    \r\n    The original unmodified version can be found here:\r\n    https://github.com/bancorprotocol/contracts/commit/63480ca28534830f184d3c4bf799c1f90d113846\r\n    \r\n    Provides support and utilities for contract ownership\r\n*/\r\ncontract Owned is IOwned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner);\r\n\r\n    /**\r\n        @dev constructor\r\n    */\r\n    constructor() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    // allows execution by the owner only\r\n    modifier ownerOnly {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    /**\r\n        @dev allows transferring the contract ownership\r\n        the new owner still needs to accept the transfer\r\n        can only be called by the contract owner\r\n        @param _newOwner    new contract owner\r\n    */\r\n    function transferOwnership(address _newOwner) public ownerOnly {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    /**\r\n        @dev used by a new owner to accept an ownership transfer\r\n    */\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = address(0);\r\n    }\r\n\r\n    /**\r\n        @dev transfers the contract ownership without needing the new owner to accept ownership\r\n        @param newContractOwner    new contract owner\r\n    */\r\n    function transferOwnershipNow(address newContractOwner) ownerOnly public {\r\n        require(newContractOwner != owner);\r\n        emit OwnerUpdate(owner, newContractOwner);\r\n        owner = newContractOwner;\r\n    }\r\n\r\n}\r\n\r\n// File: contracts/interfaces/ILogger.sol\r\n\r\n/*\r\n    Logger Contract Interface\r\n*/\r\n\r\ncontract ILogger {\r\n    function addNewLoggerPermission(address addressToPermission) public;\r\n    function emitTaskCreated(uint uuid, uint amount) public;\r\n    function emitProjectCreated(uint uuid, uint amount, address rewardAddress) public;\r\n    function emitNewSmartToken(address token) public;\r\n    function emitIssuance(uint256 amount) public;\r\n    function emitDestruction(uint256 amount) public;\r\n    function emitTransfer(address from, address to, uint256 value) public;\r\n    function emitApproval(address owner, address spender, uint256 value) public;\r\n    function emitGenericLog(string messageType, string message) public;\r\n}\r\n\r\n// File: contracts/Logger.sol\r\n\r\n/*\r\n\r\nCentralized logger allows backend to easily watch all events on all communities without needing to watch each community individually\r\n\r\n*/\r\ncontract Logger is Owned, ILogger  {\r\n\r\n    // Community\r\n    event TaskCreated(address msgSender, uint _uuid, uint _amount);\r\n    event ProjectCreated(address msgSender, uint _uuid, uint _amount, address _address);\r\n\r\n    // SmartToken\r\n    // triggered when a smart token is deployed - the _token address is defined for forward compatibility\r\n    //  in case we want to trigger the event from a factory\r\n    event NewSmartToken(address msgSender, address _token);\r\n    // triggered when the total supply is increased\r\n    event Issuance(address msgSender, uint256 _amount);\r\n    // triggered when the total supply is decreased\r\n    event Destruction(address msgSender, uint256 _amount);\r\n    // erc20\r\n    event Transfer(address msgSender, address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address msgSender, address indexed _owner, address indexed _spender, uint256 _value);\r\n\r\n    // Logger\r\n    event NewCommunityAddress(address msgSender, address _newAddress);\r\n\r\n    event GenericLog(address msgSender, string messageType, string message);\r\n    mapping (address => bool) public permissionedAddresses;\r\n\r\n    modifier hasLoggerPermissions(address _address) {\r\n        require(permissionedAddresses[_address] == true);\r\n        _;\r\n    }\r\n\r\n    function addNewLoggerPermission(address addressToPermission) ownerOnly public {\r\n        permissionedAddresses[addressToPermission] = true;\r\n    }\r\n\r\n    function emitTaskCreated(uint uuid, uint amount) public hasLoggerPermissions(msg.sender) {\r\n        emit TaskCreated(msg.sender, uuid, amount);\r\n    }\r\n\r\n    function emitProjectCreated(uint uuid, uint amount, address rewardAddress) public hasLoggerPermissions(msg.sender) {\r\n        emit ProjectCreated(msg.sender, uuid, amount, rewardAddress);\r\n    }\r\n\r\n    function emitNewSmartToken(address token) public hasLoggerPermissions(msg.sender) {\r\n        emit NewSmartToken(msg.sender, token);\r\n    }\r\n\r\n    function emitIssuance(uint256 amount) public hasLoggerPermissions(msg.sender) {\r\n        emit Issuance(msg.sender, amount);\r\n    }\r\n\r\n    function emitDestruction(uint256 amount) public hasLoggerPermissions(msg.sender) {\r\n        emit Destruction(msg.sender, amount);\r\n    }\r\n\r\n    function emitTransfer(address from, address to, uint256 value) public hasLoggerPermissions(msg.sender) {\r\n        emit Transfer(msg.sender, from, to, value);\r\n    }\r\n\r\n    function emitApproval(address owner, address spender, uint256 value) public hasLoggerPermissions(msg.sender) {\r\n        emit Approval(msg.sender, owner, spender, value);\r\n    }\r\n\r\n    function emitGenericLog(string messageType, string message) public hasLoggerPermissions(msg.sender) {\r\n        emit GenericLog(msg.sender, messageType, message);\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/IERC20.sol\r\n\r\n/*\r\n    Smart Token Interface\r\n*/\r\ncontract IERC20 {\r\n    function balanceOf(address tokenOwner) public constant returns (uint balance);\r\n    function allowance(address tokenOwner, address spender) public constant returns (uint remaining);\r\n    function transfer(address to, uint tokens) public returns (bool success);\r\n    function approve(address spender, uint tokens) public returns (bool success);\r\n    function transferFrom(address from, address to, uint tokens) public returns (bool success);\r\n\r\n    event Transfer(address indexed from, address indexed to, uint tokens);\r\n    event Approval(address indexed tokenOwner, address indexed spender, uint tokens);\r\n}\r\n\r\n// File: contracts/interfaces/ICommunityAccount.sol\r\n\r\n/*\r\n    Community Account Interface\r\n*/\r\ncontract ICommunityAccount is IOwned {\r\n    function setStakedBalances(uint _amount, address msgSender) public;\r\n    function setTotalStaked(uint _totalStaked) public;\r\n    function setTimeStaked(uint _timeStaked, address msgSender) public;\r\n    function setEscrowedTaskBalances(uint uuid, uint balance) public;\r\n    function setEscrowedProjectBalances(uint uuid, uint balance) public;\r\n    function setEscrowedProjectPayees(uint uuid, address payeeAddress) public;\r\n    function setTotalTaskEscrow(uint balance) public;\r\n    function setTotalProjectEscrow(uint balance) public;\r\n}\r\n\r\n// File: contracts/CommunityAccount.sol\r\n\r\n/**\r\n@title Tribe Account\r\n@notice This contract is used as a community's data store.\r\n@notice Advantages:\r\n@notice 1) Decouple logic contract from data contract\r\n@notice 2) Safely upgrade logic contract without compromising stored data\r\n*/\r\ncontract CommunityAccount is Owned, ICommunityAccount {\r\n\r\n    // Staking Variables.  In community token\r\n    mapping (address => uint256) public stakedBalances;\r\n    mapping (address => uint256) public timeStaked;\r\n    uint public totalStaked;\r\n\r\n    // Escrow variables.  In native token\r\n    uint public totalTaskEscrow;\r\n    uint public totalProjectEscrow;\r\n    mapping (uint256 => uint256) public escrowedTaskBalances;\r\n    mapping (uint256 => uint256) public escrowedProjectBalances;\r\n    mapping (uint256 => address) public escrowedProjectPayees;\r\n    \r\n    /**\r\n    @notice This function allows the community to transfer tokens out of the contract.\r\n    @param tokenContractAddress Address of community contract\r\n    @param destination Destination address of user looking to remove tokens from contract\r\n    @param amount Amount to transfer out of community\r\n    */\r\n    function transferTokensOut(address tokenContractAddress, address destination, uint amount) public ownerOnly returns(bool result) {\r\n        IERC20 token = IERC20(tokenContractAddress);\r\n        return token.transfer(destination, amount);\r\n    }\r\n\r\n    /**\r\n    @notice This is the community staking method\r\n    @param _amount Amount to be staked\r\n    @param msgSender Address of the staker\r\n    */\r\n    function setStakedBalances(uint _amount, address msgSender) public ownerOnly {\r\n        stakedBalances[msgSender] = _amount;\r\n    }\r\n\r\n    /**\r\n    @param _totalStaked Set total amount staked in community\r\n     */\r\n    function setTotalStaked(uint _totalStaked) public ownerOnly {\r\n        totalStaked = _totalStaked;\r\n    }\r\n\r\n    /**\r\n    @param _timeStaked Time of user staking into community\r\n    @param msgSender Staker address\r\n     */\r\n    function setTimeStaked(uint _timeStaked, address msgSender) public ownerOnly {\r\n        timeStaked[msgSender] = _timeStaked;\r\n    }\r\n\r\n    /**\r\n    @param uuid id of escrowed task\r\n    @param balance Balance to be set of escrowed task\r\n     */\r\n    function setEscrowedTaskBalances(uint uuid, uint balance) public ownerOnly {\r\n        escrowedTaskBalances[uuid] = balance;\r\n    }\r\n\r\n    /**\r\n    @param uuid id of escrowed project\r\n    @param balance Balance to be set of escrowed project\r\n     */\r\n    function setEscrowedProjectBalances(uint uuid, uint balance) public ownerOnly {\r\n        escrowedProjectBalances[uuid] = balance;\r\n    }\r\n\r\n    /**\r\n    @param uuid id of escrowed project\r\n    @param payeeAddress Address funds will go to once project completed\r\n     */\r\n    function setEscrowedProjectPayees(uint uuid, address payeeAddress) public ownerOnly {\r\n        escrowedProjectPayees[uuid] = payeeAddress;\r\n    }\r\n\r\n    /**\r\n    @param balance Balance which to set total task escrow to\r\n     */\r\n    function setTotalTaskEscrow(uint balance) public ownerOnly {\r\n        totalTaskEscrow = balance;\r\n    }\r\n\r\n    /**\r\n    @param balance Balance which to set total project to\r\n     */\r\n    function setTotalProjectEscrow(uint balance) public ownerOnly {\r\n        totalProjectEscrow = balance;\r\n    }\r\n}\r\n\r\n// File: contracts/interfaces/ISmartToken.sol\r\n\r\n/**\r\n    @notice Smart Token Interface\r\n*/\r\ncontract ISmartToken is IOwned, IERC20 {\r\n    function disableTransfers(bool _disable) public;\r\n    function issue(address _to, uint256 _amount) public;\r\n    function destroy(address _from, uint256 _amount) public;\r\n}\r\n\r\n// File: contracts/interfaces/ICommunity.sol\r\n\r\n/*\r\n    Community Interface\r\n*/\r\ncontract ICommunity {\r\n    function transferCurator(address _curator) public;\r\n    function transferVoteController(address _voteController) public;\r\n    function setMinimumStakingRequirement(uint _minimumStakingRequirement) public;\r\n    function setLockupPeriodSeconds(uint _lockupPeriodSeconds) public;\r\n    function setLogger(address newLoggerAddress) public;\r\n    function setTokenAddresses(address newNativeTokenAddress, address newCommunityTokenAddress) public;\r\n    function setCommunityAccount(address newCommunityAccountAddress) public;\r\n    function setCommunityAccountOwner(address newOwner) public;\r\n    function getAvailableDevFund() public view returns (uint);\r\n    function getLockedDevFundAmount() public view returns (uint);\r\n    function createNewTask(uint uuid, uint amount) public;\r\n    function cancelTask(uint uuid) public;\r\n    function rewardTaskCompletion(uint uuid, address user) public;\r\n    function createNewProject(uint uuid, uint amount, address projectPayee) public;\r\n    function cancelProject(uint uuid) public;\r\n    function rewardProjectCompletion(uint uuid) public;\r\n    function stakeCommunityTokens() public;\r\n    function unstakeCommunityTokens() public;\r\n    function isMember(address memberAddress)public view returns (bool);\r\n}\r\n\r\n// File: contracts/utility/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that revert on error\r\n * From https://github.com/OpenZeppelin/openzeppelin-solidity/commit/a2e710386933d3002062888b35aae8ac0401a7b3\r\n */\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, reverts on overflow.\r\n    */\r\n    function mul(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n        // benefit is lost if 'b' is also tested.\r\n        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n        if (_a == 0) {\r\n            return 0;\r\n        }\r\n\r\n        uint256 c = _a * _b;\r\n        require(c / _a == _b);\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers truncating the quotient, reverts on division by zero.\r\n    */\r\n    function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b > 0); // Solidity only automatically asserts when dividing by 0\r\n        uint256 c = _a / _b;\r\n        // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        require(_b <= _a);\r\n        uint256 c = _a - _b;\r\n\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, reverts on overflow.\r\n    */\r\n    function add(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n        uint256 c = _a + _b;\r\n        require(c >= _a);\r\n\r\n        return c;\r\n    }\r\n}\r\n\r\n// File: contracts/Community.sol\r\n\r\n/**\r\n@notice Main community logic contract.\r\n@notice functionality:\r\n@notice 1) Stake / Unstake community tokens.  This is how user joins or leaves community.\r\n@notice 2) Create Projects and Tasks by escrowing NTV token until curator or voteController determines task complete\r\n@notice 3) Log all events to singleton Logger contract\r\n@notice 4) Own communityAccount contract which holds all staking- and escrow-related funds and variables\r\n@notice --- This abstraction of funds allows for easy upgrade process; launch new community -> transfer ownership of the existing communityAccount\r\n@notice --- View test/integration-test-upgrades.js to demonstrate this process\r\n */\r\ncontract Community is ICommunity {\r\n\r\n    address public curator;\r\n    address public voteController;\r\n    uint public minimumStakingRequirement;\r\n    uint public lockupPeriodSeconds;\r\n    ISmartToken public nativeTokenInstance;\r\n    ISmartToken public communityTokenInstance;\r\n    Logger public logger;\r\n    CommunityAccount public communityAccount;\r\n\r\n    modifier onlyCurator {\r\n        require(msg.sender == curator);\r\n        _;\r\n    }\r\n\r\n    modifier onlyVoteController {\r\n        require(msg.sender == voteController);\r\n        _;\r\n    }\r\n\r\n    modifier sufficientDevFundBalance (uint amount) {\r\n        require(amount <= getAvailableDevFund());\r\n        _;\r\n    }\r\n\r\n    /**\r\n    @param _minimumStakingRequirement Minimum stake amount to join community\r\n    @param _lockupPeriodSeconds Required minimum holding time, in seconds, after joining for staker to leave\r\n    @param _curator Address of community curator\r\n    @param _communityTokenContractAddress Address of community token contract\r\n    @param _nativeTokenContractAddress Address of ontract\r\n    @param _voteController Address of vote controller\r\n    @param _loggerContractAddress Address of logger contract\r\n    @param _communityAccountContractAddress Address of community account\r\n     */\r\n    constructor(uint _minimumStakingRequirement,\r\n        uint _lockupPeriodSeconds,\r\n        address _curator,\r\n        address _communityTokenContractAddress,\r\n        address _nativeTokenContractAddress,\r\n        address _voteController,\r\n        address _loggerContractAddress,\r\n        address _communityAccountContractAddress) public {\r\n        communityAccount = CommunityAccount(_communityAccountContractAddress);\r\n        curator = _curator;\r\n        minimumStakingRequirement = _minimumStakingRequirement;\r\n        lockupPeriodSeconds = _lockupPeriodSeconds;\r\n        logger = Logger(_loggerContractAddress);\r\n        voteController = _voteController;\r\n        nativeTokenInstance = ISmartToken(_nativeTokenContractAddress);\r\n        communityTokenInstance = ISmartToken(_communityTokenContractAddress);\r\n    }\r\n\r\n    // TODO add events to each of these\r\n    /**\r\n    @notice Sets curator to input curator address\r\n    @param _curator Address of new community curator\r\n     */\r\n    function transferCurator(address _curator) public onlyCurator {\r\n        curator = _curator;\r\n        logger.emitGenericLog(\"transferCurator\", \"\");\r\n    }\r\n\r\n    /**\r\n    @notice Sets vote controller to input vote controller address\r\n    @param _voteController Address of new vote controller\r\n     */\r\n    function transferVoteController(address _voteController) public onlyCurator {\r\n        voteController = _voteController;\r\n        logger.emitGenericLog(\"transferVoteController\", \"\");\r\n    }\r\n\r\n    /**\r\n    @notice Sets the minimum community staking requirement\r\n    @param _minimumStakingRequirement Minimum community staking requirement to be set\r\n     */\r\n    function setMinimumStakingRequirement(uint _minimumStakingRequirement) public onlyCurator {\r\n        minimumStakingRequirement = _minimumStakingRequirement;\r\n        logger.emitGenericLog(\"setMinimumStakingRequirement\", \"\");\r\n    }\r\n\r\n    /**\r\n    @notice Sets lockup period for community staking\r\n    @param _lockupPeriodSeconds Community staking lockup period, in seconds\r\n    */\r\n    function setLockupPeriodSeconds(uint _lockupPeriodSeconds) public onlyCurator {\r\n        lockupPeriodSeconds = _lockupPeriodSeconds;\r\n        logger.emitGenericLog(\"setLockupPeriodSeconds\", \"\");\r\n    }\r\n\r\n    /**\r\n    @notice Updates Logger contract address to be used\r\n    @param newLoggerAddress Address of new Logger contract\r\n     */\r\n    function setLogger(address newLoggerAddress) public onlyCurator {\r\n        logger = Logger(newLoggerAddress);\r\n        logger.emitGenericLog(\"setLogger\", \"\");\r\n    }\r\n\r\n    /**\r\n    @param newNativeTokenAddress New Native token address\r\n    @param newCommunityTokenAddress New community token address\r\n     */\r\n    function setTokenAddresses(address newNativeTokenAddress, address newCommunityTokenAddress) public onlyCurator {\r\n        nativeTokenInstance = ISmartToken(newNativeTokenAddress);\r\n        communityTokenInstance = ISmartToken(newCommunityTokenAddress);\r\n        logger.emitGenericLog(\"setTokenAddresses\", \"\");\r\n    }\r\n\r\n    /**\r\n    @param newCommunityAccountAddress Address of new community account\r\n     */\r\n    function setCommunityAccount(address newCommunityAccountAddress) public onlyCurator {\r\n        communityAccount = CommunityAccount(newCommunityAccountAddress);\r\n        logger.emitGenericLog(\"setCommunityAccount\", \"\");\r\n    }\r\n\r\n    /**\r\n    @param newOwner New community account owner address\r\n     */\r\n    function setCommunityAccountOwner(address newOwner) public onlyCurator {\r\n        communityAccount.transferOwnershipNow(newOwner);\r\n        logger.emitGenericLog(\"setCommunityAccountOwner\", \"\");\r\n    }\r\n\r\n    /// @return Amount in the dev fund not locked up by project or task stake\r\n    function getAvailableDevFund() public view returns (uint) {\r\n        uint devFundBalance = nativeTokenInstance.balanceOf(address(communityAccount));\r\n        return SafeMath.sub(devFundBalance, getLockedDevFundAmount());\r\n    }\r\n\r\n    /// @return Amount locked up in escrow\r\n    function getLockedDevFundAmount() public view returns (uint) {\r\n        return SafeMath.add(communityAccount.totalTaskEscrow(), communityAccount.totalProjectEscrow());\r\n    }\r\n\r\n    /* Task escrow code below (in community tokens) */\r\n\r\n    /// @notice Updates the escrow values for a new task\r\n    function createNewTask(uint uuid, uint amount) public onlyCurator sufficientDevFundBalance (amount) {\r\n        communityAccount.setEscrowedTaskBalances(uuid, amount);\r\n        communityAccount.setTotalTaskEscrow(SafeMath.add(communityAccount.totalTaskEscrow(), amount));\r\n        logger.emitTaskCreated(uuid, amount);\r\n        logger.emitGenericLog(\"createNewTask\", \"\");\r\n    }\r\n\r\n    /// @notice Subtracts the tasks escrow and sets tasks escrow balance to 0\r\n    function cancelTask(uint uuid) public onlyCurator {\r\n        communityAccount.setTotalTaskEscrow(SafeMath.sub(communityAccount.totalTaskEscrow(), communityAccount.escrowedTaskBalances(uuid)));\r\n        communityAccount.setEscrowedTaskBalances(uuid, 0);\r\n        logger.emitGenericLog(\"cancelTask\", \"\");\r\n    }\r\n\r\n    /// @notice Pays task completer and updates escrow balances\r\n    function rewardTaskCompletion(uint uuid, address user) public onlyVoteController {\r\n        communityAccount.transferTokensOut(address(nativeTokenInstance), user, communityAccount.escrowedTaskBalances(uuid));\r\n        communityAccount.setTotalTaskEscrow(SafeMath.sub(communityAccount.totalTaskEscrow(), communityAccount.escrowedTaskBalances(uuid)));\r\n        communityAccount.setEscrowedTaskBalances(uuid, 0);\r\n        logger.emitGenericLog(\"rewardTaskCompletion\", \"\");\r\n    }\r\n\r\n    /* Project escrow code below (in community tokens) */\r\n\r\n    /// @notice updates the escrow values along with the project payee for a new project\r\n    function createNewProject(uint uuid, uint amount, address projectPayee) public onlyCurator sufficientDevFundBalance (amount) {\r\n        communityAccount.setEscrowedProjectBalances(uuid, amount);\r\n        communityAccount.setEscrowedProjectPayees(uuid, projectPayee);\r\n        communityAccount.setTotalProjectEscrow(SafeMath.add(communityAccount.totalProjectEscrow(), amount));\r\n        logger.emitProjectCreated(uuid, amount, projectPayee);\r\n        logger.emitGenericLog(\"createNewProject\", \"\");\r\n    }\r\n\r\n    /// @notice Subtracts tasks escrow and sets tasks escrow balance to 0\r\n    function cancelProject(uint uuid) public onlyCurator {\r\n        communityAccount.setTotalProjectEscrow(SafeMath.sub(communityAccount.totalProjectEscrow(), communityAccount.escrowedProjectBalances(uuid)));\r\n        communityAccount.setEscrowedProjectBalances(uuid, 0);\r\n        logger.emitGenericLog(\"cancelProject\", \"\");\r\n    }\r\n\r\n    /// @notice Pays out upon project completion\r\n    /// @notice Updates escrow balances\r\n    function rewardProjectCompletion(uint uuid) public onlyVoteController {\r\n        communityAccount.transferTokensOut(\r\n            address(nativeTokenInstance),\r\n            communityAccount.escrowedProjectPayees(uuid),\r\n            communityAccount.escrowedProjectBalances(uuid));\r\n        communityAccount.setTotalProjectEscrow(SafeMath.sub(communityAccount.totalProjectEscrow(), communityAccount.escrowedProjectBalances(uuid)));\r\n        communityAccount.setEscrowedProjectBalances(uuid, 0);\r\n        logger.emitGenericLog(\"rewardProjectCompletion\", \"\");\r\n    }\r\n\r\n    /// @notice Stake code (in community tokens)\r\n    function stakeCommunityTokens() public {\r\n\r\n        require(minimumStakingRequirement >= communityAccount.stakedBalances(msg.sender));\r\n\r\n        uint amount = minimumStakingRequirement - communityAccount.stakedBalances(msg.sender);\r\n        require(amount > 0);\r\n        require(communityTokenInstance.transferFrom(msg.sender, address(communityAccount), amount));\r\n\r\n        communityAccount.setStakedBalances(SafeMath.add(communityAccount.stakedBalances(msg.sender), amount), msg.sender);\r\n        communityAccount.setTotalStaked(SafeMath.add(communityAccount.totalStaked(), amount));\r\n        communityAccount.setTimeStaked(now, msg.sender);\r\n        logger.emitGenericLog(\"stakeCommunityTokens\", \"\");\r\n    }\r\n\r\n    /// @notice Unstakes user from community and sends funds back to user\r\n    /// @notice Checks lockup period and balance before unstaking\r\n    function unstakeCommunityTokens() public {\r\n        uint amount = communityAccount.stakedBalances(msg.sender);\r\n\r\n        require(now - communityAccount.timeStaked(msg.sender) >= lockupPeriodSeconds);\r\n\r\n        communityAccount.setStakedBalances(0, msg.sender);\r\n        communityAccount.setTotalStaked(SafeMath.sub(communityAccount.totalStaked(), amount));\r\n        require(communityAccount.transferTokensOut(address(communityTokenInstance), msg.sender, amount));\r\n        logger.emitGenericLog(\"unstakeCommunityTokens\", \"\");\r\n    }\r\n\r\n    /// @notice Checks that the user is fully staked\r\n    function isMember(address memberAddress) public view returns (bool) {\r\n        return (communityAccount.stakedBalances(memberAddress) >= minimumStakingRequirement);\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_curator\",\"type\":\"address\"}],\"name\":\"transferCurator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nativeTokenInstance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"uint256\"}],\"name\":\"cancelProject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"stakeCommunityTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockupPeriodSeconds\",\"type\":\"uint256\"}],\"name\":\"setLockupPeriodSeconds\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_voteController\",\"type\":\"address\"}],\"name\":\"transferVoteController\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"createNewTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"setCommunityAccountOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newLoggerAddress\",\"type\":\"address\"}],\"name\":\"setLogger\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"uint256\"}],\"name\":\"rewardProjectCompletion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"uint256\"},{\"name\":\"amount\",\"type\":\"uint256\"},{\"name\":\"projectPayee\",\"type\":\"address\"}],\"name\":\"createNewProject\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityTokenInstance\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_minimumStakingRequirement\",\"type\":\"uint256\"}],\"name\":\"setMinimumStakingRequirement\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"uint256\"}],\"name\":\"cancelTask\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unstakeCommunityTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"lockupPeriodSeconds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"voteController\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"memberAddress\",\"type\":\"address\"}],\"name\":\"isMember\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"communityAccount\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newNativeTokenAddress\",\"type\":\"address\"},{\"name\":\"newCommunityTokenAddress\",\"type\":\"address\"}],\"name\":\"setTokenAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"newCommunityAccountAddress\",\"type\":\"address\"}],\"name\":\"setCommunityAccount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getAvailableDevFund\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getLockedDevFundAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"curator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"uuid\",\"type\":\"uint256\"},{\"name\":\"user\",\"type\":\"address\"}],\"name\":\"rewardTaskCompletion\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minimumStakingRequirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_minimumStakingRequirement\",\"type\":\"uint256\"},{\"name\":\"_lockupPeriodSeconds\",\"type\":\"uint256\"},{\"name\":\"_curator\",\"type\":\"address\"},{\"name\":\"_communityTokenContractAddress\",\"type\":\"address\"},{\"name\":\"_nativeTokenContractAddress\",\"type\":\"address\"},{\"name\":\"_voteController\",\"type\":\"address\"},{\"name\":\"_loggerContractAddress\",\"type\":\"address\"},{\"name\":\"_communityAccountContractAddress\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"Community","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000ad78ebc5ac6200000000000000000000000000000000000000000000000000000000000000076a7000000000000000000000000003cadf160a9d2e66e69bbdab63219dde2f1c07a170000000000000000000000001627ab73a27232468bae3a13786e1234ce9848a300000000000000000000000000000000000000000000000000000000000000000000000000000000000000003cadf160a9d2e66e69bbdab63219dde2f1c07a170000000000000000000000002d8232aa33f3321d54c9339734de7749452bc124000000000000000000000000efa0f12ea4e96027dc575a3e0fedfbe5bc93b0fe","Library":"","SwarmSource":"bzzr://ccce86f7b26ec5483d59848e335f7925b8501d1d39cb31fefc4c6d98b3e5af34"}]}