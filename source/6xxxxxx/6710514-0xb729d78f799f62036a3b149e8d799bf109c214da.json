{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title Library to validate AZTEC zero-knowledge proofs\r\n * @author Zachary Williamson, AZTEC\r\n * @dev Don't include this as an internal library. This contract uses a static memory table to cache elliptic curve primitives and hashes.\r\n * Calling this internally from another function will lead to memory mutation and undefined behaviour.\r\n * The intended use case is to call this externally via `deletagecall`. External calls to OptimizedAZTEC can be treated as pure functions as this contract contains no storage and makes no external calls (other than to precompiles)\r\n * Copyright AZTEC 2018. All rights reserved.\r\n * We will be releasing AZTEC as an open-source protocol that provides efficient transaction privacy for Ethereum.\r\n * This will include our bespoke AZTEC decentralized exchange, allowing for cross-asset transfers with full transaction privacy\r\n * and interopability with public decentralized exchanges.\r\n * Stay tuned for updates!\r\n **/\r\ncontract AZTEC {\r\n    /**\r\n     * @dev AZTEC will take any transaction sent to it and attempt to validate a zero knowledge proof.\r\n     * If the proof is not valid, the transaction will throw.\r\n     * @notice See AZTECInterface for how method calls should be constructed.\r\n     * 'Cost' of raw elliptic curve primitives for a transaction: 260,700 gas + (124,500 * number of input notes) + (167,600 * number of output notes).\r\n     * For a basic 'joinSplit' with 2 inputs and 2 outputs = 844,900 gas.\r\n     * AZTEC is written in IULIA to enable manual memory management and for other efficiency savings.\r\n     **/\r\n    function() external payable {\r\n        assembly {\r\n            // We don't check for function signatures, there's only one function that ever gets called: validateJoinSplit()\r\n            // We still assume calldata is offset by 4 bytes so that we can represent this contract through a compatible ABI\r\n            validateJoinSplit()\r\n            // should not get here\r\n            mstore(0x00, 404)\r\n            revert(0x00, 0x20)\r\n\r\n            /**\r\n             * @dev Validate an AZTEC protocol JoinSplit zero-knowledge proof\r\n             * Calldata Map is\r\n             * 0x04:0x24       = calldata location of start of ```note``` dynamic array\r\n             * 0x24:0x44       = m, which defines the index separator between input notes ando utput notes\r\n             * 0x44:0x64       = Fiat-Shamir heuristicified random challenge\r\n             * 0x64:0xe4       = G2 element t2, the trusted setup public key\r\n             * 0xe4:0x104      = start of ```note``` dynamic array, contains the size of the array (```n```)\r\n             * Subsequent calldata arranged in 0xc0 sized blocks of data, each representing an AZTEC commitment and zero-knowledge proof variables\r\n             *\r\n             * Note data map (uint[6]) is\r\n             * 0x00:0x20       = Z_p element \\bar{k}_i\r\n             * 0x20:0x40       = Z_p element \\bar{a}_i\r\n             * 0x40:0x80       = G1 element \\gamma_i\r\n             * 0x80:0xc0       = G1 element \\sigma_i\r\n             *\r\n             * The last element in the note array is special and contains the following:\r\n             * 0x00:0x20       = Z_p element k_{public}\r\n             * 0x20:0x40       = Z_p element \\bar{a}_i\r\n             * 0x40:0x60       = G1 element \\gamma_i\r\n             * 0x60-0x80       = G1 element \\sigma_i\r\n             * We can recover \\bar{k}_{n-1} from the homomorphic sum condition \\sum_{i=0}^{m-1}\\bar{k}_i = \\sum_{i=m}^{n-1}\\bar{k}_i + k_{public}\r\n             * So we use the empty slot to store k_{public}, which represents any public 'value' being blinded into zero-knowledge notes\r\n             *\r\n             * We use a hard-coded memory map to reduce gas costs - if this is not called as an external contract then terrible things will happen!\r\n             * 0x00:0x20       = scratch data to store result of keccak256 calls\r\n             * 0x20:0x80       = scratch data to store \\gamma_i and a multiplication scalar\r\n             * 0x80:0xc0       = x-coordinate of generator h\r\n             * 0xc0:0xe0       = y-coordinate of generator h\r\n             * 0xe0:0x100      = scratch data to store a scalar we plan to multiply h by\r\n             * 0x100:0x160     = scratch data to store \\sigma_i and a multiplication scalar\r\n             * 0x160:0x1a0     = stratch data to store result of G1 point additions\r\n             * 0x1a0:0x1c0     = scratch data to store result of \\sigma_i^{-cx_{i-m-1}}\r\n             * 0x1c0:0x200     = location of pairing accumulator \\sigma_{acc}, where \\sigma_{acc} = \\prod_{i=m}^{n-1}\\sigma_i^{cx_{i-m-1}}\r\n             * 0x220:0x260     = scratch data to store \\gamma_i^{cx_{i-m-1}}\r\n             * 0x260:0x2a0     = location of pairing accumulator \\gamma_{acc}, where \\gamma_{acc} = \\prod_{i=m}^{n-1}\\gamma_i^{cx_{i-m-1}}\r\n             * 0x2a0:0x2c0     = msg.sender (contract should be called via delegatecall/staticcall)\r\n             * 0x2c0:0x2e0     = kn (memory used to reconstruct hash starts here)\r\n             * 0x2e0:0x300     = m\r\n             * 0x300:???       = block of memory that contains (\\gamma_i, \\sigma_i)_{i=0}^{n-1} concatenated with (B_i)_{i=0}^{n-1}\r\n             **/\r\n            function validateJoinSplit() {\r\n                mstore(0x80, 7673901602397024137095011250362199966051872585513276903826533215767972925880) // h_x\r\n                mstore(0xa0, 8489654445897228341090914135473290831551238522473825886865492707826370766375) // h_y\r\n                let notes := add(0x04, calldataload(0x04))\r\n                let m := calldataload(0x24)\r\n                let n := calldataload(notes)\r\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\r\n                let challenge := mod(calldataload(0x44), gen_order)\r\n                // validate m <= n\r\n                if gt(m, n) { mstore(0x00, 404) revert(0x00, 0x20) }\r\n                // recover k_{public} and calculate k_{public}\r\n                let kn := calldataload(sub(calldatasize, 0xc0))\r\n                // add kn and m to final hash table\r\n                mstore(0x2a0, caller)\r\n                mstore(0x2c0, kn)\r\n                mstore(0x2e0, m)\r\n                kn := mulmod(sub(gen_order, kn), challenge, gen_order) // we actually want c*k_{public}\r\n                hashCommitments(notes, n)\r\n                let b := add(0x300, mul(n, 0x80))\r\n\r\n                // Iterate over every note and calculate the blinding factor B_i = \\gamma_i^{kBar}h^{aBar}\\sigma_i^{-c}.\r\n                // We use the AZTEC protocol pairing optimization to reduce the number of pairing comparisons to 1, which adds some minor alterations\r\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\r\n                    // Get the calldata index of this note\r\n                    let noteIndex := add(add(notes, 0x20), mul(i, 0xc0))\r\n                    // Define variables k, a and c.\r\n                    // If i <= m then\r\n                    //   k = kBar_i\r\n                    //   a = aBar_i\r\n                    //   c = challenge\r\n                    // If i > m then we add a modification for the pairing optimization\r\n                    //   k = kBar_i * x_i\r\n                    //   a = aBar_i * x_i\r\n                    //   c = challenge * x_i\r\n                    // Set j = i - (m+1).\r\n                    // x_0 = 1\r\n                    // x_1 = keccak256(input string)\r\n                    // all other x_{j} = keccak256(x_{j-1})\r\n                    // The reason for doing this is that the point  \\sigma_i^{-cx_j} can be re-used in the pairing check\r\n                    // Instead of validating e(\\gamma_i, t_2) == e(\\sigma_i, g_2) for all i = [m+1,\\ldots,n]\r\n                    // We instead validate e(\\Pi_{i=m+1}^{n}\\gamma_i^{-cx_j}, t_2) == e(\\Pi_{i=m+1}^{n}\\sigma_i^{cx_j}, g_2).\r\n                    // x_j is a pseudorandom variable whose entropy source is the input string, allowing for\r\n                    // a sum of commitment points to be evaluated in one pairing comparison\r\n                    let k\r\n                    let a := calldataload(add(noteIndex, 0x20))\r\n                    let c := challenge\r\n\r\n                    // We don't transmit kBar_{n-1} in the proof to save space, instead we derive it\r\n                    // As per the homomorphic sum condition: \\sum_{i=0}^{m-1}\\bar{k}_i = \\sum_{i=m}^{n-1}\\bar{k}_i + k_{public}c, \r\n                    // We can recover \\bar{k}_{n-1}.\r\n                    // If m=n then \\bar{k}_{n-1} = \\sum_{i=0}^{n-1}\\bar{k}_i + k_{public}\r\n                    // else \\bar{k}_{n-1} = \\sum_{i=0}^{m-1}\\bar{k}_i - \\sum_{i=m}^{n-1}\\bar{k}_i - k_{public}\r\n                    switch eq(add(i, 0x01), n)\r\n                    case 1 {\r\n                        k := kn\r\n                        // if all notes are input notes, invert k\r\n                        if eq(m, n) {\r\n                            k := sub(gen_order, k)\r\n                        }\r\n                    }\r\n                    case 0 { k := calldataload(noteIndex) }\r\n\r\n                    // Check this commitment is well formed...\r\n                    // validateCommitment(noteIndex, k, a)\r\n                    // If i > m then this is an output note.\r\n                    // Set k = kx_j, a = ax_j, c = cx_j, where j = i - (m+1)\r\n                    switch gt(add(i, 0x01), m)\r\n                    case 1 {\r\n                        // before we update k, update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\r\n                        kn := addmod(kn, sub(gen_order, k), gen_order)\r\n                        let x := mod(mload(0x00), gen_order)\r\n                        k := mulmod(k, x, gen_order)\r\n                        a := mulmod(a, x, gen_order)\r\n                        c := mulmod(challenge, x, gen_order)\r\n                        // calculate x_{j+1}\r\n                        mstore(0x00, keccak256(0x00, 0x20))\r\n                    }\r\n                    case 0 {\r\n                        // nothing to do here except update kn = \\sum_{i=0}^{m-1}k_i - \\sum_{i=m}^{n-1}k_i\r\n                        kn := addmod(kn, k, gen_order)\r\n                    }\r\n                    \r\n                    // Calculate the G1 element \\gamma_i^{k}h^{a}\\sigma_i^{-c} = B_i\r\n                    // Memory map:\r\n                    // 0x20: \\gamma_iX\r\n                    // 0x40: \\gamma_iY\r\n                    // 0x60: k_i\r\n                    // 0x80: hX\r\n                    // 0xa0: hY\r\n                    // 0xc0: a_i\r\n                    // 0xe0: \\sigma_iX\r\n                    // 0x100: \\sigma_iY\r\n                    // 0x120: -c\r\n                    calldatacopy(0xe0, add(noteIndex, 0x80), 0x40)\r\n                    calldatacopy(0x20, add(noteIndex, 0x40), 0x40)\r\n                    mstore(0x120, sub(gen_order, c)) \r\n                    mstore(0x60, k)\r\n                    mstore(0xc0, a)\r\n\r\n                    // Call bn128 scalar multiplication precompiles\r\n                    // Represent point + multiplication scalar in 3 consecutive blocks of memory\r\n                    // Store \\sigma_i^{-c} at 0x1a0:0x200\r\n                    // Store \\gamma_i^{k} at 0x120:0x160\r\n                    // Store h^{a} at 0x160:0x1a0\r\n                    let result := staticcall(gas, 7, 0xe0, 0x60, 0x1a0, 0x40)\r\n                    result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x120, 0x40))\r\n                    result := and(result, staticcall(gas, 7, 0x80, 0x60, 0x160, 0x40))\r\n\r\n                    // Call bn128 group addition precompiles\r\n                    // \\gamma_i^{k} and h^{a} in memory block 0x120:0x1a0\r\n                    // Store result of addition at 0x160:0x1a0\r\n                    result := and(result, staticcall(gas, 6, 0x120, 0x80, 0x160, 0x40))\r\n                    // \\gamma_i^{k}h^{a} and \\sigma^{-c} in memory block 0x160:0x1e0\r\n                    // Store resulting point B at memory index b\r\n                    result := and(result, staticcall(gas, 6, 0x160, 0x80, b, 0x40))\r\n\r\n                    // We have \\sigma^{-c} at 0x1a0:0x200\r\n                    // And \\sigma_{acc} at 0x1e0:0x200\r\n                    // If i = m + 1 (i.e. first output note)\r\n                    // then we set \\gamma_{acc} and \\sigma_{acc} to \\gamma_i, -\\sigma_i\r\n                    if eq(i, m) {\r\n                        mstore(0x260, mload(0x20))\r\n                        mstore(0x280, mload(0x40))\r\n                        mstore(0x1e0, mload(0xe0))\r\n                        mstore(0x200, sub(0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47, mload(0x100)))\r\n                    }\r\n                    // If i > m + 1 (i.e. subsequent output notes)\r\n                    // then we add \\sigma^{-c} and \\sigma_{acc} and store result at \\sigma_{acc} (0x1e0:0x200)\r\n                    // we then calculate \\gamma^{cx} and add into \\gamma_{acc}\r\n                    if gt(i, m) {\r\n                       mstore(0x60, c)\r\n                       result := and(result, staticcall(gas, 7, 0x20, 0x60, 0x220, 0x40))\r\n                       // \\gamma_i^{cx} now at 0x220:0x260, \\gamma_{acc} is at 0x260:0x2a0\r\n                       result := and(result, staticcall(gas, 6, 0x220, 0x80, 0x260, 0x40))\r\n                       // add \\sigma_i^{-cx} and \\sigma_{acc} into \\sigma_{acc} at 0x1e0\r\n                       result := and(result, staticcall(gas, 6, 0x1a0, 0x80, 0x1e0, 0x40))\r\n                    }\r\n                    // throw transaction if any calls to precompiled contracts failed\r\n                    if iszero(result) { revert(0x00, 0x00) }\r\n                    b := add(b, 0x40) // increase B pointer by 2 words\r\n                }\r\n\r\n                // If the AZTEC protocol is implemented correctly then any input notes were previously outputs of\r\n                // a JoinSplit transaction. We can inductively assume that all input notes are well-formed AZTEC commitments and do not need to validate the implicit range proof\r\n                // This is not the case for any output commitments, so if (m < n) call validatePairing()\r\n                if lt(m, n) {\r\n                   validatePairing(0x64)\r\n                }\r\n\r\n                // We now have the note commitments and the calculated blinding factors in a block of memory\r\n                // starting at 0x2a0, of size (b - 0x2a0).\r\n                // Hash this block to reconstruct the initial challenge ahd validate that they match\r\n                let expected := mod(keccak256(0x2a0, sub(b, 0x2a0)), gen_order)\r\n                if iszero(eq(expected, challenge)) {\r\n                    // No! Bad! No soup for you!\r\n                    mstore(0x00, 404)\r\n                    revert(0x00, 0x20)\r\n                }\r\n\r\n                // Great! All done. This is a valid proof so return ```true```\r\n                mstore(0x00, 0x01)\r\n                return(0x00, 0x20)\r\n            }\r\n\r\n            /**        \r\n             * @dev evaluate if e(P1, t2) . e(P2, g2) == 0.\r\n             * @notice we don't hard-code t2 so that contracts that call this library can use different trusted setups.\r\n             **/\r\n            function validatePairing(t2) {\r\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\r\n                let t2_x_1 := calldataload(t2) // 0x464\r\n                let t2_x_2 := calldataload(add(t2, 0x20))\r\n                let t2_y_1 := calldataload(add(t2, 0x40))\r\n                let t2_y_2 := calldataload(add(t2, 0x60))\r\n                // check provided setup pubkey is not zero or g2\r\n                if or(or(or(or(or(or(or(\r\n                    iszero(t2_x_1),\r\n                    iszero(t2_x_2)),\r\n                    iszero(t2_y_1)),\r\n                    iszero(t2_y_2)),\r\n                    eq(t2_x_1, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)),\r\n                    eq(t2_x_2, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)),\r\n                    eq(t2_y_1, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)),\r\n                    eq(t2_y_2, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b))\r\n                {\r\n                    mstore(0x00, 500)\r\n                    revert(0x00, 0x20)\r\n                }\r\n\r\n                // store coords in memory\r\n                // indices are a bit off, scipr lab's libff limb ordering (c0, c1) is opposite to what precompile expects\r\n                // We can overwrite the memory we used previously as this function is called at the end of the validation routine.\r\n                mstore(0x20, mload(0x1e0)) // sigma accumulator x\r\n                mstore(0x40, mload(0x200)) // sigma accumulator y\r\n                mstore(0x80, 0x1800deef121f1e76426a00665e5c4479674322d4f75edadd46debd5cd992f6ed)\r\n                mstore(0x60, 0x198e9393920d483a7260bfb731fb5d25f1aa493335a9e71297e485b7aef312c2)\r\n                mstore(0xc0, 0x12c85ea5db8c6deb4aab71808dcb408fe3d1e7690c43d37b4ce6cc0166fa7daa)\r\n                mstore(0xa0, 0x90689d0585ff075ec9e99ad690c3395bc4b313370b38ef355acdadcd122975b)\r\n                mstore(0xe0, mload(0x260)) // gamma accumulator x\r\n                mstore(0x100, mload(0x280)) // gamma accumulator y\r\n                mstore(0x140, t2_x_1)\r\n                mstore(0x120, t2_x_2)\r\n                mstore(0x180, t2_y_1)\r\n                mstore(0x160, t2_y_2)\r\n\r\n                let success := staticcall(gas, 8, 0x20, 0x180, 0x20, 0x20)\r\n\r\n                if or(iszero(success), iszero(mload(0x20))) {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n            }\r\n\r\n            /**\r\n             * @dev check that this note's points are on the altbn128 curve(y^2 = x^3 + 3)\r\n             * and that signatures 'k' and 'a' are modulo the order of the curve. Transaction will throw if this is not the case.\r\n             * @param note the calldata loation of the note\r\n             **/\r\n            function validateCommitment(note, k, a) {\r\n                let gen_order := 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001\r\n                let field_order := 0x30644e72e131a029b85045b68181585d97816a916871ca8d3c208c16d87cfd47\r\n                let gammaX := calldataload(add(note, 0x40))\r\n                let gammaY := calldataload(add(note, 0x60))\r\n                let sigmaX := calldataload(add(note, 0x80))\r\n                let sigmaY := calldataload(add(note, 0xa0))\r\n                if iszero(\r\n                    and(\r\n                        and(\r\n                            and(\r\n                                eq(mod(a, gen_order), a), // a is modulo generator order?\r\n                                gt(a, 1)                  // can't be 0 or 1 either!\r\n                            ),\r\n                            and(\r\n                                eq(mod(k, gen_order), k), // k is modulo generator order?\r\n                                gt(k, 1)                  // and not 0 or 1\r\n                            )\r\n                        ),\r\n                        and(\r\n                            eq( // y^2 ?= x^3 + 3\r\n                                addmod(mulmod(mulmod(sigmaX, sigmaX, field_order), sigmaX, field_order), 3, field_order),\r\n                                mulmod(sigmaY, sigmaY, field_order)\r\n                            ),\r\n                            eq( // y^2 ?= x^3 + 3\r\n                                addmod(mulmod(mulmod(gammaX, gammaX, field_order), gammaX, field_order), 3, field_order),\r\n                                mulmod(gammaY, gammaY, field_order)\r\n                            )\r\n                        )\r\n                    )\r\n                ) {\r\n                    mstore(0x00, 400)\r\n                    revert(0x00, 0x20)\r\n                }\r\n            }\r\n\r\n            /**\r\n             * @dev Calculate the keccak256 hash of the commitments for both input notes and output notes.\r\n             * This is used both as an input to validate the challenge `c` and also to generate pseudorandom relationships\r\n             * between commitments for different outputNotes, so that we can combine them into a single multi-exponentiation for the purposes of validating the bilinear pairing relationships.\r\n             * @param notes calldata location notes\r\n             * @param n number of notes\r\n             **/\r\n            function hashCommitments(notes, n) {\r\n                for { let i := 0 } lt(i, n) { i := add(i, 0x01) } {\r\n                    let index := add(add(notes, mul(i, 0xc0)), 0x60)\r\n                    calldatacopy(add(0x300, mul(i, 0x80)), index, 0x80)\r\n                }\r\n                mstore(0x00, keccak256(0x300, mul(n, 0x80)))\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"}]","ContractName":"AZTEC","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e54b79b13f7a30abf6e840837ed273e244e0b22e0e9ef6baa213c537bebf97d5"}]}