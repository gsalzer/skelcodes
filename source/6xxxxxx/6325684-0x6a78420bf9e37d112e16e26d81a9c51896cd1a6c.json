{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/Ownable.sol\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoEther.sol\r\n\r\n/**\r\n * @title Contracts that should not own Ether\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up\r\n * in the contract, it will allow the owner to reclaim this Ether.\r\n * @notice Ether can still be sent to this contract by:\r\n * calling functions labeled `payable`\r\n * `selfdestruct(contract_address)`\r\n * mining directly to the contract address\r\n */\r\ncontract HasNoEther is Ownable {\r\n\r\n  /**\r\n  * @dev Constructor that rejects incoming Ether\r\n  * The `payable` flag is added so we can access `msg.value` without compiler warning. If we\r\n  * leave out payable, then Solidity will allow inheriting contracts to implement a payable\r\n  * constructor. By doing it this way we prevent a payable constructor from working. Alternatively\r\n  * we could use assembly to access msg.value.\r\n  */\r\n  constructor() public payable {\r\n    require(msg.value == 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Disallows direct send by setting a default function without the `payable` flag.\r\n   */\r\n  function() external {\r\n  }\r\n\r\n  /**\r\n   * @dev Transfer all Ether held by the contract to the owner.\r\n   */\r\n  function reclaimEther() external onlyOwner {\r\n    owner.transfer(address(this).balance);\r\n  }\r\n}\r\n\r\n// File: contracts/lifecycle/Finalizable.sol\r\n\r\n/**\r\n * @title Finalizable contract\r\n * @dev Lifecycle extension where an owner can do extra work after finishing.\r\n */\r\ncontract Finalizable is Ownable {\r\n  using SafeMath for uint256;\r\n\r\n  /// @dev Throws if called before the contract is finalized.\r\n  modifier onlyFinalized() {\r\n    require(isFinalized, \"Contract not finalized.\");\r\n    _;\r\n  }\r\n\r\n  /// @dev Throws if called after the contract is finalized.\r\n  modifier onlyNotFinalized() {\r\n    require(!isFinalized, \"Contract already finalized.\");\r\n    _;\r\n  }\r\n\r\n  bool public isFinalized = false;\r\n\r\n  event Finalized();\r\n\r\n  /**\r\n   * @dev Called by owner to do some extra finalization\r\n   * work. Calls the contract's finalization function.\r\n   */\r\n  function finalize() public onlyOwner onlyNotFinalized {\r\n    finalization();\r\n    emit Finalized();\r\n\r\n    isFinalized = true;\r\n  }\r\n\r\n  /**\r\n   * @dev Can be overridden to add finalization logic. The overriding function\r\n   * should call super.finalization() to ensure the chain of finalization is\r\n   * executed entirely.\r\n   */\r\n  function finalization() internal {\r\n    // override\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address _who) public view returns (uint256);\r\n  function transfer(address _to, uint256 _value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address _owner, address _spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address _from, address _to, uint256 _value)\r\n    public returns (bool);\r\n\r\n  function approve(address _spender, uint256 _value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol\r\n\r\n/**\r\n * @title SafeERC20\r\n * @dev Wrappers around ERC20 operations that throw on failure.\r\n * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract,\r\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\r\n */\r\nlibrary SafeERC20 {\r\n  function safeTransfer(\r\n    ERC20Basic _token,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transfer(_to, _value));\r\n  }\r\n\r\n  function safeTransferFrom(\r\n    ERC20 _token,\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.transferFrom(_from, _to, _value));\r\n  }\r\n\r\n  function safeApprove(\r\n    ERC20 _token,\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    internal\r\n  {\r\n    require(_token.approve(_spender, _value));\r\n  }\r\n}\r\n\r\n// File: contracts/payment/TokenEscrow.sol\r\n\r\n/**\r\n * @title TokenEscrow\r\n * @dev Base token escrow contract, holds funds destinated to a payee until they\r\n * withdraw them. The contract that uses the escrow as its payment method\r\n * should be its owner, and provide public methods redirecting to the escrow's\r\n * deposit and withdraw.\r\n */\r\ncontract TokenEscrow is Ownable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  event Deposited(address indexed payee, uint256 amount);\r\n  event Withdrawn(address indexed payee, uint256 amount);\r\n\r\n  // deposits of the beneficiaries of tokens\r\n  mapping(address => uint256) private deposits;\r\n\r\n  // ERC20 token contract being held\r\n  ERC20 public token;\r\n\r\n  constructor(ERC20 _token) public {\r\n    require(_token != address(0), \"Token address should not be 0x0.\");\r\n    token = _token;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the token accumulated balance for a payee.\r\n   * @param _payee The destination address of the tokens.\r\n   */\r\n  function depositsOf(address _payee) public view returns (uint256) {\r\n    return deposits[_payee];\r\n  }\r\n\r\n  /**\r\n   * @dev Stores the token amount as credit to be withdrawn.\r\n   * @param _payee The destination address of the tokens.\r\n   * @param _amount The amount of tokens that can be pulled.\r\n   */\r\n  function deposit(address _payee, uint256 _amount) public onlyOwner {\r\n    require(_payee != address(0), \"Destination address should not be 0x0.\");\r\n    require(_payee != address(this), \"Deposits should not be made to this contract.\");\r\n\r\n    deposits[_payee] = deposits[_payee].add(_amount);\r\n    token.safeTransferFrom(owner, this, _amount);\r\n\r\n    emit Deposited(_payee, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw accumulated balance for a payee.\r\n   * @param _payee The address whose tokens will be withdrawn and transferred to.\r\n   */\r\n  function withdraw(address _payee) public onlyOwner {\r\n    uint256 payment = deposits[_payee];\r\n    assert(token.balanceOf(address(this)) >= payment);\r\n\r\n    deposits[_payee] = 0;\r\n    token.safeTransfer(_payee, payment);\r\n\r\n    emit Withdrawn(_payee, payment);\r\n  }\r\n}\r\n\r\n// File: contracts/payment/TokenConditionalEscrow.sol\r\n\r\n/**\r\n * @title ConditionalEscrow\r\n * @dev Base abstract escrow to only allow withdrawal if a condition is met.\r\n */\r\ncontract TokenConditionalEscrow is TokenEscrow {\r\n\r\n  /**\r\n   * @dev Returns whether an address is allowed to withdraw their tokens. To be\r\n   * implemented by derived contracts.\r\n   * @param _payee The destination address of the tokens.\r\n   */\r\n  function withdrawalAllowed(address _payee) public view returns (bool);\r\n\r\n  /**\r\n   * @dev Withdraw accumulated balance for a payee if allowed.\r\n   * @param _payee The address whose tokens will be withdrawn and transferred to.\r\n   */\r\n  function withdraw(address _payee) public {\r\n    require(withdrawalAllowed(_payee), \"Withdrawal is not allowed.\");\r\n    super.withdraw(_payee);\r\n  }\r\n}\r\n\r\n// File: contracts/payment/TokenTimelockEscrow.sol\r\n\r\n/**\r\n * @title TokenTimelockEscrow\r\n * @dev Token escrow to only allow withdrawal only if the lock period\r\n * has expired. As only the owner can make deposits and withdrawals\r\n * this contract should be owned by the crowdsale, which can then\r\n * perform deposits and withdrawals for individual users.\r\n */\r\ncontract TokenTimelockEscrow is TokenConditionalEscrow {\r\n\r\n  // timestamp when token release is enabled\r\n  uint256 public releaseTime;\r\n\r\n  constructor(uint256 _releaseTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_releaseTime > block.timestamp, \"Release time should be in the future.\");\r\n    releaseTime = _releaseTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Returns whether an address is allowed to withdraw their tokens.\r\n   * @param _payee The destination address of the tokens.\r\n   */\r\n  function withdrawalAllowed(address _payee) public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp >= releaseTime;\r\n  }\r\n}\r\n\r\n// File: contracts/payment/TokenTimelockFactory.sol\r\n\r\n/**\r\n * @title TokenTimelockFactory\r\n * @dev Allows creation of timelock wallet.\r\n */\r\ncontract TokenTimelockFactory {\r\n\r\n  /**\r\n   * @dev Allows verified creation of token timelock wallet.\r\n   * @param _token Address of the token being locked.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred.\r\n   * @param _releaseTime The release times after which the tokens can be withdrawn.\r\n   * @return Returns wallet address.\r\n   */\r\n  function create(\r\n    ERC20 _token,\r\n    address _beneficiary,\r\n    uint256 _releaseTime\r\n  )\r\n    public\r\n    returns (address wallet);\r\n}\r\n\r\n// File: contracts/payment/TokenVestingFactory.sol\r\n\r\n/**\r\n * @title TokenVestingFactory\r\n * @dev Allows creation of token vesting wallet.\r\n */\r\ncontract TokenVestingFactory {\r\n\r\n  /**\r\n   * @dev Allows verified creation of token vesting wallet.\r\n   * Creates a vesting contract that vests its balance of any ERC20 token to the\r\n   * _beneficiary, gradually in a linear fashion until _start + _duration. By then all\r\n   * of the balance will have vested.\r\n   * @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _start the time (as Unix time) at which point vesting starts\r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @param _revocable whether the vesting is revocable or not\r\n   * @return Returns wallet address.\r\n   */\r\n  function create(\r\n    address _beneficiary,\r\n    uint256 _start,\r\n    uint256 _cliff,\r\n    uint256 _duration,\r\n    bool _revocable\r\n  )\r\n    public\r\n    returns (address wallet);\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoContracts.sol\r\n\r\n/**\r\n * @title Contracts that should not own Contracts\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner\r\n * of this contract to reclaim ownership of the contracts.\r\n */\r\ncontract HasNoContracts is Ownable {\r\n\r\n  /**\r\n   * @dev Reclaim ownership of Ownable contracts\r\n   * @param _contractAddr The address of the Ownable to be reclaimed.\r\n   */\r\n  function reclaimContract(address _contractAddr) external onlyOwner {\r\n    Ownable contractInst = Ownable(_contractAddr);\r\n    contractInst.transferOwnership(owner);\r\n  }\r\n}\r\n\r\n// File: contracts/TokenTimelockEscrowImpl.sol\r\n\r\n/// @title TokenTimelockEscrowImpl\r\ncontract TokenTimelockEscrowImpl is HasNoEther, HasNoContracts, TokenTimelockEscrow {\r\n\r\n  constructor(ERC20 _token, uint256 _releaseTime)\r\n    public\r\n    TokenEscrow(_token)\r\n    TokenTimelockEscrow(_releaseTime)\r\n  {\r\n    // constructor\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol\r\n\r\n/**\r\n * @title Contracts that should be able to recover tokens\r\n * @author SylTi\r\n * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner.\r\n * This will prevent any accidental loss of tokens.\r\n */\r\ncontract CanReclaimToken is Ownable {\r\n  using SafeERC20 for ERC20Basic;\r\n\r\n  /**\r\n   * @dev Reclaim all ERC20Basic compatible tokens\r\n   * @param _token ERC20Basic The address of the token contract\r\n   */\r\n  function reclaimToken(ERC20Basic _token) external onlyOwner {\r\n    uint256 balance = _token.balanceOf(this);\r\n    _token.safeTransfer(owner, balance);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/ownership/HasNoTokens.sol\r\n\r\n/**\r\n * @title Contracts that should not own Tokens\r\n * @author Remco Bloemen <remco@2π.com>\r\n * @dev This blocks incoming ERC223 tokens to prevent accidental loss of tokens.\r\n * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the\r\n * owner to reclaim the tokens.\r\n */\r\ncontract HasNoTokens is CanReclaimToken {\r\n\r\n /**\r\n  * @dev Reject all ERC223 compatible tokens\r\n  * @param _from address The address that is transferring the tokens\r\n  * @param _value uint256 the amount of the specified token\r\n  * @param _data Bytes The data passed from the caller.\r\n  */\r\n  function tokenFallback(\r\n    address _from,\r\n    uint256 _value,\r\n    bytes _data\r\n  )\r\n    external\r\n    pure\r\n  {\r\n    _from;\r\n    _value;\r\n    _data;\r\n    revert();\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol\r\n\r\n/**\r\n * @title Crowdsale\r\n * @dev Crowdsale is a base contract for managing a token crowdsale,\r\n * allowing investors to purchase tokens with ether. This contract implements\r\n * such functionality in its most fundamental form and can be extended to provide additional\r\n * functionality and/or custom behavior.\r\n * The external interface represents the basic interface for purchasing tokens, and conform\r\n * the base architecture for crowdsales. They are *not* intended to be modified / overridden.\r\n * The internal interface conforms the extensible and modifiable surface of crowdsales. Override\r\n * the methods to add functionality. Consider using 'super' where appropriate to concatenate\r\n * behavior.\r\n */\r\ncontract Crowdsale {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 public rate;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  /**\r\n   * Event for token purchase logging\r\n   * @param purchaser who paid for the tokens\r\n   * @param beneficiary who got the tokens\r\n   * @param value weis paid for purchase\r\n   * @param amount amount of tokens purchased\r\n   */\r\n  event TokenPurchase(\r\n    address indexed purchaser,\r\n    address indexed beneficiary,\r\n    uint256 value,\r\n    uint256 amount\r\n  );\r\n\r\n  /**\r\n   * @param _rate Number of token units a buyer gets per wei\r\n   * @param _wallet Address where collected funds will be forwarded to\r\n   * @param _token Address of the token being sold\r\n   */\r\n  constructor(uint256 _rate, address _wallet, ERC20 _token) public {\r\n    require(_rate > 0);\r\n    require(_wallet != address(0));\r\n    require(_token != address(0));\r\n\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Crowdsale external interface\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev fallback function ***DO NOT OVERRIDE***\r\n   */\r\n  function () external payable {\r\n    buyTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev low level token purchase ***DO NOT OVERRIDE***\r\n   * @param _beneficiary Address performing the token purchase\r\n   */\r\n  function buyTokens(address _beneficiary) public payable {\r\n\r\n    uint256 weiAmount = msg.value;\r\n    _preValidatePurchase(_beneficiary, weiAmount);\r\n\r\n    // calculate token amount to be created\r\n    uint256 tokens = _getTokenAmount(weiAmount);\r\n\r\n    // update state\r\n    weiRaised = weiRaised.add(weiAmount);\r\n\r\n    _processPurchase(_beneficiary, tokens);\r\n    emit TokenPurchase(\r\n      msg.sender,\r\n      _beneficiary,\r\n      weiAmount,\r\n      tokens\r\n    );\r\n\r\n    _updatePurchasingState(_beneficiary, weiAmount);\r\n\r\n    _forwardFunds();\r\n    _postValidatePurchase(_beneficiary, weiAmount);\r\n  }\r\n\r\n  // -----------------------------------------\r\n  // Internal interface (extensible)\r\n  // -----------------------------------------\r\n\r\n  /**\r\n   * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations.\r\n   * Example from CappedCrowdsale.sol's _preValidatePurchase method: \r\n   *   super._preValidatePurchase(_beneficiary, _weiAmount);\r\n   *   require(weiRaised.add(_weiAmount) <= cap);\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    require(_beneficiary != address(0));\r\n    require(_weiAmount != 0);\r\n  }\r\n\r\n  /**\r\n   * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _postValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens.\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    token.safeTransfer(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens.\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _tokenAmount Number of tokens to be purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    _deliverTokens(_beneficiary, _tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.)\r\n   * @param _beneficiary Address receiving the tokens\r\n   * @param _weiAmount Value in wei involved in the purchase\r\n   */\r\n  function _updatePurchasingState(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    // optional override\r\n  }\r\n\r\n  /**\r\n   * @dev Override to extend the way in which ether is converted to tokens.\r\n   * @param _weiAmount Value in wei to be converted into tokens\r\n   * @return Number of tokens that can be purchased with the specified _weiAmount\r\n   */\r\n  function _getTokenAmount(uint256 _weiAmount)\r\n    internal view returns (uint256)\r\n  {\r\n    return _weiAmount.mul(rate);\r\n  }\r\n\r\n  /**\r\n   * @dev Determines how ETH is stored/forwarded on purchases.\r\n   */\r\n  function _forwardFunds() internal {\r\n    wallet.transfer(msg.value);\r\n  }\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/validation/IndividuallyCappedCrowdsale.sol\r\n\r\n/**\r\n * @title IndividuallyCappedCrowdsale\r\n * @dev Crowdsale with per-user caps.\r\n */\r\ncontract IndividuallyCappedCrowdsale is Ownable, Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public contributions;\r\n  mapping(address => uint256) public caps;\r\n\r\n  /**\r\n   * @dev Sets a specific user's maximum contribution.\r\n   * @param _beneficiary Address to be capped\r\n   * @param _cap Wei limit for individual contribution\r\n   */\r\n  function setUserCap(address _beneficiary, uint256 _cap) external onlyOwner {\r\n    caps[_beneficiary] = _cap;\r\n  }\r\n\r\n  /**\r\n   * @dev Sets a group of users' maximum contribution.\r\n   * @param _beneficiaries List of addresses to be capped\r\n   * @param _cap Wei limit for individual contribution\r\n   */\r\n  function setGroupCap(\r\n    address[] _beneficiaries,\r\n    uint256 _cap\r\n  )\r\n    external\r\n    onlyOwner\r\n  {\r\n    for (uint256 i = 0; i < _beneficiaries.length; i++) {\r\n      caps[_beneficiaries[i]] = _cap;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the cap of a specific user.\r\n   * @param _beneficiary Address whose cap is to be checked\r\n   * @return Current cap for individual user\r\n   */\r\n  function getUserCap(address _beneficiary) public view returns (uint256) {\r\n    return caps[_beneficiary];\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the amount contributed so far by a sepecific user.\r\n   * @param _beneficiary Address of contributor\r\n   * @return User contribution so far\r\n   */\r\n  function getUserContribution(address _beneficiary)\r\n    public view returns (uint256)\r\n  {\r\n    return contributions[_beneficiary];\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring purchase to respect the user's funding cap.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n    require(contributions[_beneficiary].add(_weiAmount) <= caps[_beneficiary]);\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior to update user contributions\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _updatePurchasingState(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    super._updatePurchasingState(_beneficiary, _weiAmount);\r\n    contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol\r\n\r\n/**\r\n * @title CappedCrowdsale\r\n * @dev Crowdsale with a limit for total contributions.\r\n */\r\ncontract CappedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public cap;\r\n\r\n  /**\r\n   * @dev Constructor, takes maximum amount of wei accepted in the crowdsale.\r\n   * @param _cap Max amount of wei to be contributed\r\n   */\r\n  constructor(uint256 _cap) public {\r\n    require(_cap > 0);\r\n    cap = _cap;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the cap has been reached.\r\n   * @return Whether the cap was reached\r\n   */\r\n  function capReached() public view returns (bool) {\r\n    return weiRaised >= cap;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring purchase to respect the funding cap.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n    require(weiRaised.add(_weiAmount) <= cap);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol\r\n\r\n/**\r\n * @title TimedCrowdsale\r\n * @dev Crowdsale accepting contributions only within a time frame.\r\n */\r\ncontract TimedCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  /**\r\n   * @dev Reverts if not in crowdsale time range.\r\n   */\r\n  modifier onlyWhileOpen {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp >= openingTime && block.timestamp <= closingTime);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Constructor, takes crowdsale opening and closing times.\r\n   * @param _openingTime Crowdsale opening time\r\n   * @param _closingTime Crowdsale closing time\r\n   */\r\n  constructor(uint256 _openingTime, uint256 _closingTime) public {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime >= block.timestamp);\r\n    require(_closingTime >= _openingTime);\r\n\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open has already elapsed.\r\n   * @return Whether crowdsale period has elapsed\r\n   */\r\n  function hasClosed() public view returns (bool) {\r\n    // solium-disable-next-line security/no-block-members\r\n    return block.timestamp > closingTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Extend parent behavior requiring to be within contributing period\r\n   * @param _beneficiary Token purchaser\r\n   * @param _weiAmount Amount of wei contributed\r\n   */\r\n  function _preValidatePurchase(\r\n    address _beneficiary,\r\n    uint256 _weiAmount\r\n  )\r\n    internal\r\n    onlyWhileOpen\r\n  {\r\n    super._preValidatePurchase(_beneficiary, _weiAmount);\r\n  }\r\n\r\n}\r\n\r\n// File: openzeppelin-solidity/contracts/crowdsale/emission/AllowanceCrowdsale.sol\r\n\r\n/**\r\n * @title AllowanceCrowdsale\r\n * @dev Extension of Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale.\r\n */\r\ncontract AllowanceCrowdsale is Crowdsale {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  address public tokenWallet;\r\n\r\n  /**\r\n   * @dev Constructor, takes token wallet address.\r\n   * @param _tokenWallet Address holding the tokens, which has approved allowance to the crowdsale\r\n   */\r\n  constructor(address _tokenWallet) public {\r\n    require(_tokenWallet != address(0));\r\n    tokenWallet = _tokenWallet;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks the amount of tokens left in the allowance.\r\n   * @return Amount of tokens left in the allowance\r\n   */\r\n  function remainingTokens() public view returns (uint256) {\r\n    return token.allowance(tokenWallet, this);\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides parent behavior by transferring tokens from wallet.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _tokenAmount Amount of tokens purchased\r\n   */\r\n  function _deliverTokens(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    token.safeTransferFrom(tokenWallet, _beneficiary, _tokenAmount);\r\n  }\r\n}\r\n\r\n// File: contracts/crowdsale/distribution/PostDeliveryCrowdsale.sol\r\n\r\n/**\r\n * @title PostDeliveryCrowdsale\r\n * @dev Crowdsale that locks tokens from withdrawal until it ends.\r\n */\r\ncontract PostDeliveryCrowdsale is TimedCrowdsale {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) public balances;\r\n\r\n  /// @dev Withdraw tokens only after crowdsale ends.\r\n  function withdrawTokens() public {\r\n    _withdrawTokens(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw tokens only after crowdsale ends.\r\n   * @param _beneficiary Token purchaser\r\n   */\r\n  function _withdrawTokens(address _beneficiary) internal {\r\n    require(hasClosed(), \"Crowdsale not closed.\");\r\n    uint256 amount = balances[_beneficiary];\r\n    require(amount > 0, \"Beneficiary has zero balance.\");\r\n    balances[_beneficiary] = 0;\r\n    _deliverTokens(_beneficiary, amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Overrides parent by storing balances instead of issuing tokens right away.\r\n   * @param _beneficiary Token purchaser\r\n   * @param _tokenAmount Amount of tokens purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/TokenCrowdsale.sol\r\n\r\n/**\r\n * @title TokenCrowdsale\r\n * @dev This is a ERC20 token crowdsale that will sell tokens util\r\n * the cap is reached, time expired or the allowance is spent.\r\n */\r\n// solium-disable-next-line\r\ncontract TokenCrowdsale\r\n  is\r\n    HasNoTokens,\r\n    HasNoContracts,\r\n    TimedCrowdsale,\r\n    CappedCrowdsale,\r\n    IndividuallyCappedCrowdsale,\r\n    PostDeliveryCrowdsale,\r\n    AllowanceCrowdsale\r\n{\r\n\r\n  // When withdrawals open\r\n  uint256 public withdrawTime;\r\n\r\n  // Amount of tokens sold\r\n  uint256 public tokensSold;\r\n\r\n  // Amount of tokens delivered\r\n  uint256 public tokensDelivered;\r\n\r\n  constructor(\r\n    uint256 _rate,\r\n    address _wallet,\r\n    ERC20 _token,\r\n    address _tokenWallet,\r\n    uint256 _cap,\r\n    uint256 _openingTime,\r\n    uint256 _closingTime,\r\n    uint256 _withdrawTime\r\n  )\r\n    public\r\n    Crowdsale(_rate, _wallet, _token)\r\n    TimedCrowdsale(_openingTime, _closingTime)\r\n    CappedCrowdsale(_cap)\r\n    AllowanceCrowdsale(_tokenWallet)\r\n  {\r\n    require(_withdrawTime >= _closingTime, \"Withdrawals should open after crowdsale closes.\");\r\n    withdrawTime = _withdrawTime;\r\n  }\r\n\r\n  /**\r\n   * @dev Checks whether the period in which the crowdsale is open\r\n   * has already elapsed or cap was reached.\r\n   * @return Whether crowdsale has ended\r\n   */\r\n  function hasEnded() public view returns (bool) {\r\n    return hasClosed() || capReached();\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw tokens only after crowdsale ends.\r\n   * @param _beneficiary Token purchaser\r\n   */\r\n  function withdrawTokens(address _beneficiary) public {\r\n    _withdrawTokens(_beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw tokens only after crowdsale ends.\r\n   * @param _beneficiaries List of token purchasers\r\n   */\r\n  function withdrawTokens(address[] _beneficiaries) public {\r\n    for (uint32 i = 0; i < _beneficiaries.length; i ++) {\r\n      _withdrawTokens(_beneficiaries[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev We use this function to store the total amount of tokens sold\r\n   * @param _beneficiary Token purchaser\r\n   * @param _tokenAmount Amount of tokens purchased\r\n   */\r\n  function _processPurchase(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    super._processPurchase(_beneficiary, _tokenAmount);\r\n    tokensSold = tokensSold.add(_tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev We use this function to store the total amount of tokens delivered\r\n   * @param _beneficiary Address performing the token purchase\r\n   * @param _tokenAmount Number of tokens to be emitted\r\n   */\r\n  function _deliverTokens(\r\n    address _beneficiary,\r\n    uint256 _tokenAmount\r\n  )\r\n    internal\r\n  {\r\n    super._deliverTokens(_beneficiary, _tokenAmount);\r\n    tokensDelivered = tokensDelivered.add(_tokenAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw tokens only after crowdsale ends.\r\n   * @param _beneficiary Token purchaser\r\n   */\r\n  function _withdrawTokens(address _beneficiary) internal {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp > withdrawTime, \"Withdrawals not open.\");\r\n    super._withdrawTokens(_beneficiary);\r\n  }\r\n\r\n}\r\n\r\n// File: contracts/TokenDistributor.sol\r\n\r\n/**\r\n * @title TokenDistributor\r\n * @dev This is a token distribution contract used to distribute tokens and create a public Crowdsale.\r\n */\r\ncontract TokenDistributor is HasNoEther, Finalizable {\r\n  using SafeMath for uint256;\r\n  using SafeERC20 for ERC20;\r\n\r\n  // We also declare Factory.ContractInstantiation here to read it in truffle logs\r\n  // https://github.com/trufflesuite/truffle/issues/555\r\n  event ContractInstantiation(address sender, address instantiation);\r\n  event CrowdsaleInstantiated(address sender, address instantiation, uint256 allowance);\r\n\r\n  /// Party (team multisig) who is in the control of the token pool.\r\n  /// @notice this will be different from the owner address (scripted) that calls this contract.\r\n  address public benefactor;\r\n\r\n  // How many token units a buyer gets per wei.\r\n  // The rate is the conversion between wei and the smallest and indivisible token unit.\r\n  // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK\r\n  // 1 wei will give you 1 unit, or 0.001 TOK.\r\n  uint256 public rate;\r\n\r\n   // Address where funds are collected\r\n  address public wallet;\r\n\r\n  // The token being sold\r\n  ERC20 public token;\r\n\r\n  // Max cap for presale + crowdsale\r\n  uint256 public cap;\r\n\r\n  // Crowdsale is open in this period\r\n  uint256 public openingTime;\r\n  uint256 public closingTime;\r\n\r\n  // When withdrawals open\r\n  uint256 public withdrawTime;\r\n\r\n  // Amount of wei raised\r\n  uint256 public weiRaised;\r\n\r\n  // Crowdsale that is created after the presale distribution is finalized\r\n  TokenCrowdsale public crowdsale;\r\n\r\n  // Escrow contract used to lock team tokens until crowdsale ends\r\n  TokenTimelockEscrow public presaleEscrow;\r\n\r\n  // Escrow contract used to lock bonus tokens\r\n  TokenTimelockEscrow public bonusEscrow;\r\n\r\n  // Factory used to create individual time locked token contracts\r\n  TokenTimelockFactory public timelockFactory;\r\n\r\n  // Factory used to create individual vesting token contracts\r\n  TokenVestingFactory public vestingFactory;\r\n\r\n  /// @dev Throws if called before the crowdsale is created.\r\n  modifier onlyIfCrowdsale() {\r\n    require(crowdsale != address(0), \"Crowdsale not started.\");\r\n    _;\r\n  }\r\n\r\n  constructor(\r\n    address _benefactor,\r\n    uint256 _rate,\r\n    address _wallet,\r\n    ERC20 _token,\r\n    uint256 _cap,\r\n    uint256 _openingTime,\r\n    uint256 _closingTime,\r\n    uint256 _withdrawTime,\r\n    uint256 _bonusTime\r\n  )\r\n    public\r\n  {\r\n    require(address(_benefactor) != address(0), \"Benefactor address should not be 0x0.\");\r\n    require(_rate > 0, \"Rate should not be > 0.\");\r\n    require(_wallet != address(0), \"Wallet address should not be 0x0.\");\r\n    require(address(_token) != address(0), \"Token address should not be 0x0.\");\r\n    require(_cap > 0, \"Cap should be > 0.\");\r\n    // solium-disable-next-line security/no-block-members\r\n    require(_openingTime > block.timestamp, \"Opening time should be in the future.\");\r\n    require(_closingTime > _openingTime, \"Closing time should be after opening.\");\r\n    require(_withdrawTime >= _closingTime, \"Withdrawals should open after crowdsale closes.\");\r\n    require(_bonusTime > _withdrawTime, \"Bonus time should be set after withdrawals open.\");\r\n\r\n    benefactor = _benefactor;\r\n    rate = _rate;\r\n    wallet = _wallet;\r\n    token = _token;\r\n    cap = _cap;\r\n    openingTime = _openingTime;\r\n    closingTime = _closingTime;\r\n    withdrawTime = _withdrawTime;\r\n\r\n    presaleEscrow = new TokenTimelockEscrowImpl(_token, _withdrawTime);\r\n    bonusEscrow = new TokenTimelockEscrowImpl(_token, _bonusTime);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets a specific user's maximum contribution.\r\n   * @param _beneficiary Address to be capped\r\n   * @param _cap Wei limit for individual contribution\r\n   */\r\n  function setUserCap(address _beneficiary, uint256 _cap) external onlyOwner onlyIfCrowdsale {\r\n    crowdsale.setUserCap(_beneficiary, _cap);\r\n  }\r\n\r\n  /**\r\n   * @dev Sets a group of users' maximum contribution.\r\n   * @param _beneficiaries List of addresses to be capped\r\n   * @param _cap Wei limit for individual contribution\r\n   */\r\n  function setGroupCap(address[] _beneficiaries, uint256 _cap) external onlyOwner onlyIfCrowdsale {\r\n    crowdsale.setGroupCap(_beneficiaries, _cap);\r\n  }\r\n\r\n  /**\r\n   * @dev Returns the cap of a specific user.\r\n   * @param _beneficiary Address whose cap is to be checked\r\n   * @return Current cap for individual user\r\n   */\r\n  function getUserCap(address _beneficiary) public view onlyIfCrowdsale returns (uint256) {\r\n    return crowdsale.getUserCap(_beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to store the sent amount as credit to be pulled when withdrawals open.\r\n   * @param _dest The destination address of the funds.\r\n   * @param _amount The amount to transfer.\r\n   */\r\n  function depositPresale(address _dest, uint256 _amount) public onlyOwner onlyNotFinalized {\r\n    require(_dest != address(this), \"Transfering tokens to this contract address is not allowed.\");\r\n    require(token.allowance(benefactor, this) >= _amount, \"Not enough allowance.\");\r\n    token.transferFrom(benefactor, this, _amount);\r\n    token.approve(presaleEscrow, _amount);\r\n    presaleEscrow.deposit(_dest, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to store the sent amount as credit to be pulled when withdrawals open.\r\n   * @param _dest The destination address of the funds.\r\n   * @param _amount The amount to transfer.\r\n   * @param _weiAmount The amount of wei exchanged for the tokens.\r\n   */\r\n  function depositPresale(address _dest, uint256 _amount, uint256 _weiAmount) public {\r\n    require(cap >= weiRaised.add(_weiAmount), \"Cap reached.\");\r\n    depositPresale(_dest, _amount);\r\n    weiRaised = weiRaised.add(_weiAmount);\r\n  }\r\n\r\n  /// @dev Withdraw accumulated balance, called by beneficiary.\r\n  function withdrawPresale() public {\r\n    presaleEscrow.withdraw(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw accumulated balance for beneficiary.\r\n   * @param _beneficiary Address of beneficiary\r\n   */\r\n  function withdrawPresale(address _beneficiary) public {\r\n    presaleEscrow.withdraw(_beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw accumulated balances for beneficiaries.\r\n   * @param _beneficiaries List of addresses of beneficiaries\r\n   */\r\n  function withdrawPresale(address[] _beneficiaries) public {\r\n    for (uint32 i = 0; i < _beneficiaries.length; i ++) {\r\n      presaleEscrow.withdraw(_beneficiaries[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to store the sent amount as credit to be pulled from token timelock contract.\r\n   * @param _dest The destination address of the funds.\r\n   * @param _amount The amount to transfer.\r\n   */\r\n  function depositBonus(address _dest, uint256 _amount) public onlyOwner onlyNotFinalized {\r\n    require(_dest != address(this), \"Transfering tokens to this contract address is not allowed.\");\r\n    require(token.allowance(benefactor, this) >= _amount, \"Not enough allowance.\");\r\n    token.transferFrom(benefactor, this, _amount);\r\n    token.approve(bonusEscrow, _amount);\r\n    bonusEscrow.deposit(_dest, _amount);\r\n  }\r\n\r\n  /// @dev Withdraw accumulated balance, called by beneficiary.\r\n  function withdrawBonus() public {\r\n    bonusEscrow.withdraw(msg.sender);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw accumulated balance for beneficiary.\r\n   * @param _beneficiary Address of beneficiary\r\n   */\r\n  function withdrawBonus(address _beneficiary) public {\r\n    bonusEscrow.withdraw(_beneficiary);\r\n  }\r\n\r\n  /**\r\n   * @dev Withdraw accumulated balances for beneficiaries.\r\n   * @param _beneficiaries List of addresses of beneficiaries\r\n   */\r\n  function withdrawBonus(address[] _beneficiaries) public {\r\n    for (uint32 i = 0; i < _beneficiaries.length; i ++) {\r\n      bonusEscrow.withdraw(_beneficiaries[i]);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to deposit tokens and bonus as credit to be pulled by benefactor.\r\n   * @param _dest The destination address of the funds.\r\n   * @param _amount The amount to transfer.\r\n   * @param _bonusAmount The bonus amount to transfer.\r\n   */\r\n  function depositPresaleWithBonus(\r\n    address _dest,\r\n    uint256 _amount,\r\n    uint256 _bonusAmount\r\n  )\r\n    public\r\n  {\r\n    depositPresale(_dest, _amount);\r\n    depositBonus(_dest, _bonusAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to deposit tokens and bonus as credit to be pulled by benefactor.\r\n   * @param _dest The destination address of the funds.\r\n   * @param _amount The amount to transfer.\r\n   * @param _weiAmount The amount of wei exchanged for the tokens.\r\n   * @param _bonusAmount The bonus amount to transfer.\r\n   */\r\n  function depositPresaleWithBonus(\r\n    address _dest,\r\n    uint256 _amount,\r\n    uint256 _weiAmount,\r\n    uint256 _bonusAmount\r\n  )\r\n    public\r\n  {\r\n    depositPresale(_dest, _amount, _weiAmount);\r\n    depositBonus(_dest, _bonusAmount);\r\n  }\r\n\r\n  /**\r\n   * @dev Setter for TokenTimelockFactory because of gas limits\r\n   * @param _timelockFactory Address of the TokenTimelockFactory contract\r\n   */\r\n  function setTokenTimelockFactory(address _timelockFactory) public onlyOwner {\r\n    require(_timelockFactory != address(0), \"Factory address should not be 0x0.\");\r\n    require(timelockFactory == address(0), \"Factory already initalizied.\");\r\n    timelockFactory = TokenTimelockFactory(_timelockFactory);\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to store the sent amount as credit to be pulled\r\n   * from token timelock contract.\r\n   * @param _dest The destination address of the funds.\r\n   * @param _amount The amount to transfer.\r\n   * @param _releaseTime The release times after which the tokens can be withdrawn.\r\n   * @return Returns wallet address.\r\n   */\r\n  function depositAndLock(\r\n    address _dest,\r\n    uint256 _amount,\r\n    uint256 _releaseTime\r\n  )\r\n    public\r\n    onlyOwner\r\n    onlyNotFinalized\r\n    returns (address tokenWallet)\r\n  {\r\n    require(token.allowance(benefactor, this) >= _amount, \"Not enough allowance.\");\r\n    require(_dest != address(0), \"Destination address should not be 0x0.\");\r\n    require(_dest != address(this), \"Transfering tokens to this contract address is not allowed.\");\r\n    require(_releaseTime >= withdrawTime, \"Tokens should unlock after withdrawals open.\");\r\n    tokenWallet = timelockFactory.create(\r\n      token,\r\n      _dest,\r\n      _releaseTime\r\n    );\r\n    token.transferFrom(benefactor, tokenWallet, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev Setter for TokenVestingFactory because of gas limits\r\n   * @param _vestingFactory Address of the TokenVestingFactory contract\r\n   */\r\n  function setTokenVestingFactory(address _vestingFactory) public onlyOwner {\r\n    require(_vestingFactory != address(0), \"Factory address should not be 0x0.\");\r\n    require(vestingFactory == address(0), \"Factory already initalizied.\");\r\n    vestingFactory = TokenVestingFactory(_vestingFactory);\r\n  }\r\n\r\n  /**\r\n   * @dev Called by the payer to store the sent amount as credit to be pulled\r\n   * from token vesting contract.\r\n   * @param _dest The destination address of the funds.\r\n   * @param _amount The amount to transfer.\r\n   * @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n   * @param _start the time (as Unix time) at which point vesting starts\r\n   * @param _duration duration in seconds of the period in which the tokens will vest\r\n   * @return Returns wallet address.\r\n   */\r\n  function depositAndVest(\r\n    address _dest,\r\n    uint256 _amount,\r\n    uint256 _start,\r\n    uint256 _cliff,\r\n    uint256 _duration\r\n  )\r\n    public\r\n    onlyOwner\r\n    onlyNotFinalized\r\n    returns (address tokenWallet)\r\n  {\r\n    require(token.allowance(benefactor, this) >= _amount, \"Not enough allowance.\");\r\n    require(_dest != address(0), \"Destination address should not be 0x0.\");\r\n    require(_dest != address(this), \"Transfering tokens to this contract address is not allowed.\");\r\n    require(_start.add(_cliff) >= withdrawTime, \"Tokens should unlock after withdrawals open.\");\r\n    bool revocable = false;\r\n    tokenWallet = vestingFactory.create(\r\n      _dest,\r\n      _start,\r\n      _cliff,\r\n      _duration,\r\n      revocable\r\n    );\r\n    token.transferFrom(benefactor, tokenWallet, _amount);\r\n  }\r\n\r\n  /**\r\n   * @dev In case there are any unsold tokens, they are claimed by the owner\r\n   * @param _beneficiary Address where claimable tokens are going to be transfered\r\n   */\r\n  function claimUnsold(address _beneficiary) public onlyIfCrowdsale onlyOwner {\r\n    // solium-disable-next-line security/no-block-members\r\n    require(block.timestamp > withdrawTime, \"Withdrawals not open.\");\r\n    uint256 sold = crowdsale.tokensSold();\r\n    uint256 delivered = crowdsale.tokensDelivered();\r\n    uint256 toDeliver = sold.sub(delivered);\r\n\r\n    uint256 balance = token.balanceOf(this);\r\n    uint256 claimable = balance.sub(toDeliver);\r\n\r\n    if (claimable > 0) {\r\n      token.safeTransfer(_beneficiary, claimable);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @dev Finalization logic that will create a Crowdsale with provided parameters\r\n   * and calculated cap depending on the amount raised in presale.\r\n   */\r\n  function finalization() internal {\r\n    uint256 crowdsaleCap = cap.sub(weiRaised);\r\n    if (crowdsaleCap < 1 ether) {\r\n      // Cap reached in presale, no crowdsale necessary\r\n      return;\r\n    }\r\n\r\n    address tokenWallet = this;\r\n    crowdsale = new TokenCrowdsale(\r\n      rate,\r\n      wallet,\r\n      token,\r\n      tokenWallet,\r\n      crowdsaleCap,\r\n      openingTime,\r\n      closingTime,\r\n      withdrawTime\r\n    );\r\n    uint256 allowance = token.allowance(benefactor, this);\r\n    token.transferFrom(benefactor, this, allowance);\r\n    token.approve(crowdsale, allowance);\r\n    emit CrowdsaleInstantiated(msg.sender, crowdsale, allowance);\r\n  }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"withdrawBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bonusEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_timelockFactory\",\"type\":\"address\"}],\"name\":\"setTokenTimelockFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_start\",\"type\":\"uint256\"},{\"name\":\"_cliff\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint256\"}],\"name\":\"depositAndVest\",\"outputs\":[{\"name\":\"tokenWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"cap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"},{\"name\":\"_bonusAmount\",\"type\":\"uint256\"}],\"name\":\"depositPresaleWithBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"weiRaised\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"withdrawTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"closingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalize\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"wallet\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timelockFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"}],\"name\":\"withdrawPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"depositBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"claimUnsold\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"benefactor\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"getUserCap\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isFinalized\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"crowdsale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"reclaimEther\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiaries\",\"type\":\"address[]\"},{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setGroupCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_releaseTime\",\"type\":\"uint256\"}],\"name\":\"depositAndLock\",\"outputs\":[{\"name\":\"tokenWallet\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"openingTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_bonusAmount\",\"type\":\"uint256\"}],\"name\":\"depositPresaleWithBonus\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"}],\"name\":\"setUserCap\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"withdrawPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"presaleEscrow\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dest\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_weiAmount\",\"type\":\"uint256\"}],\"name\":\"depositPresale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingFactory\",\"type\":\"address\"}],\"name\":\"setTokenVestingFactory\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"vestingFactory\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_benefactor\",\"type\":\"address\"},{\"name\":\"_rate\",\"type\":\"uint256\"},{\"name\":\"_wallet\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_cap\",\"type\":\"uint256\"},{\"name\":\"_openingTime\",\"type\":\"uint256\"},{\"name\":\"_closingTime\",\"type\":\"uint256\"},{\"name\":\"_withdrawTime\",\"type\":\"uint256\"},{\"name\":\"_bonusTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"instantiation\",\"type\":\"address\"}],\"name\":\"ContractInstantiation\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"instantiation\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"allowance\",\"type\":\"uint256\"}],\"name\":\"CrowdsaleInstantiated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[],\"name\":\"Finalized\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"TokenDistributor","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"500","ConstructorArguments":"0000000000000000000000001f2d70b965e56fa30e32a797bef5200884112f340000000000000000000000000000000000000000000000000000000000001aee000000000000000000000000cd5fb5d52ead04eb8349befa27cc935d931350b2000000000000000000000000d07d9fe2d2cc067015e2b4917d24933804f42cfa00000000000000000000000000000000000000000000098774738bc822200000000000000000000000000000000000000000000000000000000000005b9d1060000000000000000000000000000000000000000000000000000000005ba3a7e0000000000000000000000000000000000000000000000000000000005bb0d6e0000000000000000000000000000000000000000000000000000000005c277de0","Library":"","SwarmSource":"bzzr://a6a2e4cf795e3d05cb1355f5110b8a27b5045f1b299965146f194de70c0c7340"}]}