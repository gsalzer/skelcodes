{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ninterface POUInterface {\r\n\r\n    function totalStaked(address) external view returns(uint256);\r\n    function numApplications(address) external view returns(uint256);\r\n\r\n}\r\n\r\n\r\ninterface SaleInterface {\r\n    function saleTokensPerUnit() external view returns(uint256);\r\n    function extraTokensPerUnit() external view returns(uint256);\r\n    function unitContributions(address) external view returns(uint256);\r\n    function disbursementHandler() external view returns(address);\r\n}\r\n\r\n\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n/// @title Interface for token controllers. The controller specifies whether a transfer can be done.\r\ncontract TokenControllerI {\r\n\r\n    /// @dev Specifies whether a transfer is allowed or not.\r\n    /// @return True if the transfer is allowed\r\n    function transferAllowed(address _from, address _to)\r\n        external\r\n        view\r\n        returns (bool);\r\n}\r\n\r\n\r\n\r\n\r\ncontract FoamTokenController is TokenControllerI, Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    POUInterface public registry;\r\n    POUInterface public signaling;\r\n    SaleInterface public sale;\r\n    SaleInterface public saft;\r\n\r\n    uint256 public platformLaunchDate;\r\n\r\n    uint256 public saleTokensPerUnit;\r\n    uint256 public extraTokensPerUnit;\r\n\r\n    mapping (address => bool) public isProtocolContract;\r\n\r\n    mapping(address => address) public proposedPair;\r\n    mapping(address => address) public pair;\r\n\r\n    mapping(address => bool) public isBlacklisted;\r\n    mapping(address => bool) public pouCompleted;\r\n\r\n    event ProposeWhitelisted(address _whitelistor, address _whitelistee);\r\n    event ConfirmWhitelisted(address _whitelistor, address _whitelistee);\r\n    event PoUCompleted(address contributor, address secondAddress, bool isComplete);\r\n\r\n    // this is one of the TF multisigs.\r\n    // We can then send the tokens onwards to wherever FOAM request for the tokens to be.\r\n    address acceptedAddress = 0x36A9b165ef64767230A7Aded71B04F0911bB1283;\r\n\r\n    constructor(POUInterface _registry, POUInterface _signaling, SaleInterface _sale, SaleInterface _saft, uint256 _launchDate) public {\r\n        require(_registry != address(0), \"registry contract must have a valid address\");\r\n        require(_signaling != address(0), \"signaling contract must have a valid address\");\r\n        require(_sale != address(0), \"sale contract must have a valid address\");\r\n        require(_saft != address(0), \"saft contract must have a valid address\");\r\n        require(_launchDate != 0 && _launchDate <= now, \"platform cannot have launched in the future\");\r\n\r\n        registry = _registry;\r\n        signaling = _signaling;\r\n        sale = _sale;\r\n        saft = _saft;\r\n        platformLaunchDate = _launchDate;\r\n\r\n        isProtocolContract[address(registry)] = true;\r\n        isProtocolContract[address(signaling)] = true;\r\n\r\n        saleTokensPerUnit = sale.saleTokensPerUnit();\r\n        extraTokensPerUnit = sale.extraTokensPerUnit();\r\n    }\r\n\r\n    function setWhitelisted(address _whitelisted) public {\r\n        require(_whitelisted != 0, \"cannot whitelist the zero address\");\r\n\r\n        require(pair[msg.sender] == 0, \"sender's address must not be paired yet\");\r\n        require(pair[_whitelisted] == 0, \"proposed whitelist address must not be paired yet\");\r\n\r\n        require(sale.unitContributions(msg.sender) != 0, \"sender must have purchased tokens during the sale\");\r\n        require(sale.unitContributions(_whitelisted) == 0, \"proposed whitelist address must not have purchased tokens during the sale\");\r\n\r\n        proposedPair[msg.sender] = _whitelisted;\r\n        emit ProposeWhitelisted(msg.sender, _whitelisted);\r\n    }\r\n\r\n    function confirmWhitelisted(address _whitelistor) public {\r\n        require(pair[msg.sender] == 0, \"sender's address must not be paired yet\");\r\n        require(pair[_whitelistor] == 0, \"whitelistor's address must not be paired yet\");\r\n\r\n        require(proposedPair[_whitelistor] == msg.sender, \"whitelistor's proposed address must be the sender\");\r\n\r\n        pair[msg.sender] = _whitelistor;\r\n        pair[_whitelistor] = msg.sender;\r\n\r\n        emit ConfirmWhitelisted(_whitelistor, msg.sender);\r\n    }\r\n\r\n    function setAcceptedAddress(address _newAcceptedAddress) public onlyOwner {\r\n      require(_newAcceptedAddress != address(0), \"blacklist bypass address cannot be the zero address\");\r\n      acceptedAddress = _newAcceptedAddress;\r\n    }\r\n\r\n    function pairAddresses(address[] froms, address[] tos) public onlyOwner {\r\n      require(froms.length == tos.length, \"pair arrays must be same size\");\r\n      for (uint256 i = 0; i < froms.length; i++) {\r\n        pair[froms[i]] = tos[i];\r\n        pair[tos[i]] = froms[i];\r\n      }\r\n    }\r\n\r\n    function blacklistAddresses(address[] _addresses, bool _isBlacklisted) public onlyOwner {\r\n        for (uint256 i = 0; i < _addresses.length; i++) {\r\n            isBlacklisted[_addresses[i]] = _isBlacklisted;\r\n        }\r\n    }\r\n\r\n    function setPoUCompleted(address _user, bool _isCompleted) public onlyOwner {\r\n        pouCompleted[_user] = _isCompleted;\r\n    }\r\n\r\n    function changeRegistry(POUInterface _newRegistry) public onlyOwner {\r\n        require(_newRegistry != address(0), \"registry contract must have a valid address\");\r\n        isProtocolContract[address(registry)] = false;\r\n        isProtocolContract[address(_newRegistry)] = true;\r\n        registry = _newRegistry;\r\n    }\r\n\r\n    function changeSignaling(POUInterface _newSignaling) public onlyOwner {\r\n        require(_newSignaling != address(0), \"signaling contract must have a valid address\");\r\n        isProtocolContract[address(signaling)] = false;\r\n        isProtocolContract[address(_newSignaling)] = true;\r\n        signaling = _newSignaling;\r\n    }\r\n\r\n    function setPlatformLaunchDate(uint256 _launchDate) public onlyOwner {\r\n        require(_launchDate != 0 && _launchDate <= now, \"platform cannot have launched in the future\");\r\n        platformLaunchDate = _launchDate;\r\n    }\r\n\r\n    function setProtocolContract(address _contract, bool _isProtocolContract) public onlyOwner {\r\n        isProtocolContract[_contract] = _isProtocolContract;\r\n    }\r\n\r\n    function setProtocolContracts(address[] _addresses, bool _isProtocolContract) public onlyOwner {\r\n      for (uint256 i = 0; i < _addresses.length; i++) {\r\n        isProtocolContract[_addresses[i]] = _isProtocolContract;\r\n      }\r\n    }\r\n\r\n    function setSaleContract(SaleInterface _sale) public onlyOwner {\r\n      require(_sale != address(0), \"sale contract must have a valid address\");\r\n      sale = _sale;\r\n    }\r\n\r\n    function setSaftContract(SaleInterface _saft) public onlyOwner {\r\n      require(_saft != address(0), \"saft contract must have a valid address\");\r\n      saft = _saft;\r\n    }\r\n\r\n    function transferAllowed(address _from, address _to)\r\n        external\r\n        view\r\n        returns (bool)\r\n    {\r\n        if(isBlacklisted[_from]) {\r\n            return _to == acceptedAddress;\r\n        }\r\n\r\n        bool protocolTransfer = isProtocolContract[_from] || isProtocolContract[_to];\r\n        bool whitelistedTransfer = pair[_from] == _to && pair[_to] == _from;\r\n\r\n        if (protocolTransfer || whitelistedTransfer || platformLaunchDate + 365 days <= now) {\r\n            return true;\r\n        } else if (platformLaunchDate + 45 days > now) {\r\n            return false;\r\n        }\r\n        return purchaseCheck(_from);\r\n    }\r\n\r\n    function purchaseCheck(address _contributor) public returns (bool) {\r\n        if(pouCompleted[_contributor]){\r\n            return true;\r\n        }\r\n\r\n        address secondAddress = pair[_contributor];\r\n        if(secondAddress != address(0) && pouCompleted[secondAddress]) {\r\n            return true;\r\n        }\r\n\r\n        uint256 contributed = sale.unitContributions(_contributor).add(saft.unitContributions(_contributor));\r\n\r\n        if (contributed == 0) {\r\n            if (secondAddress == 0) {\r\n                return true;\r\n            } else {\r\n                contributed = sale.unitContributions(secondAddress).add(saft.unitContributions(secondAddress));\r\n            }\r\n        }\r\n\r\n\r\n        uint256 tokensStaked = registry.totalStaked(_contributor).add(signaling.totalStaked(_contributor));\r\n        uint256 PoICreated = registry.numApplications(_contributor).add(signaling.numApplications(_contributor));\r\n\r\n        if (secondAddress != 0) {\r\n            tokensStaked = tokensStaked.add(registry.totalStaked(secondAddress)).add(signaling.totalStaked(secondAddress));\r\n            PoICreated = PoICreated.add(registry.numApplications(secondAddress)).add(signaling.numApplications(secondAddress));\r\n        }\r\n\r\n        uint256 tokensBought = contributed.mul(saleTokensPerUnit.add(extraTokensPerUnit));\r\n\r\n        bool enoughStaked;\r\n        if (contributed <= 10000) {\r\n            enoughStaked = tokensStaked >= tokensBought.mul(25).div(100);\r\n        } else {\r\n            enoughStaked = tokensStaked >= tokensBought.mul(50).div(100);\r\n        }\r\n\r\n        bool isComplete = enoughStaked && PoICreated >= 10;\r\n        if (isComplete == true) {\r\n          pouCompleted[_contributor] = true;\r\n          if (secondAddress != address(0)) {\r\n            pouCompleted[secondAddress] = true;\r\n          }\r\n          emit PoUCompleted(_contributor, secondAddress, isComplete);\r\n        }\r\n\r\n        return isComplete;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_sale\",\"type\":\"address\"}],\"name\":\"setSaleContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRegistry\",\"type\":\"address\"}],\"name\":\"changeRegistry\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"}],\"name\":\"transferAllowed\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSignaling\",\"type\":\"address\"}],\"name\":\"changeSignaling\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_saft\",\"type\":\"address\"}],\"name\":\"setSaftContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contract\",\"type\":\"address\"},{\"name\":\"_isProtocolContract\",\"type\":\"bool\"}],\"name\":\"setProtocolContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelisted\",\"type\":\"address\"}],\"name\":\"setWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contributor\",\"type\":\"address\"}],\"name\":\"purchaseCheck\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_launchDate\",\"type\":\"uint256\"}],\"name\":\"setPlatformLaunchDate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"platformLaunchDate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"froms\",\"type\":\"address[]\"},{\"name\":\"tos\",\"type\":\"address[]\"}],\"name\":\"pairAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_user\",\"type\":\"address\"},{\"name\":\"_isCompleted\",\"type\":\"bool\"}],\"name\":\"setPoUCompleted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"sale\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pouCompleted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"registry\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"pair\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_isBlacklisted\",\"type\":\"bool\"}],\"name\":\"blacklistAddresses\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"signaling\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_whitelistor\",\"type\":\"address\"}],\"name\":\"confirmWhitelisted\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isProtocolContract\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saft\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"proposedPair\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newAcceptedAddress\",\"type\":\"address\"}],\"name\":\"setAcceptedAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"saleTokensPerUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_addresses\",\"type\":\"address[]\"},{\"name\":\"_isProtocolContract\",\"type\":\"bool\"}],\"name\":\"setProtocolContracts\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"extraTokensPerUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"isBlacklisted\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_registry\",\"type\":\"address\"},{\"name\":\"_signaling\",\"type\":\"address\"},{\"name\":\"_sale\",\"type\":\"address\"},{\"name\":\"_saft\",\"type\":\"address\"},{\"name\":\"_launchDate\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_whitelistor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_whitelistee\",\"type\":\"address\"}],\"name\":\"ProposeWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_whitelistor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_whitelistee\",\"type\":\"address\"}],\"name\":\"ConfirmWhitelisted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"contributor\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"secondAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"isComplete\",\"type\":\"bool\"}],\"name\":\"PoUCompleted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"FoamTokenController","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"300","ConstructorArguments":"0000000000000000000000002832373dddad96bbfb44f1b7da11b6541026bf4000000000000000000000000036f16a0d35b866cdd0f3c3fa39e2ba8f48b099d20000000000000000000000003ce3b6d9372a4d761172a89cf0139129309fa0ae00000000000000000000000096ea349168b9545e1944c194963bb617ce025ff3000000000000000000000000000000000000000000000000000000005bd301c0","Library":"","SwarmSource":"bzzr://ee01510a5282d567b7d547bcd23ee1a570695f39f21151ecb8d58b719993ba11"}]}