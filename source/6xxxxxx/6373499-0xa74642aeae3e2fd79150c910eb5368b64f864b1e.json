{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity^0.4.24;\r\n\r\n/**\r\n                        MOBIUS 2D\r\n                     https://m2d.win \r\n                                       \r\n    This game was inspired by FOMO3D. Our code is much cleaner and more efficient (built from scratch).\r\n    Some useless \"features\" like the teams were not implemented.\r\n \r\n    The Mobius2D game consists of rounds with guaranteed winners!\r\n    You buy \"shares\" (instad of keys) for a given round, and you get returns from investors after you.\r\n    The sare price is constant until the hard deadline, after which it increases exponentially. \r\n    If a round is inactive for a day it can end earlier than the hard deadline.\r\n    If a round runs longer, it is guaranteed to finish not much after the hard deadline (and the last investor gets the big jackpot).\r\n    Additionally, if you invest more than 0.1 ETH you get a chance to win an airdrop and you get bonus shares\r\n    Part of all funds also go to a big final jackpot - the last investor (before a round runs out) wins.\r\n    Payouts work in REAL TIME - you can withdraw your returns at any time!\r\n    Additionally, the first round is an ICO, so you'll also get our tokens by participating!\r\n    !!!!!!!!!!!!!!\r\n    Token holders will receive part of current and future revenue of this and any other game we develop!\r\n    !!!!!!!!!!!!!!\r\n    \r\n    .................................. LAUGHING MAN sssyyhddmN..........................................\r\n    ..........................Nmdyyso+/:--.``` :`  `-`:--:/+ossyhdmN....................................\r\n    ......................Ndhyso/:.`   --.     o.  /+`o::` `` `-:+osyh..................................\r\n    ..................MNdyso/-` /-`/:+./:/..`  +.  //.o +.+::+ -`  `-/sshdN.............................\r\n    ................Ndyso:` ` --:+`o//.-:-```  ...  ``` - /::::/ +..-` ./osh............................\r\n    ..............Nhso/. .-.:/`o--:``   `..-:::oss+::--.``    .:/::/`+-`/../sydN........................\r\n    ............mhso-``-:+./:-:.   .-/+osssssssssssssssssso+:-`  -//o::+:/` .:oyhN......................\r\n    ..........Nhso:`  .+-./ `  .:+sssssso+//:-------:://+ossssso/---.`-`/:-o/ `:syd.....................\r\n    ........Mdyo- +/../`-`  ./osssso/-.`                 ``.:+ossss+:`  `-+`  ` `/sy....................\r\n    ......MNys/` -:-/:    -+ssss+-`                           `.:+ssss/.  `  -+-. .osh..................\r\n    ......mys-  :-/+-`  :osss+-`                                  .:osss+.  `//o:- `/syN................\r\n    ....Mdso. --:-/-  -osss+.                                       `-osss+`  :--://`-sy................\r\n    ....dso-. ++:+  `/sss+.                                           `:osss:  `:.-+  -sy...............\r\n    ..Mdso``+///.` .osss:                                               `/sss+`  :/-.. -syN.............\r\n    ..mss` `+::/  .ssso.                                                  :sss+` `+:/+  -syN............\r\n    ..ys-   ```  .ssso`                                                    -sss+` `:::+:`/sh............\r\n    Mds+ `:/..  `osso`                                                      -sss+  -:`.` `ssN...........\r\n    Mys. `/+::  +sss/........................................................+sss:.....-::+sy..NN.......\r\n    ds+  :-/-  .ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssyyhdN...\r\n    hs: `/+::   :/+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ossssyhNM\r\n    ss. `:::`                    ````                        ```                               ``-+sssyN\r\n    ss` /:-+` `o++:           .:+oooo+/.                 `-/ooooo+-`                               -sssy\r\n    ss  `:/:  `sss/          :ooo++/++os/`              .oso++/++oso.                               osss\r\n    ss``/:--  `sss/         ./.`      `.::              /-.`     ``-/`                             -sssy\r\n    ss.:::-:.  ssso         `            `                                                    ``.-+sssyN\r\n    hs:`:/:/.  /sss.   .++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++oossssyhNM\r\n    ds+ ``     .sss/   -ssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssyyyyhmN...\r\n    Nss.:::::.  +sss.   +sss/........................................osss:...+sss:......../shmNNN.......\r\n    Mds+..-:::` `osso`  `+sss:                                     `+sss:   -sss+  .:-.` `ssN...........\r\n    ..ys- .+.::  .ssso`  `/sss+.                                  -osss:   -sss+` `:++-` /sh............\r\n    ..mss` .-.    .ssso.   :osss/`                              .+ssso.   :sss+` `.:+:` -syN............\r\n    ..Mdso`  `--:` .osss:   `/ssss/.`                        `-+ssso:`  `/sss+` `++.-. -syN.............\r\n    ....dso` -//+-` `/sss+.   ./ossso/-``                `.:+sssso:`  `:osss:  .::+/. -sy...............\r\n    ....Mdso. `-//-`  -osss+.   `-+ssssso+/:-.`````..-:/+osssso/.   `-osss+.` -///-  -sy................\r\n    ......mys- `/://.`  :osss+-`   `-/+osssssssssssssssssso+:.    .:osss+.  .:`..-``/syN................\r\n    ......MNys/` ..+-/:   -+ssss+-`    `.-://++oooo++/:-.`    `.:+ssss/.  .`      .osh..................\r\n    ........Mdyo- `::/.  `  ./osssso/-.`                 ``.:+ossss+:` `  .//`  `/sy....................\r\n    ..........Nhso-     :+:.`  .:+sssssso+//:--------://+ossssso/:.  `::/: --/.:syd.....................\r\n    ............mhso-` ./+--+-:    .-/+osssssssssssssssssso+/-.  .+` `//-/ `::oyhN......................\r\n    ..............Nhso/`   +/:--+.-`    `..-:::////::--.``    .`:/-o`  ./`./sydN........................\r\n    ................Ndys+:` ``--+++-  .:  `.``      `` -.`/:/`.o./::.  ./osh............................\r\n    ..................MNdyso/-` ` :`  +-  :+.o`s ::-/++`s`+/o.-:`  `-/sshdN.............................\r\n    ......................Ndhyso/:.` .+   +/:/ +:/-./:-`+: `` `.:+osyh..................................\r\n    ..........................Nmdyyso+/:--/.``      ``..-:/+ossyhdmN....................................\r\n    ..............................MN..dhhyyssssssssssssyyhddmN..........................................\r\n */\r\n \r\ncontract DSMath {\r\n    function add(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x + y) >= x);\r\n    }\r\n    function sub(uint x, uint y) internal pure returns (uint z) {\r\n        require((z = x - y) <= x);\r\n    }\r\n    function mul(uint x, uint y) internal pure returns (uint z) {\r\n        require(y == 0 || (z = x * y) / y == x);\r\n    }\r\n\r\n    function min(uint x, uint y) internal pure returns (uint z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function max(uint x, uint y) internal pure returns (uint z) {\r\n        return x >= y ? x : y;\r\n    }\r\n    function imin(int x, int y) internal pure returns (int z) {\r\n        return x <= y ? x : y;\r\n    }\r\n    function imax(int x, int y) internal pure returns (int z) {\r\n        return x >= y ? x : y;\r\n    }\r\n\r\n    uint constant WAD = 10 ** 18;\r\n    uint constant RAY = 10 ** 27;\r\n\r\n    function wmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), WAD / 2) / WAD;\r\n    }\r\n    function rmul(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, y), RAY / 2) / RAY;\r\n    }\r\n    function wdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, WAD), y / 2) / y;\r\n    }\r\n    function rdiv(uint x, uint y) internal pure returns (uint z) {\r\n        z = add(mul(x, RAY), y / 2) / y;\r\n    }\r\n\r\n    // This famous algorithm is called \"exponentiation by squaring\"\r\n    // and calculates x^n with x as fixed-point and n as regular unsigned.\r\n    //\r\n    // It's O(log n), instead of O(n) for naive repeated multiplication.\r\n    //\r\n    // These facts are why it works:\r\n    //\r\n    //  If n is even, then x^n = (x^2)^(n/2).\r\n    //  If n is odd,  then x^n = x * x^(n-1),\r\n    //   and applying the equation for even x gives\r\n    //    x^n = x * (x^2)^((n-1) / 2).\r\n    //\r\n    //  Also, EVM division is flooring and\r\n    //    floor[(n-1) / 2] = floor[n / 2].\r\n    //\r\n    function rpow(uint x, uint n) internal pure returns (uint z) {\r\n        z = n % 2 != 0 ? x : RAY;\r\n\r\n        for (n /= 2; n != 0; n /= 2) {\r\n            x = rmul(x, x);\r\n\r\n            if (n % 2 != 0) {\r\n                z = rmul(z, x);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\ncontract DSAuthority {\r\n    function canCall(\r\n        address src, address dst, bytes4 sig\r\n    ) public view returns (bool);\r\n}\r\n\r\ncontract DSAuthEvents {\r\n    event LogSetAuthority (address indexed authority);\r\n    event LogSetOwner     (address indexed owner);\r\n}\r\n\r\ncontract DSAuth is DSAuthEvents {\r\n    DSAuthority  public  authority;\r\n    address      public  owner;\r\n\r\n    constructor() public {\r\n        owner = msg.sender;\r\n        emit LogSetOwner(msg.sender);\r\n    }\r\n\r\n    function setOwner(address owner_)\r\n        public\r\n        auth\r\n    {\r\n        owner = owner_;\r\n        emit LogSetOwner(owner);\r\n    }\r\n\r\n    function setAuthority(DSAuthority authority_)\r\n        public\r\n        auth\r\n    {\r\n        authority = authority_;\r\n        emit LogSetAuthority(authority);\r\n    }\r\n\r\n    modifier auth {\r\n        require(isAuthorized(msg.sender, msg.sig));\r\n        _;\r\n    }\r\n\r\n    function isAuthorized(address src, bytes4 sig) internal view returns (bool) {\r\n        if (src == address(this)) {\r\n            return true;\r\n        } else if (src == owner) {\r\n            return true;\r\n        } else if (authority == DSAuthority(0)) {\r\n            return false;\r\n        } else {\r\n            return authority.canCall(src, this, sig);\r\n        }\r\n    }\r\n}\r\n\r\ninterface MobiusToken {\r\n    function mint(address _to, uint _amount) external;\r\n    function finishMinting() external returns (bool);\r\n    function disburseDividends() external payable;\r\n}\r\n \r\ncontract Mobius2D is DSMath, DSAuth {\r\n    // IPFS hash of the website - can be accessed even if our domain goes down.\r\n    // Just go to any public IPFS gateway and use this hash - e.g. ipfs.infura.io/ipfs/<ipfsHash>\r\n    string public ipfsHash;\r\n    string public ipfsHashType = \"ipfs\"; // can either be ipfs, or ipns\r\n\r\n    MobiusToken public token;\r\n\r\n    // In case of an upgrade, these variables will be set. An upgrade does not affect a currently running round,\r\n    // nor does it do anything with investors' vaults.\r\n    bool public upgraded;\r\n    address public nextVersion;\r\n\r\n    // Total stats\r\n    uint public totalSharesSold;\r\n    uint public totalEarningsGenerated;\r\n    uint public totalDividendsPaid;\r\n    uint public totalJackpotsWon;\r\n\r\n    // Fractions for where revenue goes\r\n    uint public constant DEV_FRACTION = WAD / 20;             // 5% goes to devs\r\n    uint public constant DEV_DIVISOR = 20;             // 5% \r\n\r\n    uint public constant RETURNS_FRACTION = 65 * 10**16;      // 65% goes to share holders\r\n    // 1% if it is a referral purchase, this value will be taken from the above fraction (e.g. if 1% is for refferals, then 64% goes to returns) \r\n    uint public constant REFERRAL_FRACTION = 1 * 10**16;  \r\n    uint public constant JACKPOT_SEED_FRACTION = WAD / 20;    // 5% goes to the next round's jackpot\r\n    uint public constant JACKPOT_FRACTION = 15 * 10**16;      // 15% goes to the final jackpot\r\n    uint public constant AIRDROP_FRACTION = WAD / 100;        // 1% goes to airdrops\r\n    uint public constant DIVIDENDS_FRACTION = 9 * 10**16;     // 9% goes to token holders!\r\n\r\n    uint public constant STARTING_SHARE_PRICE = 1 finney; // a 1000th of an ETH\r\n    uint public constant PRICE_INCREASE_PERIOD = 1 hours; // how often the price doubles after the hard deadline\r\n\r\n    uint public constant HARD_DEADLINE_DURATION = 30 days; // hard deadline is this much after the round start\r\n    uint public constant SOFT_DEADLINE_DURATION = 1 days; // max soft deadline\r\n    uint public constant TIME_PER_SHARE = 5 minutes; // how much time is added to the soft deadline per share purchased\r\n    \r\n    uint public jackpotSeed;// Jackpot from previous rounds\r\n    uint public devBalance; // outstanding balance for devs\r\n    uint public raisedICO;\r\n\r\n    // Helpers to calculate returns - no funds are ever held on lockdown\r\n    uint public unclaimedReturns;\r\n    uint public constant MULTIPLIER = RAY;\r\n\r\n    // This represents an investor. No need to player IDs - they are useless (everyone already has a unique address).\r\n    // Just use native mappings (duh!)\r\n    struct Investor {\r\n        uint lastCumulativeReturnsPoints;\r\n        uint shares;\r\n    }\r\n\r\n    // This represents a round\r\n    struct MobiusRound {\r\n        uint totalInvested;        \r\n        uint jackpot;\r\n        uint airdropPot;\r\n        uint totalShares;\r\n        uint cumulativeReturnsPoints; // this is to help calculate returns when the total number of shares changes\r\n        uint hardDeadline;\r\n        uint softDeadline;\r\n        uint price;\r\n        uint lastPriceIncreaseTime;\r\n        address lastInvestor;\r\n        bool finalized;\r\n        mapping (address => Investor) investors;\r\n    }\r\n\r\n    struct Vault {\r\n        uint totalReturns; // Total balance = returns + referral returns + jackpots/airdrops \r\n        uint refReturns; // how much of the total is from referrals\r\n    }\r\n\r\n    mapping (address => Vault) vaults;\r\n\r\n    uint public latestRoundID;// the first round has an ID of 0\r\n    MobiusRound[] rounds;\r\n\r\n    event SharesIssued(address indexed to, uint shares);\r\n    event ReturnsWithdrawn(address indexed by, uint amount);\r\n    event JackpotWon(address by, uint amount);\r\n    event AirdropWon(address by, uint amount);\r\n    event RoundStarted(uint indexed ID, uint hardDeadline);\r\n    event IPFSHashSet(string _type, string _hash);\r\n\r\n    constructor(address _token) public {\r\n        token = MobiusToken(_token);\r\n    }\r\n\r\n    // The return values will include all vault balance, but you must specify a roundID because\r\n    // Returns are not actually calculated in storage until you invest in the round or withdraw them\r\n    function estimateReturns(address investor, uint roundID) public view \r\n    returns (uint totalReturns, uint refReturns) \r\n    {\r\n        MobiusRound storage rnd = rounds[roundID];\r\n        uint outstanding;\r\n        if(rounds.length > 1) {\r\n            if(hasReturns(investor, roundID - 1)) {\r\n                MobiusRound storage prevRnd = rounds[roundID - 1];\r\n                outstanding = _outstandingReturns(investor, prevRnd);\r\n            }\r\n        }\r\n\r\n        outstanding += _outstandingReturns(investor, rnd);\r\n        \r\n        totalReturns = vaults[investor].totalReturns + outstanding;\r\n        refReturns = vaults[investor].refReturns;\r\n    }\r\n\r\n    function hasReturns(address investor, uint roundID) public view returns (bool) {\r\n        MobiusRound storage rnd = rounds[roundID];\r\n        return rnd.cumulativeReturnsPoints > rnd.investors[investor].lastCumulativeReturnsPoints;\r\n    }\r\n\r\n    function investorInfo(address investor, uint roundID) external view\r\n    returns(uint shares, uint totalReturns, uint referralReturns) \r\n    {\r\n        MobiusRound storage rnd = rounds[roundID];\r\n        shares = rnd.investors[investor].shares;\r\n        (totalReturns, referralReturns) = estimateReturns(investor, roundID);\r\n    }\r\n\r\n    function roundInfo(uint roundID) external view \r\n    returns(\r\n        address leader, \r\n        uint price,\r\n        uint jackpot, \r\n        uint airdrop, \r\n        uint shares, \r\n        uint totalInvested,\r\n        uint distributedReturns,\r\n        uint _hardDeadline,\r\n        uint _softDeadline,\r\n        bool finalized\r\n        )\r\n    {\r\n        MobiusRound storage rnd = rounds[roundID];\r\n        leader = rnd.lastInvestor;\r\n        price = rnd.price;\r\n        jackpot = rnd.jackpot;\r\n        airdrop = rnd.airdropPot;\r\n        shares = rnd.totalShares;\r\n        totalInvested = rnd.totalInvested;\r\n        distributedReturns = wmul(rnd.totalInvested, RETURNS_FRACTION);\r\n        _hardDeadline = rnd.hardDeadline;\r\n        _softDeadline = rnd.softDeadline;\r\n        finalized = rnd.finalized;\r\n    }\r\n\r\n    function totalsInfo() external view \r\n    returns(\r\n        uint totalReturns,\r\n        uint totalShares,\r\n        uint totalDividends,\r\n        uint totalJackpots\r\n    ) {\r\n        MobiusRound storage rnd = rounds[latestRoundID];\r\n        if(rnd.softDeadline > now) {\r\n            totalShares = totalSharesSold + rnd.totalShares;\r\n            totalReturns = totalEarningsGenerated + wmul(rnd.totalInvested, RETURNS_FRACTION);\r\n            totalDividends = totalDividendsPaid + wmul(rnd.totalInvested, DIVIDENDS_FRACTION);\r\n        } else {\r\n            totalShares = totalSharesSold;\r\n            totalReturns = totalEarningsGenerated;\r\n            totalDividends = totalDividendsPaid;\r\n        }\r\n        totalJackpots = totalJackpotsWon;\r\n    }\r\n\r\n    function () public payable {\r\n        buyShares(address(0x0));\r\n    }\r\n\r\n    /// Function to buy shares in the latest round. Purchase logic is abstracted\r\n    function buyShares(address ref) public payable {        \r\n        if(rounds.length > 0) {\r\n            MobiusRound storage rnd = rounds[latestRoundID];   \r\n               \r\n            _purchase(rnd, msg.value, ref);            \r\n        } else {\r\n            revert(\"Not yet started\");\r\n        }\r\n    }\r\n\r\n    /// Function to purchase with what you have in your vault as returns\r\n    function reinvestReturns(uint value) public {        \r\n        reinvestReturns(value, address(0x0));\r\n    }\r\n\r\n    function reinvestReturns(uint value, address ref) public {        \r\n        MobiusRound storage rnd = rounds[latestRoundID];\r\n        _updateReturns(msg.sender, rnd);        \r\n        require(vaults[msg.sender].totalReturns >= value, \"Can't spend what you don't have\");        \r\n        vaults[msg.sender].totalReturns = sub(vaults[msg.sender].totalReturns, value);\r\n        vaults[msg.sender].refReturns = min(vaults[msg.sender].refReturns, vaults[msg.sender].totalReturns);\r\n        unclaimedReturns = sub(unclaimedReturns, value);\r\n        _purchase(rnd, value, ref);\r\n    }\r\n\r\n    function withdrawReturns() public {\r\n        MobiusRound storage rnd = rounds[latestRoundID];\r\n\r\n        if(rounds.length > 1) {// check if they also have returns from before\r\n            if(hasReturns(msg.sender, latestRoundID - 1)) {\r\n                MobiusRound storage prevRnd = rounds[latestRoundID - 1];\r\n                _updateReturns(msg.sender, prevRnd);\r\n            }\r\n        }\r\n        _updateReturns(msg.sender, rnd);\r\n        uint amount = vaults[msg.sender].totalReturns;\r\n        require(amount > 0, \"Nothing to withdraw!\");\r\n        unclaimedReturns = sub(unclaimedReturns, amount);\r\n        vaults[msg.sender].totalReturns = 0;\r\n        vaults[msg.sender].refReturns = 0;\r\n        \r\n        rnd.investors[msg.sender].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\r\n        msg.sender.transfer(amount);\r\n\r\n        emit ReturnsWithdrawn(msg.sender, amount);\r\n    }\r\n\r\n    // Manually update your returns for a given round in case you were inactive since before it ended\r\n    function updateMyReturns(uint roundID) public {\r\n        MobiusRound storage rnd = rounds[roundID];\r\n        _updateReturns(msg.sender, rnd);\r\n    }\r\n\r\n    function finalizeAndRestart() public payable {\r\n        finalizeLastRound();\r\n        startNewRound();\r\n    }\r\n\r\n    /// Anyone can start a new round\r\n    function startNewRound() public payable {\r\n        require(!upgraded, \"This contract has been upgraded!\");\r\n        if(rounds.length > 0) {\r\n            require(rounds[latestRoundID].finalized, \"Previous round not finalized\");\r\n            require(rounds[latestRoundID].softDeadline < now, \"Previous round still running\");\r\n        }\r\n        uint _rID = rounds.length++;\r\n        MobiusRound storage rnd = rounds[_rID];\r\n        latestRoundID = _rID;\r\n\r\n        rnd.lastInvestor = msg.sender;\r\n        rnd.price = STARTING_SHARE_PRICE;\r\n        rnd.hardDeadline = now + HARD_DEADLINE_DURATION;\r\n        rnd.softDeadline = now + SOFT_DEADLINE_DURATION;\r\n        rnd.jackpot = jackpotSeed;\r\n        jackpotSeed = 0; \r\n\r\n        _purchase(rnd, msg.value, address(0x0));\r\n        emit RoundStarted(_rID, rnd.hardDeadline);\r\n    }\r\n\r\n    /// Anyone can finalize a finished round\r\n    function finalizeLastRound() public {\r\n        MobiusRound storage rnd = rounds[latestRoundID];\r\n        _finalizeRound(rnd);\r\n    }\r\n    \r\n    /// This is how devs pay the bills\r\n    function withdrawDevShare() public auth {\r\n        uint value = devBalance;\r\n        devBalance = 0;\r\n        msg.sender.transfer(value);\r\n    }\r\n\r\n    function setIPFSHash(string _type, string _hash) public auth {\r\n        ipfsHashType = _type;\r\n        ipfsHash = _hash;\r\n        emit IPFSHashSet(_type, _hash);\r\n    }\r\n\r\n    function upgrade(address _nextVersion) public auth {\r\n        require(_nextVersion != address(0x0), \"Invalid Address!\");\r\n        require(!upgraded, \"Already upgraded!\");\r\n        upgraded = true;\r\n        nextVersion = _nextVersion;\r\n        if(rounds[latestRoundID].finalized) {\r\n            //if last round was finalized (and no new round was started), transfer the jackpot seed to the new version\r\n            vaults[nextVersion].totalReturns = jackpotSeed;\r\n            jackpotSeed = 0;\r\n        }\r\n    }\r\n\r\n    /// Purchase logic\r\n    function _purchase(MobiusRound storage rnd, uint value, address ref) internal {\r\n        require(rnd.softDeadline >= now, \"After deadline!\");\r\n        require(value >= rnd.price/10, \"Not enough Ether!\");\r\n        rnd.totalInvested = add(rnd.totalInvested, value);\r\n\r\n        // Set the last investor (to win the jackpot after the deadline)\r\n        if(value >= rnd.price)\r\n            rnd.lastInvestor = msg.sender;\r\n        // Check out airdrop \r\n        _airDrop(rnd, value);\r\n        // Process revenue in different \"buckets\"\r\n        _splitRevenue(rnd, value, ref);\r\n        // Update returns before issuing shares\r\n        _updateReturns(msg.sender, rnd);\r\n        //issue shares for the current round. 1 share = 1 time increase for the deadline\r\n        uint newShares = _issueShares(rnd, msg.sender, value);\r\n\r\n        //Mint tokens during the first round\r\n        if(rounds.length == 1) {\r\n            token.mint(msg.sender, newShares);\r\n        }\r\n        uint timeIncreases = newShares/WAD;// since 1 share is represented by 1 * 10^18, divide by 10^18\r\n        // adjust soft deadline to new soft deadline\r\n        uint newDeadline = add(rnd.softDeadline, mul(timeIncreases, TIME_PER_SHARE));\r\n        rnd.softDeadline = min(newDeadline, now + SOFT_DEADLINE_DURATION);\r\n        // If after hard deadline, double the price every price increase periods\r\n        if(now > rnd.hardDeadline) {\r\n            if(now > rnd.lastPriceIncreaseTime + PRICE_INCREASE_PERIOD) {\r\n                rnd.price = rnd.price * 2;\r\n                rnd.lastPriceIncreaseTime = now;\r\n            }\r\n        }\r\n    }\r\n\r\n    function _finalizeRound(MobiusRound storage rnd) internal {\r\n        require(!rnd.finalized, \"Already finalized!\");\r\n        require(rnd.softDeadline < now, \"Round still running!\");\r\n\r\n        if(rounds.length == 1) {\r\n            // After finishing minting tokens they will be transferable and dividends will be available!\r\n            require(token.finishMinting(), \"Couldn't finish minting tokens!\");\r\n        }\r\n        // Transfer jackpot to winner's vault\r\n        vaults[rnd.lastInvestor].totalReturns = add(vaults[rnd.lastInvestor].totalReturns, rnd.jackpot);\r\n        unclaimedReturns = add(unclaimedReturns, rnd.jackpot);\r\n        \r\n        emit JackpotWon(rnd.lastInvestor, rnd.jackpot);\r\n        totalJackpotsWon += rnd.jackpot;\r\n        // transfer the leftover to the next round's jackpot\r\n        jackpotSeed = add(jackpotSeed, wmul(rnd.totalInvested, JACKPOT_SEED_FRACTION));\r\n        //Empty the AD pot if it has a balance.\r\n        jackpotSeed = add(jackpotSeed, rnd.airdropPot);\r\n        if(upgraded) {\r\n            // if upgraded transfer the jackpot seed to the new version\r\n            vaults[nextVersion].totalReturns = jackpotSeed;\r\n            jackpotSeed = 0; \r\n        }        \r\n        //Send out dividends to token holders\r\n        uint _div;\r\n        if(rounds.length == 1){\r\n            // 2% during the first round, and the normal fraction otherwise\r\n            _div = wmul(rnd.totalInvested, 2 * 10**16);            \r\n        } else {\r\n            _div = wmul(rnd.totalInvested, DIVIDENDS_FRACTION);            \r\n        }\r\n        token.disburseDividends.value(_div)();\r\n        totalDividendsPaid += _div;\r\n        totalSharesSold += rnd.totalShares;\r\n        totalEarningsGenerated += wmul(rnd.totalInvested, RETURNS_FRACTION);\r\n\r\n        rnd.finalized = true;\r\n    }\r\n\r\n    /** \r\n        This is where the magic happens: every investor gets an exact share of all returns proportional to their shares\r\n        If you're early, you'll have a larger share for longer, so obviously you earn more.\r\n    */\r\n    function _updateReturns(address _investor, MobiusRound storage rnd) internal {\r\n        if(rnd.investors[_investor].shares == 0) {\r\n            return;\r\n        }\r\n        \r\n        uint outstanding = _outstandingReturns(_investor, rnd);\r\n\r\n        // if there are any returns, transfer them to the investor's vaults\r\n        if (outstanding > 0) {\r\n            vaults[_investor].totalReturns = add(vaults[_investor].totalReturns, outstanding);\r\n        }\r\n\r\n        rnd.investors[_investor].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\r\n    }\r\n\r\n    function _outstandingReturns(address _investor, MobiusRound storage rnd) internal view returns(uint) {\r\n        if(rnd.investors[_investor].shares == 0) {\r\n            return 0;\r\n        }\r\n        // check if there've been new returns\r\n        uint newReturns = sub(\r\n            rnd.cumulativeReturnsPoints, \r\n            rnd.investors[_investor].lastCumulativeReturnsPoints\r\n            );\r\n\r\n        uint outstanding = 0;\r\n        if(newReturns != 0) { \r\n            // outstanding returns = (total new returns points * ivestor shares) / MULTIPLIER\r\n            // The MULTIPLIER is used also at the point of returns disbursment\r\n            outstanding = mul(newReturns, rnd.investors[_investor].shares) / MULTIPLIER;\r\n        }\r\n\r\n        return outstanding;\r\n    }\r\n\r\n    /// Process revenue according to fractions\r\n    function _splitRevenue(MobiusRound storage rnd, uint value, address ref) internal {\r\n        uint roundReturns;\r\n        uint returnsOffset;\r\n        if(rounds.length == 1){\r\n            returnsOffset = 13 * 10**16;// during the first round reduce returns (by 13%) and give more to the ICO\r\n        }\r\n        if(ref != address(0x0)) {\r\n            // if there was a referral\r\n            roundReturns = wmul(value, RETURNS_FRACTION - REFERRAL_FRACTION - returnsOffset);\r\n            uint _ref = wmul(value, REFERRAL_FRACTION);\r\n            vaults[ref].totalReturns = add(vaults[ref].totalReturns, _ref);            \r\n            vaults[ref].refReturns = add(vaults[ref].refReturns, _ref);\r\n            unclaimedReturns = add(unclaimedReturns, _ref);\r\n        } else {\r\n            roundReturns = wmul(value, RETURNS_FRACTION - returnsOffset);\r\n        }\r\n        \r\n        uint airdrop = wmul(value, AIRDROP_FRACTION);\r\n        uint jackpot = wmul(value, JACKPOT_FRACTION);\r\n        \r\n        uint dev;\r\n        // During the ICO, devs get 25% (5% originally, 7% from the dividends fraction, \r\n        // and 13% from the returns), leaving 2% for dividends, and 52% for returns \r\n        // This is only during the first round, and later rounds leave the original fractions:\r\n        // 5% for devs, 9% dividends, 65% returns \r\n        if(rounds.length == 1){\r\n            // calculate dividends at the end, no need to do it at every purchase\r\n            dev = value / 4; // 25% \r\n            raisedICO += dev;\r\n        } else {\r\n            dev = value / DEV_DIVISOR;\r\n        }\r\n        // if this is the first purchase, send to jackpot (no one can claim these returns otherwise)\r\n        if(rnd.totalShares == 0) {\r\n            rnd.jackpot = add(rnd.jackpot, roundReturns);\r\n        } else {\r\n            _disburseReturns(rnd, roundReturns);\r\n        }\r\n        \r\n        rnd.airdropPot = add(rnd.airdropPot, airdrop);\r\n        rnd.jackpot = add(rnd.jackpot, jackpot);\r\n        devBalance = add(devBalance, dev);\r\n    }\r\n\r\n    function _disburseReturns(MobiusRound storage rnd, uint value) internal {\r\n        unclaimedReturns = add(unclaimedReturns, value);// keep track of unclaimed returns\r\n        // The returns points represent returns*MULTIPLIER/totalShares (at the point of purchase)\r\n        // This allows us to keep outstanding balances of shareholders when the total supply changes in real time\r\n        if(rnd.totalShares == 0) {\r\n            rnd.cumulativeReturnsPoints = mul(value, MULTIPLIER) / wdiv(value, rnd.price);\r\n        } else {\r\n            rnd.cumulativeReturnsPoints = add(\r\n                rnd.cumulativeReturnsPoints, \r\n                mul(value, MULTIPLIER) / rnd.totalShares\r\n            );\r\n        }\r\n    }\r\n\r\n    function _issueShares(MobiusRound storage rnd, address _investor, uint value) internal returns(uint) {    \r\n        if(rnd.investors[_investor].lastCumulativeReturnsPoints == 0) {\r\n            rnd.investors[_investor].lastCumulativeReturnsPoints = rnd.cumulativeReturnsPoints;\r\n        }    \r\n        \r\n        uint newShares = wdiv(value, rnd.price);\r\n        \r\n        //bonuses:\r\n        if(value >= 100 ether) {\r\n            newShares = mul(newShares, 2);//get double shares if you paid more than 100 ether\r\n        } else if(value >= 10 ether) {\r\n            newShares = add(newShares, newShares/2);//50% bonus\r\n        } else if(value >= 1 ether) {\r\n            newShares = add(newShares, newShares/3);//33% bonus\r\n        } else if(value >= 100 finney) {\r\n            newShares = add(newShares, newShares/10);//10% bonus\r\n        }\r\n\r\n        rnd.investors[_investor].shares = add(rnd.investors[_investor].shares, newShares);\r\n        rnd.totalShares = add(rnd.totalShares, newShares);\r\n        emit SharesIssued(_investor, newShares);\r\n        return newShares;\r\n    }    \r\n\r\n    function _airDrop(MobiusRound storage rnd, uint value) internal {\r\n        require(msg.sender == tx.origin, \"ONLY HOOMANS (or scripts that don't use smart contracts)!\");\r\n        if(value > 100 finney) {\r\n            /**\r\n                Creates a random number from the last block hash and current timestamp.\r\n                One could add more seemingly random data like the msg.sender, etc, but that doesn't \r\n                make it harder for a miner to manipulate the result in their favor (if they intended to).\r\n             */\r\n            uint chance = uint(keccak256(abi.encodePacked(blockhash(block.number - 1), now)));\r\n            if(chance % 200 == 0) {// once in 200 times\r\n                uint prize = rnd.airdropPot / 2;// win half of the pot, regardless of how much you paid\r\n                rnd.airdropPot = rnd.airdropPot / 2;\r\n                vaults[msg.sender].totalReturns = add(vaults[msg.sender].totalReturns, prize);\r\n                unclaimedReturns = add(unclaimedReturns, prize);\r\n                totalJackpotsWon += prize;\r\n                emit AirdropWon(msg.sender, prize);\r\n            }\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"raisedICO\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"MULTIPLIER\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nextVersion\",\"type\":\"address\"}],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"nextVersion\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"unclaimedReturns\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"owner_\",\"type\":\"address\"}],\"name\":\"setOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEV_DIVISOR\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"TIME_PER_SHARE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ipfsHashType\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEarningsGenerated\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"investorInfo\",\"outputs\":[{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"totalReturns\",\"type\":\"uint256\"},{\"name\":\"referralReturns\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"updateMyReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"roundInfo\",\"outputs\":[{\"name\":\"leader\",\"type\":\"address\"},{\"name\":\"price\",\"type\":\"uint256\"},{\"name\":\"jackpot\",\"type\":\"uint256\"},{\"name\":\"airdrop\",\"type\":\"uint256\"},{\"name\":\"shares\",\"type\":\"uint256\"},{\"name\":\"totalInvested\",\"type\":\"uint256\"},{\"name\":\"distributedReturns\",\"type\":\"uint256\"},{\"name\":\"_hardDeadline\",\"type\":\"uint256\"},{\"name\":\"_softDeadline\",\"type\":\"uint256\"},{\"name\":\"finalized\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawDevShare\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"hasReturns\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"buyShares\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeAndRestart\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_type\",\"type\":\"string\"},{\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"setIPFSHash\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalsInfo\",\"outputs\":[{\"name\":\"totalReturns\",\"type\":\"uint256\"},{\"name\":\"totalShares\",\"type\":\"uint256\"},{\"name\":\"totalDividends\",\"type\":\"uint256\"},{\"name\":\"totalJackpots\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"STARTING_SHARE_PRICE\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSeed\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DIVIDENDS_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SOFT_DEADLINE_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSharesSold\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"authority_\",\"type\":\"address\"}],\"name\":\"setAuthority\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"REFERRAL_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"RETURNS_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"HARD_DEADLINE_DURATION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"reinvestReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"investor\",\"type\":\"address\"},{\"name\":\"roundID\",\"type\":\"uint256\"}],\"name\":\"estimateReturns\",\"outputs\":[{\"name\":\"totalReturns\",\"type\":\"uint256\"},{\"name\":\"refReturns\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_SEED_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"JACKPOT_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"AIRDROP_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"startNewRound\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"authority\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"finalizeLastRound\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"upgraded\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"ref\",\"type\":\"address\"}],\"name\":\"reinvestReturns\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ipfsHash\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalDividendsPaid\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"devBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalJackpotsWon\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"DEV_FRACTION\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"latestRoundID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_INCREASE_PERIOD\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"shares\",\"type\":\"uint256\"}],\"name\":\"SharesIssued\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"ReturnsWithdrawn\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"JackpotWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"by\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"AirdropWon\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"ID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"hardDeadline\",\"type\":\"uint256\"}],\"name\":\"RoundStarted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_type\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"_hash\",\"type\":\"string\"}],\"name\":\"IPFSHashSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"authority\",\"type\":\"address\"}],\"name\":\"LogSetAuthority\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"owner\",\"type\":\"address\"}],\"name\":\"LogSetOwner\",\"type\":\"event\"}]","ContractName":"Mobius2D","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"00000000000000000000000054cdc9d889c28f55f59f6b136822868c7d4726fc","Library":"","SwarmSource":"bzzr://b33fc6e93ef4b9e89506e3e462cface98815913fcd0d7f1f727682c7c04f25e4"}]}