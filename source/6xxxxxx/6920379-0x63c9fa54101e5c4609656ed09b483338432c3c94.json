{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^ 0.4.21;\r\n\r\n/**\r\n *   @title SafeMath\r\n *   @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a * b;\r\n        assert(a == 0 || c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b > 0);\r\n        uint256 c = a / b;\r\n        assert(a == b * c + a % b);\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns(uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n\r\n/**\r\n *   @title ERC20\r\n *   @dev Standart ERC20 token interface\r\n */\r\ncontract ERC20 {\r\n    function balanceOf(address _owner) public constant returns(uint256);\r\n    function transfer(address _to, uint256 _value) public returns(bool);\r\n    function transferFrom(address _from, address _to, uint256 _value) public returns(bool);\r\n    function approve(address _spender, uint256 _value) public returns(bool);\r\n    function allowance(address _owner, address _spender) public constant returns(uint256);\r\n    mapping(address => uint256) balances;\r\n    mapping(address => mapping(address => uint256)) allowed;\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\n\r\n/**\r\n *   @dev CRET token contract\r\n */\r\ncontract WbcToken is ERC20 {\r\n    using SafeMath for uint256;\r\n    string public name = \"WhizBizCoin\";\r\n    string public symbol = \"WB\";\r\n    uint256 public decimals = 18;\r\n    uint256 public totalSupply = 888000000 * 1e18;\r\n    uint256 public timeStamp = 0;\r\n    uint256 constant fundPartYear = 44400000 * 1e18; \r\n    uint256 constant trioPartYear = 8880000 * 1e18; //1% of tokens for CrowdSale, Film Comany and Investors in one year for 6 years\r\n    uint256 constant minimumAge = 30 days; // minimum age for coins\r\n    uint256 constant oneYear = 360 days;\r\n    uint256 public minted = 0;\r\n    address public teamCSN;\r\n    address public teamFilmCompany;\r\n    address public teamInvestors;\r\n    address public teamFund;\r\n    address public manager;\r\n    address public reserveFund;\r\n    \r\n    struct transferStruct{\r\n    uint128 amount;\r\n    uint64 time;\r\n    }\r\n    \r\n    mapping(uint8 => bool) trioChecker;\r\n    mapping(uint8 => bool) fundChecker;\r\n    mapping(uint256 => bool) priceChecker;\r\n    mapping(address => transferStruct[]) transferSt;\r\n    mapping(uint256 => uint256) coinPriceNow;\r\n\r\n    // Ico contract address\r\n    address public owner;\r\n\r\n    // Allows execution by the owner only\r\n    modifier onlyOwner {\r\n        require(msg.sender == owner);\r\n        _;\r\n    }\r\n    \r\n    modifier onlyManager {\r\n        require(msg.sender == manager);\r\n        _;\r\n    }\r\n    \r\n    \r\n    \r\n    constructor (address _owner, address _teamCSN, address _teamFilmCompany, address _teamInvestors, address _fund, address _manager, address _reserveFund) public {\r\n        owner = _owner;\r\n        teamCSN = _teamCSN;\r\n        teamFilmCompany = _teamFilmCompany;\r\n        teamInvestors = _teamInvestors;\r\n        teamFund = _fund;\r\n        manager = _manager;\r\n        reserveFund = _reserveFund;\r\n\r\n    }\r\n    \r\n    \r\n    function doTimeStamp(uint256 _value) external onlyOwner {\r\n        timeStamp = _value;\r\n    }\r\n    \r\n    \r\n\r\n   /**\r\n    *   @dev Mint tokens\r\n    *   @param _investor     address the tokens will be issued to\r\n    *   @param _value        number of tokens\r\n    */\r\n    function mintTokens(address _investor, uint256 _value) external onlyOwner {\r\n        require(_value > 0);\r\n        require(minted.add(_value) <= totalSupply);\r\n        balances[_investor] = balances[_investor].add(_value);\r\n        minted = minted.add(_value);\r\n        transferSt[_investor].push(transferStruct(uint128(_value),uint64(now)));\r\n        emit Transfer(0x0, _investor, _value);\r\n    }\r\n    \r\n    \r\n    \r\n    function mintTrio() external onlyManager {\r\n        require(now > (timeStamp + 360 days));\r\n        if(now > (timeStamp + 360 days) && now <= (timeStamp + 720 days)){\r\n            require(trioChecker[1] != true);\r\n            partingTrio(1);\r\n        }\r\n        if(now > (timeStamp + 720 days) && now <= (timeStamp + 1080 days)){\r\n            require(trioChecker[2] != true);\r\n            partingTrio(2);\r\n        }\r\n        if(now > (timeStamp + 1080 days) && now <= (timeStamp + 1440 days)){\r\n            require(trioChecker[3] != true);\r\n            partingTrio(3);\r\n        }\r\n        if(now > (timeStamp + 1440 days) && now <= (timeStamp + 1800 days)){\r\n            require(trioChecker[4] != true);\r\n            partingTrio(4);\r\n        }\r\n        if(now > (timeStamp + 1800 days) && now <= (timeStamp + 2160 days)){\r\n            require(trioChecker[5] != true);\r\n            partingTrio(5);\r\n        }\r\n        if(now > (timeStamp + 2160 days) && now <= (timeStamp + 2520 days)){\r\n            require(trioChecker[6] != true);\r\n            partingTrio(6);\r\n        }\r\n    }\r\n    \r\n    \r\n    function mintFund() external onlyManager {\r\n        require(now > (timeStamp + 360 days));\r\n        if(now > (timeStamp + 360 days) && now <= (timeStamp + 720 days)){\r\n            require(fundChecker[1] != true);\r\n            partingFund(1);\r\n        }\r\n        if(now > (timeStamp + 720 days) && now <= (timeStamp + 1080 days)){\r\n            require(fundChecker[2] != true);\r\n            partingFund(2);\r\n        }\r\n        if(now > (timeStamp + 1080 days) && now <= (timeStamp + 1440 days)){\r\n            require(fundChecker[3] != true);\r\n            partingFund(3);\r\n        }\r\n        if(now > (timeStamp + 1440 days) && now <= (timeStamp + 1800 days)){\r\n            require(fundChecker[4] != true);\r\n            partingFund(4);\r\n        }\r\n        if(now > (timeStamp + 1800 days) && now <= (timeStamp + 2160 days)){\r\n            require(fundChecker[5] != true);\r\n            partingFund(5);\r\n        }\r\n        if(now > (timeStamp + 2160 days) && now <= (timeStamp + 2520 days)){\r\n            require(fundChecker[6] != true);\r\n            partingFund(6);\r\n        }\r\n        if(now > (timeStamp + 2520 days) && now <= (timeStamp + 2880 days)){\r\n            require(fundChecker[7] != true);\r\n            partingFund(7);\r\n        }\r\n    \r\n    }\r\n    \r\n    \r\n    function partingFund(uint8 _x) internal {\r\n        require(_x > 0 && _x <= 7);\r\n        balances[teamFund] = balances[teamFund].add(fundPartYear);\r\n        fundChecker[_x] = true;\r\n        minted = minted.add(fundPartYear);\r\n        transferSt[teamFund].push(transferStruct(uint128(fundPartYear),uint64(now)));\r\n            \r\n        emit Transfer(0x0, teamFund, fundPartYear);\r\n    }\r\n    \r\n    \r\n    function partingTrio(uint8 _x) internal {\r\n        require(_x > 0 && _x <= 6);\r\n        balances[teamCSN] = balances[teamCSN].add(trioPartYear);\r\n        balances[teamFilmCompany] = balances[teamFilmCompany].add(trioPartYear);\r\n        balances[teamInvestors] = balances[teamInvestors].add(trioPartYear);\r\n        trioChecker[_x] = true;\r\n        minted = minted.add(trioPartYear.mul(3));\r\n        transferSt[teamCSN].push(transferStruct(uint128(trioPartYear),uint64(now)));\r\n        transferSt[teamFilmCompany].push(transferStruct(uint128(trioPartYear),uint64(now)));\r\n        transferSt[teamInvestors].push(transferStruct(uint128(trioPartYear),uint64(now)));\r\n            \r\n        emit Transfer(0x0, teamCSN, trioPartYear);\r\n        emit Transfer(0x0, teamFilmCompany, trioPartYear);\r\n        emit Transfer(0x0, teamInvestors, trioPartYear);\r\n    }\r\n\r\n\r\n   /**\r\n    *   @dev Get balance of investor\r\n    *   @param _owner        investor's address\r\n    *   @return              balance of investor\r\n    */\r\n    function balanceOf(address _owner) public constant returns(uint256) {\r\n      return balances[_owner];\r\n    }\r\n\r\n   /**\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transfer(address _to, uint256 _amount) public returns(bool) {\r\n        if(msg.sender == _to) {return POSMint();}\r\n        balances[msg.sender] = balances[msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(msg.sender, _to, _amount);\r\n        if(transferSt[msg.sender].length > 0) {delete transferSt[msg.sender];}\r\n        uint64 _now = uint64(now);\r\n        transferSt[msg.sender].push(transferStruct(uint128(balances[msg.sender]),_now));\r\n        transferSt[_to].push(transferStruct(uint128(_amount),_now));\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @return true if the transfer was successful\r\n    */\r\n    function transferFrom(address _from, address _to, uint256 _amount) public returns(bool) {\r\n        require(_amount <= allowed[_from][msg.sender]);\r\n        require(_amount <= balances[_from]);\r\n        balances[_from] = balances[_from].sub(_amount);\r\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount);\r\n        balances[_to] = balances[_to].add(_amount);\r\n        emit Transfer(_from, _to, _amount);\r\n        if(transferSt[_from].length > 0) {delete transferSt[_from];}\r\n        uint64 _now = uint64(now);\r\n        transferSt[_from].push(transferStruct(uint128(balances[_from]),_now));\r\n        transferSt[_to].push(transferStruct(uint128(_amount),_now));\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function POSMint() internal returns (bool) {\r\n        require(now > (timeStamp + minimumAge));\r\n        if(balances[msg.sender] <= 0) {return false;}\r\n        if(transferSt[msg.sender].length <= 0) {return false;}\r\n\r\n        uint256 _now = now;\r\n        uint256 _year = getYear();\r\n        uint256 _phase = getPhase(_year);\r\n        uint256 _coinsAmount = getCoinsAmount(msg.sender, _now);\r\n        if(_coinsAmount <= 0) {return false;}\r\n        uint256 _coinsPrice = getCoinPrice(_year, _phase);\r\n        if(_coinsPrice <= 0) {return false;}\r\n        uint256 reward = (_coinsAmount.mul(_coinsPrice)).div(100000);\r\n        if(reward <= 0) {return false;}\r\n        if(reward > 0) {require(minted.add(reward) <= totalSupply);}\r\n        minted = minted.add(reward);\r\n        balances[msg.sender] = balances[msg.sender].add(reward);\r\n        delete transferSt[msg.sender];\r\n        transferSt[msg.sender].push(transferStruct(uint128(balances[msg.sender]),uint64(now)));\r\n\r\n        emit Transfer(0x0, msg.sender, reward);\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function getCoinsAmount(address _address, uint _now) internal view returns (uint256) {\r\n        if(transferSt[_address].length <= 0) {return 0;}\r\n        uint256 Coins = 0;\r\n        for (uint256 i = 0; i < transferSt[_address].length; i++){\r\n            if( _now < uint(transferSt[_address][i].time).add(minimumAge) ) {return Coins;}\r\n            Coins = Coins.add(uint256(transferSt[_address][i].amount));\r\n        }\r\n        return Coins;\r\n    }\r\n    \r\n    \r\n    function getYear() internal view returns (uint256) {\r\n        require(timeStamp > 0);\r\n        for(uint256 i = 0; i <= 99; i++) {\r\n        if(now >= ((timeStamp + minimumAge).add((i.mul(oneYear)))) && now < ((timeStamp + minimumAge).add(((i+1).mul(oneYear))))) {\r\n            return (i);    // how many years gone\r\n            }\r\n        }\r\n        if(now >= ((timeStamp + minimumAge).add((oneYear.mul(100))))) {return (100);}\r\n    \r\n    }\r\n\r\n\r\n    function getPhase(uint256 _x) internal pure returns (uint256) {\r\n        require(_x >= 0);\r\n        if(_x >= 0 && _x < 3) {return 1;}\r\n        if(_x >= 3 && _x < 6) {return 2;}\r\n        if(_x >= 6 && _x < 9) {return 3;}\r\n        if(_x >= 9 && _x < 12) {return 4;}\r\n        if(_x >= 12) {return 5;}        // last phase which include 18*3 years\r\n    \r\n    }\r\n    \r\n    \r\n    function getMonthLimit(uint256 _x) internal pure returns (uint256) {\r\n        require(_x > 0 && _x <=5);\r\n        if(_x == 1) {return (2220000 * 1e18);} //limit in month in this phase for all\r\n        if(_x == 2) {return (1480000 * 1e18);}\r\n        if(_x == 3) {return (740000 * 1e18);}\r\n        if(_x == 4) {return (370000 * 1e18);}\r\n        if(_x == 5) {return (185000 * 1e18);}\r\n    }\r\n    \r\n \r\n\r\n    \r\n    function getCoinPrice(uint256 _year, uint256 _phase) internal returns (uint256) {\r\n    require(_year >= 0);\r\n    uint256 _monthLimit = getMonthLimit(_phase);\r\n    uint256 _sumToAdd = _year.mul(oneYear);\r\n    uint256 _monthInYear = _year.mul(12);\r\n\r\n    for(uint256 i = 0; i <= 11; i++) {\r\n    if(now >= (timeStamp + minimumAge).add(_sumToAdd).add(minimumAge.mul(i)) && now < (timeStamp + minimumAge).add(_sumToAdd).add(minimumAge.mul(i+1))) {\r\n        uint256 _num = _monthInYear.add(i);\r\n        if(priceChecker[_num] != true) {\r\n            coinPriceNow[_num] = minted;\r\n            priceChecker[_num] = true;\r\n            return (_monthLimit.mul(100000)).div(minted);} \r\n        if(priceChecker[_num] == true) {\r\n            return (_monthLimit.mul(100000)).div(coinPriceNow[_num]);}\r\n    }\r\n    }\r\n}\r\n\r\n   /**\r\n    *   @dev Allows another account/contract to spend some tokens on its behalf\r\n    * approve has to be called twice in 2 separate transactions - once to\r\n    *   change the allowance to 0 and secondly to change it to the new allowance value\r\n    *   @param _spender      approved address\r\n    *   @param _amount       allowance amount\r\n    *\r\n    *   @return true if the approval was successful\r\n    */\r\n    function approve(address _spender, uint256 _amount) public returns(bool) {\r\n        require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\r\n        allowed[msg.sender][_spender] = _amount;\r\n        emit Approval(msg.sender, _spender, _amount);\r\n        return true;\r\n    }\r\n\r\n   /**\r\n    *   @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n    *\r\n    *   @param _owner        the address which owns the funds\r\n    *   @param _spender      the address which will spend the funds\r\n    *\r\n    *   @return              the amount of tokens still avaible for the spender\r\n    */\r\n    function allowance(address _owner, address _spender) public constant returns(uint256) {\r\n        return allowed[_owner][_spender];\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"teamCSN\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_spender\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"approve\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeStamp\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintTrio\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSupply\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transferFrom\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"decimals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamInvestors\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"minted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamFilmCompany\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"teamFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"doTimeStamp\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"balanceOf\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"mintFund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"transfer\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"reserveFund\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_spender\",\"type\":\"address\"}],\"name\":\"allowance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_investor\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"mintTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"},{\"name\":\"_teamCSN\",\"type\":\"address\"},{\"name\":\"_teamFilmCompany\",\"type\":\"address\"},{\"name\":\"_teamInvestors\",\"type\":\"address\"},{\"name\":\"_fund\",\"type\":\"address\"},{\"name\":\"_manager\",\"type\":\"address\"},{\"name\":\"_reserveFund\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_from\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_to\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Transfer\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"_owner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"_spender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"Approval\",\"type\":\"event\"}]","ContractName":"WbcToken","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000042d0b779f9c6831e414ef8555d6d325c4d48d2d8000000000000000000000000199f395944e8e9f1cb88ab256d7795fb9acd6b320000000000000000000000005b9364643bd8529e6f542ae9480d7889770e48640000000000000000000000008d20baefc893495696230a091789b13af3ca4a330000000000000000000000000dcf8b982a286873ecc27987a3198bb521a8ef06000000000000000000000000a3a106f1d081f5b9fc0b2a1b46613f55ea308cdc0000000000000000000000005f9100aa68836dd4979b4b2ef94e8e1d8546380b","Library":"","SwarmSource":"bzzr://f680cf848876aed58d8d97fdaef7c5ea3a118b4842a4fd4c67cf1aea366af0a5"}]}