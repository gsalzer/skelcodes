{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\npragma experimental \"v0.5.0\";\r\n\r\n/*\r\n\r\n    Copyright 2018 dYdX Trading Inc.\r\n\r\n    Licensed under the Apache License, Version 2.0 (the \"License\");\r\n    you may not use this file except in compliance with the License.\r\n    You may obtain a copy of the License at\r\n\r\n    http://www.apache.org/licenses/LICENSE-2.0\r\n\r\n    Unless required by applicable law or agreed to in writing, software\r\n    distributed under the License is distributed on an \"AS IS\" BASIS,\r\n    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n    See the License for the specific language governing permissions and\r\n    limitations under the License.\r\n\r\n*/\r\n\r\n// File: openzeppelin-solidity/contracts/math/SafeMath.sol\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (_a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = _a * _b;\r\n    assert(c / _a == _b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    // assert(_b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = _a / _b;\r\n    // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold\r\n    return _a / _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 _a, uint256 _b) internal pure returns (uint256) {\r\n    assert(_b <= _a);\r\n    return _a - _b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) {\r\n    c = _a + _b;\r\n    assert(c >= _a);\r\n    return c;\r\n  }\r\n}\r\n\r\n// File: contracts/external/0x/v1/ZeroExExchangeInterfaceV1.sol\r\n\r\n/// @title Exchange - Facilitates exchange of ERC20 tokens.\r\n/// @author Amir Bandeali - <amir@0xProject.com>, Will Warren - <will@0xProject.com>\r\ncontract ZeroExExchangeInterfaceV1 {\r\n    // Error Codes\r\n    enum Errors {\r\n        ORDER_EXPIRED,                    // Order has already expired\r\n        ORDER_FULLY_FILLED_OR_CANCELLED,  // Order has already been fully filled or cancelled\r\n        ROUNDING_ERROR_TOO_LARGE,         // Rounding error too large\r\n        INSUFFICIENT_BALANCE_OR_ALLOWANCE // Insufficient balance or allowance for token transfer\r\n    }\r\n\r\n    string constant public VERSION = \"1.0.0\";\r\n    uint16 constant public EXTERNAL_QUERY_GAS_LIMIT = 4999;    // Changes to state require at least 5000 gas\r\n\r\n    address public ZRX_TOKEN_CONTRACT;\r\n    address public TOKEN_TRANSFER_PROXY_CONTRACT;\r\n\r\n    // Mappings of orderHash => amounts of takerTokenAmount filled or cancelled.\r\n    mapping (bytes32 => uint256) public filled;\r\n    mapping (bytes32 => uint256) public cancelled;\r\n\r\n    /*\r\n    * Core exchange functions\r\n    */\r\n\r\n    /// @dev Fills the input order.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfer will fail before attempting.\r\n    /// @param v ECDSA signature parameter v.\r\n    /// @param r ECDSA signature parameters r.\r\n    /// @param s ECDSA signature parameters s.\r\n    /// @return Total amount of takerToken filled in trade.\r\n    function fillOrder(\r\n        address[5] orderAddresses,\r\n        uint256[6] orderValues,\r\n        uint256 fillTakerTokenAmount,\r\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n        returns (uint256 filledTakerTokenAmount);\r\n\r\n    /// @dev Cancels the input order.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @param cancelTakerTokenAmount Desired amount of takerToken to cancel in order.\r\n    /// @return Amount of takerToken cancelled.\r\n    function cancelOrder(\r\n        address[5] orderAddresses,\r\n        uint256[6] orderValues,\r\n        uint256 cancelTakerTokenAmount)\r\n        public\r\n        returns (uint256);\r\n\r\n    /*\r\n    * Wrapper functions\r\n    */\r\n\r\n    /// @dev Fills an order with specified parameters and ECDSA signature, throws if specified amount not filled entirely.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @param fillTakerTokenAmount Desired amount of takerToken to fill.\r\n    /// @param v ECDSA signature parameter v.\r\n    /// @param r ECDSA signature parameters r.\r\n    /// @param s ECDSA signature parameters s.\r\n    function fillOrKillOrder(\r\n        address[5] orderAddresses,\r\n        uint256[6] orderValues,\r\n        uint256 fillTakerTokenAmount,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public;\r\n\r\n    /// @dev Synchronously executes multiple fill orders in a single transaction.\r\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n    /// @param orderValues Array of uint256 arrays containing individual order values.\r\n    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\r\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\r\n    /// @param v Array ECDSA signature v parameters.\r\n    /// @param r Array of ECDSA signature r parameters.\r\n    /// @param s Array of ECDSA signature s parameters.\r\n    function batchFillOrders(\r\n        address[5][] orderAddresses,\r\n        uint256[6][] orderValues,\r\n        uint256[] fillTakerTokenAmounts,\r\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n        uint8[] v,\r\n        bytes32[] r,\r\n        bytes32[] s)\r\n        public;\r\n\r\n    /// @dev Synchronously executes multiple fillOrKill orders in a single transaction.\r\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n    /// @param orderValues Array of uint256 arrays containing individual order values.\r\n    /// @param fillTakerTokenAmounts Array of desired amounts of takerToken to fill in orders.\r\n    /// @param v Array ECDSA signature v parameters.\r\n    /// @param r Array of ECDSA signature r parameters.\r\n    /// @param s Array of ECDSA signature s parameters.\r\n    function batchFillOrKillOrders(\r\n        address[5][] orderAddresses,\r\n        uint256[6][] orderValues,\r\n        uint256[] fillTakerTokenAmounts,\r\n        uint8[] v,\r\n        bytes32[] r,\r\n        bytes32[] s)\r\n        public;\r\n\r\n    /// @dev Synchronously executes multiple fill orders in a single transaction until total fillTakerTokenAmount filled.\r\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n    /// @param orderValues Array of uint256 arrays containing individual order values.\r\n    /// @param fillTakerTokenAmount Desired total amount of takerToken to fill in orders.\r\n    /// @param shouldThrowOnInsufficientBalanceOrAllowance Test if transfers will fail before attempting.\r\n    /// @param v Array ECDSA signature v parameters.\r\n    /// @param r Array of ECDSA signature r parameters.\r\n    /// @param s Array of ECDSA signature s parameters.\r\n    /// @return Total amount of fillTakerTokenAmount filled in orders.\r\n    function fillOrdersUpTo(\r\n        address[5][] orderAddresses,\r\n        uint256[6][] orderValues,\r\n        uint256 fillTakerTokenAmount,\r\n        bool shouldThrowOnInsufficientBalanceOrAllowance,\r\n        uint8[] v,\r\n        bytes32[] r,\r\n        bytes32[] s)\r\n        public\r\n        returns (uint256);\r\n\r\n    /// @dev Synchronously cancels multiple orders in a single transaction.\r\n    /// @param orderAddresses Array of address arrays containing individual order addresses.\r\n    /// @param orderValues Array of uint256 arrays containing individual order values.\r\n    /// @param cancelTakerTokenAmounts Array of desired amounts of takerToken to cancel in orders.\r\n    function batchCancelOrders(\r\n        address[5][] orderAddresses,\r\n        uint256[6][] orderValues,\r\n        uint256[] cancelTakerTokenAmounts)\r\n        public;\r\n\r\n    /*\r\n    * Constant public functions\r\n    */\r\n\r\n    /// @dev Calculates Keccak-256 hash of order with specified parameters.\r\n    /// @param orderAddresses Array of order's maker, taker, makerToken, takerToken, and feeRecipient.\r\n    /// @param orderValues Array of order's makerTokenAmount, takerTokenAmount, makerFee, takerFee, expirationTimestampInSec, and salt.\r\n    /// @return Keccak-256 hash of order.\r\n    function getOrderHash(address[5] orderAddresses, uint256[6] orderValues)\r\n        public\r\n        view\r\n        returns (bytes32);\r\n\r\n    /// @dev Verifies that an order signature is valid.\r\n    /// @param signer address of signer.\r\n    /// @param hash Signed Keccak-256 hash.\r\n    /// @param v ECDSA signature parameter v.\r\n    /// @param r ECDSA signature parameters r.\r\n    /// @param s ECDSA signature parameters s.\r\n    /// @return Validity of order signature.\r\n    function isValidSignature(\r\n        address signer,\r\n        bytes32 hash,\r\n        uint8 v,\r\n        bytes32 r,\r\n        bytes32 s)\r\n        public\r\n        pure\r\n        returns (bool);\r\n\r\n    /// @dev Checks if rounding error > 0.1%.\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to multiply with numerator/denominator.\r\n    /// @return Rounding error is present.\r\n    function isRoundingError(uint256 numerator, uint256 denominator, uint256 target)\r\n        public\r\n        pure\r\n        returns (bool);\r\n\r\n    /// @dev Calculates partial value given a numerator and denominator.\r\n    /// @param numerator Numerator.\r\n    /// @param denominator Denominator.\r\n    /// @param target Value to calculate partial of.\r\n    /// @return Partial value of target.\r\n    function getPartialAmount(uint256 numerator, uint256 denominator, uint256 target)\r\n        public\r\n        pure\r\n        returns (uint256);\r\n\r\n    /// @dev Calculates the sum of values already filled and cancelled for a given order.\r\n    /// @param orderHash The Keccak-256 hash of the given order.\r\n    /// @return Sum of values already filled and cancelled.\r\n    function getUnavailableTakerTokenAmount(bytes32 orderHash)\r\n        public\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/lib/MathHelpers.sol\r\n\r\n/**\r\n * @title MathHelpers\r\n * @author dYdX\r\n *\r\n * This library helps with common math functions in Solidity\r\n */\r\nlibrary MathHelpers {\r\n    using SafeMath for uint256;\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              target * numerator / denominator\r\n     */\r\n    function getPartialAmount(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return numerator.mul(target).div(denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates partial value given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator\r\n     * @param  denominator  Denominator\r\n     * @param  target       Value to calculate partial of\r\n     * @return              Rounded-up result of target * numerator / denominator\r\n     */\r\n    function getPartialAmountRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator,\r\n        uint256 target\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return divisionRoundedUp(numerator.mul(target), denominator);\r\n    }\r\n\r\n    /**\r\n     * Calculates division given a numerator and denominator, rounded up.\r\n     *\r\n     * @param  numerator    Numerator.\r\n     * @param  denominator  Denominator.\r\n     * @return              Rounded-up result of numerator / denominator\r\n     */\r\n    function divisionRoundedUp(\r\n        uint256 numerator,\r\n        uint256 denominator\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        assert(denominator != 0); // coverage-enable-line\r\n        if (numerator == 0) {\r\n            return 0;\r\n        }\r\n        return numerator.sub(1).div(denominator).add(1);\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint256(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return 2 ** 256 - 1;\r\n    }\r\n\r\n    /**\r\n     * Calculates and returns the maximum value for a uint256 in solidity\r\n     *\r\n     * @return  The maximum value for uint256\r\n     */\r\n    function maxUint32(\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint32)\r\n    {\r\n        return 2 ** 32 - 1;\r\n    }\r\n\r\n    /**\r\n     * Returns the number of bits in a uint256. That is, the lowest number, x, such that n >> x == 0\r\n     *\r\n     * @param  n  The uint256 to get the number of bits in\r\n     * @return    The number of bits in n\r\n     */\r\n    function getNumBits(\r\n        uint256 n\r\n    )\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        uint256 first = 0;\r\n        uint256 last = 256;\r\n        while (first < last) {\r\n            uint256 check = (first + last) / 2;\r\n            if ((n >> check) == 0) {\r\n                last = check;\r\n            } else {\r\n                first = check + 1;\r\n            }\r\n        }\r\n        assert(first <= 256);\r\n        return first;\r\n    }\r\n}\r\n\r\n// File: contracts/lib/GeneralERC20.sol\r\n\r\n/**\r\n * @title GeneralERC20\r\n * @author dYdX\r\n *\r\n * Interface for using ERC20 Tokens. We have to use a special interface to call ERC20 functions so\r\n * that we dont automatically revert when calling non-compliant tokens that have no return value for\r\n * transfer(), transferFrom(), or approve().\r\n */\r\ninterface GeneralERC20 {\r\n    function totalSupply(\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function balanceOf(\r\n        address who\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function allowance(\r\n        address owner,\r\n        address spender\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n\r\n    function transfer(\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n\r\n    function transferFrom(\r\n        address from,\r\n        address to,\r\n        uint256 value\r\n    )\r\n        external;\r\n\r\n    function approve(\r\n        address spender,\r\n        uint256 value\r\n    )\r\n        external;\r\n}\r\n\r\n// File: contracts/lib/TokenInteract.sol\r\n\r\n/**\r\n * @title TokenInteract\r\n * @author dYdX\r\n *\r\n * This library contains functions for interacting with ERC20 tokens\r\n */\r\nlibrary TokenInteract {\r\n    function balanceOf(\r\n        address token,\r\n        address owner\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GeneralERC20(token).balanceOf(owner);\r\n    }\r\n\r\n    function allowance(\r\n        address token,\r\n        address owner,\r\n        address spender\r\n    )\r\n        internal\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return GeneralERC20(token).allowance(owner, spender);\r\n    }\r\n\r\n    function approve(\r\n        address token,\r\n        address spender,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        GeneralERC20(token).approve(spender, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#approve: Approval failed\"\r\n        );\r\n    }\r\n\r\n    function transfer(\r\n        address token,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        address from = address(this);\r\n        if (\r\n            amount == 0\r\n            || from == to\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        GeneralERC20(token).transfer(to, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#transfer: Transfer failed\"\r\n        );\r\n    }\r\n\r\n    function transferFrom(\r\n        address token,\r\n        address from,\r\n        address to,\r\n        uint256 amount\r\n    )\r\n        internal\r\n    {\r\n        if (\r\n            amount == 0\r\n            || from == to\r\n        ) {\r\n            return;\r\n        }\r\n\r\n        GeneralERC20(token).transferFrom(from, to, amount);\r\n\r\n        require(\r\n            checkSuccess(),\r\n            \"TokenInteract#transferFrom: TransferFrom failed\"\r\n        );\r\n    }\r\n\r\n    // ============ Private Helper-Functions ============\r\n\r\n    /**\r\n     * Checks the return value of the previous function up to 32 bytes. Returns true if the previous\r\n     * function returned 0 bytes or 32 bytes that are not all-zero.\r\n     */\r\n    function checkSuccess(\r\n    )\r\n        private\r\n        pure\r\n        returns (bool)\r\n    {\r\n        uint256 returnValue = 0;\r\n\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            // check number of bytes returned from last function call\r\n            switch returndatasize\r\n\r\n            // no bytes returned: assume success\r\n            case 0x0 {\r\n                returnValue := 1\r\n            }\r\n\r\n            // 32 bytes returned: check if non-zero\r\n            case 0x20 {\r\n                // copy 32 bytes into scratch space\r\n                returndatacopy(0x0, 0x0, 0x20)\r\n\r\n                // load those bytes into returnValue\r\n                returnValue := mload(0x0)\r\n            }\r\n\r\n            // not sure what was returned: dont mark as success\r\n            default { }\r\n        }\r\n\r\n        return returnValue != 0;\r\n    }\r\n}\r\n\r\n// File: contracts/margin/interfaces/ExchangeReader.sol\r\n\r\n/**\r\n * @title ExchangeReader\r\n * @author dYdX\r\n *\r\n * Contract interface that wraps an exchange and provides information about the current state of the\r\n * exchange or particular orders\r\n */\r\ninterface ExchangeReader {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Get the maxmimum amount of makerToken for some order\r\n     *\r\n     * @param  makerToken           Address of makerToken, the token to receive\r\n     * @param  takerToken           Address of takerToken, the token to pay\r\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                      Maximum amount of makerToken\r\n     */\r\n    function getMaxMakerAmount(\r\n        address makerToken,\r\n        address takerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/margin/interfaces/ExchangeWrapper.sol\r\n\r\n/**\r\n * @title ExchangeWrapper\r\n * @author dYdX\r\n *\r\n * Contract interface that Exchange Wrapper smart contracts must implement in order to interface\r\n * with other smart contracts through a common interface.\r\n */\r\ninterface ExchangeWrapper {\r\n\r\n    // ============ Public Functions ============\r\n\r\n    /**\r\n     * Exchange some amount of takerToken for makerToken.\r\n     *\r\n     * @param  tradeOriginator      Address of the initiator of the trade (however, this value\r\n     *                              cannot always be trusted as it is set at the discretion of the\r\n     *                              msg.sender)\r\n     * @param  receiver             Address to set allowance on once the trade has completed\r\n     * @param  makerToken           Address of makerToken, the token to receive\r\n     * @param  takerToken           Address of takerToken, the token to pay\r\n     * @param  requestedFillAmount  Amount of takerToken being paid\r\n     * @param  orderData            Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                      The amount of makerToken received\r\n     */\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes orderData\r\n    )\r\n        external\r\n        returns (uint256);\r\n\r\n    /**\r\n     * Get amount of takerToken required to buy a certain amount of makerToken for a given trade.\r\n     * Should match the takerToken amount used in exchangeForAmount. If the order cannot provide\r\n     * exactly desiredMakerToken, then it must return the price to buy the minimum amount greater\r\n     * than desiredMakerToken\r\n     *\r\n     * @param  makerToken         Address of makerToken, the token to receive\r\n     * @param  takerToken         Address of takerToken, the token to pay\r\n     * @param  desiredMakerToken  Amount of makerToken requested\r\n     * @param  orderData          Arbitrary bytes data for any information to pass to the exchange\r\n     * @return                    Amount of takerToken the needed to complete the transaction\r\n     */\r\n    function getExchangeCost(\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 desiredMakerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256);\r\n}\r\n\r\n// File: contracts/margin/external/exchangewrappers/ZeroExV1ExchangeWrapper.sol\r\n\r\n/**\r\n * @title ZeroExV1ExchangeWrapper\r\n * @author dYdX\r\n *\r\n * dYdX ExchangeWrapper to interface with 0x Version 1\r\n */\r\ncontract ZeroExV1ExchangeWrapper is\r\n    ExchangeWrapper,\r\n    ExchangeReader\r\n{\r\n    using SafeMath for uint256;\r\n    using TokenInteract for address;\r\n\r\n    // ============ Structs ============\r\n\r\n    struct Order {\r\n        address maker;\r\n        address taker;\r\n        address feeRecipient;\r\n        uint256 makerTokenAmount;\r\n        uint256 takerTokenAmount;\r\n        uint256 makerFee;\r\n        uint256 takerFee;\r\n        uint256 expirationUnixTimestampSec;\r\n        uint256 salt;\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n    }\r\n\r\n    // ============ State Variables ============\r\n\r\n    // msg.senders that will put the correct tradeOriginator in callerData when doing an exchange\r\n    mapping (address => bool) public TRUSTED_MSG_SENDER;\r\n\r\n    // address of the ZeroEx V1 Exchange\r\n    address public ZERO_EX_EXCHANGE;\r\n\r\n    // address of the ZeroEx V1 TokenTransferProxy\r\n    address public ZERO_EX_TOKEN_PROXY;\r\n\r\n    // address of the ZRX token\r\n    address public ZRX;\r\n\r\n    // ============ Constructor ============\r\n\r\n    constructor(\r\n        address zeroExExchange,\r\n        address zeroExProxy,\r\n        address zrxToken,\r\n        address[] trustedMsgSenders\r\n    )\r\n        public\r\n    {\r\n        ZERO_EX_EXCHANGE = zeroExExchange;\r\n        ZERO_EX_TOKEN_PROXY = zeroExProxy;\r\n        ZRX = zrxToken;\r\n\r\n        for (uint256 i = 0; i < trustedMsgSenders.length; i++) {\r\n            TRUSTED_MSG_SENDER[trustedMsgSenders[i]] = true;\r\n        }\r\n\r\n        // The ZRX token does not decrement allowance if set to MAX_UINT\r\n        // therefore setting it once to the maximum amount is sufficient\r\n        // NOTE: this is *not* standard behavior for an ERC20, so do not rely on it for other tokens\r\n        ZRX.approve(ZERO_EX_TOKEN_PROXY, MathHelpers.maxUint256());\r\n    }\r\n\r\n    // ============ Public Functions ============\r\n\r\n    function exchange(\r\n        address tradeOriginator,\r\n        address receiver,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount,\r\n        bytes orderData\r\n    )\r\n        external\r\n        returns (uint256)\r\n    {\r\n        Order memory order = parseOrder(orderData);\r\n\r\n        require(\r\n            requestedFillAmount <= order.takerTokenAmount,\r\n            \"ZeroExV1ExchangeWrapper#exchange: Requested fill amount larger than order size\"\r\n        );\r\n\r\n        require(\r\n            requestedFillAmount <= takerToken.balanceOf(address(this)),\r\n            \"ZeroExV1ExchangeWrapper#exchange: Requested fill amount larger than tokens held\"\r\n        );\r\n\r\n        transferTakerFee(\r\n            order,\r\n            tradeOriginator,\r\n            requestedFillAmount\r\n        );\r\n\r\n        ensureAllowance(\r\n            takerToken,\r\n            ZERO_EX_TOKEN_PROXY,\r\n            requestedFillAmount\r\n        );\r\n\r\n        uint256 receivedMakerTokenAmount = doTrade(\r\n            order,\r\n            makerToken,\r\n            takerToken,\r\n            requestedFillAmount\r\n        );\r\n\r\n        ensureAllowance(\r\n            makerToken,\r\n            receiver,\r\n            receivedMakerTokenAmount\r\n        );\r\n\r\n        return receivedMakerTokenAmount;\r\n    }\r\n\r\n    function getExchangeCost(\r\n        address /* makerToken */,\r\n        address /* takerToken */,\r\n        uint256 desiredMakerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        Order memory order = parseOrder(orderData);\r\n\r\n        return MathHelpers.getPartialAmountRoundedUp(\r\n            order.takerTokenAmount,\r\n            order.makerTokenAmount,\r\n            desiredMakerToken\r\n        );\r\n    }\r\n\r\n    function getMaxMakerAmount(\r\n        address makerToken,\r\n        address takerToken,\r\n        bytes orderData\r\n    )\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        address zeroExExchange = ZERO_EX_EXCHANGE;\r\n        Order memory order = parseOrder(orderData);\r\n\r\n        // order cannot be taken if expired\r\n        if (block.timestamp >= order.expirationUnixTimestampSec) {\r\n            return 0;\r\n        }\r\n\r\n        bytes32 orderHash = getOrderHash(\r\n            zeroExExchange,\r\n            makerToken,\r\n            takerToken,\r\n            order\r\n        );\r\n\r\n        uint256 unavailableTakerAmount =\r\n            ZeroExExchangeInterfaceV1(zeroExExchange).getUnavailableTakerTokenAmount(orderHash);\r\n        uint256 takerAmount = order.takerTokenAmount.sub(unavailableTakerAmount);\r\n        uint256 makerAmount = MathHelpers.getPartialAmount(\r\n            takerAmount,\r\n            order.takerTokenAmount,\r\n            order.makerTokenAmount\r\n        );\r\n\r\n        return makerAmount;\r\n    }\r\n\r\n    // ============ Private Functions ============\r\n\r\n    function transferTakerFee(\r\n        Order memory order,\r\n        address tradeOriginator,\r\n        uint256 requestedFillAmount\r\n    )\r\n        private\r\n    {\r\n        if (order.feeRecipient == address(0)) {\r\n            return;\r\n        }\r\n\r\n        uint256 takerFee = MathHelpers.getPartialAmount(\r\n            requestedFillAmount,\r\n            order.takerTokenAmount,\r\n            order.takerFee\r\n        );\r\n\r\n        if (takerFee == 0) {\r\n            return;\r\n        }\r\n\r\n        require(\r\n            TRUSTED_MSG_SENDER[msg.sender],\r\n            \"ZeroExV1ExchangeWrapper#transferTakerFee: Only trusted senders can dictate the fee payer\"\r\n        );\r\n\r\n        ZRX.transferFrom(\r\n            tradeOriginator,\r\n            address(this),\r\n            takerFee\r\n        );\r\n    }\r\n\r\n    function doTrade(\r\n        Order memory order,\r\n        address makerToken,\r\n        address takerToken,\r\n        uint256 requestedFillAmount\r\n    )\r\n        private\r\n        returns (uint256)\r\n    {\r\n        uint256 filledTakerTokenAmount = ZeroExExchangeInterfaceV1(ZERO_EX_EXCHANGE).fillOrder(\r\n            [\r\n                order.maker,\r\n                order.taker,\r\n                makerToken,\r\n                takerToken,\r\n                order.feeRecipient\r\n            ],\r\n            [\r\n                order.makerTokenAmount,\r\n                order.takerTokenAmount,\r\n                order.makerFee,\r\n                order.takerFee,\r\n                order.expirationUnixTimestampSec,\r\n                order.salt\r\n            ],\r\n            requestedFillAmount,\r\n            true,\r\n            order.v,\r\n            order.r,\r\n            order.s\r\n        );\r\n\r\n        require(\r\n            filledTakerTokenAmount == requestedFillAmount,\r\n            \"ZeroExV1ExchangeWrapper#doTrade: Could not fill requested amount\"\r\n        );\r\n\r\n        uint256 receivedMakerTokenAmount = MathHelpers.getPartialAmount(\r\n            filledTakerTokenAmount,\r\n            order.takerTokenAmount,\r\n            order.makerTokenAmount\r\n        );\r\n\r\n        return receivedMakerTokenAmount;\r\n    }\r\n\r\n    function ensureAllowance(\r\n        address token,\r\n        address spender,\r\n        uint256 requiredAmount\r\n    )\r\n        private\r\n    {\r\n        if (token.allowance(address(this), spender) >= requiredAmount) {\r\n            return;\r\n        }\r\n\r\n        token.approve(\r\n            spender,\r\n            MathHelpers.maxUint256()\r\n        );\r\n    }\r\n\r\n    function getOrderHash(\r\n        address exchangeAddress,\r\n        address makerToken,\r\n        address takerToken,\r\n        Order memory order\r\n    )\r\n        private\r\n        pure\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                exchangeAddress,\r\n                order.maker,\r\n                order.taker,\r\n                makerToken,\r\n                takerToken,\r\n                order.feeRecipient,\r\n                order.makerTokenAmount,\r\n                order.takerTokenAmount,\r\n                order.makerFee,\r\n                order.takerFee,\r\n                order.expirationUnixTimestampSec,\r\n                order.salt\r\n            )\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Accepts a byte array with each variable padded to 32 bytes\r\n     */\r\n    function parseOrder(\r\n        bytes orderData\r\n    )\r\n        private\r\n        pure\r\n        returns (Order memory)\r\n    {\r\n        Order memory order;\r\n\r\n        /**\r\n         * Total: 384 bytes\r\n         * mstore stores 32 bytes at a time, so go in increments of 32 bytes\r\n         *\r\n         * NOTE: The first 32 bytes in an array stores the length, so we start reading from 32\r\n         */\r\n        /* solium-disable-next-line security/no-inline-assembly */\r\n        assembly {\r\n            mstore(order,           mload(add(orderData, 32)))  // maker\r\n            mstore(add(order, 32),  mload(add(orderData, 64)))  // taker\r\n            mstore(add(order, 64),  mload(add(orderData, 96)))  // feeRecipient\r\n            mstore(add(order, 96),  mload(add(orderData, 128))) // makerTokenAmount\r\n            mstore(add(order, 128), mload(add(orderData, 160))) // takerTokenAmount\r\n            mstore(add(order, 160), mload(add(orderData, 192))) // makerFee\r\n            mstore(add(order, 192), mload(add(orderData, 224))) // takerFee\r\n            mstore(add(order, 224), mload(add(orderData, 256))) // expirationUnixTimestampSec\r\n            mstore(add(order, 256), mload(add(orderData, 288))) // salt\r\n            mstore(add(order, 288), mload(add(orderData, 320))) // v\r\n            mstore(add(order, 320), mload(add(orderData, 352))) // r\r\n            mstore(add(order, 352), mload(add(orderData, 384))) // s\r\n        }\r\n\r\n        return order;\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"},{\"name\":\"desiredMakerToken\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"getExchangeCost\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"getMaxMakerAmount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_EX_EXCHANGE\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"tradeOriginator\",\"type\":\"address\"},{\"name\":\"receiver\",\"type\":\"address\"},{\"name\":\"makerToken\",\"type\":\"address\"},{\"name\":\"takerToken\",\"type\":\"address\"},{\"name\":\"requestedFillAmount\",\"type\":\"uint256\"},{\"name\":\"orderData\",\"type\":\"bytes\"}],\"name\":\"exchange\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZERO_EX_TOKEN_PROXY\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ZRX\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"TRUSTED_MSG_SENDER\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"zeroExExchange\",\"type\":\"address\"},{\"name\":\"zeroExProxy\",\"type\":\"address\"},{\"name\":\"zrxToken\",\"type\":\"address\"},{\"name\":\"trustedMsgSenders\",\"type\":\"address[]\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"}]","ContractName":"ZeroExV1ExchangeWrapper","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"10000","ConstructorArguments":"00000000000000000000000012459c951127e0c374ff9105dda097662a0270930000000000000000000000008da0d80f5007ef1e431dd2127178d224e32c2ef4000000000000000000000000e41d2489571d322189246dafa5ebde1f4699f4980000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000100000000000000000000000036bf21c8e661b21e6166e4385f574941fdc6caff","Library":"","SwarmSource":"bzzr://7d4e3e93ae7596a804bc122bb54c7c2fe76ec71fa205a5c50978bb637473f6c4"}]}