{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    function totalSupply() public view returns (uint256);\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n\r\ncontract Voting{\r\n\r\n    using SafeMath for uint;\r\n\r\n    struct Vote{\r\n        address voter;\r\n        uint enityID;\r\n        uint voted;\r\n        uint tokensStaked;\r\n        uint votingPeriod;\r\n    }\r\n\r\n    struct Entity{\r\n        uint id;\r\n        string name;\r\n        uint startTime;\r\n        uint reward;\r\n        uint noOfStakedTokens;\r\n        Vote[] votes;\r\n        uint firstPeriodOutcome;\r\n        uint secondPeriodOutcome;\r\n        uint finalOutcome;\r\n        mapping(address => bool) voteCasted;\r\n    }\r\n\r\n\r\n    Entity[] public entities;\r\n\r\n    struct Wallet{\r\n        uint voteCount;\r\n        bool registered;\r\n        uint[] lastOutcomes;\r\n    }\r\n\r\n    mapping(address => Wallet) public wallets;\r\n    address[] walletList;\r\n\r\n\r\n    mapping(uint => mapping(address => uint)) public payouts;\r\n    address public owner;\r\n\r\n    ERC20 public token;\r\n\r\n  \r\n\r\n    constructor(address _token) public{\r\n        owner = msg.sender; //TODO\r\n        token = ERC20(_token);\r\n    }\r\n\r\n    modifier onlyOwner(){\r\n        require(msg.sender == owner || msg.sender == address(this));\r\n        _;\r\n    }\r\n    \r\n    function changeOwner(address _newOwner) public onlyOwner{\r\n        require(_newOwner != 0x0);\r\n        require(_newOwner != owner);\r\n\r\n        owner = _newOwner;\r\n    }\r\n\r\n\r\n    event NewEntity(uint id, string name, uint startTime, uint reward);\r\n    function addEntity(string _name, uint _startTime, uint _reward) public onlyOwner{\r\n        require(_startTime > 0 && _reward > 0);\r\n\r\n        uint newEntityID = entities.length;\r\n\r\n        entities.length++;\r\n        Entity storage newEntity = entities[entities.length - 1];\r\n\r\n        newEntity.id = entities.length - 1;\r\n        newEntity.name = _name;\r\n        newEntity.startTime = _startTime;\r\n        newEntity.reward = _reward;\r\n        newEntity.noOfStakedTokens = 0;\r\n        newEntity.firstPeriodOutcome = 0;\r\n        newEntity.secondPeriodOutcome = 0;\r\n        newEntity.finalOutcome = 0;\r\n\r\n        Vote memory v;\r\n        newEntity.votes.push(v);\r\n        entities.push(newEntity);\r\n\r\n        token.transferFrom(msg.sender, address(this), _reward);\r\n        for(uint i = 0; i < walletList.length; i++){\r\n            wallets[walletList[i]].voteCount = wallets[walletList[i]].voteCount.sub(1);\r\n        }\r\n\r\n        emit NewEntity(newEntityID, _name, _startTime, _reward);\r\n    }\r\n\r\n    event VoteCasted(uint entityID, uint voted, uint tokenAmount, uint votingPeriod, address voter);\r\n    function castVote(uint _entityID, uint _voted, uint _tokenStaked) public{\r\n        require(_entityID >= 0 && _tokenStaked > 0);\r\n\r\n        Entity storage entity = entities[_entityID];\r\n        Wallet storage wallet = wallets[msg.sender];\r\n\r\n        require(!entity.voteCasted[msg.sender]);\r\n        require(wallet.voteCount <= 20);\r\n\r\n        if(!wallet.registered){\r\n            uint[] memory empty;\r\n            wallets[msg.sender] = Wallet(0, true, empty);\r\n            walletList.push(msg.sender);\r\n        }\r\n        \r\n        uint votingPeriod;  \r\n\r\n        // if(now >= entity.startTime && now <= entity.startTime + 7 days){\r\n        //     votingPeriod = 1;\r\n        // } else if(now > entity.startTime + 7 days && now <= entity.startTime + 14 days){\r\n        //     votingPeriod = 2;\r\n        // } else {\r\n        //     return;\r\n        // }\r\n\r\n\r\n        if(now >= entity.startTime && now <= entity.startTime + 5 seconds){\r\n            votingPeriod = 1;\r\n        } else if(now > entity.startTime + 5 seconds && now <= entity.startTime + 10 seconds){\r\n            if(entity.firstPeriodOutcome == 0){\r\n                this.determineFirstPeriodOutcome(entity.id);\r\n            }\r\n\r\n            require(entity.firstPeriodOutcome != _voted);\r\n            votingPeriod = 2;\r\n\r\n        } else {\r\n            revert();\r\n        }\r\n\r\n        entity.votes.push(Vote(msg.sender, _entityID, _voted, _tokenStaked, votingPeriod));\r\n        entity.noOfStakedTokens = entity.noOfStakedTokens.add(_tokenStaked);\r\n\r\n        token.transferFrom(msg.sender, address(this), _tokenStaked);\r\n\r\n        wallet.voteCount = wallet.voteCount.add(1);\r\n\r\n        entity.voteCasted[msg.sender] = true;\r\n\r\n        emit VoteCasted(_entityID, _voted, _tokenStaked, votingPeriod, msg.sender);\r\n    }\r\n\r\n    function getYESVotesByEntity(uint _entityID) public view returns(uint){\r\n        require(_entityID >= 0);\r\n\r\n        Entity memory entity = entities[_entityID];\r\n\r\n        uint count = 0;\r\n\r\n        for(uint i = 0; i < entity.votes.length; i++){\r\n            if(entity.votes[i].voted == 1){\r\n                count = count.add(1);\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n\r\n    function getNOVotesByEntity(uint _entityID) public view returns(uint){\r\n        require(_entityID >= 0);\r\n\r\n        Entity memory entity = entities[_entityID];\r\n\r\n        uint count = 0;\r\n\r\n        for(uint i = 0; i < entity.votes.length; i++){\r\n            if(entity.votes[i].voted == 2){\r\n                count = count.add(1);\r\n            }\r\n        }\r\n\r\n        return count;\r\n    }\r\n\r\n    function getCurrentPeriodByEntity(uint _entityID) public view returns(uint){\r\n        require(_entityID >= 0);\r\n\r\n        Entity memory entity = entities[_entityID];\r\n\r\n        uint time = entity.startTime;\r\n\r\n        uint period = 0;\r\n\r\n        if(now >= time && now < time + 5 seconds){\r\n            period = 1;\r\n        }\r\n        else if(now >= time + 5 seconds && now <= time + 10 seconds ){\r\n            period = 2;\r\n        }\r\n\r\n        return period;\r\n\r\n    }\r\n\r\n    function getOutcomeOfFirstPeriodByEntity(uint _entityID) public view returns(uint){\r\n        require(_entityID >= 0);\r\n        return entities[_entityID].firstPeriodOutcome;\r\n    }\r\n\r\n    function getOutcomeOfSecondPeriodByEntity(uint _entityID) public view returns(uint){\r\n        require(_entityID >= 0);\r\n        return entities[_entityID].secondPeriodOutcome;\r\n    }\r\n\r\n    function getFinalOutcomeByEntity(uint _entityID) public view returns(uint){\r\n        require(_entityID >= 0);\r\n        return entities[_entityID].finalOutcome;\r\n    }\r\n\r\n    function getVotingPower(uint _noOfStakedTokens, uint _VotertokensStaked, address voter) public view returns(uint){\r\n\r\n        Wallet memory w = wallets[voter];\r\n\r\n        uint Co = 0;\r\n        uint Io = 0;\r\n        uint i = 0;\r\n        if(w.lastOutcomes.length > 20){\r\n            uint counter = w.lastOutcomes.length - 20;\r\n\r\n            for(i = 0; i < 20; i++){\r\n                if(w.lastOutcomes[counter] == 1){\r\n                    Co = Co.add(1);\r\n                } else if(w.lastOutcomes[counter] == 2){\r\n                    Io = Io.add(1);\r\n                }\r\n                counter = counter.add(1);\r\n            }\r\n        }\r\n        else {\r\n            for(i = 0; i < w.lastOutcomes.length; i++){\r\n                if(w.lastOutcomes[i] == 1){\r\n                    Co = Co.add(1);\r\n                } else if(w.lastOutcomes[i] == 2){\r\n                    Io = Io.add(1);\r\n                }\r\n            }\r\n        }\r\n\r\n        uint Si = _VotertokensStaked;\r\n        uint St = _noOfStakedTokens;\r\n\r\n        uint Vmax = w.voteCount; // ?? TODO\r\n\r\n        return getResult(Co, Io, Si, St, Vmax);\r\n        \r\n    \r\n\r\n    }\r\n\r\n    function getResult(uint Co, uint Io, uint Si, uint St, uint Vmax) public pure returns(uint){\r\n\r\n        uint Vp = 1 + ((Co.sub(Io).div(Vmax)).mul(1).div(20) + (Si.div(St)).mul(3).div(20));\r\n// Vp = 1 + (0.05 x (Co - Io / Vm+x) + (0.15 * (Si / St)))\r\n        return Vp;\r\n    }\r\n\r\n    event FirstPeriodOutcome(uint entityID, uint outcome);\r\n    function determineFirstPeriodOutcome(uint _entityID) external onlyOwner{\r\n        require(_entityID >= 0);\r\n\r\n        Entity storage entity = entities[_entityID];\r\n\r\n        uint yesVotesPower = 0;\r\n        uint noVotesPower = 0;\r\n\r\n\r\n        uint i = 0;\r\n        for(i = 0; i < entity.votes.length; i++){\r\n            uint votingPower = 0;\r\n            if(entity.votes[i].votingPeriod == 1 && entity.votes[i].voted == 1){\r\n\r\n                votingPower = getVotingPower(entity.noOfStakedTokens, entity.votes[i].tokensStaked, entity.votes[i].voter);\r\n                yesVotesPower = yesVotesPower.add(votingPower);\r\n\r\n            } else if(entity.votes[i].votingPeriod == 1 && entity.votes[i].voted == 2){\r\n\r\n                votingPower = getVotingPower(entity.noOfStakedTokens, entity.votes[i].tokensStaked, entity.votes[i].voter);\r\n                noVotesPower = noVotesPower.add(votingPower);\r\n\r\n            }\r\n        }\r\n\r\n        uint totalVotingPower = yesVotesPower + noVotesPower;\r\n\r\n        uint yes_percent = yesVotesPower.mul(100).div(totalVotingPower);\r\n        uint no_percent = noVotesPower.mul(100).div(totalVotingPower);\r\n\r\n        if(yes_percent > no_percent){\r\n            entity.firstPeriodOutcome = 1;\r\n        }else{\r\n            entity.firstPeriodOutcome = 2;\r\n        }\r\n\r\n        emit FirstPeriodOutcome(_entityID, entity.firstPeriodOutcome);\r\n    }\r\n\r\n\r\n    // event SecondPeriodOutcome(uint entityID, uint outcome);\r\n    function determineOutcome(uint _entityID) external onlyOwner{\r\n        require(_entityID >= 0);\r\n\r\n        Entity storage entity = entities[_entityID];\r\n\r\n        // require(now > entity.startTime + 5 seconds);\r\n        if(entity.firstPeriodOutcome == 0){\r\n            this.determineFirstPeriodOutcome(entity.id);\r\n        }\r\n\r\n        uint yesVotesPower = 0;\r\n        uint noVotesPower = 0;\r\n\r\n        bool voteExists;\r\n\r\n\r\n        uint i = 0;\r\n        for(i = 0; i < entity.votes.length; i++){\r\n            uint votingPower = 0;\r\n            if(entity.votes[i].votingPeriod == 2 && entity.votes[i].voted == 1){\r\n\r\n                votingPower = getVotingPower(entity.noOfStakedTokens, entity.votes[i].tokensStaked, entity.votes[i].voter);\r\n                yesVotesPower = yesVotesPower.add(votingPower);\r\n                voteExists = true;\r\n\r\n            } else if(entity.votes[i].votingPeriod == 2 && entity.votes[i].voted == 2){\r\n\r\n                votingPower = getVotingPower(entity.noOfStakedTokens, entity.votes[i].tokensStaked, entity.votes[i].voter);\r\n                noVotesPower = noVotesPower.add(votingPower);\r\n                voteExists = true;\r\n\r\n            }\r\n        }\r\n\r\n        if(voteExists){\r\n            uint totalVotingPower = yesVotesPower + noVotesPower;\r\n\r\n            uint yes_percent = yesVotesPower.mul(100).div(totalVotingPower);\r\n            uint no_percent = noVotesPower.mul(100).div(totalVotingPower);\r\n\r\n            if(yes_percent > no_percent){\r\n                entity.secondPeriodOutcome = 1;\r\n            }else{\r\n                entity.secondPeriodOutcome = 2;\r\n            }\r\n\r\n        }\r\n\r\n        this.determineFinalOutcome(entity.id);\r\n        // emit SecondPeriodOutcome(_entityID,entity.secondPeriodOutcome);\r\n\r\n\r\n    }\r\n\r\n    event FinalOutcome(uint entityID, uint outcome);\r\n    function determineFinalOutcome(uint _entityID) external onlyOwner{\r\n        require(_entityID >= 0);\r\n\r\n        Entity storage entity = entities[_entityID];\r\n        uint i = 0;\r\n\r\n        if(entity.secondPeriodOutcome == 0){\r\n            uint votingPowerYes = 0;\r\n            uint votingPowerNo = 0;\r\n\r\n            for(i = 0; i < entity.votes.length; i++){\r\n                if(entity.votes[i].votingPeriod == 1 && entity.votes[i].voted == 1){\r\n                    votingPowerYes = votingPowerYes.add(getVotingPower(entity.noOfStakedTokens, entity.votes[i].tokensStaked, entity.votes[i].voter));\r\n                } else if(entity.votes[i].votingPeriod == 1 && entity.votes[i].voted == 2){\r\n                    votingPowerNo = votingPowerNo.add(getVotingPower(entity.noOfStakedTokens, entity.votes[i].tokensStaked, entity.votes[i].voter));\r\n                }\r\n            }\r\n\r\n            uint total = votingPowerYes + votingPowerNo;\r\n            uint percent_yes = votingPowerYes.mul(100).div(total);\r\n            uint percent_no = votingPowerNo.mul(100).div(total);\r\n\r\n            if(percent_yes >= uint(251).div(5)){\r\n                entity.finalOutcome = 1;\r\n            } else if(percent_no >= uint(251).div(5)){\r\n                entity.finalOutcome = 2;\r\n            }\r\n\r\n        } else {\r\n\r\n         \r\n            uint votingPower1 = 0;\r\n            uint votingPower2 = 0;\r\n\r\n            for(i = 0; i < entity.votes.length; i++){\r\n                if(entity.votes[i].votingPeriod == 1 && entity.votes[i].voted == entity.firstPeriodOutcome){\r\n                    votingPower1 = votingPower1.add(getVotingPower(entity.noOfStakedTokens, entity.votes[i].tokensStaked, entity.votes[i].voter));\r\n                } else if(entity.votes[i].votingPeriod == 2){\r\n                    votingPower2 = votingPower2.add(getVotingPower(entity.noOfStakedTokens, entity.votes[i].tokensStaked, entity.votes[i].voter));\r\n                }\r\n            }\r\n\r\n\r\n            uint totalPower = votingPower1 + votingPower2;\r\n\r\n            uint first_percent = votingPower1.mul(100).div(totalPower);\r\n            uint second_percent = votingPower2.mul(100).div(totalPower);\r\n\r\n            if(second_percent > 60){\r\n                entity.finalOutcome = entity.secondPeriodOutcome;\r\n            } else {\r\n                entity.finalOutcome = entity.firstPeriodOutcome;\r\n            }\r\n            \r\n        }\r\n\r\n        setPayoutForWinners(entity.finalOutcome, entity);\r\n        emit FinalOutcome(_entityID, entity.finalOutcome);\r\n    }\r\n\r\n    event PayoutSet(uint en,address voter, uint amount);\r\n    function setPayoutForWinners(uint _outcome, Entity memory entity) internal{\r\n        \r\n        uint reward = entity.reward;\r\n        uint totalStakedTokens = entity.noOfStakedTokens;\r\n\r\n        Vote[] memory votes = entity.votes;\r\n\r\n        uint i = 0;\r\n\r\n        for(i = 0; i < votes.length; i++){\r\n            if(votes[i].voted == _outcome){\r\n\r\n                uint stakedTokensByVoter = votes[i].tokensStaked;\r\n                uint percent_coin = stakedTokensByVoter.mul(100).div(totalStakedTokens);\r\n                uint percent_reward = reward.mul(percent_coin).div(100);\r\n\r\n                uint claimableAmount = stakedTokensByVoter + percent_reward;\r\n\r\n                payouts[entity.id][votes[i].voter] = claimableAmount;\r\n                wallets[votes[i].voter].lastOutcomes.push(1);\r\n                // emit PayoutSet(entity.id, votes[i].voter, payouts[entity.id][votes[i].voter]);\r\n\r\n            } else {\r\n                wallets[votes[i].voter].lastOutcomes.push(2);\r\n            }\r\n        }\r\n    }\r\n\r\n    event TokenClaimed(address claimer, uint amount);\r\n    function claimTokens(uint _entityID) external{\r\n        require(_entityID >= 0);\r\n\r\n        uint claimableAmount = payouts[_entityID][msg.sender];\r\n        require(token.balanceOf(address(this)) >= claimableAmount);\r\n\r\n        payouts[_entityID][msg.sender] = 0;\r\n\r\n        token.transfer(msg.sender, claimableAmount);\r\n\r\n        emit TokenClaimed(msg.sender, claimableAmount);\r\n    }\r\n\r\n\r\n    // function getEntity(uint _entityID) public view returns(){\r\n    //     require(_entityID >= 0);\r\n    //     Entity memory entity = entities[_entityID];\r\n\r\n    // }\r\n\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"getNOVotesByEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"getFinalOutcomeByEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"getCurrentPeriodByEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_noOfStakedTokens\",\"type\":\"uint256\"},{\"name\":\"_VotertokensStaked\",\"type\":\"uint256\"},{\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"getVotingPower\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"getOutcomeOfSecondPeriodByEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"claimTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"payouts\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"},{\"name\":\"_voted\",\"type\":\"uint256\"},{\"name\":\"_tokenStaked\",\"type\":\"uint256\"}],\"name\":\"castVote\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"entities\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"string\"},{\"name\":\"startTime\",\"type\":\"uint256\"},{\"name\":\"reward\",\"type\":\"uint256\"},{\"name\":\"noOfStakedTokens\",\"type\":\"uint256\"},{\"name\":\"firstPeriodOutcome\",\"type\":\"uint256\"},{\"name\":\"secondPeriodOutcome\",\"type\":\"uint256\"},{\"name\":\"finalOutcome\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"getYESVotesByEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"Co\",\"type\":\"uint256\"},{\"name\":\"Io\",\"type\":\"uint256\"},{\"name\":\"Si\",\"type\":\"uint256\"},{\"name\":\"St\",\"type\":\"uint256\"},{\"name\":\"Vmax\",\"type\":\"uint256\"}],\"name\":\"getResult\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"wallets\",\"outputs\":[{\"name\":\"voteCount\",\"type\":\"uint256\"},{\"name\":\"registered\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"getOutcomeOfFirstPeriodByEntity\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_name\",\"type\":\"string\"},{\"name\":\"_startTime\",\"type\":\"uint256\"},{\"name\":\"_reward\",\"type\":\"uint256\"}],\"name\":\"addEntity\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"changeOwner\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"determineFinalOutcome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"determineFirstPeriodOutcome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_entityID\",\"type\":\"uint256\"}],\"name\":\"determineOutcome\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"token\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"id\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"name\",\"type\":\"string\"},{\"indexed\":false,\"name\":\"startTime\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"NewEntity\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"entityID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voted\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"tokenAmount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"votingPeriod\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"}],\"name\":\"VoteCasted\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"entityID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"outcome\",\"type\":\"uint256\"}],\"name\":\"FirstPeriodOutcome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"entityID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"outcome\",\"type\":\"uint256\"}],\"name\":\"FinalOutcome\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"en\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"voter\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"PayoutSet\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"claimer\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokenClaimed\",\"type\":\"event\"}]","ContractName":"Voting","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000eed2b7756e295a9300e53dd049aeb0751899bae3","Library":"","SwarmSource":"bzzr://cd2e055e4a5cdd782286eb6aa9e9370f15572da24163f1c2bf4efb62e8015176"}]}