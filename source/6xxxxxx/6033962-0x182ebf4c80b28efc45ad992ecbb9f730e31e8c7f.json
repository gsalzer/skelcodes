{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n    uint256 public totalSupply;\r\n    function balanceOf(address who) public view returns (uint256);\r\n    function transfer(address to, uint256 value) public returns (bool);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n    function allowance(address owner, address spender) public view returns (uint256);\r\n    function transferFrom(address from, address to, uint256 value) public returns (bool);\r\n    function approve(address spender, uint256 value) public returns (bool);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        uint256 c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return c;\r\n    }\r\n\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        uint256 c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\n/*\r\n * @title MerkleProof\r\n * @dev Merkle proof verification\r\n * @note Based on https://github.com/ameensol/merkle-tree-solidity/blob/master/src/MerkleProof.sol\r\n */\r\nlibrary MerkleProof {\r\n  /*\r\n   * @dev Verifies a Merkle proof proving the existence of a leaf in a Merkle tree. Assumes that each pair of leaves\r\n   * and each pair of pre-images is sorted.\r\n   * @param _proof Merkle proof containing sibling hashes on the branch from the leaf to the root of the Merkle tree\r\n   * @param _root Merkle root\r\n   * @param _leaf Leaf of Merkle tree\r\n   */\r\n  function verifyProof(bytes _proof, bytes32 _root, bytes32 _leaf) public pure returns (bool) {\r\n    // Check if proof length is a multiple of 32\r\n    if (_proof.length % 32 != 0) return false;\r\n\r\n    bytes32 proofElement;\r\n    bytes32 computedHash = _leaf;\r\n\r\n    for (uint256 i = 32; i <= _proof.length; i += 32) {\r\n      assembly {\r\n        // Load the current element of the proof\r\n        proofElement := mload(add(_proof, i))\r\n      }\r\n\r\n      if (computedHash < proofElement) {\r\n        // Hash(current computed hash + current element of the proof)\r\n        computedHash = keccak256(computedHash, proofElement);\r\n      } else {\r\n        // Hash(current element of the proof + current computed hash)\r\n        computedHash = keccak256(proofElement, computedHash);\r\n      }\r\n    }\r\n\r\n    // Check if the computed hash (root) is equal to the provided root\r\n    return computedHash == _root;\r\n  }\r\n}\r\n\r\n/**\r\n * @title MerkleMine\r\n * @dev Token distribution based on providing Merkle proofs of inclusion in genesis state to generate allocation\r\n */\r\ncontract MerkleMine {\r\n    using SafeMath for uint256;\r\n\r\n    // ERC20 token being distributed\r\n    ERC20 public token;\r\n    // Merkle root representing genesis state which encodes token recipients\r\n    bytes32 public genesisRoot;\r\n    // Total amount of tokens that can be generated\r\n    uint256 public totalGenesisTokens;\r\n    // Total number of recipients included in genesis state\r\n    uint256 public totalGenesisRecipients;\r\n    // Amount of tokens per recipient allocation. Equal to `totalGenesisTokens` / `totalGenesisRecipients`\r\n    uint256 public tokensPerAllocation;\r\n    // Minimum ETH balance threshold for recipients included in genesis state\r\n    uint256 public balanceThreshold;\r\n    // Block number of genesis - used to determine which ETH accounts are included in the genesis state\r\n    uint256 public genesisBlock;\r\n    // Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\r\n    // As the current block gets closer to `callerAllocationEndBlock`, the caller receives a larger precentage of the allocation\r\n    uint256 public callerAllocationStartBlock;\r\n    // From this block onwards, a third party caller (not the recipient) can generate and claim the recipient's full allocation\r\n    uint256 public callerAllocationEndBlock;\r\n    // Number of blocks in the caller allocation period as defined by `callerAllocationEndBlock` - `callerAllocationStartBlock`\r\n    uint256 public callerAllocationPeriod;\r\n\r\n    // Track if the generation process is started\r\n    bool public started;\r\n\r\n    // Track the already generated allocations for recipients\r\n    mapping (address => bool) public generated;\r\n\r\n    // Check that a recipient's allocation has not been generated\r\n    modifier notGenerated(address _recipient) {\r\n        require(!generated[_recipient]);\r\n        _;\r\n    }\r\n\r\n    // Check that the generation period is started\r\n    modifier isStarted() {\r\n        require(started);\r\n        _;\r\n    }\r\n\r\n    // Check that the generation period is not started\r\n    modifier isNotStarted() {\r\n        require(!started);\r\n        _;\r\n    }\r\n\r\n    event Generate(address indexed _recipient, address indexed _caller, uint256 _recipientTokenAmount, uint256 _callerTokenAmount, uint256 _block);\r\n\r\n    /**\r\n     * @dev MerkleMine constructor\r\n     * @param _token ERC20 token being distributed\r\n     * @param _genesisRoot Merkle root representing genesis state which encodes token recipients\r\n     * @param _totalGenesisTokens Total amount of tokens that can be generated\r\n     * @param _totalGenesisRecipients Total number of recipients included in genesis state\r\n     * @param _balanceThreshold Minimum ETH balance threshold for recipients included in genesis state\r\n     * @param _genesisBlock Block number of genesis - used to determine which ETH accounts are included in the genesis state\r\n     * @param _callerAllocationStartBlock Start block where a third party caller (not the recipient) can generate and split the allocation with the recipient\r\n     * @param _callerAllocationEndBlock From this block onwards, a third party caller (not the recipient) can generate and claim the recipient's full allocation\r\n     */\r\n    function MerkleMine(\r\n        address _token,\r\n        bytes32 _genesisRoot,\r\n        uint256 _totalGenesisTokens,\r\n        uint256 _totalGenesisRecipients,\r\n        uint256 _balanceThreshold,\r\n        uint256 _genesisBlock,\r\n        uint256 _callerAllocationStartBlock,\r\n        uint256 _callerAllocationEndBlock\r\n    )\r\n        public\r\n    {\r\n        // Address of token contract must not be null\r\n        require(_token != address(0));\r\n        // Number of recipients must be non-zero\r\n        require(_totalGenesisRecipients > 0);\r\n        // Genesis block must be at or before the current block\r\n        require(_genesisBlock <= block.number);\r\n        // Start block for caller allocation must be after current block\r\n        require(_callerAllocationStartBlock > block.number);\r\n        // End block for caller allocation must be after caller allocation start block\r\n        require(_callerAllocationEndBlock > _callerAllocationStartBlock);\r\n\r\n        token = ERC20(_token);\r\n        genesisRoot = _genesisRoot;\r\n        totalGenesisTokens = _totalGenesisTokens;\r\n        totalGenesisRecipients = _totalGenesisRecipients;\r\n        tokensPerAllocation = _totalGenesisTokens.div(_totalGenesisRecipients);\r\n        balanceThreshold = _balanceThreshold;\r\n        genesisBlock = _genesisBlock;\r\n        callerAllocationStartBlock = _callerAllocationStartBlock;\r\n        callerAllocationEndBlock = _callerAllocationEndBlock;\r\n        callerAllocationPeriod = _callerAllocationEndBlock.sub(_callerAllocationStartBlock);\r\n    }\r\n\r\n    /**\r\n     * @dev Start the generation period - first checks that this contract's balance is equal to `totalGenesisTokens`\r\n     * The generation period must not already be started\r\n     */\r\n    function start() external isNotStarted {\r\n        // Check that this contract has a sufficient balance for the generation period\r\n        require(token.balanceOf(this) >= totalGenesisTokens);\r\n\r\n        started = true;\r\n    }\r\n\r\n    /**\r\n     * @dev Generate a recipient's token allocation. Generation period must be started. Starting from `callerAllocationStartBlock`\r\n     * a third party caller (not the recipient) can invoke this function to generate the recipient's token\r\n     * allocation and claim a percentage of it. The percentage of the allocation claimed by the\r\n     * third party caller is determined by how many blocks have elapsed since `callerAllocationStartBlock`.\r\n     * After `callerAllocationEndBlock`, a third party caller can claim the full allocation\r\n     * @param _recipient Recipient of token allocation\r\n     * @param _merkleProof Proof of recipient's inclusion in genesis state Merkle root\r\n     */\r\n    function generate(address _recipient, bytes _merkleProof) external isStarted notGenerated(_recipient) {\r\n        // Check the Merkle proof\r\n        bytes32 leaf = keccak256(_recipient);\r\n        // _merkleProof must prove inclusion of _recipient in the genesis state root\r\n        require(MerkleProof.verifyProof(_merkleProof, genesisRoot, leaf));\r\n\r\n        generated[_recipient] = true;\r\n\r\n        address caller = msg.sender;\r\n\r\n        if (caller == _recipient) {\r\n            // If the caller is the recipient, transfer the full allocation to the caller/recipient\r\n            require(token.transfer(_recipient, tokensPerAllocation));\r\n\r\n            Generate(_recipient, _recipient, tokensPerAllocation, 0, block.number);\r\n        } else {\r\n            // If the caller is not the recipient, the token allocation generation\r\n            // can only take place if we are in the caller allocation period\r\n            require(block.number >= callerAllocationStartBlock);\r\n\r\n            uint256 callerTokenAmount = callerTokenAmountAtBlock(block.number);\r\n            uint256 recipientTokenAmount = tokensPerAllocation.sub(callerTokenAmount);\r\n\r\n            if (callerTokenAmount > 0) {\r\n                require(token.transfer(caller, callerTokenAmount));\r\n            }\r\n\r\n            if (recipientTokenAmount > 0) {\r\n                require(token.transfer(_recipient, recipientTokenAmount));\r\n            }\r\n\r\n            Generate(_recipient, caller, recipientTokenAmount, callerTokenAmount, block.number);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Return the amount of tokens claimable by a third party caller when generating a recipient's token allocation at a given block\r\n     * @param _blockNumber Block at which to compute the amount of tokens claimable by a third party caller\r\n     */\r\n    function callerTokenAmountAtBlock(uint256 _blockNumber) public view returns (uint256) {\r\n        if (_blockNumber < callerAllocationStartBlock) {\r\n            // If the block is before the start of the caller allocation period, the third party caller can claim nothing\r\n            return 0;\r\n        } else if (_blockNumber >= callerAllocationEndBlock) {\r\n            // If the block is at or after the end block of the caller allocation period, the third party caller can claim everything\r\n            return tokensPerAllocation;\r\n        } else {\r\n            // During the caller allocation period, the third party caller can claim an increasing percentage\r\n            // of the recipient's allocation based on a linear curve - as more blocks pass in the caller allocation\r\n            // period, the amount claimable by the third party caller increases linearly\r\n            uint256 blocksSinceCallerAllocationStartBlock = _blockNumber.sub(callerAllocationStartBlock);\r\n            return tokensPerAllocation.mul(blocksSinceCallerAllocationStartBlock).div(callerAllocationPeriod);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * @title BytesUtil\r\n * @dev Utilities for extracting bytes from byte arrays\r\n * Functions taken from:\r\n * - https://github.com/ethereum/solidity-examples/blob/master/src/unsafe/Memory.sol\r\n * - https://github.com/ethereum/solidity-examples/blob/master/src/bytes/Bytes.sol\r\n */\r\nlibrary BytesUtil{\r\n    uint256 internal constant BYTES_HEADER_SIZE = 32;\r\n    uint256 internal constant WORD_SIZE = 32;\r\n    \r\n    /**\r\n     * @dev Returns a memory pointer to the data portion of the provided bytes array.\r\n     * @param bts Memory byte array\r\n     */\r\n    function dataPtr(bytes memory bts) internal pure returns (uint256 addr) {\r\n        assembly {\r\n            addr := add(bts, /*BYTES_HEADER_SIZE*/ 32)\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev Copy 'len' bytes from memory address 'src', to address 'dest'.\r\n     * This function does not check the or destination, it only copies\r\n     * the bytes.\r\n     * @param src Memory address of source byte array\r\n     * @param dest Memory address of destination byte array\r\n     * @param len Number of bytes to copy from `src` to `dest`\r\n     */\r\n    function copy(uint256 src, uint256 dest, uint256 len) internal pure {\r\n        // Copy word-length chunks while possible\r\n        for (; len >= WORD_SIZE; len -= WORD_SIZE) {\r\n            assembly {\r\n                mstore(dest, mload(src))\r\n            }\r\n            dest += WORD_SIZE;\r\n            src += WORD_SIZE;\r\n        }\r\n\r\n        // Copy remaining bytes\r\n        uint256 mask = 256 ** (WORD_SIZE - len) - 1;\r\n        assembly {\r\n            let srcpart := and(mload(src), not(mask))\r\n            let destpart := and(mload(dest), mask)\r\n            mstore(dest, or(destpart, srcpart))\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Creates a 'bytes memory' variable from the memory address 'addr', with the\r\n     * length 'len'. The function will allocate new memory for the bytes array, and\r\n     * the 'len bytes starting at 'addr' will be copied into that new memory.\r\n     * @param addr Memory address of input byte array\r\n     * @param len Number of bytes to copy from input byte array\r\n     */\r\n    function toBytes(uint256 addr, uint256 len) internal pure returns (bytes memory bts) {\r\n        bts = new bytes(len);\r\n        uint256 btsptr = dataPtr(bts);\r\n        copy(addr, btsptr, len);\r\n    }\r\n    \r\n    /**\r\n     * @dev Copies 'len' bytes from 'bts' into a new array, starting at the provided 'startIndex'.\r\n     * Returns the new copy.\r\n     * Requires that:\r\n     *  - 'startIndex + len <= self.length'\r\n     * The length of the substring is: 'len'\r\n     * @param bts Memory byte array to copy from\r\n     * @param startIndex Index of `bts` to start copying bytes from\r\n     * @param len Number of bytes to copy from `bts`\r\n     */\r\n    function substr(bytes memory bts, uint256 startIndex, uint256 len) internal pure returns (bytes memory) {\r\n        require(startIndex + len <= bts.length);\r\n        if (len == 0) {\r\n            return;\r\n        }\r\n        uint256 addr = dataPtr(bts);\r\n        return toBytes(addr + startIndex, len);\r\n    }\r\n\r\n    /**\r\n     * @dev Reads a bytes32 value from a byte array by copying 32 bytes from `bts` starting at the provided `startIndex`.\r\n     * @param bts Memory byte array to copy from\r\n     * @param startIndex Index of `bts` to start copying bytes from\r\n     */\r\n    function readBytes32(bytes memory bts, uint256 startIndex) internal pure returns (bytes32 result) {\r\n        require(startIndex + 32 <= bts.length);\r\n\r\n        uint256 addr = dataPtr(bts);\r\n\r\n        assembly {\r\n            result := mload(add(addr, startIndex))\r\n        }\r\n\r\n        return result;\r\n    }\r\n}\r\n\r\n/**\r\n * @title MultiMerkleMine\r\n * @dev The MultiMerkleMine contract is purely a convenience wrapper around an existing MerkleMine contract deployed on the blockchain.\r\n */\r\ncontract MultiMerkleMine {\r\n\tusing SafeMath for uint256;\r\n\r\n\t/**\r\n     * @dev Generates token allocations for multiple recipients. Generation period must be started.\r\n     * @param _merkleMineContract Address of the deployed MerkleMine contract\r\n     * @param _recipients Array of recipients\r\n     * @param _merkleProofs Proofs for respective recipients constructed in the format: \r\n     *       [proof_1_size, proof_1, proof_2_size, proof_2, ... , proof_n_size, proof_n]\r\n     */\r\n\tfunction multiGenerate(address _merkleMineContract, address[] _recipients, bytes _merkleProofs) public {\r\n\t\tMerkleMine mine = MerkleMine(_merkleMineContract);\r\n\t\tERC20 token = ERC20(mine.token());\r\n\r\n\t\trequire(\r\n\t\t\tblock.number >= mine.callerAllocationStartBlock(),\r\n\t\t\t\"caller allocation period has not started\"\r\n\t\t);\r\n\t\t\r\n\t\tuint256 initialBalance = token.balanceOf(this);\r\n\t\tbytes[] memory proofs = new bytes[](_recipients.length);\r\n\r\n\t\t// Counter to keep track of position in `_merkleProofs` byte array\r\n\t\tuint256 i = 0;\r\n\t\t// Counter to keep track of index of each extracted Merkle proof\r\n\t\tuint256 j = 0;\r\n\r\n\t\t// Extract proofs\r\n\t\twhile(i < _merkleProofs.length){\r\n\t\t\tuint256 proofSize = uint256(BytesUtil.readBytes32(_merkleProofs, i));\r\n\r\n\t\t\trequire(\r\n\t\t\t\tproofSize % 32 == 0,\r\n\t\t\t\t\"proof size must be a multiple of 32\"\r\n\t\t\t);\r\n\r\n\t\t\tproofs[j] = BytesUtil.substr(_merkleProofs, i + 32, proofSize);\r\n\r\n\t\t\ti = i + 32 + proofSize;\r\n\t\t\tj++;\r\n\t\t}\r\n\r\n\t\trequire(\r\n\t\t\t_recipients.length == j,\r\n\t\t\t\"number of recipients != number of proofs\"\r\n\t\t);\r\n\r\n\t\tfor (uint256 k = 0; k < _recipients.length; k++) {\r\n\t\t\t// If recipient's token allocation has not been generated, generate the token allocation\r\n\t\t\t// Else, continue to the next recipient\r\n\t\t\tif (!mine.generated(_recipients[k])) {\r\n\t\t\t\tmine.generate(_recipients[k], proofs[k]);\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tuint256 newBalanceSinceAllocation = token.balanceOf(this);\r\n\t\tuint256 callerTokensGenerated = newBalanceSinceAllocation.sub(initialBalance);\r\n\r\n\t\t// Transfer caller's portion of tokens generated by this function call \r\n\t\tif (callerTokensGenerated > 0) {\r\n\t\t\trequire(token.transfer(msg.sender, callerTokensGenerated));\r\n\t\t}\r\n\t}\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_merkleMineContract\",\"type\":\"address\"},{\"name\":\"_recipients\",\"type\":\"address[]\"},{\"name\":\"_merkleProofs\",\"type\":\"bytes\"}],\"name\":\"multiGenerate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"}]","ContractName":"MultiMerkleMine","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3d8784cc2ee440d8fd9a5735fce92aa140c837350e6c2b6d292a0bc860aa404a"}]}