{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.21;\r\npragma experimental \"v0.5.0\";\r\n\r\ncontract Owned {\r\n    address public owner;\r\n    address public newOwner;\r\n\r\n    function Owned() public {\r\n        owner = msg.sender;\r\n    }\r\n\r\n    modifier onlyOwner {\r\n        assert(msg.sender == owner);\r\n        _;\r\n    }\r\n\r\n    function transferOwnership(address _newOwner) public onlyOwner {\r\n        require(_newOwner != owner);\r\n        newOwner = _newOwner;\r\n    }\r\n\r\n    function acceptOwnership() public {\r\n        require(msg.sender == newOwner);\r\n        emit OwnerUpdate(owner, newOwner);\r\n        owner = newOwner;\r\n        newOwner = 0x0;\r\n    }\r\n\r\n    event OwnerUpdate(address _prevOwner, address _newOwner);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.*/\r\n    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        assert(c / a == b);\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Integer division of two numbers, truncating the quotient.\r\n    */\r\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n        // uint256 c = a / b;\r\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n        return a / b;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n        assert(b <= a);\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n        c = a + b;\r\n        assert(c >= a);\r\n        return c;\r\n    }\r\n}\r\n\r\ninterface ERC20TokenInterface {\r\n    function transfer(address _to, uint256 _value) external returns (bool success);\r\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success);\r\n    function approve(address _spender, uint256 _value) external returns (bool success);\r\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining);\r\n    function totalSupply() external view returns (uint256 _totalSupply);\r\n    function balanceOf(address _owner) external view returns (uint256 balance);\r\n\r\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\r\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\r\n}\r\n\r\ninterface TokenVestingInterface {\r\n    function getReleasableFunds() external view returns (uint256);\r\n\r\n    function release() external;\r\n\r\n    function setWithdrawalAddress(address _newAddress) external;\r\n\r\n    function revoke(string _reason) external view;\r\n\r\n    function getTokenBalance() external view returns (uint256);\r\n\r\n    function updateBalanceOnFunding(uint256 _amount) external;\r\n\r\n    function salvageOtherTokensFromContract(address _tokenAddress, address _to, uint _amount) external;\r\n\r\n    function salvageNotAllowedTokensSentToContract(address _to, uint _amount) external;\r\n}\r\n\r\ninterface VestingMasterInterface {\r\n    function amountLockedInVestings() view external returns (uint256);\r\n\r\n    function substractLockedAmount(uint256 _amount) external;\r\n\r\n    function addLockedAmount(uint256 _amount) external;\r\n\r\n    function addInternalBalance(uint256 _amount) external;\r\n}\r\n\r\ninterface ReleasingScheduleInterface {\r\n    function getReleasableFunds(address _vesting) external view returns (uint256);\r\n}\r\n\r\n/** @title Linear releasing schedule contract */\r\ncontract ReleasingScheduleLinearContract {\r\n    /** @dev Contains functionality for releasing funds linearly; set amount on set intervals until funds are available\r\n    * @param _startTime Start time of schedule (not first releas time)\r\n    * @param _tickDuration Interval of payouts\r\n    * @param _amountPerTick Amount to be released per interval\r\n    * @return created contracts address.\r\n    */\r\n    using SafeMath for uint256;\r\n    uint256 public startTime;\r\n    uint256 public tickDuration;\r\n    uint256 public amountPerTick;\r\n\r\n    function ReleasingScheduleLinearContract(uint256 _startTime, uint256 _tickDuration, uint256 _amountPerTick) public{\r\n        startTime = _startTime;\r\n        tickDuration = _tickDuration;\r\n        amountPerTick = _amountPerTick;\r\n    }\r\n\r\n    function getReleasableFunds(address _vesting) public view returns (uint256){\r\n        TokenVestingContract vesting = TokenVestingContract(_vesting);\r\n        uint256 balance = ERC20TokenInterface(vesting.tokenAddress()).balanceOf(_vesting);\r\n        // check if there is balance and if it is active yet\r\n        if (balance == 0 || (startTime >= now)) {\r\n            return 0;\r\n        }\r\n        // all funds that may be released according to vesting schedule \r\n        uint256 vestingScheduleAmount = (now.sub(startTime) / tickDuration) * amountPerTick;\r\n        // deduct already released funds \r\n        uint256 releasableFunds = vestingScheduleAmount.sub(vesting.alreadyReleasedAmount());\r\n        // make sure to release remainder of funds for last payout\r\n        if (releasableFunds > balance) {\r\n            releasableFunds = balance;\r\n        }\r\n        return releasableFunds;\r\n    }\r\n}\r\n\r\ncontract TgeOtherReleasingScheduleContract is ReleasingScheduleLinearContract {\r\n    uint256 constant releaseDate = 1578873600;\r\n    uint256 constant monthLength = 2592000;\r\n\r\n    function TgeOtherReleasingScheduleContract(uint256 _amount, uint256 _startTime) ReleasingScheduleLinearContract(_startTime - monthLength, monthLength, _amount / 12) public {\r\n    }\r\n\r\n    function getReleasableFunds(address _vesting) public view returns (uint256) {\r\n        if (now < releaseDate) {\r\n            return 0;\r\n        }\r\n        return super.getReleasableFunds(_vesting);\r\n    }\r\n}\r\n\r\ncontract TgeTeamReleasingScheduleContract {\r\n    uint256 constant releaseDate = 1578873600;\r\n\r\n    function TgeTeamReleasingScheduleContract() public {}\r\n\r\n    function getReleasableFunds(address _vesting) public view returns (uint256) {\r\n        TokenVestingContract vesting = TokenVestingContract(_vesting);\r\n        if (releaseDate >= now) {\r\n            return 0;\r\n        } else {\r\n            return vesting.getTokenBalance();\r\n        }\r\n\r\n    }\r\n}\r\n\r\n/** @title Vesting contract*/\r\ncontract TokenVestingContract is Owned {\r\n    /** @dev Contains basic vesting functionality. Uses releasing schedule to ascertain amount of funds to release\r\n    * @param _beneficiary Receiver of funds.\r\n    * @param _tokenAddress Address of token contract.\r\n    * @param _revocable Allows owner to terminate vesting, but all funds yet vested still go to beneficiary. Owner gets remainder of funds back.\r\n    * @param _changable Allows that releasing schedule and withdrawal address be changed. Essentialy rendering contract not binding.\r\n    * @param _releasingScheduleContract Address of scheduling contract, that implements getReleasableFunds() function\r\n    * @return created vesting's address.\r\n    */\r\n    using SafeMath for uint256;\r\n\r\n    address public beneficiary;\r\n    address public tokenAddress;\r\n    bool public canReceiveTokens;\r\n    bool public revocable;  // \r\n    bool public changable;  // allows that releasing schedule and withdrawal address be changed. Essentialy rendering contract not binding.\r\n    address public releasingScheduleContract;\r\n    bool fallbackTriggered;\r\n\r\n    bool public revoked;\r\n    uint256 public alreadyReleasedAmount;\r\n    uint256 public internalBalance;\r\n\r\n    event Released(uint256 _amount);\r\n    event RevokedAndDestroyed(string _reason);\r\n    event WithdrawalAddressSet(address _newAddress);\r\n    event TokensReceivedSinceLastCheck(uint256 _amount);\r\n    event VestingReceivedFunding(uint256 _amount);\r\n    event SetReleasingSchedule(address _addy);\r\n    event NotAllowedTokensReceived(uint256 amount);\r\n\r\n    function TokenVestingContract(address _beneficiary, address _tokenAddress, bool _canReceiveTokens, bool _revocable, bool _changable, address _releasingScheduleContract) public {\r\n        beneficiary = _beneficiary;\r\n        tokenAddress = _tokenAddress;\r\n        canReceiveTokens = _canReceiveTokens;\r\n        revocable = _revocable;\r\n        changable = _changable;\r\n        releasingScheduleContract = _releasingScheduleContract;\r\n\r\n        alreadyReleasedAmount = 0;\r\n        revoked = false;\r\n        internalBalance = 0;\r\n        fallbackTriggered = false;\r\n    }\r\n\r\n    function setReleasingSchedule(address _releasingScheduleContract) external onlyOwner {\r\n        require(changable);\r\n        releasingScheduleContract = _releasingScheduleContract;\r\n\r\n        emit SetReleasingSchedule(releasingScheduleContract);\r\n    }\r\n\r\n    function setWithdrawalAddress(address _newAddress) external onlyOwner {\r\n        beneficiary = _newAddress;\r\n\r\n        emit WithdrawalAddressSet(_newAddress);\r\n    }\r\n    /// release tokens that are already vested/releasable\r\n    function release() external returns (uint256 transferedAmount) {\r\n        checkForReceivedTokens();\r\n        require(msg.sender == beneficiary || msg.sender == owner);\r\n        uint256 amountToTransfer = ReleasingScheduleInterface(releasingScheduleContract).getReleasableFunds(this);\r\n        require(amountToTransfer > 0);\r\n        // internal accounting\r\n        alreadyReleasedAmount = alreadyReleasedAmount.add(amountToTransfer);\r\n        internalBalance = internalBalance.sub(amountToTransfer);\r\n        VestingMasterInterface(owner).substractLockedAmount(amountToTransfer);\r\n        // actual transfer\r\n        ERC20TokenInterface(tokenAddress).transfer(beneficiary, amountToTransfer);\r\n        emit Released(amountToTransfer);\r\n        return amountToTransfer;\r\n    }\r\n\r\n    function revoke(string _reason) external onlyOwner {\r\n        require(revocable);\r\n        // returns funds not yet vested according to vesting schedule\r\n        uint256 releasableFunds = ReleasingScheduleInterface(releasingScheduleContract).getReleasableFunds(this);\r\n        ERC20TokenInterface(tokenAddress).transfer(beneficiary, releasableFunds);\r\n        VestingMasterInterface(owner).substractLockedAmount(releasableFunds);\r\n        // have to do it here, can't use return, because contract selfdestructs\r\n        // returns remainder of funds to VestingMaster and kill vesting contract\r\n        VestingMasterInterface(owner).addInternalBalance(getTokenBalance());\r\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\r\n        emit RevokedAndDestroyed(_reason);\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function getTokenBalance() public view returns (uint256 tokenBalance) {\r\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\r\n    }\r\n    // master calls this when it uploads funds in order to differentiate betwen funds from master and 3rd party\r\n    function updateBalanceOnFunding(uint256 _amount) external onlyOwner {\r\n        internalBalance = internalBalance.add(_amount);\r\n        emit VestingReceivedFunding(_amount);\r\n    }\r\n    // check for changes in balance in order to track amount of locked tokens and notify master\r\n    function checkForReceivedTokens() public {\r\n        if (getTokenBalance() != internalBalance) {\r\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\r\n            // if not allowed to receive tokens, do not account for them\r\n            if (canReceiveTokens) {\r\n                internalBalance = getTokenBalance();\r\n                VestingMasterInterface(owner).addLockedAmount(receivedFunds);\r\n            } else {\r\n                emit NotAllowedTokensReceived(receivedFunds);\r\n            }\r\n            emit TokensReceivedSinceLastCheck(receivedFunds);\r\n        }\r\n        fallbackTriggered = true;\r\n    }\r\n\r\n    function salvageOtherTokensFromContract(address _tokenAddress, address _to, uint _amount) external onlyOwner {\r\n        require(_tokenAddress != tokenAddress);\r\n        ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n    }\r\n\r\n    function salvageNotAllowedTokensSentToContract(address _to, uint _amount) external onlyOwner {\r\n        // check if there are any new tokens\r\n        checkForReceivedTokens();\r\n        // only allow sending tokens, that were not allowed to be sent to contract\r\n        require(_amount <= getTokenBalance() - internalBalance);\r\n        ERC20TokenInterface(tokenAddress).transfer(_to, _amount);\r\n    }\r\n    function () external{\r\n        fallbackTriggered = true;\r\n    }\r\n}\r\n\r\ncontract VestingMasterContract is Owned {\r\n    using SafeMath for uint256;\r\n\r\n    address public tokenAddress;\r\n    bool public canReceiveTokens;\r\n    address public moderator;\r\n    uint256 public internalBalance;\r\n    uint256 public amountLockedInVestings;\r\n    bool public fallbackTriggered;\r\n\r\n    struct VestingStruct {\r\n        uint256 arrayPointer;\r\n        // custom data\r\n        address beneficiary;\r\n        address releasingScheduleContract;\r\n        string vestingType;\r\n        uint256 vestingVersion;\r\n    }\r\n\r\n    address[] public vestingAddresses;\r\n    mapping(address => VestingStruct) public addressToVestingStruct;\r\n    mapping(address => address) public beneficiaryToVesting;\r\n\r\n    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\r\n    event LockedAmountDecreased(uint256 amount);\r\n    event LockedAmountIncreased(uint256 amount);\r\n    event TokensReceivedSinceLastCheck(uint256 amount);\r\n    event TokensReceivedWithApproval(uint256 amount, bytes extraData);\r\n    event NotAllowedTokensReceived(uint256 amount);\r\n\r\n    function VestingMasterContract(address _tokenAddress, bool _canReceiveTokens) public{\r\n        tokenAddress = _tokenAddress;\r\n        canReceiveTokens = _canReceiveTokens;\r\n        internalBalance = 0;\r\n        amountLockedInVestings = 0;\r\n    }\r\n    // todo: make storage lib\r\n    ////////// STORAGE HELPERS  ///////////\r\n    function vestingExists(address _vestingAddress) public view returns (bool exists){\r\n        if (vestingAddresses.length == 0) {return false;}\r\n        return (vestingAddresses[addressToVestingStruct[_vestingAddress].arrayPointer] == _vestingAddress);\r\n    }\r\n\r\n    function storeNewVesting(address _vestingAddress, address _beneficiary, address _releasingScheduleContract, string _vestingType, uint256 _vestingVersion) internal onlyOwner returns (uint256 vestingsLength) {\r\n        require(!vestingExists(_vestingAddress));\r\n        addressToVestingStruct[_vestingAddress].beneficiary = _beneficiary;\r\n        addressToVestingStruct[_vestingAddress].releasingScheduleContract = _releasingScheduleContract;\r\n        addressToVestingStruct[_vestingAddress].vestingType = _vestingType;\r\n        addressToVestingStruct[_vestingAddress].vestingVersion = _vestingVersion;\r\n        beneficiaryToVesting[_beneficiary] = _vestingAddress;\r\n        addressToVestingStruct[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\r\n        return vestingAddresses.length;\r\n    }\r\n\r\n    function deleteVestingFromStorage(address _vestingAddress) internal onlyOwner returns (uint256 vestingsLength) {\r\n        require(vestingExists(_vestingAddress));\r\n        delete (beneficiaryToVesting[addressToVestingStruct[_vestingAddress].beneficiary]);\r\n        uint256 indexToDelete = addressToVestingStruct[_vestingAddress].arrayPointer;\r\n        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\r\n        vestingAddresses[indexToDelete] = keyToMove;\r\n        addressToVestingStruct[keyToMove].arrayPointer = indexToDelete;\r\n        vestingAddresses.length--;\r\n        return vestingAddresses.length;\r\n    }\r\n\r\n    function addVesting(address _vestingAddress, address _beneficiary, address _releasingScheduleContract, string _vestingType, uint256 _vestingVersion) public {\r\n        uint256 vestingBalance = TokenVestingInterface(_vestingAddress).getTokenBalance();\r\n        amountLockedInVestings = amountLockedInVestings.add(vestingBalance);\r\n        storeNewVesting(_vestingAddress, _beneficiary, _releasingScheduleContract, _vestingType, _vestingVersion);\r\n    }\r\n\r\n    /// releases funds to beneficiary\r\n    function releaseVesting(address _vestingContract) external {\r\n        require(vestingExists(_vestingContract));\r\n        require(msg.sender == addressToVestingStruct[_vestingContract].beneficiary || msg.sender == owner || msg.sender == moderator);\r\n        TokenVestingInterface(_vestingContract).release();\r\n    }\r\n    /// Transfers releasable funds from vesting to beneficiary (caller of this method)\r\n    function releaseMyTokens() external {\r\n        address vesting = beneficiaryToVesting[msg.sender];\r\n        require(vesting != 0);\r\n        TokenVestingInterface(vesting).release();\r\n    }\r\n\r\n    // add funds to vesting contract\r\n    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\r\n        // convenience, so you don't have to call it manualy if you just uploaded funds\r\n        checkForReceivedTokens();\r\n        // check if there is actually enough funds\r\n        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\r\n        // make sure that fundee is vesting contract on the list\r\n        require(vestingExists(_vestingContract));\r\n        internalBalance = internalBalance.sub(_amount);\r\n        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\r\n        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\r\n        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\r\n    }\r\n\r\n    function getTokenBalance() public constant returns (uint256) {\r\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\r\n    }\r\n    // revoke vesting; release releasable funds to beneficiary and return remaining to master and kill vesting contract\r\n    function revokeVesting(address _vestingContract, string _reason) external onlyOwner {\r\n        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\r\n        subVestingContract.revoke(_reason);\r\n        deleteVestingFromStorage(_vestingContract);\r\n    }\r\n    // when vesting is revoked it sends back remaining tokens and updates internalBalance\r\n    function addInternalBalance(uint256 _amount) external {\r\n        require(vestingExists(msg.sender));\r\n        internalBalance = internalBalance.add(_amount);\r\n    }\r\n    // vestings notifies if there has been any changes in amount of locked tokens\r\n    function addLockedAmount(uint256 _amount) external {\r\n        require(vestingExists(msg.sender));\r\n        amountLockedInVestings = amountLockedInVestings.add(_amount);\r\n        emit LockedAmountIncreased(_amount);\r\n    }\r\n    // vestings notifies if there has been any changes in amount of locked tokens\r\n    function substractLockedAmount(uint256 _amount) external {\r\n        require(vestingExists(msg.sender));\r\n        amountLockedInVestings = amountLockedInVestings.sub(_amount);\r\n        emit LockedAmountDecreased(_amount);\r\n    }\r\n    // check for changes in balance in order to track amount of locked tokens\r\n    function checkForReceivedTokens() public {\r\n        if (getTokenBalance() != internalBalance) {\r\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\r\n            if (canReceiveTokens) {\r\n                amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\r\n                internalBalance = getTokenBalance();\r\n            }\r\n            else {\r\n                emit NotAllowedTokensReceived(receivedFunds);\r\n            }\r\n            emit TokensReceivedSinceLastCheck(receivedFunds);\r\n        } else {\r\n            emit TokensReceivedSinceLastCheck(0);\r\n        }\r\n        fallbackTriggered = false;\r\n    }\r\n\r\n    function salvageNotAllowedTokensSentToContract(address _contractFrom, address _to, uint _amount) external onlyOwner {\r\n        if (_contractFrom == address(this)) {\r\n            // check if there are any new tokens\r\n            checkForReceivedTokens();\r\n            // only allow sending tokens, that were not allowed to be sent to contract\r\n            require(_amount <= getTokenBalance() - internalBalance);\r\n            ERC20TokenInterface(tokenAddress).transfer(_to, _amount);\r\n        }\r\n        if (vestingExists(_contractFrom)) {\r\n            TokenVestingInterface(_contractFrom).salvageNotAllowedTokensSentToContract(_to, _amount);\r\n        }\r\n    }\r\n\r\n    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) external onlyOwner {\r\n        require(_tokenAddress != tokenAddress);\r\n        if (_contractAddress == address(this)) {\r\n            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\r\n        }\r\n        if (vestingExists(_contractAddress)) {\r\n            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\r\n        }\r\n    }\r\n\r\n    function killContract() external onlyOwner {\r\n        require(vestingAddresses.length == 0);\r\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\r\n        selfdestruct(owner);\r\n    }\r\n\r\n    function setWithdrawalAddress(address _vestingContract, address _beneficiary) external {\r\n        require(vestingExists(_vestingContract));\r\n        TokenVestingContract vesting = TokenVestingContract(_vestingContract);\r\n        // withdrawal address can be changed only by beneficiary or in case vesting is changable also by owner\r\n        require(msg.sender == vesting.beneficiary() || (msg.sender == owner && vesting.changable()));\r\n        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\r\n        addressToVestingStruct[_vestingContract].beneficiary = _beneficiary;\r\n    }\r\n\r\n    function receiveApproval(address _from, uint256 _amount, address _tokenAddress, bytes _extraData) external {\r\n        require(canReceiveTokens);\r\n        require(_tokenAddress == tokenAddress);\r\n        ERC20TokenInterface(_tokenAddress).transferFrom(_from, address(this), _amount);\r\n        amountLockedInVestings = amountLockedInVestings.add(_amount);\r\n        internalBalance = internalBalance.add(_amount);\r\n        emit TokensReceivedWithApproval(_amount, _extraData);\r\n    }\r\n\r\n    // Deploys a vesting contract to _beneficiary. Assumes that a releasing\r\n    // schedule contract has already been deployed, so we pass it the address\r\n    // of that contract as _releasingSchedule\r\n    function deployVesting(\r\n        address _beneficiary,\r\n        string _vestingType,\r\n        uint256 _vestingVersion,\r\n        bool _canReceiveTokens,\r\n        bool _revocable,\r\n        bool _changable,\r\n        address _releasingSchedule\r\n    ) public onlyOwner {\r\n        TokenVestingContract newVesting = new TokenVestingContract(_beneficiary, tokenAddress, _canReceiveTokens, _revocable, _changable, _releasingSchedule);\r\n        addVesting(newVesting, _beneficiary, _releasingSchedule, _vestingType, _vestingVersion);\r\n    }\r\n\r\n    function deployOtherVesting(\r\n        address _beneficiary,\r\n        uint256 _amount,\r\n        uint256 _startTime\r\n    ) public onlyOwner {\r\n        TgeOtherReleasingScheduleContract releasingSchedule = new TgeOtherReleasingScheduleContract(_amount, _startTime);\r\n        TokenVestingContract newVesting = new TokenVestingContract(_beneficiary, tokenAddress, true, true, true, releasingSchedule);\r\n        addVesting(newVesting, _beneficiary, releasingSchedule, 'other', 1);\r\n        fundVesting(newVesting, _amount);\r\n    }\r\n\r\n    function deployTgeTeamVesting(\r\n    address _beneficiary,\r\n    uint256 _amount\r\n    ) public onlyOwner {\r\n        TgeTeamReleasingScheduleContract releasingSchedule = new TgeTeamReleasingScheduleContract();\r\n        TokenVestingContract newVesting = new TokenVestingContract(_beneficiary, tokenAddress, true, true, true, releasingSchedule);\r\n        addVesting(newVesting, _beneficiary, releasingSchedule, 'X8 team', 1);\r\n        fundVesting(newVesting, _amount);\r\n    }\r\n\r\n\r\n    /**\r\n    * Used to transfer ownership of a vesting contract to this master contract.\r\n    * The vesting contracts require that the master contract be their owner.\r\n    * Use this when you deploy a TokenVestingContract manually and need to transfer\r\n    * ownership to this master contract. First call transferOwnership on the vesting\r\n    * contract.\r\n    * @param _vesting the vesting contract of which to accept ownership.\r\n    */\r\n    function acceptOwnershipOfVesting(address _vesting) external onlyOwner {\r\n        TokenVestingContract(_vesting).acceptOwnership();\r\n    }\r\n\r\n    function setModerator(address _moderator) external onlyOwner {\r\n        moderator = _moderator;\r\n    }\r\n\r\n    function () external{\r\n        fallbackTriggered = true;\r\n    }\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_vestingContract\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"}],\"name\":\"setWithdrawalAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"vestingAddresses\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_contractAddress\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageOtherTokensFromContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_startTime\",\"type\":\"uint256\"}],\"name\":\"deployOtherVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"amountLockedInVestings\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"killContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"beneficiaryToVesting\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"canReceiveTokens\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_contractFrom\",\"type\":\"address\"},{\"name\":\"_to\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"salvageNotAllowedTokensSentToContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"internalBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"deployTgeTeamVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"moderator\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addLockedAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"releaseMyTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingContract\",\"type\":\"address\"},{\"name\":\"_reason\",\"type\":\"string\"}],\"name\":\"revokeVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingContract\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"fundVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_vestingAddress\",\"type\":\"address\"}],\"name\":\"vestingExists\",\"outputs\":[{\"name\":\"exists\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_moderator\",\"type\":\"address\"}],\"name\":\"setModerator\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"acceptOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getTokenBalance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"substractLockedAmount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_from\",\"type\":\"address\"},{\"name\":\"_amount\",\"type\":\"uint256\"},{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_extraData\",\"type\":\"bytes\"}],\"name\":\"receiveApproval\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"tokenAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vesting\",\"type\":\"address\"}],\"name\":\"acceptOwnershipOfVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"addInternalBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"fallbackTriggered\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingContract\",\"type\":\"address\"}],\"name\":\"releaseVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"newOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_vestingAddress\",\"type\":\"address\"},{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_releasingScheduleContract\",\"type\":\"address\"},{\"name\":\"_vestingType\",\"type\":\"string\"},{\"name\":\"_vestingVersion\",\"type\":\"uint256\"}],\"name\":\"addVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"addressToVestingStruct\",\"outputs\":[{\"name\":\"arrayPointer\",\"type\":\"uint256\"},{\"name\":\"beneficiary\",\"type\":\"address\"},{\"name\":\"releasingScheduleContract\",\"type\":\"address\"},{\"name\":\"vestingType\",\"type\":\"string\"},{\"name\":\"vestingVersion\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"checkForReceivedTokens\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_beneficiary\",\"type\":\"address\"},{\"name\":\"_vestingType\",\"type\":\"string\"},{\"name\":\"_vestingVersion\",\"type\":\"uint256\"},{\"name\":\"_canReceiveTokens\",\"type\":\"bool\"},{\"name\":\"_revocable\",\"type\":\"bool\"},{\"name\":\"_changable\",\"type\":\"bool\"},{\"name\":\"_releasingSchedule\",\"type\":\"address\"}],\"name\":\"deployVesting\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_tokenAddress\",\"type\":\"address\"},{\"name\":\"_canReceiveTokens\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"beneficiary\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"tokenAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"VestingContractFunded\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedAmountDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"LockedAmountIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TokensReceivedSinceLastCheck\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"extraData\",\"type\":\"bytes\"}],\"name\":\"TokensReceivedWithApproval\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"NotAllowedTokensReceived\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_prevOwner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"OwnerUpdate\",\"type\":\"event\"}]","ContractName":"VestingMasterContract","CompilerVersion":"v0.4.21+commit.dfe3193c","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"000000000000000000000000910dfc18d6ea3d6a7124a6f8b5458f281060fa4c0000000000000000000000000000000000000000000000000000000000000001","Library":"","SwarmSource":"bzzr://0d8527a8c12f2cc354e036a53f390267f50b07d5ff33680a78ffb14286cdde5a"}]}