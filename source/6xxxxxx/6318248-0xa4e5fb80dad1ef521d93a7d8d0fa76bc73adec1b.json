{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\n\r\ncontract FoMoInsurance {\r\n    using SafeMath for *;\r\n    using NameFilter for string;\r\n    using F3DKeysCalcLong for uint256;\r\n\r\n\r\n    //*********\r\n    // STRUCTS\r\n    //*********\r\n    struct Player {\r\n        uint256 id;     // player id\r\n        bytes32 name;   // player name\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        bool isAgent;   // referral activated\r\n        uint256 eth;    // eth player has added to round\r\n        uint256 keys;   // keys\r\n        uint256 units;  // uints of insurance\r\n        uint256 plyrLastSeen; // last day player played\r\n        uint256 mask;   // player mask\r\n        uint256 level;\r\n        uint256 accumulatedAff;\r\n    }\r\n\r\n\r\n    //***************\r\n    // EXTERNAL DATA\r\n    //***************\r\n    FoMo3Dlong constant private FoMoLong = FoMo3Dlong(0xA62142888ABa8370742bE823c1782D17A0389Da1);\r\n    DiviesInterface constant private Divies = DiviesInterface(0x93B2dbDd3F242EED7D7c7180c5A4Eddc4BaAE3E7);\r\n    address constant private community = address(0xe853A139b87dD816f052A60Ef646Fd89f7964545);\r\n    uint256 public end;\r\n    bool public ended;\r\n\r\n\r\n    //******************\r\n    // GLOBAL VARIABLES\r\n    //******************\r\n    mapping(address => mapping(uint256 => uint256)) public unitToExpirePlayer;\r\n    mapping(uint256 => uint256) public unitToExpire; // unit of insurance due at day x\r\n\r\n    uint256 public issuedInsurance; // all issued insurance\r\n    uint256 public ethOfKey;        // virtual eth of bought keys\r\n    uint256 public keys;            // totalSupply of key\r\n    uint256 public pot;             // eth gonna pay to beneficiary\r\n    uint256 public today;           // today's date\r\n    uint256 public _now;            // current time\r\n    uint256 public mask;            // global mask\r\n    uint256 public agents;          // number of agent\r\n\r\n    // player data\r\n    mapping(address => Player) public player; // player data\r\n    mapping(uint256 => address) public agentxID_; // return agent address by id\r\n    mapping(bytes32 => address) public agentxName_; // return agent address by name\r\n\r\n    // constant parameters\r\n    uint256 constant maxInsurePeriod = 100;\r\n    uint256 constant thisRoundIndex = 2;\r\n    uint256 constant maxLevel = 10;\r\n\r\n    // rate of buying x day insurance\r\n    uint256[101] public rate =\r\n    [0,\r\n    1000000000000000000,\r\n    1990000000000000000,\r\n    2970100000000000000,\r\n    3940399000000000000,\r\n    4900995010000000000,\r\n    5851985059900000000,\r\n    6793465209301000000,\r\n    7725530557207990000,\r\n    8648275251635910100,\r\n    9561792499119550999,\r\n    10466174574128355489,\r\n    11361512828387071934,\r\n    12247897700103201215,\r\n    13125418723102169203,\r\n    13994164535871147511,\r\n    14854222890512436036,\r\n    15705680661607311676,\r\n    16548623854991238559,\r\n    17383137616441326173,\r\n    18209306240276912911,\r\n    19027213177874143782,\r\n    19836941046095402344,\r\n    20638571635634448321,\r\n    21432185919278103838,\r\n    22217864060085322800,\r\n    22995685419484469572,\r\n    23765728565289624876,\r\n    24528071279636728627,\r\n    25282790566840361341,\r\n    26029962661171957728,\r\n    26769663034560238151,\r\n    27501966404214635769,\r\n    28226946740172489411,\r\n    28944677272770764517,\r\n    29655230500043056872,\r\n    30358678195042626303,\r\n    31055091413092200040,\r\n    31744540498961278040,\r\n    32427095093971665260,\r\n    33102824143031948607,\r\n    33771795901601629121,\r\n    34434077942585612830,\r\n    35089737163159756702,\r\n    35738839791528159135,\r\n    36381451393612877544,\r\n    37017636879676748769,\r\n    37647460510879981281,\r\n    38270985905771181468,\r\n    38888276046713469653,\r\n    39499393286246334956,\r\n    40104399353383871606,\r\n    40703355359850032890,\r\n    41296321806251532561,\r\n    41883358588189017235,\r\n    42464525002307127063,\r\n    43039879752284055792,\r\n    43609480954761215234,\r\n    44173386145213603082,\r\n    44731652283761467051,\r\n    45284335760923852380,\r\n    45831492403314613856,\r\n    46373177479281467717,\r\n    46909445704488653040,\r\n    47440351247443766510,\r\n    47965947734969328845,\r\n    48486288257619635557,\r\n    49001425375043439201,\r\n    49511411121293004809,\r\n    50016297010080074761,\r\n    50516134039979274013,\r\n    51010972699579481273,\r\n    51500862972583686460,\r\n    51985854342857849595,\r\n    52465995799429271099,\r\n    52941335841434978388,\r\n    53411922483020628604,\r\n    53877803258190422318,\r\n    54339025225608518095,\r\n    54795634973352432914,\r\n    55247678623618908585,\r\n    55695201837382719499,\r\n    56138249819008892304,\r\n    56576867320818803381,\r\n    57011098647610615347,\r\n    57440987661134509194,\r\n    57866577784523164102,\r\n    58287912006677932461,\r\n    58705032886611153136,\r\n    59117982557745041605,\r\n    59526802732167591189,\r\n    59931534704845915277,\r\n    60332219357797456124,\r\n    60728897164219481563,\r\n    61121608192577286747,\r\n    61510392110651513880,\r\n    61895288189544998741,\r\n    62276335307649548754,\r\n    62653571954573053266,\r\n    63027036235027322733,\r\n    63396765872677049506];\r\n\r\n    // threshold of agent upgrade\r\n    uint256[10] public requirement =\r\n    [0,\r\n    73890560989306501,\r\n    200855369231876674,\r\n    545981500331442382,\r\n    1484131591025766010,\r\n    4034287934927351160,\r\n    10966331584284585813,\r\n    29809579870417282259,\r\n    81030839275753838749,\r\n    220264657948067161559];\r\n\r\n\r\n    //******************\r\n    // EVENT\r\n    //******************\r\n    event UPGRADE (address indexed agent, uint256 level);\r\n    event BUYINSURANCE(address indexed buyer, uint256 indexed start, uint256 unit,  uint256 date);\r\n\r\n\r\n    //******************\r\n    // MODIFIER\r\n    //******************\r\n    modifier isHuman() {\r\n        address _addr = msg.sender;\r\n        uint256 _codeLength;\r\n\r\n        assembly {_codeLength := extcodesize(_addr)}\r\n        require(_codeLength == 0, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev Constructor\r\n     * @notice Initialize the time\r\n     */\r\n    constructor() public {\r\n        _now = now;\r\n        today = _now / 1 days;\r\n    }\r\n\r\n    /**\r\n     * @dev Ticker\r\n     * @notice It is called everytime when a player interacts with this contract\r\n     * @return true is Fomo3D is ended, false otherwise\r\n     */\r\n    function tick() internal returns(bool) {\r\n        if (_now != now) {\r\n            _now = now;\r\n            uint256 _today; // the current day as soon as ticker is called\r\n\r\n            //check if fomo3D ends\r\n            (,,end, ended,,,,,,,,) = FoMoLong.round_(thisRoundIndex);\r\n            if (!ended) {\r\n                _today = _now / 1 days;\r\n            }\r\n            else {\r\n                _today = end / 1 days;\r\n            }\r\n\r\n            // calculate the outdated issuedInsurance\r\n            while (today < _today) {\r\n                issuedInsurance = issuedInsurance.sub(unitToExpire[today]);\r\n                today += 1;\r\n            }\r\n        }\r\n        return ended;\r\n    }\r\n\r\n    /**\r\n     * @dev Register\r\n     * @notice Register a name by a human player\r\n     */\r\n    function register(string _nameString) external payable isHuman() {\r\n        bytes32 _name = _nameString.nameFilter();\r\n        address _agent = msg.sender;\r\n        require(msg.value >= 10000000000000000);\r\n        require(agentxName_[_name] == address(0));\r\n\r\n        if(!player[_agent].isAgent){\r\n            agents += 1;\r\n            player[_agent].isAgent = true;\r\n            player[_agent].id = agents;\r\n            player[_agent].level = 1;\r\n            agentxID_[agents] = _agent;\r\n        }\r\n        // set name active for the player\r\n        player[_agent].name = _name;\r\n        agentxName_[_name] = _agent;\r\n\r\n        if(!community.send(msg.value)){\r\n            pot = pot.add(msg.value);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Upgrade\r\n     * @notice Upgrade when a player's affiliate bonus meet the promotion\r\n     */\r\n    function upgrade() external isHuman(){\r\n        address _agent = msg.sender;\r\n        require(player[_agent].isAgent);\r\n        require(player[_agent].level < maxLevel);\r\n\r\n        if(player[_agent].accumulatedAff >= requirement[player[_agent].level]){\r\n            player[_agent].level = (1).add(player[_agent].level);\r\n            emit UPGRADE(_agent,player[_agent].level);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Buy, using address for referral\r\n     */\r\n    function buyXaddr(address _agent, uint256 _date)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        // ticker\r\n        if(tick()){\r\n            msg.sender.transfer(msg.value);\r\n            return;\r\n        }\r\n\r\n        // validate agent\r\n        if(!player[_agent].isAgent){\r\n            _agent = address(0);\r\n        }\r\n\r\n        buyCore(msg.sender, msg.value, _date, _agent);\r\n    }\r\n\r\n    function buyXid(uint256 _agentId, uint256 _date)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        // ticker\r\n        if(tick()){\r\n            msg.sender.transfer(msg.value);\r\n            return;\r\n        }\r\n\r\n        address _agent = agentxID_[_agentId];\r\n\r\n        // validate agent\r\n        if(!player[_agent].isAgent){\r\n            _agent = address(0);\r\n        }\r\n\r\n        buyCore(msg.sender, msg.value, _date, _agent);\r\n    }\r\n\r\n    function buyXname(bytes32 _agentName, uint256 _date)\r\n        isHuman()\r\n        public\r\n        payable\r\n    {\r\n        // ticker\r\n        if(tick()){\r\n            msg.sender.transfer(msg.value);\r\n            return;\r\n        }\r\n\r\n        address _agent = agentxName_[_agentName];\r\n\r\n        // validate agent\r\n        if(!player[_agent].isAgent){\r\n            _agent = address(0);\r\n        }\r\n\r\n        buyCore(msg.sender, msg.value, _date, _agent);\r\n    }\r\n\r\n    /**\r\n     * @dev Core part of buying\r\n     */\r\n    function buyCore(address _buyer, uint256 _eth, uint256 _date, address _agent) internal {\r\n\r\n        updatePlayerUnit(_buyer);\r\n        \r\n        require(_eth >= 1000000000, \"pocket lint: not a valid currency\");\r\n\r\n        if(_date > maxInsurePeriod){\r\n            _date = maxInsurePeriod;\r\n        }\r\n        uint256 _rate = rate[_date] + 1000000000000000000;\r\n        uint256 ethToBuyKey = _eth.mul(1000000000000000000) / _rate;\r\n        //-- ethToBuyKey is a virtual amount used to represent the eth player paid for buying keys, which is usually different from _eth\r\n\r\n        // get value of keys and insurances can be bought\r\n        uint256 _key = ethOfKey.keysRec(ethToBuyKey);\r\n        uint256 _unit = (_date == 0)? 0: _key;\r\n        uint256 newDate = today + _date - 1;\r\n\r\n\r\n        // update global data\r\n        ethOfKey = ethOfKey.add(ethToBuyKey);\r\n        keys = keys.add(_key);\r\n        unitToExpire[newDate] = unitToExpire[newDate].add(_unit);\r\n        issuedInsurance = issuedInsurance.add(_unit);\r\n\r\n        // update player data\r\n        player[_buyer].eth = player[_buyer].eth.add(_eth);\r\n        player[_buyer].keys = player[_buyer].keys.add(_key);\r\n        player[_buyer].units = player[_buyer].units.add(_unit);\r\n        unitToExpirePlayer[_buyer][newDate] = unitToExpirePlayer[_buyer][newDate].add(_unit);\r\n\r\n        distributeEx(_eth, _agent);\r\n        distributeIn(_buyer, _eth, _key);\r\n        emit BUYINSURANCE(_buyer, today, _unit, _date);\r\n    }\r\n\r\n    /**\r\n     * @dev Update player's units of insurance\r\n     */\r\n    function updatePlayerUnit(address _player) internal {\r\n        uint256 _today = player[_player].plyrLastSeen;\r\n        uint256 expiredUnit = 0;\r\n        if(_today != 0){\r\n            while(_today < today){\r\n                expiredUnit = expiredUnit.add(unitToExpirePlayer[_player][_today]);\r\n                _today += 1;\r\n            }\r\n            player[_player].units = player[_player].units.sub(expiredUnit);\r\n        }\r\n        player[_player].plyrLastSeen = today;\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute to the external\r\n     */\r\n    function distributeEx(uint256 _eth, address _agent) internal {\r\n        uint256 ex = _eth / 4 ;\r\n        uint256 affRate;\r\n        if(player[_agent].isAgent){\r\n            affRate = player[_agent].level.add(6);\r\n        }\r\n        uint256 _aff = _eth.mul(affRate) / 100;\r\n        if (_aff > 0) {\r\n            player[_agent].aff = player[_agent].aff.add(_aff);\r\n            player[_agent].accumulatedAff = player[_agent].accumulatedAff.add(_aff);\r\n        }\r\n        ex = ex.sub(_aff);\r\n        uint256 _com = ex / 3;\r\n        uint256 _p3d = ex.sub(_com);\r\n\r\n        if(!community.send(_com)){\r\n            pot = pot.add(_com);\r\n        }\r\n        Divies.deposit.value(_p3d)();\r\n    }\r\n\r\n    /**\r\n     * @dev Distribute to the internal\r\n     */\r\n    function distributeIn(address _buyer, uint256 _eth, uint256 _keys) internal {\r\n        uint256 _gen = _eth.mul(3) / 20;\r\n\r\n        // update eth balance (eth = eth - (com share + aff share + p3d share))\r\n        _eth = _eth.sub(_eth / 4);\r\n\r\n        // calculate pot\r\n        uint256 _pot = _eth.sub(_gen);\r\n\r\n        // distribute gen share (that's what updateMasks() does) and adjust\r\n        // balances for dust.\r\n        uint256 _dust = updateMasks(_buyer, _gen, _keys);\r\n        if (_dust > 0)\r\n            _gen = _gen.sub(_dust);\r\n\r\n        // add eth to pot\r\n        pot = pot.add(_dust).add(_pot);\r\n    }\r\n\r\n    function updateMasks(address  _player, uint256 _gen, uint256 _keys)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        /* MASKING NOTES\r\n            earnings masks are a tricky thing for people to wrap their minds around.\r\n            the basic thing to understand here is we're going to have a global\r\n            tracker based on profit per share for each round, that increases in\r\n            relevant proportion to the increase in share supply.\r\n\r\n            the player will have an additional mask that basically says \"based\r\n            on the global mask, my shares, and how much i've already withdrawn,\r\n            how much is still owed to me?\"\r\n        */\r\n\r\n        // calculate profit per key & global mask based on this buy:  (dust goes to pot)\r\n        uint256 _ppt = _gen.mul(1000000000000000000) / keys;\r\n        mask = mask.add(_ppt);\r\n\r\n        // calculate player earning from their own buy (only based on the keys\r\n        // they just bought). & update player earnings mask\r\n        uint256 _pearn = (_ppt.mul(_keys)) / 1000000000000000000;\r\n        player[_player].mask = (((mask.mul(_keys)) / 1000000000000000000).sub(_pearn)).add(player[_player].mask);\r\n\r\n        // calculate & return dust\r\n        return(_gen.sub( _ppt.mul(keys) / 1000000000000000000));\r\n    }\r\n\r\n    /**\r\n     * @dev Submit a claim from the beneficiary\r\n     */\r\n    function claim() isHuman() public {\r\n        require(tick());\r\n        address beneficiary = msg.sender;\r\n        updatePlayerUnit(beneficiary);\r\n        uint256 amount = pot.mul(player[beneficiary].units) / issuedInsurance;\r\n        player[beneficiary].units = 0;\r\n        beneficiary.transfer(amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Withdraw dividends and aff\r\n     */\r\n    function withdraw() isHuman() public {\r\n        // setup temp var for player eth\r\n        uint256 _eth;\r\n\r\n        // get their earnings\r\n        _eth = withdrawEarnings(msg.sender);\r\n\r\n        // gib moni\r\n        if (_eth > 0)\r\n            msg.sender.transfer(_eth);\r\n    }\r\n\r\n    function withdrawEarnings(address _player)\r\n        private\r\n        returns(uint256)\r\n    {\r\n        // update gen vault\r\n        updateGenVault(_player);\r\n\r\n        // from vaults\r\n        uint256 _earnings = player[_player].gen.add(player[_player].aff);\r\n        if (_earnings > 0) {\r\n            player[_player].gen = 0;\r\n            player[_player].aff = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n\r\n    function updateGenVault(address _player)\r\n        private\r\n    {\r\n        uint256 _earnings = calcUnMaskedEarnings(_player);\r\n        if (_earnings > 0) {\r\n            // put in gen vault\r\n            player[_player].gen = _earnings.add(player[_player].gen);\r\n            // zero out their earnings by updating mask\r\n            player[_player].mask = _earnings.add(player[_player].mask);\r\n        }\r\n    }\r\n\r\n    function calcUnMaskedEarnings(address _player)\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(  (mask.mul(player[_player].keys) / 1000000000000000000).sub(player[_player].mask)  );\r\n    }\r\n\r\n    /**\r\n     * @dev Return the price buyer will pay for next 1 individual key.\r\n     * @return Price for next key bought (in wei format)\r\n     */\r\n    function getBuyPrice() public view returns(uint256) {\r\n        return(keys.add(1000000000000000000).ethRec(1000000000000000000));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the units of insurance of player\r\n     * @return Amount of existing units of insurance\r\n     */\r\n    function getCurrentUnit(address _player) public view returns(uint256) {\r\n        uint256 _unit = player[_player].units;\r\n        uint256 _today = player[_player].plyrLastSeen;\r\n        uint256 expiredUnit = 0;\r\n        if(_today != 0){\r\n            while(_today < today){\r\n                expiredUnit = expiredUnit.add(unitToExpirePlayer[_player][_today]);\r\n                _today += 1;\r\n            }\r\n\r\n        }\r\n        return( _unit == 0 ? 0 : _unit.sub(expiredUnit));\r\n    }\r\n\r\n    /**\r\n     * @dev Get the list of units of insurace going to expire of a player\r\n     * @return List of units of insurance going to expire from a player\r\n     */\r\n    function getExpiringUnitListPlayer(address _player)\r\n        public\r\n        view\r\n        returns(uint256[maxInsurePeriod] expiringUnitList)\r\n    {\r\n        for(uint256 i=0; i<maxInsurePeriod; i++) {\r\n            expiringUnitList[i] = unitToExpirePlayer[_player][today+i];\r\n        }\r\n        return(expiringUnitList);\r\n    }\r\n\r\n    /**\r\n     * @dev Get the list of units of insurace going to expire\r\n     * @return List of units of insurance going to expire\r\n     */\r\n    function getExpiringUnitList()\r\n        public\r\n        view\r\n        returns(uint256[maxInsurePeriod] expiringUnitList)\r\n    {\r\n        for(uint256 i=0; i<maxInsurePeriod; i++){\r\n            expiringUnitList[i] = unitToExpire[today+i];\r\n        }\r\n        return(expiringUnitList);\r\n    }\r\n}\r\n\r\ncontract FoMo3Dlong {\r\n//==============================================================================\r\n//     _| _ _|_ _    _ _ _|_    _   .\r\n//    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes)\r\n//=============================|================================================\r\n    uint256 public rID_;    // round id number / total rounds that have happened\r\n//****************\r\n// ROUND DATA\r\n//****************\r\n    mapping (uint256 => F3Ddatasets.Round) public round_;\r\n}\r\n\r\ninterface DiviesInterface {\r\n    function deposit() external payable;\r\n}\r\n\r\nlibrary F3DKeysCalcLong {\r\n    using SafeMath for *;\r\n    /**\r\n     * @dev calculates number of keys received given X eth\r\n     * @param _curEth current amount of eth in contract\r\n     * @param _newEth eth being spent\r\n     * @return amount of ticket purchased\r\n     */\r\n    function keysRec(uint256 _curEth, uint256 _newEth)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return(keys((_curEth).add(_newEth)).sub(keys(_curEth)));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates amount of eth received if you sold X keys\r\n     * @param _curKeys current amount of keys that exist\r\n     * @param _sellKeys amount of keys you wish to sell\r\n     * @return amount of eth received\r\n     */\r\n    function ethRec(uint256 _curKeys, uint256 _sellKeys)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys))));\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how many keys would exist with given an amount of eth\r\n     * @param _eth eth \"in contract\"\r\n     * @return number of keys that would exist\r\n     */\r\n    function keys(uint256 _eth)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000);\r\n    }\r\n\r\n    /**\r\n     * @dev calculates how much eth would be in contract given a number of keys\r\n     * @param _keys number of keys \"in contract\"\r\n     * @return eth that would exists\r\n     */\r\n    function eth(uint256 _keys)\r\n        internal\r\n        pure\r\n        returns(uint256)\r\n    {\r\n        return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq());\r\n    }\r\n}\r\n\r\nlibrary F3Ddatasets {\r\n    struct Round {\r\n        uint256 plyr;   // pID of player in lead\r\n        uint256 team;   // tID of team in lead\r\n        uint256 end;    // time ends/ended\r\n        bool ended;     // has round end function been ran\r\n        uint256 strt;   // time round started\r\n        uint256 keys;   // keys\r\n        uint256 eth;    // total eth in\r\n        uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends)\r\n        uint256 mask;   // global mask\r\n        uint256 ico;    // total eth sent in during ICO phase\r\n        uint256 icoGen; // total eth for gen during ICO phase\r\n        uint256 icoAvg; // average key price for ICO phase\r\n    }\r\n}\r\n\r\nlibrary NameFilter {\r\n    /**\r\n     * @dev filters name strings\r\n     * -converts uppercase to lower case.\r\n     * -makes sure it does not start/end with a space\r\n     * -makes sure it does not contain multiple spaces in a row\r\n     * -cannot be only numbers\r\n     * -cannot start with 0x\r\n     * -restricts characters to A-Z, a-z, 0-9, and space.\r\n     * @return reprocessed string in bytes32 format\r\n     */\r\n    function nameFilter(string _input)\r\n        internal\r\n        pure\r\n        returns(bytes32)\r\n    {\r\n        bytes memory _temp = bytes(_input);\r\n        uint256 _length = _temp.length;\r\n\r\n        //sorry limited to 32 characters\r\n        require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\");\r\n        // make sure it doesnt start with or end with space\r\n        require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\");\r\n        // make sure first two characters are not 0x\r\n        if (_temp[0] == 0x30)\r\n        {\r\n            require(_temp[1] != 0x78, \"string cannot start with 0x\");\r\n            require(_temp[1] != 0x58, \"string cannot start with 0X\");\r\n        }\r\n\r\n        // create a bool to track if we have a non number character\r\n        bool _hasNonNumber;\r\n\r\n        // convert & check\r\n        for (uint256 i = 0; i < _length; i++)\r\n        {\r\n            // if its uppercase A-Z\r\n            if (_temp[i] > 0x40 && _temp[i] < 0x5b)\r\n            {\r\n                // convert to lower case a-z\r\n                _temp[i] = byte(uint(_temp[i]) + 32);\r\n\r\n                // we have a non number\r\n                if (_hasNonNumber == false)\r\n                    _hasNonNumber = true;\r\n            } else {\r\n                require\r\n                (\r\n                    // require character is a space\r\n                    _temp[i] == 0x20 ||\r\n                    // OR lowercase a-z\r\n                    (_temp[i] > 0x60 && _temp[i] < 0x7b) ||\r\n                    // or 0-9\r\n                    (_temp[i] > 0x2f && _temp[i] < 0x3a),\r\n                    \"string contains invalid characters\"\r\n                );\r\n                // make sure theres not 2x spaces in a row\r\n                if (_temp[i] == 0x20)\r\n                    require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\");\r\n\r\n                // see if we have a character other than a number\r\n                if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39))\r\n                    _hasNonNumber = true;\r\n            }\r\n        }\r\n\r\n        require(_hasNonNumber == true, \"string cannot be only numbers\");\r\n\r\n        bytes32 _ret;\r\n        assembly {\r\n            _ret := mload(add(_temp, 32))\r\n        }\r\n        return (_ret);\r\n    }\r\n}\r\n\r\nlibrary SafeMath {\r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c)\r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y)\r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y)\r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n\r\n    /**\r\n     * @dev x to the power of y\r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else\r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getBuyPrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"mask\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ended\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"agentxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unitToExpirePlayer\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"keys\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getExpiringUnitList\",\"outputs\":[{\"name\":\"expiringUnitList\",\"type\":\"uint256[100]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"issuedInsurance\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getExpiringUnitListPlayer\",\"outputs\":[{\"name\":\"expiringUnitList\",\"type\":\"uint256[100]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pot\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"player\",\"outputs\":[{\"name\":\"id\",\"type\":\"uint256\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"isAgent\",\"type\":\"bool\"},{\"name\":\"eth\",\"type\":\"uint256\"},{\"name\":\"keys\",\"type\":\"uint256\"},{\"name\":\"units\",\"type\":\"uint256\"},{\"name\":\"plyrLastSeen\",\"type\":\"uint256\"},{\"name\":\"mask\",\"type\":\"uint256\"},{\"name\":\"level\",\"type\":\"uint256\"},{\"name\":\"accumulatedAff\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"claim\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"agents\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_player\",\"type\":\"address\"}],\"name\":\"getCurrentUnit\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"requirement\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agentId\",\"type\":\"uint256\"},{\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"buyXid\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agent\",\"type\":\"address\"},{\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"buyXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_agentName\",\"type\":\"bytes32\"},{\"name\":\"_date\",\"type\":\"uint256\"}],\"name\":\"buyXname\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"unitToExpire\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"_now\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ethOfKey\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"today\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"upgrade\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"agentxID_\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rate\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"end\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_nameString\",\"type\":\"string\"}],\"name\":\"register\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"agent\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"level\",\"type\":\"uint256\"}],\"name\":\"UPGRADE\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"buyer\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"start\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"unit\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"date\",\"type\":\"uint256\"}],\"name\":\"BUYINSURANCE\",\"type\":\"event\"}]","ContractName":"FoMoInsurance","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://e9c4be2df65f0917683a00ef0f245ef0fb4370a9508e0237f6cd91529cf3a0a0"}]}