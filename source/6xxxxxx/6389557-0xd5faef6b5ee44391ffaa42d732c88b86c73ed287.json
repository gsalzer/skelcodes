{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/// @notice RenExAtomicSwapper implements the RenEx atomic swapping interface\r\n/// for Ether values. Does not support ERC20 tokens.\r\ncontract RenExAtomicSwapper {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    struct Swap {\r\n        uint256 timelock;\r\n        uint256 value;\r\n        address ethTrader;\r\n        address withdrawTrader;\r\n        bytes32 secretLock;\r\n        bytes32 secretKey;\r\n    }\r\n\r\n    enum States {\r\n        INVALID,\r\n        OPEN,\r\n        CLOSED,\r\n        EXPIRED\r\n    }\r\n\r\n    // Events\r\n    event LogOpen(bytes32 _swapID, address _withdrawTrader, bytes32 _secretLock);\r\n    event LogExpire(bytes32 _swapID);\r\n    event LogClose(bytes32 _swapID, bytes32 _secretKey);\r\n\r\n    // Storage\r\n    mapping (bytes32 => Swap) private swaps;\r\n    mapping (bytes32 => States) private swapStates;\r\n    mapping (bytes32 => uint256) public redeemedAt;\r\n\r\n    /// @notice Throws if the swap is not invalid (i.e. has already been opened)\r\n    modifier onlyInvalidSwaps(bytes32 _swapID) {\r\n        require(swapStates[_swapID] == States.INVALID, \"swap opened previously\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the swap is not open.\r\n    modifier onlyOpenSwaps(bytes32 _swapID) {\r\n        require(swapStates[_swapID] == States.OPEN, \"swap not open\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the swap is not closed.\r\n    modifier onlyClosedSwaps(bytes32 _swapID) {\r\n        require(swapStates[_swapID] == States.CLOSED, \"swap not redeemed\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the swap is not expirable.\r\n    modifier onlyExpirableSwaps(bytes32 _swapID) {\r\n        /* solium-disable-next-line security/no-block-members */\r\n        require(now >= swaps[_swapID].timelock, \"swap not expirable\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Throws if the secret key is not valid.\r\n    modifier onlyWithSecretKey(bytes32 _swapID, bytes32 _secretKey) {\r\n        require(swaps[_swapID].secretLock == sha256(abi.encodePacked(_secretKey)), \"invalid secret\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    constructor(string _VERSION) public {\r\n        VERSION = _VERSION;\r\n    }\r\n\r\n    /// @notice Initiates the atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _withdrawTrader The address of the withdrawing trader.\r\n    /// @param _secretLock The hash of the secret (Hash Lock).\r\n    /// @param _timelock The unix timestamp when the swap expires.\r\n    function initiate(\r\n        bytes32 _swapID,\r\n        address _withdrawTrader,\r\n        bytes32 _secretLock,\r\n        uint256 _timelock\r\n    ) external onlyInvalidSwaps(_swapID) payable {\r\n        // Store the details of the swap.\r\n        Swap memory swap = Swap({\r\n            timelock: _timelock,\r\n            value: msg.value,\r\n            ethTrader: msg.sender,\r\n            withdrawTrader: _withdrawTrader,\r\n            secretLock: _secretLock,\r\n            secretKey: 0x0\r\n        });\r\n        swaps[_swapID] = swap;\r\n        swapStates[_swapID] = States.OPEN;\r\n\r\n        // Logs open event\r\n        emit LogOpen(_swapID, _withdrawTrader, _secretLock);\r\n    }\r\n\r\n    /// @notice Redeems an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    /// @param _secretKey The secret of the atomic swap.\r\n    function redeem(bytes32 _swapID, bytes32 _secretKey) external onlyOpenSwaps(_swapID) onlyWithSecretKey(_swapID, _secretKey) {\r\n        // Close the swap.\r\n        Swap memory swap = swaps[_swapID];\r\n        swaps[_swapID].secretKey = _secretKey;\r\n        swapStates[_swapID] = States.CLOSED;\r\n        /* solium-disable-next-line security/no-block-members */\r\n        redeemedAt[_swapID] = now;\r\n\r\n        // Transfer the ETH funds from this contract to the withdrawing trader.\r\n        swap.withdrawTrader.transfer(swap.value);\r\n\r\n        // Logs close event\r\n        emit LogClose(_swapID, _secretKey);\r\n    }\r\n\r\n    /// @notice Refunds an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function refund(bytes32 _swapID) external onlyOpenSwaps(_swapID) onlyExpirableSwaps(_swapID) {\r\n        // Expire the swap.\r\n        Swap memory swap = swaps[_swapID];\r\n        swapStates[_swapID] = States.EXPIRED;\r\n\r\n        // Transfer the ETH value from this contract back to the ETH trader.\r\n        swap.ethTrader.transfer(swap.value);\r\n\r\n        // Logs expire event\r\n        emit LogExpire(_swapID);\r\n    }\r\n\r\n    /// @notice Audits an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function audit(bytes32 _swapID) external view returns (uint256 timelock, uint256 value, address to, address from, bytes32 secretLock) {\r\n        Swap memory swap = swaps[_swapID];\r\n        return (swap.timelock, swap.value, swap.withdrawTrader, swap.ethTrader, swap.secretLock);\r\n    }\r\n\r\n    /// @notice Audits the secret of an atomic swap.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function auditSecret(bytes32 _swapID) external view onlyClosedSwaps(_swapID) returns (bytes32 secretKey) {\r\n        Swap memory swap = swaps[_swapID];\r\n        return swap.secretKey;\r\n    }\r\n\r\n    /// @notice Checks whether a swap is refundable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function refundable(bytes32 _swapID) external view returns (bool) {\r\n        /* solium-disable-next-line security/no-block-members */\r\n        return (now >= swaps[_swapID].timelock && swapStates[_swapID] == States.OPEN);\r\n    }\r\n\r\n    /// @notice Checks whether a swap is initiatable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function initiatable(bytes32 _swapID) external view returns (bool) {\r\n        return (swapStates[_swapID] == States.INVALID);\r\n    }\r\n\r\n    /// @notice Checks whether a swap is redeemable or not.\r\n    ///\r\n    /// @param _swapID The unique atomic swap id.\r\n    function redeemable(bytes32 _swapID) external view returns (bool) {\r\n        return (swapStates[_swapID] == States.OPEN);\r\n    }\r\n\r\n    /// @notice Generates a deterministic swap id using initiate swap details.\r\n    ///\r\n    /// @param _withdrawTrader The address of the withdrawing trader.\r\n    /// @param _secretLock The hash of the secret.\r\n    /// @param _timelock The expiry timestamp.\r\n    function swapID(address _withdrawTrader, bytes32 _secretLock, uint256 _timelock) public pure returns (bytes32) {\r\n        return keccak256(abi.encodePacked(_withdrawTrader, _secretLock, _timelock));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"initiatable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_withdrawTrader\",\"type\":\"address\"},{\"name\":\"_secretLock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"initiate\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_withdrawTrader\",\"type\":\"address\"},{\"name\":\"_secretLock\",\"type\":\"bytes32\"},{\"name\":\"_timelock\",\"type\":\"uint256\"}],\"name\":\"swapID\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"pure\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"redeemable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"refund\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"auditSecret\",\"outputs\":[{\"name\":\"secretKey\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"refundable\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"name\":\"_secretKey\",\"type\":\"bytes32\"}],\"name\":\"redeem\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"redeemedAt\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"audit\",\"outputs\":[{\"name\":\"timelock\",\"type\":\"uint256\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"from\",\"type\":\"address\"},{\"name\":\"secretLock\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_VERSION\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_withdrawTrader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"_secretLock\",\"type\":\"bytes32\"}],\"name\":\"LogOpen\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"}],\"name\":\"LogExpire\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"_swapID\",\"type\":\"bytes32\"},{\"indexed\":false,\"name\":\"_secretKey\",\"type\":\"bytes32\"}],\"name\":\"LogClose\",\"type\":\"event\"}]","ContractName":"RenExAtomicSwapper","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000005312e302e31000000000000000000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://f7803594c971963981c8a2a9f19a130eb0591181421756fb522f45c932d51f4a"}]}