{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\n\r\ncontract SPBevents {\r\n\r\n    // fired whenever theres a withdraw\r\n    event onWithdraw\r\n    (\r\n        uint256 indexed sniperID,\r\n        address sniperAddress,\r\n        uint256 ethOut,\r\n        uint256 timeStamp\r\n    );\r\n\r\n    // fired whenever an affiliate is paid\r\n    event onAffiliatePayout\r\n    (\r\n        uint256 indexed affiliateID,\r\n        uint256 indexed roundID,\r\n        uint256 indexed buyerID,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a sniper get a random number\r\n    event onCheckMainpot\r\n    (\r\n        uint256 indexed randomNumber,\r\n        uint256 indexed roundID,\r\n        address indexed sniperAddress,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a sniper get a random number\r\n    event onCheckLuckypot\r\n    (\r\n        uint256 indexed randomNumber,\r\n        uint256 indexed roundID,\r\n        address indexed sniperAddress,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a sniper get a random number\r\n    event onCheckKingpot\r\n    (\r\n        uint256 indexed randomNumber,\r\n        address indexed sniperAddress,\r\n        uint256 indexed roundID,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a sniper get a random number hit the exact same numbers that other snipers have\r\n    event onCheckHitNumber\r\n    (\r\n        uint256 indexed randomNumber,\r\n        uint256 indexed beingHitSniperID,\r\n        address indexed firedSniperAddress,\r\n        uint256 roundID,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a sniper send eth\r\n    event onEndTx\r\n    (\r\n        uint256 sniperID,\r\n        uint256 ethIn,\r\n        uint256 number,\r\n        uint256 laffID,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    // fired whenever a sniper send eth for ICO\r\n    event onICOAngel\r\n    (\r\n        address indexed whoInvest,\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n    \r\n    event onOEZDay\r\n    (\r\n        uint256 amount,\r\n        uint256 timeStamp\r\n    );\r\n}\r\n\r\ncontract modularBillion is SPBevents {}\r\n\r\ncontract SniperBillion is modularBillion {\r\n    \r\n    using SafeMath for *;\r\n    using Array256Lib for uint256[];\r\n   \r\n    \r\n    address constant private comReward_ = 0x8Aa94D530cC572aF0C730147E1ab76875F25f71C;\r\n    address constant private comMarket_ = 0x6c14CAAc549d7411faE4e201105B4D33afb8a3db;\r\n    address constant private comICO_ = 0xbAdb636C5C3665a969159a6b993F811D9F263639;\r\n    address constant private donateAccount_ =  0x1bB064708eBf4763BeB495877E99Dfeb75198942;\r\n    \r\n    RubyFundForwarderInterface constant private Ruby_Fund = RubyFundForwarderInterface(0x7D653E0Ecb4DAF3166a49525Df04147a7180B051);\r\n    SniperBookInterface constant private SniperBook = SniperBookInterface(0xc294FA45F713B09d865A088543765800F47514eD);\r\n\r\n    string constant public name   = \"Sniper Billion Official\";\r\n    string constant public symbol = \"SPB\";\r\n    \r\n\r\n    uint256 constant private icoEndTime_ = 24 hours;   // ICO timer end at this\r\n    uint256 constant private maxNumber_  = 100000000; // 100,000,000 - 100 million\r\n\r\n    uint256 public totalSum_;\r\n    uint256 public rID_;\r\n    uint256 public icoAmount_;\r\n    \r\n    bool private isDrawed_ = false;\r\n    uint256 lastSID_;\r\n    \r\n    uint256[] private globalArr_;\r\n    uint256[] private icoSidArr_;            \r\n    uint256[] private luckyPotBingoArr_;\r\n    uint256[] private airdropPotBingoArr_;\r\n    \r\n    //****************\r\n    // SNIPER DATA \r\n    //****************\r\n    mapping (address => uint256) public sIDxAddr_;          // (addr => sID) returns sniper id by address\r\n    mapping (bytes32 => uint256) public sIDxName_;          // (name => sID) returns sniper id by name\r\n    mapping (uint256 => uint256) public sidXnum_;           // (number => sID) returns sniper id by random number;\r\n\r\n    mapping (uint256 => SPBdatasets.Sniper) public spr_;   // (sID => data) sniper data\r\n    mapping (uint256 => SPBdatasets.Round) public round_;\r\n    mapping (uint256 => mapping (bytes32 => bool)) public sprNames_; // (sID => name => bool) list of names a sniper owns.\r\n    \r\n    \r\n    constructor()\r\n        public \r\n    {\r\n        //does nothing\r\n    }\r\n\r\n    /**\r\n     * @dev used to make sure no one can interact with contract until it has \r\n     * been activated. \r\n     */\r\n    modifier isActivated() {\r\n        require(activated_ == true, \"its not ready yet.  check our discord\"); \r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev prevents contracts from interacting with Sniper Billion Game \r\n     */\r\n    modifier isHuman() {\r\n        require(tx.origin == msg.sender, \"sorry humans only\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @dev sets boundaries for incoming tx \r\n     */\r\n    modifier isWithinLimits(uint256 _eth) {\r\n        require(_eth >= 100000000000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 100000000000000000000000, \"no vitalik, no\");\r\n        _;    \r\n    }\r\n    \r\n    /**\r\n     * @dev check boundaries for ico time \r\n     */\r\n    modifier isIcoPhase() {\r\n        require(now < round_[1].icoend, \"ico end\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev after the ICO ends, the game begins\r\n     */\r\n    modifier isGameStart() {\r\n        require(now > round_[rID_].icoend, \"start\");\r\n        _;\r\n    }\r\n    \r\n    /**\r\n     * @dev sets boundaries for ico\r\n     */\r\n    modifier isWithinIcoLimits(uint256 _eth) {\r\n        require(_eth >= 1000000000000000000, \"pocket lint: not a valid currency\");\r\n        require(_eth <= 200000000000000000000, \"ico up to 200 Ether\");\r\n        _;    \r\n    }\r\n    \r\n    /**\r\n     * @dev emergency buy uses last stored affiliate ID\r\n     */\r\n    function()\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        isGameStart()\r\n        payable\r\n        external\r\n    {\r\n        // determine if sniper is new or not\r\n        determineSID();\r\n            \r\n        // fetch sniper id\r\n        uint256 _sID = sIDxAddr_[msg.sender];\r\n        \r\n        // buy core \r\n        buyCore(_sID, spr_[_sID].laff);\r\n    }\r\n    \r\n    function buyXaddr(address _affCode)\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isWithinLimits(msg.value)\r\n        isGameStart()\r\n        payable\r\n    {\r\n        // determine if sniper is new or not\r\n        determineSID();\r\n        \r\n        // fetch player id\r\n        uint256 _sID = sIDxAddr_[msg.sender];\r\n        \r\n        // manage affiliate residuals\r\n        uint256 _affID;\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = spr_[_sID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = sIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != spr_[_sID].laff)\r\n            {\r\n                // update last affiliate\r\n                spr_[_sID].laff = _affID;\r\n            }\r\n        }\r\n        \r\n\r\n        // if no affiliate code was given or player tried to use their own, lolz\r\n        if (_affCode == address(0) || _affCode == msg.sender)\r\n        {\r\n            // use last stored affiliate code\r\n            _affID = spr_[_sID].laff;\r\n        \r\n        // if affiliate code was given    \r\n        } else {\r\n            // get affiliate ID from aff Code \r\n            _affID = sIDxAddr_[_affCode];\r\n            \r\n            // if affID is not the same as previously stored \r\n            if (_affID != spr_[_sID].laff)\r\n            {\r\n                // update last affiliate\r\n                spr_[_sID].laff = _affID;\r\n            }\r\n        }\r\n\r\n        // buy core \r\n        buyCore(_sID, _affID);\r\n    }\r\n\r\n\r\n    function becomeSniperAngel()\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n        isIcoPhase()\r\n        isWithinIcoLimits(msg.value)\r\n        payable\r\n    {\r\n        // determine if sniper is new or not\r\n        determineSID();\r\n        \r\n        \r\n        // fetch sniper id\r\n        uint256 _sID = sIDxAddr_[msg.sender];\r\n        \r\n        spr_[_sID].icoAmt = spr_[_sID].icoAmt.add(msg.value); \r\n        \r\n        icoSidArr_.push(_sID);\r\n        \r\n        //ico amount 80% to mainpot\r\n        round_[1].mpot = round_[1].mpot.add((msg.value / 100).mul(80));\r\n        \r\n        //total ICO amount\r\n        icoAmount_ = icoAmount_.add(msg.value);\r\n        \r\n        //ico amount 20% to community.\r\n        uint256 _icoEth = (msg.value / 100).mul(20);\r\n        \r\n        if(_icoEth > 0)\r\n            comICO_.transfer(_icoEth);\r\n            \r\n        emit onICOAngel(msg.sender, msg.value, block.timestamp);\r\n    }\r\n    \r\n\r\n    /**\r\n     * @dev withdraws all of your earnings.\r\n     * -functionhash- \r\n     */\r\n    function withdraw()\r\n        public\r\n        isActivated()\r\n        isHuman()\r\n    {\r\n        // grab time\r\n        uint256 _now = now;\r\n        \r\n        // fetch player ID\r\n        uint256 _sID = sIDxAddr_[msg.sender];\r\n        \r\n\r\n        // get their earnings\r\n       uint256 _eth = withdrawEarnings(_sID);\r\n        \r\n        // gib moni\r\n        if (_eth > 0)\r\n            spr_[_sID].addr.transfer(_eth);\r\n        \r\n        // fire withdraw event\r\n        emit SPBevents.onWithdraw(_sID, msg.sender, _eth, _now);\r\n        \r\n    }\r\n    \r\n\r\n    function withdrawEarnings(uint256 _sID)\r\n        private\r\n        returns(uint256)\r\n    {\r\n\r\n        // from vaults \r\n        uint256 _earnings = (spr_[_sID].win).add(spr_[_sID].gen).add(spr_[_sID].aff).add(spr_[_sID].gems);\r\n        if (_earnings > 0)\r\n        {\r\n            spr_[_sID].win = 0;\r\n            spr_[_sID].gen = 0;\r\n            spr_[_sID].aff = 0;\r\n            spr_[_sID].gems = 0;\r\n        }\r\n\r\n        return(_earnings);\r\n    }\r\n\r\n    function generateRandom()\r\n        private\r\n        view\r\n        returns(uint256)\r\n    {\r\n        uint256 seed = uint256(keccak256(abi.encodePacked(\r\n            (block.timestamp).add\r\n            (block.difficulty).add\r\n            ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add\r\n            (block.gaslimit).add\r\n            ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add\r\n            (block.number)\r\n        )));\r\n        seed = seed - ((seed / 100000000) * 100000000) + 1;\r\n        return seed;\r\n    }\r\n\r\n    function itemRemove(uint256[] storage self, uint256 index) private {\r\n        if (index >= self.length) return;\r\n\r\n        for (uint256 i = index; i < self.length - 1; i++){\r\n            self[i] = self[i+1];\r\n        }\r\n        self.length--;\r\n    }\r\n\r\n    /**\r\n     * @dev logic runs whenever a buy order is executed.\r\n     */\r\n    function buyCore(uint256 _sID, uint256 _affID)\r\n        private\r\n    {\r\n        uint256 _rID = rID_;\r\n \r\n        //If the sniper does not enter the game through the affiliate, then 10% is paid to the team, \r\n        //otherwise, paid to the affiliate.\r\n\r\n        if(_affID == 0 && spr_[_sID].laff == 0) {\r\n            emit onAffiliatePayout(4, _rID, _sID, msg.value, now);\r\n            core(_rID, _sID, msg.value, 4);\r\n        }else{\r\n            emit onAffiliatePayout(_affID, _rID, _sID, msg.value, now);\r\n            core(_rID, _sID, msg.value, _affID);\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * @dev this is the core logic for any buy that happens.\r\n     */\r\n    function core(uint256 _rID, uint256 _sID, uint256 _eth, uint256 _affID)\r\n        private\r\n    {\r\n        uint256 _now = block.timestamp;\r\n\r\n        uint256 _value = _eth;\r\n        uint256 _laffRearwd = _value / 10;\r\n        \r\n        //affiliate sniper\r\n        spr_[_affID].aff = spr_[_affID].aff.add(_laffRearwd);\r\n        \r\n        //set sniper last affiliate id;\r\n        spr_[_sID].laff = _affID;\r\n        spr_[_sID].lplyt = _now;\r\n\r\n        _value = _value.sub(_laffRearwd);\r\n\r\n        uint256 _rndFireNum = generateRandom();\r\n        \r\n        emit onEndTx(_sID, _eth, _rndFireNum, _affID, _now);\r\n        \r\n        round_[_rID].ltime = _now;\r\n\r\n        bool _isBingoLp = false;\r\n        bool _isBingoKp = false;\r\n\r\n        if(globalArr_.length != 0){\r\n            if(globalArr_.length == 1)\r\n            {\r\n                globalArrEqualOne(_rID, _sID, _value, _rndFireNum);\r\n            }else{\r\n                globalArrNotEqualOne(_rID, _sID, _value, _rndFireNum);\r\n            }\r\n        }else{\r\n\r\n            globalArrEqualZero(_rID, _sID, _value, _rndFireNum);\r\n            \r\n        }\r\n        _isBingoLp = calcBingoLuckyPot(_rndFireNum);\r\n        \r\n        //bingo luckypot\r\n        if(_isBingoLp){\r\n            spr_[_sID].win = spr_[_sID].win.add(round_[_rID].lpot);\r\n            round_[_rID].lpot = 0;\r\n            emit onCheckLuckypot(_rndFireNum, _rID, spr_[_sID].addr, block.timestamp);\r\n        }\r\n\r\n        //bingo kingpot\r\n        if(_eth >= 500000000000000000){\r\n            _isBingoKp = calcBingoAirdropPot(_rndFireNum);\r\n            \r\n            if(_isBingoKp){\r\n                spr_[_sID].win = spr_[_sID].win.add(round_[_rID].apot);\r\n                round_[_rID].apot = 0;\r\n                emit onCheckKingpot(_rndFireNum, spr_[_sID].addr, _rID, block.timestamp);\r\n            }\r\n        }\r\n        \r\n        //win mainpot\r\n        checkWinMainPot(_rID, _sID, _rndFireNum);\r\n        \r\n        //surprise mother fuck\r\n        autoDrawWithOEZDay();\r\n    }\r\n    \r\n    /**\r\n     * @dev If the game is too crazy, the first draw will not be available for 180 days, \r\n     * and the contract will be automatically assigned to ensure the benefit of everyone. \r\n     * If the prize is opened once in 180 days, this setting is invalid.\r\n     */\r\n    \r\n    function autoDrawWithOEZDay()\r\n        private\r\n    {\r\n        uint256 _oezDay = round_[rID_].strt + 180 days;\r\n        if(!isDrawed_ && now > _oezDay){\r\n            \r\n            totalSum_ = 0;\r\n\r\n            // If an ICO investor exists\r\n            // ico         30%\r\n            // team        30%\r\n            // all sniper  30%\r\n            // marketing    5%\r\n            // donate       5%\r\n            \r\n            // If the ICO investor does not exist\r\n            // team        30%\r\n            // all sniper  60%\r\n            // marketing    5%\r\n            // donate       5%\r\n            \r\n            uint256 _cttBalance = round_[rID_].mpot.add(round_[rID_].lpot).add(round_[rID_].apot);\r\n            \r\n            \r\n            uint256 _communityRewards = (_cttBalance / 100).mul(30);\r\n            \r\n            if(_communityRewards > 0)\r\n                comReward_.transfer(_communityRewards);\r\n                \r\n            uint256 _sniperDividend;\r\n            \r\n        \r\n            if(icoAmount_ > 0){\r\n                // sniper dividend 30%\r\n                _sniperDividend = (_cttBalance / 100).mul(30);\r\n                //ico 30%\r\n                uint256 _icoValue = (_cttBalance / 100).mul(30);\r\n                distributeICO(_icoValue);\r\n            }else{\r\n                // sniper dividend 60%\r\n                _sniperDividend = (_cttBalance / 100).mul(60);\r\n            }\r\n            \r\n            \r\n            //each piece\r\n            uint256 _eachPiece = _sniperDividend / lastSID_;\r\n            \r\n            for(uint256 i = 1; i < lastSID_; i++)\r\n            {\r\n                spr_[i].win = spr_[i].win.add(_eachPiece);\r\n            }\r\n            \r\n            \r\n            //marketing 5% & donate 5%\r\n            uint256 _communityMarket = (_cttBalance / 100).mul(5);\r\n            if(_communityMarket > 0){\r\n                comMarket_.transfer(_communityMarket);\r\n                donateAccount_.transfer(_communityMarket);\r\n            }\r\n            \r\n            emit onOEZDay(_cttBalance, now);\r\n            \r\n            round_[rID_].mpot = 0;\r\n            round_[rID_].lpot = 0;\r\n            round_[rID_].apot = 0;\r\n            \r\n            uint256 _icoEndTime = round_[rID_].icoend;\r\n            \r\n            rID_++;\r\n            \r\n            round_[rID_].strt = now;\r\n            round_[rID_].icoend = _icoEndTime;\r\n            \r\n        }\r\n    }\r\n    \r\n    function globalArrEqualZero(uint256 _rID, uint256 _sID, uint256 _value, uint256 _rndFireNum)\r\n        private\r\n    {\r\n        round_[_rID].mpot = round_[_rID].mpot.add(((_value / 2) / 100).mul(90));\r\n        round_[_rID].lpot = round_[_rID].lpot.add(((_value / 2) / 100).mul(5));\r\n        round_[_rID].apot = round_[_rID].apot.add(((_value / 2) / 100).mul(5));\r\n        \r\n        sidXnum_[_rndFireNum] = _sID;\r\n        \r\n        spr_[_sID].numbers.push(_rndFireNum);\r\n        spr_[_sID].snums++;\r\n        spr_[_sID].gen = spr_[_sID].gen.add(_value / 2);\r\n        globalArr_.push(_rndFireNum);\r\n        \r\n        totalSum_ = totalSum_.add(_rndFireNum);\r\n    }\r\n\r\n    function globalArrNotEqualOne(uint256 _rID, uint256 _sID, uint256 _value, uint256 _rndFireNum)\r\n        private\r\n    {\r\n        uint256 _opID = sidXnum_[globalArr_[0]];\r\n        bool _found = false;\r\n        uint256 _index = 0;\r\n\r\n        (_found, _index) = globalArr_.indexOf(_rndFireNum, false);\r\n        _opID = sidXnum_[_rndFireNum];\r\n        \r\n        \r\n\r\n        if(_found){\r\n\r\n            (_found, _index) = spr_[_opID].numbers.indexOf(_rndFireNum, false);\r\n            \r\n            itemRemove(spr_[_opID].numbers, _index);\r\n\r\n            spr_[_opID].snums--;\r\n            \r\n            sidXnum_[_rndFireNum] = _sID;\r\n            \r\n            spr_[_sID].snums++;\r\n            spr_[_sID].numbers.push(_rndFireNum);\r\n            \r\n            spr_[_opID].win = spr_[_opID].win.add(_value);\r\n            \r\n            emit onCheckHitNumber(_rndFireNum, _opID, spr_[_sID].addr, _rID, block.timestamp);\r\n    \r\n        }else{\r\n            round_[_rID].mpot = round_[_rID].mpot.add(((_value / 2) / 100).mul(90));\r\n            round_[_rID].lpot = round_[_rID].lpot.add(((_value / 2) / 100).mul(5));\r\n            round_[_rID].apot = round_[_rID].apot.add(((_value / 2) / 100).mul(5));\r\n\r\n            globalArr_.push(_rndFireNum);\r\n            globalArr_.heapSort();\r\n            (_found, _index) = globalArr_.indexOf(_rndFireNum, true);\r\n\r\n            if(_index == 0){\r\n                _opID = sidXnum_[globalArr_[_index + 1]];\r\n                \r\n                spr_[_opID].win = spr_[_opID].win.add(((_value / 2) / 100).mul(50));\r\n            \r\n                \r\n                spr_[_sID].snums++;\r\n                spr_[_sID].numbers.push(_rndFireNum);\r\n                spr_[_sID].gen = spr_[_sID].gen.add(((_value / 2) / 100).mul(50));\r\n                \r\n                sidXnum_[_rndFireNum] = _sID;\r\n                \r\n            }else if(_index == globalArr_.length - 1){\r\n                _opID = sidXnum_[globalArr_[_index -1]];\r\n                \r\n                spr_[_opID].win = spr_[_opID].win.add(((_value / 2) / 100).mul(50));\r\n                \r\n                spr_[_sID].snums++;\r\n                spr_[_sID].numbers.push(_rndFireNum);\r\n                spr_[_sID].gen = spr_[_sID].gen.add(((_value / 2) / 100).mul(50));\r\n                \r\n                sidXnum_[_rndFireNum] = _sID;\r\n                \r\n            }else{\r\n                uint256 _leftSID = sidXnum_[globalArr_[_index - 1]];\r\n                uint256 _rightSID = sidXnum_[globalArr_[_index + 1]];\r\n                \r\n                spr_[_leftSID].win = spr_[_leftSID].win.add(((_value / 2) / 100).mul(50));\r\n                spr_[_rightSID].win = spr_[_rightSID].win.add(((_value / 2) / 100).mul(50));\r\n                \r\n                spr_[_sID].snums++;\r\n                spr_[_sID].numbers.push(_rndFireNum);\r\n                \r\n                \r\n                sidXnum_[_rndFireNum] = _sID;\r\n            }\r\n            \r\n            \r\n                \r\n        }\r\n        \r\n        totalSum_ = totalSum_.add(_rndFireNum);\r\n    }\r\n\r\n    function globalArrEqualOne(uint256 _rID, uint256 _sID, uint256 _value, uint256 _rndFireNum)\r\n        private\r\n    {\r\n        uint256 _opID = sidXnum_[globalArr_[0]];\r\n        bool _found = false;\r\n        uint256 _index = 0;\r\n        if(globalArr_[0] != _rndFireNum)\r\n        {\r\n            \r\n            round_[_rID].mpot = round_[_rID].mpot.add(((_value / 2) / 100).mul(90));\r\n            round_[_rID].lpot = round_[_rID].lpot.add(((_value / 2) / 100).mul(5));\r\n            round_[_rID].apot = round_[_rID].apot.add(((_value / 2) / 100).mul(5));\r\n            \r\n            sidXnum_[_rndFireNum] = _sID;\r\n            \r\n            spr_[_opID].win = spr_[_opID].win.add((_value / 4));\r\n            \r\n            spr_[_sID].snums++;\r\n            spr_[_sID].numbers.push(_rndFireNum);\r\n            spr_[_sID].gen = spr_[_sID].gen.add((_value / 4));\r\n    \r\n            globalArr_.push(_rndFireNum);\r\n        }else{\r\n            spr_[_opID].win = spr_[_opID].win.add(_value);\r\n            \r\n            (_found, _index) = spr_[_opID].numbers.indexOf(_rndFireNum, false);\r\n        \r\n            itemRemove(spr_[_opID].numbers, _index);\r\n\r\n            sidXnum_[_rndFireNum] = _sID;\r\n            \r\n            spr_[_opID].snums--;\r\n\r\n            spr_[_sID].snums++;\r\n            spr_[_sID].numbers.push(_rndFireNum);\r\n            \r\n            emit onCheckHitNumber(_rndFireNum, _opID, spr_[_sID].addr, _rID, block.timestamp);\r\n            \r\n        }\r\n        \r\n        totalSum_ = totalSum_.add(_rndFireNum);\r\n    }\r\n    \r\n    function checkLuckyPot(uint256 _rndFireNum) private returns(uint256){\r\n        delete luckyPotBingoArr_;\r\n        uint256 number = _rndFireNum;\r\n        uint returnNum = number;\r\n        while (number > 0) {\r\n            uint256 digit = uint8(number % 10); \r\n            number = number / 10;\r\n \r\n            luckyPotBingoArr_.push(digit);\r\n        }\r\n\r\n        return returnNum;\r\n    }\r\n    \r\n    function checkAirdropPot(uint256 _rndFireNum) private returns(uint256){\r\n        delete airdropPotBingoArr_;\r\n        uint256 number = _rndFireNum;\r\n        uint returnNum = number;\r\n        while (number > 0) {\r\n            uint256 digit = uint8(number % 10); \r\n            number = number / 10;\r\n\r\n            airdropPotBingoArr_.push(digit);\r\n        }\r\n\r\n        return returnNum;\r\n    }\r\n    \r\n    function getDigit(uint256 x) private view returns (uint256) {\r\n        return luckyPotBingoArr_[x];\r\n    }\r\n    \r\n\r\n    function calcBingoLuckyPot(uint256 _rndFireNum)\r\n        private\r\n        returns(bool)\r\n    {\r\n        \r\n        bool _isBingoLucky = false;\r\n        checkLuckyPot(_rndFireNum);\r\n        uint256 _flag;\r\n\r\n        if(luckyPotBingoArr_.length > 1) {\r\n            for(uint256 i = 0; i < luckyPotBingoArr_.length; i++){\r\n                if(luckyPotBingoArr_[0] == getDigit(i)){\r\n                    _flag++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(_flag == luckyPotBingoArr_.length && _flag != 0 && luckyPotBingoArr_.length != 0){\r\n            _isBingoLucky = true;\r\n        }\r\n\r\n        return(_isBingoLucky);\r\n    }\r\n\r\n    function calcBingoAirdropPot(uint256 _rndFireNum) private returns(bool) {\r\n        bool _isBingoAirdrop = false;\r\n        checkAirdropPot(_rndFireNum);\r\n        uint256 _temp;\r\n        \r\n        if(airdropPotBingoArr_.length > 1) {\r\n            \r\n            airdropPotBingoArr_.heapSort();\r\n            \r\n            _temp = airdropPotBingoArr_[0];\r\n            \r\n            for(uint256 i = 0; i < airdropPotBingoArr_.length; i++){\r\n                if(i == 0 || airdropPotBingoArr_[i] == _temp.add(i)){         \r\n                    _isBingoAirdrop = true;\r\n                }else{\r\n                    _isBingoAirdrop = false;\r\n                    break;\r\n                }\r\n                \r\n            }\r\n        }\r\n\r\n        return(_isBingoAirdrop);\r\n    }\r\n\r\n    function checkWinMainPot(uint256 _rID, uint256 _sID, uint256 _rndFireNum) private {\r\n        if(totalSum_ == maxNumber_){\r\n            \r\n            isDrawed_ = true;\r\n            \r\n            totalSum_ = 0;\r\n\r\n            spr_[_sID].snums = 0;\r\n            delete spr_[_sID].numbers;\r\n            \r\n            // winer 48%\r\n            // next round 20%\r\n            // ico 20%\r\n            // marketing 1%\r\n            // donate 1%\r\n            // team 10%\r\n            \r\n            uint256 _nextMpot;\r\n            uint256 _nextLpot = round_[_rID].lpot;\r\n            uint256 _nextApot = round_[_rID].apot;\r\n            uint256 _icoEndTime = round_[_rID].icoend;\r\n   \r\n            //If no one is involved in the ICO, 20% of the ICO will be allocated, 10% of which will be allocated to the community and 10% to the next round.\r\n            \r\n            uint256 _communityRewards;\r\n            \r\n            if(icoAmount_ > 0){\r\n                //next round 20%\r\n                _nextMpot = (round_[_rID].mpot / 100).mul(20);\r\n                // team 10%\r\n                _communityRewards = (round_[_rID].mpot / 100).mul(10);\r\n            }else{\r\n                //next round 30%\r\n                _nextMpot = (round_[_rID].mpot / 100).mul(30);\r\n                // team 20%\r\n                _communityRewards = (round_[_rID].mpot / 100).mul(20);\r\n            }\r\n            \r\n            if(_communityRewards > 0)\r\n                comReward_.transfer(_communityRewards);\r\n            \r\n            spr_[_sID].win = spr_[_sID].win.add((round_[rID_].mpot / 100).mul(48));\r\n            \r\n            //marketing 1% & donate 1%\r\n            uint256 _communityMarket = (round_[_rID].mpot / 100).mul(1);\r\n            if(_communityMarket > 0){\r\n                comMarket_.transfer(_communityMarket);\r\n                donateAccount_.transfer(_communityMarket);\r\n            }\r\n            \r\n            \r\n            emit onCheckMainpot(_rndFireNum, _rID, spr_[_sID].addr, block.timestamp);\r\n            \r\n            //ico 20%\r\n            if(icoAmount_ > 0){\r\n                uint256 _icoValue = (round_[_rID].mpot / 100).mul(20);\r\n                distributeICO(_icoValue);\r\n            }\r\n            \r\n            round_[rID_].mpot = 0;\r\n            round_[rID_].lpot = 0;\r\n            round_[rID_].apot = 0;\r\n            \r\n            rID_++;\r\n\r\n            round_[rID_].strt = now;\r\n            round_[rID_].mpot = _nextMpot;\r\n            round_[rID_].lpot = _nextLpot;\r\n            round_[rID_].apot = _nextApot;\r\n            round_[rID_].icoend = _icoEndTime;\r\n            \r\n        }else{\r\n\r\n            if(totalSum_ > maxNumber_){\r\n                uint256 _overNum = totalSum_.sub(maxNumber_);\r\n                totalSum_ = maxNumber_.sub(_overNum);\r\n            }\r\n            \r\n        }\r\n    }\r\n\r\n    function distributeICO(uint256 _icoValue)\r\n        private\r\n    {\r\n        for(uint256 i = 0; i < icoSidArr_.length; i++){\r\n\r\n            uint256 _ps = percent(spr_[icoSidArr_[i]].icoAmt, icoAmount_, 4);\r\n            uint256 _rs = _ps.mul(_icoValue) / 10000;\r\n            spr_[icoSidArr_[i]].gems = spr_[icoSidArr_[i]].gems.add(_rs);\r\n        }\r\n    }\r\n    \r\n    function percent(uint256 numerator, uint256 denominator, uint256 precision) private pure returns(uint256 quotient) {\r\n\r\n         // caution, check safe-to-multiply here\r\n        uint256 _numerator  = numerator * 10 ** (precision+1);\r\n        // with rounding of last digit\r\n        uint256 _quotient =  ((_numerator / denominator) + 5) / 10;\r\n        return ( _quotient);\r\n   }\r\n\r\n\r\n    /**\r\n     * @dev gets existing or registers new sID.  use this when a sniper may be new\r\n     * @return sID \r\n     */\r\n    function determineSID()\r\n        private\r\n    {\r\n        uint256 _sID = sIDxAddr_[msg.sender];\r\n        // if sniper is new to this version of H1M\r\n        if (_sID == 0)\r\n        {\r\n            // grab their sniper ID, name and last aff ID, from sniper names contract \r\n            _sID = SniperBook.getSniperID(msg.sender);\r\n            lastSID_ = _sID;\r\n            bytes32 _name = SniperBook.getSniperName(_sID);\r\n            uint256 _laff = SniperBook.getSniperLAff(_sID);\r\n            \r\n            // set up sniper account \r\n            sIDxAddr_[msg.sender] = _sID;\r\n            spr_[_sID].addr = msg.sender;\r\n            \r\n            if (_name != \"\")\r\n            {\r\n                sIDxName_[_name] = _sID;\r\n                spr_[_sID].name = _name;\r\n                sprNames_[_sID][_name] = true;\r\n            }\r\n            \r\n            if (_laff != 0 && _laff != _sID)\r\n                spr_[_sID].laff = _laff;\r\n            \r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     *  for UI\r\n     */\r\n     \r\n    function getTotalSum()\r\n        public\r\n        isHuman()\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return(totalSum_);\r\n    }\r\n    \r\n    function getCurrentRoundInfo()\r\n        public\r\n        isHuman()\r\n        view\r\n        returns(uint256, uint256, uint256, uint256, uint256, uint256[] memory)\r\n    {\r\n        \r\n        return(rID_, totalSum_, round_[rID_].lpot, round_[rID_].mpot, round_[rID_].apot, globalArr_);\r\n    }\r\n    \r\n    function getSniperInfo(address _addr)\r\n        public\r\n        isHuman()\r\n        view\r\n        returns(uint256[] memory, uint256, uint256, uint256, uint256,  uint256)\r\n    {\r\n        \r\n        return(spr_[sIDxAddr_[_addr]].numbers, spr_[sIDxAddr_[_addr]].aff, spr_[sIDxAddr_[_addr]].win, spr_[sIDxAddr_[_addr]].gems, spr_[sIDxAddr_[_addr]].gen, spr_[sIDxAddr_[_addr]].icoAmt);\r\n    }\r\n    \r\n    function getSID(address _addr)\r\n        public\r\n        isHuman()\r\n        view\r\n        returns(uint256)\r\n    {\r\n        \r\n        return(sIDxAddr_[_addr]);\r\n    }\r\n    \r\n    function getGameTime()\r\n        public\r\n        isHuman()\r\n        view\r\n        returns(uint256, uint256, bool)\r\n    {\r\n        bool _icoOff = false;\r\n        if(now > round_[1].icoend && activated_){\r\n            _icoOff = true;\r\n        }\r\n        return(round_[1].icoend, icoAmount_, _icoOff);\r\n    }\r\n\r\n    /** upon contract deploy, it will be deactivated.  this is a one time\r\n     * use function that will activate the contract.  we do this so devs \r\n     * have time to set things up on the web end                            **/\r\n    bool public activated_ = false;\r\n    function activate()\r\n        public\r\n    {\r\n        // only luckyteam can activate \r\n        require(\r\n            msg.sender == 0x461f346C3B3D401A5f9Fef44bAB704e96abC926F ||\r\n            msg.sender == 0x727fE77FFDf8D40F34f641DfB358d9856F9563cA ||\r\n            msg.sender == 0x3b300189AfA703372022Ca97C64FaA27AdA05238 ||\r\n            msg.sender == 0x4b95DE2f5E202b59B22a0EcCf6A7C2aa5578Ee4D ||\r\n\t\t\tmsg.sender == 0x9f01209Fb1FA757cF6025C2aBf17b847408deDE5,\r\n            \"only luckyteam can activate\"\r\n        );\r\n        \r\n        // make sure comReward its been linked.\r\n        require(address(comReward_) != address(0), \"must link to comReward address\");\r\n        \r\n        // make sure comMarket its been linked.\r\n        require(address(comMarket_) != address(0), \"must link to comMarket address\");\r\n\r\n        // make sure comICO its been linked.\r\n        require(address(comICO_) != address(0), \"must link to comICO address\");\r\n        \r\n        // make sure donateAccount its been linked.\r\n        require(address(donateAccount_) != address(0), \"must link to donateAccount address\");\r\n        \r\n        // can only be ran once\r\n        require(activated_ == false, \"H1M already activated\");\r\n        \r\n        // activate the contract \r\n        activated_ = true;\r\n        \r\n        // lets start first round\r\n\t\trID_ = 1;\r\n        round_[1].strt = now;\r\n        round_[1].icostrt = now;\r\n        round_[1].icoend = now + icoEndTime_;\r\n    }\r\n    \r\n    function receiveSniperInfo(uint256 _sID, address _addr, bytes32 _name, uint256 _laff)\r\n        external\r\n    {\r\n        require (msg.sender == address(SniperBook), \"your not playerNames contract... hmmm..\");\r\n        if (sIDxAddr_[_addr] != _sID)\r\n            sIDxAddr_[_addr] = _sID;\r\n        if (sIDxName_[_name] != _sID)\r\n            sIDxName_[_name] = _sID;\r\n        if (spr_[_sID].addr != _addr)\r\n            spr_[_sID].addr = _addr;\r\n        if (spr_[_sID].name != _name)\r\n            spr_[_sID].name = _name;\r\n        if (spr_[_sID].laff != _laff)\r\n            spr_[_sID].laff = _laff;\r\n        if (sprNames_[_sID][_name] == false)\r\n            sprNames_[_sID][_name] = true;\r\n    }\r\n    \r\n    /**\r\n     * @dev receives entire player name list \r\n     */\r\n    function receiveSniperNameList(uint256 _sID, bytes32 _name)\r\n        external\r\n    {\r\n        require (msg.sender == address(SniperBook), \"your not playerNames contract... hmmm..\");\r\n        if(sprNames_[_sID][_name] == false)\r\n            sprNames_[_sID][_name] = true;\r\n    }   \r\n\r\n}\r\n\r\nlibrary SPBdatasets {\r\n    \r\n    struct Round {\r\n        uint256 strt;    // time round started\r\n        uint256 icostrt; // time ico started\r\n        uint256 icoend;  // time ico ended;\r\n        uint256 ltime;   // last buy time.\r\n        uint256 apot;    // airdrop pot;\r\n        uint256 lpot;    // lucky pot;\r\n        uint256 mpot;    // main pot paid to winner\r\n    }\r\n    \r\n    struct Sniper {\r\n        address addr;   // player address\r\n        bytes32 name;   // player name\r\n        uint256 win;    // winnings vault\r\n        uint256 gen;    // general vault\r\n        uint256 aff;    // affiliate vault\r\n        uint256 lplyt;  // last played time\r\n        uint256 laff;   // last affiliate id used\r\n        uint256 snums;\r\n        uint256 icoAmt; // sniper ico amount\r\n        uint256 gems;\r\n        uint256[] numbers; //\r\n    }\r\n}\r\n\r\n\r\ninterface RubyFundForwarderInterface {\r\n    function deposit() external payable returns(bool);\r\n    function status() external view returns(address, address, bool);\r\n    function startMigration(address _newCorpBank) external returns(bool);\r\n    function cancelMigration() external returns(bool);\r\n    function finishMigration() external returns(bool);\r\n    function setup(address _firstCorpBank) external;\r\n}\r\n\r\ninterface SniperBookInterface {\r\n    function getSniperID(address _addr) external returns (uint256);\r\n    function getSniperName(uint256 _sID) external view returns (bytes32);\r\n    function getSniperLAff(uint256 _sID) external view returns (uint256);\r\n    function getSniperAddr(uint256 _sID) external view returns (address);\r\n    function getNameFee() external view returns (uint256);\r\n    function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256);\r\n    function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256);\r\n}\r\n\r\n/**\r\n * @title SafeMath v0.1.9\r\n * @dev Math operations with safety checks that throw on error\r\n * change notes:  original SafeMath library from OpenZeppelin modified by Inventor\r\n * - added sqrt\r\n * - added sq\r\n * - added pwr \r\n * - changed asserts to requires with error log outputs\r\n * - removed div, its useless\r\n */\r\nlibrary SafeMath {\r\n    \r\n    /**\r\n    * @dev Multiplies two numbers, throws on overflow.\r\n    */\r\n    function mul(uint256 a, uint256 b) \r\n        internal \r\n        pure \r\n        returns (uint256 c) \r\n    {\r\n        if (a == 0) {\r\n            return 0;\r\n        }\r\n        c = a * b;\r\n        require(c / a == b, \"SafeMath mul failed\");\r\n        return c;\r\n    }\r\n\r\n    /**\r\n    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n    */\r\n    function sub(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256) \r\n    {\r\n        require(b <= a, \"SafeMath sub failed\");\r\n        return a - b;\r\n    }\r\n\r\n    /**\r\n    * @dev Adds two numbers, throws on overflow.\r\n    */\r\n    function add(uint256 a, uint256 b)\r\n        internal\r\n        pure\r\n        returns (uint256 c) \r\n    {\r\n        c = a + b;\r\n        require(c >= a, \"SafeMath add failed\");\r\n        return c;\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square root of given x.\r\n     */\r\n    function sqrt(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256 y) \r\n    {\r\n        uint256 z = ((add(x,1)) / 2);\r\n        y = x;\r\n        while (z < y) \r\n        {\r\n            y = z;\r\n            z = ((add((x / z),z)) / 2);\r\n        }\r\n    }\r\n    \r\n    /**\r\n     * @dev gives square. multiplies x by x\r\n     */\r\n    function sq(uint256 x)\r\n        internal\r\n        pure\r\n        returns (uint256)\r\n    {\r\n        return (mul(x,x));\r\n    }\r\n    \r\n    /**\r\n     * @dev x to the power of y \r\n     */\r\n    function pwr(uint256 x, uint256 y)\r\n        internal \r\n        pure \r\n        returns (uint256)\r\n    {\r\n        if (x==0)\r\n            return (0);\r\n        else if (y==0)\r\n            return (1);\r\n        else \r\n        {\r\n            uint256 z = x;\r\n            for (uint256 i=1; i < y; i++)\r\n                z = mul(z,x);\r\n            return (z);\r\n        }\r\n    }\r\n}\r\n\r\nlibrary Array256Lib {\r\n\r\n  /// @dev Sum vector\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return sum The sum of all elements, does not check for overflow\r\n  function sumElements(uint256[] storage self) public view returns(uint256 sum) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        sum := add(sload(add(sha3(0x60,0x20),i)),sum)\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the max value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return maxValue The highest value in the array\r\n  function getMax(uint256[] storage self) public view returns(uint256 maxValue) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      maxValue := sload(sha3(0x60,0x20))\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        switch gt(sload(add(sha3(0x60,0x20),i)), maxValue)\r\n        case 1 {\r\n          maxValue := sload(add(sha3(0x60,0x20),i))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Returns the minimum value in an array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @return minValue The highest value in the array\r\n  function getMin(uint256[] storage self) public view returns(uint256 minValue) {\r\n    assembly {\r\n      mstore(0x60,self_slot)\r\n      minValue := sload(sha3(0x60,0x20))\r\n\r\n      for { let i := 0 } lt(i, sload(self_slot)) { i := add(i, 1) } {\r\n        switch gt(sload(add(sha3(0x60,0x20),i)), minValue)\r\n        case 0 {\r\n          minValue := sload(add(sha3(0x60,0x20),i))\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Finds the index of a given value in an array\r\n  /// @param self Storage array containing uint256 type variables\r\n  /// @param value The value to search for\r\n  /// @param isSorted True if the array is sorted, false otherwise\r\n  /// @return found True if the value was found, false otherwise\r\n  /// @return index The index of the given value, returns 0 if found is false\r\n  function indexOf(uint256[] storage self, uint256 value, bool isSorted)\r\n           public\r\n           view\r\n           returns(bool found, uint256 index) {\r\n    assembly{\r\n      mstore(0x60,self_slot)\r\n      switch isSorted\r\n      case 1 {\r\n        let high := sub(sload(self_slot),1)\r\n        let mid := 0\r\n        let low := 0\r\n        for { } iszero(gt(low, high)) { } {\r\n          mid := div(add(low,high),2)\r\n\r\n          switch lt(sload(add(sha3(0x60,0x20),mid)),value)\r\n          case 1 {\r\n             low := add(mid,1)\r\n          }\r\n          case 0 {\r\n            switch gt(sload(add(sha3(0x60,0x20),mid)),value)\r\n            case 1 {\r\n              high := sub(mid,1)\r\n            }\r\n            case 0 {\r\n              found := 1\r\n              index := mid\r\n              low := add(high,1)\r\n            }\r\n          }\r\n        }\r\n      }\r\n      case 0 {\r\n        for { let low := 0 } lt(low, sload(self_slot)) { low := add(low, 1) } {\r\n          switch eq(sload(add(sha3(0x60,0x20),low)), value)\r\n          case 1 {\r\n            found := 1\r\n            index := low\r\n            low := sload(self_slot)\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of child node\r\n  /// @return pI The parent node index\r\n  function getParentI(uint256 index) private pure returns (uint256 pI) {\r\n    uint256 i = index - 1;\r\n    pI = i/2;\r\n  }\r\n\r\n  /// @dev Utility function for heapSort\r\n  /// @param index The index of parent node\r\n  /// @return lcI The index of left child\r\n  function getLeftChildI(uint256 index) private pure returns (uint256 lcI) {\r\n    uint256 i = index * 2;\r\n    lcI = i + 1;\r\n  }\r\n\r\n  /// @dev Sorts given array in place\r\n  /// @param self Storage array containing uint256 type variables\r\n  function heapSort(uint256[] storage self) public {\r\n    uint256 end = self.length - 1;\r\n    uint256 start = getParentI(end);\r\n    uint256 root = start;\r\n    uint256 lChild;\r\n    uint256 rChild;\r\n    uint256 swap;\r\n    uint256 temp;\r\n    while(start >= 0){\r\n      root = start;\r\n      lChild = getLeftChildI(start);\r\n      while(lChild <= end){\r\n        rChild = lChild + 1;\r\n        swap = root;\r\n        if(self[swap] < self[lChild])\r\n          swap = lChild;\r\n        if((rChild <= end) && (self[swap]<self[rChild]))\r\n          swap = rChild;\r\n        if(swap == root)\r\n          lChild = end+1;\r\n        else {\r\n          temp = self[swap];\r\n          self[swap] = self[root];\r\n          self[root] = temp;\r\n          root = swap;\r\n          lChild = getLeftChildI(root);\r\n        }\r\n      }\r\n      if(start == 0)\r\n        break;\r\n      else\r\n        start = start - 1;\r\n    }\r\n    while(end > 0){\r\n      temp = self[end];\r\n      self[end] = self[0];\r\n      self[0] = temp;\r\n      end = end - 1;\r\n      root = 0;\r\n      lChild = getLeftChildI(0);\r\n      while(lChild <= end){\r\n        rChild = lChild + 1;\r\n        swap = root;\r\n        if(self[swap] < self[lChild])\r\n          swap = lChild;\r\n        if((rChild <= end) && (self[swap]<self[rChild]))\r\n          swap = rChild;\r\n        if(swap == root)\r\n          lChild = end + 1;\r\n        else {\r\n          temp = self[swap];\r\n          self[swap] = self[root];\r\n          self[root] = temp;\r\n          root = swap;\r\n          lChild = getLeftChildI(root);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /// @dev Removes duplicates from a given array.\r\n  /// @param self Storage array containing uint256 type variables\r\n  function uniq(uint256[] storage self) public returns (uint256 length) {\r\n    bool contains;\r\n    uint256 index;\r\n\r\n    for (uint256 i = 0; i < self.length; i++) {\r\n      (contains, index) = indexOf(self, self[i], false);\r\n\r\n      if (i > index) {\r\n        for (uint256 j = i; j < self.length - 1; j++){\r\n          self[j] = self[j + 1];\r\n        }\r\n\r\n        delete self[self.length - 1];\r\n        self.length--;\r\n        i--;\r\n      }\r\n    }\r\n\r\n    length = self.length;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"getTotalSum\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"name\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"activate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"icoAmount_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getSID\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"round_\",\"outputs\":[{\"name\":\"strt\",\"type\":\"uint256\"},{\"name\":\"icostrt\",\"type\":\"uint256\"},{\"name\":\"icoend\",\"type\":\"uint256\"},{\"name\":\"ltime\",\"type\":\"uint256\"},{\"name\":\"apot\",\"type\":\"uint256\"},{\"name\":\"lpot\",\"type\":\"uint256\"},{\"name\":\"mpot\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"sIDxName_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sID\",\"type\":\"uint256\"},{\"name\":\"_name\",\"type\":\"bytes32\"}],\"name\":\"receiveSniperNameList\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"spr_\",\"outputs\":[{\"name\":\"addr\",\"type\":\"address\"},{\"name\":\"name\",\"type\":\"bytes32\"},{\"name\":\"win\",\"type\":\"uint256\"},{\"name\":\"gen\",\"type\":\"uint256\"},{\"name\":\"aff\",\"type\":\"uint256\"},{\"name\":\"lplyt\",\"type\":\"uint256\"},{\"name\":\"laff\",\"type\":\"uint256\"},{\"name\":\"snums\",\"type\":\"uint256\"},{\"name\":\"icoAmt\",\"type\":\"uint256\"},{\"name\":\"gems\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rID_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getCurrentRoundInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256[]\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"becomeSniperAngel\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"sprNames_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"symbol\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"sidXnum_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"getGameTime\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_affCode\",\"type\":\"address\"}],\"name\":\"buyXaddr\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"activated_\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_sID\",\"type\":\"uint256\"},{\"name\":\"_addr\",\"type\":\"address\"},{\"name\":\"_name\",\"type\":\"bytes32\"},{\"name\":\"_laff\",\"type\":\"uint256\"}],\"name\":\"receiveSniperInfo\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"sIDxAddr_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_addr\",\"type\":\"address\"}],\"name\":\"getSniperInfo\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256[]\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalSum_\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"sniperID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"sniperAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"ethOut\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onWithdraw\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"affiliateID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"buyerID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onAffiliatePayout\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sniperAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onCheckMainpot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sniperAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onCheckLuckypot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"sniperAddress\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onCheckKingpot\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"randomNumber\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"beingHitSniperID\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"firedSniperAddress\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"roundID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onCheckHitNumber\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"sniperID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"ethIn\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"number\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"laffID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onEndTx\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"whoInvest\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onICOAngel\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"amount\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"timeStamp\",\"type\":\"uint256\"}],\"name\":\"onOEZDay\",\"type\":\"event\"}]","ContractName":"SniperBillion","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"Array256Lib:09b7b04d6f7083ad913f8bfc88314aeee301f708","SwarmSource":"bzzr://e14770bc70f70bb196dfa6dacf19f2abfe1875efa329a0e0f6e53cd4abc42183"}]}