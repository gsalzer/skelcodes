{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.24;\r\n\r\ncontract Enum {\r\n    enum Operation {\r\n        Call,\r\n        DelegateCall,\r\n        Create\r\n    }\r\n}\r\n\r\ncontract EtherPaymentFallback {\r\n\r\n    /// @dev Fallback function accepts Ether transactions.\r\n    function ()\r\n        external\r\n        payable\r\n    {\r\n\r\n    }\r\n}\r\n\r\ncontract Executor is EtherPaymentFallback {\r\n\r\n    event ContractCreation(address newContract);\r\n\r\n    function execute(address to, uint256 value, bytes data, Enum.Operation operation, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        if (operation == Enum.Operation.Call)\r\n            success = executeCall(to, value, data, txGas);\r\n        else if (operation == Enum.Operation.DelegateCall)\r\n            success = executeDelegateCall(to, data, txGas);\r\n        else {\r\n            address newContract = executeCreate(data);\r\n            success = newContract != 0;\r\n            emit ContractCreation(newContract);\r\n        }\r\n    }\r\n\r\n    function executeCall(address to, uint256 value, bytes data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := call(txGas, to, value, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeDelegateCall(address to, bytes data, uint256 txGas)\r\n        internal\r\n        returns (bool success)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            success := delegatecall(txGas, to, add(data, 0x20), mload(data), 0, 0)\r\n        }\r\n    }\r\n\r\n    function executeCreate(bytes data)\r\n        internal\r\n        returns (address newContract)\r\n    {\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            newContract := create(0, add(data, 0x20), mload(data))\r\n        }\r\n    }\r\n}\r\n\r\ncontract SelfAuthorized {\r\n    modifier authorized() {\r\n        require(msg.sender == address(this), \"Method can only be called from this contract\");\r\n        _;\r\n    }\r\n}\r\n\r\ncontract ModuleManager is SelfAuthorized, Executor {\r\n\r\n    event EnabledModule(Module module);\r\n    event DisabledModule(Module module);\r\n\r\n    address public constant SENTINEL_MODULES = address(0x1);\r\n\r\n    mapping (address => address) internal modules;\r\n    \r\n    function setupModules(address to, bytes data)\r\n        internal\r\n    {\r\n        require(modules[SENTINEL_MODULES] == 0, \"Modules have already been initialized\");\r\n        modules[SENTINEL_MODULES] = SENTINEL_MODULES;\r\n        if (to != 0)\r\n            // Setup has to complete successfully or transaction fails.\r\n            require(executeDelegateCall(to, data, gasleft()), \"Could not finish initialization\");\r\n    }\r\n\r\n    /// @dev Allows to add a module to the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param module Module to be whitelisted.\r\n    function enableModule(Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Module address cannot be null or sentinel.\r\n        require(address(module) != 0 && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        // Module cannot be added twice.\r\n        require(modules[module] == 0, \"Module has already been added\");\r\n        modules[module] = modules[SENTINEL_MODULES];\r\n        modules[SENTINEL_MODULES] = module;\r\n        emit EnabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows to remove a module from the whitelist.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevModule Module that pointed to the module to be removed in the linked list\r\n    /// @param module Module to be removed.\r\n    function disableModule(Module prevModule, Module module)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate module address and check that it corresponds to module index.\r\n        require(address(module) != 0 && address(module) != SENTINEL_MODULES, \"Invalid module address provided\");\r\n        require(modules[prevModule] == address(module), \"Invalid prevModule, module pair provided\");\r\n        modules[prevModule] = modules[module];\r\n        modules[module] = 0;\r\n        emit DisabledModule(module);\r\n    }\r\n\r\n    /// @dev Allows a Module to execute a Safe transaction without any further confirmations.\r\n    /// @param to Destination address of module transaction.\r\n    /// @param value Ether value of module transaction.\r\n    /// @param data Data payload of module transaction.\r\n    /// @param operation Operation type of module transaction.\r\n    function execTransactionFromModule(address to, uint256 value, bytes data, Enum.Operation operation)\r\n        public\r\n        returns (bool success)\r\n    {\r\n        // Only whitelisted modules are allowed.\r\n        require(modules[msg.sender] != 0, \"Method can only be called from an enabled module\");\r\n        // Execute transaction without further confirmations.\r\n        success = execute(to, value, data, operation, gasleft());\r\n    }\r\n\r\n    /// @dev Returns array of modules.\r\n    /// @return Array of modules.\r\n    function getModules()\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        // Calculate module count\r\n        uint256 moduleCount = 0;\r\n        address currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        address[] memory array = new address[](moduleCount);\r\n\r\n        // populate return array\r\n        moduleCount = 0;\r\n        currentModule = modules[SENTINEL_MODULES];\r\n        while(currentModule != SENTINEL_MODULES) {\r\n            array[moduleCount] = currentModule;\r\n            currentModule = modules[currentModule];\r\n            moduleCount ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\ncontract OwnerManager is SelfAuthorized {\r\n\r\n    event AddedOwner(address owner);\r\n    event RemovedOwner(address owner);\r\n    event ChangedThreshold(uint256 threshold);\r\n\r\n    address public constant SENTINEL_OWNERS = address(0x1);\r\n\r\n    mapping(address => address) internal owners;\r\n    uint256 ownerCount;\r\n    uint256 internal threshold;\r\n\r\n    /// @dev Setup function sets initial storage of contract.\r\n    /// @param _owners List of Safe owners.\r\n    /// @param _threshold Number of required confirmations for a Safe transaction.\r\n    function setupOwners(address[] _owners, uint256 _threshold)\r\n        internal\r\n    {\r\n        // Threshold can only be 0 at initialization.\r\n        // Check ensures that setup function can only be called once.\r\n        require(threshold == 0, \"Owners have already been setup\");\r\n        // Validate that threshold is smaller than number of added owners.\r\n        require(_threshold <= _owners.length, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        // Initializing Safe owners.\r\n        address currentOwner = SENTINEL_OWNERS;\r\n        for (uint256 i = 0; i < _owners.length; i++) {\r\n            // Owner address cannot be null.\r\n            address owner = _owners[i];\r\n            require(owner != 0 && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n            // No duplicate owners allowed.\r\n            require(owners[owner] == 0, \"Duplicate owner address provided\");\r\n            owners[currentOwner] = owner;\r\n            currentOwner = owner;\r\n        }\r\n        owners[currentOwner] = SENTINEL_OWNERS;\r\n        ownerCount = _owners.length;\r\n        threshold = _threshold;\r\n    }\r\n\r\n    /// @dev Allows to add a new owner to the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param owner New owner address.\r\n    /// @param _threshold New threshold.\r\n    function addOwnerWithThreshold(address owner, uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(owner != 0 && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[owner] == 0, \"Address is already an owner\");\r\n        owners[owner] = owners[SENTINEL_OWNERS];\r\n        owners[SENTINEL_OWNERS] = owner;\r\n        ownerCount++;\r\n        emit AddedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to remove an owner from the Safe and update the threshold at the same time.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be removed in the linked list\r\n    /// @param owner Owner address to be removed.\r\n    /// @param _threshold New threshold.\r\n    function removeOwner(address prevOwner, address owner, uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Only allow to remove an owner, if threshold can still be reached.\r\n        require(ownerCount - 1 >= _threshold, \"New owner count needs to be larger than new threshold\");\r\n        // Validate owner address and check that it corresponds to owner index.\r\n        require(owner != 0 && owner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == owner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[prevOwner] = owners[owner];\r\n        owners[owner] = 0;\r\n        ownerCount--;\r\n        emit RemovedOwner(owner);\r\n        // Change threshold if threshold was changed.\r\n        if (threshold != _threshold)\r\n            changeThreshold(_threshold);\r\n    }\r\n\r\n    /// @dev Allows to swap/replace an owner from the Safe with another address.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param prevOwner Owner that pointed to the owner to be replaced in the linked list\r\n    /// @param oldOwner Owner address to be replaced.\r\n    /// @param newOwner New owner address.\r\n    function swapOwner(address prevOwner, address oldOwner, address newOwner)\r\n        public\r\n        authorized\r\n    {\r\n        // Owner address cannot be null.\r\n        require(newOwner != 0 && newOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        // No duplicate owners allowed.\r\n        require(owners[newOwner] == 0, \"Address is already an owner\");\r\n        // Validate oldOwner address and check that it corresponds to owner index.\r\n        require(oldOwner != 0 && oldOwner != SENTINEL_OWNERS, \"Invalid owner address provided\");\r\n        require(owners[prevOwner] == oldOwner, \"Invalid prevOwner, owner pair provided\");\r\n        owners[newOwner] = owners[oldOwner];\r\n        owners[prevOwner] = newOwner;\r\n        owners[oldOwner] = 0;\r\n        emit RemovedOwner(oldOwner);\r\n        emit AddedOwner(newOwner);\r\n    }\r\n\r\n    /// @dev Allows to update the number of required confirmations by Safe owners.\r\n    ///      This can only be done via a Safe transaction.\r\n    /// @param _threshold New threshold.\r\n    function changeThreshold(uint256 _threshold)\r\n        public\r\n        authorized\r\n    {\r\n        // Validate that threshold is smaller than number of owners.\r\n        require(_threshold <= ownerCount, \"Threshold cannot exceed owner count\");\r\n        // There has to be at least one Safe owner.\r\n        require(_threshold >= 1, \"Threshold needs to be greater than 0\");\r\n        threshold = _threshold;\r\n        emit ChangedThreshold(threshold);\r\n    }\r\n\r\n    function getThreshold()\r\n        public\r\n        view\r\n        returns (uint256)\r\n    {\r\n        return threshold;\r\n    }\r\n\r\n    function isOwner(address owner)\r\n        public\r\n        view\r\n        returns (bool)\r\n    {\r\n        return owners[owner] != 0;\r\n    }\r\n\r\n    /// @dev Returns array of owners.\r\n    /// @return Array of Safe owners.\r\n    function getOwners()\r\n        public\r\n        view\r\n        returns (address[])\r\n    {\r\n        address[] memory array = new address[](ownerCount);\r\n\r\n        // populate return array\r\n        uint256 index = 0;\r\n        address currentOwner = owners[SENTINEL_OWNERS];\r\n        while(currentOwner != SENTINEL_OWNERS) {\r\n            array[index] = currentOwner;\r\n            currentOwner = owners[currentOwner];\r\n            index ++;\r\n        }\r\n        return array;\r\n    }\r\n}\r\n\r\ncontract MasterCopy is SelfAuthorized {\r\n  // masterCopy always needs to be first declared variable, to ensure that it is at the same location as in the Proxy contract.\r\n  // It should also always be ensured that the address is stored alone (uses a full word)\r\n    address masterCopy;\r\n\r\n  /// @dev Allows to upgrade the contract. This can only be done via a Safe transaction.\r\n  /// @param _masterCopy New contract address.\r\n    function changeMasterCopy(address _masterCopy)\r\n        public\r\n        authorized\r\n    {\r\n        // Master copy address cannot be null.\r\n        require(_masterCopy != 0, \"Invalid master copy address provided\");\r\n        masterCopy = _masterCopy;\r\n    }\r\n}\r\n\r\ncontract Module is MasterCopy {\r\n\r\n    ModuleManager public manager;\r\n\r\n    modifier authorized() {\r\n        require(msg.sender == address(manager), \"Method can only be called from manager\");\r\n        _;\r\n    }\r\n\r\n    function setManager()\r\n        internal\r\n    {\r\n        // manager can only be 0 at initalization of contract.\r\n        // Check ensures that setup function can only be called once.\r\n        require(address(manager) == 0, \"Manager has already been set\");\r\n        manager = ModuleManager(msg.sender);\r\n    }\r\n}\r\n\r\ncontract SignatureDecoder {\r\n    \r\n    /// @dev Recovers address who signed the message \r\n    /// @param messageHash operation ethereum signed message hash\r\n    /// @param messageSignature message `txHash` signature\r\n    /// @param pos which signature to read\r\n    function recoverKey (\r\n        bytes32 messageHash, \r\n        bytes messageSignature,\r\n        uint256 pos\r\n    )\r\n        internal\r\n        pure\r\n        returns (address) \r\n    {\r\n        uint8 v;\r\n        bytes32 r;\r\n        bytes32 s;\r\n        (v, r, s) = signatureSplit(messageSignature, pos);\r\n        return ecrecover(messageHash, v, r, s);\r\n    }\r\n\r\n    /// @dev divides bytes signature into `uint8 v, bytes32 r, bytes32 s`\r\n    /// @param pos which signature to read\r\n    /// @param signatures concatenated rsv signatures\r\n    function signatureSplit(bytes signatures, uint256 pos)\r\n        internal\r\n        pure\r\n        returns (uint8 v, bytes32 r, bytes32 s)\r\n    {\r\n        // The signature format is a compact form of:\r\n        //   {bytes32 r}{bytes32 s}{uint8 v}\r\n        // Compact means, uint8 is not padded to 32 bytes.\r\n        // solium-disable-next-line security/no-inline-assembly\r\n        assembly {\r\n            let signaturePos := mul(0x41, pos)\r\n            r := mload(add(signatures, add(signaturePos, 0x20)))\r\n            s := mload(add(signatures, add(signaturePos, 0x40)))\r\n            // Here we are loading the last 32 bytes, including 31 bytes\r\n            // of 's'. There is no 'mload8' to do this.\r\n            //\r\n            // 'byte' is not working due to the Solidity parser, so lets\r\n            // use the second best option, 'and'\r\n            v := and(mload(add(signatures, add(signaturePos, 0x41))), 0xff)\r\n        }\r\n    }\r\n}\r\n\r\ncontract StateChannelModule is Module, SignatureDecoder {\r\n\r\n    string public constant NAME = \"State Channel Module\";\r\n    string public constant VERSION = \"0.0.2\";\r\n\r\n    // isExecuted mapping allows to check if a transaction (by hash) was already executed.\r\n    mapping (bytes32 => uint256) public isExecuted;\r\n\r\n    /// @dev Setup function sets manager\r\n    function setup()\r\n        public\r\n    {\r\n        setManager();\r\n    }\r\n\r\n    /// @dev Allows to execute a Safe transaction confirmed by required number of owners.\r\n    /// @param to Destination address of Safe transaction.\r\n    /// @param value Ether value of Safe transaction.\r\n    /// @param data Data payload of Safe transaction.\r\n    /// @param operation Operation type of Safe transaction.\r\n    /// @param nonce Nonce used for this Safe transaction.\r\n    /// @param signatures Packed signature data ({bytes32 r}{bytes32 s}{uint8 v})\r\n    function execTransaction(\r\n        address to, \r\n        uint256 value, \r\n        bytes data, \r\n        Enum.Operation operation, \r\n        uint256 nonce,\r\n        bytes signatures\r\n    )\r\n        public\r\n    {\r\n        bytes32 transactionHash = getTransactionHash(to, value, data, operation, nonce);\r\n        require(isExecuted[transactionHash] == 0, \"Transaction already executed\");\r\n        checkHash(transactionHash, signatures);\r\n        // Mark as executed and execute transaction.\r\n        isExecuted[transactionHash] = 1;\r\n        require(manager.execTransactionFromModule(to, value, data, operation), \"Could not execute transaction\");\r\n    }\r\n\r\n    function checkHash(bytes32 transactionHash, bytes signatures)\r\n        internal\r\n        view\r\n    {\r\n        // There cannot be an owner with address 0.\r\n        address lastOwner = address(0);\r\n        address currentOwner;\r\n        uint256 i;\r\n        uint256 threshold = OwnerManager(manager).getThreshold();\r\n        // Validate threshold is reached.\r\n        for (i = 0; i < threshold; i++) {\r\n            currentOwner = recoverKey(transactionHash, signatures, i);\r\n            require(OwnerManager(manager).isOwner(currentOwner), \"Signature not provided by owner\");\r\n            require(currentOwner > lastOwner, \"Signatures are not ordered by owner address\");\r\n            lastOwner = currentOwner;\r\n        }\r\n    }\r\n\r\n    /// @dev Returns hash to be signed by owners.\r\n    /// @param to Destination address.\r\n    /// @param value Ether value.\r\n    /// @param data Data payload.\r\n    /// @param operation Operation type.\r\n    /// @param nonce Transaction nonce.\r\n    /// @return Transaction hash.\r\n    function getTransactionHash(\r\n        address to, \r\n        uint256 value, \r\n        bytes data, \r\n        Enum.Operation operation, \r\n        uint256 nonce\r\n    )\r\n        public\r\n        view\r\n        returns (bytes32)\r\n    {\r\n        return keccak256(abi.encodePacked(byte(0x19), byte(0), this, to, value, data, operation, nonce));\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operation\",\"type\":\"uint8\"},{\"name\":\"nonce\",\"type\":\"uint256\"}],\"name\":\"getTransactionHash\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"manager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_masterCopy\",\"type\":\"address\"}],\"name\":\"changeMasterCopy\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NAME\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"setup\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"name\":\"isExecuted\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"to\",\"type\":\"address\"},{\"name\":\"value\",\"type\":\"uint256\"},{\"name\":\"data\",\"type\":\"bytes\"},{\"name\":\"operation\",\"type\":\"uint8\"},{\"name\":\"nonce\",\"type\":\"uint256\"},{\"name\":\"signatures\",\"type\":\"bytes\"}],\"name\":\"execTransaction\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"}]","ContractName":"StateChannelModule","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"0","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://9d10401a9b09040336a10bc3b6762de4d7d0342f3d687a394bf0dada85d8aeb9"}]}