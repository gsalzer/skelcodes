{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity 0.4.24;\r\n\r\n/**\r\n * @title ERC20Basic\r\n * @dev Simpler version of ERC20 interface\r\n * See https://github.com/ethereum/EIPs/issues/179\r\n */\r\ncontract ERC20Basic {\r\n  function totalSupply() public view returns (uint256);\r\n  function balanceOf(address who) public view returns (uint256);\r\n  function transfer(address to, uint256 value) public returns (bool);\r\n  event Transfer(address indexed from, address indexed to, uint256 value);\r\n}\r\n\r\n/**\r\n * @title ERC20 interface\r\n * @dev see https://github.com/ethereum/EIPs/issues/20\r\n */\r\ncontract ERC20 is ERC20Basic {\r\n  function allowance(address owner, address spender)\r\n    public view returns (uint256);\r\n\r\n  function transferFrom(address from, address to, uint256 value)\r\n    public returns (bool);\r\n\r\n  function approve(address spender, uint256 value) public returns (bool);\r\n  event Approval(\r\n    address indexed owner,\r\n    address indexed spender,\r\n    uint256 value\r\n  );\r\n}\r\n\r\n/**\r\n * @title SafeMath\r\n * @dev Math operations with safety checks that throw on error\r\n */\r\nlibrary SafeMath {\r\n\r\n  /**\r\n  * @dev Multiplies two numbers, throws on overflow.\r\n  */\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\r\n    // benefit is lost if 'b' is also tested.\r\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    c = a * b;\r\n    assert(c / a == b);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n  * @dev Integer division of two numbers, truncating the quotient.\r\n  */\r\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\r\n    // uint256 c = a / b;\r\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n    return a / b;\r\n  }\r\n\r\n  /**\r\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\r\n  */\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    assert(b <= a);\r\n    return a - b;\r\n  }\r\n\r\n  /**\r\n  * @dev Adds two numbers, throws on overflow.\r\n  */\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256 c) {\r\n    c = a + b;\r\n    assert(c >= a);\r\n    return c;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Ownable\r\n * @dev The Ownable contract has an owner address, and provides basic authorization control\r\n * functions, this simplifies the implementation of \"user permissions\".\r\n */\r\ncontract Ownable {\r\n  address public owner;\r\n\r\n\r\n  event OwnershipRenounced(address indexed previousOwner);\r\n  event OwnershipTransferred(\r\n    address indexed previousOwner,\r\n    address indexed newOwner\r\n  );\r\n\r\n\r\n  /**\r\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\r\n   * account.\r\n   */\r\n  constructor() public {\r\n    owner = msg.sender;\r\n  }\r\n\r\n  /**\r\n   * @dev Throws if called by any account other than the owner.\r\n   */\r\n  modifier onlyOwner() {\r\n    require(msg.sender == owner);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to relinquish control of the contract.\r\n   * @notice Renouncing to ownership will leave the contract without an owner.\r\n   * It will not be possible to call the functions with the `onlyOwner`\r\n   * modifier anymore.\r\n   */\r\n  function renounceOwnership() public onlyOwner {\r\n    emit OwnershipRenounced(owner);\r\n    owner = address(0);\r\n  }\r\n\r\n  /**\r\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function transferOwnership(address _newOwner) public onlyOwner {\r\n    _transferOwnership(_newOwner);\r\n  }\r\n\r\n  /**\r\n   * @dev Transfers control of the contract to a newOwner.\r\n   * @param _newOwner The address to transfer ownership to.\r\n   */\r\n  function _transferOwnership(address _newOwner) internal {\r\n    require(_newOwner != address(0));\r\n    emit OwnershipTransferred(owner, _newOwner);\r\n    owner = _newOwner;\r\n  }\r\n}\r\n\r\n/**\r\n * @title Basic token\r\n * @dev Basic version of StandardToken, with no allowances.\r\n */\r\ncontract BasicToken is ERC20Basic {\r\n  using SafeMath for uint256;\r\n\r\n  mapping(address => uint256) balances;\r\n\r\n  uint256 totalSupply_;\r\n\r\n  /**\r\n  * @dev Total number of tokens in existence\r\n  */\r\n  function totalSupply() public view returns (uint256) {\r\n    return totalSupply_;\r\n  }\r\n\r\n  /**\r\n  * @dev Transfer token for a specified address\r\n  * @param _to The address to transfer to.\r\n  * @param _value The amount to be transferred.\r\n  */\r\n  function transfer(address _to, uint256 _value) public returns (bool) {\r\n    require(_to != address(0));\r\n    require(_value <= balances[msg.sender]);\r\n\r\n    balances[msg.sender] = balances[msg.sender].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    emit Transfer(msg.sender, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n  * @dev Gets the balance of the specified address.\r\n  * @param _owner The address to query the the balance of.\r\n  * @return An uint256 representing the amount owned by the passed address.\r\n  */\r\n  function balanceOf(address _owner) public view returns (uint256) {\r\n    return balances[_owner];\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Standard ERC20 token\r\n *\r\n * @dev Implementation of the basic standard token.\r\n * https://github.com/ethereum/EIPs/issues/20\r\n * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\r\n */\r\ncontract StandardToken is ERC20, BasicToken {\r\n\r\n  mapping (address => mapping (address => uint256)) internal allowed;\r\n\r\n\r\n  /**\r\n   * @dev Transfer tokens from one address to another\r\n   * @param _from address The address which you want to send tokens from\r\n   * @param _to address The address which you want to transfer to\r\n   * @param _value uint256 the amount of tokens to be transferred\r\n   */\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    require(_to != address(0));\r\n    require(_value <= balances[_from]);\r\n    require(_value <= allowed[_from][msg.sender]);\r\n\r\n    balances[_from] = balances[_from].sub(_value);\r\n    balances[_to] = balances[_to].add(_value);\r\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\r\n    emit Transfer(_from, _to, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\r\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\r\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\r\n   * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards:\r\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _value The amount of tokens to be spent.\r\n   */\r\n  function approve(address _spender, uint256 _value) public returns (bool) {\r\n    allowed[msg.sender][_spender] = _value;\r\n    emit Approval(msg.sender, _spender, _value);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\r\n   * @param _owner address The address which owns the funds.\r\n   * @param _spender address The address which will spend the funds.\r\n   * @return A uint256 specifying the amount of tokens still available for the spender.\r\n   */\r\n  function allowance(\r\n    address _owner,\r\n    address _spender\r\n   )\r\n    public\r\n    view\r\n    returns (uint256)\r\n  {\r\n    return allowed[_owner][_spender];\r\n  }\r\n\r\n  /**\r\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To increment\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _addedValue The amount of tokens to increase the allowance by.\r\n   */\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint256 _addedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    allowed[msg.sender][_spender] = (\r\n      allowed[msg.sender][_spender].add(_addedValue));\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\r\n   * approve should be called when allowed[_spender] == 0. To decrement\r\n   * allowed value is better to use this function to avoid 2 calls (and wait until\r\n   * the first transaction is mined)\r\n   * From MonolithDAO Token.sol\r\n   * @param _spender The address which will spend the funds.\r\n   * @param _subtractedValue The amount of tokens to decrease the allowance by.\r\n   */\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint256 _subtractedValue\r\n  )\r\n    public\r\n    returns (bool)\r\n  {\r\n    uint256 oldValue = allowed[msg.sender][_spender];\r\n    if (_subtractedValue > oldValue) {\r\n      allowed[msg.sender][_spender] = 0;\r\n    } else {\r\n      allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\r\n    }\r\n    emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\r\n    return true;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * @title Pausable\r\n * @dev Base contract which allows children to implement an emergency stop mechanism.\r\n */\r\ncontract Pausable is Ownable {\r\n  event Pause();\r\n  event Unpause();\r\n\r\n  bool public paused = false;\r\n\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is not paused.\r\n   */\r\n  modifier whenNotPaused() {\r\n    require(!paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev Modifier to make a function callable only when the contract is paused.\r\n   */\r\n  modifier whenPaused() {\r\n    require(paused);\r\n    _;\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to pause, triggers stopped state\r\n   */\r\n  function pause() onlyOwner whenNotPaused public {\r\n    paused = true;\r\n    emit Pause();\r\n  }\r\n\r\n  /**\r\n   * @dev called by the owner to unpause, returns to normal state\r\n   */\r\n  function unpause() onlyOwner whenPaused public {\r\n    paused = false;\r\n    emit Unpause();\r\n  }\r\n}\r\n\r\n/**\r\n * @title Pausable token\r\n * @dev StandardToken modified with pausable transfers.\r\n **/\r\ncontract PausableToken is StandardToken, Pausable {\r\n\r\n  function transfer(\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transfer(_to, _value);\r\n  }\r\n\r\n  function transferFrom(\r\n    address _from,\r\n    address _to,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.transferFrom(_from, _to, _value);\r\n  }\r\n\r\n  function approve(\r\n    address _spender,\r\n    uint256 _value\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool)\r\n  {\r\n    return super.approve(_spender, _value);\r\n  }\r\n\r\n  function increaseApproval(\r\n    address _spender,\r\n    uint _addedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.increaseApproval(_spender, _addedValue);\r\n  }\r\n\r\n  function decreaseApproval(\r\n    address _spender,\r\n    uint _subtractedValue\r\n  )\r\n    public\r\n    whenNotPaused\r\n    returns (bool success)\r\n  {\r\n    return super.decreaseApproval(_spender, _subtractedValue);\r\n  }\r\n}\r\n\r\n/**\r\n * @title Burnable Token\r\n * @dev Token that can be irreversibly burned (destroyed).\r\n */\r\ncontract BurnableToken is BasicToken {\r\n\r\n  event Burn(address indexed burner, uint256 value);\r\n\r\n  /**\r\n   * @dev Burns a specific amount of tokens.\r\n   * @param _value The amount of token to be burned.\r\n   */\r\n  function burn(uint256 _value) public {\r\n    _burn(msg.sender, _value);\r\n  }\r\n\r\n  function _burn(address _who, uint256 _value) internal {\r\n    require(_value <= balances[_who]);\r\n    // no need to require value <= totalSupply, since that would imply the\r\n    // sender's balance is greater than the totalSupply, which *should* be an assertion failure\r\n\r\n    balances[_who] = balances[_who].sub(_value);\r\n    totalSupply_ = totalSupply_.sub(_value);\r\n    emit Burn(_who, _value);\r\n    emit Transfer(_who, address(0), _value);\r\n  }\r\n}\r\n\r\ncontract RepublicToken is PausableToken, BurnableToken {\r\n\r\n    string public constant name = \"Republic Token\";\r\n    string public constant symbol = \"REN\";\r\n    uint8 public constant decimals = 18;\r\n    uint256 public constant INITIAL_SUPPLY = 1000000000 * 10**uint256(decimals);\r\n\r\n    /// @notice The RepublicToken Constructor.\r\n    constructor() public {\r\n        totalSupply_ = INITIAL_SUPPLY;\r\n        balances[msg.sender] = INITIAL_SUPPLY;\r\n    }\r\n\r\n    function transferTokens(address beneficiary, uint256 amount) public onlyOwner returns (bool) {\r\n        /* solium-disable error-reason */\r\n        require(amount > 0);\r\n\r\n        balances[owner] = balances[owner].sub(amount);\r\n        balances[beneficiary] = balances[beneficiary].add(amount);\r\n        emit Transfer(owner, beneficiary, amount);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/**\r\n * @notice LinkedList is a library for a circular double linked list.\r\n */\r\nlibrary LinkedList {\r\n\r\n    /*\r\n    * @notice A permanent NULL node (0x0) in the circular double linked list.\r\n    * NULL.next is the head, and NULL.previous is the tail.\r\n    */\r\n    address public constant NULL = 0x0;\r\n\r\n    /**\r\n    * @notice A node points to the node before it, and the node after it. If\r\n    * node.previous = NULL, then the node is the head of the list. If\r\n    * node.next = NULL, then the node is the tail of the list.\r\n    */\r\n    struct Node {\r\n        bool inList;\r\n        address previous;\r\n        address next;\r\n    }\r\n\r\n    /**\r\n    * @notice LinkedList uses a mapping from address to nodes. Each address\r\n    * uniquely identifies a node, and in this way they are used like pointers.\r\n    */\r\n    struct List {\r\n        mapping (address => Node) list;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node before an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert before the target.\r\n    */\r\n    function insertBefore(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"already in list\");\r\n        require(isInList(self, target) || target == NULL, \"not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address prev = self.list[target].previous;\r\n\r\n        self.list[newNode].next = target;\r\n        self.list[newNode].previous = prev;\r\n        self.list[target].previous = newNode;\r\n        self.list[prev].next = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a new node after an existing node.\r\n    *\r\n    * @param self The list being used.\r\n    * @param target The existing node in the list.\r\n    * @param newNode The next node to insert after the target.\r\n    */\r\n    function insertAfter(List storage self, address target, address newNode) internal {\r\n        require(!isInList(self, newNode), \"already in list\");\r\n        require(isInList(self, target) || target == NULL, \"not in list\");\r\n\r\n        // It is expected that this value is sometimes NULL.\r\n        address n = self.list[target].next;\r\n\r\n        self.list[newNode].previous = target;\r\n        self.list[newNode].next = n;\r\n        self.list[target].next = newNode;\r\n        self.list[n].previous = newNode;\r\n\r\n        self.list[newNode].inList = true;\r\n    }\r\n\r\n    /**\r\n    * @notice Remove a node from the list, and fix the previous and next\r\n    * pointers that are pointing to the removed node. Removing anode that is not\r\n    * in the list will do nothing.\r\n    *\r\n    * @param self The list being using.\r\n    * @param node The node in the list to be removed.\r\n    */\r\n    function remove(List storage self, address node) internal {\r\n        require(isInList(self, node), \"not in list\");\r\n        if (node == NULL) {\r\n            return;\r\n        }\r\n        address p = self.list[node].previous;\r\n        address n = self.list[node].next;\r\n\r\n        self.list[p].next = n;\r\n        self.list[n].previous = p;\r\n\r\n        // Deleting the node should set this value to false, but we set it here for\r\n        // explicitness.\r\n        self.list[node].inList = false;\r\n        delete self.list[node];\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the beginning of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the beginning of the list.\r\n    */\r\n    function prepend(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertBefore(self, begin(self), node);\r\n    }\r\n\r\n    /**\r\n    * @notice Insert a node at the end of the list.\r\n    *\r\n    * @param self The list being used.\r\n    * @param node The node to insert at the end of the list.\r\n    */\r\n    function append(List storage self, address node) internal {\r\n        // isInList(node) is checked in insertBefore\r\n\r\n        insertAfter(self, end(self), node);\r\n    }\r\n\r\n    function swap(List storage self, address left, address right) internal {\r\n        // isInList(left) and isInList(right) are checked in remove\r\n\r\n        address previousRight = self.list[right].previous;\r\n        remove(self, right);\r\n        insertAfter(self, left, right);\r\n        remove(self, left);\r\n        insertAfter(self, previousRight, left);\r\n    }\r\n\r\n    function isInList(List storage self, address node) internal view returns (bool) {\r\n        return self.list[node].inList;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the beginning of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the beginning of the double\r\n    * linked list.\r\n    */\r\n    function begin(List storage self) internal view returns (address) {\r\n        return self.list[NULL].next;\r\n    }\r\n\r\n    /**\r\n    * @notice Get the node at the end of a double linked list.\r\n    *\r\n    * @param self The list being used.\r\n    *\r\n    * @return A address identifying the node at the end of the double linked\r\n    * list.\r\n    */\r\n    function end(List storage self) internal view returns (address) {\r\n        return self.list[NULL].previous;\r\n    }\r\n\r\n    function next(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"not in list\");\r\n        return self.list[node].next;\r\n    }\r\n\r\n    function previous(List storage self, address node) internal view returns (address) {\r\n        require(isInList(self, node), \"not in list\");\r\n        return self.list[node].previous;\r\n    }\r\n\r\n}\r\n\r\n/// @notice This contract stores data and funds for the DarknodeRegistry\r\n/// contract. The data / fund logic and storage have been separated to improve\r\n/// upgradability.\r\ncontract DarknodeRegistryStore is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice Darknodes are stored in the darknode struct. The owner is the\r\n    /// address that registered the darknode, the bond is the amount of REN that\r\n    /// was transferred during registration, and the public key is the\r\n    /// encryption key that should be used when sending sensitive information to\r\n    /// the darknode.\r\n    struct Darknode {\r\n        // The owner of a Darknode is the address that called the register\r\n        // function. The owner is the only address that is allowed to\r\n        // deregister the Darknode, unless the Darknode is slashed for\r\n        // malicious behavior.\r\n        address owner;\r\n\r\n        // The bond is the amount of REN submitted as a bond by the Darknode.\r\n        // This amount is reduced when the Darknode is slashed for malicious\r\n        // behavior.\r\n        uint256 bond;\r\n\r\n        // The block number at which the Darknode is considered registered.\r\n        uint256 registeredAt;\r\n\r\n        // The block number at which the Darknode is considered deregistered.\r\n        uint256 deregisteredAt;\r\n\r\n        // The public key used by this Darknode for encrypting sensitive data\r\n        // off chain. It is assumed that the Darknode has access to the\r\n        // respective private key, and that there is an agreement on the format\r\n        // of the public key.\r\n        bytes publicKey;\r\n    }\r\n\r\n    /// Registry data.\r\n    mapping(address => Darknode) private darknodeRegistry;\r\n    LinkedList.List private darknodes;\r\n\r\n    // RepublicToken.\r\n    RepublicToken public ren;\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _ren The address of the RepublicToken contract.\r\n    constructor(\r\n        string _VERSION,\r\n        RepublicToken _ren\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        ren = _ren;\r\n    }\r\n\r\n    /// @notice Instantiates a darknode and appends it to the darknodes\r\n    /// linked-list.\r\n    ///\r\n    /// @param _darknodeID The darknode's ID.\r\n    /// @param _darknodeOwner The darknode's owner's address\r\n    /// @param _bond The darknode's bond value\r\n    /// @param _publicKey The darknode's public key\r\n    /// @param _registeredAt The time stamp when the darknode is registered.\r\n    /// @param _deregisteredAt The time stamp when the darknode is deregistered.\r\n    function appendDarknode(\r\n        address _darknodeID,\r\n        address _darknodeOwner,\r\n        uint256 _bond,\r\n        bytes _publicKey,\r\n        uint256 _registeredAt,\r\n        uint256 _deregisteredAt\r\n    ) external onlyOwner {\r\n        Darknode memory darknode = Darknode({\r\n            owner: _darknodeOwner,\r\n            bond: _bond,\r\n            publicKey: _publicKey,\r\n            registeredAt: _registeredAt,\r\n            deregisteredAt: _deregisteredAt\r\n        });\r\n        darknodeRegistry[_darknodeID] = darknode;\r\n        LinkedList.append(darknodes, _darknodeID);\r\n    }\r\n\r\n    /// @notice Returns the address of the first darknode in the store\r\n    function begin() external view onlyOwner returns(address) {\r\n        return LinkedList.begin(darknodes);\r\n    }\r\n\r\n    /// @notice Returns the address of the next darknode in the store after the\r\n    /// given address.\r\n    function next(address darknodeID) external view onlyOwner returns(address) {\r\n        return LinkedList.next(darknodes, darknodeID);\r\n    }\r\n\r\n    /// @notice Removes a darknode from the store and transfers its bond to the\r\n    /// owner of this contract.\r\n    function removeDarknode(address darknodeID) external onlyOwner {\r\n        uint256 bond = darknodeRegistry[darknodeID].bond;\r\n        delete darknodeRegistry[darknodeID];\r\n        LinkedList.remove(darknodes, darknodeID);\r\n        require(ren.transfer(owner, bond), \"bond transfer failed\");\r\n    }\r\n\r\n    /// @notice Updates the bond of the darknode. If the bond is being\r\n    /// decreased, the difference is sent to the owner of this contract.\r\n    function updateDarknodeBond(address darknodeID, uint256 bond) external onlyOwner {\r\n        uint256 previousBond = darknodeRegistry[darknodeID].bond;\r\n        darknodeRegistry[darknodeID].bond = bond;\r\n        if (previousBond > bond) {\r\n            require(ren.transfer(owner, previousBond - bond), \"cannot transfer bond\");\r\n        }\r\n    }\r\n\r\n    /// @notice Updates the deregistration timestamp of a darknode.\r\n    function updateDarknodeDeregisteredAt(address darknodeID, uint256 deregisteredAt) external onlyOwner {\r\n        darknodeRegistry[darknodeID].deregisteredAt = deregisteredAt;\r\n    }\r\n\r\n    /// @notice Returns the owner of a given darknode.\r\n    function darknodeOwner(address darknodeID) external view onlyOwner returns (address) {\r\n        return darknodeRegistry[darknodeID].owner;\r\n    }\r\n\r\n    /// @notice Returns the bond of a given darknode.\r\n    function darknodeBond(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].bond;\r\n    }\r\n\r\n    /// @notice Returns the registration time of a given darknode.\r\n    function darknodeRegisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].registeredAt;\r\n    }\r\n\r\n    /// @notice Returns the deregistration time of a given darknode.\r\n    function darknodeDeregisteredAt(address darknodeID) external view onlyOwner returns (uint256) {\r\n        return darknodeRegistry[darknodeID].deregisteredAt;\r\n    }\r\n\r\n    /// @notice Returns the encryption public key of a given darknode.\r\n    function darknodePublicKey(address darknodeID) external view onlyOwner returns (bytes) {\r\n        return darknodeRegistry[darknodeID].publicKey;\r\n    }\r\n}\r\n\r\n/// @notice DarknodeRegistry is responsible for the registration and\r\n/// deregistration of Darknodes.\r\ncontract DarknodeRegistry is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice Darknode pods are shuffled after a fixed number of blocks.\r\n    /// An Epoch stores an epoch hash used as an (insecure) RNG seed, and the\r\n    /// blocknumber which restricts when the next epoch can be called.\r\n    struct Epoch {\r\n        uint256 epochhash;\r\n        uint256 blocknumber;\r\n    }\r\n\r\n    uint256 public numDarknodes;\r\n    uint256 public numDarknodesNextEpoch;\r\n    uint256 public numDarknodesPreviousEpoch;\r\n\r\n    /// Variables used to parameterize behavior.\r\n    uint256 public minimumBond;\r\n    uint256 public minimumPodSize;\r\n    uint256 public minimumEpochInterval;\r\n    address public slasher;\r\n\r\n    /// When one of the above variables is modified, it is only updated when the\r\n    /// next epoch is called. These variables store the values for the next epoch.\r\n    uint256 public nextMinimumBond;\r\n    uint256 public nextMinimumPodSize;\r\n    uint256 public nextMinimumEpochInterval;\r\n    address public nextSlasher;\r\n\r\n    /// The current and previous epoch\r\n    Epoch public currentEpoch;\r\n    Epoch public previousEpoch;\r\n\r\n    /// Republic ERC20 token contract used to transfer bonds.\r\n    RepublicToken public ren;\r\n\r\n    /// Darknode Registry Store is the storage contract for darknodes.\r\n    DarknodeRegistryStore public store;\r\n\r\n    /// @notice Emitted when a darknode is registered.\r\n    /// @param _darknodeID The darknode ID that was registered.\r\n    /// @param _bond The amount of REN that was transferred as bond.\r\n    event LogDarknodeRegistered(address _darknodeID, uint256 _bond);\r\n\r\n    /// @notice Emitted when a darknode is deregistered.\r\n    /// @param _darknodeID The darknode ID that was deregistered.\r\n    event LogDarknodeDeregistered(address _darknodeID);\r\n\r\n    /// @notice Emitted when a refund has been made.\r\n    /// @param _owner The address that was refunded.\r\n    /// @param _amount The amount of REN that was refunded.\r\n    event LogDarknodeOwnerRefunded(address _owner, uint256 _amount);\r\n\r\n    /// @notice Emitted when a new epoch has begun.\r\n    event LogNewEpoch();\r\n\r\n    /// @notice Emitted when a constructor parameter has been updated.\r\n    event LogMinimumBondUpdated(uint256 previousMinimumBond, uint256 nextMinimumBond);\r\n    event LogMinimumPodSizeUpdated(uint256 previousMinimumPodSize, uint256 nextMinimumPodSize);\r\n    event LogMinimumEpochIntervalUpdated(uint256 previousMinimumEpochInterval, uint256 nextMinimumEpochInterval);\r\n    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\r\n\r\n    /// @notice Only allow the owner that registered the darknode to pass.\r\n    modifier onlyDarknodeOwner(address _darknodeID) {\r\n        require(store.darknodeOwner(_darknodeID) == msg.sender, \"must be darknode owner\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow unregistered darknodes.\r\n    modifier onlyRefunded(address _darknodeID) {\r\n        require(isRefunded(_darknodeID), \"must be refunded or never registered\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow refundable darknodes.\r\n    modifier onlyRefundable(address _darknodeID) {\r\n        require(isRefundable(_darknodeID), \"must be deregistered for at least one epoch\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allowed registered nodes without a pending deregistration to\r\n    /// deregister\r\n    modifier onlyDeregisterable(address _darknodeID) {\r\n        require(isDeregisterable(_darknodeID), \"must be deregisterable\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Only allow the Slasher contract.\r\n    modifier onlySlasher() {\r\n        require(slasher == msg.sender, \"must be slasher\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _renAddress The address of the RepublicToken contract.\r\n    /// @param _storeAddress The address of the DarknodeRegistryStore contract.\r\n    /// @param _minimumBond The minimum bond amount that can be submitted by a\r\n    ///        Darknode.\r\n    /// @param _minimumPodSize The minimum size of a Darknode pod.\r\n    /// @param _minimumEpochInterval The minimum number of blocks between\r\n    ///        epochs.\r\n    constructor(\r\n        string _VERSION,\r\n        RepublicToken _renAddress,\r\n        DarknodeRegistryStore _storeAddress,\r\n        uint256 _minimumBond,\r\n        uint256 _minimumPodSize,\r\n        uint256 _minimumEpochInterval\r\n    ) public {\r\n        VERSION = _VERSION;\r\n\r\n        store = _storeAddress;\r\n        ren = _renAddress;\r\n\r\n        minimumBond = _minimumBond;\r\n        nextMinimumBond = minimumBond;\r\n\r\n        minimumPodSize = _minimumPodSize;\r\n        nextMinimumPodSize = minimumPodSize;\r\n\r\n        minimumEpochInterval = _minimumEpochInterval;\r\n        nextMinimumEpochInterval = minimumEpochInterval;\r\n\r\n        currentEpoch = Epoch({\r\n            epochhash: uint256(blockhash(block.number - 1)),\r\n            blocknumber: block.number\r\n        });\r\n        numDarknodes = 0;\r\n        numDarknodesNextEpoch = 0;\r\n        numDarknodesPreviousEpoch = 0;\r\n    }\r\n\r\n    /// @notice Register a darknode and transfer the bond to this contract. The\r\n    /// caller must provide a public encryption key for the darknode as well as\r\n    /// a bond in REN. The bond must be provided as an ERC20 allowance. The dark\r\n    /// node will remain pending registration until the next epoch. Only after\r\n    /// this period can the darknode be deregistered. The caller of this method\r\n    /// will be stored as the owner of the darknode.\r\n    ///\r\n    /// @param _darknodeID The darknode ID that will be registered.\r\n    /// @param _publicKey The public key of the darknode. It is stored to allow\r\n    ///        other darknodes and traders to encrypt messages to the trader.\r\n    /// @param _bond The bond that will be paid. It must be greater than, or\r\n    ///        equal to, the minimum bond.\r\n    function register(address _darknodeID, bytes _publicKey, uint256 _bond) external onlyRefunded(_darknodeID) {\r\n        // REN allowance\r\n        require(_bond >= minimumBond, \"insufficient bond\");\r\n        // require(ren.allowance(msg.sender, address(this)) >= _bond);\r\n        require(ren.transferFrom(msg.sender, address(this), _bond), \"bond transfer failed\");\r\n        ren.transfer(address(store), _bond);\r\n\r\n        // Flag this darknode for registration\r\n        store.appendDarknode(\r\n            _darknodeID,\r\n            msg.sender,\r\n            _bond,\r\n            _publicKey,\r\n            currentEpoch.blocknumber + minimumEpochInterval,\r\n            0\r\n        );\r\n\r\n        numDarknodesNextEpoch += 1;\r\n\r\n        // Emit an event.\r\n        emit LogDarknodeRegistered(_darknodeID, _bond);\r\n    }\r\n\r\n    /// @notice Deregister a darknode. The darknode will not be deregistered\r\n    /// until the end of the epoch. After another epoch, the bond can be\r\n    /// refunded by calling the refund method.\r\n    /// @param _darknodeID The darknode ID that will be deregistered. The caller\r\n    ///        of this method store.darknodeRegisteredAt(_darknodeID) must be\r\n    //         the owner of this darknode.\r\n    function deregister(address _darknodeID) external onlyDeregisterable(_darknodeID) onlyDarknodeOwner(_darknodeID) {\r\n        // Flag the darknode for deregistration\r\n        store.updateDarknodeDeregisteredAt(_darknodeID, currentEpoch.blocknumber + minimumEpochInterval);\r\n        numDarknodesNextEpoch -= 1;\r\n\r\n        // Emit an event\r\n        emit LogDarknodeDeregistered(_darknodeID);\r\n    }\r\n\r\n    /// @notice Progress the epoch if it is possible to do so. This captures\r\n    /// the current timestamp and current blockhash and overrides the current\r\n    /// epoch.\r\n    function epoch() external {\r\n        if (previousEpoch.blocknumber == 0) {\r\n            // The first epoch must be called by the owner of the contract\r\n            require(msg.sender == owner, \"not authorized (first epochs)\");\r\n        }\r\n\r\n        // Require that the epoch interval has passed\r\n        require(block.number >= currentEpoch.blocknumber + minimumEpochInterval, \"epoch interval has not passed\");\r\n        uint256 epochhash = uint256(blockhash(block.number - 1));\r\n\r\n        // Update the epoch hash and timestamp\r\n        previousEpoch = currentEpoch;\r\n        currentEpoch = Epoch({\r\n            epochhash: epochhash,\r\n            blocknumber: block.number\r\n        });\r\n\r\n        // Update the registry information\r\n        numDarknodesPreviousEpoch = numDarknodes;\r\n        numDarknodes = numDarknodesNextEpoch;\r\n\r\n        // If any update functions have been called, update the values now\r\n        if (nextMinimumBond != minimumBond) {\r\n            minimumBond = nextMinimumBond;\r\n            emit LogMinimumBondUpdated(minimumBond, nextMinimumBond);\r\n        }\r\n        if (nextMinimumPodSize != minimumPodSize) {\r\n            minimumPodSize = nextMinimumPodSize;\r\n            emit LogMinimumPodSizeUpdated(minimumPodSize, nextMinimumPodSize);\r\n        }\r\n        if (nextMinimumEpochInterval != minimumEpochInterval) {\r\n            minimumEpochInterval = nextMinimumEpochInterval;\r\n            emit LogMinimumEpochIntervalUpdated(minimumEpochInterval, nextMinimumEpochInterval);\r\n        }\r\n        if (nextSlasher != slasher) {\r\n            slasher = nextSlasher;\r\n            emit LogSlasherUpdated(slasher, nextSlasher);\r\n        }\r\n\r\n        // Emit an event\r\n        emit LogNewEpoch();\r\n    }\r\n\r\n    /// @notice Allows the contract owner to transfer ownership of the\r\n    /// DarknodeRegistryStore.\r\n    /// @param _newOwner The address to transfer the ownership to.\r\n    function transferStoreOwnership(address _newOwner) external onlyOwner {\r\n        store.transferOwnership(_newOwner);\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum bond.\r\n    /// @param _nextMinimumBond The minimum bond amount that can be submitted by\r\n    ///        a darknode.\r\n    function updateMinimumBond(uint256 _nextMinimumBond) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumBond = _nextMinimumBond;\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum pod size.\r\n    /// @param _nextMinimumPodSize The minimum size of a pod.\r\n    function updateMinimumPodSize(uint256 _nextMinimumPodSize) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumPodSize = _nextMinimumPodSize;\r\n    }\r\n\r\n    /// @notice Allows the contract owner to update the minimum epoch interval.\r\n    /// @param _nextMinimumEpochInterval The minimum number of blocks between epochs.\r\n    function updateMinimumEpochInterval(uint256 _nextMinimumEpochInterval) external onlyOwner {\r\n        // Will be updated next epoch\r\n        nextMinimumEpochInterval = _nextMinimumEpochInterval;\r\n    }\r\n\r\n    /// @notice Allow the contract owner to update the DarknodeSlasher contract\r\n    /// address.\r\n    /// @param _slasher The new slasher address.\r\n    function updateSlasher(address _slasher) external onlyOwner {\r\n        nextSlasher = _slasher;\r\n    }\r\n\r\n    /// @notice Allow the DarknodeSlasher contract to slash half of a darknode's\r\n    /// bond and deregister it. The bond is distributed as follows:\r\n    ///   1/2 is kept by the guilty prover\r\n    ///   1/8 is rewarded to the first challenger\r\n    ///   1/8 is rewarded to the second challenger\r\n    ///   1/4 becomes unassigned\r\n    /// @param _prover The guilty prover whose bond is being slashed\r\n    /// @param _challenger1 The first of the two darknodes who submitted the challenge\r\n    /// @param _challenger2 The second of the two darknodes who submitted the challenge\r\n    function slash(address _prover, address _challenger1, address _challenger2)\r\n        external\r\n        onlySlasher\r\n    {\r\n        uint256 penalty = store.darknodeBond(_prover) / 2;\r\n        uint256 reward = penalty / 4;\r\n\r\n        // Slash the bond of the failed prover in half\r\n        store.updateDarknodeBond(_prover, penalty);\r\n\r\n        // If the darknode has not been deregistered then deregister it\r\n        if (isDeregisterable(_prover)) {\r\n            store.updateDarknodeDeregisteredAt(_prover, currentEpoch.blocknumber + minimumEpochInterval);\r\n            numDarknodesNextEpoch -= 1;\r\n            emit LogDarknodeDeregistered(_prover);\r\n        }\r\n\r\n        // Reward the challengers with less than the penalty so that it is not\r\n        // worth challenging yourself\r\n        ren.transfer(store.darknodeOwner(_challenger1), reward);\r\n        ren.transfer(store.darknodeOwner(_challenger2), reward);\r\n    }\r\n\r\n    /// @notice Refund the bond of a deregistered darknode. This will make the\r\n    /// darknode available for registration again. Anyone can call this function\r\n    /// but the bond will always be refunded to the darknode owner.\r\n    ///\r\n    /// @param _darknodeID The darknode ID that will be refunded. The caller\r\n    ///        of this method must be the owner of this darknode.\r\n    function refund(address _darknodeID) external onlyRefundable(_darknodeID) {\r\n        address darknodeOwner = store.darknodeOwner(_darknodeID);\r\n\r\n        // Remember the bond amount\r\n        uint256 amount = store.darknodeBond(_darknodeID);\r\n\r\n        // Erase the darknode from the registry\r\n        store.removeDarknode(_darknodeID);\r\n\r\n        // Refund the owner by transferring REN\r\n        ren.transfer(darknodeOwner, amount);\r\n\r\n        // Emit an event.\r\n        emit LogDarknodeOwnerRefunded(darknodeOwner, amount);\r\n    }\r\n\r\n    /// @notice Retrieves the address of the account that registered a darknode.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the owner for.\r\n    function getDarknodeOwner(address _darknodeID) external view returns (address) {\r\n        return store.darknodeOwner(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves the bond amount of a darknode in 10^-18 REN.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the bond for.\r\n    function getDarknodeBond(address _darknodeID) external view returns (uint256) {\r\n        return store.darknodeBond(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves the encryption public key of the darknode.\r\n    /// @param _darknodeID The ID of the darknode to retrieve the public key for.\r\n    function getDarknodePublicKey(address _darknodeID) external view returns (bytes) {\r\n        return store.darknodePublicKey(_darknodeID);\r\n    }\r\n\r\n    /// @notice Retrieves a list of darknodes which are registered for the\r\n    /// current epoch.\r\n    /// @param _start A darknode ID used as an offset for the list. If _start is\r\n    ///        0x0, the first dark node will be used. _start won't be\r\n    ///        included it is not registered for the epoch.\r\n    /// @param _count The number of darknodes to retrieve starting from _start.\r\n    ///        If _count is 0, all of the darknodes from _start are\r\n    ///        retrieved. If _count is more than the remaining number of\r\n    ///        registered darknodes, the rest of the list will contain\r\n    ///        0x0s.\r\n    function getDarknodes(address _start, uint256 _count) external view returns (address[]) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodes;\r\n        }\r\n        return getDarknodesFromEpochs(_start, count, false);\r\n    }\r\n\r\n    /// @notice Retrieves a list of darknodes which were registered for the\r\n    /// previous epoch. See `getDarknodes` for the parameter documentation.\r\n    function getPreviousDarknodes(address _start, uint256 _count) external view returns (address[]) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodesPreviousEpoch;\r\n        }\r\n        return getDarknodesFromEpochs(_start, count, true);\r\n    }\r\n\r\n    /// @notice Returns whether a darknode is scheduled to become registered\r\n    /// at next epoch.\r\n    /// @param _darknodeID The ID of the darknode to return\r\n    function isPendingRegistration(address _darknodeID) external view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        return registeredAt != 0 && registeredAt > currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the pending deregistered state. In\r\n    /// this state a darknode is still considered registered.\r\n    function isPendingDeregistration(address _darknodeID) external view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return deregisteredAt != 0 && deregisteredAt > currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the deregistered state.\r\n    function isDeregistered(address _darknodeID) public view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return deregisteredAt != 0 && deregisteredAt <= currentEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode can be deregistered. This is true if the\r\n    /// darknodes is in the registered state and has not attempted to\r\n    /// deregister yet.\r\n    function isDeregisterable(address _darknodeID) public view returns (bool) {\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        // The Darknode is currently in the registered state and has not been\r\n        // transitioned to the pending deregistration, or deregistered, state\r\n        return isRegistered(_darknodeID) && deregisteredAt == 0;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the refunded state. This is true\r\n    /// for darknodes that have never been registered, or darknodes that have\r\n    /// been deregistered and refunded.\r\n    function isRefunded(address _darknodeID) public view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        return registeredAt == 0 && deregisteredAt == 0;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is refundable. This is true for darknodes\r\n    /// that have been in the deregistered state for one full epoch.\r\n    function isRefundable(address _darknodeID) public view returns (bool) {\r\n        return isDeregistered(_darknodeID) && store.darknodeDeregisteredAt(_darknodeID) <= previousEpoch.blocknumber;\r\n    }\r\n\r\n    /// @notice Returns if a darknode is in the registered state.\r\n    function isRegistered(address _darknodeID) public view returns (bool) {\r\n        return isRegisteredInEpoch(_darknodeID, currentEpoch);\r\n    }\r\n\r\n    /// @notice Returns if a darknode was in the registered state last epoch.\r\n    function isRegisteredInPreviousEpoch(address _darknodeID) public view returns (bool) {\r\n        return isRegisteredInEpoch(_darknodeID, previousEpoch);\r\n    }\r\n\r\n    /// @notice Returns if a darknode was in the registered state for a given\r\n    /// epoch.\r\n    /// @param _darknodeID The ID of the darknode\r\n    /// @param _epoch One of currentEpoch, previousEpoch\r\n    function isRegisteredInEpoch(address _darknodeID, Epoch _epoch) private view returns (bool) {\r\n        uint256 registeredAt = store.darknodeRegisteredAt(_darknodeID);\r\n        uint256 deregisteredAt = store.darknodeDeregisteredAt(_darknodeID);\r\n        bool registered = registeredAt != 0 && registeredAt <= _epoch.blocknumber;\r\n        bool notDeregistered = deregisteredAt == 0 || deregisteredAt > _epoch.blocknumber;\r\n        // The Darknode has been registered and has not yet been deregistered,\r\n        // although it might be pending deregistration\r\n        return registered && notDeregistered;\r\n    }\r\n\r\n    /// @notice Returns a list of darknodes registered for either the current\r\n    /// or the previous epoch. See `getDarknodes` for documentation on the\r\n    /// parameters `_start` and `_count`.\r\n    /// @param _usePreviousEpoch If true, use the previous epoch, otherwise use\r\n    ///        the current epoch.\r\n    function getDarknodesFromEpochs(address _start, uint256 _count, bool _usePreviousEpoch) private view returns (address[]) {\r\n        uint256 count = _count;\r\n        if (count == 0) {\r\n            count = numDarknodes;\r\n        }\r\n\r\n        address[] memory nodes = new address[](count);\r\n\r\n        // Begin with the first node in the list\r\n        uint256 n = 0;\r\n        address next = _start;\r\n        if (next == 0x0) {\r\n            next = store.begin();\r\n        }\r\n\r\n        // Iterate until all registered Darknodes have been collected\r\n        while (n < count) {\r\n            if (next == 0x0) {\r\n                break;\r\n            }\r\n            // Only include Darknodes that are currently registered\r\n            bool includeNext;\r\n            if (_usePreviousEpoch) {\r\n                includeNext = isRegisteredInPreviousEpoch(next);\r\n            } else {\r\n                includeNext = isRegistered(next);\r\n            }\r\n            if (!includeNext) {\r\n                next = store.next(next);\r\n                continue;\r\n            }\r\n            nodes[n] = next;\r\n            next = store.next(next);\r\n            n += 1;\r\n        }\r\n        return nodes;\r\n    }\r\n}\r\n\r\n/**\r\n * @title Math\r\n * @dev Assorted math operations\r\n */\r\nlibrary Math {\r\n  function max64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min64(uint64 a, uint64 b) internal pure returns (uint64) {\r\n    return a < b ? a : b;\r\n  }\r\n\r\n  function max256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a >= b ? a : b;\r\n  }\r\n\r\n  function min256(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    return a < b ? a : b;\r\n  }\r\n}\r\n\r\n/// @notice Implements safeTransfer, safeTransferFrom and\r\n/// safeApprove for CompatibleERC20.\r\n///\r\n/// See https://github.com/ethereum/solidity/issues/4116\r\n///\r\n/// This library allows interacting with ERC20 tokens that implement any of\r\n/// these interfaces:\r\n///\r\n/// (1) transfer returns true on success, false on failure\r\n/// (2) transfer returns true on success, reverts on failure\r\n/// (3) transfer returns nothing on success, reverts on failure\r\n///\r\n/// Additionally, safeTransferFromWithFees will return the final token\r\n/// value received after accounting for token fees.\r\nlibrary CompatibleERC20Functions {\r\n    using SafeMath for uint256;\r\n\r\n    /// @notice Calls transfer on the token and reverts if the call fails.\r\n    function safeTransfer(address token, address to, uint256 amount) internal {\r\n        CompatibleERC20(token).transfer(to, amount);\r\n        require(previousReturnValue(), \"transfer failed\");\r\n    }\r\n\r\n    /// @notice Calls transferFrom on the token and reverts if the call fails.\r\n    function safeTransferFrom(address token, address from, address to, uint256 amount) internal {\r\n        CompatibleERC20(token).transferFrom(from, to, amount);\r\n        require(previousReturnValue(), \"transferFrom failed\");\r\n    }\r\n\r\n    /// @notice Calls approve on the token and reverts if the call fails.\r\n    function safeApprove(address token, address spender, uint256 amount) internal {\r\n        CompatibleERC20(token).approve(spender, amount);\r\n        require(previousReturnValue(), \"approve failed\");\r\n    }\r\n\r\n    /// @notice Calls transferFrom on the token, reverts if the call fails and\r\n    /// returns the value transferred after fees.\r\n    function safeTransferFromWithFees(address token, address from, address to, uint256 amount) internal returns (uint256) {\r\n        uint256 balancesBefore = CompatibleERC20(token).balanceOf(to);\r\n        CompatibleERC20(token).transferFrom(from, to, amount);\r\n        require(previousReturnValue(), \"transferFrom failed\");\r\n        uint256 balancesAfter = CompatibleERC20(token).balanceOf(to);\r\n        return Math.min256(amount, balancesAfter.sub(balancesBefore));\r\n    }\r\n\r\n    /// @notice Checks the return value of the previous function. Returns true\r\n    /// if the previous function returned 32 non-zero bytes or returned zero\r\n    /// bytes.\r\n    function previousReturnValue() private pure returns (bool)\r\n    {\r\n        uint256 returnData = 0;\r\n\r\n        assembly { /* solium-disable-line security/no-inline-assembly */\r\n            // Switch on the number of bytes returned by the previous call\r\n            switch returndatasize\r\n\r\n            // 0 bytes: ERC20 of type (3), did not throw\r\n            case 0 {\r\n                returnData := 1\r\n            }\r\n\r\n            // 32 bytes: ERC20 of types (1) or (2)\r\n            case 32 {\r\n                // Copy the return data into scratch space\r\n                returndatacopy(0x0, 0x0, 32)\r\n\r\n                // Load  the return data into returnData\r\n                returnData := mload(0x0)\r\n            }\r\n\r\n            // Other return size: return false\r\n            default { }\r\n        }\r\n\r\n        return returnData != 0;\r\n    }\r\n}\r\n\r\n/// @notice ERC20 interface which doesn't specify the return type for transfer,\r\n/// transferFrom and approve.\r\ninterface CompatibleERC20 {\r\n    // Modified to not return boolean\r\n    function transfer(address to, uint256 value) external;\r\n    function transferFrom(address from, address to, uint256 value) external;\r\n    function approve(address spender, uint256 value) external;\r\n\r\n    // Not modifier\r\n    function totalSupply() external view returns (uint256);\r\n    function balanceOf(address who) external view returns (uint256);\r\n    function allowance(address owner, address spender) external view returns (uint256);\r\n    event Transfer(address indexed from, address indexed to, uint256 value);\r\n    event Approval(address indexed owner, address indexed spender, uint256 value);\r\n}\r\n\r\n/// @notice The DarknodeRewardVault contract is responsible for holding fees\r\n/// for darknodes for settling orders. Fees can be withdrawn to the address of\r\n/// the darknode's operator. Fees can be in ETH or in ERC20 tokens.\r\n/// Docs: https://github.com/republicprotocol/republic-sol/blob/master/docs/02-darknode-reward-vault.md\r\ncontract DarknodeRewardVault is Ownable {\r\n    using SafeMath for uint256;\r\n    using CompatibleERC20Functions for CompatibleERC20;\r\n\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice The special address for Ether.\r\n    address constant public ETHEREUM = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE;\r\n\r\n    DarknodeRegistry public darknodeRegistry;\r\n\r\n    mapping(address => mapping(address => uint256)) public darknodeBalances;\r\n\r\n    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _darknodeRegistry The DarknodeRegistry contract that is used by\r\n    ///        the vault to lookup Darknode owners.\r\n    constructor(string _VERSION, DarknodeRegistry _darknodeRegistry) public {\r\n        VERSION = _VERSION;\r\n        darknodeRegistry = _darknodeRegistry;\r\n    }\r\n\r\n    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) public onlyOwner {\r\n        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\r\n        darknodeRegistry = _newDarknodeRegistry;\r\n    }\r\n\r\n    /// @notice Deposit fees into the vault for a Darknode. The Darknode\r\n    /// registration is not checked (to reduce gas fees); the caller must be\r\n    /// careful not to call this function for a Darknode that is not registered\r\n    /// otherwise any fees deposited to that Darknode can be withdrawn by a\r\n    /// malicious adversary (by registering the Darknode before the honest\r\n    /// party and claiming ownership).\r\n    ///\r\n    /// @param _darknode The address of the Darknode that will receive the\r\n    ///        fees.\r\n    /// @param _token The address of the ERC20 token being used to pay the fee.\r\n    ///        A special address is used for Ether.\r\n    /// @param _value The amount of fees in the smallest unit of the token.\r\n    function deposit(address _darknode, ERC20 _token, uint256 _value) public payable {\r\n        uint256 receivedValue = _value;\r\n        if (address(_token) == ETHEREUM) {\r\n            require(msg.value == _value, \"mismatched ether value\");\r\n        } else {\r\n            require(msg.value == 0, \"unexpected ether value\");\r\n            receivedValue = CompatibleERC20(_token).safeTransferFromWithFees(msg.sender, address(this), _value);\r\n        }\r\n        darknodeBalances[_darknode][_token] = darknodeBalances[_darknode][_token].add(receivedValue);\r\n    }\r\n\r\n    /// @notice Withdraw fees earned by a Darknode. The fees will be sent to\r\n    /// the owner of the Darknode. If a Darknode is not registered the fees\r\n    /// cannot be withdrawn.\r\n    ///\r\n    /// @param _darknode The address of the Darknode whose fees are being\r\n    ///        withdrawn. The owner of this Darknode will receive the fees.\r\n    /// @param _token The address of the ERC20 token to withdraw.\r\n    function withdraw(address _darknode, ERC20 _token) public {\r\n        address darknodeOwner = darknodeRegistry.getDarknodeOwner(address(_darknode));\r\n\r\n        require(darknodeOwner != 0x0, \"invalid darknode owner\");\r\n\r\n        uint256 value = darknodeBalances[_darknode][_token];\r\n        darknodeBalances[_darknode][_token] = 0;\r\n\r\n        if (address(_token) == ETHEREUM) {\r\n            darknodeOwner.transfer(value);\r\n        } else {\r\n            CompatibleERC20(_token).safeTransfer(darknodeOwner, value);\r\n        }\r\n    }\r\n\r\n}\r\n\r\n/// @notice The BrokerVerifier interface defines the functions that a settlement\r\n/// layer's broker verifier contract must implement.\r\ninterface BrokerVerifier {\r\n\r\n    /// @notice The function signature that will be called when a trader opens\r\n    /// an order.\r\n    ///\r\n    /// @param _trader The trader requesting the withdrawal.\r\n    /// @param _signature The 65-byte signature from the broker.\r\n    /// @param _orderID The 32-byte order ID.\r\n    function verifyOpenSignature(\r\n        address _trader,\r\n        bytes _signature,\r\n        bytes32 _orderID\r\n    ) external returns (bool);\r\n}\r\n\r\n/// @notice The Settlement interface defines the functions that a settlement\r\n/// layer must implement.\r\n/// Docs: https://github.com/republicprotocol/republic-sol/blob/nightly/docs/05-settlement.md\r\ninterface Settlement {\r\n    function submitOrder(\r\n        bytes _details,\r\n        uint64 _settlementID,\r\n        uint64 _tokens,\r\n        uint256 _price,\r\n        uint256 _volume,\r\n        uint256 _minimumVolume\r\n    ) external;\r\n\r\n    function submissionGasPriceLimit() external view returns (uint256);\r\n\r\n    function settle(\r\n        bytes32 _buyID,\r\n        bytes32 _sellID\r\n    ) external;\r\n\r\n    /// @notice orderStatus should return the status of the order, which should\r\n    /// be:\r\n    ///     0  - Order not seen before\r\n    ///     1  - Order details submitted\r\n    ///     >1 - Order settled, or settlement no longer possible\r\n    function orderStatus(bytes32 _orderID) external view returns (uint8);\r\n}\r\n\r\n/// @notice SettlementRegistry allows a Settlement layer to register the\r\n/// contracts used for match settlement and for broker signature verification.\r\ncontract SettlementRegistry is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    struct SettlementDetails {\r\n        bool registered;\r\n        Settlement settlementContract;\r\n        BrokerVerifier brokerVerifierContract;\r\n    }\r\n\r\n    // Settlement IDs are 64-bit unsigned numbers\r\n    mapping(uint64 => SettlementDetails) public settlementDetails;\r\n\r\n    // Events\r\n    event LogSettlementRegistered(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\r\n    event LogSettlementUpdated(uint64 settlementID, Settlement settlementContract, BrokerVerifier brokerVerifierContract);\r\n    event LogSettlementDeregistered(uint64 settlementID);\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    constructor(string _VERSION) public {\r\n        VERSION = _VERSION;\r\n    }\r\n\r\n    /// @notice Returns the settlement contract of a settlement layer.\r\n    function settlementRegistration(uint64 _settlementID) external view returns (bool) {\r\n        return settlementDetails[_settlementID].registered;\r\n    }\r\n\r\n    /// @notice Returns the settlement contract of a settlement layer.\r\n    function settlementContract(uint64 _settlementID) external view returns (Settlement) {\r\n        return settlementDetails[_settlementID].settlementContract;\r\n    }\r\n\r\n    /// @notice Returns the broker verifier contract of a settlement layer.\r\n    function brokerVerifierContract(uint64 _settlementID) external view returns (BrokerVerifier) {\r\n        return settlementDetails[_settlementID].brokerVerifierContract;\r\n    }\r\n\r\n    /// @param _settlementID A unique 64-bit settlement identifier.\r\n    /// @param _settlementContract The address to use for settling matches.\r\n    /// @param _brokerVerifierContract The decimals to use for verifying\r\n    ///        broker signatures.\r\n    function registerSettlement(uint64 _settlementID, Settlement _settlementContract, BrokerVerifier _brokerVerifierContract) public onlyOwner {\r\n        bool alreadyRegistered = settlementDetails[_settlementID].registered;\r\n        \r\n        settlementDetails[_settlementID] = SettlementDetails({\r\n            registered: true,\r\n            settlementContract: _settlementContract,\r\n            brokerVerifierContract: _brokerVerifierContract\r\n        });\r\n\r\n        if (alreadyRegistered) {\r\n            emit LogSettlementUpdated(_settlementID, _settlementContract, _brokerVerifierContract);\r\n        } else {\r\n            emit LogSettlementRegistered(_settlementID, _settlementContract, _brokerVerifierContract);\r\n        }\r\n    }\r\n\r\n    /// @notice Deregisteres a settlement layer, clearing the details.\r\n    /// @param _settlementID The unique 64-bit settlement identifier.\r\n    function deregisterSettlement(uint64 _settlementID) external onlyOwner {\r\n        require(settlementDetails[_settlementID].registered, \"not registered\");\r\n\r\n        delete settlementDetails[_settlementID];\r\n\r\n        emit LogSettlementDeregistered(_settlementID);\r\n    }\r\n}\r\n\r\n/**\r\n * @title Eliptic curve signature operations\r\n * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d\r\n * TODO Remove this library once solidity supports passing a signature to ecrecover.\r\n * See https://github.com/ethereum/solidity/issues/864\r\n */\r\n\r\nlibrary ECRecovery {\r\n\r\n  /**\r\n   * @dev Recover signer address from a message by using their signature\r\n   * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address.\r\n   * @param sig bytes signature, the signature is generated using web3.eth.sign()\r\n   */\r\n  function recover(bytes32 hash, bytes sig)\r\n    internal\r\n    pure\r\n    returns (address)\r\n  {\r\n    bytes32 r;\r\n    bytes32 s;\r\n    uint8 v;\r\n\r\n    // Check the signature length\r\n    if (sig.length != 65) {\r\n      return (address(0));\r\n    }\r\n\r\n    // Divide the signature in r, s and v variables\r\n    // ecrecover takes the signature parameters, and the only way to get them\r\n    // currently is to use assembly.\r\n    // solium-disable-next-line security/no-inline-assembly\r\n    assembly {\r\n      r := mload(add(sig, 32))\r\n      s := mload(add(sig, 64))\r\n      v := byte(0, mload(add(sig, 96)))\r\n    }\r\n\r\n    // Version of signature should be 27 or 28, but 0 and 1 are also possible versions\r\n    if (v < 27) {\r\n      v += 27;\r\n    }\r\n\r\n    // If the version is correct return the signer address\r\n    if (v != 27 && v != 28) {\r\n      return (address(0));\r\n    } else {\r\n      // solium-disable-next-line arg-overflow\r\n      return ecrecover(hash, v, r, s);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * toEthSignedMessageHash\r\n   * @dev prefix a bytes32 value with \"\\x19Ethereum Signed Message:\"\r\n   * and hash the result\r\n   */\r\n  function toEthSignedMessageHash(bytes32 hash)\r\n    internal\r\n    pure\r\n    returns (bytes32)\r\n  {\r\n    // 32 is the length in bytes of hash,\r\n    // enforced by the type signature above\r\n    return keccak256(\r\n      abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash)\r\n    );\r\n  }\r\n}\r\n\r\nlibrary Utils {\r\n\r\n    /**\r\n     * @notice Converts a number to its string/bytes representation\r\n     *\r\n     * @param _v the uint to convert\r\n     */\r\n    function uintToBytes(uint256 _v) internal pure returns (bytes) {\r\n        uint256 v = _v;\r\n        if (v == 0) {\r\n            return \"0\";\r\n        }\r\n\r\n        uint256 digits = 0;\r\n        uint256 v2 = v;\r\n        while (v2 > 0) {\r\n            v2 /= 10;\r\n            digits += 1;\r\n        }\r\n\r\n        bytes memory result = new bytes(digits);\r\n\r\n        for (uint256 i = 0; i < digits; i++) {\r\n            result[digits - i - 1] = bytes1((v % 10) + 48);\r\n            v /= 10;\r\n        }\r\n\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * @notice Retrieves the address from a signature\r\n     *\r\n     * @param _hash the message that was signed (any length of bytes)\r\n     * @param _signature the signature (65 bytes)\r\n     */\r\n    function addr(bytes _hash, bytes _signature) internal pure returns (address) {\r\n        bytes memory prefix = \"\\x19Ethereum Signed Message:\\n\";\r\n        bytes memory encoded = abi.encodePacked(prefix, uintToBytes(_hash.length), _hash);\r\n        bytes32 prefixedHash = keccak256(encoded);\r\n\r\n        return ECRecovery.recover(prefixedHash, _signature);\r\n    }\r\n\r\n}\r\n\r\n/// @notice The Orderbook contract stores the state and priority of orders and\r\n/// allows the Darknodes to easily reach consensus. Eventually, this contract\r\n/// will only store a subset of order states, such as cancellation, to improve\r\n/// the throughput of orders.\r\ncontract Orderbook is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    /// @notice OrderState enumerates the possible states of an order. All\r\n    /// orders default to the Undefined state.\r\n    enum OrderState {Undefined, Open, Confirmed, Canceled}\r\n\r\n    /// @notice Order stores a subset of the public data associated with an order.\r\n    struct Order {\r\n        OrderState state;     // State of the order\r\n        address trader;       // Trader that owns the order\r\n        address confirmer;    // Darknode that confirmed the order in a match\r\n        uint64 settlementID;  // The settlement that signed the order opening\r\n        uint256 priority;     // Logical time priority of this order\r\n        uint256 blockNumber;  // Block number of the most recent state change\r\n        bytes32 matchedOrder; // Order confirmed in a match with this order\r\n    }\r\n\r\n    RepublicToken public ren;\r\n    DarknodeRegistry public darknodeRegistry;\r\n    SettlementRegistry public settlementRegistry;\r\n\r\n    bytes32[] private orderbook;\r\n\r\n    // Order details are exposed through directly accessing this mapping, or\r\n    // through the getter functions below for each of the order's fields.\r\n    mapping(bytes32 => Order) public orders;\r\n\r\n    event LogFeeUpdated(uint256 previousFee, uint256 nextFee);\r\n    event LogDarknodeRegistryUpdated(DarknodeRegistry previousDarknodeRegistry, DarknodeRegistry nextDarknodeRegistry);\r\n\r\n    /// @notice Only allow registered dark nodes.\r\n    modifier onlyDarknode(address _sender) {\r\n        require(darknodeRegistry.isRegistered(address(_sender)), \"must be registered darknode\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _renAddress The address of the RepublicToken contract.\r\n    /// @param _darknodeRegistry The address of the DarknodeRegistry contract.\r\n    /// @param _settlementRegistry The address of the SettlementRegistry\r\n    ///        contract.\r\n    constructor(\r\n        string _VERSION,\r\n        RepublicToken _renAddress,\r\n        DarknodeRegistry _darknodeRegistry,\r\n        SettlementRegistry _settlementRegistry\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        ren = _renAddress;\r\n        darknodeRegistry = _darknodeRegistry;\r\n        settlementRegistry = _settlementRegistry;\r\n    }\r\n\r\n    /// @notice Allows the owner to update the address of the DarknodeRegistry\r\n    /// contract.\r\n    function updateDarknodeRegistry(DarknodeRegistry _newDarknodeRegistry) external onlyOwner {\r\n        emit LogDarknodeRegistryUpdated(darknodeRegistry, _newDarknodeRegistry);\r\n        darknodeRegistry = _newDarknodeRegistry;\r\n    }\r\n\r\n    /// @notice Open an order in the orderbook. The order must be in the\r\n    /// Undefined state.\r\n    ///\r\n    /// @param _signature Signature of the message that defines the trader. The\r\n    ///        message is \"Republic Protocol: open: {orderId}\".\r\n    /// @param _orderID The hash of the order.\r\n    function openOrder(uint64 _settlementID, bytes _signature, bytes32 _orderID) external {\r\n        require(orders[_orderID].state == OrderState.Undefined, \"invalid order status\");\r\n\r\n        address trader = msg.sender;\r\n\r\n        // Verify the order signature\r\n        require(settlementRegistry.settlementRegistration(_settlementID), \"settlement not registered\");\r\n        BrokerVerifier brokerVerifier = settlementRegistry.brokerVerifierContract(_settlementID);\r\n        require(brokerVerifier.verifyOpenSignature(trader, _signature, _orderID), \"invalid broker signature\");\r\n\r\n        orders[_orderID] = Order({\r\n            state: OrderState.Open,\r\n            trader: trader,\r\n            confirmer: 0x0,\r\n            settlementID: _settlementID,\r\n            priority: orderbook.length + 1,\r\n            blockNumber: block.number,\r\n            matchedOrder: 0x0\r\n        });\r\n\r\n        orderbook.push(_orderID);\r\n    }\r\n\r\n    /// @notice Confirm an order match between orders. The confirmer must be a\r\n    /// registered Darknode and the orders must be in the Open state. A\r\n    /// malicious confirmation by a Darknode will result in a bond slash of the\r\n    /// Darknode.\r\n    ///\r\n    /// @param _orderID The hash of the order.\r\n    /// @param _matchedOrderID The hashes of the matching order.\r\n    function confirmOrder(bytes32 _orderID, bytes32 _matchedOrderID) external onlyDarknode(msg.sender) {\r\n        require(orders[_orderID].state == OrderState.Open, \"invalid order status\");\r\n        require(orders[_matchedOrderID].state == OrderState.Open, \"invalid order status\");\r\n\r\n        orders[_orderID].state = OrderState.Confirmed;\r\n        orders[_orderID].confirmer = msg.sender;\r\n        orders[_orderID].matchedOrder = _matchedOrderID;\r\n        orders[_orderID].blockNumber = block.number;\r\n\r\n        orders[_matchedOrderID].state = OrderState.Confirmed;\r\n        orders[_matchedOrderID].confirmer = msg.sender;\r\n        orders[_matchedOrderID].matchedOrder = _orderID;\r\n        orders[_matchedOrderID].blockNumber = block.number;\r\n    }\r\n\r\n    /// @notice Cancel an open order in the orderbook. An order can be cancelled\r\n    /// by the trader who opened the order, or by the broker verifier contract.\r\n    /// This allows the settlement layer to implement their own logic for\r\n    /// cancelling orders without trader interaction (e.g. to ban a trader from\r\n    /// a specific darkpool, or to use multiple order-matching platforms)\r\n    ///\r\n    /// @param _orderID The hash of the order.\r\n    function cancelOrder(bytes32 _orderID) external {\r\n        require(orders[_orderID].state == OrderState.Open, \"invalid order state\");\r\n\r\n        // Require the msg.sender to be the trader or the broker verifier\r\n        address brokerVerifier = address(settlementRegistry.brokerVerifierContract(orders[_orderID].settlementID));\r\n        require(msg.sender == orders[_orderID].trader || msg.sender == brokerVerifier, \"not authorized\");\r\n\r\n        orders[_orderID].state = OrderState.Canceled;\r\n        orders[_orderID].blockNumber = block.number;\r\n    }\r\n\r\n    /// @notice returns status of the given orderID.\r\n    function orderState(bytes32 _orderID) external view returns (OrderState) {\r\n        return orders[_orderID].state;\r\n    }\r\n\r\n    /// @notice returns a list of matched orders to the given orderID.\r\n    function orderMatch(bytes32 _orderID) external view returns (bytes32) {\r\n        return orders[_orderID].matchedOrder;\r\n    }\r\n\r\n    /// @notice returns the priority of the given orderID.\r\n    /// The priority is the index of the order in the orderbook.\r\n    function orderPriority(bytes32 _orderID) external view returns (uint256) {\r\n        return orders[_orderID].priority;\r\n    }\r\n\r\n    /// @notice returns the trader of the given orderID.\r\n    /// Trader is the one who signs the message and does the actual trading.\r\n    function orderTrader(bytes32 _orderID) external view returns (address) {\r\n        return orders[_orderID].trader;\r\n    }\r\n\r\n    /// @notice returns the darknode address which confirms the given orderID.\r\n    function orderConfirmer(bytes32 _orderID) external view returns (address) {\r\n        return orders[_orderID].confirmer;\r\n    }\r\n\r\n    /// @notice returns the block number when the order being last modified.\r\n    function orderBlockNumber(bytes32 _orderID) external view returns (uint256) {\r\n        return orders[_orderID].blockNumber;\r\n    }\r\n\r\n    /// @notice returns the block depth of the orderId\r\n    function orderDepth(bytes32 _orderID) external view returns (uint256) {\r\n        if (orders[_orderID].blockNumber == 0) {\r\n            return 0;\r\n        }\r\n        return (block.number - orders[_orderID].blockNumber);\r\n    }\r\n\r\n    /// @notice returns the number of orders in the orderbook\r\n    function ordersCount() external view returns (uint256) {\r\n        return orderbook.length;\r\n    }\r\n\r\n    /// @notice returns order details of the orders starting from the offset.\r\n    function getOrders(uint256 _offset, uint256 _limit) external view returns (bytes32[], address[], uint8[]) {\r\n        if (_offset >= orderbook.length) {\r\n            return;\r\n        }\r\n\r\n        // If the provided limit is more than the number of orders after the offset,\r\n        // decrease the limit\r\n        uint256 limit = _limit;\r\n        if (_offset + limit > orderbook.length) {\r\n            limit = orderbook.length - _offset;\r\n        }\r\n\r\n        bytes32[] memory orderIDs = new bytes32[](limit);\r\n        address[] memory traderAddresses = new address[](limit);\r\n        uint8[] memory states = new uint8[](limit);\r\n\r\n        for (uint256 i = 0; i < limit; i++) {\r\n            bytes32 order = orderbook[i + _offset];\r\n            orderIDs[i] = order;\r\n            traderAddresses[i] = orders[order].trader;\r\n            states[i] = uint8(orders[order].state);\r\n        }\r\n\r\n        return (orderIDs, traderAddresses, states);\r\n    }\r\n}\r\n\r\n/// @notice A library for calculating and verifying order match details\r\nlibrary SettlementUtils {\r\n\r\n    struct OrderDetails {\r\n        uint64 settlementID;\r\n        uint64 tokens;\r\n        uint256 price;\r\n        uint256 volume;\r\n        uint256 minimumVolume;\r\n    }\r\n\r\n    /// @notice Calculates the ID of the order.\r\n    /// @param details Order details that are not required for settlement\r\n    ///        execution. They are combined as a single byte array.\r\n    /// @param order The order details required for settlement execution.\r\n    function hashOrder(bytes details, OrderDetails memory order) internal pure returns (bytes32) {\r\n        return keccak256(\r\n            abi.encodePacked(\r\n                details,\r\n                order.settlementID,\r\n                order.tokens,\r\n                order.price,\r\n                order.volume,\r\n                order.minimumVolume\r\n            )\r\n        );\r\n    }\r\n\r\n    /// @notice Verifies that two orders match when considering the tokens,\r\n    /// price, volumes / minimum volumes and settlement IDs. verifyMatchDetails is used\r\n    /// my the DarknodeSlasher to verify challenges. Settlement layers may also\r\n    /// use this function.\r\n    /// @dev When verifying two orders for settlement, you should also:\r\n    ///   1) verify the orders have been confirmed together\r\n    ///   2) verify the orders' traders are distinct\r\n    /// @param _buy The buy order details.\r\n    /// @param _sell The sell order details.\r\n    function verifyMatchDetails(OrderDetails memory _buy, OrderDetails memory _sell) internal pure returns (bool) {\r\n\r\n        // Buy and sell tokens should match\r\n        if (!verifyTokens(_buy.tokens, _sell.tokens)) {\r\n            return false;\r\n        }\r\n\r\n        // Buy price should be greater than sell price\r\n        if (_buy.price < _sell.price) {\r\n            return false;\r\n        }\r\n\r\n        // // Buy volume should be greater than sell minimum volume\r\n        if (_buy.volume < _sell.minimumVolume) {\r\n            return false;\r\n        }\r\n\r\n        // Sell volume should be greater than buy minimum volume\r\n        if (_sell.volume < _buy.minimumVolume) {\r\n            return false;\r\n        }\r\n\r\n        // Require that the orders were submitted to the same settlement layer\r\n        if (_buy.settlementID != _sell.settlementID) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /// @notice Verifies that two token requirements can be matched and that the\r\n    /// tokens are formatted correctly.\r\n    /// @param _buyTokens The buy token details.\r\n    /// @param _sellToken The sell token details.\r\n    function verifyTokens(uint64 _buyTokens, uint64 _sellToken) internal pure returns (bool) {\r\n        return ((\r\n                uint32(_buyTokens) == uint32(_sellToken >> 32)) && (\r\n                uint32(_sellToken) == uint32(_buyTokens >> 32)) && (\r\n                uint32(_buyTokens >> 32) <= uint32(_buyTokens))\r\n        );\r\n    }\r\n}\r\n\r\n/// @notice RenExTokens is a registry of tokens that can be traded on RenEx.\r\ncontract RenExTokens is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    struct TokenDetails {\r\n        address addr;\r\n        uint8 decimals;\r\n        bool registered;\r\n    }\r\n\r\n    // Storage\r\n    mapping(uint32 => TokenDetails) public tokens;\r\n    mapping(uint32 => bool) private detailsSubmitted;\r\n\r\n    // Events\r\n    event LogTokenRegistered(uint32 tokenCode, address tokenAddress, uint8 tokenDecimals);\r\n    event LogTokenDeregistered(uint32 tokenCode);\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    constructor(string _VERSION) public {\r\n        VERSION = _VERSION;\r\n    }\r\n\r\n    /// @notice Allows the owner to register and the details for a token.\r\n    /// Once details have been submitted, they cannot be overwritten.\r\n    /// To re-register the same token with different details (e.g. if the address\r\n    /// has changed), a different token identifier should be used and the\r\n    /// previous token identifier should be deregistered.\r\n    /// If a token is not Ethereum-based, the address will be set to 0x0.\r\n    ///\r\n    /// @param _tokenCode A unique 32-bit token identifier.\r\n    /// @param _tokenAddress The address of the token.\r\n    /// @param _tokenDecimals The decimals to use for the token.\r\n    function registerToken(uint32 _tokenCode, address _tokenAddress, uint8 _tokenDecimals) public onlyOwner {\r\n        require(!tokens[_tokenCode].registered, \"already registered\");\r\n\r\n        // If a token is being re-registered, the same details must be provided.\r\n        if (detailsSubmitted[_tokenCode]) {\r\n            require(tokens[_tokenCode].addr == _tokenAddress, \"different address\");\r\n            require(tokens[_tokenCode].decimals == _tokenDecimals, \"different decimals\");\r\n        } else {\r\n            detailsSubmitted[_tokenCode] = true;\r\n        }\r\n\r\n        tokens[_tokenCode] = TokenDetails({\r\n            addr: _tokenAddress,\r\n            decimals: _tokenDecimals,\r\n            registered: true\r\n        });\r\n\r\n        emit LogTokenRegistered(_tokenCode, _tokenAddress, _tokenDecimals);\r\n    }\r\n\r\n    /// @notice Sets a token as being deregistered. The details are still stored\r\n    /// to prevent the token from being re-registered with different details.\r\n    ///\r\n    /// @param _tokenCode The unique 32-bit token identifier.\r\n    function deregisterToken(uint32 _tokenCode) external onlyOwner {\r\n        require(tokens[_tokenCode].registered, \"not registered\");\r\n\r\n        tokens[_tokenCode].registered = false;\r\n\r\n        emit LogTokenDeregistered(_tokenCode);\r\n    }\r\n}\r\n\r\n/// @notice RenExSettlement implements the Settlement interface. It implements\r\n/// the on-chain settlement for the RenEx settlement layer, and the fee payment\r\n/// for the RenExAtomic settlement layer.\r\ncontract RenExSettlement is Ownable {\r\n    using SafeMath for uint256;\r\n\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    // This contract handles the settlements with ID 1 and 2.\r\n    uint32 constant public RENEX_SETTLEMENT_ID = 1;\r\n    uint32 constant public RENEX_ATOMIC_SETTLEMENT_ID = 2;\r\n\r\n    // Fees in RenEx are 0.2%. To represent this as integers, it is broken into\r\n    // a numerator and denominator.\r\n    uint256 constant public DARKNODE_FEES_NUMERATOR = 2;\r\n    uint256 constant public DARKNODE_FEES_DENOMINATOR = 1000;\r\n\r\n    // Constants used in the price / volume inputs.\r\n    int16 constant private PRICE_OFFSET = 12;\r\n    int16 constant private VOLUME_OFFSET = 12;\r\n\r\n    // Constructor parameters, updatable by the owner\r\n    Orderbook public orderbookContract;\r\n    RenExTokens public renExTokensContract;\r\n    RenExBalances public renExBalancesContract;\r\n    address public slasherAddress;\r\n    uint256 public submissionGasPriceLimit;\r\n\r\n    enum OrderStatus {None, Submitted, Settled, Slashed}\r\n\r\n    struct TokenPair {\r\n        RenExTokens.TokenDetails priorityToken;\r\n        RenExTokens.TokenDetails secondaryToken;\r\n    }\r\n\r\n    // A uint256 tuple representing a value and an associated fee\r\n    struct ValueWithFees {\r\n        uint256 value;\r\n        uint256 fees;\r\n    }\r\n\r\n    // A uint256 tuple representing a fraction\r\n    struct Fraction {\r\n        uint256 numerator;\r\n        uint256 denominator;\r\n    }\r\n\r\n    // We use left and right because the tokens do not always represent the\r\n    // priority and secondary tokens.\r\n    struct SettlementDetails {\r\n        uint256 leftVolume;\r\n        uint256 rightVolume;\r\n        uint256 leftTokenFee;\r\n        uint256 rightTokenFee;\r\n        address leftTokenAddress;\r\n        address rightTokenAddress;\r\n    }\r\n\r\n    // Events\r\n    event LogOrderbookUpdated(Orderbook previousOrderbook, Orderbook nextOrderbook);\r\n    event LogRenExTokensUpdated(RenExTokens previousRenExTokens, RenExTokens nextRenExTokens);\r\n    event LogRenExBalancesUpdated(RenExBalances previousRenExBalances, RenExBalances nextRenExBalances);\r\n    event LogSubmissionGasPriceLimitUpdated(uint256 previousSubmissionGasPriceLimit, uint256 nextSubmissionGasPriceLimit);\r\n    event LogSlasherUpdated(address previousSlasher, address nextSlasher);\r\n\r\n    // Order Storage\r\n    mapping(bytes32 => SettlementUtils.OrderDetails) public orderDetails;\r\n    mapping(bytes32 => address) public orderSubmitter;\r\n    mapping(bytes32 => OrderStatus) public orderStatus;\r\n\r\n    // Match storage (match details are indexed by [buyID][sellID])\r\n    mapping(bytes32 => mapping(bytes32 => uint256)) public matchTimestamp;\r\n\r\n    /// @notice Prevents a function from being called with a gas price higher\r\n    /// than the specified limit.\r\n    ///\r\n    /// @param _gasPriceLimit The gas price upper-limit in Wei.\r\n    modifier withGasPriceLimit(uint256 _gasPriceLimit) {\r\n        require(tx.gasprice <= _gasPriceLimit, \"gas price too high\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Restricts a function to only being called by the slasher\r\n    /// address.\r\n    modifier onlySlasher() {\r\n        require(msg.sender == slasherAddress, \"unauthorized\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _orderbookContract The address of the Orderbook contract.\r\n    /// @param _renExBalancesContract The address of the RenExBalances\r\n    ///        contract.\r\n    /// @param _renExTokensContract The address of the RenExTokens contract.\r\n    constructor(\r\n        string _VERSION,\r\n        Orderbook _orderbookContract,\r\n        RenExTokens _renExTokensContract,\r\n        RenExBalances _renExBalancesContract,\r\n        address _slasherAddress,\r\n        uint256 _submissionGasPriceLimit\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        orderbookContract = _orderbookContract;\r\n        renExTokensContract = _renExTokensContract;\r\n        renExBalancesContract = _renExBalancesContract;\r\n        slasherAddress = _slasherAddress;\r\n        submissionGasPriceLimit = _submissionGasPriceLimit;\r\n    }\r\n\r\n    /// @notice The owner of the contract can update the Orderbook address.\r\n    /// @param _newOrderbookContract The address of the new Orderbook contract.\r\n    function updateOrderbook(Orderbook _newOrderbookContract) external onlyOwner {\r\n        emit LogOrderbookUpdated(orderbookContract, _newOrderbookContract);\r\n        orderbookContract = _newOrderbookContract;\r\n    }\r\n\r\n    /// @notice The owner of the contract can update the RenExTokens address.\r\n    /// @param _newRenExTokensContract The address of the new RenExTokens\r\n    ///       contract.\r\n    function updateRenExTokens(RenExTokens _newRenExTokensContract) external onlyOwner {\r\n        emit LogRenExTokensUpdated(renExTokensContract, _newRenExTokensContract);\r\n        renExTokensContract = _newRenExTokensContract;\r\n    }\r\n    \r\n    /// @notice The owner of the contract can update the RenExBalances address.\r\n    /// @param _newRenExBalancesContract The address of the new RenExBalances\r\n    ///       contract.\r\n    function updateRenExBalances(RenExBalances _newRenExBalancesContract) external onlyOwner {\r\n        emit LogRenExBalancesUpdated(renExBalancesContract, _newRenExBalancesContract);\r\n        renExBalancesContract = _newRenExBalancesContract;\r\n    }\r\n\r\n    /// @notice The owner of the contract can update the order submission gas\r\n    /// price limit.\r\n    /// @param _newSubmissionGasPriceLimit The new gas price limit.\r\n    function updateSubmissionGasPriceLimit(uint256 _newSubmissionGasPriceLimit) external onlyOwner {\r\n        emit LogSubmissionGasPriceLimitUpdated(submissionGasPriceLimit, _newSubmissionGasPriceLimit);\r\n        submissionGasPriceLimit = _newSubmissionGasPriceLimit;\r\n    }\r\n\r\n    /// @notice The owner of the contract can update the slasher address.\r\n    /// @param _newSlasherAddress The new slasher address.\r\n    function updateSlasher(address _newSlasherAddress) external onlyOwner {\r\n        emit LogSlasherUpdated(slasherAddress, _newSlasherAddress);\r\n        slasherAddress = _newSlasherAddress;\r\n    }\r\n\r\n    /// @notice Stores the details of an order.\r\n    ///\r\n    /// @param _prefix The miscellaneous details of the order required for\r\n    ///        calculating the order id.\r\n    /// @param _settlementID The settlement identifier.\r\n    /// @param _tokens The encoding of the token pair (buy token is encoded as\r\n    ///        the first 32 bytes and sell token is encoded as the last 32\r\n    ///        bytes).\r\n    /// @param _price The price of the order. Interpreted as the cost for 1\r\n    ///        standard unit of the non-priority token, in 1e12 (i.e.\r\n    ///        PRICE_OFFSET) units of the priority token).\r\n    /// @param _volume The volume of the order. Interpreted as the maximum\r\n    ///        number of 1e-12 (i.e. VOLUME_OFFSET) units of the non-priority\r\n    ///        token that can be traded by this order.\r\n    /// @param _minimumVolume The minimum volume the trader is willing to\r\n    ///        accept. Encoded the same as the volume.\r\n    function submitOrder(\r\n        bytes _prefix,\r\n        uint64 _settlementID,\r\n        uint64 _tokens,\r\n        uint256 _price,\r\n        uint256 _volume,\r\n        uint256 _minimumVolume\r\n    ) external withGasPriceLimit(submissionGasPriceLimit) {\r\n\r\n        SettlementUtils.OrderDetails memory order = SettlementUtils.OrderDetails({\r\n            settlementID: _settlementID,\r\n            tokens: _tokens,\r\n            price: _price,\r\n            volume: _volume,\r\n            minimumVolume: _minimumVolume\r\n        });\r\n        bytes32 orderID = SettlementUtils.hashOrder(_prefix, order);\r\n\r\n        require(orderStatus[orderID] == OrderStatus.None, \"order already submitted\");\r\n        require(orderbookContract.orderState(orderID) == Orderbook.OrderState.Confirmed, \"unconfirmed order\");\r\n\r\n        orderSubmitter[orderID] = msg.sender;\r\n        orderStatus[orderID] = OrderStatus.Submitted;\r\n        orderDetails[orderID] = order;\r\n    }\r\n\r\n    /// @notice Settles two orders that are matched. `submitOrder` must have been\r\n    /// called for each order before this function is called.\r\n    ///\r\n    /// @param _buyID The 32 byte ID of the buy order.\r\n    /// @param _sellID The 32 byte ID of the sell order.\r\n    function settle(bytes32 _buyID, bytes32 _sellID) external {\r\n        require(orderStatus[_buyID] == OrderStatus.Submitted, \"invalid buy status\");\r\n        require(orderStatus[_sellID] == OrderStatus.Submitted, \"invalid sell status\");\r\n\r\n        // Check the settlement ID (only have to check for one, since\r\n        // `verifyMatchDetails` checks that they are the same)\r\n        require(\r\n            orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID ||\r\n            orderDetails[_buyID].settlementID == RENEX_SETTLEMENT_ID,\r\n            \"invalid settlement id\"\r\n        );\r\n\r\n        // Verify that the two order details are compatible.\r\n        require(SettlementUtils.verifyMatchDetails(orderDetails[_buyID], orderDetails[_sellID]), \"incompatible orders\");\r\n\r\n        // Verify that the two orders have been confirmed to one another.\r\n        require(orderbookContract.orderMatch(_buyID) == _sellID, \"unconfirmed orders\");\r\n\r\n        // Retrieve token details.\r\n        TokenPair memory tokens = getTokenDetails(orderDetails[_buyID].tokens);\r\n\r\n        // Require that the tokens have been registered.\r\n        require(tokens.priorityToken.registered, \"unregistered priority token\");\r\n        require(tokens.secondaryToken.registered, \"unregistered secondary token\");\r\n\r\n        address buyer = orderbookContract.orderTrader(_buyID);\r\n        address seller = orderbookContract.orderTrader(_sellID);\r\n\r\n        require(buyer != seller, \"orders from same trader\");\r\n\r\n        execute(_buyID, _sellID, buyer, seller, tokens);\r\n\r\n        /* solium-disable-next-line security/no-block-members */\r\n        matchTimestamp[_buyID][_sellID] = now;\r\n\r\n        // Store that the orders have been settled.\r\n        orderStatus[_buyID] = OrderStatus.Settled;\r\n        orderStatus[_sellID] = OrderStatus.Settled;\r\n    }\r\n\r\n    /// @notice Slashes the bond of a guilty trader. This is called when an\r\n    /// atomic swap is not executed successfully.\r\n    /// To open an atomic order, a trader must have a balance equivalent to\r\n    /// 0.6% of the trade in the Ethereum-based token. 0.2% is always paid in\r\n    /// darknode fees when the order is matched. If the remaining amount is\r\n    /// is slashed, it is distributed as follows:\r\n    ///   1) 0.2% goes to the other trader, covering their fee\r\n    ///   2) 0.2% goes to the slasher address\r\n    /// Only one order in a match can be slashed.\r\n    ///\r\n    /// @param _guiltyOrderID The 32 byte ID of the order of the guilty trader.\r\n    function slash(bytes32 _guiltyOrderID) external onlySlasher {\r\n        require(orderDetails[_guiltyOrderID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID, \"slashing non-atomic trade\");\r\n\r\n        bytes32 innocentOrderID = orderbookContract.orderMatch(_guiltyOrderID);\r\n\r\n        require(orderStatus[_guiltyOrderID] == OrderStatus.Settled, \"invalid order status\");\r\n        require(orderStatus[innocentOrderID] == OrderStatus.Settled, \"invalid order status\");\r\n        orderStatus[_guiltyOrderID] = OrderStatus.Slashed;\r\n\r\n        (bytes32 buyID, bytes32 sellID) = isBuyOrder(_guiltyOrderID) ?\r\n            (_guiltyOrderID, innocentOrderID) : (innocentOrderID, _guiltyOrderID);\r\n\r\n        TokenPair memory tokens = getTokenDetails(orderDetails[buyID].tokens);\r\n\r\n        SettlementDetails memory settlementDetails = calculateAtomicFees(buyID, sellID, tokens);\r\n\r\n        // Transfer the fee amount to the other trader\r\n        renExBalancesContract.transferBalanceWithFee(\r\n            orderbookContract.orderTrader(_guiltyOrderID),\r\n            orderbookContract.orderTrader(innocentOrderID),\r\n            settlementDetails.leftTokenAddress,\r\n            settlementDetails.leftTokenFee,\r\n            0,\r\n            0x0\r\n        );\r\n\r\n        // Transfer the fee amount to the slasher\r\n        renExBalancesContract.transferBalanceWithFee(\r\n            orderbookContract.orderTrader(_guiltyOrderID),\r\n            slasherAddress,\r\n            settlementDetails.leftTokenAddress,\r\n            settlementDetails.leftTokenFee,\r\n            0,\r\n            0x0\r\n        );\r\n    }\r\n\r\n    /// @notice Retrieves the settlement details of an order.\r\n    /// For atomic swaps, it returns the full volumes, not the settled fees.\r\n    ///\r\n    /// @param _orderID The order to lookup the details of. Can be the ID of a\r\n    ///        buy or a sell order.\r\n    /// @return [\r\n    ///     a boolean representing whether or not the order has been settled,\r\n    ///     a boolean representing whether or not the order is a buy\r\n    ///     the 32-byte order ID of the matched order\r\n    ///     the volume of the priority token,\r\n    ///     the volume of the secondary token,\r\n    ///     the fee paid in the priority token,\r\n    ///     the fee paid in the secondary token,\r\n    ///     the token code of the priority token,\r\n    ///     the token code of the secondary token\r\n    /// ]\r\n    function getMatchDetails(bytes32 _orderID)\r\n    external view returns (\r\n        bool settled,\r\n        bool orderIsBuy,\r\n        bytes32 matchedID,\r\n        uint256 priorityVolume,\r\n        uint256 secondaryVolume,\r\n        uint256 priorityFee,\r\n        uint256 secondaryFee,\r\n        uint32 priorityToken,\r\n        uint32 secondaryToken\r\n    ) {\r\n        matchedID = orderbookContract.orderMatch(_orderID);\r\n\r\n        orderIsBuy = isBuyOrder(_orderID);\r\n\r\n        (bytes32 buyID, bytes32 sellID) = orderIsBuy ?\r\n            (_orderID, matchedID) : (matchedID, _orderID);\r\n\r\n        SettlementDetails memory settlementDetails = calculateSettlementDetails(\r\n            buyID,\r\n            sellID,\r\n            getTokenDetails(orderDetails[buyID].tokens)\r\n        );\r\n\r\n        return (\r\n            orderStatus[_orderID] == OrderStatus.Settled || orderStatus[_orderID] == OrderStatus.Slashed,\r\n            orderIsBuy,\r\n            matchedID,\r\n            settlementDetails.leftVolume,\r\n            settlementDetails.rightVolume,\r\n            settlementDetails.leftTokenFee,\r\n            settlementDetails.rightTokenFee,\r\n            uint32(orderDetails[buyID].tokens >> 32),\r\n            uint32(orderDetails[buyID].tokens)\r\n        );\r\n    }\r\n\r\n    /// @notice Exposes the hashOrder function for computing a hash of an\r\n    /// order's details. An order hash is used as its ID. See `submitOrder`\r\n    /// for the parameter descriptions.\r\n    ///\r\n    /// @return The 32-byte hash of the order.\r\n    function hashOrder(\r\n        bytes _prefix,\r\n        uint64 _settlementID,\r\n        uint64 _tokens,\r\n        uint256 _price,\r\n        uint256 _volume,\r\n        uint256 _minimumVolume\r\n    ) external pure returns (bytes32) {\r\n        return SettlementUtils.hashOrder(_prefix, SettlementUtils.OrderDetails({\r\n            settlementID: _settlementID,\r\n            tokens: _tokens,\r\n            price: _price,\r\n            volume: _volume,\r\n            minimumVolume: _minimumVolume\r\n        }));\r\n    }\r\n\r\n    /// @notice Called by `settle`, executes the settlement for a RenEx order\r\n    /// or distributes the fees for a RenExAtomic swap.\r\n    ///\r\n    /// @param _buyID The 32 byte ID of the buy order.\r\n    /// @param _sellID The 32 byte ID of the sell order.\r\n    /// @param _buyer The address of the buy trader.\r\n    /// @param _seller The address of the sell trader.\r\n    /// @param _tokens The details of the priority and secondary tokens.\r\n    function execute(\r\n        bytes32 _buyID,\r\n        bytes32 _sellID,\r\n        address _buyer,\r\n        address _seller,\r\n        TokenPair memory _tokens\r\n    ) private {\r\n        // Calculate the fees for atomic swaps, and the settlement details\r\n        // otherwise.\r\n        SettlementDetails memory settlementDetails = (orderDetails[_buyID].settlementID == RENEX_ATOMIC_SETTLEMENT_ID) ?\r\n            settlementDetails = calculateAtomicFees(_buyID, _sellID, _tokens) :\r\n            settlementDetails = calculateSettlementDetails(_buyID, _sellID, _tokens);\r\n\r\n        // Transfer priority token value\r\n        renExBalancesContract.transferBalanceWithFee(\r\n            _buyer,\r\n            _seller,\r\n            settlementDetails.leftTokenAddress,\r\n            settlementDetails.leftVolume,\r\n            settlementDetails.leftTokenFee,\r\n            orderSubmitter[_buyID]\r\n        );\r\n\r\n        // Transfer secondary token value\r\n        renExBalancesContract.transferBalanceWithFee(\r\n            _seller,\r\n            _buyer,\r\n            settlementDetails.rightTokenAddress,\r\n            settlementDetails.rightVolume,\r\n            settlementDetails.rightTokenFee,\r\n            orderSubmitter[_sellID]\r\n        );\r\n    }\r\n\r\n    /// @notice Calculates the details required to execute two matched orders.\r\n    ///\r\n    /// @param _buyID The 32 byte ID of the buy order.\r\n    /// @param _sellID The 32 byte ID of the sell order.\r\n    /// @param _tokens The details of the priority and secondary tokens.\r\n    /// @return A struct containing the settlement details.\r\n    function calculateSettlementDetails(\r\n        bytes32 _buyID,\r\n        bytes32 _sellID,\r\n        TokenPair memory _tokens\r\n    ) private view returns (SettlementDetails memory) {\r\n\r\n        // Calculate the mid-price (using numerator and denominator to not loose\r\n        // precision).\r\n        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\r\n\r\n        // Calculate the lower of the two max volumes of each trader\r\n        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\r\n\r\n        uint256 priorityTokenVolume = joinFraction(\r\n            commonVolume.mul(midPrice.numerator),\r\n            midPrice.denominator,\r\n            int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\r\n        );\r\n        uint256 secondaryTokenVolume = joinFraction(\r\n            commonVolume,\r\n            1,\r\n            int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\r\n        );\r\n\r\n        // Calculate darknode fees\r\n        ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\r\n        ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\r\n\r\n        return SettlementDetails({\r\n            leftVolume: priorityVwF.value,\r\n            rightVolume: secondaryVwF.value,\r\n            leftTokenFee: priorityVwF.fees,\r\n            rightTokenFee: secondaryVwF.fees,\r\n            leftTokenAddress: _tokens.priorityToken.addr,\r\n            rightTokenAddress: _tokens.secondaryToken.addr\r\n        });\r\n    }\r\n\r\n    /// @notice Calculates the fees to be transferred for an atomic swap.\r\n    ///\r\n    /// @param _buyID The 32 byte ID of the buy order.\r\n    /// @param _sellID The 32 byte ID of the sell order.\r\n    /// @param _tokens The details of the priority and secondary tokens.\r\n    /// @return A struct containing the fee details.\r\n    function calculateAtomicFees(\r\n        bytes32 _buyID,\r\n        bytes32 _sellID,\r\n        TokenPair memory _tokens\r\n    ) private view returns (SettlementDetails memory) {\r\n\r\n        // Calculate the mid-price (using numerator and denominator to not loose\r\n        // precision).\r\n        Fraction memory midPrice = Fraction(orderDetails[_buyID].price + orderDetails[_sellID].price, 2);\r\n\r\n        // Calculate the lower of the two max volumes of each trader\r\n        uint256 commonVolume = Math.min256(orderDetails[_buyID].volume, orderDetails[_sellID].volume);\r\n\r\n        if (isEthereumBased(_tokens.secondaryToken.addr)) {\r\n            uint256 secondaryTokenVolume = joinFraction(\r\n                commonVolume,\r\n                1,\r\n                int16(_tokens.secondaryToken.decimals) - VOLUME_OFFSET\r\n            );\r\n\r\n            // Calculate darknode fees\r\n            ValueWithFees memory secondaryVwF = subtractDarknodeFee(secondaryTokenVolume);\r\n\r\n            return SettlementDetails({\r\n                leftVolume: 0,\r\n                rightVolume: 0,\r\n                leftTokenFee: secondaryVwF.fees,\r\n                rightTokenFee: secondaryVwF.fees,\r\n                leftTokenAddress: _tokens.secondaryToken.addr,\r\n                rightTokenAddress: _tokens.secondaryToken.addr\r\n            });\r\n        } else if (isEthereumBased(_tokens.priorityToken.addr)) {\r\n            uint256 priorityTokenVolume = joinFraction(\r\n                commonVolume.mul(midPrice.numerator),\r\n                midPrice.denominator,\r\n                int16(_tokens.priorityToken.decimals) - PRICE_OFFSET - VOLUME_OFFSET\r\n            );\r\n\r\n            // Calculate darknode fees\r\n            ValueWithFees memory priorityVwF = subtractDarknodeFee(priorityTokenVolume);\r\n\r\n            return SettlementDetails({\r\n                leftVolume: 0,\r\n                rightVolume: 0,\r\n                leftTokenFee: priorityVwF.fees,\r\n                rightTokenFee: priorityVwF.fees,\r\n                leftTokenAddress: _tokens.priorityToken.addr,\r\n                rightTokenAddress: _tokens.priorityToken.addr\r\n            });\r\n        } else {\r\n            // Currently, at least one token must be Ethereum-based.\r\n            // This will be implemented in the future.\r\n            revert(\"non-eth atomic swaps are not supported\");\r\n        }\r\n    }\r\n\r\n    /// @notice Order parity is set by the order tokens are listed. This returns\r\n    /// whether an order is a buy or a sell.\r\n    /// @return true if _orderID is a buy order.\r\n    function isBuyOrder(bytes32 _orderID) private view returns (bool) {\r\n        uint64 tokens = orderDetails[_orderID].tokens;\r\n        uint32 firstToken = uint32(tokens >> 32);\r\n        uint32 secondaryToken = uint32(tokens);\r\n        return (firstToken < secondaryToken);\r\n    }\r\n\r\n    /// @return (value - fee, fee) where fee is 0.2% of value\r\n    function subtractDarknodeFee(uint256 _value) private pure returns (ValueWithFees memory) {\r\n        uint256 newValue = (_value * (DARKNODE_FEES_DENOMINATOR - DARKNODE_FEES_NUMERATOR)) / DARKNODE_FEES_DENOMINATOR;\r\n        return ValueWithFees(newValue, _value - newValue);\r\n    }\r\n\r\n    /// @notice Gets the order details of the priority and secondary token from\r\n    /// the RenExTokens contract and returns them as a single struct.\r\n    ///\r\n    /// @param _tokens The 64-bit combined token identifiers.\r\n    /// @return A TokenPair struct containing two TokenDetails structs.\r\n    function getTokenDetails(uint64 _tokens) private view returns (TokenPair memory) {\r\n        (\r\n            address priorityAddress,\r\n            uint8 priorityDecimals,\r\n            bool priorityRegistered\r\n        ) = renExTokensContract.tokens(uint32(_tokens >> 32));\r\n\r\n        (\r\n            address secondaryAddress,\r\n            uint8 secondaryDecimals,\r\n            bool secondaryRegistered\r\n        ) = renExTokensContract.tokens(uint32(_tokens));\r\n\r\n        return TokenPair({\r\n            priorityToken: RenExTokens.TokenDetails(priorityAddress, priorityDecimals, priorityRegistered),\r\n            secondaryToken: RenExTokens.TokenDetails(secondaryAddress, secondaryDecimals, secondaryRegistered)\r\n        });\r\n    }\r\n\r\n    /// @return true if _tokenAddress is 0x0, representing a token that is not\r\n    /// on Ethereum\r\n    function isEthereumBased(address _tokenAddress) private pure returns (bool) {\r\n        return (_tokenAddress != address(0x0));\r\n    }\r\n\r\n    /// @notice Computes (_numerator / _denominator) * 10 ** _scale\r\n    function joinFraction(uint256 _numerator, uint256 _denominator, int16 _scale) private pure returns (uint256) {\r\n        if (_scale >= 0) {\r\n            // Check that (10**_scale) doesn't overflow\r\n            assert(_scale <= 77); // log10(2**256) = 77.06\r\n            return _numerator.mul(10 ** uint256(_scale)) / _denominator;\r\n        } else {\r\n            /// @dev If _scale is less than -77, 10**-_scale would overflow.\r\n            // For now, -_scale > -24 (when a token has 0 decimals and\r\n            // VOLUME_OFFSET and PRICE_OFFSET are each 12). It is unlikely these\r\n            // will be increased to add to more than 77.\r\n            // assert((-_scale) <= 77); // log10(2**256) = 77.06\r\n            return (_numerator / _denominator) / 10 ** uint256(-_scale);\r\n        }\r\n    }\r\n}\r\n\r\n/// @notice RenExBrokerVerifier implements the BrokerVerifier contract,\r\n/// verifying broker signatures for order opening and fund withdrawal.\r\ncontract RenExBrokerVerifier is Ownable {\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    // Events\r\n    event LogBalancesContractUpdated(address previousBalancesContract, address nextBalancesContract);\r\n    event LogBrokerRegistered(address broker);\r\n    event LogBrokerDeregistered(address broker);\r\n\r\n    // Storage\r\n    mapping(address => bool) public brokers;\r\n    mapping(address => uint256) public traderNonces;\r\n\r\n    address public balancesContract;\r\n\r\n    modifier onlyBalancesContract() {\r\n        require(msg.sender == balancesContract, \"not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    constructor(string _VERSION) public {\r\n        VERSION = _VERSION;\r\n    }\r\n\r\n    /// @notice Allows the owner of the contract to update the address of the\r\n    /// RenExBalances contract.\r\n    ///\r\n    /// @param _balancesContract The address of the new balances contract\r\n    function updateBalancesContract(address _balancesContract) external onlyOwner {\r\n        emit LogBalancesContractUpdated(balancesContract, _balancesContract);\r\n\r\n        balancesContract = _balancesContract;\r\n    }\r\n\r\n    /// @notice Approved an address to sign order-opening and withdrawals.\r\n    /// @param _broker The address of the broker.\r\n    function registerBroker(address _broker) external onlyOwner {\r\n        require(!brokers[_broker], \"already registered\");\r\n        brokers[_broker] = true;\r\n        emit LogBrokerRegistered(_broker);\r\n    }\r\n\r\n    /// @notice Reverts the a broker's registration.\r\n    /// @param _broker The address of the broker.\r\n    function deregisterBroker(address _broker) external onlyOwner {\r\n        require(brokers[_broker], \"not registered\");\r\n        brokers[_broker] = false;\r\n        emit LogBrokerDeregistered(_broker);\r\n    }\r\n\r\n    /// @notice Verifies a broker's signature for an order opening.\r\n    /// The data signed by the broker is a prefixed message and the order ID.\r\n    ///\r\n    /// @param _trader The trader requesting the withdrawal.\r\n    /// @param _signature The 65-byte signature from the broker.\r\n    /// @param _orderID The 32-byte order ID.\r\n    /// @return True if the signature is valid, false otherwise.\r\n    function verifyOpenSignature(\r\n        address _trader,\r\n        bytes _signature,\r\n        bytes32 _orderID\r\n    ) external view returns (bool) {\r\n        bytes memory data = abi.encodePacked(\"Republic Protocol: open: \", _trader, _orderID);\r\n        address signer = Utils.addr(data, _signature);\r\n        return (brokers[signer] == true);\r\n    }\r\n\r\n    /// @notice Verifies a broker's signature for a trader withdrawal.\r\n    /// The data signed by the broker is a prefixed message, the trader address\r\n    /// and a 256-bit trader nonce, which is incremented every time a valid\r\n    /// signature is checked.\r\n    ///\r\n    /// @param _trader The trader requesting the withdrawal.\r\n    /// @param _signature 65-byte signature from the broker.\r\n    /// @return True if the signature is valid, false otherwise.\r\n    function verifyWithdrawSignature(\r\n        address _trader,\r\n        bytes _signature\r\n    ) external onlyBalancesContract returns (bool) {\r\n        bytes memory data = abi.encodePacked(\"Republic Protocol: withdraw: \", _trader, traderNonces[_trader]);\r\n        address signer = Utils.addr(data, _signature);\r\n        if (brokers[signer]) {\r\n            traderNonces[_trader] += 1;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n\r\n/// @notice RenExBalances is responsible for holding RenEx trader funds.\r\ncontract RenExBalances is Ownable {\r\n    using SafeMath for uint256;\r\n    using CompatibleERC20Functions for CompatibleERC20;\r\n\r\n    string public VERSION; // Passed in as a constructor parameter.\r\n\r\n    RenExSettlement public settlementContract;\r\n    RenExBrokerVerifier public brokerVerifierContract;\r\n    DarknodeRewardVault public rewardVaultContract;\r\n\r\n    /// @dev Should match the address in the DarknodeRewardVault\r\n    address constant public ETHEREUM = address(0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE);\r\n    \r\n    // Delay between a trader calling `withdrawSignal` and being able to call\r\n    // `withdraw` without a broker signature.\r\n    uint256 constant public SIGNAL_DELAY = 48 hours;\r\n\r\n    // Events\r\n    event LogBalanceDecreased(address trader, ERC20 token, uint256 value);\r\n    event LogBalanceIncreased(address trader, ERC20 token, uint256 value);\r\n    event LogRenExSettlementContractUpdated(address previousRenExSettlementContract, address newRenExSettlementContract);\r\n    event LogRewardVaultContractUpdated(address previousRewardVaultContract, address newRewardVaultContract);\r\n    event LogBrokerVerifierContractUpdated(address previousBrokerVerifierContract, address newBrokerVerifierContract);\r\n\r\n    // Storage\r\n    mapping(address => mapping(address => uint256)) public traderBalances;\r\n    mapping(address => mapping(address => uint256)) public traderWithdrawalSignals;\r\n\r\n    /// @notice The contract constructor.\r\n    ///\r\n    /// @param _VERSION A string defining the contract version.\r\n    /// @param _rewardVaultContract The address of the RewardVault contract.\r\n    constructor(\r\n        string _VERSION,\r\n        DarknodeRewardVault _rewardVaultContract,\r\n        RenExBrokerVerifier _brokerVerifierContract\r\n    ) public {\r\n        VERSION = _VERSION;\r\n        rewardVaultContract = _rewardVaultContract;\r\n        brokerVerifierContract = _brokerVerifierContract;\r\n    }\r\n\r\n    /// @notice Restricts a function to only being called by the RenExSettlement\r\n    /// contract.\r\n    modifier onlyRenExSettlementContract() {\r\n        require(msg.sender == address(settlementContract), \"not authorized\");\r\n        _;\r\n    }\r\n\r\n    /// @notice Restricts trader withdrawing to be called if a signature from a\r\n    /// RenEx broker is provided, or if a certain amount of time has passed\r\n    /// since a trader has called `signalBackupWithdraw`.\r\n    /// @dev If the trader is withdrawing after calling `signalBackupWithdraw`,\r\n    /// this will reset the time to zero, writing to storage.\r\n    modifier withBrokerSignatureOrSignal(address _token, bytes _signature) {\r\n        address trader = msg.sender;\r\n        if (brokerVerifierContract.verifyWithdrawSignature(trader, _signature)) {\r\n            _;\r\n        } else {\r\n            bool hasSignalled = traderWithdrawalSignals[trader][_token] != 0;\r\n            /* solium-disable-next-line security/no-block-members */\r\n            bool hasWaitedDelay = (now - traderWithdrawalSignals[trader][_token]) > SIGNAL_DELAY;\r\n            require(hasSignalled && hasWaitedDelay, \"not signalled\");\r\n            traderWithdrawalSignals[trader][_token] = 0;\r\n            _;\r\n        }\r\n    }\r\n\r\n    /// @notice Allows the owner of the contract to update the address of the\r\n    /// RenExSettlement contract.\r\n    ///\r\n    /// @param _newSettlementContract the address of the new settlement contract\r\n    function updateRenExSettlementContract(RenExSettlement _newSettlementContract) external onlyOwner {\r\n        emit LogRenExSettlementContractUpdated(settlementContract, _newSettlementContract);\r\n        settlementContract = _newSettlementContract;\r\n    }\r\n\r\n    /// @notice Allows the owner of the contract to update the address of the\r\n    /// DarknodeRewardVault contract.\r\n    ///\r\n    /// @param _newRewardVaultContract the address of the new reward vault contract\r\n    function updateRewardVaultContract(DarknodeRewardVault _newRewardVaultContract) external onlyOwner {\r\n        emit LogRewardVaultContractUpdated(rewardVaultContract, _newRewardVaultContract);\r\n        rewardVaultContract = _newRewardVaultContract;\r\n    }\r\n\r\n    /// @notice Allows the owner of the contract to update the address of the\r\n    /// RenExBrokerVerifier contract.\r\n    ///\r\n    /// @param _newBrokerVerifierContract the address of the new broker verifier contract\r\n    function updateBrokerVerifierContract(RenExBrokerVerifier _newBrokerVerifierContract) external onlyOwner {\r\n        emit LogBrokerVerifierContractUpdated(brokerVerifierContract, _newBrokerVerifierContract);\r\n        brokerVerifierContract = _newBrokerVerifierContract;\r\n    }\r\n\r\n    /// @notice Transfer a token value from one trader to another, transferring\r\n    /// a fee to the RewardVault. Can only be called by the RenExSettlement\r\n    /// contract.\r\n    ///\r\n    /// @param _traderFrom The address of the trader to decrement the balance of.\r\n    /// @param _traderTo The address of the trader to increment the balance of.\r\n    /// @param _token The token's address.\r\n    /// @param _value The number of tokens to decrement the balance by (in the\r\n    ///        token's smallest unit).\r\n    /// @param _fee The fee amount to forward on to the RewardVault.\r\n    /// @param _feePayee The recipient of the fee.\r\n    function transferBalanceWithFee(address _traderFrom, address _traderTo, address _token, uint256 _value, uint256 _fee, address _feePayee)\r\n    external onlyRenExSettlementContract {\r\n        require(traderBalances[_traderFrom][_token] >= _fee, \"insufficient funds for fee\");\r\n\r\n        if (address(_token) == ETHEREUM) {\r\n            rewardVaultContract.deposit.value(_fee)(_feePayee, ERC20(_token), _fee);\r\n        } else {\r\n            CompatibleERC20(_token).safeApprove(rewardVaultContract, _fee);\r\n            rewardVaultContract.deposit(_feePayee, ERC20(_token), _fee);\r\n        }\r\n        privateDecrementBalance(_traderFrom, ERC20(_token), _value + _fee);\r\n        if (_value > 0) {\r\n            privateIncrementBalance(_traderTo, ERC20(_token), _value);\r\n        }\r\n    }\r\n\r\n    /// @notice Deposits ETH or an ERC20 token into the contract.\r\n    ///\r\n    /// @param _token The token's address (must be a registered token).\r\n    /// @param _value The amount to deposit in the token's smallest unit.\r\n    function deposit(ERC20 _token, uint256 _value) external payable {\r\n        address trader = msg.sender;\r\n\r\n        if (address(_token) == ETHEREUM) {\r\n            require(msg.value == _value, \"mismatched value parameter and tx value\");\r\n        } else {\r\n            require(msg.value == 0, \"unexpected ether transfer\");\r\n            CompatibleERC20(_token).safeTransferFromWithFees(trader, this, _value);\r\n        }\r\n        privateIncrementBalance(trader, _token, _value);\r\n    }\r\n\r\n    /// @notice Withdraws ETH or an ERC20 token from the contract. A broker\r\n    /// signature is required to guarantee that the trader has a sufficient\r\n    /// balance after accounting for open orders. As a trustless backup,\r\n    /// traders can withdraw 48 hours after calling `signalBackupWithdraw`.\r\n    ///\r\n    /// @param _token The token's address.\r\n    /// @param _value The amount to withdraw in the token's smallest unit.\r\n    /// @param _signature The broker signature\r\n    function withdraw(ERC20 _token, uint256 _value, bytes _signature) external withBrokerSignatureOrSignal(_token, _signature) {\r\n        address trader = msg.sender;\r\n\r\n        privateDecrementBalance(trader, _token, _value);\r\n        if (address(_token) == ETHEREUM) {\r\n            trader.transfer(_value);\r\n        } else {\r\n            CompatibleERC20(_token).safeTransfer(trader, _value);\r\n        }\r\n    }\r\n\r\n    /// @notice A trader can withdraw without needing a broker signature if they\r\n    /// first call `signalBackupWithdraw` for the token they want to withdraw.\r\n    /// The trader can only withdraw the particular token once for each call to\r\n    /// this function. Traders can signal the intent to withdraw multiple\r\n    /// tokens.\r\n    /// Once this function is called, brokers will not sign order-opens for the\r\n    /// trader until the trader has withdrawn, guaranteeing that they won't have\r\n    /// orders open for the particular token.\r\n    function signalBackupWithdraw(address _token) external {\r\n        /* solium-disable-next-line security/no-block-members */\r\n        traderWithdrawalSignals[msg.sender][_token] = now;\r\n    }\r\n\r\n    function privateIncrementBalance(address _trader, ERC20 _token, uint256 _value) private {\r\n        traderBalances[_trader][_token] = traderBalances[_trader][_token].add(_value);\r\n\r\n        emit LogBalanceIncreased(_trader, _token, _value);\r\n    }\r\n\r\n    function privateDecrementBalance(address _trader, ERC20 _token, uint256 _value) private {\r\n        require(traderBalances[_trader][_token] >= _value, \"insufficient funds\");\r\n        traderBalances[_trader][_token] = traderBalances[_trader][_token].sub(_value);\r\n\r\n        emit LogBalanceDecreased(_trader, _token, _value);\r\n    }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"brokerVerifierContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newSettlementContract\",\"type\":\"address\"}],\"name\":\"updateRenExSettlementContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardVaultContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_signature\",\"type\":\"bytes\"}],\"name\":\"withdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_traderFrom\",\"type\":\"address\"},{\"name\":\"_traderTo\",\"type\":\"address\"},{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"},{\"name\":\"_fee\",\"type\":\"uint256\"},{\"name\":\"_feePayee\",\"type\":\"address\"}],\"name\":\"transferBalanceWithFee\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"},{\"name\":\"_value\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBrokerVerifierContract\",\"type\":\"address\"}],\"name\":\"updateBrokerVerifierContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"renounceOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_token\",\"type\":\"address\"}],\"name\":\"signalBackupWithdraw\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"traderBalances\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"SIGNAL_DELAY\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newRewardVaultContract\",\"type\":\"address\"}],\"name\":\"updateRewardVaultContract\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"settlementContract\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOwner\",\"type\":\"address\"}],\"name\":\"transferOwnership\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ETHEREUM\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"address\"}],\"name\":\"traderWithdrawalSignals\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"VERSION\",\"outputs\":[{\"name\":\"\",\"type\":\"string\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"name\":\"_VERSION\",\"type\":\"string\"},{\"name\":\"_rewardVaultContract\",\"type\":\"address\"},{\"name\":\"_brokerVerifierContract\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogBalanceDecreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"trader\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"token\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"value\",\"type\":\"uint256\"}],\"name\":\"LogBalanceIncreased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousRenExSettlementContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newRenExSettlementContract\",\"type\":\"address\"}],\"name\":\"LogRenExSettlementContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousRewardVaultContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newRewardVaultContract\",\"type\":\"address\"}],\"name\":\"LogRewardVaultContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"previousBrokerVerifierContract\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"newBrokerVerifierContract\",\"type\":\"address\"}],\"name\":\"LogBrokerVerifierContractUpdated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"}],\"name\":\"OwnershipRenounced\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"previousOwner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"newOwner\",\"type\":\"address\"}],\"name\":\"OwnershipTransferred\",\"type\":\"event\"}]","ContractName":"RenExBalances","CompilerVersion":"v0.4.24+commit.e67f0147","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000880407c9cd119bef48b1821cdfc434e3ca3cd58800000000000000000000000031a0d1a199631d244761eeba67e8501296d2e383000000000000000000000000000000000000000000000000000000000000000d6d61696e6e65742d312e302e3000000000000000000000000000000000000000","Library":"","SwarmSource":"bzzr://dde6b2569bdae7216ddb4d7e826136cdafba8370bb67cf237e90222449a5578a"}]}