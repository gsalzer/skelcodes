{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.23;\r\n\r\n/* Controls state and access rights for contract functions\r\n * @title Operational Control\r\n * @author Fazri Zubair & Farhan Khwaja (Lucid Sight, Inc.)\r\n * Inspired and adapted from contract created by OpenZeppelin\r\n * Ref: https://github.com/OpenZeppelin/zeppelin-solidity/\r\n */\r\ncontract OperationalControl {\r\n    // Facilitates access & control for the game.\r\n    // Roles:\r\n    //  -The Managers (Primary/Secondary): Has universal control of all elements (No ability to withdraw)\r\n    //  -The Banker: The Bank can withdraw funds and adjust fees / prices.\r\n    //  -otherManagers: Contracts that need access to functions for gameplay\r\n\r\n    /// @dev Emited when contract is upgraded\r\n    event ContractUpgrade(address newContract);\r\n\r\n    // The addresses of the accounts (or contracts) that can execute actions within each roles.\r\n    address public managerPrimary;\r\n    address public managerSecondary;\r\n    address public bankManager;\r\n\r\n    // Contracts that require access for gameplay\r\n    mapping(address => uint8) public otherManagers;\r\n\r\n    // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked\r\n    bool public paused = false;\r\n\r\n    // @dev Keeps track whether the contract erroredOut. When that is true, most actions are blocked & refund can be claimed\r\n    bool public error = false;\r\n\r\n    /// @dev Operation modifiers for limiting access\r\n    modifier onlyManager() {\r\n        require(msg.sender == managerPrimary || msg.sender == managerSecondary);\r\n        _;\r\n    }\r\n\r\n    modifier onlyBanker() {\r\n        require(msg.sender == bankManager);\r\n        _;\r\n    }\r\n\r\n    modifier onlyOtherManagers() {\r\n        require(otherManagers[msg.sender] == 1);\r\n        _;\r\n    }\r\n\r\n\r\n    modifier anyOperator() {\r\n        require(\r\n            msg.sender == managerPrimary ||\r\n            msg.sender == managerSecondary ||\r\n            msg.sender == bankManager ||\r\n            otherManagers[msg.sender] == 1\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Other Manager. (State = 1 is active, 0 is disabled)\r\n    function setOtherManager(address _newOp, uint8 _state) external onlyManager {\r\n        require(_newOp != address(0));\r\n\r\n        otherManagers[_newOp] = _state;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Primary Manager.\r\n    function setPrimaryManager(address _newGM) external onlyManager {\r\n        require(_newGM != address(0));\r\n\r\n        managerPrimary = _newGM;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Secondary Manager.\r\n    function setSecondaryManager(address _newGM) external onlyManager {\r\n        require(_newGM != address(0));\r\n\r\n        managerSecondary = _newGM;\r\n    }\r\n\r\n    /// @dev Assigns a new address to act as the Banker.\r\n    function setBanker(address _newBK) external onlyManager {\r\n        require(_newBK != address(0));\r\n\r\n        bankManager = _newBK;\r\n    }\r\n\r\n    /*** Pausable functionality adapted from OpenZeppelin ***/\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS NOT paused\r\n    modifier whenNotPaused() {\r\n        require(!paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract IS paused\r\n    modifier whenPaused {\r\n        require(paused);\r\n        _;\r\n    }\r\n\r\n    /// @dev Modifier to allow actions only when the contract has Error\r\n    modifier whenError {\r\n        require(error);\r\n        _;\r\n    }\r\n\r\n    /// @dev Called by any Operator role to pause the contract.\r\n    /// Used only if a bug or exploit is discovered (Here to limit losses / damage)\r\n    function pause() external onlyManager whenNotPaused {\r\n        paused = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\r\n    /// @notice This is public rather than external so it can be called by derived contracts. \r\n    function unpause() public onlyManager whenPaused {\r\n        // can't unpause if contract was upgraded\r\n        paused = false;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\r\n    /// @notice This is public rather than external so it can be called by derived contracts. \r\n    function hasError() public onlyManager whenPaused {\r\n        error = true;\r\n    }\r\n\r\n    /// @dev Unpauses the smart contract. Can only be called by the Game Master\r\n    /// @notice This is public rather than external so it can be called by derived contracts. \r\n    function noError() public onlyManager whenPaused {\r\n        error = false;\r\n    }\r\n}\r\n\r\ncontract CSCNFTFactory {\r\n\r\n   \r\n    /** Public Functions */\r\n\r\n    function getAssetDetails(uint256 _assetId) public view returns(\r\n        uint256 assetId,\r\n        uint256 ownersIndex,\r\n        uint256 assetTypeSeqId,\r\n        uint256 assetType,\r\n        uint256 createdTimestamp,\r\n        uint256 isAttached,\r\n        address creator,\r\n        address owner\r\n    );\r\n\r\n    function getAssetDetailsURI(uint256 _assetId) public view returns(\r\n        uint256 assetId,\r\n        uint256 ownersIndex,\r\n        uint256 assetTypeSeqId,\r\n        uint256 assetType,\r\n        uint256 createdTimestamp,\r\n        uint256 isAttached,\r\n        address creator,\r\n        address owner,\r\n        string metaUriAddress\r\n    );\r\n\r\n    function getAssetRawMeta(uint256 _assetId) public view returns(\r\n        uint256 dataA,\r\n        uint128 dataB\r\n    );\r\n\r\n    function getAssetIdItemType(uint256 _assetId) public view returns(\r\n        uint256 assetType\r\n    );\r\n\r\n    function getAssetIdTypeSequenceId(uint256 _assetId) public view returns(\r\n        uint256 assetTypeSequenceId\r\n    );\r\n    \r\n    function getIsNFTAttached( uint256 _tokenId) \r\n    public view returns(\r\n        uint256 isAttached\r\n    );\r\n\r\n    function getAssetIdCreator(uint256 _assetId) public view returns(\r\n        address creator\r\n    );\r\n    function getAssetIdOwnerAndOIndex(uint256 _assetId) public view returns(\r\n        address owner,\r\n        uint256 ownerIndex\r\n    );\r\n    function getAssetIdOwnerIndex(uint256 _assetId) public view returns(\r\n        uint256 ownerIndex\r\n    );\r\n\r\n    function getAssetIdOwner(uint256 _assetId) public view returns(\r\n        address owner\r\n    );\r\n\r\n    function isAssetIdOwnerOrApproved(address requesterAddress, uint256 _assetId) public view returns(\r\n        bool\r\n    );\r\n    /// @param _owner The owner whose ships tokens we are interested in.\r\n    /// @dev This method MUST NEVER be called by smart contract code. First, it's fairly\r\n    ///  expensive (it walks the entire NFT owners array looking for NFT belonging to owner),\r\n    ///  but it also returns a dynamic array, which is only supported for web3 calls, and\r\n    ///  not contract-to-contract calls.\r\n    function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens);\r\n    // Get the name of the Asset type\r\n    function getTypeName (uint32 _type) public returns(string);\r\n    function RequestDetachment(\r\n        uint256 _tokenId\r\n    )\r\n        public;\r\n    function AttachAsset(\r\n        uint256 _tokenId\r\n    )\r\n        public;\r\n    function BatchAttachAssets(uint256[10] _ids) public;\r\n    function BatchDetachAssets(uint256[10] _ids) public;\r\n    function RequestDetachmentOnPause (uint256 _tokenId) public;\r\n    function burnAsset(uint256 _assetID) public;\r\n    function balanceOf(address _owner) public view returns (uint256 _balance);\r\n    function ownerOf(uint256 _tokenId) public view returns (address _owner);\r\n    function exists(uint256 _tokenId) public view returns (bool _exists);\r\n    function approve(address _to, uint256 _tokenId) public;\r\n    function getApproved(uint256 _tokenId)\r\n        public view returns (address _operator);\r\n    function setApprovalForAll(address _operator, bool _approved) public;\r\n    function isApprovedForAll(address _owner, address _operator)\r\n        public view returns (bool);\r\n    function transferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(address _from, address _to, uint256 _tokenId) public;\r\n    function safeTransferFrom(\r\n        address _from,\r\n        address _to,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public;\r\n\r\n}\r\n\r\n/**\r\n * @title ERC721 token receiver interface\r\n * @dev Interface for any contract that wants to support safeTransfers\r\n *  from ERC721 asset contracts.\r\n */\r\ncontract ERC721Receiver {\r\n    /**\r\n    * @dev Magic value to be returned upon successful reception of an NFT\r\n    *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`,\r\n    *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\r\n    */\r\n    bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba;\r\n\r\n    /**\r\n    * @notice Handle the receipt of an NFT\r\n    * @dev The ERC721 smart contract calls this function on the recipient\r\n    *  after a `safetransfer`. This function MAY throw to revert and reject the\r\n    *  transfer. This function MUST use 50,000 gas or less. Return of other\r\n    *  than the magic value MUST result in the transaction being reverted.\r\n    *  Note: the contract address is always the message sender.\r\n    * @param _from The sending address\r\n    * @param _tokenId The NFT identifier which is being transfered\r\n    * @param _data Additional data with no specified format\r\n    * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`\r\n    */\r\n    function onERC721Received(\r\n        address _from,\r\n        uint256 _tokenId,\r\n        bytes _data\r\n    )\r\n        public\r\n        returns(bytes4);\r\n}\r\ncontract ERC721Holder is ERC721Receiver {\r\n    function onERC721Received(address, uint256, bytes) public returns(bytes4) {\r\n        return ERC721_RECEIVED;\r\n    }\r\n}\r\n\r\ncontract CSCTimeSaleManager is ERC721Holder, OperationalControl {\r\n    //DATATYPES & CONSTANTS\r\n    struct CollectibleSale {\r\n        // Current owner of NFT (ERC721)\r\n        address seller;\r\n        // Price (in wei) at beginning of sale (For Buying)\r\n        uint256 startingPrice;\r\n        // Price (in wei) at end of sale (For Buying)\r\n        uint256 endingPrice;\r\n        // Duration (in seconds) of sale, 2592000 = 30 days\r\n        uint256 duration;\r\n        // Time when sale started\r\n        // NOTE: 0 if this sale has been concluded\r\n        uint64 startedAt;\r\n        // Flag denoting is the Sale still active\r\n        bool isActive;\r\n        // address of the wallet who bought the asset\r\n        address buyer;\r\n        // ERC721 AssetID\r\n        uint256 tokenId;\r\n    }\r\n    struct PastSales {\r\n        uint256[5] sales;\r\n    }\r\n\r\n    // CSCNTFAddress\r\n    address public NFTAddress;\r\n\r\n    // Map from token to their corresponding sale.\r\n    mapping (uint256 => CollectibleSale) public tokenIdToSale;\r\n\r\n    // Count of AssetType Sales\r\n    mapping (uint256 => uint256) public assetTypeSaleCount;\r\n\r\n    // Last 5 Prices of AssetType Sales\r\n    mapping (uint256 => PastSales) internal assetTypeSalePrices;\r\n\r\n    uint256 public avgSalesToCount = 5;\r\n\r\n    // type to sales of type\r\n    mapping(uint256 => uint256[]) public assetTypeSalesTokenId;\r\n\r\n    event SaleWinner(address owner, uint256 collectibleId, uint256 buyingPrice);\r\n    event SaleCreated(uint256 tokenID, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint64 startedAt);\r\n    event SaleCancelled(address seller, uint256 collectibleId);\r\n\r\n    constructor() public {\r\n        require(msg.sender != address(0));\r\n        paused = true;\r\n        error = false;\r\n        managerPrimary = msg.sender;\r\n        managerSecondary = msg.sender;\r\n        bankManager = msg.sender;\r\n    }\r\n\r\n    function  setNFTAddress(address _address) public onlyManager {\r\n        NFTAddress = _address;\r\n    }\r\n\r\n    function setAvgSalesCount(uint256 _count) public onlyManager  {\r\n        avgSalesToCount = _count;\r\n    }\r\n\r\n    /// @dev Creates and begins a new sale.\r\n    function CreateSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\r\n        _createSale(_tokenId, _startingPrice, _endingPrice, _duration, _seller);\r\n    }\r\n\r\n    function BatchCreateSales(uint256[] _tokenIds, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\r\n        uint256 _tokenId;\r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n            _tokenId = _tokenIds[i];\r\n            _createSale(_tokenId, _startingPrice, _endingPrice, _duration, _seller);\r\n        }\r\n    }\r\n\r\n    function CreateSaleAvgPrice(uint256 _tokenId, uint256 _margin, uint _minPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\r\n        var cscNFT = CSCNFTFactory(NFTAddress);\r\n        uint256 assetType = cscNFT.getAssetIdItemType(_tokenId);\r\n        // Avg Price of last sales\r\n        uint256 salePrice = GetAssetTypeAverageSalePrice(assetType);\r\n\r\n        //  0-10,000 is mapped to 0%-100% - will be typically 12000 or 120%\r\n        salePrice = salePrice * _margin / 10000;\r\n\r\n        if(salePrice < _minPrice) {\r\n            salePrice = _minPrice;\r\n        } \r\n       \r\n        _createSale(_tokenId, salePrice, _endingPrice, _duration, _seller);\r\n    }\r\n\r\n    function BatchCreateSaleAvgPrice(uint256[] _tokenIds, uint256 _margin, uint _minPrice, uint256 _endingPrice, uint64 _duration, address _seller) public anyOperator {\r\n        var cscNFT = CSCNFTFactory(NFTAddress);\r\n        uint256 assetType;\r\n        uint256 _tokenId;\r\n        uint256 salePrice;\r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n            _tokenId = _tokenIds[i];\r\n            assetType = cscNFT.getAssetIdItemType(_tokenId);\r\n            // Avg Price of last sales\r\n            salePrice = GetAssetTypeAverageSalePrice(assetType);\r\n\r\n            //  0-10,000 is mapped to 0%-100% - will be typically 12000 or 120%\r\n            salePrice = salePrice * _margin / 10000;\r\n\r\n            if(salePrice < _minPrice) {\r\n                salePrice = _minPrice;\r\n            } \r\n            \r\n            _tokenId = _tokenIds[i];\r\n            _createSale(_tokenId, salePrice, _endingPrice, _duration, _seller);\r\n        }\r\n    }\r\n\r\n    function BatchCancelSales(uint256[] _tokenIds) public anyOperator {\r\n        uint256 _tokenId;\r\n        for (uint256 i = 0; i < _tokenIds.length; ++i) {\r\n            _tokenId = _tokenIds[i];\r\n            _cancelSale(_tokenId);\r\n        }\r\n    }\r\n\r\n    function CancelSale(uint256 _assetId) public anyOperator {\r\n        _cancelSale(_assetId);\r\n    }\r\n\r\n    function GetCurrentSalePrice(uint256 _assetId) external view returns(uint256 _price) {\r\n        CollectibleSale memory _sale = tokenIdToSale[_assetId];\r\n        \r\n        return _currentPrice(_sale);\r\n    }\r\n\r\n    function GetCurrentTypeSalePrice(uint256 _assetType) external view returns(uint256 _price) {\r\n        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\r\n        return _currentPrice(_sale);\r\n    }\r\n\r\n    function GetCurrentTypeDuration(uint256 _assetType) external view returns(uint256 _duration) {\r\n        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\r\n        return  _sale.duration;\r\n    }\r\n\r\n    function GetCurrentTypeStartTime(uint256 _assetType) external view returns(uint256 _startedAt) {\r\n        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\r\n        return  _sale.startedAt;\r\n    }\r\n\r\n    function GetCurrentTypeSaleItem(uint256 _assetType) external view returns(address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, uint256 tokenId) {\r\n        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\r\n        return (\r\n            _sale.seller,\r\n            _sale.startingPrice,\r\n            _sale.endingPrice,\r\n            _sale.duration,\r\n            _sale.startedAt,\r\n            _sale.tokenId\r\n        );\r\n    }\r\n\r\n    function GetCurrentTypeSaleCount(uint256 _assetType) external view returns(uint256 _count) {\r\n        return assetTypeSalesTokenId[_assetType].length;\r\n    }\r\n\r\n    function BuyCurrentTypeOfAsset(uint256 _assetType) external whenNotPaused payable {\r\n        require(msg.sender != address(0));\r\n        require(msg.sender != address(this));\r\n\r\n        CollectibleSale memory _sale = tokenIdToSale[assetTypeSalesTokenId[_assetType][0]];\r\n        require(_isOnSale(_sale));\r\n\r\n        _buy(_sale.tokenId, msg.sender, msg.value);\r\n    }\r\n\r\n    /// @dev BuyNow Function which call the interncal buy function\r\n    /// after doing all the pre-checks required to initiate a buy\r\n    function BuyAsset(uint256 _assetId) external whenNotPaused payable {\r\n        require(msg.sender != address(0));\r\n        require(msg.sender != address(this));\r\n        CollectibleSale memory _sale = tokenIdToSale[_assetId];\r\n        require(_isOnSale(_sale));\r\n        \r\n        //address seller = _sale.seller;\r\n\r\n        _buy(_assetId, msg.sender, msg.value);\r\n    }\r\n\r\n    function GetAssetTypeAverageSalePrice(uint256 _assetType) public view returns (uint256) {\r\n        uint256 sum = 0;\r\n        for (uint256 i = 0; i < avgSalesToCount; i++) {\r\n            sum += assetTypeSalePrices[_assetType].sales[i];\r\n        }\r\n        return sum / 5;\r\n    }\r\n\r\n    /// @dev Override unpause so it requires all external contract addresses\r\n    ///  to be set before contract can be unpaused. Also, we can't have\r\n    ///  newContractAddress set either, because then the contract was upgraded.\r\n    /// @notice This is public rather than external so we can call super.unpause\r\n    ///  without using an expensive CALL.\r\n    function unpause() public anyOperator whenPaused {\r\n        // Actually unpause the contract.\r\n        super.unpause();\r\n    }\r\n\r\n    /// @dev Remove all Ether from the contract, which is the owner's cuts\r\n    ///  as well as any Ether sent directly to the contract address.\r\n    ///  Always transfers to the NFT (ERC721) contract, but can be called either by\r\n    ///  the owner or the NFT (ERC721) contract.\r\n    function withdrawBalance() public onlyBanker {\r\n        // We are using this boolean method to make sure that even if one fails it will still work\r\n        bankManager.transfer(address(this).balance);\r\n    }\r\n\r\n    /// @dev Returns sales info for an CSLCollectibles (ERC721) on sale.\r\n    /// @param _assetId - ID of the token on sale\r\n    function getSale(uint256 _assetId) external view returns (address seller, uint256 startingPrice, uint256 endingPrice, uint256 duration, uint256 startedAt, bool isActive, address buyer, uint256 tokenId) {\r\n        CollectibleSale memory sale = tokenIdToSale[_assetId];\r\n        require(_isOnSale(sale));\r\n        return (\r\n            sale.seller,\r\n            sale.startingPrice,\r\n            sale.endingPrice,\r\n            sale.duration,\r\n            sale.startedAt,\r\n            sale.isActive,\r\n            sale.buyer,\r\n            sale.tokenId\r\n        );\r\n    }\r\n\r\n\r\n    /** Internal Functions */\r\n\r\n    function _createSale(uint256 _tokenId, uint256 _startingPrice, uint256 _endingPrice, uint64 _duration, address _seller) internal {\r\n        var cscNFT = CSCNFTFactory(NFTAddress);\r\n\r\n        require(cscNFT.isAssetIdOwnerOrApproved(this, _tokenId) == true);\r\n        \r\n        CollectibleSale memory onSale = tokenIdToSale[_tokenId];\r\n        require(onSale.isActive == false);\r\n\r\n        // Sanity check that no inputs overflow how many bits we've allocated\r\n        // to store them in the sale struct.\r\n        require(_startingPrice == uint256(uint128(_startingPrice)));\r\n        require(_endingPrice == uint256(uint128(_endingPrice)));\r\n        require(_duration == uint256(uint64(_duration)));\r\n\r\n        //Transfer ownership if needed\r\n        if(cscNFT.ownerOf(_tokenId) != address(this)) {\r\n            \r\n            require(cscNFT.isApprovedForAll(msg.sender, this) == true);\r\n\r\n            cscNFT.safeTransferFrom(cscNFT.ownerOf(_tokenId), this, _tokenId);\r\n        }\r\n\r\n        CollectibleSale memory sale = CollectibleSale(\r\n            _seller,\r\n            uint128(_startingPrice),\r\n            uint128(_endingPrice),\r\n            uint64(_duration),\r\n            uint64(now),\r\n            true,\r\n            address(0),\r\n            uint256(_tokenId)\r\n        );\r\n        _addSale(_tokenId, sale);\r\n    }\r\n\r\n    /// @dev Adds an sale to the list of open sales. Also fires the\r\n    ///  SaleCreated event.\r\n    function _addSale(uint256 _assetId, CollectibleSale _sale) internal {\r\n        // Require that all sales have a duration of\r\n        // at least one minute.\r\n        require(_sale.duration >= 1 minutes);\r\n        \r\n        tokenIdToSale[_assetId] = _sale;\r\n\r\n        var cscNFT = CSCNFTFactory(NFTAddress);\r\n        uint256 assetType = cscNFT.getAssetIdItemType(_assetId);\r\n        assetTypeSalesTokenId[assetType].push(_assetId);\r\n\r\n        SaleCreated(\r\n            uint256(_assetId),\r\n            uint256(_sale.startingPrice),\r\n            uint256(_sale.endingPrice),\r\n            uint256(_sale.duration),\r\n            uint64(_sale.startedAt)\r\n        );\r\n    }\r\n\r\n    /// @dev Returns current price of a Collectible (ERC721) on sale. Broken into two\r\n    ///  functions (this one, that computes the duration from the sale\r\n    ///  structure, and the other that does the price computation) so we\r\n    ///  can easily test that the price computation works correctly.\r\n    function _currentPrice(CollectibleSale memory _sale) internal view returns (uint256) {\r\n        uint256 secondsPassed = 0;\r\n\r\n        // A bit of insurance against negative values (or wraparound).\r\n        // Probably not necessary (since Ethereum guarnatees that the\r\n        // now variable doesn't ever go backwards).\r\n        if (now > _sale.startedAt) {\r\n            secondsPassed = now - _sale.startedAt;\r\n        }\r\n\r\n        return _computeCurrentPrice(\r\n            _sale.startingPrice,\r\n            _sale.endingPrice,\r\n            _sale.duration,\r\n            secondsPassed\r\n        );\r\n    }\r\n\r\n    /// @dev Computes the current price of an sale. Factored out\r\n    ///  from _currentPrice so we can run extensive unit tests.\r\n    ///  When testing, make this function public and turn on\r\n    ///  `Current price computation` test suite.\r\n    function _computeCurrentPrice(uint256 _startingPrice, uint256 _endingPrice, uint256 _duration, uint256 _secondsPassed) internal pure returns (uint256) {\r\n        // NOTE: We don't use SafeMath (or similar) in this function because\r\n        //  all of our public functions carefully cap the maximum values for\r\n        //  time (at 64-bits) and currency (at 128-bits). _duration is\r\n        //  also known to be non-zero (see the require() statement in\r\n        //  _addSale())\r\n        if (_secondsPassed >= _duration) {\r\n            // We've reached the end of the dynamic pricing portion\r\n            // of the sale, just return the end price.\r\n            return _endingPrice;\r\n        } else {\r\n            // Starting price can be higher than ending price (and often is!), so\r\n            // this delta can be negative.\r\n            int256 totalPriceChange = int256(_endingPrice) - int256(_startingPrice);\r\n\r\n            // This multiplication can't overflow, _secondsPassed will easily fit within\r\n            // 64-bits, and totalPriceChange will easily fit within 128-bits, their product\r\n            // will always fit within 256-bits.\r\n            int256 currentPriceChange = totalPriceChange * int256(_secondsPassed) / int256(_duration);\r\n\r\n            // currentPriceChange can be negative, but if so, will have a magnitude\r\n            // less that _startingPrice. Thus, this result will always end up positive.\r\n            int256 currentPrice = int256(_startingPrice) + currentPriceChange;\r\n\r\n            return uint256(currentPrice);\r\n        }\r\n    }\r\n\r\n    function _buy(uint256 _assetId, address _buyer, uint256 _price) internal {\r\n\r\n        CollectibleSale storage _sale = tokenIdToSale[_assetId];\r\n\r\n        // Check that the bid is greater than or equal to the current buyOut price\r\n        uint256 currentPrice = _currentPrice(_sale);\r\n\r\n        require(_price >= currentPrice);\r\n        _sale.buyer = _buyer;\r\n        _sale.isActive = false;\r\n\r\n        _removeSale(_assetId);\r\n\r\n        uint256 bidExcess = _price - currentPrice;\r\n        _buyer.transfer(bidExcess);\r\n\r\n        var cscNFT = CSCNFTFactory(NFTAddress);\r\n        uint256 assetType = cscNFT.getAssetIdItemType(_assetId);\r\n        _updateSaleAvgHistory(assetType, _price);\r\n        cscNFT.safeTransferFrom(this, _buyer, _assetId);\r\n\r\n        emit SaleWinner(_buyer, _assetId, _price);\r\n    }\r\n\r\n    function _cancelSale (uint256 _assetId) internal {\r\n        CollectibleSale storage _sale = tokenIdToSale[_assetId];\r\n\r\n        require(_sale.isActive == true);\r\n\r\n        address sellerAddress = _sale.seller;\r\n\r\n        _removeSale(_assetId);\r\n\r\n        var cscNFT = CSCNFTFactory(NFTAddress);\r\n\r\n        cscNFT.safeTransferFrom(this, sellerAddress, _assetId);\r\n\r\n        emit SaleCancelled(sellerAddress, _assetId);\r\n    }\r\n    \r\n    /// @dev Returns true if the FT (ERC721) is on sale.\r\n    function _isOnSale(CollectibleSale memory _sale) internal view returns (bool) {\r\n        return (_sale.startedAt > 0 && _sale.isActive);\r\n    }\r\n\r\n    function _updateSaleAvgHistory(uint256 _assetType, uint256 _price) internal {\r\n        assetTypeSaleCount[_assetType] += 1;\r\n        assetTypeSalePrices[_assetType].sales[assetTypeSaleCount[_assetType] % avgSalesToCount] = _price;\r\n    }\r\n\r\n    /// @dev Removes an sale from the list of open sales.\r\n    /// @param _assetId - ID of the token on sale\r\n    function _removeSale(uint256 _assetId) internal {\r\n        delete tokenIdToSale[_assetId];\r\n\r\n        var cscNFT = CSCNFTFactory(NFTAddress);\r\n        uint256 assetType = cscNFT.getAssetIdItemType(_assetId);\r\n\r\n        bool hasFound = false;\r\n        for (uint i = 0; i < assetTypeSalesTokenId[assetType].length; i++) {\r\n            if ( assetTypeSalesTokenId[assetType][i] == _assetId) {\r\n                hasFound = true;\r\n            }\r\n            if(hasFound == true) {\r\n                if(i+1 < assetTypeSalesTokenId[assetType].length)\r\n                    assetTypeSalesTokenId[assetType][i] = assetTypeSalesTokenId[assetType][i+1];\r\n                else \r\n                    delete assetTypeSalesTokenId[assetType][i];\r\n            }\r\n        }\r\n        assetTypeSalesTokenId[assetType].length--;\r\n    }\r\n\r\n}","ABI":"[{\"constant\":false,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"BuyAsset\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"otherManagers\",\"outputs\":[{\"name\":\"\",\"type\":\"uint8\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_margin\",\"type\":\"uint256\"},{\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint64\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"BatchCreateSaleAvgPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"NFTAddress\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"name\":\"setAvgSalesCount\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"tokenIdToSale\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint64\"},{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unpause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetType\",\"type\":\"uint256\"}],\"name\":\"GetCurrentTypeDuration\",\"outputs\":[{\"name\":\"_duration\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint64\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"CreateSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"paused\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawBalance\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetTypeSaleCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_address\",\"type\":\"address\"}],\"name\":\"setNFTAddress\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"CancelSale\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"GetCurrentSalePrice\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetType\",\"type\":\"uint256\"}],\"name\":\"GetCurrentTypeSalePrice\",\"outputs\":[{\"name\":\"_price\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"},{\"name\":\"_startingPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint64\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"BatchCreateSales\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenIds\",\"type\":\"uint256[]\"}],\"name\":\"BatchCancelSales\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setSecondaryManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"assetTypeSalesTokenId\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"pause\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetType\",\"type\":\"uint256\"}],\"name\":\"GetCurrentTypeSaleItem\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"noError\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetType\",\"type\":\"uint256\"}],\"name\":\"GetCurrentTypeStartTime\",\"outputs\":[{\"name\":\"_startedAt\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"hasError\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerPrimary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newOp\",\"type\":\"address\"},{\"name\":\"_state\",\"type\":\"uint8\"}],\"name\":\"setOtherManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newGM\",\"type\":\"address\"}],\"name\":\"setPrimaryManager\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"error\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetType\",\"type\":\"uint256\"}],\"name\":\"GetAssetTypeAverageSalePrice\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_tokenId\",\"type\":\"uint256\"},{\"name\":\"_margin\",\"type\":\"uint256\"},{\"name\":\"_minPrice\",\"type\":\"uint256\"},{\"name\":\"_endingPrice\",\"type\":\"uint256\"},{\"name\":\"_duration\",\"type\":\"uint64\"},{\"name\":\"_seller\",\"type\":\"address\"}],\"name\":\"CreateSaleAvgPrice\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetId\",\"type\":\"uint256\"}],\"name\":\"getSale\",\"outputs\":[{\"name\":\"seller\",\"type\":\"address\"},{\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"name\":\"duration\",\"type\":\"uint256\"},{\"name\":\"startedAt\",\"type\":\"uint256\"},{\"name\":\"isActive\",\"type\":\"bool\"},{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"tokenId\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_assetType\",\"type\":\"uint256\"}],\"name\":\"BuyCurrentTypeOfAsset\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"avgSalesToCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"bankManager\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"managerSecondary\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"\",\"type\":\"address\"},{\"name\":\"\",\"type\":\"uint256\"},{\"name\":\"\",\"type\":\"bytes\"}],\"name\":\"onERC721Received\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes4\"}],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_newBK\",\"type\":\"address\"}],\"name\":\"setBanker\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_assetType\",\"type\":\"uint256\"}],\"name\":\"GetCurrentTypeSaleCount\",\"outputs\":[{\"name\":\"_count\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"owner\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"collectibleId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"buyingPrice\",\"type\":\"uint256\"}],\"name\":\"SaleWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"tokenID\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"endingPrice\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"duration\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"startedAt\",\"type\":\"uint64\"}],\"name\":\"SaleCreated\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"seller\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"collectibleId\",\"type\":\"uint256\"}],\"name\":\"SaleCancelled\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"newContract\",\"type\":\"address\"}],\"name\":\"ContractUpgrade\",\"type\":\"event\"}]","ContractName":"CSCTimeSaleManager","CompilerVersion":"v0.4.23+commit.124ca40d","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://3d5aae27dc7d0feda7a01108025692ad2d35e454dddbb296b6f937018d56f12e"}]}