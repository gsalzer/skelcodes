{"status":"1","message":"OK","result":[{"SourceCode":"pragma solidity ^0.4.25;\r\n\r\ncontract P3Daily {\r\n    \r\n    using SafeMath for uint256;\r\n    \r\n    struct Round {\r\n        uint256 pot;\r\n        uint256 ticketsSold;\r\n        uint256 blockNumber;\r\n        uint256 startTime;\r\n        mapping(uint256 => address) tickets;\r\n        mapping(address => uint256) ticketsPerAddress;\r\n    }\r\n    \r\n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\r\n    address constant sacMasternode = address(0x4fac33dAbFd83d160717dFee4175d9cAaA249CA5);\r\n    address constant dev = address(0xF0EA6CE7d210Ee58e83a463Af13989B5c2DbE108);\r\n    \r\n    uint256 constant public PRICE_PER_TICKET = 0.01 ether;\r\n    uint256 constant public ROUND_LENGTH = 24 hours;\r\n    \r\n    mapping(uint256 => Round) public rounds;\r\n    mapping(address => uint256) private vault;\r\n    \r\n    uint256 public currentRoundNumber;\r\n    \r\n    event TicketsPurchased(address indexed player, uint256 indexed amount);\r\n    event LotteryWinner(address indexed winner, uint256 indexed winnings, uint256 indexed ticket);\r\n    event WithdrawVault(address indexed player, uint256 indexed amaount);\r\n    event Validator(address indexed validator, uint256 indexed reward);\r\n    \r\n    modifier isValidPurchase(uint256 _howMany)\r\n    {\r\n        require(_howMany > 0);\r\n        require(msg.value == _howMany.mul(PRICE_PER_TICKET));\r\n        _;\r\n    }\r\n    \r\n    modifier canPayFromVault(uint256 _howMany)\r\n    {\r\n        require(_howMany > 0);\r\n        require(vault[msg.sender] >= _howMany.mul(PRICE_PER_TICKET));\r\n        _;\r\n    }\r\n    \r\n    modifier positiveVaultBalance()\r\n    {\r\n        require(vault[msg.sender] > 0);\r\n        _;\r\n    }\r\n    \r\n    constructor()\r\n        public\r\n    {\r\n        currentRoundNumber = 0;\r\n        rounds[currentRoundNumber] = Round(0, 0, 0, now);\r\n    }\r\n    \r\n    function() external payable {}\r\n       \r\n    function isRoundOver()\r\n        public\r\n        view\r\n        returns(bool)\r\n    {\r\n        return now >= rounds[currentRoundNumber].startTime.add(ROUND_LENGTH);\r\n    }\r\n    \r\n    function potentialWinner()\r\n        external\r\n        view\r\n        returns(address)\r\n    {\r\n        if(isRoundOver() &&\r\n        rounds[currentRoundNumber].blockNumber != 0 &&\r\n        block.number - 256 <= rounds[currentRoundNumber].blockNumber &&\r\n        rounds[currentRoundNumber].blockNumber != block.number) {\r\n            uint256 potentialwinningTicket = uint256(blockhash(rounds[currentRoundNumber].blockNumber)) % rounds[currentRoundNumber].ticketsSold;\r\n            return rounds[currentRoundNumber].tickets[potentialwinningTicket];\r\n        }\r\n        \r\n        return address(0);\r\n    }\r\n    \r\n    function blocksUntilNewPotentialWinner()\r\n        external\r\n        view\r\n        returns (uint256)\r\n    {\r\n        if(isRoundOver() &&\r\n        rounds[currentRoundNumber].blockNumber != 0 &&\r\n        block.number - 256 <= rounds[currentRoundNumber].blockNumber &&\r\n        rounds[currentRoundNumber].blockNumber != block.number) {\r\n           return 256 - (block.number - rounds[currentRoundNumber].blockNumber);\r\n        }\r\n        \r\n        return 0;\r\n    }\r\n    \r\n    function getTicketOwner(uint256 _number)\r\n        external\r\n        view\r\n        returns(address)\r\n    {\r\n        return rounds[currentRoundNumber].tickets[_number];\r\n    }\r\n    \r\n     function ticketsPurchased()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return rounds[currentRoundNumber].ticketsSold;\r\n    }\r\n    \r\n    function timeLeft()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        if(isRoundOver()) {\r\n            return 0;\r\n        }\r\n        \r\n        return ROUND_LENGTH.sub(now.sub(rounds[currentRoundNumber].startTime));\r\n    }\r\n    \r\n    function jackpotSize()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return rounds[currentRoundNumber].pot.add(p3dContract.myDividends(true)).mul(97) / 100;\r\n    }\r\n    \r\n    function validatorReward()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return rounds[currentRoundNumber].pot.add(p3dContract.myDividends(true)) / 100;\r\n    }\r\n    \r\n    function myVault()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return vault[msg.sender];\r\n    }\r\n    \r\n    function myTickets()\r\n        external\r\n        view\r\n        returns(uint256)\r\n    {\r\n        return rounds[currentRoundNumber].ticketsPerAddress[msg.sender];\r\n    }\r\n    \r\n    function purchaseTicket(uint256 _howMany)\r\n        external\r\n        payable\r\n        isValidPurchase(_howMany)\r\n    {\r\n        if(!isRoundOver() || onRoundEnd()) {\r\n            acceptPurchase(_howMany, msg.value);\r\n        } else {\r\n            vault[msg.sender] = vault[msg.sender].add(msg.value);\r\n        }\r\n    }\r\n    \r\n    function purchaseFromVault(uint256 _howMany)\r\n        external\r\n        canPayFromVault(_howMany)\r\n    {\r\n        if(!isRoundOver() || onRoundEnd()) {\r\n            uint256 value = _howMany.mul(PRICE_PER_TICKET);\r\n            vault[msg.sender] -= value;\r\n            acceptPurchase(_howMany, value);\r\n        }\r\n    }\r\n    \r\n    function validate()\r\n        external\r\n    {\r\n        require(isRoundOver());\r\n        \r\n        onRoundEnd();\r\n    }\r\n    \r\n    function withdrawFromVault()\r\n        external\r\n        positiveVaultBalance\r\n    {\r\n        uint256 amount = vault[msg.sender];\r\n        vault[msg.sender] = 0;\r\n        \r\n        emit WithdrawVault(msg.sender, amount);\r\n        \r\n        msg.sender.transfer(amount);\r\n    }\r\n    \r\n    function onRoundEnd()\r\n        private\r\n        returns(bool newRound)\r\n    {\r\n        //no tickets sold => create new round\r\n        if(rounds[currentRoundNumber].ticketsSold == 0) {\r\n            currentRoundNumber++;\r\n            rounds[currentRoundNumber] = Round(0, 0, 0, now);\r\n            return true;\r\n        }\r\n        \r\n        //blocknumber has not been chosen or is too old => set new one\r\n        if(rounds[currentRoundNumber].blockNumber == 0 || block.number - 256 > rounds[currentRoundNumber].blockNumber) {\r\n            rounds[currentRoundNumber].blockNumber = block.number;\r\n            return false;\r\n        }\r\n        \r\n        //can't determine hash of current block\r\n        if(block.number == rounds[currentRoundNumber].blockNumber) {return false;}\r\n        \r\n        //determine winner\r\n        uint256 winningTicket = uint256(blockhash(rounds[currentRoundNumber].blockNumber)) % rounds[currentRoundNumber].ticketsSold;\r\n        address winner = rounds[currentRoundNumber].tickets[winningTicket];\r\n        \r\n        uint256 totalWinnings = rounds[currentRoundNumber].pot;\r\n        \r\n        uint256 dividends = p3dContract.myDividends(true);\r\n        if(dividends > 0) {\r\n            p3dContract.withdraw();\r\n            totalWinnings = totalWinnings.add(dividends);\r\n        }\r\n        \r\n        //winner reward\r\n        uint256 winnings = totalWinnings.mul(97) / 100;\r\n        vault[winner] = vault[winner].add(winnings);\r\n        emit LotteryWinner(winner, winnings, winningTicket);\r\n        \r\n        //validator reward\r\n        vault[msg.sender] = vault[msg.sender].add(totalWinnings / 100);\r\n        emit Validator(msg.sender, totalWinnings / 100);\r\n        \r\n        //dev fee\r\n        vault[dev] = vault[dev].add(totalWinnings.mul(2) / 100);\r\n        \r\n        currentRoundNumber++;\r\n        rounds[currentRoundNumber] = Round(0, 0, 0, now);\r\n        return true;\r\n    }\r\n    \r\n    function acceptPurchase(uint256 _howMany, uint256 value)\r\n        private\r\n    {\r\n        uint256 ticketsSold = rounds[currentRoundNumber].ticketsSold;\r\n        uint256 boundary = _howMany.add(ticketsSold);\r\n        \r\n        for(uint256 i = ticketsSold; i < boundary; i++) {\r\n            rounds[currentRoundNumber].tickets[i] = msg.sender;\r\n        }\r\n        \r\n        rounds[currentRoundNumber].ticketsSold = boundary;\r\n        rounds[currentRoundNumber].pot = rounds[currentRoundNumber].pot.add(value.mul(60) / 100);\r\n        rounds[currentRoundNumber].ticketsPerAddress[msg.sender] = rounds[currentRoundNumber].ticketsPerAddress[msg.sender].add(_howMany);\r\n        \r\n        emit TicketsPurchased(msg.sender, _howMany);\r\n        \r\n        p3dContract.buy.value(value.mul(40) / 100)(sacMasternode);\r\n    }\r\n}\r\n\r\ninterface HourglassInterface {\r\n    function buy(address _playerAddress) payable external returns(uint256);\r\n    function withdraw() external;\r\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\r\n}\r\n\r\nlibrary SafeMath {\r\n\r\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    if (a == 0) {\r\n      return 0;\r\n    }\r\n\r\n    uint256 c = a * b;\r\n    require(c / a == b);\r\n\r\n    return c;\r\n  }\r\n\r\n  function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    require(b <= a);\r\n    uint256 c = a - b;\r\n\r\n    return c;\r\n  }\r\n\r\n  function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n    uint256 c = a + b;\r\n    require(c >= a);\r\n\r\n    return c;\r\n  }\r\n}","ABI":"[{\"constant\":true,\"inputs\":[],\"name\":\"myTickets\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFromVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"timeLeft\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"isRoundOver\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"potentialWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"jackpotSize\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"validate\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"PRICE_PER_TICKET\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"validatorReward\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"rounds\",\"outputs\":[{\"name\":\"pot\",\"type\":\"uint256\"},{\"name\":\"ticketsSold\",\"type\":\"uint256\"},{\"name\":\"blockNumber\",\"type\":\"uint256\"},{\"name\":\"startTime\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ticketsPurchased\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"currentRoundNumber\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ROUND_LENGTH\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"myVault\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"_number\",\"type\":\"uint256\"}],\"name\":\"getTicketOwner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_howMany\",\"type\":\"uint256\"}],\"name\":\"purchaseTicket\",\"outputs\":[],\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"blocksUntilNewPotentialWinner\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"stateMutability\":\"view\",\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_howMany\",\"type\":\"uint256\"}],\"name\":\"purchaseFromVault\",\"outputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"payable\":false,\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"payable\":true,\"stateMutability\":\"payable\",\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amount\",\"type\":\"uint256\"}],\"name\":\"TicketsPurchased\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"winner\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"winnings\",\"type\":\"uint256\"},{\"indexed\":true,\"name\":\"ticket\",\"type\":\"uint256\"}],\"name\":\"LotteryWinner\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"player\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"amaount\",\"type\":\"uint256\"}],\"name\":\"WithdrawVault\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"validator\",\"type\":\"address\"},{\"indexed\":true,\"name\":\"reward\",\"type\":\"uint256\"}],\"name\":\"Validator\",\"type\":\"event\"}]","ContractName":"P3Daily","CompilerVersion":"v0.4.25+commit.59dbf8f1","OptimizationUsed":"1","Runs":"200","ConstructorArguments":"","Library":"","SwarmSource":"bzzr://64439cba06fda756fb68520fabd9c5440b76b6f73cc4e2c5d0fc04ad1c4fe949"}]}